{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","fish-topo-bo.js","webpack:/webpack/bootstrap d999bf11626ecda66fa4","webpack:///index.bo.js","webpack:///lib/fish-topo-bo/lib/FishTopoBo.js","webpack:///~/zrender/lib/zrender.js","webpack:///~/zrender/lib/core/guid.js","webpack:///~/zrender/lib/core/env.js","webpack:///~/zrender/lib/core/util.js","webpack:///~/zrender/lib/Handler.js","webpack:///~/zrender/lib/mixin/Draggable.js","webpack:///~/zrender/lib/mixin/Eventful.js","webpack:///~/zrender/lib/Storage.js","webpack:///~/zrender/lib/container/Group.js","webpack:///~/zrender/lib/Element.js","webpack:///~/zrender/lib/mixin/Transformable.js","webpack:///~/zrender/lib/core/matrix.js","webpack:///~/zrender/lib/core/vector.js","webpack:///~/zrender/lib/mixin/Animatable.js","webpack:///~/zrender/lib/animation/Animator.js","webpack:///~/zrender/lib/animation/Clip.js","webpack:///~/zrender/lib/animation/easing.js","webpack:///~/zrender/lib/tool/color.js","webpack:///~/zrender/lib/core/LRU.js","webpack:///~/zrender/lib/core/log.js","webpack:///~/zrender/lib/config.js","webpack:///~/zrender/lib/core/BoundingRect.js","webpack:///~/zrender/lib/core/timsort.js","webpack:///~/zrender/lib/animation/Animation.js","webpack:///~/zrender/lib/core/event.js","webpack:///~/zrender/lib/animation/requestAnimationFrame.js","webpack:///~/zrender/lib/dom/HandlerProxy.js","webpack:///~/zrender/lib/core/GestureMgr.js","webpack:///~/zrender/lib/Painter.js","webpack:///~/zrender/lib/Layer.js","webpack:///~/zrender/lib/graphic/Style.js","webpack:///~/zrender/lib/graphic/Pattern.js","webpack:///~/zrender/lib/graphic/Image.js","webpack:///~/zrender/lib/graphic/Displayable.js","webpack:///~/zrender/lib/graphic/mixin/RectText.js","webpack:///~/zrender/lib/contain/text.js","webpack:///lib/fish-topo-bo/lib/node/BoNode.js","webpack:///lib/fish-topo-bo/lib/models/Const.js","webpack:///lib/fish-topo-bo/lib/node/BoName.js","webpack:///lib/fish-topo-core/lib/graphic.js","webpack:///~/zrender/lib/tool/path.js","webpack:///~/zrender/lib/graphic/Path.js","webpack:///~/zrender/lib/core/PathProxy.js","webpack:///~/zrender/lib/core/curve.js","webpack:///~/zrender/lib/core/bbox.js","webpack:///~/zrender/lib/contain/path.js","webpack:///~/zrender/lib/contain/line.js","webpack:///~/zrender/lib/contain/cubic.js","webpack:///~/zrender/lib/contain/quadratic.js","webpack:///~/zrender/lib/contain/arc.js","webpack:///~/zrender/lib/contain/util.js","webpack:///~/zrender/lib/contain/windingLine.js","webpack:///~/zrender/lib/tool/transformPath.js","webpack:///~/zrender/lib/graphic/Gradient.js","webpack:///~/zrender/lib/graphic/Text.js","webpack:///~/zrender/lib/graphic/shape/Circle.js","webpack:///~/zrender/lib/graphic/shape/Sector.js","webpack:///~/zrender/lib/graphic/shape/Ring.js","webpack:///~/zrender/lib/graphic/shape/Polygon.js","webpack:///~/zrender/lib/graphic/helper/poly.js","webpack:///~/zrender/lib/graphic/helper/smoothSpline.js","webpack:///~/zrender/lib/graphic/helper/smoothBezier.js","webpack:///~/zrender/lib/graphic/shape/Polyline.js","webpack:///~/zrender/lib/graphic/shape/Rect.js","webpack:///~/zrender/lib/graphic/helper/roundRect.js","webpack:///~/zrender/lib/graphic/shape/Line.js","webpack:///~/zrender/lib/graphic/shape/BezierCurve.js","webpack:///~/zrender/lib/graphic/shape/Arc.js","webpack:///~/zrender/lib/graphic/LinearGradient.js","webpack:///~/zrender/lib/graphic/RadialGradient.js","webpack:///lib/fish-topo-bo/lib/node/EventDecisionNode.js","webpack:///lib/fish-topo-bo/lib/node/LineNode.js","webpack:///lib/fish-topo-bo/lib/node/BoAttrNode.js","webpack:///lib/fish-topo-bo/lib/node/Relation.js","webpack:///~/zrender/lib/vml/vml.js","webpack:///~/zrender/lib/vml/graphic.js","webpack:///~/zrender/lib/vml/core.js","webpack:///~/zrender/lib/vml/Painter.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","FishTopoBo","dom","opts","nowZoom","canScale","_zr","zr","init","renderer","devicePixelRatio","util","BoNode","Relation","Const","graphic","eventTool","fishTopoProto","prototype","group","Group","groupDrag","add","zrScale","resize","addBo","boData","_setParent","layout","x","startPos","y","level","_bfs","_moveRightByParent","boNode","getShape","addChildBo","child","childCnt","length","childBoArr","i","parent","next","_levelMaxPos","_queue","push","tmp","shift","BO_NODE_WIDTH","_moveRightByChild","BO_NODE_OFFSET_X","width","moved","_moveRightByPrevious","parentBoNode","boNodeHeight","getBoundingRect","height","getLayout","BO_NODE_OFFSET_Y","getData","relationNode","relation","_relationLen","j","sourceId","targetId","sourceText","targetText","childOfName","setCurrentBo","boId","style","childCount","childAt","name","setCurrent","clear","type","zoom","zoomDelta","zoomX","zoomY","that","target","pos","position","scale","newZoom","_zoom","zoomScale","attr","getWidth","getHeight","on","e","stop","event","wheelDelta","offsetX","offsetY","groupDragFunction","moveDrag","gx","gy","min","max","sX","clientX","startX","sY","clientY","startY","nowGroupPosition","groupPositionX","groupPositionY","endDrag","off","moveFunction","upFunction","cancelBubble","drag","node","GroupNode","nodeMessage","shape","nodeXY","movePosition","moveX","moveY","groupNode","reDraw","alarm","newAlarmPosition","ConnectionManager","refreshLineByNode","layoutNode","forceLayoutOption","nodes","allNodes","_","indexOf","alarmPositionX","alarmPositionY","isdraggable","idBase","Date","instances","DOM_ATTRIBUTE_KEY","fishTopoBo","version","dependencies","zrender","Error","defaults","showGridLine","gridLineSpacing","setAttribute","getInstanceByDom","key","getAttribute","dispose","chart","topo","zrUtil","isDom","isDisposed","delInstance","guid","env","Handler","Storage","Animation","HandlerProxy","useVML","canvasSupported","painterCtors","canvas","ZRender","hasOwnProperty","getInstance","registerPainter","Ctor","self","storage","rendererType","vml","painter","handerProxy","getViewportRoot","handler","animation","stage","update","bind","flush","start","_needsRefresh","oldDelFromMap","delFromMap","oldAddToMap","addToMap","elId","el","get","removeSelfFromZr","addSelfToZr","constructor","getId","addRoot","remove","delRoot","configLayer","zLevel","config","refreshImmediately","refresh","_needsRefreshHover","refreshHoverImmediately","addHover","refreshHover","removeHover","clearHover","clearAnimation","pathToImage","dpr","setCursorStyle","cursorStyle","eventName","eventHandler","context","trigger","idStart","detect","ua","os","browser","firefox","match","ie","edge","weChat","test","document","createElement","getContext","touchEventsSupported","window","pointerEventsSupported","navigator","userAgent","clone","source","result","typeStr","objToString","len","TYPED_ARRAY","from","BUILTIN_OBJECT","isPrimitive","merge","overwrite","isObject","targetProp","sourceProp","isArray","isBuiltInObject","mergeAll","targetAndSources","extend","overlay","createCanvas","_ctx","array","value","inherits","clazz","baseClazz","F","clazzPrototype","prop","superClass","mixin","isArrayLike","data","each","obj","cb","forEach","nativeForEach","map","nativeMap","reduce","memo","nativeReduce","filter","nativeFilter","find","func","args","nativeSlice","arguments","apply","concat","curry","isFunction","isString","nodeType","ownerDocument","eqNaN","retrieve","values","slice","Function","assert","condition","message","setAsPrimitive","primitiveKey","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","Object","toString","arrayProto","Array","noop","makeEventPacket","eveType","zrX","zrY","gestureEvent","pinchX","pinchY","pinchScale","zrDelta","zrByTouch","EmptyProxy","isHover","displayable","rectHover","silent","clipPath","contain","Draggable","Eventful","handlerNames","proxy","painterRoot","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","hovered","findHover","lastHovered","setCursor","cursor","__zr","dispatchToElement","mouseout","innerDom","element","toElement","relatedTarget","parentNode","dispatch","eventArgs","targetEl","eventPacket","eachOtherLayer","layer","exclude","list","getDisplayList","ignore","_downel","_upel","_dragStart","_drag","_dragEnd","draggingTarget","draggable","_draggingTarget","dragging","_x","_y","dx","dy","drift","dropTarget","lastDropTarget","_dropTarget","arrySlice","_$handlers","one","_h","h","ctx","isSilent","newList","l","argLen","splice","triggerWithContext","shapeCompareFunc","a","b","zlevel","z","z2","timsort","_elements","_roots","_displayList","_displayListLen","traverse","includeIgnore","updateDisplayList","roots","displayList","_updateAndAddDisplayable","clipPaths","beforeUpdate","__dirty","afterUpdate","userSetClipPath","currentClipPath","parentClipPath","updateTransform","isGroup","children","_children","__clipPaths","addChildrenToStorage","delChildrenFromStorage","idx","__storage","dirty","elements","_renderList","displayableSortFunc","Element","BoundingRect","_doAdd","addBefore","nextSibling","removeAll","eachChild","includeChildren","rect","tmpRect","tmpMat","invisible","childRect","transform","getLocalTransform","copy","applyTransform","union","Transformable","Animatable","decomposeTransform","attrKV","hide","show","setClipPath","removeClipPath","__clipTarget","animators","addAnimator","removeAnimator","isNotAroundZero","val","EPSILON","matrix","vector","mIdentity","identity","rotation","origin","transformableProto","needLocalTransform","parentHasTransform","create","mul","invTransform","invert","rotate","setTransform","restoreTransform","tmpTransform","sx","sy","Math","sqrt","atan2","getGlobalScale","transformCoordToLocal","v2","transformCoordToGlobal","ArrayCtor","Float32Array","out","m1","m2","out0","out1","out2","out3","out4","out5","translate","v","rad","aa","ac","atx","ab","ad","aty","st","sin","ct","cos","vx","vy","det","set","v1","scaleAndAdd","sub","lenSquare","div","dot","s","normalize","d","distance","distanceSquare","negate","lerp","t","lengthSquare","dist","distSquare","Animator","log","animate","path","loop","animatingShape","pathSplitted","split","animator","during","done","stopAnimation","forwardToLast","animateTo","time","delay","easing","callback","count","_animateToShallow","objShallow","propertyCount","props","when","defaultGetter","defaultSetter","interpolateNumber","p0","p1","percent","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isNaN","isArraySame","catmullRomInterpolateArray","p2","p3","t2","t3","catmullRomInterpolate","v0","cloneValue","ret","rgba2String","rgba","floor","join","createTrackClip","oneTrackDone","keyframes","propName","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","sort","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","color","parse","lastValue","_target","w","lastFrame","lastFramePercent","onframe","frame","range","clip","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","pause","_paused","resume","isPaused","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","clipList","removeClip","getClips","options","_life","_initialized","gap","onrestart","_pausedTime","easingFuncs","step","globalTime","deltaTime","_startTime","easingFunc","schedule","fire","restart","_needsRemove","remainder","eventType","arg","linear","k","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","PI","sinusoidalOut","sinusoidalInOut","exponentialIn","pow","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","clampCssByte","round","clampCssAngle","clampCssFloat","f","parseCssInt","str","charAt","parseFloat","parseInt","parseCssFloat","cssHueToRgb","setRgba","r","g","copyRgba","putToCache","colorStr","rgbaArr","lastRemovedArr","colorCache","put","cached","replace","toLowerCase","kCSSColorTable","op","ep","fname","substr","params","alpha","pop","hsla2rgba","iv","hsla","rgba2hsla","H","S","R","G","B","vMin","vMax","delta","L","deltaR","deltaG","deltaB","lift","colorArr","stringify","toHex","fastMapToColor","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","LRU","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","LinkedList","head","tail","_len","linkedListProto","insert","entry","Entry","insertEntry","prev","maxSize","_list","_map","_maxSize","_lastRemovedEntry","LRUProto","removed","leastUsedEntry","debugMode","console","vec2","v2ApplyTransform","mathMin","mathMax","other","lt","rb","lb","rt","maxX","maxY","calculateTransform","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","minRunLength","n","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","mid","pivot","left","right","gallopLeft","hint","lastOffset","maxOffset","offset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","Dispatcher","requestAnimationFrame","_clips","_running","_time","_pauseStart","clips","_update","getTime","deferredEvents","deferredClips","_startLoop","getBoundingClientRect","top","clientToLocal","calculate","defaultGetZrXY","layerX","layerY","box","normalizeEvent","isTouch","touch","targetTouches","changedTouches","detail","addEventListener","isDomLevel2","attachEvent","removeEventListener","detachEvent","preventDefault","stopPropagation","returnValue","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","setTimeout","eventNameFix","processGesture","gestureMgr","_gestureMgr","gestureInfo","recognize","setTouchTimer","instance","_touching","clearTimeout","_touchTimer","isPointerFromTouch","pointerType","initDomHandler","makeMouseHandler","fn","touchHandlerNames","_handlers","domHandlers","pointerHandlerNames","mouseHandlerNames","HandlerDomProxy","mountHandlers","GestureMgr","TOUCH_CLICK_DELAY","pointerEventNames","pointerdown","pointerup","pointermove","pointerout","nm","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","pointPair","center","eventUtil","_track","_doTrack","_recognize","touches","trackItem","points","recognizers","pinch","track","pinchEnd","pinchPre","isFinite","pinchCenter","parseInt10","isLayerValid","__builtin__","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","beginPath","buildPath","createRoot","domRoot","cssText","Layer","MAX_PROGRESSIVE_LAYER_NUMBER","Painter","singleCanvas","nodeName","toUpperCase","_opts","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","initContext","_domRoot","_getSize","appendChild","_progressiveLayers","_hoverlayer","_hoverElements","isSingleCanvas","paintAll","_paintList","_startProgessive","hoverStyle","__hoverMir","elMirror","__from","setStyle","hoverElements","hoverLayer","getLayer","scope","save","originalEl","_doPaintEl","restore","token","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuiltinLayer","flushProgressiveLayer","globalAlpha","shadowBlur","currentLayer","drawImage","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","opacity","culling","prevClipLayer","prevElClipPaths","prevEl","beforeBrush","brush","afterBrush","insertLayer","layersMap","prevLayer","virtual","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","elCount","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","progressive","_clearLayer","layerConfig","delLayer","removeChild","display","clearLayer","getRenderedCanvas","imageLayer","pixelRatio","clearColor","backgroundColor","whIdx","wh","cwh","plt","prb","stl","defaultView","getComputedStyle","shadowBlurSize","shadowOffsetX","shadowOffsetY","lineWidth","hasStroke","leftMargin","rightMargin","topMargin","bottomMargin","clearRect","pathTransform","ImageShape","imgShape","image","returnFalse","createDom","newDom","newDomStyle","Style","Pattern","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","createBackBuffer","clearAll","haveMotionBLur","globalCompositeOperation","clearColorGradientOrPattern","colorStops","__canvasGradient","getGradient","getCanvasPattern","fillStyle","fillRect","createLinearGradient","x2","y2","global","canvasGradient","createRadialGradient","STYLE_COMMON_PROPS","extendFrom","fill","stroke","lineDash","lineDashOffset","strokeNoScale","text","textFill","textStroke","textPosition","textOffset","textBaseline","textAlign","textVerticalAlign","textDistance","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","textRotation","blend","prevStyle","firstDraw","styleName","strokeStyle","getLineScale","hasFill","otherStyle","newStyle","method","addColorStop","styleProto","repeat","_canvasPattern","createPattern","ZImage","Displayable","globalImageCache","src","_image","cachedImgObj","Image","onload","pending","aspect","sWidth","sHeight","drawRectText","_rect","RectText","rectContain","coord","animateStyle","useStyle","parsePercent","maxValue","lastIndexOf","textContain","textRect","align","font","textFont","baseline","verticalAlign","lineHeight","res","adjustTextPositionOnRect","shadowColor","textShadowColor","textLines","strokeText","fillText","getTextWidth","textWidthCache","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getTextRect","textLineLen","textHeight","halfHeight","truncateText","containerWidth","ellipsis","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","BO","_data","viewOption","fish","_oriStartPos","_nextStartPos","_displayAttrDataType","displayAttrDataType","_displayAttrEvent","displayAttrEvent","_boClickable","boClickable","_boPopupOpts","boPopupOpts","_boEventClickable","boEventClickable","_boEventPopupOpts","boEventPopupOpts","_attrEventClickable","attrEventClickable","_attrEventPopupOpts","attrEventPopupOpts","_isCurrent","isCurrent","_boShapeHeight","_group","_boShape","_render","BoName","EventDecision","Line","BoAttr","boProto","_createBoName","_createEventDecision","_createBoAttr","_createBoShape","_boNameShape","clickable","onclick","_click","_calNextShapeStartPos","boEventArr","_eventShape","_boEventArr","_boEventLen","_eventOpts","popupOpts","boAttrArr","_boAttrShape","_lineShape","_boAttrArr","_boAttrLen","_attrEventStartPos","BoLine","AttrLine","displayDataType","displayEventDecision","eventClickable","eventPopupOpts","AttrEventLine","curShape","BO_NODE_DEFAULT_HEIGHT","Rect","brushType","lineCape","DATA","popupView","BO_NAME_FONT","BO_NAME_PADDING_TOP","BO_NAME_PADDING_BOTTOM","BO_EVENT_HEIGHT","BO_EVENT_WIDTH","BO_EVENT_FONT","BO_ATTR_FONT","BO_ATTR_PADDING_TOP","BO_ATTR_PADDING_BOTTOM","BO_ATTR_PADDING_LEFT","BO_ATTR_DATA_TYPE_PADDING_RIGHT","BO_ATTR_EVENT_WIDTH","LINE_DASH","RELATION_OFFSET","RELATION_ARROW_WIDTH","RELATION_ARROW_HEIGHT","RELATION_TEXT_OFFSET_X","RELATION_TEXT_OFFSET_Y","Text","doSingleEnterHover","__isHover","__hoverStlDirty","__hoverStl","colorTool","Gradient","normalStyle","__normalStl","doSingleLeaveHover","normalStl","doEnterHover","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","animatableModel","postfix","duration","getShallow","animationEasing","pathTool","Path","Util","Circle","Sector","Ring","Polygon","Polyline","BezierCurve","Arc","LinearGradient","RadialGradient","extendShape","extendPath","pathData","extendFromString","makePath","createFromString","boundingRect","cx","cy","resizePath","mergePath","pathRect","subPixelOptimizeLine","param","subPixelOptimize","x1","y1","subPixelOptimizeRect","originX","originY","originWidth","originHeight","positiveOrNegative","doubledPosition","setHoverStyle","setNormalStyle","setText","textStyle","labelModel","labelPosition","labelColor","textStyleModel","getModel","getFont","getTextColor","updateProps","initProps","getTransform","ancestor","mat","vertex","transformDirection","direction","hBase","abs","vBase","processArc","fa","fs","rx","ry","psiDeg","cmd","psi","xp","mathCos","mathSin","yp","lambda","mathSqrt","cxp","cyp","theta","vAngle","u","dTheta","vRatio","addData","createPathProxyFromString","cs","cc","RegExp","prevCmd","arr","cpx","cpy","PathProxy","CMD","ctlPtx","ctlPty","M","C","Q","A","Z","toStatic","createPathOptions","pathProxy","setData","transformPath","rebuildPath","vMag","acos","pathEls","pathList","pathEl","pathBundle","appendPath","pathContain","__dirtyPath","strokeContainThreshold","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","_fillGradient","_strokeGradient","ctxLineDash","setLineDash","setScale","setLineDashOffset","shapeCfg","inBundle","needsUpdateRect","rectWithStroke","_rectWithStroke","lineScale","localPos","containStroke","dirtyPath","animateShape","setShape","Sub","defaultShape","thisShape","curve","bbox","min2","max2","mathAbs","hasTypedArray","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","moveTo","lineTo","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","x3","y3","_dashedBezierTo","quadraticCurveTo","_dashedQuadraticTo","arc","startAngle","endAngle","anticlockwise","arcTo","radius","closePath","x0","y0","lineDashSum","appendSize","appendPathData","_expandData","_prevCmd","newData","dash","dashSum","nDash","cubicAt","bezierLen","tmpLen","Number","MAX_VALUE","xi","yi","fromLine","fromCubic","fromQuadratic","fromArc","ux","uy","scaleX","scaleY","isEllipse","isAroundZero","onet","cubicDerivativeAt","cubicRootAt","t1","disc","K","discSqrt","Y1","Y2","mathPow","ONE_THIRD","T","ASqrt","THREE_SQRT","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","d1","d2","interval","Infinity","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","v2Create","end","extremity","PI2","fromPoints","bottom","xDim","yDim","tx","ty","vec2Min","vec2Max","diff","angle","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","x_","windingQuadratic","y_","windingArc","dir","normalizeRadian","containPath","isStroke","windingLine","cubic","quadratic","line","_l","_a","_b","_s","nPoint","mathAtan2","shadowTemp","r0","clockwise","modified","unitX","unitY","polyHelper","smooth","smoothConstraint","smoothSpline","smoothBezier","controlPoints","cp1","cp2","interpolate","isLoop","segs","w2","w3","v2Min","v2Max","v2Scale","v2Distance","v2Add","constraint","prevPoint","nextPoint","cps","point","d0","sum","cp0","roundRectHelper","r1","r2","r3","r4","total","pointAt","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","curveTool","tangentAt","globalCoord","EventDecisionNode","_startPos","_type","_clickable","_popupOpts","eventProto","_createEventShape","_createEVentName","eventNameShape","endPos","_line","attrHeight","_style","strokeColor","boAttrData","_keyValue","keyValue","_displayDataType","_displayEventDecision","_eventClickable","_eventPopupOpts","boAttrProto","_createText","_createDataType","attrNameShape","_dataTypeShape","dataType","_boAttrEventArr","boAttrEventArr","_boAttrEventLen","padding","sourceShape","targetShape","_sourceText","_targetText","_lStartPos","_lEndPos","_rStartPos","_rEndPos","_leftDirection","relationProto","_createLine","_createArrow","_linePoints","_arrowPoints","_arrowShape","_sourceTextPos","_targetTextPos","_textAlign","_srcTextShape","_targetTextShape","vmlCore","comma","imageTransformPrefix","Z2","ZLEVEL_BASE","Z_BASE","initRootElStyle","coordsize","coordorigin","encodeHtmlAttribute","String","rgb2Str","append","getZIndex","setColorAndOpacity","getColorAndAlpha","updateFillNode","zrEl","gradientType","focus","expansion","rectWidth","rectHeight","dimension","stops","cs1","cs2","colorAndAlphaList","colorAndAlpha","color1","color2","opacity1","opacity2","focusposition","updateStrokeNode","dashstyle","updateFillAndStroke","vmlEl","isFill","getElementsByTagName","createNode","pathDataToString","cmdStr","brushVML","vmlRoot","_vmlEl","needTransform","strokeEl","weight","zIndex","removeRectText","onRemove","onAdd","appendRectText","isImage","img","tagName","ow","oh","_imageSrc","_imageWidth","_imageHeight","imageRuntimeStyle","runtimeStyle","oldRuntimeWidth","oldRuntimeHeight","dw","dh","sw","sh","hasCrop","doc","vmlElStyle","hasRotation","transformFilter","imageEl","_imageEl","cropEl","_cropEl","imageELStyle","tmpImage","overflow","cropElStyle","filterStr","textMeasureEl","DEFAULT_STYLE_NORMAL","fontStyleCache","fontStyleCacheCount","MAX_FONT_CACHE_SIZE","fontEl","getFontStyle","fontString","fontStyle","fontFamily","variant","fontVariant","fontWeight","size","fontSize","family","body","ex","createTextNode","offsetWidth","fromTextEl","textPathEl","skewEl","textVmlEl","_textVmlEl","textpathok","to","coords","textVmlElStyle","toFixed","string","proto","urn","win","vmlInited","namespaces","zrvml","initVML","styleSheets","createStyleSheet","addRule","VMLPainter","vmlViewport","_vmlRoot","_vmlViewport","_firstPaint","createMethodNotSupport","zrLog","__alreadyNotVisible","_getWidth","_getHeight","vmlViewportStyle","currentStyle","clientWidth","paddingLeft","paddingRight","clientHeight","paddingTop","paddingBottom","notSupportedMethods"],"mappings":"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","file":"fish-topo-bo.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoBo\"] = factory();\n\telse\n\t\troot[\"fishTopoBo\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoBo\"] = factory();\n\telse\n\t\troot[\"fishTopoBo\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Export fishTopo as CommonJS module\r\n\t */\r\n\tmodule.exports = __webpack_require__(2);\r\n\t//兼容IE8 引入VML 如果不需要兼容IE8请删除\r\n\t__webpack_require__(77);\r\n\t\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Created by majianan on 16/5/19.\r\n\t *\r\n\t */\r\n\t\r\n\t    var zr = __webpack_require__(3);\r\n\t    var util = __webpack_require__(6);\r\n\t    var BoNode = __webpack_require__(39);\r\n\t    var Relation = __webpack_require__(76);\r\n\t    var Const = __webpack_require__(40);\r\n\t    var graphic = __webpack_require__(42);\r\n\t    var eventTool = __webpack_require__(27);\r\n\t\r\n\t    function FishTopoBo(dom, opts) {\r\n\t        /**\r\n\t         * 缩放\r\n\t         * @type {number}\r\n\t         */\r\n\t        this.nowZoom = 1;\r\n\t        this.canScale = true;\r\n\t\r\n\t        /**\r\n\t         * 初始化zrender\r\n\t         */\r\n\t        this._zr = zr.init(dom, {\r\n\t            renderer: opts.renderer || 'canvas',\r\n\t            devicePixelRatio: opts.devicePixelRatio\r\n\t        });\r\n\t    }\r\n\t\r\n\t    var fishTopoProto = FishTopoBo.prototype;\r\n\t\r\n\t    /**\r\n\t     * 初始化\r\n\t     */\r\n\t    fishTopoProto.init = function () {\r\n\t        this.group = new graphic.Group();\r\n\t        this.groupDrag(this.group);\r\n\t        this._zr.add(this.group);\r\n\t        this.zrScale();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 调整尺寸  在窗口大小发生改变时需要手工调用\r\n\t     */\r\n\t    fishTopoProto.resize = function () {\r\n\t        this._zr.resize();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 添加BO\r\n\t     * @param {Object} boData, bo数据\r\n\t     * @param {{\r\n\t     *          startPos: {x: number, y: number} 起始位置,\r\n\t     *          displayAttrDataType: boolean 是否显示属性数据类型,\r\n\t     *          displayAttrEvent: boolean 是否显示属性事件决策,\r\n\t     *          boClickable: boolean BO是否支持点击事件, 可空 默认false\r\n\t     *          boPopupUrl: String 点击BO弹出页面地址\r\n\t     *          boEventClickable: boolean BO事件决策是否支持点击事件, 可空 默认false\r\n\t     *          boEventPopupUrl: String 点击BO事件决策弹出页面地址\r\n\t     *          attrEventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false\r\n\t     *          attrEventPopupUrl: String 点击BO属性事件决策弹出页面地址\r\n\t     *          isCurrent: boolean 是否为当前BO\r\n\t     *          }} opts\r\n\t     * @returns {*}\r\n\t     */\r\n\t    fishTopoProto.addBo = function (boData, opts) {\r\n\t        //设置BO父子关系，便于后续整体移动\r\n\t        this._setParent(boData);\r\n\t\r\n\t        //layout BO的布局信息，x,y左上角起始坐标, level:层级\r\n\t        boData.layout = {\r\n\t            x: opts.startPos.x,\r\n\t            y: opts.startPos.y,\r\n\t            level: 1\r\n\t        };\r\n\t\r\n\t        //计算BO的X坐标\r\n\t        this._bfs(boData);\r\n\t\r\n\t        //按照起始坐标整体左移\r\n\t        this._moveRightByParent(boData, opts.startPos.x - boData.layout.x);\r\n\t\r\n\t        //画BO\r\n\t        var boNode = new BoNode(boData, opts);\r\n\t        this.group.add(boNode.getShape());\r\n\t\r\n\t        //创建子BO\r\n\t        this.addChildBo(boNode, opts);\r\n\t\r\n\t        return boNode;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 设置BO的父子关系\r\n\t     * @param {Object} boData BO数据\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._setParent = function (boData) {\r\n\t        if (boData.child) {\r\n\t            var childCnt = boData.child.length,\r\n\t                childBoArr = boData.child;\r\n\t            for (var i = 0; i < childCnt; i++) {\r\n\t                childBoArr[i].parent = boData;\r\n\t                if (childBoArr[i + 1]) {\r\n\t                    childBoArr[i].next = childBoArr[i + 1];\r\n\t                }\r\n\t                //设置最后子节点的next=下一个父节点的第一个子节点\r\n\t                else if (boData.next && boData.next.child) {\r\n\t                    childBoArr[i].next = boData.next.child[0];\r\n\t                }\r\n\t                this._setParent(childBoArr[i]);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * Breadth-First-Search 计算X坐标\r\n\t     * 由于BO宽度定死，可以在画图之前计算每个BO的起始X坐标\r\n\t     * 每个BO的高度根据显示内容不固定，因此需要根据实际的父BO高度才能计算本身的起始Y坐标\r\n\t     * @param boData\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._bfs = function (boData) {\r\n\t        //用于保存每个level的最大坐标值\r\n\t        this._levelMaxPos = {};\r\n\t\r\n\t        this._queue = [];   //存放BO数据\r\n\t        this._queue.push(boData);\r\n\t\r\n\t        while (this._queue.length > 0) {\r\n\t            var tmp = this._queue.shift();\r\n\t            //console.log('BO[' + tmp.name + '] {x: ' + tmp.layout.x + ', level: ' + tmp.layout.level + '} ');\r\n\t            //console.log('    ***Before this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\t\r\n\t            //该level第一个节点\r\n\t            if (!this._levelMaxPos[tmp.layout.level]) {\r\n\t                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n\t            }\r\n\t            //当前就是最右侧的节点\r\n\t            else if (this._levelMaxPos[tmp.layout.level].x + Const.BO_NODE_WIDTH <= tmp.layout.x) {\r\n\t                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n\t            }\r\n\t            //当前节点与之前的节点有交叉，则需要连同父节点整体向右移动\r\n\t            else {\r\n\t                this._moveRightByChild(tmp, this._levelMaxPos[tmp.layout.level].x - tmp.layout.x + Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X)\r\n\t                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n\t            }\r\n\t\r\n\t            //console.log('    ***After this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\t\r\n\t            //存在子节点，计算子节点坐标，同时添加到队列中，以便后续计算调整x坐标\r\n\t            if (tmp.child) {\r\n\t                var childCnt = tmp.child.length;\r\n\t\r\n\t                for (var i = 0; i < childCnt; i++) {\r\n\t\r\n\t                    tmp.child[i].layout = {\r\n\t                        x: tmp.layout.x - (Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X) * ((childCnt - 1) / 2 - i),\r\n\t                        level: tmp.layout.level + 1\r\n\t                    };\r\n\t\r\n\t                    this._queue.push(tmp.child[i]);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 子节点右移时，同时下一个子节点，以及父节点都同时移动\r\n\t     * @param boData\r\n\t     * @param width\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._moveRightByChild = function (boData, width) {\r\n\t        if (boData) {\r\n\t\r\n\t            if (!boData.layout.moved) {\r\n\t\r\n\t                if (boData.layout.level == 1) {\r\n\t                    boData.layout.x += width / 2;\r\n\t                } else {\r\n\t                    boData.layout.x += width;\r\n\t                }\r\n\t\r\n\t                boData.layout.moved = true;\r\n\t            }\r\n\t            //当前节点的下一节点整体右移\r\n\t            this._moveRightByPrevious(boData.next, width);\r\n\t            //当前节点的父节点整体右移\r\n\t            this._moveRightByChild(boData.parent, width);\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 前一个节点右移的时候，所有后面的节点整体右移\r\n\t     * @param boData\r\n\t     * @param width\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._moveRightByPrevious = function (boData, width) {\r\n\t        if (boData) {\r\n\t            boData.layout.x += width;\r\n\t            //当前节点的所有后续节点整体右移\r\n\t            this._moveRightByPrevious(boData.next, width);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 父节点右移时，所有子节点整体右移\r\n\t     * @param boData\r\n\t     * @param width\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._moveRightByParent = function (boData, width) {\r\n\t        if (boData) {\r\n\t            boData.layout.x += width;\r\n\t            if (boData.child) {\r\n\t                for (var i = 0; i < boData.child.length; i++) {\r\n\t                    this._moveRightByParent(boData.child[i], width);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 添加子BO\r\n\t     * @param {BoNode} parentBoNode\r\n\t     * @param {Object} opts\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto.addChildBo = function (parentBoNode, opts) {\r\n\t\r\n\t        this._queue = []; //需要根据BO节点的实际高度计算自己点的起始Y坐标，因此存放的是BoNode图形\r\n\t        this._queue.push(parentBoNode);\r\n\t\r\n\t        while (this._queue.length > 0) {\r\n\t            var tmp = this._queue.shift(),\r\n\t                boNodeHeight = tmp.getShape().getBoundingRect().height;\r\n\t            //console.log('Parent BO[' + tmp.getData().name + '] {y: ' + tmp.getLayout().y + ', level: ' + tmp.getLayout().level + ', boNodeHeight:' + boNodeHeight + '} ');\r\n\t            //console.log('    ***Before this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\t\r\n\t            //如果是该Level第一个节点，或者当低于原来的节点\r\n\t            if (!this._levelMaxPos[tmp.getLayout().level].y ||\r\n\t                this._levelMaxPos[tmp.getLayout().level].y < tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y) {\r\n\t                this._levelMaxPos[tmp.getLayout().level].y = tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y;\r\n\t            }\r\n\t\r\n\t            //console.log('    ***After this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\t\r\n\t            if (tmp.getData().child) {\r\n\t\r\n\t                var childBoArr = tmp.getData().child,\r\n\t                    childCnt = childBoArr.length,\r\n\t                    boNode,\r\n\t                    relationNode;\r\n\t\r\n\t                //该level所有子节点的起始Y坐标都相同\r\n\t                opts.startPos.y = this._levelMaxPos[tmp.getLayout().level].y;\r\n\t                for (var i = 0; i < childCnt; i++) {\r\n\t                    opts.startPos.x = childBoArr[i].layout.x;\r\n\t                    childBoArr[i].layout.y = opts.startPos.y;\r\n\t                    boNode = new BoNode(childBoArr[i], opts);\r\n\t                    //console.log('Child BO[' + boNode.getData().name + '] {y: ' + opts.startPos.y + ', level: ' + boNode.getLayout().level + '} ');\r\n\t\r\n\t                    this.group.add(boNode.getShape());\r\n\t                    this._queue.push(boNode);\r\n\t\r\n\t                    //BO关系\r\n\t                    if (childBoArr[i].relation) {\r\n\t                        var _relationLen = childBoArr[i].relation.length;\r\n\t                        for (var j = 0; j < _relationLen; j++) {\r\n\t                            var sourceId = childBoArr[i].relation[j].sourceId,\r\n\t                                targetId = childBoArr[i].relation[j].targetId,\r\n\t                                sourceText = childBoArr[i].relation[j].sourceText,\r\n\t                                targetText = childBoArr[i].relation[j].targetText;\r\n\t\r\n\t                            relationNode = new Relation(\r\n\t                                boNode.getShape().childOfName(sourceId),\r\n\t                                tmp.getShape().childOfName(targetId),\r\n\t                                sourceText,\r\n\t                                targetText\r\n\t                            );\r\n\t                            this.group.add(relationNode.getShape());\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 设置当前BO为特殊样式\r\n\t     * @param {String} boId, BO标识\r\n\t     * @param {Object} style, BO特殊样式,可空\r\n\t     */\r\n\t    fishTopoProto.setCurrentBo = function (boId, style) {\r\n\t        var length = this.group.childCount();\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            if (this.group.childAt(i).name == boId) {\r\n\t                this.group.childAt(i).setCurrent(style);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 清空\r\n\t     */\r\n\t    fishTopoProto.clear = function () {\r\n\t        this._zr.clear();\r\n\t        this.group = new graphic.Group();\r\n\t        this._zr.add(this.group);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 缩放功能\r\n\t     * @param type\r\n\t     */\r\n\t    fishTopoProto.zrScale = function (type) {\r\n\t        var that = this;\r\n\t        if (type) {\r\n\t            if (type == \"narrowing\") {\r\n\t                var zoomDelta = 1 / 1.1;\r\n\t                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }\r\n\t            if (type == \"enlarge\") {\r\n\t                var zoomDelta = 1.1;\r\n\t                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }\r\n\t        } else {\r\n\t            that._zr.on('mousewheel', function (e) {\r\n\t                eventTool.stop(e.event);\r\n\t                var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\r\n\t                zoom(zoomDelta, e.offsetX, e.offsetY);\r\n\t            });\r\n\t        }\r\n\t        ;\r\n\t        function zoom(zoomDelta, zoomX, zoomY) {\r\n\t            if (that.canScale == false) {\r\n\t                return;\r\n\t            }\r\n\t            var target = that.group;\r\n\t            if (target) {\r\n\t                var pos = target.position;\r\n\t                var scale = target.scale;\r\n\t                var newZoom = that._zoom = that._zoom || 1;\r\n\t                newZoom *= zoomDelta;\r\n\t                var zoomScale = newZoom / that._zoom;\r\n\t                // if(newZoom>2.6||newZoom<0.38){\r\n\t                //     return;\r\n\t                // };\r\n\t                that._zoom = newZoom;\r\n\t\r\n\t                that.nowZoom = newZoom;\r\n\t                // Keep the mouse center when scaling\r\n\t                pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\r\n\t                pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\r\n\t                scale[0] *= zoomScale;\r\n\t                scale[1] *= zoomScale;\r\n\t                target.attr(\"position\", [pos[0], pos[1]]);\r\n\t                target.attr(\"scale\", [scale[0], scale[1]]);\r\n\t                //that.minimap.updateSelectionPosition(pos,zoomScale);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 拖拽Group\r\n\t     */\r\n\t    fishTopoProto.groupDrag = function () {\r\n\t        var that = this;\r\n\t        that._zr.on(\"mousedown\", function (e) {\r\n\t            groupDragFunction(e);\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t        function groupDragFunction(e) {\r\n\t            var startX = e.event.clientX;\r\n\t            var startY = e.event.clientY;\r\n\t            var moveFunction = function (e) {\r\n\t                moveDrag(e);\r\n\t            }\r\n\t            var nowGroupPosition = that.group.position;\r\n\t            var groupPositionX = that.group.position[0];\r\n\t            var groupPositionY = that.group.position[1];\r\n\t            var alarmPositionX, alarmPositionY;\r\n\t\r\n\t            function moveDrag(e) {\r\n\t                var width = that.group.getBoundingRect().width * that.nowZoom;\r\n\t                var height = that.group.getBoundingRect().height * that.nowZoom;\r\n\t                var gx = that.group.getBoundingRect().x * that.nowZoom;\r\n\t                var gy = that.group.getBoundingRect().y * that.nowZoom;\r\n\t                var min = [10 - (width + gx), 10 - (height + gy)];\r\n\t                var max = [(that._zr.getWidth() - gx) - 10, (that._zr.getHeight() - gy) - 10];\r\n\t                var sX = (e.event.clientX - startX) * (that.nowZoom);\r\n\t                var sY = (e.event.clientY - startY) * (that.nowZoom);\r\n\t                nowGroupPosition[0] = groupPositionX + (sX);\r\n\t                nowGroupPosition[1] = groupPositionY + (sY);\r\n\t                if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] < min[0] || nowGroupPosition[1] < min[1]) {\r\n\t                    return;\r\n\t                } else {\r\n\t                    that.group.attr(\"position\", nowGroupPosition);\r\n\t                }\r\n\t            }\r\n\t\r\n\t            that._zr.on('mousemove', moveFunction);\r\n\t            var upFunction = function (e) {\r\n\t                endDrag(e);\r\n\t            }\r\n\t\r\n\t            function endDrag(e) {\r\n\t                that._zr.off('mousemove', moveFunction);\r\n\t                that._zr.off('mouseup', upFunction);\r\n\t                that._zr.off(\"globalout\", upFunction);\r\n\t            }\r\n\t\r\n\t            that._zr.on('mouseup', upFunction);\r\n\t            that._zr.on(\"globalout\", upFunction);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 拖拽\r\n\t     * @param node\r\n\t     */\r\n\t    fishTopoProto.drag = function (node) {\r\n\t        var that = this;\r\n\t        node.on(\"mousedown\", function (e) {\r\n\t            if (this.isdraggable == false) {\r\n\t                return;\r\n\t            }\r\n\t            groupDragFunction(e);\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t        function groupDragFunction(e) {\r\n\t            var startX = e.event.clientX;\r\n\t            var startY = e.event.clientY;\r\n\t            var moveFunction = function (e) {\r\n\t                moveDrag(e);\r\n\t            }\r\n\t            var nowGroupPosition = node.position;\r\n\t            var groupPositionX = node.position[0];\r\n\t            var groupPositionY = node.position[1];\r\n\t            var alarmPositionX, alarmPositionY;\r\n\t            if (node.alarm) {\r\n\t                var newAlarmPosition = node.alarm.position;\r\n\t                alarmPositionX = node.alarm.position[0];\r\n\t                alarmPositionY = node.alarm.position[1];\r\n\t            }\r\n\t            ;\r\n\t            function moveDrag(e) {\r\n\t                var sX = (e.event.clientX - startX) / (that.nowZoom);\r\n\t                var sY = (e.event.clientY - startY) / (that.nowZoom);\r\n\t                if (node.parent && node.parent instanceof GroupNode) {\r\n\t                    //放入node现有数值，用于重绘group\r\n\t                    var nodeMessage = {\r\n\t                        width: node.shape.width,\r\n\t                        height: node.shape.height,\r\n\t                        position: node.position,\r\n\t                        nodeXY: [node.shape.x, node.shape.y],\r\n\t                        movePosition: [groupPositionX, groupPositionY],\r\n\t                        moveX: sX,\r\n\t                        moveY: sY\r\n\t                    };\r\n\t                    var groupNode = node.parent;\r\n\t                    groupNode.reDraw(nodeMessage, node);\r\n\t                } else {\r\n\t                    nowGroupPosition[0] = groupPositionX + (sX);\r\n\t                    nowGroupPosition[1] = groupPositionY + (sY);\r\n\t                    node.attr(\"position\", nowGroupPosition);\r\n\t                    if (node.alarm) {\r\n\t                        var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm.getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect().height - 3];\r\n\t                        node.alarm.attr(\"position\", newAlarmPosition);\r\n\t                    }\r\n\t                    ;\r\n\t                }\r\n\t                ConnectionManager.refreshLineByNode(node);\r\n\t            }\r\n\t\r\n\t            that._zr.on('mousemove', moveFunction);\r\n\t            var upFunction = function (e) {\r\n\t                endDrag(e);\r\n\t            }\r\n\t            //拖拽结束\r\n\t            function endDrag(e) {\r\n\t                that._zr.off('mousemove', moveFunction);\r\n\t                that._zr.off('mouseup', upFunction);\r\n\t                that._zr.off(\"globalout\", upFunction);\r\n\t                //布局重新计算\r\n\t                if (node.layout) {\r\n\t                    that.layoutNode(\"tree\", {\"node\": node});\r\n\t                }\r\n\t                if (that.forceLayoutOption) {\r\n\t                    var nodes = that.forceLayoutOption.allNodes;\r\n\t                    if (_.indexOf(nodes, node) != -1) {\r\n\t                        that.layoutNode(\"force\", this.forceLayoutOption);\r\n\t                    }\r\n\t                }\r\n\t                ;\r\n\t            }\r\n\t\r\n\t            that._zr.on('mouseup', upFunction);\r\n\t            that._zr.on(\"globalout\", upFunction);\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    // ---------对外暴露fishTopoBo------------------\r\n\t    var idBase = new Date() - 0;\r\n\t    var instances = {};\r\n\t    var DOM_ATTRIBUTE_KEY = '_fishTopoBo_instance_';\r\n\t    var fishTopoBo = {\r\n\t        /**\r\n\t         * @type {number}\r\n\t         */\r\n\t        version: '1.0.0',\r\n\t        dependencies: {\r\n\t            zrender: '3.0.4'\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param {HTMLDomElement} dom\r\n\t     * @param {Object} opts\r\n\t     */\r\n\t    fishTopoBo.init = function (dom, opts) {\r\n\t        if (!dom) {\r\n\t            throw new Error('Initialize failed: invalid dom.');\r\n\t        }\r\n\t\r\n\t        opts = opts || {};\r\n\t        // Default value\r\n\t        util.defaults(opts,\r\n\t            {\r\n\t                type: \"bpmn\",\r\n\t                showGridLine: true,\r\n\t                devicePixelRatio: 1,\r\n\t                gridLineSpacing:10\r\n\t            }\r\n\t        );\r\n\t\r\n\t        var fishTopoBo = new FishTopoBo(dom, opts);\r\n\t        fishTopoBo.init();\r\n\t\r\n\t        fishTopoBo.id = 'ft_' + idBase++;\r\n\t        instances[fishTopoBo.id] = fishTopoBo;\r\n\t\r\n\t        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoBo.id);\r\n\t\r\n\t        return fishTopoBo;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * @param  {HTMLDomElement} dom\r\n\t     * @return {fishTopo}\r\n\t     */\r\n\t    fishTopoBo.getInstanceByDom = function (dom) {\r\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n\t        return instances[key];\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Dispose a fishTopo instance\r\n\t     * @param  {module:fishTopo|HTMLDomElement|string} fishTopo\r\n\t     */\r\n\t    fishTopoBo.dispose = function (chart) {\r\n\t        var topo;\r\n\t        if (zrUtil.isDom(chart)) {\r\n\t            topo = fishTopoBo.getInstanceByDom(chart);\r\n\t        }\r\n\t        else if (typeof chart === 'string') {\r\n\t            topo = instances[chart];\r\n\t        }\r\n\t        if ((topo instanceof fishTopoBo) && !topo.isDisposed()) {\r\n\t            topo.dispose();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = fishTopoBo;\r\n\t\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * ZRender, a high performance 2d drawing library.\n\t *\n\t * Copyright (c) 2013, Baidu Inc.\n\t * All rights reserved.\n\t *\n\t * LICENSE\n\t * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n\t */\n\t// Global defines\n\t\n\t    var guid = __webpack_require__(4);\n\t    var env = __webpack_require__(5);\n\t    var zrUtil = __webpack_require__(6);\n\t\n\t    var Handler = __webpack_require__(7);\n\t    var Storage = __webpack_require__(10);\n\t    var Animation = __webpack_require__(26);\n\t    var HandlerProxy = __webpack_require__(29);\n\t\n\t    var useVML = !env.canvasSupported;\n\t\n\t    var painterCtors = {\n\t        canvas: __webpack_require__(31)\n\t    };\n\t\n\t    var instances = {};    // ZRender实例map索引\n\t\n\t    var zrender = {};\n\t\n\t    /**\n\t     * @type {string}\n\t     */\n\t    zrender.version = '3.4.1';\n\t\n\t    /**\n\t     * Initializing a zrender instance\n\t     * @param {HTMLElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.init = function(dom, opts) {\n\t        var zr = new ZRender(guid(), dom, opts);\n\t        instances[zr.id] = zr;\n\t        return zr;\n\t    };\n\t\n\t    /**\n\t     * Dispose zrender instance\n\t     * @param {module:zrender/ZRender} zr\n\t     */\n\t    zrender.dispose = function (zr) {\n\t        if (zr) {\n\t            zr.dispose();\n\t        }\n\t        else {\n\t            for (var key in instances) {\n\t                if (instances.hasOwnProperty(key)) {\n\t                    instances[key].dispose();\n\t                }\n\t            }\n\t            instances = {};\n\t        }\n\t\n\t        return zrender;\n\t    };\n\t\n\t    /**\n\t     * Get zrender instance by id\n\t     * @param {string} id zrender instance id\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.getInstance = function (id) {\n\t        return instances[id];\n\t    };\n\t\n\t    zrender.registerPainter = function (name, Ctor) {\n\t        painterCtors[name] = Ctor;\n\t    };\n\t\n\t    function delInstance(id) {\n\t        delete instances[id];\n\t    }\n\t\n\t    /**\n\t     * @module zrender/ZRender\n\t     */\n\t    /**\n\t     * @constructor\n\t     * @alias module:zrender/ZRender\n\t     * @param {string} id\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     */\n\t    var ZRender = function(id, dom, opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         */\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id = id;\n\t\n\t        var self = this;\n\t        var storage = new Storage();\n\t\n\t        var rendererType = opts.renderer;\n\t        // TODO WebGL\n\t        if (useVML) {\n\t            if (!painterCtors.vml) {\n\t                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t            }\n\t            rendererType = 'vml';\n\t        }\n\t        else if (!rendererType || !painterCtors[rendererType]) {\n\t            rendererType = 'canvas';\n\t        }\n\t        var painter = new painterCtors[rendererType](dom, storage, opts);\n\t\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t\n\t        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\t\n\t        /**\n\t         * @type {module:zrender/animation/Animation}\n\t         */\n\t        this.animation = new Animation({\n\t            stage: {\n\t                update: zrUtil.bind(this.flush, this)\n\t            }\n\t        });\n\t        this.animation.start();\n\t\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._needsRefresh;\n\t\n\t        // 修改 storage.delFromMap, 每次删除元素之前删除动画\n\t        // FIXME 有点ugly\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t\n\t            oldDelFromMap.call(storage, elId);\n\t\n\t            el && el.removeSelfFromZr(self);\n\t        };\n\t\n\t        storage.addToMap = function (el) {\n\t            oldAddToMap.call(storage, el);\n\t\n\t            el.addSelfToZr(self);\n\t        };\n\t    };\n\t\n\t    ZRender.prototype = {\n\t\n\t        constructor: ZRender,\n\t        /**\n\t         * 获取实例唯一标识\n\t         * @return {string}\n\t         */\n\t        getId: function () {\n\t            return this.id;\n\t        },\n\t\n\t        /**\n\t         * 添加元素\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        add: function (el) {\n\t            this.storage.addRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * 删除元素\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        remove: function (el) {\n\t            this.storage.delRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Change configuration of layer\n\t         * @param {string} zLevel\n\t         * @param {Object} config\n\t         * @param {string} [config.clearColor=0] Clear color\n\t         * @param {string} [config.motionBlur=false] If enable motion blur\n\t         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n\t        */\n\t        configLayer: function (zLevel, config) {\n\t            this.painter.configLayer(zLevel, config);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Repaint the canvas immediately\n\t         */\n\t        refreshImmediately: function () {\n\t            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t            // Or it will cause zrender refreshes again and again.\n\t            this._needsRefresh = false;\n\t            this.painter.refresh();\n\t            /**\n\t             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t             */\n\t            this._needsRefresh = false;\n\t        },\n\t\n\t        /**\n\t         * Mark and repaint the canvas in the next frame of browser\n\t         */\n\t        refresh: function() {\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Perform all refresh\n\t         */\n\t        flush: function () {\n\t            if (this._needsRefresh) {\n\t                this.refreshImmediately();\n\t            }\n\t            if (this._needsRefreshHover) {\n\t                this.refreshHoverImmediately();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add element to hover layer\n\t         * @param  {module:zrender/Element} el\n\t         * @param {Object} style\n\t         */\n\t        addHover: function (el, style) {\n\t            if (this.painter.addHover) {\n\t                this.painter.addHover(el, style);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add element from hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        removeHover: function (el) {\n\t            if (this.painter.removeHover) {\n\t                this.painter.removeHover(el);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clear all hover elements in hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        clearHover: function () {\n\t            if (this.painter.clearHover) {\n\t                this.painter.clearHover();\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Refresh hover in next frame\n\t         */\n\t        refreshHover: function () {\n\t            this._needsRefreshHover = true;\n\t        },\n\t\n\t        /**\n\t         * Refresh hover immediately\n\t         */\n\t        refreshHoverImmediately: function () {\n\t            this._needsRefreshHover = false;\n\t            this.painter.refreshHover && this.painter.refreshHover();\n\t        },\n\t\n\t        /**\n\t         * Resize the canvas.\n\t         * Should be invoked when container size is changed\n\t         * @param {Object} [opts]\n\t         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t         */\n\t        resize: function(opts) {\n\t            opts = opts || {};\n\t            this.painter.resize(opts.width, opts.height);\n\t            this.handler.resize();\n\t        },\n\t\n\t        /**\n\t         * Stop and clear all animation immediately\n\t         */\n\t        clearAnimation: function () {\n\t            this.animation.clear();\n\t        },\n\t\n\t        /**\n\t         * Get container width\n\t         */\n\t        getWidth: function() {\n\t            return this.painter.getWidth();\n\t        },\n\t\n\t        /**\n\t         * Get container height\n\t         */\n\t        getHeight: function() {\n\t            return this.painter.getHeight();\n\t        },\n\t\n\t        /**\n\t         * Export the canvas as Base64 URL\n\t         * @param {string} type\n\t         * @param {string} [backgroundColor='#fff']\n\t         * @return {string} Base64 URL\n\t         */\n\t        // toDataURL: function(type, backgroundColor) {\n\t        //     return this.painter.getRenderedCanvas({\n\t        //         backgroundColor: backgroundColor\n\t        //     }).toDataURL(type);\n\t        // },\n\t\n\t        /**\n\t         * Converting a path to image.\n\t         * It has much better performance of drawing image rather than drawing a vector path.\n\t         * @param {module:zrender/graphic/Path} e\n\t         * @param {number} width\n\t         * @param {number} height\n\t         */\n\t        pathToImage: function(e, dpr) {\n\t            return this.painter.pathToImage(e, dpr);\n\t        },\n\t\n\t        /**\n\t         * Set default cursor\n\t         * @param {string} [cursorStyle='default'] 例如 crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            this.handler.setCursorStyle(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * Bind event\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {Function} eventHandler Handler function\n\t         * @param {Object} [context] Context object\n\t         */\n\t        on: function(eventName, eventHandler, context) {\n\t            this.handler.on(eventName, eventHandler, context);\n\t        },\n\t\n\t        /**\n\t         * Unbind event\n\t         * @param {string} eventName Event name\n\t         * @param {Function} [eventHandler] Handler function\n\t         */\n\t        off: function(eventName, eventHandler) {\n\t            this.handler.off(eventName, eventHandler);\n\t        },\n\t\n\t        /**\n\t         * Trigger event manually\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {event=} event Event object\n\t         */\n\t        trigger: function (eventName, event) {\n\t            this.handler.trigger(eventName, event);\n\t        },\n\t\n\t\n\t        /**\n\t         * Clear all objects and the canvas.\n\t         */\n\t        clear: function () {\n\t            this.storage.delRoot();\n\t            this.painter.clear();\n\t        },\n\t\n\t        /**\n\t         * Dispose self.\n\t         */\n\t        dispose: function () {\n\t            this.animation.stop();\n\t\n\t            this.clear();\n\t            this.storage.dispose();\n\t            this.painter.dispose();\n\t            this.handler.dispose();\n\t\n\t            this.animation =\n\t            this.storage =\n\t            this.painter =\n\t            this.handler = null;\n\t\n\t            delInstance(this.id);\n\t        }\n\t    };\n\t\n\t    module.exports = zrender;\n\t\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/**\n\t * zrender: 生成唯一id\n\t *\n\t * @author errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var idStart = 0x0907;\n\t\n\t    module.exports = function () {\n\t        return idStart++;\n\t    };\n\t\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/**\n\t * echarts设备环境识别\n\t *\n\t * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n\t * @author firede[firede@firede.us]\n\t * @desc thanks zepto.\n\t */\n\t\n\t    var env = {};\n\t    if (typeof navigator === 'undefined') {\n\t        // In node\n\t        env = {\n\t            browser: {},\n\t            os: {},\n\t            node: true,\n\t            // Assume canvas is supported\n\t            canvasSupported: true\n\t        };\n\t    }\n\t    else {\n\t        env = detect(navigator.userAgent);\n\t    }\n\t\n\t    module.exports = env;\n\t\n\t    // Zepto.js\n\t    // (c) 2010-2013 Thomas Fuchs\n\t    // Zepto.js may be freely distributed under the MIT license.\n\t\n\t    function detect(ua) {\n\t        var os = {};\n\t        var browser = {};\n\t        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t        // var touchpad = webos && ua.match(/TouchPad/);\n\t        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t        // var playbook = ua.match(/PlayBook/);\n\t        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n\t        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n\t            // IE 11 Trident/7.0; rv:11.0\n\t            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\t\n\t        var weChat = (/micromessenger/i).test(ua);\n\t\n\t        // Todo: clean this up with a better OS/browser seperation:\n\t        // - discern (more) between multiple browsers on android\n\t        // - decide if kindle fire in silk mode is android or not\n\t        // - Firefox on Android doesn't specify the Android version\n\t        // - possibly devide in os, device and browser hashes\n\t\n\t        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t\n\t        // if (android) os.android = true, os.version = android[2];\n\t        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t        // if (webos) os.webos = true, os.version = webos[2];\n\t        // if (touchpad) os.touchpad = true;\n\t        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t        // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t        // if (playbook) browser.playbook = true;\n\t        // if (kindle) os.kindle = true, os.version = kindle[1];\n\t        // if (silk) browser.silk = true, browser.version = silk[1];\n\t        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t        if (firefox) {\n\t            browser.firefox = true;\n\t            browser.version = firefox[1];\n\t        }\n\t        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t        // if (webview) browser.webview = true;\n\t\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t\n\t        if (edge) {\n\t            browser.edge = true;\n\t            browser.version = edge[1];\n\t        }\n\t\n\t        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n\t        // not be set on win phone. So we do not consider Win Phone.\n\t        if (weChat) {\n\t            browser.weChat = true;\n\t        }\n\t\n\t        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t\n\t        return {\n\t            browser: browser,\n\t            os: os,\n\t            node: false,\n\t            // 原生canvas支持，改极端点了\n\t            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n\t            canvasSupported : document.createElement('canvas').getContext ? true : false,\n\t            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n\t            // works on most browsers\n\t            // IE10/11 does not support touch event, and MS Edge supports them but not by\n\t            // default, so we dont check navigator.maxTouchPoints for them here.\n\t            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t            // <http://caniuse.com/#search=pointer%20event>.\n\t            pointerEventsSupported: 'onpointerdown' in window\n\t                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n\t                // events currently. So we dont use that on other browsers unless tested sufficiently.\n\t                // Although IE 10 supports pointer event, it use old style and is different from the\n\t                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n\t                && (browser.edge || (browser.ie && browser.version >= 11))\n\t        };\n\t    }\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/core/util\n\t */\n\t\n\t\n\t    // 用于处理merge时无法遍历Date等对象的问题\n\t    var BUILTIN_OBJECT = {\n\t        '[object Function]': 1,\n\t        '[object RegExp]': 1,\n\t        '[object Date]': 1,\n\t        '[object Error]': 1,\n\t        '[object CanvasGradient]': 1,\n\t        '[object CanvasPattern]': 1,\n\t        // For node-canvas\n\t        '[object Image]': 1,\n\t        '[object Canvas]': 1\n\t    };\n\t\n\t    var TYPED_ARRAY = {\n\t        '[object Int8Array]': 1,\n\t        '[object Uint8Array]': 1,\n\t        '[object Uint8ClampedArray]': 1,\n\t        '[object Int16Array]': 1,\n\t        '[object Uint16Array]': 1,\n\t        '[object Int32Array]': 1,\n\t        '[object Uint32Array]': 1,\n\t        '[object Float32Array]': 1,\n\t        '[object Float64Array]': 1\n\t    };\n\t\n\t    var objToString = Object.prototype.toString;\n\t\n\t    var arrayProto = Array.prototype;\n\t    var nativeForEach = arrayProto.forEach;\n\t    var nativeFilter = arrayProto.filter;\n\t    var nativeSlice = arrayProto.slice;\n\t    var nativeMap = arrayProto.map;\n\t    var nativeReduce = arrayProto.reduce;\n\t\n\t    /**\n\t     * Those data types can be cloned:\n\t     *     Plain object, Array, TypedArray, number, string, null, undefined.\n\t     * Those data types will be assgined using the orginal data:\n\t     *     BUILTIN_OBJECT\n\t     * Instance of user defined class will be cloned to a plain object, without\n\t     * properties in prototype.\n\t     * Other data types is not supported (not sure what will happen).\n\t     *\n\t     * Caution: do not support clone Date, for performance consideration.\n\t     * (There might be a large number of date in `series.data`).\n\t     * So date should not be modified in and out of echarts.\n\t     *\n\t     * @param {*} source\n\t     * @return {*} new\n\t     */\n\t    function clone(source) {\n\t        if (source == null || typeof source != 'object') {\n\t            return source;\n\t        }\n\t\n\t        var result = source;\n\t        var typeStr = objToString.call(source);\n\t\n\t        if (typeStr === '[object Array]') {\n\t            result = [];\n\t            for (var i = 0, len = source.length; i < len; i++) {\n\t                result[i] = clone(source[i]);\n\t            }\n\t        }\n\t        else if (TYPED_ARRAY[typeStr]) {\n\t            result = source.constructor.from(source);\n\t        }\n\t        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n\t            result = {};\n\t            for (var key in source) {\n\t                if (source.hasOwnProperty(key)) {\n\t                    result[key] = clone(source[key]);\n\t                }\n\t            }\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolean} [overwrite=false]\n\t     */\n\t    function merge(target, source, overwrite) {\n\t        // We should escapse that source is string\n\t        // and enter for ... in ...\n\t        if (!isObject(source) || !isObject(target)) {\n\t            return overwrite ? clone(source) : target;\n\t        }\n\t\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                var targetProp = target[key];\n\t                var sourceProp = source[key];\n\t\n\t                if (isObject(sourceProp)\n\t                    && isObject(targetProp)\n\t                    && !isArray(sourceProp)\n\t                    && !isArray(targetProp)\n\t                    && !isDom(sourceProp)\n\t                    && !isDom(targetProp)\n\t                    && !isBuiltInObject(sourceProp)\n\t                    && !isBuiltInObject(targetProp)\n\t                    && !isPrimitive(sourceProp)\n\t                    && !isPrimitive(targetProp)\n\t                ) {\n\t                    // 如果需要递归覆盖，就递归调用merge\n\t                    merge(targetProp, sourceProp, overwrite);\n\t                }\n\t                else if (overwrite || !(key in target)) {\n\t                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n\t                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n\t                    target[key] = clone(source[key], true);\n\t                }\n\t            }\n\t        }\n\t\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t     * @param {boolean} [overwrite=false]\n\t     * @return {*} target\n\t     */\n\t    function mergeAll(targetAndSources, overwrite) {\n\t        var result = targetAndSources[0];\n\t        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t            result = merge(result, targetAndSources[i], overwrite);\n\t        }\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function extend(target, source) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolen} [overlay=false]\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function defaults(target, source, overlay) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)\n\t                && (overlay ? source[key] != null : target[key] == null)\n\t            ) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    function createCanvas() {\n\t        return document.createElement('canvas');\n\t    }\n\t    // FIXME\n\t    var _ctx;\n\t    function getContext() {\n\t        if (!_ctx) {\n\t            // Use util.createCanvas instead of createCanvas\n\t            // because createCanvas may be overwritten in different environment\n\t            _ctx = util.createCanvas().getContext('2d');\n\t        }\n\t        return _ctx;\n\t    }\n\t\n\t    /**\n\t     * 查询数组中元素的index\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function indexOf(array, value) {\n\t        if (array) {\n\t            if (array.indexOf) {\n\t                return array.indexOf(value);\n\t            }\n\t            for (var i = 0, len = array.length; i < len; i++) {\n\t                if (array[i] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    /**\n\t     * 构造类继承关系\n\t     *\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} clazz 源类\n\t     * @param {Function} baseClazz 基类\n\t     */\n\t    function inherits(clazz, baseClazz) {\n\t        var clazzPrototype = clazz.prototype;\n\t        function F() {}\n\t        F.prototype = baseClazz.prototype;\n\t        clazz.prototype = new F();\n\t\n\t        for (var prop in clazzPrototype) {\n\t            clazz.prototype[prop] = clazzPrototype[prop];\n\t        }\n\t        clazz.prototype.constructor = clazz;\n\t        clazz.superClass = baseClazz;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Function} target\n\t     * @param {Object|Function} sorce\n\t     * @param {boolean} overlay\n\t     */\n\t    function mixin(target, source, overlay) {\n\t        target = 'prototype' in target ? target.prototype : target;\n\t        source = 'prototype' in source ? source.prototype : source;\n\t\n\t        defaults(target, source, overlay);\n\t    }\n\t\n\t    /**\n\t     * @param {Array|TypedArray} data\n\t     */\n\t    function isArrayLike(data) {\n\t        if (! data) {\n\t            return;\n\t        }\n\t        if (typeof data == 'string') {\n\t            return false;\n\t        }\n\t        return typeof data.length == 'number';\n\t    }\n\t\n\t    /**\n\t     * 数组或对象遍历\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     */\n\t    function each(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.forEach && obj.forEach === nativeForEach) {\n\t            obj.forEach(cb, context);\n\t        }\n\t        else if (obj.length === +obj.length) {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                cb.call(context, obj[i], i, obj);\n\t            }\n\t        }\n\t        else {\n\t            for (var key in obj) {\n\t                if (obj.hasOwnProperty(key)) {\n\t                    cb.call(context, obj[key], key, obj);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组映射\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function map(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.map && obj.map === nativeMap) {\n\t            return obj.map(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                result.push(cb.call(context, obj[i], i, obj));\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {Object} [memo]\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function reduce(obj, cb, memo, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.reduce && obj.reduce === nativeReduce) {\n\t            return obj.reduce(cb, memo, context);\n\t        }\n\t        else {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                memo = cb.call(context, memo, obj[i], i, obj);\n\t            }\n\t            return memo;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组过滤\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function filter(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.filter && obj.filter === nativeFilter) {\n\t            return obj.filter(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                if (cb.call(context, obj[i], i, obj)) {\n\t                    result.push(obj[i]);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组项查找\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function find(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        for (var i = 0, len = obj.length; i < len; i++) {\n\t            if (cb.call(context, obj[i], i, obj)) {\n\t                return obj[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @param {*} context\n\t     * @return {Function}\n\t     */\n\t    function bind(func, context) {\n\t        var args = nativeSlice.call(arguments, 2);\n\t        return function () {\n\t            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @return {Function}\n\t     */\n\t    function curry(func) {\n\t        var args = nativeSlice.call(arguments, 1);\n\t        return function () {\n\t            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isArray(value) {\n\t        return objToString.call(value) === '[object Array]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isFunction(value) {\n\t        return typeof value === 'function';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isString(value) {\n\t        return objToString.call(value) === '[object String]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isObject(value) {\n\t        // Avoid a V8 JIT bug in Chrome 19-20.\n\t        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t        var type = typeof value;\n\t        return type === 'function' || (!!value && type == 'object');\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isBuiltInObject(value) {\n\t        return !!BUILTIN_OBJECT[objToString.call(value)];\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isDom(value) {\n\t        return typeof value === 'object'\n\t            && typeof value.nodeType === 'number'\n\t            && typeof value.ownerDocument === 'object';\n\t    }\n\t\n\t    /**\n\t     * Whether is exactly NaN. Notice isNaN('a') returns true.\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function eqNaN(value) {\n\t        return value !== value;\n\t    }\n\t\n\t    /**\n\t     * If value1 is not null, then return value1, otherwise judget rest of values.\n\t     * @memberOf module:zrender/core/util\n\t     * @return {*} Final value\n\t     */\n\t    function retrieve(values) {\n\t        for (var i = 0, len = arguments.length; i < len; i++) {\n\t            if (arguments[i] != null) {\n\t                return arguments[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} arr\n\t     * @param {number} startIndex\n\t     * @param {number} endIndex\n\t     * @return {Array}\n\t     */\n\t    function slice() {\n\t        return Function.call.apply(nativeSlice, arguments);\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {boolean} condition\n\t     * @param {string} message\n\t     */\n\t    function assert(condition, message) {\n\t        if (!condition) {\n\t            throw new Error(message);\n\t        }\n\t    }\n\t\n\t    var primitiveKey = '__ec_primitive__';\n\t    /**\n\t     * Set an object as primitive to be ignored traversing children in clone or merge\n\t     */\n\t    function setAsPrimitive(obj) {\n\t        obj[primitiveKey] = true;\n\t    }\n\t\n\t    function isPrimitive(obj) {\n\t        return obj[primitiveKey];\n\t    }\n\t\n\t    var util = {\n\t        inherits: inherits,\n\t        mixin: mixin,\n\t        clone: clone,\n\t        merge: merge,\n\t        mergeAll: mergeAll,\n\t        extend: extend,\n\t        defaults: defaults,\n\t        getContext: getContext,\n\t        createCanvas: createCanvas,\n\t        indexOf: indexOf,\n\t        slice: slice,\n\t        find: find,\n\t        isArrayLike: isArrayLike,\n\t        each: each,\n\t        map: map,\n\t        reduce: reduce,\n\t        filter: filter,\n\t        bind: bind,\n\t        curry: curry,\n\t        isArray: isArray,\n\t        isString: isString,\n\t        isObject: isObject,\n\t        isFunction: isFunction,\n\t        isBuiltInObject: isBuiltInObject,\n\t        isDom: isDom,\n\t        eqNaN: eqNaN,\n\t        retrieve: retrieve,\n\t        assert: assert,\n\t        setAsPrimitive: setAsPrimitive,\n\t        noop: function () {}\n\t    };\n\t    module.exports = util;\n\t\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Handler\n\t * @module zrender/Handler\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (shenyi.914@gmail.com)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(6);\n\t    var Draggable = __webpack_require__(8);\n\t\n\t    var Eventful = __webpack_require__(9);\n\t\n\t    function makeEventPacket(eveType, target, event) {\n\t        return {\n\t            type: eveType,\n\t            event: event,\n\t            target: target,\n\t            cancelBubble: false,\n\t            offsetX: event.zrX,\n\t            offsetY: event.zrY,\n\t            gestureEvent: event.gestureEvent,\n\t            pinchX: event.pinchX,\n\t            pinchY: event.pinchY,\n\t            pinchScale: event.pinchScale,\n\t            wheelDelta: event.zrDelta,\n\t            zrByTouch: event.zrByTouch\n\t        };\n\t    }\n\t\n\t    function EmptyProxy () {}\n\t    EmptyProxy.prototype.dispose = function () {};\n\t\n\t    var handlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n\t    ];\n\t    /**\n\t     * @alias module:zrender/Handler\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Eventful\n\t     * @param {module:zrender/Storage} storage Storage instance.\n\t     * @param {module:zrender/Painter} painter Painter instance.\n\t     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n\t     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n\t     */\n\t    var Handler = function(storage, painter, proxy, painterRoot) {\n\t        Eventful.call(this);\n\t\n\t        this.storage = storage;\n\t\n\t        this.painter = painter;\n\t\n\t        this.painterRoot = painterRoot;\n\t\n\t        proxy = proxy || new EmptyProxy();\n\t\n\t        /**\n\t         * Proxy of event. can be Dom, WebGLSurface, etc.\n\t         */\n\t        this.proxy = proxy;\n\t\n\t        // Attach handler\n\t        proxy.handler = this;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._hovered;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Date}\n\t         */\n\t        this._lastTouchMoment;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastX;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastY;\n\t\n\t\n\t        Draggable.call(this);\n\t\n\t        util.each(handlerNames, function (name) {\n\t            proxy.on && proxy.on(name, this[name], this);\n\t        }, this);\n\t    };\n\t\n\t    Handler.prototype = {\n\t\n\t        constructor: Handler,\n\t\n\t        mousemove: function (event) {\n\t            var x = event.zrX;\n\t            var y = event.zrY;\n\t\n\t            var hovered = this.findHover(x, y, null);\n\t            var lastHovered = this._hovered;\n\t            var proxy = this.proxy;\n\t\n\t            this._hovered = hovered;\n\t\n\t            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\t\n\t            // Mouse out on previous hovered element\n\t            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n\t                this.dispatchToElement(lastHovered, 'mouseout', event);\n\t            }\n\t\n\t            // Mouse moving on one element\n\t            this.dispatchToElement(hovered, 'mousemove', event);\n\t\n\t            // Mouse over on a new element\n\t            if (hovered && hovered !== lastHovered) {\n\t                this.dispatchToElement(hovered, 'mouseover', event);\n\t            }\n\t        },\n\t\n\t        mouseout: function (event) {\n\t            this.dispatchToElement(this._hovered, 'mouseout', event);\n\t\n\t            // There might be some doms created by upper layer application\n\t            // at the same level of painter.getViewportRoot() (e.g., tooltip\n\t            // dom created by echarts), where 'globalout' event should not\n\t            // be triggered when mouse enters these doms. (But 'mouseout'\n\t            // should be triggered at the original hovered element as usual).\n\t            var element = event.toElement || event.relatedTarget;\n\t            var innerDom;\n\t            do {\n\t                element = element && element.parentNode;\n\t            }\n\t            while (element && element.nodeType != 9 && !(\n\t                innerDom = element === this.painterRoot\n\t            ));\n\t\n\t            !innerDom && this.trigger('globalout', {event: event});\n\t        },\n\t\n\t        /**\n\t         * Resize\n\t         */\n\t        resize: function (event) {\n\t            this._hovered = null;\n\t        },\n\t\n\t        /**\n\t         * Dispatch event\n\t         * @param {string} eventName\n\t         * @param {event=} eventArgs\n\t         */\n\t        dispatch: function (eventName, eventArgs) {\n\t            var handler = this[eventName];\n\t            handler && handler.call(this, eventArgs);\n\t        },\n\t\n\t        /**\n\t         * Dispose\n\t         */\n\t        dispose: function () {\n\t\n\t            this.proxy.dispose();\n\t\n\t            this.storage =\n\t            this.proxy =\n\t            this.painter = null;\n\t        },\n\t\n\t        /**\n\t         * 设置默认的cursor style\n\t         * @param {string} [cursorStyle='default'] 例如 crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            var proxy = this.proxy;\n\t            proxy.setCursor && proxy.setCursor(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * 事件分发代理\n\t         *\n\t         * @private\n\t         * @param {Object} targetEl 目标图形元素\n\t         * @param {string} eventName 事件名称\n\t         * @param {Object} event 事件对象\n\t         */\n\t        dispatchToElement: function (targetEl, eventName, event) {\n\t            var eventHandler = 'on' + eventName;\n\t            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\t\n\t            var el = targetEl;\n\t\n\t            while (el) {\n\t                el[eventHandler]\n\t                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t\n\t                el.trigger(eventName, eventPacket);\n\t\n\t                el = el.parent;\n\t\n\t                if (eventPacket.cancelBubble) {\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (!eventPacket.cancelBubble) {\n\t                // 冒泡到顶级 zrender 对象\n\t                this.trigger(eventName, eventPacket);\n\t                // 分发事件到用户自定义层\n\t                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\t                this.painter && this.painter.eachOtherLayer(function (layer) {\n\t                    if (typeof(layer[eventHandler]) == 'function') {\n\t                        layer[eventHandler].call(layer, eventPacket);\n\t                    }\n\t                    if (layer.trigger) {\n\t                        layer.trigger(eventName, eventPacket);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @param {module:zrender/graphic/Displayable} exclude\n\t         * @method\n\t         */\n\t        findHover: function(x, y, exclude) {\n\t            var list = this.storage.getDisplayList();\n\t            for (var i = list.length - 1; i >= 0 ; i--) {\n\t                if (!list[i].silent\n\t                 && list[i] !== exclude\n\t                 // getDisplayList may include ignored item in VML mode\n\t                 && !list[i].ignore\n\t                 && isHover(list[i], x, y)) {\n\t                    return list[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    // Common handlers\n\t    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t        Handler.prototype[name] = function (event) {\n\t            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t            var hovered = this.findHover(event.zrX, event.zrY, null);\n\t\n\t            if (name === 'mousedown') {\n\t                this._downel = hovered;\n\t                // In case click triggered before mouseup\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'mosueup') {\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'click') {\n\t                if (this._downel !== this._upel) {\n\t                    return;\n\t                }\n\t            }\n\t\n\t            this.dispatchToElement(hovered, name, event);\n\t        };\n\t    });\n\t\n\t    function isHover(displayable, x, y) {\n\t        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t            var el = displayable;\n\t            while (el) {\n\t                // If ancestor is silent or clipped by ancestor\n\t                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n\t                    return false;\n\t                }\n\t                el = el.parent;\n\t            }\n\t            return true;\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    util.mixin(Handler, Eventful);\n\t    util.mixin(Handler, Draggable);\n\t\n\t    module.exports = Handler;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t// TODO Draggable for group\n\t// FIXME Draggable on element which has parent rotation or scale\n\t\n\t    function Draggable() {\n\t\n\t        this.on('mousedown', this._dragStart, this);\n\t        this.on('mousemove', this._drag, this);\n\t        this.on('mouseup', this._dragEnd, this);\n\t        this.on('globalout', this._dragEnd, this);\n\t        // this._dropTarget = null;\n\t        // this._draggingTarget = null;\n\t\n\t        // this._x = 0;\n\t        // this._y = 0;\n\t    }\n\t\n\t    Draggable.prototype = {\n\t\n\t        constructor: Draggable,\n\t\n\t        _dragStart: function (e) {\n\t            var draggingTarget = e.target;\n\t            if (draggingTarget && draggingTarget.draggable) {\n\t                this._draggingTarget = draggingTarget;\n\t                draggingTarget.dragging = true;\n\t                this._x = e.offsetX;\n\t                this._y = e.offsetY;\n\t\n\t                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n\t            }\n\t        },\n\t\n\t        _drag: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t\n\t                var x = e.offsetX;\n\t                var y = e.offsetY;\n\t\n\t                var dx = x - this._x;\n\t                var dy = y - this._y;\n\t                this._x = x;\n\t                this._y = y;\n\t\n\t                draggingTarget.drift(dx, dy, e);\n\t                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\t\n\t                var dropTarget = this.findHover(x, y, draggingTarget);\n\t                var lastDropTarget = this._dropTarget;\n\t                this._dropTarget = dropTarget;\n\t\n\t                if (draggingTarget !== dropTarget) {\n\t                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n\t                    }\n\t                    if (dropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _dragEnd: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t\n\t            if (draggingTarget) {\n\t                draggingTarget.dragging = false;\n\t            }\n\t\n\t            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\t\n\t            if (this._dropTarget) {\n\t                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n\t            }\n\t\n\t            this._draggingTarget = null;\n\t            this._dropTarget = null;\n\t        }\n\t\n\t    };\n\t\n\t    module.exports = Draggable;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/**\n\t * 事件扩展\n\t * @module zrender/mixin/Eventful\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var arrySlice = Array.prototype.slice;\n\t\n\t    /**\n\t     * 事件分发器\n\t     * @alias module:zrender/mixin/Eventful\n\t     * @constructor\n\t     */\n\t    var Eventful = function () {\n\t        this._$handlers = {};\n\t    };\n\t\n\t    Eventful.prototype = {\n\t\n\t        constructor: Eventful,\n\t\n\t        /**\n\t         * 单次触发绑定，trigger后销毁\n\t         *\n\t         * @param {string} event 事件名\n\t         * @param {Function} handler 响应函数\n\t         * @param {Object} context\n\t         */\n\t        one: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: true,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 绑定事件\n\t         * @param {string} event 事件名\n\t         * @param {Function} handler 事件处理函数\n\t         * @param {Object} [context]\n\t         */\n\t        on: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: false,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 是否绑定了事件\n\t         * @param  {string}  event\n\t         * @return {boolean}\n\t         */\n\t        isSilent: function (event) {\n\t            var _h = this._$handlers;\n\t            return _h[event] && _h[event].length;\n\t        },\n\t\n\t        /**\n\t         * 解绑事件\n\t         * @param {string} event 事件名\n\t         * @param {Function} [handler] 事件处理函数\n\t         */\n\t        off: function (event, handler) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!event) {\n\t                this._$handlers = {};\n\t                return this;\n\t            }\n\t\n\t            if (handler) {\n\t                if (_h[event]) {\n\t                    var newList = [];\n\t                    for (var i = 0, l = _h[event].length; i < l; i++) {\n\t                        if (_h[event][i]['h'] != handler) {\n\t                            newList.push(_h[event][i]);\n\t                        }\n\t                    }\n\t                    _h[event] = newList;\n\t                }\n\t\n\t                if (_h[event] && _h[event].length === 0) {\n\t                    delete _h[event];\n\t                }\n\t            }\n\t            else {\n\t                delete _h[event];\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 事件分发\n\t         *\n\t         * @param {string} type 事件类型\n\t         */\n\t        trigger: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 3) {\n\t                    args = arrySlice.call(args, 1);\n\t                }\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(_h[i]['ctx']);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(_h[i]['ctx'], args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 带有context的事件分发, 最后一个参数是事件回调的context\n\t         * @param {string} type 事件类型\n\t         */\n\t        triggerWithContext: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 4) {\n\t                    args = arrySlice.call(args, 1, args.length - 1);\n\t                }\n\t                var ctx = args[args.length - 1];\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(ctx);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(ctx, args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(ctx, args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(ctx, args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    // 对象可以通过 onxxxx 绑定事件\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onclick\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseout\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousemove\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousewheel\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousedown\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseup\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrag\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragstart\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragend\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragenter\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragleave\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrop\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t\n\t    module.exports = Eventful;\n\t\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Storage内容仓库模块\n\t * @module zrender/Storage\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t * @author errorrik (errorrik@gmail.com)\n\t * @author pissang (https://github.com/pissang/)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(6);\n\t    var env = __webpack_require__(5);\n\t\n\t    var Group = __webpack_require__(11);\n\t\n\t    // Use timsort because in most case elements are partially sorted\n\t    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n\t    var timsort = __webpack_require__(25);\n\t\n\t    function shapeCompareFunc(a, b) {\n\t        if (a.zlevel === b.zlevel) {\n\t            if (a.z === b.z) {\n\t                // if (a.z2 === b.z2) {\n\t                //     // FIXME Slow has renderidx compare\n\t                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t                //     return a.__renderidx - b.__renderidx;\n\t                // }\n\t                return a.z2 - b.z2;\n\t            }\n\t            return a.z - b.z;\n\t        }\n\t        return a.zlevel - b.zlevel;\n\t    }\n\t    /**\n\t     * 内容仓库 (M)\n\t     * @alias module:zrender/Storage\n\t     * @constructor\n\t     */\n\t    var Storage = function () {\n\t        // 所有常规形状，id索引的map\n\t        this._elements = {};\n\t\n\t        this._roots = [];\n\t\n\t        this._displayList = [];\n\t\n\t        this._displayListLen = 0;\n\t    };\n\t\n\t    Storage.prototype = {\n\t\n\t        constructor: Storage,\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         *\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._roots.length; i++) {\n\t                this._roots[i].traverse(cb, context);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 返回所有图形的绘制队列\n\t         * @param {boolean} [update=false] 是否在返回前更新该数组\n\t         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n\t         *\n\t         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n\t         * @return {Array.<module:zrender/graphic/Displayable>}\n\t         */\n\t        getDisplayList: function (update, includeIgnore) {\n\t            includeIgnore = includeIgnore || false;\n\t            if (update) {\n\t                this.updateDisplayList(includeIgnore);\n\t            }\n\t            return this._displayList;\n\t        },\n\t\n\t        /**\n\t         * 更新图形的绘制队列。\n\t         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n\t         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n\t         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n\t         */\n\t        updateDisplayList: function (includeIgnore) {\n\t            this._displayListLen = 0;\n\t            var roots = this._roots;\n\t            var displayList = this._displayList;\n\t            for (var i = 0, len = roots.length; i < len; i++) {\n\t                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t            }\n\t            displayList.length = this._displayListLen;\n\t\n\t            // for (var i = 0, len = displayList.length; i < len; i++) {\n\t            //     displayList[i].__renderidx = i;\n\t            // }\n\t\n\t            // displayList.sort(shapeCompareFunc);\n\t            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t        },\n\t\n\t        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t\n\t            if (el.ignore && !includeIgnore) {\n\t                return;\n\t            }\n\t\n\t            el.beforeUpdate();\n\t\n\t            if (el.__dirty) {\n\t\n\t                el.update();\n\t\n\t            }\n\t\n\t            el.afterUpdate();\n\t\n\t            var userSetClipPath = el.clipPath;\n\t            if (userSetClipPath) {\n\t\n\t                // FIXME 效率影响\n\t                if (clipPaths) {\n\t                    clipPaths = clipPaths.slice();\n\t                }\n\t                else {\n\t                    clipPaths = [];\n\t                }\n\t\n\t                var currentClipPath = userSetClipPath;\n\t                var parentClipPath = el;\n\t                // Recursively add clip path\n\t                while (currentClipPath) {\n\t                    // clipPath 的变换是基于使用这个 clipPath 的元素\n\t                    currentClipPath.parent = parentClipPath;\n\t                    currentClipPath.updateTransform();\n\t\n\t                    clipPaths.push(currentClipPath);\n\t\n\t                    parentClipPath = currentClipPath;\n\t                    currentClipPath = currentClipPath.clipPath;\n\t                }\n\t            }\n\t\n\t            if (el.isGroup) {\n\t                var children = el._children;\n\t\n\t                for (var i = 0; i < children.length; i++) {\n\t                    var child = children[i];\n\t\n\t                    // Force to mark as dirty if group is dirty\n\t                    // FIXME __dirtyPath ?\n\t                    if (el.__dirty) {\n\t                        child.__dirty = true;\n\t                    }\n\t\n\t                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t                }\n\t\n\t                // Mark group clean here\n\t                el.__dirty = false;\n\t\n\t            }\n\t            else {\n\t                el.__clipPaths = clipPaths;\n\t\n\t                this._displayList[this._displayListLen++] = el;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 添加图形(Shape)或者组(Group)到根节点\n\t         * @param {module:zrender/Element} el\n\t         */\n\t        addRoot: function (el) {\n\t            // Element has been added\n\t            if (this._elements[el.id]) {\n\t                return;\n\t            }\n\t\n\t            if (el instanceof Group) {\n\t                el.addChildrenToStorage(this);\n\t            }\n\t\n\t            this.addToMap(el);\n\t            this._roots.push(el);\n\t        },\n\t\n\t        /**\n\t         * 删除指定的图形(Shape)或者组(Group)\n\t         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage\n\t         */\n\t        delRoot: function (elId) {\n\t            if (elId == null) {\n\t                // 不指定elId清空\n\t                for (var i = 0; i < this._roots.length; i++) {\n\t                    var root = this._roots[i];\n\t                    if (root instanceof Group) {\n\t                        root.delChildrenFromStorage(this);\n\t                    }\n\t                }\n\t\n\t                this._elements = {};\n\t                this._roots = [];\n\t                this._displayList = [];\n\t                this._displayListLen = 0;\n\t\n\t                return;\n\t            }\n\t\n\t            if (elId instanceof Array) {\n\t                for (var i = 0, l = elId.length; i < l; i++) {\n\t                    this.delRoot(elId[i]);\n\t                }\n\t                return;\n\t            }\n\t\n\t            var el;\n\t            if (typeof(elId) == 'string') {\n\t                el = this._elements[elId];\n\t            }\n\t            else {\n\t                el = elId;\n\t            }\n\t\n\t            var idx = util.indexOf(this._roots, el);\n\t            if (idx >= 0) {\n\t                this.delFromMap(el.id);\n\t                this._roots.splice(idx, 1);\n\t                if (el instanceof Group) {\n\t                    el.delChildrenFromStorage(this);\n\t                }\n\t            }\n\t        },\n\t\n\t        addToMap: function (el) {\n\t            if (el instanceof Group) {\n\t                el.__storage = this;\n\t            }\n\t            el.dirty(false);\n\t\n\t            this._elements[el.id] = el;\n\t\n\t            return this;\n\t        },\n\t\n\t        get: function (elId) {\n\t            return this._elements[elId];\n\t        },\n\t\n\t        delFromMap: function (elId) {\n\t            var elements = this._elements;\n\t            var el = elements[elId];\n\t            if (el) {\n\t                delete elements[elId];\n\t                if (el instanceof Group) {\n\t                    el.__storage = null;\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 清空并且释放Storage\n\t         */\n\t        dispose: function () {\n\t            this._elements =\n\t            this._renderList =\n\t            this._roots = null;\n\t        },\n\t\n\t        displayableSortFunc: shapeCompareFunc\n\t    };\n\t\n\t    module.exports = Storage;\n\t\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n\t * @module zrender/graphic/Group\n\t * @example\n\t *     var Group = require('zrender/lib/container/Group');\n\t *     var Circle = require('zrender/lib/graphic/shape/Circle');\n\t *     var g = new Group();\n\t *     g.position[0] = 100;\n\t *     g.position[1] = 100;\n\t *     g.add(new Circle({\n\t *         style: {\n\t *             x: 100,\n\t *             y: 100,\n\t *             r: 20,\n\t *         }\n\t *     }));\n\t *     zr.add(g);\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(6);\n\t    var Element = __webpack_require__(12);\n\t    var BoundingRect = __webpack_require__(24);\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Group\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @extends module:zrender/mixin/Eventful\n\t     */\n\t    var Group = function (opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        for (var key in opts) {\n\t            if (opts.hasOwnProperty(key)) {\n\t                this[key] = opts[key];\n\t            }\n\t        }\n\t\n\t        this._children = [];\n\t\n\t        this.__storage = null;\n\t\n\t        this.__dirty = true;\n\t    };\n\t\n\t    Group.prototype = {\n\t\n\t        constructor: Group,\n\t\n\t        isGroup: true,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        type: 'group',\n\t\n\t        /**\n\t         * 所有子孙元素是否响应鼠标事件\n\t         * @name module:/zrender/container/Group#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/Element>}\n\t         */\n\t        children: function () {\n\t            return this._children.slice();\n\t        },\n\t\n\t        /**\n\t         * 获取指定 index 的儿子节点\n\t         * @param  {number} idx\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childAt: function (idx) {\n\t            return this._children[idx];\n\t        },\n\t\n\t        /**\n\t         * 获取指定名字的儿子节点\n\t         * @param  {string} name\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childOfName: function (name) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (children[i].name === name) {\n\t                    return children[i];\n\t                }\n\t             }\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        childCount: function () {\n\t            return this._children.length;\n\t        },\n\t\n\t        /**\n\t         * 添加子节点到最后\n\t         * @param {module:zrender/Element} child\n\t         */\n\t        add: function (child) {\n\t            if (child && child !== this && child.parent !== this) {\n\t\n\t                this._children.push(child);\n\t\n\t                this._doAdd(child);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 添加子节点在 nextSibling 之前\n\t         * @param {module:zrender/Element} child\n\t         * @param {module:zrender/Element} nextSibling\n\t         */\n\t        addBefore: function (child, nextSibling) {\n\t            if (child && child !== this && child.parent !== this\n\t                && nextSibling && nextSibling.parent === this) {\n\t\n\t                var children = this._children;\n\t                var idx = children.indexOf(nextSibling);\n\t\n\t                if (idx >= 0) {\n\t                    children.splice(idx, 0, child);\n\t                    this._doAdd(child);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        _doAdd: function (child) {\n\t            if (child.parent) {\n\t                child.parent.remove(child);\n\t            }\n\t\n\t            child.parent = this;\n\t\n\t            var storage = this.__storage;\n\t            var zr = this.__zr;\n\t            if (storage && storage !== child.__storage) {\n\t\n\t                storage.addToMap(child);\n\t\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * 移除子节点\n\t         * @param {module:zrender/Element} child\n\t         */\n\t        remove: function (child) {\n\t            var zr = this.__zr;\n\t            var storage = this.__storage;\n\t            var children = this._children;\n\t\n\t            var idx = zrUtil.indexOf(children, child);\n\t            if (idx < 0) {\n\t                return this;\n\t            }\n\t            children.splice(idx, 1);\n\t\n\t            child.parent = null;\n\t\n\t            if (storage) {\n\t\n\t                storage.delFromMap(child.id);\n\t\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 移除所有子节点\n\t         */\n\t        removeAll: function () {\n\t            var children = this._children;\n\t            var storage = this.__storage;\n\t            var child;\n\t            var i;\n\t            for (i = 0; i < children.length; i++) {\n\t                child = children[i];\n\t                if (storage) {\n\t                    storage.delFromMap(child.id);\n\t                    if (child instanceof Group) {\n\t                        child.delChildrenFromStorage(storage);\n\t                    }\n\t                }\n\t                child.parent = null;\n\t            }\n\t            children.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 遍历所有子节点\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        eachChild: function (cb, context) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                cb.call(context, child, i);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 深度优先遍历所有子孙节点\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                cb.call(context, child);\n\t\n\t                if (child.type === 'group') {\n\t                    child.traverse(cb, context);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        addChildrenToStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        delChildrenFromStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function (includeChildren) {\n\t            // TODO Caching\n\t            var rect = null;\n\t            var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t            var children = includeChildren || this._children;\n\t            var tmpMat = [];\n\t\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                if (child.ignore || child.invisible) {\n\t                    continue;\n\t                }\n\t\n\t                var childRect = child.getBoundingRect();\n\t                var transform = child.getLocalTransform(tmpMat);\n\t                // TODO\n\t                // The boundingRect cacluated by transforming original\n\t                // rect may be bigger than the actual bundingRect when rotation\n\t                // is used. (Consider a circle rotated aginst its center, where\n\t                // the actual boundingRect should be the same as that not be\n\t                // rotated.) But we can not find better approach to calculate\n\t                // actual boundingRect yet, considering performance.\n\t                if (transform) {\n\t                    tmpRect.copy(childRect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = rect || tmpRect.clone();\n\t                    rect.union(tmpRect);\n\t                }\n\t                else {\n\t                    rect = rect || childRect.clone();\n\t                    rect.union(childRect);\n\t                }\n\t            }\n\t            return rect || tmpRect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Group, Element);\n\t\n\t    module.exports = Group;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/Element\n\t */\n\t\n\t\n\t    var guid = __webpack_require__(4);\n\t    var Eventful = __webpack_require__(9);\n\t    var Transformable = __webpack_require__(13);\n\t    var Animatable = __webpack_require__(16);\n\t    var zrUtil = __webpack_require__(6);\n\t\n\t    /**\n\t     * @alias module:zrender/Element\n\t     * @constructor\n\t     * @extends {module:zrender/mixin/Animatable}\n\t     * @extends {module:zrender/mixin/Transformable}\n\t     * @extends {module:zrender/mixin/Eventful}\n\t     */\n\t    var Element = function (opts) {\n\t\n\t        Transformable.call(this, opts);\n\t        Eventful.call(this, opts);\n\t        Animatable.call(this, opts);\n\t\n\t        /**\n\t         * 画布元素ID\n\t         * @type {string}\n\t         */\n\t        this.id = opts.id || guid();\n\t    };\n\t\n\t    Element.prototype = {\n\t\n\t        /**\n\t         * 元素类型\n\t         * Element type\n\t         * @type {string}\n\t         */\n\t        type: 'element',\n\t\n\t        /**\n\t         * 元素名字\n\t         * Element name\n\t         * @type {string}\n\t         */\n\t        name: '',\n\t\n\t        /**\n\t         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n\t         * ZRender instance will be assigned when element is associated with zrender\n\t         * @name module:/zrender/Element#__zr\n\t         * @type {module:zrender/ZRender}\n\t         */\n\t        __zr: null,\n\t\n\t        /**\n\t         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n\t         * If ignore drawing and events of the element object\n\t         * @name module:/zrender/Element#ignore\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        ignore: false,\n\t\n\t        /**\n\t         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n\t         * 该路径会继承被裁减对象的变换\n\t         * @type {module:zrender/graphic/Path}\n\t         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n\t         * @readOnly\n\t         */\n\t        clipPath: null,\n\t\n\t        /**\n\t         * Drift element\n\t         * @param  {number} dx dx on the global space\n\t         * @param  {number} dy dy on the global space\n\t         */\n\t        drift: function (dx, dy) {\n\t            switch (this.draggable) {\n\t                case 'horizontal':\n\t                    dy = 0;\n\t                    break;\n\t                case 'vertical':\n\t                    dx = 0;\n\t                    break;\n\t            }\n\t\n\t            var m = this.transform;\n\t            if (!m) {\n\t                m = this.transform = [1, 0, 0, 1, 0, 0];\n\t            }\n\t            m[4] += dx;\n\t            m[5] += dy;\n\t\n\t            this.decomposeTransform();\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         * Hook before update\n\t         */\n\t        beforeUpdate: function () {},\n\t        /**\n\t         * Hook after update\n\t         */\n\t        afterUpdate: function () {},\n\t        /**\n\t         * Update each frame\n\t         */\n\t        update: function () {\n\t            this.updateTransform();\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {},\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        attrKV: function (key, value) {\n\t            if (key === 'position' || key === 'scale' || key === 'origin') {\n\t                // Copy the array\n\t                if (value) {\n\t                    var target = this[key];\n\t                    if (!target) {\n\t                        target = this[key] = [];\n\t                    }\n\t                    target[0] = value[0];\n\t                    target[1] = value[1];\n\t                }\n\t            }\n\t            else {\n\t                this[key] = value;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Hide the element\n\t         */\n\t        hide: function () {\n\t            this.ignore = true;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * Show the element\n\t         */\n\t        show: function () {\n\t            this.ignore = false;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * @param {string|Object} key\n\t         * @param {*} value\n\t         */\n\t        attr: function (key, value) {\n\t            if (typeof key === 'string') {\n\t                this.attrKV(key, value);\n\t            }\n\t            else if (zrUtil.isObject(key)) {\n\t                for (var name in key) {\n\t                    if (key.hasOwnProperty(name)) {\n\t                        this.attrKV(name, key[name]);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.dirty(false);\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/graphic/Path} clipPath\n\t         */\n\t        setClipPath: function (clipPath) {\n\t            var zr = this.__zr;\n\t            if (zr) {\n\t                clipPath.addSelfToZr(zr);\n\t            }\n\t\n\t            // Remove previous clip path\n\t            if (this.clipPath && this.clipPath !== clipPath) {\n\t                this.removeClipPath();\n\t            }\n\t\n\t            this.clipPath = clipPath;\n\t            clipPath.__zr = zr;\n\t            clipPath.__clipTarget = this;\n\t\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         */\n\t        removeClipPath: function () {\n\t            var clipPath = this.clipPath;\n\t            if (clipPath) {\n\t                if (clipPath.__zr) {\n\t                    clipPath.removeSelfFromZr(clipPath.__zr);\n\t                }\n\t\n\t                clipPath.__zr = null;\n\t                clipPath.__clipTarget = null;\n\t                this.clipPath = null;\n\t\n\t                this.dirty(false);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        addSelfToZr: function (zr) {\n\t            this.__zr = zr;\n\t            // 添加动画\n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.addAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.addSelfToZr(zr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Remove self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        removeSelfFromZr: function (zr) {\n\t            this.__zr = null;\n\t            // 移除动画\n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.removeAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.removeSelfFromZr(zr);\n\t            }\n\t        }\n\t    };\n\t\n\t    zrUtil.mixin(Element, Animatable);\n\t    zrUtil.mixin(Element, Transformable);\n\t    zrUtil.mixin(Element, Eventful);\n\t\n\t    module.exports = Element;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 提供变换扩展\n\t * @module zrender/mixin/Transformable\n\t * @author pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var matrix = __webpack_require__(14);\n\t    var vector = __webpack_require__(15);\n\t    var mIdentity = matrix.identity;\n\t\n\t    var EPSILON = 5e-5;\n\t\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/mixin/Transformable\n\t     * @constructor\n\t     */\n\t    var Transformable = function (opts) {\n\t        opts = opts || {};\n\t        // If there are no given position, rotation, scale\n\t        if (!opts.position) {\n\t            /**\n\t             * 平移\n\t             * @type {Array.<number>}\n\t             * @default [0, 0]\n\t             */\n\t            this.position = [0, 0];\n\t        }\n\t        if (opts.rotation == null) {\n\t            /**\n\t             * 旋转\n\t             * @type {Array.<number>}\n\t             * @default 0\n\t             */\n\t            this.rotation = 0;\n\t        }\n\t        if (!opts.scale) {\n\t            /**\n\t             * 缩放\n\t             * @type {Array.<number>}\n\t             * @default [1, 1]\n\t             */\n\t            this.scale = [1, 1];\n\t        }\n\t        /**\n\t         * 旋转和缩放的原点\n\t         * @type {Array.<number>}\n\t         * @default null\n\t         */\n\t        this.origin = this.origin || null;\n\t    };\n\t\n\t    var transformableProto = Transformable.prototype;\n\t    transformableProto.transform = null;\n\t\n\t    /**\n\t     * 判断是否需要有坐标变换\n\t     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n\t     */\n\t    transformableProto.needLocalTransform = function () {\n\t        return isNotAroundZero(this.rotation)\n\t            || isNotAroundZero(this.position[0])\n\t            || isNotAroundZero(this.position[1])\n\t            || isNotAroundZero(this.scale[0] - 1)\n\t            || isNotAroundZero(this.scale[1] - 1);\n\t    };\n\t\n\t    transformableProto.updateTransform = function () {\n\t        var parent = this.parent;\n\t        var parentHasTransform = parent && parent.transform;\n\t        var needLocalTransform = this.needLocalTransform();\n\t\n\t        var m = this.transform;\n\t        if (!(needLocalTransform || parentHasTransform)) {\n\t            m && mIdentity(m);\n\t            return;\n\t        }\n\t\n\t        m = m || matrix.create();\n\t\n\t        if (needLocalTransform) {\n\t            this.getLocalTransform(m);\n\t        }\n\t        else {\n\t            mIdentity(m);\n\t        }\n\t\n\t        // 应用父节点变换\n\t        if (parentHasTransform) {\n\t            if (needLocalTransform) {\n\t                matrix.mul(m, parent.transform, m);\n\t            }\n\t            else {\n\t                matrix.copy(m, parent.transform);\n\t            }\n\t        }\n\t        // 保存这个变换矩阵\n\t        this.transform = m;\n\t\n\t        this.invTransform = this.invTransform || matrix.create();\n\t        matrix.invert(this.invTransform, m);\n\t    };\n\t\n\t    transformableProto.getLocalTransform = function (m) {\n\t        m = m || [];\n\t        mIdentity(m);\n\t\n\t        var origin = this.origin;\n\t\n\t        var scale = this.scale;\n\t        var rotation = this.rotation;\n\t        var position = this.position;\n\t        if (origin) {\n\t            // Translate to origin\n\t            m[4] -= origin[0];\n\t            m[5] -= origin[1];\n\t        }\n\t        matrix.scale(m, m, scale);\n\t        if (rotation) {\n\t            matrix.rotate(m, m, rotation);\n\t        }\n\t        if (origin) {\n\t            // Translate back from origin\n\t            m[4] += origin[0];\n\t            m[5] += origin[1];\n\t        }\n\t\n\t        m[4] += position[0];\n\t        m[5] += position[1];\n\t\n\t        return m;\n\t    };\n\t    /**\n\t     * 将自己的transform应用到context上\n\t     * @param {Context2D} ctx\n\t     */\n\t    transformableProto.setTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        if (m) {\n\t            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t        }\n\t        else {\n\t            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t        }\n\t    };\n\t\n\t    transformableProto.restoreTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t    }\n\t\n\t    var tmpTransform = [];\n\t\n\t    /**\n\t     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n\t     */\n\t    transformableProto.decomposeTransform = function () {\n\t        if (!this.transform) {\n\t            return;\n\t        }\n\t        var parent = this.parent;\n\t        var m = this.transform;\n\t        if (parent && parent.transform) {\n\t            // Get local transform and decompose them to position, scale, rotation\n\t            matrix.mul(tmpTransform, parent.invTransform, m);\n\t            m = tmpTransform;\n\t        }\n\t        var sx = m[0] * m[0] + m[1] * m[1];\n\t        var sy = m[2] * m[2] + m[3] * m[3];\n\t        var position = this.position;\n\t        var scale = this.scale;\n\t        if (isNotAroundZero(sx - 1)) {\n\t            sx = Math.sqrt(sx);\n\t        }\n\t        if (isNotAroundZero(sy - 1)) {\n\t            sy = Math.sqrt(sy);\n\t        }\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        position[0] = m[4];\n\t        position[1] = m[5];\n\t        scale[0] = sx;\n\t        scale[1] = sy;\n\t        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t    };\n\t\n\t    /**\n\t     * Get global scale\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.getGlobalScale = function () {\n\t        var m = this.transform;\n\t        if (!m) {\n\t            return [1, 1];\n\t        }\n\t        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        return [sx, sy];\n\t    };\n\t    /**\n\t     * 变换坐标位置到 shape 的局部坐标空间\n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToLocal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var invTransform = this.invTransform;\n\t        if (invTransform) {\n\t            vector.applyTransform(v2, v2, invTransform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    /**\n\t     * 变换局部坐标位置到全局坐标空间\n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToGlobal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var transform = this.transform;\n\t        if (transform) {\n\t            vector.applyTransform(v2, v2, transform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    module.exports = Transformable;\n\t\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t    /**\n\t     * 3x2矩阵操作类\n\t     * @exports zrender/tool/matrix\n\t     */\n\t    var matrix = {\n\t        /**\n\t         * 创建一个单位矩阵\n\t         * @return {Float32Array|Array.<number>}\n\t         */\n\t        create : function() {\n\t            var out = new ArrayCtor(6);\n\t            matrix.identity(out);\n\t\n\t            return out;\n\t        },\n\t        /**\n\t         * 设置矩阵为单位矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         */\n\t        identity : function(out) {\n\t            out[0] = 1;\n\t            out[1] = 0;\n\t            out[2] = 0;\n\t            out[3] = 1;\n\t            out[4] = 0;\n\t            out[5] = 0;\n\t            return out;\n\t        },\n\t        /**\n\t         * 复制矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m\n\t         */\n\t        copy: function(out, m) {\n\t            out[0] = m[0];\n\t            out[1] = m[1];\n\t            out[2] = m[2];\n\t            out[3] = m[3];\n\t            out[4] = m[4];\n\t            out[5] = m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * 矩阵相乘\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m1\n\t         * @param {Float32Array|Array.<number>} m2\n\t         */\n\t        mul : function (out, m1, m2) {\n\t            // Consider matrix.mul(m, m2, m);\n\t            // where out is the same as m2.\n\t            // So use temp variable to escape error.\n\t            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t            out[0] = out0;\n\t            out[1] = out1;\n\t            out[2] = out2;\n\t            out[3] = out3;\n\t            out[4] = out4;\n\t            out[5] = out5;\n\t            return out;\n\t        },\n\t        /**\n\t         * 平移变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        translate : function(out, a, v) {\n\t            out[0] = a[0];\n\t            out[1] = a[1];\n\t            out[2] = a[2];\n\t            out[3] = a[3];\n\t            out[4] = a[4] + v[0];\n\t            out[5] = a[5] + v[1];\n\t            return out;\n\t        },\n\t        /**\n\t         * 旋转变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {number} rad\n\t         */\n\t        rotate : function(out, a, rad) {\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t            var st = Math.sin(rad);\n\t            var ct = Math.cos(rad);\n\t\n\t            out[0] = aa * ct + ab * st;\n\t            out[1] = -aa * st + ab * ct;\n\t            out[2] = ac * ct + ad * st;\n\t            out[3] = -ac * st + ct * ad;\n\t            out[4] = ct * atx + st * aty;\n\t            out[5] = ct * aty - st * atx;\n\t            return out;\n\t        },\n\t        /**\n\t         * 缩放变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        scale : function(out, a, v) {\n\t            var vx = v[0];\n\t            var vy = v[1];\n\t            out[0] = a[0] * vx;\n\t            out[1] = a[1] * vy;\n\t            out[2] = a[2] * vx;\n\t            out[3] = a[3] * vy;\n\t            out[4] = a[4] * vx;\n\t            out[5] = a[5] * vy;\n\t            return out;\n\t        },\n\t        /**\n\t         * 求逆矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         */\n\t        invert : function(out, a) {\n\t\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t\n\t            var det = aa * ad - ab * ac;\n\t            if (!det) {\n\t                return null;\n\t            }\n\t            det = 1.0 / det;\n\t\n\t            out[0] = ad * det;\n\t            out[1] = -ab * det;\n\t            out[2] = -ac * det;\n\t            out[3] = aa * det;\n\t            out[4] = (ac * aty - ad * atx) * det;\n\t            out[5] = (ab * atx - aa * aty) * det;\n\t            return out;\n\t        }\n\t    };\n\t\n\t    module.exports = matrix;\n\t\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t\n\t    /**\n\t     * @typedef {Float32Array|Array.<number>} Vector2\n\t     */\n\t    /**\n\t     * 二维向量类\n\t     * @exports zrender/tool/vector\n\t     */\n\t    var vector = {\n\t        /**\n\t         * 创建一个向量\n\t         * @param {number} [x=0]\n\t         * @param {number} [y=0]\n\t         * @return {Vector2}\n\t         */\n\t        create: function (x, y) {\n\t            var out = new ArrayCtor(2);\n\t            if (x == null) {\n\t                x = 0;\n\t            }\n\t            if (y == null) {\n\t                y = 0;\n\t            }\n\t            out[0] = x;\n\t            out[1] = y;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 复制向量数据\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        copy: function (out, v) {\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 克隆一个向量\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        clone: function (v) {\n\t            var out = new ArrayCtor(2);\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 设置向量的两个项\n\t         * @param {Vector2} out\n\t         * @param {number} a\n\t         * @param {number} b\n\t         * @return {Vector2} 结果\n\t         */\n\t        set: function (out, a, b) {\n\t            out[0] = a;\n\t            out[1] = b;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量相加\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        add: function (out, v1, v2) {\n\t            out[0] = v1[0] + v2[0];\n\t            out[1] = v1[1] + v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量缩放后相加\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} a\n\t         */\n\t        scaleAndAdd: function (out, v1, v2, a) {\n\t            out[0] = v1[0] + v2[0] * a;\n\t            out[1] = v1[1] + v2[1] * a;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量相减\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        sub: function (out, v1, v2) {\n\t            out[0] = v1[0] - v2[0];\n\t            out[1] = v1[1] - v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量长度\n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        len: function (v) {\n\t            return Math.sqrt(this.lenSquare(v));\n\t        },\n\t\n\t        /**\n\t         * 向量长度平方\n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        lenSquare: function (v) {\n\t            return v[0] * v[0] + v[1] * v[1];\n\t        },\n\t\n\t        /**\n\t         * 向量乘法\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        mul: function (out, v1, v2) {\n\t            out[0] = v1[0] * v2[0];\n\t            out[1] = v1[1] * v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量除法\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        div: function (out, v1, v2) {\n\t            out[0] = v1[0] / v2[0];\n\t            out[1] = v1[1] / v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量点乘\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        dot: function (v1, v2) {\n\t            return v1[0] * v2[0] + v1[1] * v2[1];\n\t        },\n\t\n\t        /**\n\t         * 向量缩放\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {number} s\n\t         */\n\t        scale: function (out, v, s) {\n\t            out[0] = v[0] * s;\n\t            out[1] = v[1] * s;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量归一化\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        normalize: function (out, v) {\n\t            var d = vector.len(v);\n\t            if (d === 0) {\n\t                out[0] = 0;\n\t                out[1] = 0;\n\t            }\n\t            else {\n\t                out[0] = v[0] / d;\n\t                out[1] = v[1] / d;\n\t            }\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 计算向量间距离\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distance: function (v1, v2) {\n\t            return Math.sqrt(\n\t                (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n\t            );\n\t        },\n\t\n\t        /**\n\t         * 向量距离平方\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distanceSquare: function (v1, v2) {\n\t            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t        },\n\t\n\t        /**\n\t         * 求负向量\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        negate: function (out, v) {\n\t            out[0] = -v[0];\n\t            out[1] = -v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 插值两个点\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} t\n\t         */\n\t        lerp: function (out, v1, v2, t) {\n\t            out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t            out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 矩阵左乘向量\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {Vector2} m\n\t         */\n\t        applyTransform: function (out, v, m) {\n\t            var x = v[0];\n\t            var y = v[1];\n\t            out[0] = m[0] * x + m[2] * y + m[4];\n\t            out[1] = m[1] * x + m[3] * y + m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * 求两个向量最小值\n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        min: function (out, v1, v2) {\n\t            out[0] = Math.min(v1[0], v2[0]);\n\t            out[1] = Math.min(v1[1], v2[1]);\n\t            return out;\n\t        },\n\t        /**\n\t         * 求两个向量最大值\n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        max: function (out, v1, v2) {\n\t            out[0] = Math.max(v1[0], v2[0]);\n\t            out[1] = Math.max(v1[1], v2[1]);\n\t            return out;\n\t        }\n\t    };\n\t\n\t    vector.length = vector.len;\n\t    vector.lengthSquare = vector.lenSquare;\n\t    vector.dist = vector.distance;\n\t    vector.distSquare = vector.distanceSquare;\n\t\n\t    module.exports = vector;\n\t\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/mixin/Animatable\n\t */\n\t\n\t\n\t    var Animator = __webpack_require__(17);\n\t    var util = __webpack_require__(6);\n\t    var isString = util.isString;\n\t    var isFunction = util.isFunction;\n\t    var isObject = util.isObject;\n\t    var log = __webpack_require__(22);\n\t\n\t    /**\n\t     * @alias modue:zrender/mixin/Animatable\n\t     * @constructor\n\t     */\n\t    var Animatable = function () {\n\t\n\t        /**\n\t         * @type {Array.<module:zrender/animation/Animator>}\n\t         * @readOnly\n\t         */\n\t        this.animators = [];\n\t    };\n\t\n\t    Animatable.prototype = {\n\t\n\t        constructor: Animatable,\n\t\n\t        /**\n\t         * 动画\n\t         *\n\t         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\n\t         * @param {boolean} [loop] 动画是否循环\n\t         * @return {module:zrender/animation/Animator}\n\t         * @example:\n\t         *     el.animate('style', false)\n\t         *         .when(1000, {x: 10} )\n\t         *         .done(function(){ // Animation done })\n\t         *         .start()\n\t         */\n\t        animate: function (path, loop) {\n\t            var target;\n\t            var animatingShape = false;\n\t            var el = this;\n\t            var zr = this.__zr;\n\t            if (path) {\n\t                var pathSplitted = path.split('.');\n\t                var prop = el;\n\t                // If animating shape\n\t                animatingShape = pathSplitted[0] === 'shape';\n\t                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t                    if (!prop) {\n\t                        continue;\n\t                    }\n\t                    prop = prop[pathSplitted[i]];\n\t                }\n\t                if (prop) {\n\t                    target = prop;\n\t                }\n\t            }\n\t            else {\n\t                target = el;\n\t            }\n\t\n\t            if (!target) {\n\t                log(\n\t                    'Property \"'\n\t                    + path\n\t                    + '\" is not existed in element '\n\t                    + el.id\n\t                );\n\t                return;\n\t            }\n\t\n\t            var animators = el.animators;\n\t\n\t            var animator = new Animator(target, loop);\n\t\n\t            animator.during(function (target) {\n\t                el.dirty(animatingShape);\n\t            })\n\t            .done(function () {\n\t                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t                animators.splice(util.indexOf(animators, animator), 1);\n\t            });\n\t\n\t            animators.push(animator);\n\t\n\t            // If animate after added to the zrender\n\t            if (zr) {\n\t                zr.animation.addAnimator(animator);\n\t            }\n\t\n\t            return animator;\n\t        },\n\t\n\t        /**\n\t         * 停止动画\n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stopAnimation: function (forwardToLast) {\n\t            var animators = this.animators;\n\t            var len = animators.length;\n\t            for (var i = 0; i < len; i++) {\n\t                animators[i].stop(forwardToLast);\n\t            }\n\t            animators.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {Object} target\n\t         * @param {number} [time=500] Time in ms\n\t         * @param {string} [easing='linear']\n\t         * @param {number} [delay=0]\n\t         * @param {Function} [callback]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el.animateTo({\n\t         *      position: [10, 10]\n\t         *  }, function () { // done })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n\t         *  el.animateTo({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100, 'cubicOut', function () { // done })\n\t         */\n\t         // TODO Return animation key\n\t        animateTo: function (target, time, delay, easing, callback) {\n\t            // animateTo(target, time, easing, callback);\n\t            if (isString(delay)) {\n\t                callback = easing;\n\t                easing = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, delay, callback);\n\t            else if (isFunction(easing)) {\n\t                callback = easing;\n\t                easing = 'linear';\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, callback);\n\t            else if (isFunction(delay)) {\n\t                callback = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, callback)\n\t            else if (isFunction(time)) {\n\t                callback = time;\n\t                time = 500;\n\t            }\n\t            // animateTo(target)\n\t            else if (!time) {\n\t                time = 500;\n\t            }\n\t            // Stop all previous animations\n\t            this.stopAnimation();\n\t            this._animateToShallow('', this, target, time, delay, easing, callback);\n\t\n\t            // Animators may be removed immediately after start\n\t            // if there is nothing to animate\n\t            var animators = this.animators.slice();\n\t            var count = animators.length;\n\t            function done() {\n\t                count--;\n\t                if (!count) {\n\t                    callback && callback();\n\t                }\n\t            }\n\t\n\t            // No animators. This should be checked before animators[i].start(),\n\t            // because 'done' may be executed immediately if no need to animate.\n\t            if (!count) {\n\t                callback && callback();\n\t            }\n\t            // Start after all animators created\n\t            // Incase any animator is done immediately when all animation properties are not changed\n\t            for (var i = 0; i < animators.length; i++) {\n\t                animators[i]\n\t                    .done(done)\n\t                    .start(easing);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {string} path=''\n\t         * @param {Object} source=this\n\t         * @param {Object} target\n\t         * @param {number} [time=500]\n\t         * @param {number} [delay=0]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el._animateToShallow({\n\t         *      position: [10, 10]\n\t         *  })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms\n\t         *  el._animateToShallow({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100)\n\t         */\n\t        _animateToShallow: function (path, source, target, time, delay) {\n\t            var objShallow = {};\n\t            var propertyCount = 0;\n\t            for (var name in target) {\n\t                if (!target.hasOwnProperty(name)) {\n\t                    continue;\n\t                }\n\t\n\t                if (source[name] != null) {\n\t                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n\t                        this._animateToShallow(\n\t                            path ? path + '.' + name : name,\n\t                            source[name],\n\t                            target[name],\n\t                            time,\n\t                            delay\n\t                        );\n\t                    }\n\t                    else {\n\t                        objShallow[name] = target[name];\n\t                        propertyCount++;\n\t                    }\n\t                }\n\t                else if (target[name] != null) {\n\t                    // Attr directly if not has property\n\t                    // FIXME, if some property not needed for element ?\n\t                    if (!path) {\n\t                        this.attr(name, target[name]);\n\t                    }\n\t                    else {  // Shape or style\n\t                        var props = {};\n\t                        props[path] = {};\n\t                        props[path][name] = target[name];\n\t                        this.attr(props);\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (propertyCount > 0) {\n\t                this.animate(path, false)\n\t                    .when(time == null ? 500 : time, objShallow)\n\t                    .delay(delay || 0);\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    module.exports = Animatable;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/animation/Animator\n\t */\n\t\n\t\n\t    var Clip = __webpack_require__(18);\n\t    var color = __webpack_require__(20);\n\t    var util = __webpack_require__(6);\n\t    var isArrayLike = util.isArrayLike;\n\t\n\t    var arraySlice = Array.prototype.slice;\n\t\n\t    function defaultGetter(target, key) {\n\t        return target[key];\n\t    }\n\t\n\t    function defaultSetter(target, key, value) {\n\t        target[key] = value;\n\t    }\n\t\n\t    /**\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} percent\n\t     * @return {number}\n\t     */\n\t    function interpolateNumber(p0, p1, percent) {\n\t        return (p1 - p0) * percent + p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {string} p0\n\t     * @param  {string} p1\n\t     * @param  {number} percent\n\t     * @return {string}\n\t     */\n\t    function interpolateString(p0, p1, percent) {\n\t        return percent > 0.5 ? p1 : p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {number} percent\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function interpolateArray(p0, p1, percent, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = interpolateNumber(\n\t                        p0[i][j], p1[i][j], percent\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    // arr0 is source array, arr1 is target array.\n\t    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t    function fillArr(arr0, arr1, arrDim) {\n\t        var arr0Len = arr0.length;\n\t        var arr1Len = arr1.length;\n\t        if (arr0Len !== arr1Len) {\n\t            // FIXME Not work for TypedArray\n\t            var isPreviousLarger = arr0Len > arr1Len;\n\t            if (isPreviousLarger) {\n\t                // Cut the previous\n\t                arr0.length = arr1Len;\n\t            }\n\t            else {\n\t                // Fill the previous\n\t                for (var i = arr0Len; i < arr1Len; i++) {\n\t                    arr0.push(\n\t                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n\t                    );\n\t                }\n\t            }\n\t        }\n\t        // Handling NaN value\n\t        var len2 = arr0[0] && arr0[0].length;\n\t        for (var i = 0; i < arr0.length; i++) {\n\t            if (arrDim === 1) {\n\t                if (isNaN(arr0[i])) {\n\t                    arr0[i] = arr1[i];\n\t                }\n\t            }\n\t            else {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (isNaN(arr0[i][j])) {\n\t                        arr0[i][j] = arr1[i][j];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} arr0\n\t     * @param  {Array} arr1\n\t     * @param  {number} arrDim\n\t     * @return {boolean}\n\t     */\n\t    function isArraySame(arr0, arr1, arrDim) {\n\t        if (arr0 === arr1) {\n\t            return true;\n\t        }\n\t        var len = arr0.length;\n\t        if (len !== arr1.length) {\n\t            return false;\n\t        }\n\t        if (arrDim === 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                if (arr0[i] !== arr1[i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var len2 = arr0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (arr0[i][j] !== arr1[i][j]) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate array\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {Array} p2\n\t     * @param  {Array} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function catmullRomInterpolateArray(\n\t        p0, p1, p2, p3, t, t2, t3, out, arrDim\n\t    ) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = catmullRomInterpolate(\n\t                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n\t                );\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = catmullRomInterpolate(\n\t                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n\t                        t, t2, t3\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate number\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @return {number}\n\t     */\n\t    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    function cloneValue(value) {\n\t        if (isArrayLike(value)) {\n\t            var len = value.length;\n\t            if (isArrayLike(value[0])) {\n\t                var ret = [];\n\t                for (var i = 0; i < len; i++) {\n\t                    ret.push(arraySlice.call(value[i]));\n\t                }\n\t                return ret;\n\t            }\n\t\n\t            return arraySlice.call(value);\n\t        }\n\t\n\t        return value;\n\t    }\n\t\n\t    function rgba2String(rgba) {\n\t        rgba[0] = Math.floor(rgba[0]);\n\t        rgba[1] = Math.floor(rgba[1]);\n\t        rgba[2] = Math.floor(rgba[2]);\n\t\n\t        return 'rgba(' + rgba.join(',') + ')';\n\t    }\n\t\n\t    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n\t        var getter = animator._getter;\n\t        var setter = animator._setter;\n\t        var useSpline = easing === 'spline';\n\t\n\t        var trackLen = keyframes.length;\n\t        if (!trackLen) {\n\t            return;\n\t        }\n\t        // Guess data type\n\t        var firstVal = keyframes[0].value;\n\t        var isValueArray = isArrayLike(firstVal);\n\t        var isValueColor = false;\n\t        var isValueString = false;\n\t\n\t        // For vertices morphing\n\t        var arrDim = (\n\t                isValueArray\n\t                && isArrayLike(firstVal[0])\n\t            )\n\t            ? 2 : 1;\n\t        var trackMaxTime;\n\t        // Sort keyframe as ascending\n\t        keyframes.sort(function(a, b) {\n\t            return a.time - b.time;\n\t        });\n\t\n\t        trackMaxTime = keyframes[trackLen - 1].time;\n\t        // Percents of each keyframe\n\t        var kfPercents = [];\n\t        // Value of each keyframe\n\t        var kfValues = [];\n\t        var prevValue = keyframes[0].value;\n\t        var isAllValueEqual = true;\n\t        for (var i = 0; i < trackLen; i++) {\n\t            kfPercents.push(keyframes[i].time / trackMaxTime);\n\t            // Assume value is a color when it is a string\n\t            var value = keyframes[i].value;\n\t\n\t            // Check if value is equal, deep check if value is array\n\t            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n\t                || (!isValueArray && value === prevValue))) {\n\t                isAllValueEqual = false;\n\t            }\n\t            prevValue = value;\n\t\n\t            // Try converting a string to a color array\n\t            if (typeof value == 'string') {\n\t                var colorArray = color.parse(value);\n\t                if (colorArray) {\n\t                    value = colorArray;\n\t                    isValueColor = true;\n\t                }\n\t                else {\n\t                    isValueString = true;\n\t                }\n\t            }\n\t            kfValues.push(value);\n\t        }\n\t        if (isAllValueEqual) {\n\t            return;\n\t        }\n\t\n\t        var lastValue = kfValues[trackLen - 1];\n\t        // Polyfill array and NaN value\n\t        for (var i = 0; i < trackLen - 1; i++) {\n\t            if (isValueArray) {\n\t                fillArr(kfValues[i], lastValue, arrDim);\n\t            }\n\t            else {\n\t                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t                    kfValues[i] = lastValue;\n\t                }\n\t            }\n\t        }\n\t        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\t\n\t        // Cache the key of last frame to speed up when\n\t        // animation playback is sequency\n\t        var lastFrame = 0;\n\t        var lastFramePercent = 0;\n\t        var start;\n\t        var w;\n\t        var p0;\n\t        var p1;\n\t        var p2;\n\t        var p3;\n\t\n\t        if (isValueColor) {\n\t            var rgba = [0, 0, 0, 0];\n\t        }\n\t\n\t        var onframe = function (target, percent) {\n\t            // Find the range keyframes\n\t            // kf1-----kf2---------current--------kf3\n\t            // find kf2 and kf3 and do interpolation\n\t            var frame;\n\t            // In the easing function like elasticOut, percent may less than 0\n\t            if (percent < 0) {\n\t                frame = 0;\n\t            }\n\t            else if (percent < lastFramePercent) {\n\t                // Start from next key\n\t                // PENDING start from lastFrame ?\n\t                start = Math.min(lastFrame + 1, trackLen - 1);\n\t                for (frame = start; frame >= 0; frame--) {\n\t                    if (kfPercents[frame] <= percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                // PENDING really need to do this ?\n\t                frame = Math.min(frame, trackLen - 2);\n\t            }\n\t            else {\n\t                for (frame = lastFrame; frame < trackLen; frame++) {\n\t                    if (kfPercents[frame] > percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                frame = Math.min(frame - 1, trackLen - 2);\n\t            }\n\t            lastFrame = frame;\n\t            lastFramePercent = percent;\n\t\n\t            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n\t            if (range === 0) {\n\t                return;\n\t            }\n\t            else {\n\t                w = (percent - kfPercents[frame]) / range;\n\t            }\n\t            if (useSpline) {\n\t                p1 = kfValues[frame];\n\t                p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t                if (isValueArray) {\n\t                    catmullRomInterpolateArray(\n\t                        p0, p1, p2, p3, w, w * w, w * w * w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        value = catmullRomInterpolateArray(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(p1, p2, w);\n\t                    }\n\t                    else {\n\t                        value = catmullRomInterpolate(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w\n\t                        );\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t            else {\n\t                if (isValueArray) {\n\t                    interpolateArray(\n\t                        kfValues[frame], kfValues[frame + 1], w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        interpolateArray(\n\t                            kfValues[frame], kfValues[frame + 1], w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    else {\n\t                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t        };\n\t\n\t        var clip = new Clip({\n\t            target: animator._target,\n\t            life: trackMaxTime,\n\t            loop: animator._loop,\n\t            delay: animator._delay,\n\t            onframe: onframe,\n\t            ondestroy: oneTrackDone\n\t        });\n\t\n\t        if (easing && easing !== 'spline') {\n\t            clip.easing = easing;\n\t        }\n\t\n\t        return clip;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animator\n\t     * @constructor\n\t     * @param {Object} target\n\t     * @param {boolean} loop\n\t     * @param {Function} getter\n\t     * @param {Function} setter\n\t     */\n\t    var Animator = function(target, loop, getter, setter) {\n\t        this._tracks = {};\n\t        this._target = target;\n\t\n\t        this._loop = loop || false;\n\t\n\t        this._getter = getter || defaultGetter;\n\t        this._setter = setter || defaultSetter;\n\t\n\t        this._clipCount = 0;\n\t\n\t        this._delay = 0;\n\t\n\t        this._doneList = [];\n\t\n\t        this._onframeList = [];\n\t\n\t        this._clipList = [];\n\t    };\n\t\n\t    Animator.prototype = {\n\t        /**\n\t         * 设置动画关键帧\n\t         * @param  {number} time 关键帧时间，单位是ms\n\t         * @param  {Object} props 关键帧的属性值，key-value表示\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        when: function(time /* ms */, props) {\n\t            var tracks = this._tracks;\n\t            for (var propName in props) {\n\t                if (!props.hasOwnProperty(propName)) {\n\t                    continue;\n\t                }\n\t\n\t                if (!tracks[propName]) {\n\t                    tracks[propName] = [];\n\t                    // Invalid value\n\t                    var value = this._getter(this._target, propName);\n\t                    if (value == null) {\n\t                        // zrLog('Invalid property ' + propName);\n\t                        continue;\n\t                    }\n\t                    // If time is 0\n\t                    //  Then props is given initialize value\n\t                    // Else\n\t                    //  Initialize value from current prop value\n\t                    if (time !== 0) {\n\t                        tracks[propName].push({\n\t                            time: 0,\n\t                            value: cloneValue(value)\n\t                        });\n\t                    }\n\t                }\n\t                tracks[propName].push({\n\t                    time: time,\n\t                    value: props[propName]\n\t                });\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * 添加动画每一帧的回调函数\n\t         * @param  {Function} callback\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        during: function (callback) {\n\t            this._onframeList.push(callback);\n\t            return this;\n\t        },\n\t\n\t        pause: function () {\n\t            for (var i = 0; i < this._clipList.length; i++) {\n\t                this._clipList[i].pause();\n\t            }\n\t            this._paused = true;\n\t        },\n\t\n\t        resume: function () {\n\t            for (var i = 0; i < this._clipList.length; i++) {\n\t                this._clipList[i].resume();\n\t            }\n\t            this._paused = false;\n\t        },\n\t\n\t        isPaused: function () {\n\t            return !!this._paused;\n\t        },\n\t\n\t        _doneCallback: function () {\n\t            // Clear all tracks\n\t            this._tracks = {};\n\t            // Clear all clips\n\t            this._clipList.length = 0;\n\t\n\t            var doneList = this._doneList;\n\t            var len = doneList.length;\n\t            for (var i = 0; i < len; i++) {\n\t                doneList[i].call(this);\n\t            }\n\t        },\n\t        /**\n\t         * 开始执行动画\n\t         * @param  {string|Function} easing\n\t         *         动画缓动函数，详见{@link module:zrender/animation/easing}\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        start: function (easing) {\n\t\n\t            var self = this;\n\t            var clipCount = 0;\n\t\n\t            var oneTrackDone = function() {\n\t                clipCount--;\n\t                if (!clipCount) {\n\t                    self._doneCallback();\n\t                }\n\t            };\n\t\n\t            var lastClip;\n\t            for (var propName in this._tracks) {\n\t                if (!this._tracks.hasOwnProperty(propName)) {\n\t                    continue;\n\t                }\n\t                var clip = createTrackClip(\n\t                    this, easing, oneTrackDone,\n\t                    this._tracks[propName], propName\n\t                );\n\t                if (clip) {\n\t                    this._clipList.push(clip);\n\t                    clipCount++;\n\t\n\t                    // If start after added to animation\n\t                    if (this.animation) {\n\t                        this.animation.addClip(clip);\n\t                    }\n\t\n\t                    lastClip = clip;\n\t                }\n\t            }\n\t\n\t            // Add during callback on the last clip\n\t            if (lastClip) {\n\t                var oldOnFrame = lastClip.onframe;\n\t                lastClip.onframe = function (target, percent) {\n\t                    oldOnFrame(target, percent);\n\t\n\t                    for (var i = 0; i < self._onframeList.length; i++) {\n\t                        self._onframeList[i](target, percent);\n\t                    }\n\t                };\n\t            }\n\t\n\t            if (!clipCount) {\n\t                this._doneCallback();\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * 停止动画\n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stop: function (forwardToLast) {\n\t            var clipList = this._clipList;\n\t            var animation = this.animation;\n\t            for (var i = 0; i < clipList.length; i++) {\n\t                var clip = clipList[i];\n\t                if (forwardToLast) {\n\t                    // Move to last frame before stop\n\t                    clip.onframe(this._target, 1);\n\t                }\n\t                animation && animation.removeClip(clip);\n\t            }\n\t            clipList.length = 0;\n\t        },\n\t        /**\n\t         * 设置动画延迟开始的时间\n\t         * @param  {number} time 单位ms\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        delay: function (time) {\n\t            this._delay = time;\n\t            return this;\n\t        },\n\t        /**\n\t         * 添加动画结束的回调\n\t         * @param  {Function} cb\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        done: function(cb) {\n\t            if (cb) {\n\t                this._doneList.push(cb);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/animation/Clip>}\n\t         */\n\t        getClips: function () {\n\t            return this._clipList;\n\t        }\n\t    };\n\t\n\t    module.exports = Animator;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 动画主控制器\n\t * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n\t * @config life(1000) 动画时长\n\t * @config delay(0) 动画延迟时间\n\t * @config loop(true)\n\t * @config gap(0) 循环的间隔时间\n\t * @config onframe\n\t * @config easing(optional)\n\t * @config ondestroy(optional)\n\t * @config onrestart(optional)\n\t *\n\t * TODO pause\n\t */\n\t\n\t\n\t    var easingFuncs = __webpack_require__(19);\n\t\n\t    function Clip(options) {\n\t\n\t        this._target = options.target;\n\t\n\t        // 生命周期\n\t        this._life = options.life || 1000;\n\t        // 延时\n\t        this._delay = options.delay || 0;\n\t        // 开始时间\n\t        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n\t        this._initialized = false;\n\t\n\t        // 是否循环\n\t        this.loop = options.loop == null ? false : options.loop;\n\t\n\t        this.gap = options.gap || 0;\n\t\n\t        this.easing = options.easing || 'Linear';\n\t\n\t        this.onframe = options.onframe;\n\t        this.ondestroy = options.ondestroy;\n\t        this.onrestart = options.onrestart;\n\t\n\t        this._pausedTime = 0;\n\t        this._paused = false;\n\t    }\n\t\n\t    Clip.prototype = {\n\t\n\t        constructor: Clip,\n\t\n\t        step: function (globalTime, deltaTime) {\n\t            // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t            // PENDING\n\t            if (!this._initialized) {\n\t                this._startTime = globalTime + this._delay;\n\t                this._initialized = true;\n\t            }\n\t\n\t            if (this._paused) {\n\t                this._pausedTime += deltaTime;\n\t                return;\n\t            }\n\t\n\t            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n\t\n\t            // 还没开始\n\t            if (percent < 0) {\n\t                return;\n\t            }\n\t\n\t            percent = Math.min(percent, 1);\n\t\n\t            var easing = this.easing;\n\t            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t            var schedule = typeof easingFunc === 'function'\n\t                ? easingFunc(percent)\n\t                : percent;\n\t\n\t            this.fire('frame', schedule);\n\t\n\t            // 结束\n\t            if (percent == 1) {\n\t                if (this.loop) {\n\t                    this.restart (globalTime);\n\t                    // 重新开始周期\n\t                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\t                    return 'restart';\n\t                }\n\t\n\t                // 动画完成将这个控制器标识为待删除\n\t                // 在Animation.update中进行批量删除\n\t                this._needsRemove = true;\n\t                return 'destroy';\n\t            }\n\t\n\t            return null;\n\t        },\n\t\n\t        restart: function (globalTime) {\n\t            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n\t            this._startTime = globalTime - remainder + this.gap;\n\t            this._pausedTime = 0;\n\t\n\t            this._needsRemove = false;\n\t        },\n\t\n\t        fire: function (eventType, arg) {\n\t            eventType = 'on' + eventType;\n\t            if (this[eventType]) {\n\t                this[eventType](this._target, arg);\n\t            }\n\t        },\n\t\n\t        pause: function () {\n\t            this._paused = true;\n\t        },\n\t\n\t        resume: function () {\n\t            this._paused = false;\n\t        }\n\t    };\n\t\n\t    module.exports = Clip;\n\t\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t/**\n\t * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n\t * @see http://sole.github.io/tween.js/examples/03_graphs.html\n\t * @exports zrender/animation/easing\n\t */\n\t\n\t    var easing = {\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        linear: function (k) {\n\t            return k;\n\t        },\n\t\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticIn: function (k) {\n\t            return k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticOut: function (k) {\n\t            return k * (2 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k;\n\t            }\n\t            return -0.5 * (--k * (k - 2) - 1);\n\t        },\n\t\n\t        // 三次方的缓动（t^3）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicIn: function (k) {\n\t            return k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicOut: function (k) {\n\t            return --k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k + 2);\n\t        },\n\t\n\t        // 四次方的缓动（t^4）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticIn: function (k) {\n\t            return k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticOut: function (k) {\n\t            return 1 - (--k * k * k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k;\n\t            }\n\t            return -0.5 * ((k -= 2) * k * k * k - 2);\n\t        },\n\t\n\t        // 五次方的缓动（t^5）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticIn: function (k) {\n\t            return k * k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticOut: function (k) {\n\t            return --k * k * k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t        },\n\t\n\t        // 正弦曲线的缓动（sin(t)）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalIn: function (k) {\n\t            return 1 - Math.cos(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalOut: function (k) {\n\t            return Math.sin(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalInOut: function (k) {\n\t            return 0.5 * (1 - Math.cos(Math.PI * k));\n\t        },\n\t\n\t        // 指数曲线的缓动（2^t）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialIn: function (k) {\n\t            return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialOut: function (k) {\n\t            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialInOut: function (k) {\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * Math.pow(1024, k - 1);\n\t            }\n\t            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t        },\n\t\n\t        // 圆形曲线的缓动（sqrt(1-t^2)）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularIn: function (k) {\n\t            return 1 - Math.sqrt(1 - k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularOut: function (k) {\n\t            return Math.sqrt(1 - (--k * k));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t            }\n\t            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t        },\n\t\n\t        // 创建类似于弹簧在停止前来回振荡的动画\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticIn: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return -(a * Math.pow(2, 10 * (k -= 1)) *\n\t                        Math.sin((k - s) * (2 * Math.PI) / p));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return (a * Math.pow(2, -10 * k) *\n\t                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticInOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p));\n\t            }\n\t            return a * Math.pow(2, -10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\n\t        },\n\t\n\t        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backIn: function (k) {\n\t            var s = 1.70158;\n\t            return k * k * ((s + 1) * k - s);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backOut: function (k) {\n\t            var s = 1.70158;\n\t            return --k * k * ((s + 1) * k + s) + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backInOut: function (k) {\n\t            var s = 1.70158 * 1.525;\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * (k * k * ((s + 1) * k - s));\n\t            }\n\t            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t        },\n\t\n\t        // 创建弹跳效果\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceIn: function (k) {\n\t            return 1 - easing.bounceOut(1 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceOut: function (k) {\n\t            if (k < (1 / 2.75)) {\n\t                return 7.5625 * k * k;\n\t            }\n\t            else if (k < (2 / 2.75)) {\n\t                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t            }\n\t            else if (k < (2.5 / 2.75)) {\n\t                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t            }\n\t            else {\n\t                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t            }\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceInOut: function (k) {\n\t            if (k < 0.5) {\n\t                return easing.bounceIn(k * 2) * 0.5;\n\t            }\n\t            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t        }\n\t    };\n\t\n\t    module.exports = easing;\n\t\n\t\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/tool/color\n\t */\n\t\n\t\n\t    var LRU = __webpack_require__(21);\n\t\n\t    var kCSSColorTable = {\n\t        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n\t        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n\t        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n\t        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n\t        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n\t        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n\t        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n\t        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n\t        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n\t        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n\t        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n\t        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n\t        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n\t        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n\t        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n\t        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n\t        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n\t        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n\t        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n\t        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n\t        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n\t        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n\t        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n\t        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n\t        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n\t        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n\t        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n\t        'gray': [128,128,128,1], 'green': [0,128,0,1],\n\t        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n\t        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n\t        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n\t        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n\t        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n\t        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n\t        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n\t        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n\t        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n\t        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n\t        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n\t        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n\t        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n\t        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n\t        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n\t        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n\t        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n\t        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n\t        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n\t        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n\t        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n\t        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n\t        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n\t        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n\t        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n\t        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n\t        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n\t        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n\t        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n\t        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n\t        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n\t        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n\t        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n\t        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n\t        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n\t        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n\t        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n\t        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n\t        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n\t        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n\t        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n\t        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n\t        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n\t        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n\t        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n\t        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n\t    };\n\t\n\t    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 255 ? 255 : i;\n\t    }\n\t\n\t    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 360 ? 360 : i;\n\t    }\n\t\n\t    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n\t        return f < 0 ? 0 : f > 1 ? 1 : f;\n\t    }\n\t\n\t    function parseCssInt(str) {  // int or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssByte(parseFloat(str) / 100 * 255);\n\t        }\n\t        return clampCssByte(parseInt(str, 10));\n\t    }\n\t\n\t    function parseCssFloat(str) {  // float or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssFloat(parseFloat(str) / 100);\n\t        }\n\t        return clampCssFloat(parseFloat(str));\n\t    }\n\t\n\t    function cssHueToRgb(m1, m2, h) {\n\t        if (h < 0) {\n\t            h += 1;\n\t        }\n\t        else if (h > 1) {\n\t            h -= 1;\n\t        }\n\t\n\t        if (h * 6 < 1) {\n\t            return m1 + (m2 - m1) * h * 6;\n\t        }\n\t        if (h * 2 < 1) {\n\t            return m2;\n\t        }\n\t        if (h * 3 < 2) {\n\t            return m1 + (m2 - m1) * (2/3 - h) * 6;\n\t        }\n\t        return m1;\n\t    }\n\t\n\t    function lerp(a, b, p) {\n\t        return a + (b - a) * p;\n\t    }\n\t\n\t    function setRgba(out, r, g, b, a) {\n\t        out[0] = r; out[1] = g; out[2] = b; out[3] = a;\n\t        return out;\n\t    }\n\t    function copyRgba(out, a) {\n\t        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n\t        return out;\n\t    }\n\t    var colorCache = new LRU(20);\n\t    var lastRemovedArr = null;\n\t    function putToCache(colorStr, rgbaArr) {\n\t        // Reuse removed array\n\t        if (lastRemovedArr) {\n\t            copyRgba(lastRemovedArr, rgbaArr);\n\t        }\n\t        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n\t    }\n\t    /**\n\t     * @param {string} colorStr\n\t     * @param {Array.<number>} out\n\t     * @return {Array.<number>}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function parse(colorStr, rgbaArr) {\n\t        if (!colorStr) {\n\t            return;\n\t        }\n\t        rgbaArr = rgbaArr || [];\n\t\n\t        var cached = colorCache.get(colorStr);\n\t        if (cached) {\n\t            return copyRgba(rgbaArr, cached);\n\t        }\n\t\n\t        // colorStr may be not string\n\t        colorStr = colorStr + '';\n\t        // Remove all whitespace, not compliant, but should just be more accepting.\n\t        var str = colorStr.replace(/ /g, '').toLowerCase();\n\t\n\t        // Color keywords (and transparent) lookup.\n\t        if (str in kCSSColorTable) {\n\t            copyRgba(rgbaArr, kCSSColorTable[str]);\n\t            putToCache(colorStr, rgbaArr);\n\t            return rgbaArr;\n\t        }\n\t\n\t        // #abc and #abc123 syntax.\n\t        if (str.charAt(0) === '#') {\n\t            if (str.length === 4) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xfff)) {\n\t                    setRgba(rgbaArr, 0, 0, 0, 1);\n\t                    return;  // Covers NaN.\n\t                }\n\t                setRgba(rgbaArr,\n\t                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n\t                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n\t                    (iv & 0xf) | ((iv & 0xf) << 4),\n\t                    1\n\t                );\n\t                putToCache(colorStr, rgbaArr);\n\t                return rgbaArr;\n\t            }\n\t            else if (str.length === 7) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xffffff)) {\n\t                    setRgba(rgbaArr, 0, 0, 0, 1);\n\t                    return;  // Covers NaN.\n\t                }\n\t                setRgba(rgbaArr,\n\t                    (iv & 0xff0000) >> 16,\n\t                    (iv & 0xff00) >> 8,\n\t                    iv & 0xff,\n\t                    1\n\t                );\n\t                putToCache(colorStr, rgbaArr);\n\t                return rgbaArr;\n\t            }\n\t\n\t            return;\n\t        }\n\t        var op = str.indexOf('('), ep = str.indexOf(')');\n\t        if (op !== -1 && ep + 1 === str.length) {\n\t            var fname = str.substr(0, op);\n\t            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t            var alpha = 1;  // To allow case fallthrough.\n\t            switch (fname) {\n\t                case 'rgba':\n\t                    if (params.length !== 4) {\n\t                        setRgba(rgbaArr, 0, 0, 0, 1);\n\t                        return;\n\t                    }\n\t                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n\t                // Fall through.\n\t                case 'rgb':\n\t                    if (params.length !== 3) {\n\t                        setRgba(rgbaArr, 0, 0, 0, 1);\n\t                        return;\n\t                    }\n\t                    setRgba(rgbaArr,\n\t                        parseCssInt(params[0]),\n\t                        parseCssInt(params[1]),\n\t                        parseCssInt(params[2]),\n\t                        alpha\n\t                    );\n\t                    putToCache(colorStr, rgbaArr);\n\t                    return rgbaArr;\n\t                case 'hsla':\n\t                    if (params.length !== 4) {\n\t                        setRgba(rgbaArr, 0, 0, 0, 1);\n\t                        return;\n\t                    }\n\t                    params[3] = parseCssFloat(params[3]);\n\t                    hsla2rgba(params, rgbaArr);\n\t                    putToCache(colorStr, rgbaArr);\n\t                    return rgbaArr;\n\t                case 'hsl':\n\t                    if (params.length !== 3) {\n\t                        setRgba(rgbaArr, 0, 0, 0, 1);\n\t                        return;\n\t                    }\n\t                    hsla2rgba(params, rgbaArr);\n\t                    putToCache(colorStr, rgbaArr);\n\t                    return rgbaArr;\n\t                default:\n\t                    return;\n\t            }\n\t        }\n\t\n\t        setRgba(rgbaArr, 0, 0, 0, 1);\n\t        return;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} hsla\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} rgba\n\t     */\n\t    function hsla2rgba(hsla, rgba) {\n\t        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n\t        // NOTE(deanm): According to the CSS spec s/l should only be\n\t        // percentages, but we don't bother and let float or percentage.\n\t        var s = parseCssFloat(hsla[1]);\n\t        var l = parseCssFloat(hsla[2]);\n\t        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t        var m1 = l * 2 - m2;\n\t\n\t        rgba = rgba || [];\n\t        setRgba(rgba,\n\t            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),\n\t            1\n\t        );\n\t\n\t        if (hsla.length === 4) {\n\t            rgba[3] = hsla[3];\n\t        }\n\t\n\t        return rgba;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} hsla\n\t     */\n\t    function rgba2hsla(rgba) {\n\t        if (!rgba) {\n\t            return;\n\t        }\n\t\n\t        // RGB from 0 to 255\n\t        var R = rgba[0] / 255;\n\t        var G = rgba[1] / 255;\n\t        var B = rgba[2] / 255;\n\t\n\t        var vMin = Math.min(R, G, B); // Min. value of RGB\n\t        var vMax = Math.max(R, G, B); // Max. value of RGB\n\t        var delta = vMax - vMin; // Delta RGB value\n\t\n\t        var L = (vMax + vMin) / 2;\n\t        var H;\n\t        var S;\n\t        // HSL results from 0 to 1\n\t        if (delta === 0) {\n\t            H = 0;\n\t            S = 0;\n\t        }\n\t        else {\n\t            if (L < 0.5) {\n\t                S = delta / (vMax + vMin);\n\t            }\n\t            else {\n\t                S = delta / (2 - vMax - vMin);\n\t            }\n\t\n\t            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n\t            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n\t            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\t\n\t            if (R === vMax) {\n\t                H = deltaB - deltaG;\n\t            }\n\t            else if (G === vMax) {\n\t                H = (1 / 3) + deltaR - deltaB;\n\t            }\n\t            else if (B === vMax) {\n\t                H = (2 / 3) + deltaG - deltaR;\n\t            }\n\t\n\t            if (H < 0) {\n\t                H += 1;\n\t            }\n\t\n\t            if (H > 1) {\n\t                H -= 1;\n\t            }\n\t        }\n\t\n\t        var hsla = [H * 360, S, L];\n\t\n\t        if (rgba[3] != null) {\n\t            hsla.push(rgba[3]);\n\t        }\n\t\n\t        return hsla;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number} level\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function lift(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            for (var i = 0; i < 3; i++) {\n\t                if (level < 0) {\n\t                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t                }\n\t                else {\n\t                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n\t                }\n\t            }\n\t            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function toHex(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<Array.<number>>} colors List of rgba color array\n\t     * @param {Array.<number>} [out] Mapped gba color array\n\t     * @return {Array.<number>}\n\t     */\n\t    function fastMapToColor(normalizedValue, colors, out) {\n\t        out = out || [0, 0, 0, 0];\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return out;\n\t        }\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = colors[leftIndex];\n\t        var rightColor = colors[rightIndex];\n\t        var dv = value - leftIndex;\n\t        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n\t        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n\t        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n\t        out[3] = clampCssFloat(lerp(leftColor[3], rightColor[3], dv));\n\t        return out;\n\t    }\n\t    /**\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {boolean=} fullOutput Default false.\n\t     * @return {(string|Object)} Result color. If fullOutput,\n\t     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function mapToColor(normalizedValue, colors, fullOutput) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = parse(colors[leftIndex]);\n\t        var rightColor = parse(colors[rightIndex]);\n\t        var dv = value - leftIndex;\n\t\n\t        var color = stringify(\n\t            [\n\t                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n\t                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n\t                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n\t                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n\t            ],\n\t            'rgba'\n\t        );\n\t\n\t        return fullOutput\n\t            ? {\n\t                color: color,\n\t                leftIndex: leftIndex,\n\t                rightIndex: rightIndex,\n\t                value: value\n\t            }\n\t            : color;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} h 0 ~ 360, ignore when null.\n\t     * @param {number=} s 0 ~ 1, ignore when null.\n\t     * @param {number=} l 0 ~ 1, ignore when null.\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyHSL(color, h, s, l) {\n\t        color = parse(color);\n\t\n\t        if (color) {\n\t            color = rgba2hsla(color);\n\t            h != null && (color[0] = clampCssAngle(h));\n\t            s != null && (color[1] = parseCssFloat(s));\n\t            l != null && (color[2] = parseCssFloat(l));\n\t\n\t            return stringify(hsla2rgba(color), 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} alpha 0 ~ 1\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyAlpha(color, alpha) {\n\t        color = parse(color);\n\t\n\t        if (color && alpha != null) {\n\t            color[3] = clampCssFloat(alpha);\n\t            return stringify(color, 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {string} type 'rgba', 'hsva', ...\n\t     * @return {string} Result color. (If input illegal, return undefined).\n\t     */\n\t    function stringify(arrColor, type) {\n\t        if (!arrColor) {\n\t            return;\n\t        }\n\t        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t            colorStr += ',' + arrColor[3];\n\t        }\n\t        return type + '(' + colorStr + ')';\n\t    }\n\t\n\t    module.exports = {\n\t        parse: parse,\n\t        lift: lift,\n\t        toHex: toHex,\n\t        fastMapToColor: fastMapToColor,\n\t        mapToColor: mapToColor,\n\t        modifyHSL: modifyHSL,\n\t        modifyAlpha: modifyAlpha,\n\t        stringify: stringify\n\t    };\n\t\n\t\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t// Simple LRU cache use doubly linked list\n\t// @module zrender/core/LRU\n\t\n\t\n\t    /**\n\t     * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t     * @constructor\n\t     */\n\t    var LinkedList = function () {\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.head = null;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.tail = null;\n\t\n\t        this._len = 0;\n\t    };\n\t\n\t    var linkedListProto = LinkedList.prototype;\n\t    /**\n\t     * Insert a new value at the tail\n\t     * @param  {} val\n\t     * @return {module:zrender/core/LRU~Entry}\n\t     */\n\t    linkedListProto.insert = function (val) {\n\t        var entry = new Entry(val);\n\t        this.insertEntry(entry);\n\t        return entry;\n\t    };\n\t\n\t    /**\n\t     * Insert an entry at the tail\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.insertEntry = function (entry) {\n\t        if (!this.head) {\n\t            this.head = this.tail = entry;\n\t        }\n\t        else {\n\t            this.tail.next = entry;\n\t            entry.prev = this.tail;\n\t            entry.next = null;\n\t            this.tail = entry;\n\t        }\n\t        this._len++;\n\t    };\n\t\n\t    /**\n\t     * Remove entry.\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.remove = function (entry) {\n\t        var prev = entry.prev;\n\t        var next = entry.next;\n\t        if (prev) {\n\t            prev.next = next;\n\t        }\n\t        else {\n\t            // Is head\n\t            this.head = next;\n\t        }\n\t        if (next) {\n\t            next.prev = prev;\n\t        }\n\t        else {\n\t            // Is tail\n\t            this.tail = prev;\n\t        }\n\t        entry.next = entry.prev = null;\n\t        this._len--;\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    linkedListProto.len = function () {\n\t        return this._len;\n\t    };\n\t\n\t    /**\n\t     * Clear list\n\t     */\n\t    linkedListProto.clear = function () {\n\t        this.head = this.tail = null;\n\t        this._len = 0;\n\t    };\n\t\n\t    /**\n\t     * @constructor\n\t     * @param {} val\n\t     */\n\t    var Entry = function (val) {\n\t        /**\n\t         * @type {}\n\t         */\n\t        this.value = val;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.next;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.prev;\n\t    };\n\t\n\t    /**\n\t     * LRU Cache\n\t     * @constructor\n\t     * @alias module:zrender/core/LRU\n\t     */\n\t    var LRU = function (maxSize) {\n\t\n\t        this._list = new LinkedList();\n\t\n\t        this._map = {};\n\t\n\t        this._maxSize = maxSize || 10;\n\t\n\t        this._lastRemovedEntry = null;\n\t    };\n\t\n\t    var LRUProto = LRU.prototype;\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @param  {} value\n\t     * @return {} Removed value\n\t     */\n\t    LRUProto.put = function (key, value) {\n\t        var list = this._list;\n\t        var map = this._map;\n\t        var removed = null;\n\t        if (map[key] == null) {\n\t            var len = list.len();\n\t            // Reuse last removed entry\n\t            var entry = this._lastRemovedEntry;\n\t\n\t            if (len >= this._maxSize && len > 0) {\n\t                // Remove the least recently used\n\t                var leastUsedEntry = list.head;\n\t                list.remove(leastUsedEntry);\n\t                delete map[leastUsedEntry.key];\n\t\n\t                removed = leastUsedEntry.value;\n\t                this._lastRemovedEntry = leastUsedEntry;\n\t            }\n\t\n\t            if (entry) {\n\t                entry.value = value;\n\t            }\n\t            else {\n\t                entry = new Entry(value);\n\t            }\n\t            entry.key = key;\n\t            list.insertEntry(entry);\n\t            map[key] = entry;\n\t        }\n\t\n\t        return removed;\n\t    };\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @return {}\n\t     */\n\t    LRUProto.get = function (key) {\n\t        var entry = this._map[key];\n\t        var list = this._list;\n\t        if (entry != null) {\n\t            // Put the latest used entry in the tail\n\t            if (entry !== list.tail) {\n\t                list.remove(entry);\n\t                list.insertEntry(entry);\n\t            }\n\t\n\t            return entry.value;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Clear the cache\n\t     */\n\t    LRUProto.clear = function () {\n\t        this._list.clear();\n\t        this._map = {};\n\t    };\n\t\n\t    module.exports = LRU;\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t        var config = __webpack_require__(23);\n\t\n\t        /**\n\t         * @exports zrender/tool/log\n\t         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t         */\n\t        module.exports = function() {\n\t            if (config.debugMode === 0) {\n\t                return;\n\t            }\n\t            else if (config.debugMode == 1) {\n\t                for (var k in arguments) {\n\t                    throw new Error(arguments[k]);\n\t                }\n\t            }\n\t            else if (config.debugMode > 1) {\n\t                for (var k in arguments) {\n\t                    console.log(arguments[k]);\n\t                }\n\t            }\n\t        };\n\t\n\t        /* for debug\n\t        return function(mes) {\n\t            document.getElementById('wrong-message').innerHTML =\n\t                mes + ' ' + (new Date() - 0)\n\t                + '<br/>'\n\t                + document.getElementById('wrong-message').innerHTML;\n\t        };\n\t        */\n\t    \n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t\n\t    var dpr = 1;\n\t    // If in browser environment\n\t    if (typeof window !== 'undefined') {\n\t        dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t    }\n\t    /**\n\t     * config默认配置项\n\t     * @exports zrender/config\n\t     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t     */\n\t    var config = {\n\t        /**\n\t         * debug日志选项：catchBrushException为true下有效\n\t         * 0 : 不生成debug数据，发布用\n\t         * 1 : 异常抛出，调试用\n\t         * 2 : 控制台输出，调试用\n\t         */\n\t        debugMode: 0,\n\t\n\t        // retina 屏幕优化\n\t        devicePixelRatio: dpr\n\t    };\n\t    module.exports = config;\n\t\n\t\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module echarts/core/BoundingRect\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(15);\n\t    var matrix = __webpack_require__(14);\n\t\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    /**\n\t     * @alias module:echarts/core/BoundingRect\n\t     */\n\t    function BoundingRect(x, y, width, height) {\n\t\n\t        if (width < 0) {\n\t            x = x + width;\n\t            width = -width;\n\t        }\n\t        if (height < 0) {\n\t            y = y + height;\n\t            height = -height;\n\t        }\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.x = x;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.y = y;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.width = width;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.height = height;\n\t    }\n\t\n\t    BoundingRect.prototype = {\n\t\n\t        constructor: BoundingRect,\n\t\n\t        /**\n\t         * @param {module:echarts/core/BoundingRect} other\n\t         */\n\t        union: function (other) {\n\t            var x = mathMin(other.x, this.x);\n\t            var y = mathMin(other.y, this.y);\n\t\n\t            this.width = mathMax(\n\t                    other.x + other.width,\n\t                    this.x + this.width\n\t                ) - x;\n\t            this.height = mathMax(\n\t                    other.y + other.height,\n\t                    this.y + this.height\n\t                ) - y;\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} m\n\t         * @methods\n\t         */\n\t        applyTransform: (function () {\n\t            var lt = [];\n\t            var rb = [];\n\t            var lb = [];\n\t            var rt = [];\n\t            return function (m) {\n\t                // In case usage like this\n\t                // el.getBoundingRect().applyTransform(el.transform)\n\t                // And element has no transform\n\t                if (!m) {\n\t                    return;\n\t                }\n\t                lt[0] = lb[0] = this.x;\n\t                lt[1] = rt[1] = this.y;\n\t                rb[0] = rt[0] = this.x + this.width;\n\t                rb[1] = lb[1] = this.y + this.height;\n\t\n\t                v2ApplyTransform(lt, lt, m);\n\t                v2ApplyTransform(rb, rb, m);\n\t                v2ApplyTransform(lb, lb, m);\n\t                v2ApplyTransform(rt, rt, m);\n\t\n\t                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n\t                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n\t                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n\t                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n\t                this.width = maxX - this.x;\n\t                this.height = maxY - this.y;\n\t            };\n\t        })(),\n\t\n\t        /**\n\t         * Calculate matrix of transforming from self to target rect\n\t         * @param  {module:zrender/core/BoundingRect} b\n\t         * @return {Array.<number>}\n\t         */\n\t        calculateTransform: function (b) {\n\t            var a = this;\n\t            var sx = b.width / a.width;\n\t            var sy = b.height / a.height;\n\t\n\t            var m = matrix.create();\n\t\n\t            // 矩阵右乘\n\t            matrix.translate(m, m, [-a.x, -a.y]);\n\t            matrix.scale(m, m, [sx, sy]);\n\t            matrix.translate(m, m, [b.x, b.y]);\n\t\n\t            return m;\n\t        },\n\t\n\t        /**\n\t         * @param {(module:echarts/core/BoundingRect|Object)} b\n\t         * @return {boolean}\n\t         */\n\t        intersect: function (b) {\n\t            if (!b) {\n\t                return false;\n\t            }\n\t\n\t            if (!(b instanceof BoundingRect)) {\n\t                // Normalize negative width/height.\n\t                b = BoundingRect.create(b);\n\t            }\n\t\n\t            var a = this;\n\t            var ax0 = a.x;\n\t            var ax1 = a.x + a.width;\n\t            var ay0 = a.y;\n\t            var ay1 = a.y + a.height;\n\t\n\t            var bx0 = b.x;\n\t            var bx1 = b.x + b.width;\n\t            var by0 = b.y;\n\t            var by1 = b.y + b.height;\n\t\n\t            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var rect = this;\n\t            return x >= rect.x\n\t                && x <= (rect.x + rect.width)\n\t                && y >= rect.y\n\t                && y <= (rect.y + rect.height);\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/core/BoundingRect}\n\t         */\n\t        clone: function () {\n\t            return new BoundingRect(this.x, this.y, this.width, this.height);\n\t        },\n\t\n\t        /**\n\t         * Copy from another rect\n\t         */\n\t        copy: function (other) {\n\t            this.x = other.x;\n\t            this.y = other.y;\n\t            this.width = other.width;\n\t            this.height = other.height;\n\t        },\n\t\n\t        plain: function () {\n\t            return {\n\t                x: this.x,\n\t                y: this.y,\n\t                width: this.width,\n\t                height: this.height\n\t            };\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {Object|module:zrender/core/BoundingRect} rect\n\t     * @param {number} rect.x\n\t     * @param {number} rect.y\n\t     * @param {number} rect.width\n\t     * @param {number} rect.height\n\t     * @return {module:zrender/core/BoundingRect}\n\t     */\n\t    BoundingRect.create = function (rect) {\n\t        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n\t    };\n\t\n\t    module.exports = BoundingRect;\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t// https://github.com/mziccard/node-timsort\n\t\n\t    var DEFAULT_MIN_MERGE = 32;\n\t\n\t    var DEFAULT_MIN_GALLOPING = 7;\n\t\n\t    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t\n\t    function minRunLength(n) {\n\t        var r = 0;\n\t\n\t        while (n >= DEFAULT_MIN_MERGE) {\n\t            r |= n & 1;\n\t            n >>= 1;\n\t        }\n\t\n\t        return n + r;\n\t    }\n\t\n\t    function makeAscendingRun(array, lo, hi, compare) {\n\t        var runHi = lo + 1;\n\t\n\t        if (runHi === hi) {\n\t            return 1;\n\t        }\n\t\n\t        if (compare(array[runHi++], array[lo]) < 0) {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t                runHi++;\n\t            }\n\t\n\t            reverseRun(array, lo, runHi);\n\t        }\n\t        else {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t                runHi++;\n\t            }\n\t        }\n\t\n\t        return runHi - lo;\n\t    }\n\t\n\t    function reverseRun(array, lo, hi) {\n\t        hi--;\n\t\n\t        while (lo < hi) {\n\t            var t = array[lo];\n\t            array[lo++] = array[hi];\n\t            array[hi--] = t;\n\t        }\n\t    }\n\t\n\t    function binaryInsertionSort(array, lo, hi, start, compare) {\n\t        if (start === lo) {\n\t            start++;\n\t        }\n\t\n\t        for (; start < hi; start++) {\n\t            var pivot = array[start];\n\t\n\t            var left = lo;\n\t            var right = start;\n\t            var mid;\n\t\n\t            while (left < right) {\n\t                mid = left + right >>> 1;\n\t\n\t                if (compare(pivot, array[mid]) < 0) {\n\t                    right = mid;\n\t                }\n\t                else {\n\t                    left = mid + 1;\n\t                }\n\t            }\n\t\n\t            var n = start - left;\n\t\n\t            switch (n) {\n\t                case 3:\n\t                    array[left + 3] = array[left + 2];\n\t\n\t                case 2:\n\t                    array[left + 2] = array[left + 1];\n\t\n\t                case 1:\n\t                    array[left + 1] = array[left];\n\t                    break;\n\t                default:\n\t                    while (n > 0) {\n\t                        array[left + n] = array[left + n - 1];\n\t                        n--;\n\t                    }\n\t            }\n\t\n\t            array[left] = pivot;\n\t        }\n\t    }\n\t\n\t    function gallopLeft(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) > 0) {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t        else {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) > 0) {\n\t                lastOffset = m + 1;\n\t            }\n\t            else {\n\t                offset = m;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t\n\t    function gallopRight(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) < 0) {\n\t            maxOffset = hint + 1;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t        else {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t\n\t        lastOffset++;\n\t\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) < 0) {\n\t                offset = m;\n\t            }\n\t            else {\n\t                lastOffset = m + 1;\n\t            }\n\t        }\n\t\n\t        return offset;\n\t    }\n\t\n\t    function TimSort(array, compare) {\n\t        var minGallop = DEFAULT_MIN_GALLOPING;\n\t        var length = 0;\n\t        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t        var stackLength = 0;\n\t        var runStart;\n\t        var runLength;\n\t        var stackSize = 0;\n\t\n\t        length = array.length;\n\t\n\t        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t            tmpStorageLength = length >>> 1;\n\t        }\n\t\n\t        var tmp = [];\n\t\n\t        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t\n\t        runStart = [];\n\t        runLength = [];\n\t\n\t        function pushRun(_runStart, _runLength) {\n\t            runStart[stackSize] = _runStart;\n\t            runLength[stackSize] = _runLength;\n\t            stackSize += 1;\n\t        }\n\t\n\t        function mergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t                    if (runLength[n - 1] < runLength[n + 1]) {\n\t                        n--;\n\t                    }\n\t                }\n\t                else if (runLength[n] > runLength[n + 1]) {\n\t                    break;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function forceMergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t                    n--;\n\t                }\n\t\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function mergeAt(i) {\n\t            var start1 = runStart[i];\n\t            var length1 = runLength[i];\n\t            var start2 = runStart[i + 1];\n\t            var length2 = runLength[i + 1];\n\t\n\t            runLength[i] = length1 + length2;\n\t\n\t            if (i === stackSize - 3) {\n\t                runStart[i + 1] = runStart[i + 2];\n\t                runLength[i + 1] = runLength[i + 2];\n\t            }\n\t\n\t            stackSize--;\n\t\n\t            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t            start1 += k;\n\t            length1 -= k;\n\t\n\t            if (length1 === 0) {\n\t                return;\n\t            }\n\t\n\t            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t\n\t            if (length2 === 0) {\n\t                return;\n\t            }\n\t\n\t            if (length1 <= length2) {\n\t                mergeLow(start1, length1, start2, length2);\n\t            }\n\t            else {\n\t                mergeHigh(start1, length1, start2, length2);\n\t            }\n\t        }\n\t\n\t        function mergeLow(start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length1; i++) {\n\t                tmp[i] = array[start1 + i];\n\t            }\n\t\n\t            var cursor1 = 0;\n\t            var cursor2 = start2;\n\t            var dest = start1;\n\t\n\t            array[dest++] = array[cursor2++];\n\t\n\t            if (--length2 === 0) {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t                return;\n\t            }\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t            var count1, count2, exit;\n\t\n\t            while (1) {\n\t                count1 = 0;\n\t                count2 = 0;\n\t                exit = false;\n\t\n\t                do {\n\t                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t                        array[dest++] = array[cursor2++];\n\t                        count2++;\n\t                        count1 = 0;\n\t\n\t                        if (--length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest++] = tmp[cursor1++];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        for (i = 0; i < count1; i++) {\n\t                            array[dest + i] = tmp[cursor1 + i];\n\t                        }\n\t\n\t                        dest += count1;\n\t                        cursor1 += count1;\n\t                        length1 -= count1;\n\t                        if (length1 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest++] = array[cursor2++];\n\t\n\t                    if (--length2 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[dest + i] = array[cursor2 + i];\n\t                        }\n\t\n\t                        dest += count2;\n\t                        cursor2 += count2;\n\t                        length2 -= count2;\n\t\n\t                        if (length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = tmp[cursor1++];\n\t\n\t                    if (--length1 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            minGallop < 1 && (minGallop = 1);\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t            }\n\t            else if (length1 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeLow preconditions were not respected');\n\t            }\n\t            else {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t            }\n\t        }\n\t\n\t        function mergeHigh (start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length2; i++) {\n\t                tmp[i] = array[start2 + i];\n\t            }\n\t\n\t            var cursor1 = start1 + length1 - 1;\n\t            var cursor2 = length2 - 1;\n\t            var dest = start2 + length2 - 1;\n\t            var customCursor = 0;\n\t            var customDest = 0;\n\t\n\t            array[dest--] = array[cursor1--];\n\t\n\t            if (--length1 === 0) {\n\t                customCursor = dest - (length2 - 1);\n\t\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t\n\t            while (true) {\n\t                var count1 = 0;\n\t                var count2 = 0;\n\t                var exit = false;\n\t\n\t                do {\n\t                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t                        array[dest--] = array[cursor1--];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest--] = tmp[cursor2--];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        dest -= count1;\n\t                        cursor1 -= count1;\n\t                        length1 -= count1;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor1 + 1;\n\t\n\t                        for (i = count1 - 1; i >= 0; i--) {\n\t                            array[customDest + i] = array[customCursor + i];\n\t                        }\n\t\n\t                        if (length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = tmp[cursor2--];\n\t\n\t                    if (--length2 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        dest -= count2;\n\t                        cursor2 -= count2;\n\t                        length2 -= count2;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor2 + 1;\n\t\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[customDest + i] = tmp[customCursor + i];\n\t                        }\n\t\n\t                        if (length2 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = array[cursor1--];\n\t\n\t                    if (--length1 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            if (minGallop < 1) {\n\t                minGallop = 1;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t            }\n\t            else if (length2 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeHigh preconditions were not respected');\n\t            }\n\t            else {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t            }\n\t        }\n\t\n\t        this.mergeRuns = mergeRuns;\n\t        this.forceMergeRuns = forceMergeRuns;\n\t        this.pushRun = pushRun;\n\t    }\n\t\n\t    function sort(array, compare, lo, hi) {\n\t        if (!lo) {\n\t            lo = 0;\n\t        }\n\t        if (!hi) {\n\t            hi = array.length;\n\t        }\n\t\n\t        var remaining = hi - lo;\n\t\n\t        if (remaining < 2) {\n\t            return;\n\t        }\n\t\n\t        var runLength = 0;\n\t\n\t        if (remaining < DEFAULT_MIN_MERGE) {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t            return;\n\t        }\n\t\n\t        var ts = new TimSort(array, compare);\n\t\n\t        var minRun = minRunLength(remaining);\n\t\n\t        do {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            if (runLength < minRun) {\n\t                var force = remaining;\n\t                if (force > minRun) {\n\t                    force = minRun;\n\t                }\n\t\n\t                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t                runLength = force;\n\t            }\n\t\n\t            ts.pushRun(lo, runLength);\n\t            ts.mergeRuns();\n\t\n\t            remaining -= runLength;\n\t            lo += runLength;\n\t        } while (remaining !== 0);\n\t\n\t        ts.forceMergeRuns();\n\t    }\n\t\n\t    module.exports = sort;\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 动画主类, 调度和管理所有动画控制器\n\t *\n\t * @module zrender/animation/Animation\n\t * @author pissang(https://github.com/pissang)\n\t */\n\t// TODO Additive animation\n\t// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n\t// https://developer.apple.com/videos/wwdc2014/#236\n\t\n\t\n\t    var util = __webpack_require__(6);\n\t    var Dispatcher = __webpack_require__(27).Dispatcher;\n\t\n\t    var requestAnimationFrame = __webpack_require__(28);\n\t\n\t    var Animator = __webpack_require__(17);\n\t    /**\n\t     * @typedef {Object} IZRenderStage\n\t     * @property {Function} update\n\t     */\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animation\n\t     * @constructor\n\t     * @param {Object} [options]\n\t     * @param {Function} [options.onframe]\n\t     * @param {IZRenderStage} [options.stage]\n\t     * @example\n\t     *     var animation = new Animation();\n\t     *     var obj = {\n\t     *         x: 100,\n\t     *         y: 100\n\t     *     };\n\t     *     animation.animate(node.position)\n\t     *         .when(1000, {\n\t     *             x: 500,\n\t     *             y: 500\n\t     *         })\n\t     *         .when(2000, {\n\t     *             x: 100,\n\t     *             y: 100\n\t     *         })\n\t     *         .start('spline');\n\t     */\n\t    var Animation = function (options) {\n\t\n\t        options = options || {};\n\t\n\t        this.stage = options.stage || {};\n\t\n\t        this.onframe = options.onframe || function() {};\n\t\n\t        // private properties\n\t        this._clips = [];\n\t\n\t        this._running = false;\n\t\n\t        this._time;\n\t\n\t        this._pausedTime;\n\t\n\t        this._pauseStart;\n\t\n\t        this._paused = false;\n\t\n\t        Dispatcher.call(this);\n\t    };\n\t\n\t    Animation.prototype = {\n\t\n\t        constructor: Animation,\n\t        /**\n\t         * 添加 clip\n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        addClip: function (clip) {\n\t            this._clips.push(clip);\n\t        },\n\t        /**\n\t         * 添加 animator\n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        addAnimator: function (animator) {\n\t            animator.animation = this;\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.addClip(clips[i]);\n\t            }\n\t        },\n\t        /**\n\t         * 删除动画片段\n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        removeClip: function(clip) {\n\t            var idx = util.indexOf(this._clips, clip);\n\t            if (idx >= 0) {\n\t                this._clips.splice(idx, 1);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 删除动画片段\n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        removeAnimator: function (animator) {\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.removeClip(clips[i]);\n\t            }\n\t            animator.animation = null;\n\t        },\n\t\n\t        _update: function() {\n\t\n\t            var time = new Date().getTime() - this._pausedTime;\n\t            var delta = time - this._time;\n\t            var clips = this._clips;\n\t            var len = clips.length;\n\t\n\t            var deferredEvents = [];\n\t            var deferredClips = [];\n\t            for (var i = 0; i < len; i++) {\n\t                var clip = clips[i];\n\t                var e = clip.step(time, delta);\n\t                // Throw out the events need to be called after\n\t                // stage.update, like destroy\n\t                if (e) {\n\t                    deferredEvents.push(e);\n\t                    deferredClips.push(clip);\n\t                }\n\t            }\n\t\n\t            // Remove the finished clip\n\t            for (var i = 0; i < len;) {\n\t                if (clips[i]._needsRemove) {\n\t                    clips[i] = clips[len - 1];\n\t                    clips.pop();\n\t                    len--;\n\t                }\n\t                else {\n\t                    i++;\n\t                }\n\t            }\n\t\n\t            len = deferredEvents.length;\n\t            for (var i = 0; i < len; i++) {\n\t                deferredClips[i].fire(deferredEvents[i]);\n\t            }\n\t\n\t            this._time = time;\n\t\n\t            this.onframe(delta);\n\t\n\t            this.trigger('frame', delta);\n\t\n\t            if (this.stage.update) {\n\t                this.stage.update();\n\t            }\n\t        },\n\t\n\t        _startLoop: function () {\n\t            var self = this;\n\t\n\t            this._running = true;\n\t\n\t            function step() {\n\t                if (self._running) {\n\t\n\t                    requestAnimationFrame(step);\n\t\n\t                    !self._paused && self._update();\n\t                }\n\t            }\n\t\n\t            requestAnimationFrame(step);\n\t        },\n\t\n\t        /**\n\t         * 开始运行动画\n\t         */\n\t        start: function () {\n\t\n\t            this._time = new Date().getTime();\n\t            this._pausedTime = 0;\n\t\n\t            this._startLoop();\n\t        },\n\t        /**\n\t         * 停止运行动画\n\t         */\n\t        stop: function () {\n\t            this._running = false;\n\t        },\n\t\n\t        /**\n\t         * Pause\n\t         */\n\t        pause: function () {\n\t            if (!this._paused) {\n\t                this._pauseStart = new Date().getTime();\n\t                this._paused = true;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Resume\n\t         */\n\t        resume: function () {\n\t            if (this._paused) {\n\t                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n\t                this._paused = false;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 清除所有动画片段\n\t         */\n\t        clear: function () {\n\t            this._clips = [];\n\t        },\n\t        /**\n\t         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n\t         * @param  {Object} target\n\t         * @param  {Object} options\n\t         * @param  {boolean} [options.loop=false] 是否循环播放动画\n\t         * @param  {Function} [options.getter=null]\n\t         *         如果指定getter函数，会通过getter函数取属性值\n\t         * @param  {Function} [options.setter=null]\n\t         *         如果指定setter函数，会通过setter函数设置属性值\n\t         * @return {module:zrender/animation/Animation~Animator}\n\t         */\n\t        // TODO Gap\n\t        animate: function (target, options) {\n\t            options = options || {};\n\t\n\t            var animator = new Animator(\n\t                target,\n\t                options.loop,\n\t                options.getter,\n\t                options.setter\n\t            );\n\t\n\t            this.addAnimator(animator);\n\t\n\t            return animator;\n\t        }\n\t    };\n\t\n\t    util.mixin(Animation, Dispatcher);\n\t\n\t    module.exports = Animation;\n\t\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 事件辅助类\n\t * @module zrender/core/event\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t */\n\t\n\t\n\t    var Eventful = __webpack_require__(9);\n\t    var env = __webpack_require__(5);\n\t\n\t    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\t\n\t    function getBoundingClientRect(el) {\n\t        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n\t    }\n\t\n\t    // `calculate` is optional, default false\n\t    function clientToLocal(el, e, out, calculate) {\n\t        out = out || {};\n\t\n\t        // According to the W3C Working Draft, offsetX and offsetY should be relative\n\t        // to the padding edge of the target element. The only browser using this convention\n\t        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n\t        // not support the properties.\n\t        // (see http://www.jacklmoore.com/notes/mouse-position/)\n\t        // In zr painter.dom, padding edge equals to border edge.\n\t\n\t        // FIXME\n\t        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n\t        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n\t        // is too complex. So css-transfrom dont support in this case temporarily.\n\t        if (calculate || !env.canvasSupported) {\n\t            defaultGetZrXY(el, e, out);\n\t        }\n\t        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n\t        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n\t        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n\t        // zoom-factor, overflow / opacity layers, transforms ...)\n\t        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n\t        // <https://bugs.jquery.com/ticket/8523#comment:14>\n\t        // BTW3, In ff, offsetX/offsetY is always 0.\n\t        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n\t            out.zrX = e.layerX;\n\t            out.zrY = e.layerY;\n\t        }\n\t        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n\t        else if (e.offsetX != null) {\n\t            out.zrX = e.offsetX;\n\t            out.zrY = e.offsetY;\n\t        }\n\t        // For some other device, e.g., IOS safari.\n\t        else {\n\t            defaultGetZrXY(el, e, out);\n\t        }\n\t\n\t        return out;\n\t    }\n\t\n\t    function defaultGetZrXY(el, e, out) {\n\t        // This well-known method below does not support css transform.\n\t        var box = getBoundingClientRect(el);\n\t        out.zrX = e.clientX - box.left;\n\t        out.zrY = e.clientY - box.top;\n\t    }\n\t\n\t    /**\n\t     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.\n\t     * `calculate` is optional, default false.\n\t     */\n\t    function normalizeEvent(el, e, calculate) {\n\t\n\t        e = e || window.event;\n\t\n\t        if (e.zrX != null) {\n\t            return e;\n\t        }\n\t\n\t        var eventType = e.type;\n\t        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t\n\t        if (!isTouch) {\n\t            clientToLocal(el, e, e, calculate);\n\t            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t        }\n\t        else {\n\t            var touch = eventType != 'touchend'\n\t                ? e.targetTouches[0]\n\t                : e.changedTouches[0];\n\t            touch && clientToLocal(el, touch, e, calculate);\n\t        }\n\t\n\t        return e;\n\t    }\n\t\n\t    function addEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.addEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.attachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    function removeEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.removeEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.detachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * preventDefault and stopPropagation.\n\t     * Notice: do not do that in zrender. Upper application\n\t     * do that if necessary.\n\t     *\n\t     * @memberOf module:zrender/core/event\n\t     * @method\n\t     * @param {Event} e : event对象\n\t     */\n\t    var stop = isDomLevel2\n\t        ? function (e) {\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\t            e.cancelBubble = true;\n\t        }\n\t        : function (e) {\n\t            e.returnValue = false;\n\t            e.cancelBubble = true;\n\t        };\n\t\n\t    module.exports = {\n\t        clientToLocal: clientToLocal,\n\t        normalizeEvent: normalizeEvent,\n\t        addEventListener: addEventListener,\n\t        removeEventListener: removeEventListener,\n\t\n\t        stop: stop,\n\t        // 做向上兼容\n\t        Dispatcher: Eventful\n\t    };\n\t\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = (typeof window !== 'undefined' &&\n\t                                    (window.requestAnimationFrame\n\t                                    || window.msRequestAnimationFrame\n\t                                    || window.mozRequestAnimationFrame\n\t                                    || window.webkitRequestAnimationFrame))\n\t                                || function (func) {\n\t                                    setTimeout(func, 16);\n\t                                };\n\t\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var eventTool = __webpack_require__(27);\n\t    var zrUtil = __webpack_require__(6);\n\t    var Eventful = __webpack_require__(9);\n\t    var env = __webpack_require__(5);\n\t    var GestureMgr = __webpack_require__(30);\n\t\n\t    var addEventListener = eventTool.addEventListener;\n\t    var removeEventListener = eventTool.removeEventListener;\n\t    var normalizeEvent = eventTool.normalizeEvent;\n\t\n\t    var TOUCH_CLICK_DELAY = 300;\n\t\n\t    var mouseHandlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n\t    ];\n\t\n\t    var touchHandlerNames = [\n\t        'touchstart', 'touchend', 'touchmove'\n\t    ];\n\t\n\t    var pointerEventNames = {\n\t        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n\t    };\n\t\n\t    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n\t        var nm = name.replace('mouse', 'pointer');\n\t        return pointerEventNames[nm] ? nm : name;\n\t    });\n\t\n\t    function eventNameFix(name) {\n\t        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n\t    }\n\t\n\t    function processGesture(proxy, event, stage) {\n\t        var gestureMgr = proxy._gestureMgr;\n\t\n\t        stage === 'start' && gestureMgr.clear();\n\t\n\t        var gestureInfo = gestureMgr.recognize(\n\t            event,\n\t            proxy.handler.findHover(event.zrX, event.zrY, null),\n\t            proxy.dom\n\t        );\n\t\n\t        stage === 'end' && gestureMgr.clear();\n\t\n\t        // Do not do any preventDefault here. Upper application do that if necessary.\n\t        if (gestureInfo) {\n\t            var type = gestureInfo.type;\n\t            event.gestureEvent = type;\n\t\n\t            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n\t        }\n\t    }\n\t\n\t    // function onMSGestureChange(proxy, event) {\n\t    //     if (event.translationX || event.translationY) {\n\t    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n\t    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n\t    //     }\n\t    //     if (event.scale !== 1) {\n\t    //         event.pinchX = event.offsetX;\n\t    //         event.pinchY = event.offsetY;\n\t    //         event.pinchScale = event.scale;\n\t    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n\t    //     }\n\t    // }\n\t\n\t    /**\n\t     * Prevent mouse event from being dispatched after Touch Events action\n\t     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t     * Result: Blocking Mouse Events for 700ms.\n\t     */\n\t    function setTouchTimer(instance) {\n\t        instance._touching = true;\n\t        clearTimeout(instance._touchTimer);\n\t        instance._touchTimer = setTimeout(function () {\n\t            instance._touching = false;\n\t        }, 700);\n\t    }\n\t\n\t\n\t    var domHandlers = {\n\t        /**\n\t         * Mouse move handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mousemove: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            this.trigger('mousemove', event);\n\t        },\n\t\n\t        /**\n\t         * Mouse out handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mouseout: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            var element = event.toElement || event.relatedTarget;\n\t            if (element != this.dom) {\n\t                while (element && element.nodeType != 9) {\n\t                    // 忽略包含在root中的dom引起的mouseOut\n\t                    if (element === this.dom) {\n\t                        return;\n\t                    }\n\t\n\t                    element = element.parentNode;\n\t                }\n\t            }\n\t\n\t            this.trigger('mouseout', event);\n\t        },\n\t\n\t        /**\n\t         * Touch开始响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchstart: function (event) {\n\t            // Default mouse behaviour should not be disabled here.\n\t            // For example, page may needs to be slided.\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            this._lastTouchMoment = new Date();\n\t\n\t            processGesture(this, event, 'start');\n\t\n\t            // In touch device, trigger `mousemove`(`mouseover`) should\n\t            // be triggered, and must before `mousedown` triggered.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            domHandlers.mousedown.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch移动响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchmove: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            processGesture(this, event, 'change');\n\t\n\t            // Mouse move should always be triggered no matter whether\n\t            // there is gestrue event, because mouse move and pinch may\n\t            // be used at the same time.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch结束响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchend: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            processGesture(this, event, 'end');\n\t\n\t            domHandlers.mouseup.call(this, event);\n\t\n\t            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n\t            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n\t            // we can conveniently implement \"hover style\" in both PC and touch device just\n\t            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n\t            // to remove \"hover style\" on an element, without any additional code for\n\t            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n\t            // style\" will remain for user view)\n\t\n\t            // click event should always be triggered no matter whether\n\t            // there is gestrue event. System click can not be prevented.\n\t            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t                domHandlers.click.call(this, event);\n\t            }\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        pointerdown: function (event) {\n\t            domHandlers.mousedown.call(this, event);\n\t\n\t            // if (useMSGuesture(this, event)) {\n\t            //     this._msGesture.addPointer(event.pointerId);\n\t            // }\n\t        },\n\t\n\t        pointermove: function (event) {\n\t            // FIXME\n\t            // pointermove is so sensitive that it always triggered when\n\t            // tap(click) on touch screen, which affect some judgement in\n\t            // upper application. So, we dont support mousemove on MS touch\n\t            // device yet.\n\t            if (!isPointerFromTouch(event)) {\n\t                domHandlers.mousemove.call(this, event);\n\t            }\n\t        },\n\t\n\t        pointerup: function (event) {\n\t            domHandlers.mouseup.call(this, event);\n\t        },\n\t\n\t        pointerout: function (event) {\n\t            // pointerout will be triggered when tap on touch screen\n\t            // (IE11+/Edge on MS Surface) after click event triggered,\n\t            // which is inconsistent with the mousout behavior we defined\n\t            // in touchend. So we unify them.\n\t            // (check domHandlers.touchend for detailed explanation)\n\t            if (!isPointerFromTouch(event)) {\n\t                domHandlers.mouseout.call(this, event);\n\t            }\n\t        }\n\t    };\n\t\n\t    function isPointerFromTouch(event) {\n\t        var pointerType = event.pointerType;\n\t        return pointerType === 'pen' || pointerType === 'touch';\n\t    }\n\t\n\t    // function useMSGuesture(handlerProxy, event) {\n\t    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n\t    // }\n\t\n\t    // Common handlers\n\t    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t        domHandlers[name] = function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t            this.trigger(name, event);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * 为控制类实例初始化dom 事件处理函数\n\t     *\n\t     * @inner\n\t     * @param {module:zrender/Handler} instance 控制类实例\n\t     */\n\t    function initDomHandler(instance) {\n\t        zrUtil.each(touchHandlerNames, function (name) {\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        });\n\t\n\t        zrUtil.each(pointerHandlerNames, function (name) {\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        });\n\t\n\t        zrUtil.each(mouseHandlerNames, function (name) {\n\t            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t        });\n\t\n\t        function makeMouseHandler(fn, instance) {\n\t            return function () {\n\t                if (instance._touching) {\n\t                    return;\n\t                }\n\t                return fn.apply(instance, arguments);\n\t            };\n\t        }\n\t    }\n\t\n\t\n\t    function HandlerDomProxy(dom) {\n\t        Eventful.call(this);\n\t\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._touching = false;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._touchTimer;\n\t\n\t        /**\n\t         * @private\n\t         * @type {module:zrender/core/GestureMgr}\n\t         */\n\t        this._gestureMgr = new GestureMgr();\n\t\n\t        this._handlers = {};\n\t\n\t        initDomHandler(this);\n\t\n\t        if (env.pointerEventsSupported) { // Only IE11+/Edge\n\t            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n\t            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n\t            // at the same time.\n\t            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n\t            // screen, which do not occurs in pointer event.\n\t            // So we use pointer event to both detect touch gesture and mouse behavior.\n\t            mountHandlers(pointerHandlerNames, this);\n\t\n\t            // FIXME\n\t            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n\t            // which does not prevent defuault behavior occasionally (which may cause view port\n\t            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n\t            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n\t            // touch screen. And we only support click behavior on MS touch screen now.\n\t\n\t            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n\t            // We dont support touch on IE on win7.\n\t            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n\t            // if (typeof MSGesture === 'function') {\n\t            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n\t            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n\t            // }\n\t        }\n\t        else {\n\t            if (env.touchEventsSupported) {\n\t                mountHandlers(touchHandlerNames, this);\n\t                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t            }\n\t\n\t            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n\t            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t            // mouse event can not be handle in those devices.\n\t            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n\t            // mouseevent after touch event triggered, see `setTouchTimer`.\n\t            mountHandlers(mouseHandlerNames, this);\n\t        }\n\t\n\t        function mountHandlers(handlerNames, instance) {\n\t            zrUtil.each(handlerNames, function (name) {\n\t                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t            }, instance);\n\t        }\n\t    }\n\t\n\t    var handlerDomProxyProto = HandlerDomProxy.prototype;\n\t    handlerDomProxyProto.dispose = function () {\n\t        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t\n\t        for (var i = 0; i < handlerNames.length; i++) {\n\t            var name = handlerNames[i];\n\t            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t        }\n\t    };\n\t\n\t    handlerDomProxyProto.setCursor = function (cursorStyle) {\n\t        this.dom.style.cursor = cursorStyle || 'default';\n\t    };\n\t\n\t    zrUtil.mixin(HandlerDomProxy, Eventful);\n\t\n\t    module.exports = HandlerDomProxy;\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Only implements needed gestures for mobile.\n\t */\n\t\n\t\n\t    var eventUtil = __webpack_require__(27);\n\t\n\t    var GestureMgr = function () {\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._track = [];\n\t    };\n\t\n\t    GestureMgr.prototype = {\n\t\n\t        constructor: GestureMgr,\n\t\n\t        recognize: function (event, target, root) {\n\t            this._doTrack(event, target, root);\n\t            return this._recognize(event);\n\t        },\n\t\n\t        clear: function () {\n\t            this._track.length = 0;\n\t            return this;\n\t        },\n\t\n\t        _doTrack: function (event, target, root) {\n\t            var touches = event.touches;\n\t\n\t            if (!touches) {\n\t                return;\n\t            }\n\t\n\t            var trackItem = {\n\t                points: [],\n\t                touches: [],\n\t                target: target,\n\t                event: event\n\t            };\n\t\n\t            for (var i = 0, len = touches.length; i < len; i++) {\n\t                var touch = touches[i];\n\t                var pos = eventUtil.clientToLocal(root, touch, {});\n\t                trackItem.points.push([pos.zrX, pos.zrY]);\n\t                trackItem.touches.push(touch);\n\t            }\n\t\n\t            this._track.push(trackItem);\n\t        },\n\t\n\t        _recognize: function (event) {\n\t            for (var eventName in recognizers) {\n\t                if (recognizers.hasOwnProperty(eventName)) {\n\t                    var gestureInfo = recognizers[eventName](this._track, event);\n\t                    if (gestureInfo) {\n\t                        return gestureInfo;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    function dist(pointPair) {\n\t        var dx = pointPair[1][0] - pointPair[0][0];\n\t        var dy = pointPair[1][1] - pointPair[0][1];\n\t\n\t        return Math.sqrt(dx * dx + dy * dy);\n\t    }\n\t\n\t    function center(pointPair) {\n\t        return [\n\t            (pointPair[0][0] + pointPair[1][0]) / 2,\n\t            (pointPair[0][1] + pointPair[1][1]) / 2\n\t        ];\n\t    }\n\t\n\t    var recognizers = {\n\t\n\t        pinch: function (track, event) {\n\t            var trackLen = track.length;\n\t\n\t            if (!trackLen) {\n\t                return;\n\t            }\n\t\n\t            var pinchEnd = (track[trackLen - 1] || {}).points;\n\t            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t\n\t            if (pinchPre\n\t                && pinchPre.length > 1\n\t                && pinchEnd\n\t                && pinchEnd.length > 1\n\t            ) {\n\t                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t                !isFinite(pinchScale) && (pinchScale = 1);\n\t\n\t                event.pinchScale = pinchScale;\n\t\n\t                var pinchCenter = center(pinchEnd);\n\t                event.pinchX = pinchCenter[0];\n\t                event.pinchY = pinchCenter[1];\n\t\n\t                return {\n\t                    type: 'pinch',\n\t                    target: track[0].target,\n\t                    event: event\n\t                };\n\t            }\n\t        }\n\t\n\t        // Only pinch currently.\n\t    };\n\t\n\t    module.exports = GestureMgr;\n\t\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Default canvas painter\n\t * @module zrender/Painter\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t \n\t\n\t    var config = __webpack_require__(23);\n\t    var util = __webpack_require__(6);\n\t    var log = __webpack_require__(22);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var timsort = __webpack_require__(25);\n\t\n\t    var Layer = __webpack_require__(32);\n\t\n\t    var requestAnimationFrame = __webpack_require__(28);\n\t\n\t    // PENDIGN\n\t    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t    //\n\t    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\t    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t\n\t    function isLayerValid(layer) {\n\t        if (!layer) {\n\t            return false;\n\t        }\n\t\n\t        if (layer.__builtin__) {\n\t            return true;\n\t        }\n\t\n\t        if (typeof(layer.resize) !== 'function'\n\t            || typeof(layer.refresh) !== 'function'\n\t        ) {\n\t            return false;\n\t        }\n\t\n\t        return true;\n\t    }\n\t\n\t    function preProcessLayer(layer) {\n\t        layer.__unusedCount++;\n\t    }\n\t\n\t    function postProcessLayer(layer) {\n\t        if (layer.__unusedCount == 1) {\n\t            layer.clear();\n\t        }\n\t    }\n\t\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var viewRect = new BoundingRect(0, 0, 0, 0);\n\t    function isDisplayableCulled(el, width, height) {\n\t        tmpRect.copy(el.getBoundingRect());\n\t        if (el.transform) {\n\t            tmpRect.applyTransform(el.transform);\n\t        }\n\t        viewRect.width = width;\n\t        viewRect.height = height;\n\t        return !tmpRect.intersect(viewRect);\n\t    }\n\t\n\t    function isClipPathChanged(clipPaths, prevClipPaths) {\n\t        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n\t            return false;\n\t        }\n\t\n\t        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n\t            return true;\n\t        }\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            if (clipPaths[i] !== prevClipPaths[i]) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t\n\t    function doClip(clipPaths, ctx) {\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            var clipPath = clipPaths[i];\n\t            var path = clipPath.path;\n\t\n\t            clipPath.setTransform(ctx);\n\t            path.beginPath(ctx);\n\t            clipPath.buildPath(path, clipPath.shape);\n\t            ctx.clip();\n\t            // Transform back\n\t            clipPath.restoreTransform(ctx);\n\t        }\n\t    }\n\t\n\t    function createRoot(width, height) {\n\t        var domRoot = document.createElement('div');\n\t\n\t        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t        domRoot.style.cssText = [\n\t            'position:relative',\n\t            'overflow:hidden',\n\t            'width:' + width + 'px',\n\t            'height:' + height + 'px',\n\t            'padding:0',\n\t            'margin:0',\n\t            'border-width:0'\n\t        ].join(';') + ';';\n\t\n\t        return domRoot;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Painter\n\t     * @constructor\n\t     * @param {HTMLElement} root 绘图容器\n\t     * @param {module:zrender/Storage} storage\n\t     * @param {Ojbect} opts\n\t     */\n\t    var Painter = function (root, storage, opts) {\n\t        // In node environment using node-canvas\n\t        var singleCanvas = !root.nodeName // In node ?\n\t            || root.nodeName.toUpperCase() === 'CANVAS';\n\t\n\t        this._opts = opts = util.extend({}, opts || {});\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._singleCanvas = singleCanvas;\n\t        /**\n\t         * 绘图容器\n\t         * @type {HTMLElement}\n\t         */\n\t        this.root = root;\n\t\n\t        var rootStyle = root.style;\n\t\n\t        if (rootStyle) {\n\t            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t            rootStyle['-webkit-user-select'] =\n\t            rootStyle['user-select'] =\n\t            rootStyle['-webkit-touch-callout'] = 'none';\n\t\n\t            root.innerHTML = '';\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/Storage}\n\t         */\n\t        this.storage = storage;\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        var zlevelList = this._zlevelList = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:zrender/Layer>}\n\t         * @private\n\t         */\n\t        var layers = this._layers = {};\n\t\n\t        /**\n\t         * @type {Object.<string, Object>}\n\t         * @type {private}\n\t         */\n\t        this._layerConfig = {};\n\t\n\t        if (!singleCanvas) {\n\t            this._width = this._getSize(0);\n\t            this._height = this._getSize(1);\n\t\n\t            var domRoot = this._domRoot = createRoot(\n\t                this._width, this._height\n\t            );\n\t            root.appendChild(domRoot);\n\t        }\n\t        else {\n\t            if (opts.width != null) {\n\t                root.width = opts.width;\n\t            }\n\t            if (opts.height != null) {\n\t                root.height = opts.height;\n\t            }\n\t            // Use canvas width and height directly\n\t            var width = root.width;\n\t            var height = root.height;\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            // Create layer if only one given canvas\n\t            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t            var mainLayer = new Layer(root, this, 1);\n\t            mainLayer.initContext();\n\t            // FIXME Use canvas width and height\n\t            // mainLayer.resize(width, height);\n\t            layers[0] = mainLayer;\n\t            zlevelList.push(0);\n\t\n\t            this._domRoot = root;\n\t        }\n\t\n\t        // Layers for progressive rendering\n\t        this._progressiveLayers = [];\n\t\n\t        /**\n\t         * @type {module:zrender/Layer}\n\t         * @private\n\t         */\n\t        this._hoverlayer;\n\t\n\t        this._hoverElements = [];\n\t    };\n\t\n\t    Painter.prototype = {\n\t\n\t        constructor: Painter,\n\t\n\t        /**\n\t         * If painter use a single canvas\n\t         * @return {boolean}\n\t         */\n\t        isSingleCanvas: function () {\n\t            return this._singleCanvas;\n\t        },\n\t        /**\n\t         * @return {HTMLDivElement}\n\t         */\n\t        getViewportRoot: function () {\n\t            return this._domRoot;\n\t        },\n\t\n\t        /**\n\t         * 刷新\n\t         * @param {boolean} [paintAll=false] 强制绘制所有displayable\n\t         */\n\t        refresh: function (paintAll) {\n\t\n\t            var list = this.storage.getDisplayList(true);\n\t\n\t            var zlevelList = this._zlevelList;\n\t\n\t            this._paintList(list, paintAll);\n\t\n\t            // Paint custum layers\n\t            for (var i = 0; i < zlevelList.length; i++) {\n\t                var z = zlevelList[i];\n\t                var layer = this._layers[z];\n\t                if (!layer.__builtin__ && layer.refresh) {\n\t                    layer.refresh();\n\t                }\n\t            }\n\t\n\t            this.refreshHover();\n\t\n\t            if (this._progressiveLayers.length) {\n\t                this._startProgessive();\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        addHover: function (el, hoverStyle) {\n\t            if (el.__hoverMir) {\n\t                return;\n\t            }\n\t            var elMirror = new el.constructor({\n\t                style: el.style,\n\t                shape: el.shape\n\t            });\n\t            elMirror.__from = el;\n\t            el.__hoverMir = elMirror;\n\t            elMirror.setStyle(hoverStyle);\n\t            this._hoverElements.push(elMirror);\n\t        },\n\t\n\t        removeHover: function (el) {\n\t            var elMirror = el.__hoverMir;\n\t            var hoverElements = this._hoverElements;\n\t            var idx = util.indexOf(hoverElements, elMirror);\n\t            if (idx >= 0) {\n\t                hoverElements.splice(idx, 1);\n\t            }\n\t            el.__hoverMir = null;\n\t        },\n\t\n\t        clearHover: function (el) {\n\t            var hoverElements = this._hoverElements;\n\t            for (var i = 0; i < hoverElements.length; i++) {\n\t                var from = hoverElements[i].__from;\n\t                if (from) {\n\t                    from.__hoverMir = null;\n\t                }\n\t            }\n\t            hoverElements.length = 0;\n\t        },\n\t\n\t        refreshHover: function () {\n\t            var hoverElements = this._hoverElements;\n\t            var len = hoverElements.length;\n\t            var hoverLayer = this._hoverlayer;\n\t            hoverLayer && hoverLayer.clear();\n\t\n\t            if (!len) {\n\t                return;\n\t            }\n\t            timsort(hoverElements, this.storage.displayableSortFunc);\n\t\n\t            // Use a extream large zlevel\n\t            // FIXME?\n\t            if (!hoverLayer) {\n\t                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n\t            }\n\t\n\t            var scope = {};\n\t            hoverLayer.ctx.save();\n\t            for (var i = 0; i < len;) {\n\t                var el = hoverElements[i];\n\t                var originalEl = el.__from;\n\t                // Original el is removed\n\t                // PENDING\n\t                if (!(originalEl && originalEl.__zr)) {\n\t                    hoverElements.splice(i, 1);\n\t                    originalEl.__hoverMir = null;\n\t                    len--;\n\t                    continue;\n\t                }\n\t                i++;\n\t\n\t                // Use transform\n\t                // FIXME style and shape ?\n\t                if (!originalEl.invisible) {\n\t                    el.transform = originalEl.transform;\n\t                    el.invTransform = originalEl.invTransform;\n\t                    el.__clipPaths = originalEl.__clipPaths;\n\t                    // el.\n\t                    this._doPaintEl(el, hoverLayer, true, scope);\n\t                }\n\t            }\n\t            hoverLayer.ctx.restore();\n\t        },\n\t\n\t        _startProgessive: function () {\n\t            var self = this;\n\t\n\t            if (!self._furtherProgressive) {\n\t                return;\n\t            }\n\t\n\t            // Use a token to stop progress steps triggered by\n\t            // previous zr.refresh calling.\n\t            var token = self._progressiveToken = +new Date();\n\t\n\t            self._progress++;\n\t            requestAnimationFrame(step);\n\t\n\t            function step() {\n\t                // In case refreshed or disposed\n\t                if (token === self._progressiveToken && self.storage) {\n\t\n\t                    self._doPaintList(self.storage.getDisplayList());\n\t\n\t                    if (self._furtherProgressive) {\n\t                        self._progress++;\n\t                        requestAnimationFrame(step);\n\t                    }\n\t                    else {\n\t                        self._progressiveToken = -1;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _clearProgressive: function () {\n\t            this._progressiveToken = -1;\n\t            this._progress = 0;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                layer.__dirty && layer.clear();\n\t            });\n\t        },\n\t\n\t        _paintList: function (list, paintAll) {\n\t\n\t            if (paintAll == null) {\n\t                paintAll = false;\n\t            }\n\t\n\t            this._updateLayerStatus(list);\n\t\n\t            this._clearProgressive();\n\t\n\t            this.eachBuiltinLayer(preProcessLayer);\n\t\n\t            this._doPaintList(list, paintAll);\n\t\n\t            this.eachBuiltinLayer(postProcessLayer);\n\t        },\n\t\n\t        _doPaintList: function (list, paintAll) {\n\t            var currentLayer;\n\t            var currentZLevel;\n\t            var ctx;\n\t\n\t            // var invTransform = [];\n\t            var scope;\n\t\n\t            var progressiveLayerIdx = 0;\n\t            var currentProgressiveLayer;\n\t\n\t            var width = this._width;\n\t            var height = this._height;\n\t            var layerProgress;\n\t            var frame = this._progress;\n\t            function flushProgressiveLayer(layer) {\n\t                var dpr = ctx.dpr || 1;\n\t                ctx.save();\n\t                ctx.globalAlpha = 1;\n\t                ctx.shadowBlur = 0;\n\t                // Avoid layer don't clear in next progressive frame\n\t                currentLayer.__dirty = true;\n\t                ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t                ctx.restore();\n\t            }\n\t\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t\n\t                var elFrame = el.__frame;\n\t\n\t                // Flush at current context\n\t                // PENDING\n\t                if (elFrame < 0 && currentProgressiveLayer) {\n\t                    flushProgressiveLayer(currentProgressiveLayer);\n\t                    currentProgressiveLayer = null;\n\t                }\n\t\n\t                // Change draw layer\n\t                if (currentZLevel !== elZLevel) {\n\t                    if (ctx) {\n\t                        ctx.restore();\n\t                    }\n\t\n\t                    // Reset scope\n\t                    scope = {};\n\t\n\t                    // Only 0 zlevel if only has one canvas\n\t                    currentZLevel = elZLevel;\n\t                    currentLayer = this.getLayer(currentZLevel);\n\t\n\t                    if (!currentLayer.__builtin__) {\n\t                        log(\n\t                            'ZLevel ' + currentZLevel\n\t                            + ' has been used by unkown layer ' + currentLayer.id\n\t                        );\n\t                    }\n\t\n\t                    ctx = currentLayer.ctx;\n\t                    ctx.save();\n\t\n\t                    // Reset the count\n\t                    currentLayer.__unusedCount = 0;\n\t\n\t                    if (currentLayer.__dirty || paintAll) {\n\t                        currentLayer.clear();\n\t                    }\n\t                }\n\t\n\t                if (!(currentLayer.__dirty || paintAll)) {\n\t                    continue;\n\t                }\n\t\n\t                if (elFrame >= 0) {\n\t                    // Progressive layer changed\n\t                    if (!currentProgressiveLayer) {\n\t                        currentProgressiveLayer = this._progressiveLayers[\n\t                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n\t                        ];\n\t\n\t                        currentProgressiveLayer.ctx.save();\n\t                        currentProgressiveLayer.renderScope = {};\n\t\n\t                        if (currentProgressiveLayer\n\t                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n\t                        ) {\n\t                            // flushProgressiveLayer(currentProgressiveLayer);\n\t                            // Quick jump all progressive elements\n\t                            // All progressive element are not dirty, jump over and flush directly\n\t                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n\t                            // currentProgressiveLayer = null;\n\t                            continue;\n\t                        }\n\t\n\t                        layerProgress = currentProgressiveLayer.__progress;\n\t\n\t                        if (!currentProgressiveLayer.__dirty) {\n\t                            // Keep rendering\n\t                            frame = layerProgress;\n\t                        }\n\t\n\t                        currentProgressiveLayer.__progress = frame + 1;\n\t                    }\n\t\n\t                    if (elFrame === frame) {\n\t                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t                    }\n\t                }\n\t                else {\n\t                    this._doPaintEl(el, currentLayer, paintAll, scope);\n\t                }\n\t\n\t                el.__dirty = false;\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                flushProgressiveLayer(currentProgressiveLayer);\n\t            }\n\t\n\t            // Restore the lastLayer ctx\n\t            ctx && ctx.restore();\n\t            // If still has clipping state\n\t            // if (scope.prevElClipPaths) {\n\t            //     ctx.restore();\n\t            // }\n\t\n\t            this._furtherProgressive = false;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                if (layer.__maxProgress >= layer.__progress) {\n\t                    this._furtherProgressive = true;\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t            var ctx = currentLayer.ctx;\n\t            var m = el.transform;\n\t            if (\n\t                (currentLayer.__dirty || forcePaint)\n\t                // Ignore invisible element\n\t                && !el.invisible\n\t                // Ignore transparent element\n\t                && el.style.opacity !== 0\n\t                // Ignore scale 0 element, in some environment like node-canvas\n\t                // Draw a scale 0 element can cause all following draw wrong\n\t                // And setTransform with scale 0 will cause set back transform failed.\n\t                && !(m && !m[0] && !m[3])\n\t                // Ignore culled element\n\t                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n\t            ) {\n\t\n\t                var clipPaths = el.__clipPaths;\n\t\n\t                // Optimize when clipping on group with several elements\n\t                if (scope.prevClipLayer !== currentLayer\n\t                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n\t                ) {\n\t                    // If has previous clipping state, restore from it\n\t                    if (scope.prevElClipPaths) {\n\t                        scope.prevClipLayer.ctx.restore();\n\t                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\t\n\t                        // Reset prevEl since context has been restored\n\t                        scope.prevEl = null;\n\t                    }\n\t                    // New clipping state\n\t                    if (clipPaths) {\n\t                        ctx.save();\n\t                        doClip(clipPaths, ctx);\n\t                        scope.prevClipLayer = currentLayer;\n\t                        scope.prevElClipPaths = clipPaths;\n\t                    }\n\t                }\n\t                el.beforeBrush && el.beforeBrush(ctx);\n\t\n\t                el.brush(ctx, scope.prevEl || null);\n\t                scope.prevEl = el;\n\t\n\t                el.afterBrush && el.afterBrush(ctx);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n\t         * @param {number} zlevel\n\t         * @return {module:zrender/Layer}\n\t         */\n\t        getLayer: function (zlevel) {\n\t            if (this._singleCanvas) {\n\t                return this._layers[0];\n\t            }\n\t\n\t            var layer = this._layers[zlevel];\n\t            if (!layer) {\n\t                // Create a new layer\n\t                layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t                layer.__builtin__ = true;\n\t\n\t                if (this._layerConfig[zlevel]) {\n\t                    util.merge(layer, this._layerConfig[zlevel], true);\n\t                }\n\t\n\t                this.insertLayer(zlevel, layer);\n\t\n\t                // Context is created after dom inserted to document\n\t                // Or excanvas will get 0px clientWidth and clientHeight\n\t                layer.initContext();\n\t            }\n\t\n\t            return layer;\n\t        },\n\t\n\t        insertLayer: function (zlevel, layer) {\n\t\n\t            var layersMap = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var len = zlevelList.length;\n\t            var prevLayer = null;\n\t            var i = -1;\n\t            var domRoot = this._domRoot;\n\t\n\t            if (layersMap[zlevel]) {\n\t                log('ZLevel ' + zlevel + ' has been used already');\n\t                return;\n\t            }\n\t            // Check if is a valid layer\n\t            if (!isLayerValid(layer)) {\n\t                log('Layer of zlevel ' + zlevel + ' is not valid');\n\t                return;\n\t            }\n\t\n\t            if (len > 0 && zlevel > zlevelList[0]) {\n\t                for (i = 0; i < len - 1; i++) {\n\t                    if (\n\t                        zlevelList[i] < zlevel\n\t                        && zlevelList[i + 1] > zlevel\n\t                    ) {\n\t                        break;\n\t                    }\n\t                }\n\t                prevLayer = layersMap[zlevelList[i]];\n\t            }\n\t            zlevelList.splice(i + 1, 0, zlevel);\n\t\n\t            layersMap[zlevel] = layer;\n\t\n\t            // Vitual layer will not directly show on the screen.\n\t            // (It can be a WebGL layer and assigned to a ZImage element)\n\t            // But it still under management of zrender.\n\t            if (!layer.virtual) {\n\t                if (prevLayer) {\n\t                    var prevDom = prevLayer.dom;\n\t                    if (prevDom.nextSibling) {\n\t                        domRoot.insertBefore(\n\t                            layer.dom,\n\t                            prevDom.nextSibling\n\t                        );\n\t                    }\n\t                    else {\n\t                        domRoot.appendChild(layer.dom);\n\t                    }\n\t                }\n\t                else {\n\t                    if (domRoot.firstChild) {\n\t                        domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t                    }\n\t                    else {\n\t                        domRoot.appendChild(layer.dom);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        // Iterate each layer\n\t        eachLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                cb.call(context, this._layers[z], z);\n\t            }\n\t        },\n\t\n\t        // Iterate each buildin layer\n\t        eachBuiltinLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (layer.__builtin__) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        // Iterate each other layer except buildin layer\n\t        eachOtherLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (!layer.__builtin__) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 获取所有已创建的层\n\t         * @param {Array.<module:zrender/Layer>} [prevLayer]\n\t         */\n\t        getLayers: function () {\n\t            return this._layers;\n\t        },\n\t\n\t        _updateLayerStatus: function (list) {\n\t\n\t            var layers = this._layers;\n\t            var progressiveLayers = this._progressiveLayers;\n\t\n\t            var elCountsLastFrame = {};\n\t            var progressiveElCountsLastFrame = {};\n\t\n\t            this.eachBuiltinLayer(function (layer, z) {\n\t                elCountsLastFrame[z] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                progressiveElCountsLastFrame[idx] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            var progressiveLayerCount = 0;\n\t            var currentProgressiveLayer;\n\t            var lastProgressiveKey;\n\t            var frameCount = 0;\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var layer = layers[zlevel];\n\t                var elProgress = el.progressive;\n\t                if (layer) {\n\t                    layer.elCount++;\n\t                    layer.__dirty = layer.__dirty || el.__dirty;\n\t                }\n\t\n\t                /////// Update progressive\n\t                if (elProgress >= 0) {\n\t                    // Fix wrong progressive sequence problem.\n\t                    if (lastProgressiveKey !== elProgress) {\n\t                        lastProgressiveKey = elProgress;\n\t                        frameCount++;\n\t                    }\n\t                    var elFrame = el.__frame = frameCount - 1;\n\t                    if (!currentProgressiveLayer) {\n\t                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t                        currentProgressiveLayer = progressiveLayers[idx];\n\t                        if (!currentProgressiveLayer) {\n\t                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n\t                                'progressive', this, this.dpr\n\t                            );\n\t                            currentProgressiveLayer.initContext();\n\t                        }\n\t                        currentProgressiveLayer.__maxProgress = 0;\n\t                    }\n\t                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t                    currentProgressiveLayer.elCount++;\n\t\n\t                    currentProgressiveLayer.__maxProgress = Math.max(\n\t                        currentProgressiveLayer.__maxProgress, elFrame\n\t                    );\n\t\n\t                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t                        // Should keep rendering this  layer because progressive rendering is not finished yet\n\t                        layer.__dirty = true;\n\t                    }\n\t                }\n\t                else {\n\t                    el.__frame = -1;\n\t\n\t                    if (currentProgressiveLayer) {\n\t                        currentProgressiveLayer.__nextIdxNotProg = i;\n\t                        progressiveLayerCount++;\n\t                        currentProgressiveLayer = null;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                progressiveLayerCount++;\n\t                currentProgressiveLayer.__nextIdxNotProg = i;\n\t            }\n\t\n\t            // 层中的元素数量有发生变化\n\t            this.eachBuiltinLayer(function (layer, z) {\n\t                if (elCountsLastFrame[z] !== layer.elCount) {\n\t                    layer.__dirty = true;\n\t                }\n\t            });\n\t\n\t            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t                    el.__dirty = true;\n\t                }\n\t                if (layer.__dirty) {\n\t                    layer.__progress = 0;\n\t                }\n\t            });\n\t        },\n\t\n\t        /**\n\t         * 清除hover层外所有内容\n\t         */\n\t        clear: function () {\n\t            this.eachBuiltinLayer(this._clearLayer);\n\t            return this;\n\t        },\n\t\n\t        _clearLayer: function (layer) {\n\t            layer.clear();\n\t        },\n\t\n\t        /**\n\t         * 修改指定zlevel的绘制参数\n\t         *\n\t         * @param {string} zlevel\n\t         * @param {Object} config 配置对象\n\t         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n\t         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n\t         * @param {number} [config.lastFrameAlpha=0.7]\n\t         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t         */\n\t        configLayer: function (zlevel, config) {\n\t            if (config) {\n\t                var layerConfig = this._layerConfig;\n\t                if (!layerConfig[zlevel]) {\n\t                    layerConfig[zlevel] = config;\n\t                }\n\t                else {\n\t                    util.merge(layerConfig[zlevel], config, true);\n\t                }\n\t\n\t                var layer = this._layers[zlevel];\n\t\n\t                if (layer) {\n\t                    util.merge(layer, layerConfig[zlevel], true);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 删除指定层\n\t         * @param {number} zlevel 层所在的zlevel\n\t         */\n\t        delLayer: function (zlevel) {\n\t            var layers = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var layer = layers[zlevel];\n\t            if (!layer) {\n\t                return;\n\t            }\n\t            layer.dom.parentNode.removeChild(layer.dom);\n\t            delete layers[zlevel];\n\t\n\t            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t        },\n\t\n\t        /**\n\t         * 区域大小变化后重绘\n\t         */\n\t        resize: function (width, height) {\n\t            var domRoot = this._domRoot;\n\t            // FIXME Why ?\n\t            domRoot.style.display = 'none';\n\t\n\t            // Save input w/h\n\t            var opts = this._opts;\n\t            width != null && (opts.width = width);\n\t            height != null && (opts.height = height);\n\t\n\t            width = this._getSize(0);\n\t            height = this._getSize(1);\n\t\n\t            domRoot.style.display = '';\n\t\n\t            // 优化没有实际改变的resize\n\t            if (this._width != width || height != this._height) {\n\t                domRoot.style.width = width + 'px';\n\t                domRoot.style.height = height + 'px';\n\t\n\t                for (var id in this._layers) {\n\t                    if (this._layers.hasOwnProperty(id)) {\n\t                        this._layers[id].resize(width, height);\n\t                    }\n\t                }\n\t                util.each(this._progressiveLayers, function (layer) {\n\t                    layer.resize(width, height);\n\t                });\n\t\n\t                this.refresh(true);\n\t            }\n\t\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 清除单独的一个层\n\t         * @param {number} zlevel\n\t         */\n\t        clearLayer: function (zlevel) {\n\t            var layer = this._layers[zlevel];\n\t            if (layer) {\n\t                layer.clear();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 释放\n\t         */\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t\n\t            this.root =\n\t            this.storage =\n\t\n\t            this._domRoot =\n\t            this._layers = null;\n\t        },\n\t\n\t        /**\n\t         * Get canvas which has all thing rendered\n\t         * @param {Object} opts\n\t         * @param {string} [opts.backgroundColor]\n\t         */\n\t        getRenderedCanvas: function (opts) {\n\t            opts = opts || {};\n\t            if (this._singleCanvas) {\n\t                return this._layers[0].dom;\n\t            }\n\t\n\t            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t            imageLayer.initContext();\n\t\n\t            imageLayer.clearColor = opts.backgroundColor;\n\t            imageLayer.clear();\n\t\n\t            var displayList = this.storage.getDisplayList(true);\n\t\n\t            var scope = {};\n\t            for (var i = 0; i < displayList.length; i++) {\n\t                var el = displayList[i];\n\t                this._doPaintEl(el, imageLayer, true, scope);\n\t            }\n\t\n\t            return imageLayer.dom;\n\t        },\n\t        /**\n\t         * 获取绘图区域宽度\n\t         */\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t\n\t        /**\n\t         * 获取绘图区域高度\n\t         */\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t\n\t        _getSize: function (whIdx) {\n\t            var opts = this._opts;\n\t            var wh = ['width', 'height'][whIdx];\n\t            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n\t            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n\t            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\t\n\t            if (opts[wh] != null && opts[wh] !== 'auto') {\n\t                return parseFloat(opts[wh]);\n\t            }\n\t\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t\n\t            return (\n\t                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n\t                - (parseInt10(stl[plt]) || 0)\n\t                - (parseInt10(stl[prb]) || 0)\n\t            ) | 0;\n\t        },\n\t\n\t        pathToImage: function (path, dpr) {\n\t            dpr = dpr || this.dpr;\n\t\n\t            var canvas = document.createElement('canvas');\n\t            var ctx = canvas.getContext('2d');\n\t            var rect = path.getBoundingRect();\n\t            var style = path.style;\n\t            var shadowBlurSize = style.shadowBlur;\n\t            var shadowOffsetX = style.shadowOffsetX;\n\t            var shadowOffsetY = style.shadowOffsetY;\n\t            var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\t\n\t            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n\t            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n\t            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n\t            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n\t            var width = rect.width + leftMargin + rightMargin;\n\t            var height = rect.height + topMargin + bottomMargin;\n\t\n\t            canvas.width = width * dpr;\n\t            canvas.height = height * dpr;\n\t\n\t            ctx.scale(dpr, dpr);\n\t            ctx.clearRect(0, 0, width, height);\n\t            ctx.dpr = dpr;\n\t\n\t            var pathTransform = {\n\t                position: path.position,\n\t                rotation: path.rotation,\n\t                scale: path.scale\n\t            };\n\t            path.position = [leftMargin - rect.x, topMargin - rect.y];\n\t            path.rotation = 0;\n\t            path.scale = [1, 1];\n\t            path.updateTransform();\n\t            if (path) {\n\t                path.brush(ctx);\n\t            }\n\t\n\t            var ImageShape = __webpack_require__(35);\n\t            var imgShape = new ImageShape({\n\t                style: {\n\t                    x: 0,\n\t                    y: 0,\n\t                    image: canvas\n\t                }\n\t            });\n\t\n\t            if (pathTransform.position != null) {\n\t                imgShape.position = path.position = pathTransform.position;\n\t            }\n\t\n\t            if (pathTransform.rotation != null) {\n\t                imgShape.rotation = path.rotation = pathTransform.rotation;\n\t            }\n\t\n\t            if (pathTransform.scale != null) {\n\t                imgShape.scale = path.scale = pathTransform.scale;\n\t            }\n\t\n\t            return imgShape;\n\t        }\n\t    };\n\t\n\t    module.exports = Painter;\n\t\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/Layer\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(6);\n\t    var config = __webpack_require__(23);\n\t    var Style = __webpack_require__(33);\n\t    var Pattern = __webpack_require__(34);\n\t\n\t    function returnFalse() {\n\t        return false;\n\t    }\n\t\n\t    /**\n\t     * 创建dom\n\t     *\n\t     * @inner\n\t     * @param {string} id dom id 待用\n\t     * @param {string} type dom type，such as canvas, div etc.\n\t     * @param {Painter} painter painter instance\n\t     * @param {number} number\n\t     */\n\t    function createDom(id, type, painter, dpr) {\n\t        var newDom = document.createElement(type);\n\t        var width = painter.getWidth();\n\t        var height = painter.getHeight();\n\t\n\t        var newDomStyle = newDom.style;\n\t        // 没append呢，请原谅我这样写，清晰~\n\t        newDomStyle.position = 'absolute';\n\t        newDomStyle.left = 0;\n\t        newDomStyle.top = 0;\n\t        newDomStyle.width = width + 'px';\n\t        newDomStyle.height = height + 'px';\n\t        newDom.width = width * dpr;\n\t        newDom.height = height * dpr;\n\t\n\t        // id不作为索引用，避免可能造成的重名，定义为私有属性\n\t        newDom.setAttribute('data-zr-dom-id', id);\n\t        return newDom;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Layer\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @param {string} id\n\t     * @param {module:zrender/Painter} painter\n\t     * @param {number} [dpr]\n\t     */\n\t    var Layer = function(id, painter, dpr) {\n\t        var dom;\n\t        dpr = dpr || config.devicePixelRatio;\n\t        if (typeof id === 'string') {\n\t            dom = createDom(id, 'canvas', painter, dpr);\n\t        }\n\t        // Not using isDom because in node it will return false\n\t        else if (util.isObject(id)) {\n\t            dom = id;\n\t            id = dom.id;\n\t        }\n\t        this.id = id;\n\t        this.dom = dom;\n\t\n\t        var domStyle = dom.style;\n\t        if (domStyle) { // Not in node\n\t            dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t            domStyle['-webkit-user-select'] = 'none';\n\t            domStyle['user-select'] = 'none';\n\t            domStyle['-webkit-touch-callout'] = 'none';\n\t            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t            domStyle['padding'] = 0;\n\t            domStyle['margin'] = 0;\n\t            domStyle['border-width'] = 0;\n\t        }\n\t\n\t        this.domBack = null;\n\t        this.ctxBack = null;\n\t\n\t        this.painter = painter;\n\t\n\t        this.config = null;\n\t\n\t        // Configs\n\t        /**\n\t         * 每次清空画布的颜色\n\t         * @type {string}\n\t         * @default 0\n\t         */\n\t        this.clearColor = 0;\n\t        /**\n\t         * 是否开启动态模糊\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        this.motionBlur = false;\n\t        /**\n\t         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t         * @type {number}\n\t         * @default 0.7\n\t         */\n\t        this.lastFrameAlpha = 0.7;\n\t\n\t        /**\n\t         * Layer dpr\n\t         * @type {number}\n\t         */\n\t        this.dpr = dpr;\n\t    };\n\t\n\t    Layer.prototype = {\n\t\n\t        constructor: Layer,\n\t\n\t        elCount: 0,\n\t\n\t        __dirty: true,\n\t\n\t        initContext: function () {\n\t            this.ctx = this.dom.getContext('2d');\n\t\n\t            this.ctx.dpr = this.dpr;\n\t        },\n\t\n\t        createBackBuffer: function () {\n\t            var dpr = this.dpr;\n\t\n\t            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n\t            this.ctxBack = this.domBack.getContext('2d');\n\t\n\t            if (dpr != 1) {\n\t                this.ctxBack.scale(dpr, dpr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param  {number} width\n\t         * @param  {number} height\n\t         */\n\t        resize: function (width, height) {\n\t            var dpr = this.dpr;\n\t\n\t            var dom = this.dom;\n\t            var domStyle = dom.style;\n\t            var domBack = this.domBack;\n\t\n\t            domStyle.width = width + 'px';\n\t            domStyle.height = height + 'px';\n\t\n\t            dom.width = width * dpr;\n\t            dom.height = height * dpr;\n\t\n\t            if (domBack) {\n\t                domBack.width = width * dpr;\n\t                domBack.height = height * dpr;\n\t\n\t                if (dpr != 1) {\n\t                    this.ctxBack.scale(dpr, dpr);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 清空该层画布\n\t         * @param {boolean} clearAll Clear all with out motion blur\n\t         */\n\t        clear: function (clearAll) {\n\t            var dom = this.dom;\n\t            var ctx = this.ctx;\n\t            var width = dom.width;\n\t            var height = dom.height;\n\t\n\t            var clearColor = this.clearColor;\n\t            var haveMotionBLur = this.motionBlur && !clearAll;\n\t            var lastFrameAlpha = this.lastFrameAlpha;\n\t\n\t            var dpr = this.dpr;\n\t\n\t            if (haveMotionBLur) {\n\t                if (!this.domBack) {\n\t                    this.createBackBuffer();\n\t                }\n\t\n\t                this.ctxBack.globalCompositeOperation = 'copy';\n\t                this.ctxBack.drawImage(\n\t                    dom, 0, 0,\n\t                    width / dpr,\n\t                    height / dpr\n\t                );\n\t            }\n\t\n\t            ctx.clearRect(0, 0, width, height);\n\t            if (clearColor) {\n\t                var clearColorGradientOrPattern;\n\t                // Gradient\n\t                if (clearColor.colorStops) {\n\t                    // Cache canvas gradient\n\t                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t                        x: 0,\n\t                        y: 0,\n\t                        width: width,\n\t                        height: height\n\t                    });\n\t\n\t                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t                }\n\t                // Pattern\n\t                else if (clearColor.image) {\n\t                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t                }\n\t                ctx.save();\n\t                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t                ctx.fillRect(0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t\n\t            if (haveMotionBLur) {\n\t                var domBack = this.domBack;\n\t                ctx.save();\n\t                ctx.globalAlpha = lastFrameAlpha;\n\t                ctx.drawImage(domBack, 0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Layer;\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/graphic/Style\n\t */\n\t\n\t\n\t    var STYLE_COMMON_PROPS = [\n\t        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n\t        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n\t    ];\n\t\n\t    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t\n\t    var Style = function (opts) {\n\t        this.extendFrom(opts);\n\t    };\n\t\n\t    function createLinearGradient(ctx, obj, rect) {\n\t        // var size =\n\t        var x = obj.x;\n\t        var x2 = obj.x2;\n\t        var y = obj.y;\n\t        var y2 = obj.y2;\n\t\n\t        if (!obj.global) {\n\t            x = x * rect.width + rect.x;\n\t            x2 = x2 * rect.width + rect.x;\n\t            y = y * rect.height + rect.y;\n\t            y2 = y2 * rect.height + rect.y;\n\t        }\n\t\n\t        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t    function createRadialGradient(ctx, obj, rect) {\n\t        var width = rect.width;\n\t        var height = rect.height;\n\t        var min = Math.min(width, height);\n\t\n\t        var x = obj.x;\n\t        var y = obj.y;\n\t        var r = obj.r;\n\t        if (!obj.global) {\n\t            x = x * width + rect.x;\n\t            y = y * height + rect.y;\n\t            r = r * min;\n\t        }\n\t\n\t        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t\n\t    Style.prototype = {\n\t\n\t        constructor: Style,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        fill: '#000000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        stroke: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        opacity: 1,\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         */\n\t        lineDash: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineDashOffset: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowBlur: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetX: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetY: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineWidth: 1,\n\t\n\t        /**\n\t         * If stroke ignore scale\n\t         * @type {Boolean}\n\t         */\n\t        strokeNoScale: false,\n\t\n\t        // Bounding rect text configuration\n\t        // Not affected by element transform\n\t        /**\n\t         * @type {string}\n\t         */\n\t        text: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textFill: '#000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textStroke: null,\n\t\n\t        /**\n\t         * 'inside', 'left', 'right', 'top', 'bottom'\n\t         * [x, y]\n\t         * @type {string|Array.<number>}\n\t         * @default 'inside'\n\t         */\n\t        textPosition: 'inside',\n\t\n\t        /**\n\t         * [x, y]\n\t         * @type {Array.<number>}\n\t         */\n\t        textOffset: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textBaseline: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textAlign: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textVerticalAlign: null,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textDistance: 5,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowBlur: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetX: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetY: 0,\n\t\n\t        /**\n\t         * If transform text\n\t         * Only useful in Path and Image element\n\t         * @type {boolean}\n\t         */\n\t        textTransform: false,\n\t\n\t        /**\n\t         * Text rotate around position of Path or Image\n\t         * Only useful in Path and Image element and textTransform is false.\n\t         */\n\t        textRotation: 0,\n\t\n\t        /**\n\t         * @type {string}\n\t         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t         */\n\t        blend: null,\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         */\n\t        bind: function (ctx, el, prevEl) {\n\t            var style = this;\n\t            var prevStyle = prevEl && prevEl.style;\n\t            var firstDraw = !prevStyle;\n\t\n\t            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t                var prop = STYLE_COMMON_PROPS[i];\n\t                var styleName = prop[0];\n\t\n\t                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t                    // FIXME Invalid property value will cause style leak from previous element.\n\t                    ctx[styleName] = style[styleName] || prop[1];\n\t                }\n\t            }\n\t\n\t            if ((firstDraw || style.fill !== prevStyle.fill)) {\n\t                ctx.fillStyle = style.fill;\n\t            }\n\t            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n\t                ctx.strokeStyle = style.stroke;\n\t            }\n\t            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n\t                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t            }\n\t\n\t            if ((firstDraw || style.blend !== prevStyle.blend)) {\n\t                ctx.globalCompositeOperation = style.blend || 'source-over';\n\t            }\n\t            if (this.hasStroke()) {\n\t                var lineWidth = style.lineWidth;\n\t                ctx.lineWidth = lineWidth / (\n\t                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n\t                );\n\t            }\n\t        },\n\t\n\t        hasFill: function () {\n\t            var fill = this.fill;\n\t            return fill != null && fill !== 'none';\n\t        },\n\t\n\t        hasStroke: function () {\n\t            var stroke = this.stroke;\n\t            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t        },\n\t\n\t        /**\n\t         * Extend from other style\n\t         * @param {zrender/graphic/Style} otherStyle\n\t         * @param {boolean} overwrite\n\t         */\n\t        extendFrom: function (otherStyle, overwrite) {\n\t            if (otherStyle) {\n\t                var target = this;\n\t                for (var name in otherStyle) {\n\t                    if (otherStyle.hasOwnProperty(name)\n\t                        && (overwrite || ! target.hasOwnProperty(name))\n\t                    ) {\n\t                        target[name] = otherStyle[name];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Batch setting style with a given object\n\t         * @param {Object|string} obj\n\t         * @param {*} [obj]\n\t         */\n\t        set: function (obj, value) {\n\t            if (typeof obj === 'string') {\n\t                this[obj] = value;\n\t            }\n\t            else {\n\t                this.extendFrom(obj, true);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clone\n\t         * @return {zrender/graphic/Style} [description]\n\t         */\n\t        clone: function () {\n\t            var newStyle = new this.constructor();\n\t            newStyle.extendFrom(this, true);\n\t            return newStyle;\n\t        },\n\t\n\t        getGradient: function (ctx, obj, rect) {\n\t            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t            var canvasGradient = method(ctx, obj, rect);\n\t            var colorStops = obj.colorStops;\n\t            for (var i = 0; i < colorStops.length; i++) {\n\t                canvasGradient.addColorStop(\n\t                    colorStops[i].offset, colorStops[i].color\n\t                );\n\t            }\n\t            return canvasGradient;\n\t        }\n\t    };\n\t\n\t    var styleProto = Style.prototype;\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t        var prop = STYLE_COMMON_PROPS[i];\n\t        if (!(prop[0] in styleProto)) {\n\t            styleProto[prop[0]] = prop[1];\n\t        }\n\t    }\n\t\n\t    // Provide for others\n\t    Style.getGradient = styleProto.getGradient;\n\t\n\t    module.exports = Style;\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var Pattern = function (image, repeat) {\n\t        this.image = image;\n\t        this.repeat = repeat;\n\t\n\t        // Can be cloned\n\t        this.type = 'pattern';\n\t    };\n\t\n\t    Pattern.prototype.getCanvasPattern = function (ctx) {\n\t\n\t        return this._canvasPattern\n\t            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n\t    };\n\t\n\t    module.exports = Pattern;\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Image element\n\t * @module zrender/graphic/Image\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(36);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var zrUtil = __webpack_require__(6);\n\t\n\t    var LRU = __webpack_require__(21);\n\t    var globalImageCache = new LRU(50);\n\t    /**\n\t     * @alias zrender/graphic/Image\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function ZImage(opts) {\n\t        Displayable.call(this, opts);\n\t    }\n\t\n\t    ZImage.prototype = {\n\t\n\t        constructor: ZImage,\n\t\n\t        type: 'image',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var src = style.image;\n\t            var image;\n\t\n\t            // Must bind each time\n\t            style.bind(ctx, this, prevEl);\n\t            // style.image is a url string\n\t            if (typeof src === 'string') {\n\t                image = this._image;\n\t            }\n\t            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t            else {\n\t                image = src;\n\t            }\n\t            // FIXME Case create many images with src\n\t            if (!image && src) {\n\t                // Try get from global image cache\n\t                var cachedImgObj = globalImageCache.get(src);\n\t                if (!cachedImgObj) {\n\t                    // Create a new image\n\t                    image = new Image();\n\t                    image.onload = function () {\n\t                        image.onload = null;\n\t                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t                            cachedImgObj.pending[i].dirty();\n\t                        }\n\t                    };\n\t                    cachedImgObj = {\n\t                        image: image,\n\t                        pending: [this]\n\t                    };\n\t                    image.src = src;\n\t                    globalImageCache.put(src, cachedImgObj);\n\t                    this._image = image;\n\t                    return;\n\t                }\n\t                else {\n\t                    image = cachedImgObj.image;\n\t                    this._image = image;\n\t                    // Image is not complete finish, add to pending list\n\t                    if (!image.width || !image.height) {\n\t                        cachedImgObj.pending.push(this);\n\t                        return;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (image) {\n\t                // 图片已经加载完成\n\t                // if (image.nodeName.toUpperCase() == 'IMG') {\n\t                //     if (!image.complete) {\n\t                //         return;\n\t                //     }\n\t                // }\n\t                // Else is canvas\n\t\n\t                var x = style.x || 0;\n\t                var y = style.y || 0;\n\t                // 图片加载失败\n\t                if (!image.width || !image.height) {\n\t                    return;\n\t                }\n\t                var width = style.width;\n\t                var height = style.height;\n\t                var aspect = image.width / image.height;\n\t                if (width == null && height != null) {\n\t                    // Keep image/height ratio\n\t                    width = height * aspect;\n\t                }\n\t                else if (height == null && width != null) {\n\t                    height = width / aspect;\n\t                }\n\t                else if (width == null && height == null) {\n\t                    width = image.width;\n\t                    height = image.height;\n\t                }\n\t\n\t                // 设置transform\n\t                this.setTransform(ctx);\n\t\n\t                if (style.sWidth && style.sHeight) {\n\t                    var sx = style.sx || 0;\n\t                    var sy = style.sy || 0;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, style.sWidth, style.sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else if (style.sx && style.sy) {\n\t                    var sx = style.sx;\n\t                    var sy = style.sy;\n\t                    var sWidth = width - sx;\n\t                    var sHeight = height - sy;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, sWidth, sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else {\n\t                    ctx.drawImage(image, x, y, width, height);\n\t                }\n\t\n\t                this.restoreTransform(ctx);\n\t\n\t                // Draw rect text\n\t                if (style.text != null) {\n\t                    this.drawRectText(ctx, this.getBoundingRect());\n\t                }\n\t\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t            if (! this._rect) {\n\t                this._rect = new BoundingRect(\n\t                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n\t                );\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(ZImage, Displayable);\n\t\n\t    module.exports = ZImage;\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 可绘制的图形基类\n\t * Base class of all displayable graphic objects\n\t * @module zrender/graphic/Displayable\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(6);\n\t\n\t    var Style = __webpack_require__(33);\n\t\n\t    var Element = __webpack_require__(12);\n\t    var RectText = __webpack_require__(37);\n\t    // var Stateful = require('./mixin/Stateful');\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Displayable\n\t     * @extends module:zrender/Element\n\t     * @extends module:zrender/graphic/mixin/RectText\n\t     */\n\t    function Displayable(opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        // Extend properties\n\t        for (var name in opts) {\n\t            if (\n\t                opts.hasOwnProperty(name) &&\n\t                name !== 'style'\n\t            ) {\n\t                this[name] = opts[name];\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/graphic/Style}\n\t         */\n\t        this.style = new Style(opts.style);\n\t\n\t        this._rect = null;\n\t        // Shapes for cascade clipping.\n\t        this.__clipPaths = [];\n\t\n\t        // FIXME Stateful must be mixined after style is setted\n\t        // Stateful.call(this, opts);\n\t    }\n\t\n\t    Displayable.prototype = {\n\t\n\t        constructor: Displayable,\n\t\n\t        type: 'displayable',\n\t\n\t        /**\n\t         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n\t         * Dirty flag. From which painter will determine if this displayable object needs brush\n\t         * @name module:zrender/graphic/Displayable#__dirty\n\t         * @type {boolean}\n\t         */\n\t        __dirty: true,\n\t\n\t        /**\n\t         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n\t         * If ignore drawing of the displayable object. Mouse event will still be triggered\n\t         * @name module:/zrender/graphic/Displayable#invisible\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        invisible: false,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z: 0,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z2: 0,\n\t\n\t        /**\n\t         * z层level，决定绘画在哪层canvas中\n\t         * @name module:/zrender/graphic/Displayable#zlevel\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        zlevel: 0,\n\t\n\t        /**\n\t         * 是否可拖拽\n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        draggable: false,\n\t\n\t        /**\n\t         * 是否正在拖拽\n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        dragging: false,\n\t\n\t        /**\n\t         * 是否相应鼠标事件\n\t         * @name module:/zrender/graphic/Displayable#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * If enable culling\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        culling: false,\n\t\n\t        /**\n\t         * Mouse cursor when hovered\n\t         * @name module:/zrender/graphic/Displayable#cursor\n\t         * @type {string}\n\t         */\n\t        cursor: 'pointer',\n\t\n\t        /**\n\t         * If hover area is bounding rect\n\t         * @name module:/zrender/graphic/Displayable#rectHover\n\t         * @type {string}\n\t         */\n\t        rectHover: false,\n\t\n\t        /**\n\t         * Render the element progressively when the value >= 0,\n\t         * usefull for large data.\n\t         * @type {number}\n\t         */\n\t        progressive: -1,\n\t\n\t        beforeBrush: function (ctx) {},\n\t\n\t        afterBrush: function (ctx) {},\n\t\n\t        /**\n\t         * 图形绘制方法\n\t         * @param {Canvas2DRenderingContext} ctx\n\t         */\n\t        // Interface\n\t        brush: function (ctx, prevEl) {},\n\t\n\t        /**\n\t         * 获取最小包围盒\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        // Interface\n\t        getBoundingRect: function () {},\n\t\n\t        /**\n\t         * 判断坐标 x, y 是否在图形上\n\t         * If displayable element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        contain: function (x, y) {\n\t            return this.rectContain(x, y);\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            cb.call(context, this);\n\t        },\n\t\n\t        /**\n\t         * 判断坐标 x, y 是否在图形的包围盒上\n\t         * If bounding rect of element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        rectContain: function (x, y) {\n\t            var coord = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            return rect.contain(coord[0], coord[1]);\n\t        },\n\t\n\t        /**\n\t         * 标记图形元素为脏，并且在下一帧重绘\n\t         * Mark displayable element dirty and refresh next frame\n\t         */\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t\n\t            this._rect = null;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * 图形是否会触发事件\n\t         * If displayable object binded any event\n\t         * @return {boolean}\n\t         */\n\t        // TODO, 通过 bind 绑定的事件\n\t        // isSilent: function () {\n\t        //     return !(\n\t        //         this.hoverable || this.draggable\n\t        //         || this.onmousemove || this.onmouseover || this.onmouseout\n\t        //         || this.onmousedown || this.onmouseup || this.onclick\n\t        //         || this.ondragenter || this.ondragover || this.ondragleave\n\t        //         || this.ondrop\n\t        //     );\n\t        // },\n\t        /**\n\t         * Alias for animate('style')\n\t         * @param {boolean} loop\n\t         */\n\t        animateStyle: function (loop) {\n\t            return this.animate('style', loop);\n\t        },\n\t\n\t        attrKV: function (key, value) {\n\t            if (key !== 'style') {\n\t                Element.prototype.attrKV.call(this, key, value);\n\t            }\n\t            else {\n\t                this.style.set(value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setStyle: function (key, value) {\n\t            this.style.set(key, value);\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Use given style object\n\t         * @param  {Object} obj\n\t         */\n\t        useStyle: function (obj) {\n\t            this.style = new Style(obj);\n\t            this.dirty(false);\n\t            return this;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Displayable, Element);\n\t\n\t    zrUtil.mixin(Displayable, RectText);\n\t    // zrUtil.mixin(Displayable, Stateful);\n\t\n\t    module.exports = Displayable;\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Mixin for drawing text in a element bounding rect\n\t * @module zrender/mixin/RectText\n\t */\n\t\n\t\n\t\n\t    var textContain = __webpack_require__(38);\n\t    var BoundingRect = __webpack_require__(24);\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var RectText = function () {};\n\t\n\t    function parsePercent(value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    }\n\t\n\t    RectText.prototype = {\n\t\n\t        constructor: RectText,\n\t\n\t        /**\n\t         * Draw text in a rect with specified position.\n\t         * @param  {CanvasRenderingContext} ctx\n\t         * @param  {Object} rect Displayable rect\n\t         * @return {Object} textRect Alternative precalculated text bounding rect\n\t         */\n\t        drawRectText: function (ctx, rect, textRect) {\n\t            var style = this.style;\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            if (!text) {\n\t                return;\n\t            }\n\t\n\t            // FIXME\n\t            ctx.save();\n\t\n\t            var x;\n\t            var y;\n\t            var textPosition = style.textPosition;\n\t            var textOffset = style.textOffset;\n\t            var distance = style.textDistance;\n\t            var align = style.textAlign;\n\t            var font = style.textFont || style.font;\n\t            var baseline = style.textBaseline;\n\t            var verticalAlign = style.textVerticalAlign;\n\t\n\t            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t\n\t            // Transform rect to view space\n\t            var transform = this.transform;\n\t            if (!style.textTransform) {\n\t                if (transform) {\n\t                    tmpRect.copy(rect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = tmpRect;\n\t                }\n\t            }\n\t            else {\n\t                this.setTransform(ctx);\n\t            }\n\t\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                // Percent\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t\n\t                if (verticalAlign) {\n\t                    switch (verticalAlign) {\n\t                        case 'middle':\n\t                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= textRect.height - textRect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += textRect.lineHeight / 2;\n\t                    }\n\t                    // Force bseline to be middle\n\t                    baseline = 'middle';\n\t                }\n\t            }\n\t            else {\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, textRect, distance\n\t                );\n\t                x = res.x;\n\t                y = res.y;\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t\n\t            if (textOffset) {\n\t                x += textOffset[0];\n\t                y += textOffset[1];\n\t            }\n\t\n\t            // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t            ctx.textAlign = align || 'left';\n\t            // Use canvas default alphabetic baseline\n\t            ctx.textBaseline = baseline || 'alphabetic';\n\t\n\t            var textFill = style.textFill;\n\t            var textStroke = style.textStroke;\n\t            textFill && (ctx.fillStyle = textFill);\n\t            textStroke && (ctx.strokeStyle = textStroke);\n\t\n\t            // TODO Invalid font\n\t            ctx.font = font || '12px sans-serif';\n\t\n\t            // Text shadow\n\t            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n\t            ctx.shadowBlur = style.textShadowBlur;\n\t            ctx.shadowColor = style.textShadowColor || 'transparent';\n\t            ctx.shadowOffsetX = style.textShadowOffsetX;\n\t            ctx.shadowOffsetY = style.textShadowOffsetY;\n\t\n\t            var textLines = text.split('\\n');\n\t\n\t            if (style.textRotation) {\n\t                transform && ctx.translate(transform[4], transform[5]);\n\t                ctx.rotate(style.textRotation);\n\t                transform && ctx.translate(-transform[4], -transform[5]);\n\t            }\n\t\n\t            for (var i = 0; i < textLines.length; i++) {\n\t                    // Fill after stroke so the outline will not cover the main part.\n\t                textStroke && ctx.strokeText(textLines[i], x, y);\n\t                textFill && ctx.fillText(textLines[i], x, y);\n\t                y += textRect.lineHeight;\n\t            }\n\t\n\t            ctx.restore();\n\t        }\n\t    };\n\t\n\t    module.exports = RectText;\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var textWidthCache = {};\n\t    var textWidthCacheCounter = 0;\n\t    var TEXT_CACHE_MAX = 5000;\n\t\n\t    var util = __webpack_require__(6);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var retrieve = util.retrieve;\n\t\n\t    function getTextWidth(text, textFont) {\n\t        var key = text + ':' + textFont;\n\t        if (textWidthCache[key]) {\n\t            return textWidthCache[key];\n\t        }\n\t\n\t        var textLines = (text + '').split('\\n');\n\t        var width = 0;\n\t\n\t        for (var i = 0, l = textLines.length; i < l; i++) {\n\t            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n\t            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n\t        }\n\t\n\t        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t            textWidthCacheCounter = 0;\n\t            textWidthCache = {};\n\t        }\n\t        textWidthCacheCounter++;\n\t        textWidthCache[key] = width;\n\t\n\t        return width;\n\t    }\n\t\n\t    function getTextRect(text, textFont, textAlign, textBaseline) {\n\t        var textLineLen = ((text || '') + '').split('\\n').length;\n\t\n\t        var width = getTextWidth(text, textFont);\n\t        // FIXME 高度计算比较粗暴\n\t        var lineHeight = getTextWidth('国', textFont);\n\t        var height = textLineLen * lineHeight;\n\t\n\t        var rect = new BoundingRect(0, 0, width, height);\n\t        // Text has a special line height property\n\t        rect.lineHeight = lineHeight;\n\t\n\t        switch (textBaseline) {\n\t            case 'bottom':\n\t            case 'alphabetic':\n\t                rect.y -= lineHeight;\n\t                break;\n\t            case 'middle':\n\t                rect.y -= lineHeight / 2;\n\t                break;\n\t            // case 'hanging':\n\t            // case 'top':\n\t        }\n\t\n\t        // FIXME Right to left language\n\t        switch (textAlign) {\n\t            case 'end':\n\t            case 'right':\n\t                rect.x -= rect.width;\n\t                break;\n\t            case 'center':\n\t                rect.x -= rect.width / 2;\n\t                break;\n\t            // case 'start':\n\t            // case 'left':\n\t        }\n\t\n\t        return rect;\n\t    }\n\t\n\t    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\t\n\t        var x = rect.x;\n\t        var y = rect.y;\n\t\n\t        var height = rect.height;\n\t        var width = rect.width;\n\t\n\t        var textHeight = textRect.height;\n\t\n\t        var halfHeight = height / 2 - textHeight / 2;\n\t\n\t        var textAlign = 'left';\n\t\n\t        switch (textPosition) {\n\t            case 'left':\n\t                x -= distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'right':\n\t                x += distance + width;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'top':\n\t                x += width / 2;\n\t                y -= distance + textHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'bottom':\n\t                x += width / 2;\n\t                y += height + distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'inside':\n\t                x += width / 2;\n\t                y += halfHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideLeft':\n\t                x += distance;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideRight':\n\t                x += width - distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideTop':\n\t                x += width / 2;\n\t                y += distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideBottom':\n\t                x += width / 2;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideTopLeft':\n\t                x += distance;\n\t                y += distance;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideTopRight':\n\t                x += width - distance;\n\t                y += distance;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideBottomLeft':\n\t                x += distance;\n\t                y += height - textHeight - distance;\n\t                break;\n\t            case 'insideBottomRight':\n\t                x += width - distance;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'right';\n\t                break;\n\t        }\n\t\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            textAlign: textAlign,\n\t            textBaseline: 'top'\n\t        };\n\t    }\n\t\n\t    /**\n\t     * Show ellipsis if overflow.\n\t     *\n\t     * @param  {string} text\n\t     * @param  {string} containerWidth\n\t     * @param  {string} textFont\n\t     * @param  {number} [ellipsis='...']\n\t     * @param  {Object} [options]\n\t     * @param  {number} [options.maxIterations=3]\n\t     * @param  {number} [options.minChar=0] If truncate result are less\n\t     *                  then minChar, ellipsis will not show, which is\n\t     *                  better for user hint in some cases.\n\t     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t     * @return {string}\n\t     */\n\t    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n\t        if (!containerWidth) {\n\t            return '';\n\t        }\n\t\n\t        options = options || {};\n\t\n\t        ellipsis = retrieve(ellipsis, '...');\n\t        var maxIterations = retrieve(options.maxIterations, 2);\n\t        var minChar = retrieve(options.minChar, 0);\n\t        // FIXME\n\t        // Other languages?\n\t        var cnCharWidth = getTextWidth('国', textFont);\n\t        // FIXME\n\t        // Consider proportional font?\n\t        var ascCharWidth = getTextWidth('a', textFont);\n\t        var placeholder = retrieve(options.placeholder, '');\n\t\n\t        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\t        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\t        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t            contentWidth -= ascCharWidth;\n\t        }\n\t\n\t        var ellipsisWidth = getTextWidth(ellipsis);\n\t        if (ellipsisWidth > contentWidth) {\n\t            ellipsis = '';\n\t            ellipsisWidth = 0;\n\t        }\n\t\n\t        contentWidth = containerWidth - ellipsisWidth;\n\t\n\t        var textLines = (text + '').split('\\n');\n\t\n\t        for (var i = 0, len = textLines.length; i < len; i++) {\n\t            var textLine = textLines[i];\n\t            var lineWidth = getTextWidth(textLine, textFont);\n\t\n\t            if (lineWidth <= containerWidth) {\n\t                continue;\n\t            }\n\t\n\t            for (var j = 0;; j++) {\n\t                if (lineWidth <= contentWidth || j >= maxIterations) {\n\t                    textLine += ellipsis;\n\t                    break;\n\t                }\n\t\n\t                var subLength = j === 0\n\t                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n\t                    : lineWidth > 0\n\t                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n\t                    : 0;\n\t\n\t                textLine = textLine.substr(0, subLength);\n\t                lineWidth = getTextWidth(textLine, textFont);\n\t            }\n\t\n\t            if (textLine === '') {\n\t                textLine = placeholder;\n\t            }\n\t\n\t            textLines[i] = textLine;\n\t        }\n\t\n\t        return textLines.join('\\n');\n\t    }\n\t\n\t    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t        var width = 0;\n\t        var i = 0;\n\t        for (var len = text.length; i < len && width < contentWidth; i++) {\n\t            var charCode = text.charCodeAt(i);\n\t            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n\t        }\n\t        return i;\n\t    }\n\t\n\t    var textContain = {\n\t\n\t        getWidth: getTextWidth,\n\t\n\t        getBoundingRect: getTextRect,\n\t\n\t        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\t\n\t        truncateText: truncateText,\n\t\n\t        measureText: function (text, textFont) {\n\t            var ctx = util.getContext();\n\t            ctx.font = textFont || '12px sans-serif';\n\t            return ctx.measureText(text);\n\t        }\n\t    };\n\t\n\t    module.exports = textContain;\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO节点\r\n\t * 1.BO是一个矩形\r\n\t * 2.BO有名字\r\n\t * 3.BO有事件决策[]，双击事件决策弹出详情\r\n\t * 4.BO有外键属性[]\r\n\t * 5.BO有子BO\r\n\t * 6.当前BO特殊颜色显示\r\n\t * 7.双击BO弹出BO属性以及属性事件决策页面\r\n\t * @module fish-topo-bo/node/BoNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(40);\r\n\t    var BoName = __webpack_require__(41);\r\n\t    var EventDecision = __webpack_require__(73);\r\n\t    var Line = __webpack_require__(74);\r\n\t    var BoAttr = __webpack_require__(75);\r\n\t    var graphic = __webpack_require__(42);\r\n\t\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param {{\r\n\t     *          id: String BO主键,\r\n\t     *          name: String BO名字,\r\n\t     *          boEventArr: [] BO事件决策数组,\r\n\t     *          boAttrArr: [] BO属性数组\r\n\t     *          }} boData, bo数据对象\r\n\t     * @param {{\r\n\t     *          startPos: {x: number, y: number} 起始位置,\r\n\t     *          displayAttrDataType: boolean 是否显示属性数据类型,\r\n\t     *          displayAttrEvent: boolean 是否显示属性事件决策,\r\n\t     *          boClickable: boolean BO是否支持点击事件, 可空 默认false\r\n\t     *          boPopupOpts: Object BO弹出页面参数，url,width,height等\r\n\t     *          boEventClickable: boolean BO事件决策是否支持点击事件, 可空 默认false\r\n\t     *          boEventPopupOpts: Object BO事件决策弹出页面参数，url,width,height等\r\n\t     *          attrEventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false\r\n\t     *          attrEventPopupOpts: Object 点击BO属性事件决策弹出页面参数，url,width,height等\r\n\t     *          isCurrent: boolean 是否为当前BO\r\n\t     *          viewOption: 参数\r\n\t     *          }} opts\r\n\t     * @constructor\r\n\t     */\r\n\t    function BO(boData, opts) {\r\n\t\r\n\t        /**\r\n\t         * BO数据\r\n\t         * @type {Object}\r\n\t         * @private\r\n\t         */\r\n\t        this._data = boData;\r\n\t        this._data.viewOption = {};\r\n\t        fish.extend(this._data.viewOption, opts.viewOption||{});\r\n\t\r\n\t        /**\r\n\t         * 初始坐标，用于最后画BO矩形\r\n\t         * @type {{x: number, y: number}}\r\n\t         * @private\r\n\t         */\r\n\t        this._oriStartPos = opts.startPos;\r\n\t\r\n\t        /**\r\n\t         * 每个控件的起始参照坐标，每个控件画完之后都会重新计算\r\n\t         * @type {{x: number, y: number}}\r\n\t         * @private\r\n\t         */\r\n\t        this._nextStartPos = {\r\n\t            x: opts.startPos.x,\r\n\t            y: opts.startPos.y\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * 是否显示属性数据类型\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayAttrDataType = opts.displayAttrDataType || false;\r\n\t\r\n\t        /**\r\n\t         * 是否显示属性事件决策\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayAttrEvent = opts.displayAttrEvent || false;\r\n\t\r\n\t        //TODO\r\n\t        if (this._displayAttrEvent) {\r\n\t            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 3;\r\n\t        } else if (this._displayAttrDataType) {\r\n\t            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 1.5;\r\n\t        }\r\n\t\r\n\t        /**\r\n\t         * 是否支持点击\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._boClickable = opts.boClickable || false;\r\n\t        this._boPopupOpts = opts.boPopupOpts;\r\n\t        this._boEventClickable = opts.boEventClickable || false;\r\n\t        this._boEventPopupOpts = opts.boEventPopupOpts;\r\n\t        this._attrEventClickable = opts.attrEventClickable || false;\r\n\t        this._attrEventPopupOpts = opts.attrEventPopupOpts;\r\n\t\r\n\t        /**\r\n\t         * 是否是当前BO，当前BO特殊颜色显示\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._isCurrent = opts.isCurrent || false;\r\n\t\r\n\t\r\n\t        /**\r\n\t         * BO矩形高度，根据实际内容计算\r\n\t         * @type {number}\r\n\t         * @private\r\n\t         */\r\n\t        this._boShapeHeight = 0;\r\n\t\r\n\t        /**\r\n\t         * Group容器\r\n\t         * @type zrender/graphic/Group\r\n\t         * @private\r\n\t         */\r\n\t        this._group = new graphic.Group();\r\n\t        this._group.name = this._data.id;\r\n\t        this._group.setCurrent = function (style) {\r\n\t            //Group最后一个是BO矩形\r\n\t            var _boShape = this.childAt(this.childCount() - 1);\r\n\t\r\n\t            if (style) {\r\n\t                fish.extend(_boShape.style, style);\r\n\t            } else {\r\n\t                //默认效果\r\n\t                _boShape.style.fill = '#66CC99';\r\n\t            }\r\n\t\r\n\t        };\r\n\t\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t\r\n\t    var boProto = BO.prototype;\r\n\t\r\n\t    /**\r\n\t     * 获取BO整体图形\r\n\t     * @returns {zrender/graphic/Group}\r\n\t     */\r\n\t    boProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取数据\r\n\t     * @returns {Object}\r\n\t     */\r\n\t    boProto.getData = function () {\r\n\t        return this._data;\r\n\t    };\r\n\t\r\n\t    boProto.getLayout = function () {\r\n\t        return this._data.layout;\r\n\t    };\r\n\t\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 设置当前BO特殊演示显示\r\n\t     */\r\n\t    boProto.setCurrent = function () {\r\n\t        //BO矩形是最后一个图形\r\n\t        this.childAt(this.childCount - 1).style.fill = '#66CC99'\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成BO整体图形\r\n\t     * @private\r\n\t     */\r\n\t    boProto._render = function () {\r\n\t        //BO名字\r\n\t        this._createBoName();\r\n\t\r\n\t        //BO事件决策\r\n\t        this._createEventDecision();\r\n\t\r\n\t        //BO属性\r\n\t        this._createBoAttr();\r\n\t\r\n\t        //BO矩形\r\n\t        this._createBoShape();\r\n\t\r\n\t        //TODO\r\n\t        Const.BO_NODE_WIDTH = 180;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 生成BO名字文本\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createBoName = function () {\r\n\t        var _boNameShape = BoName(this._data.name, this._nextStartPos);\r\n\t\r\n\t        if (this._boClickable) {\r\n\t            _boNameShape.clickable = this._boClickable;\r\n\t            _boNameShape._data = this._data;\r\n\t            _boNameShape._boPopupOpts = this._boPopupOpts;\r\n\t            _boNameShape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t        this._group.add(_boNameShape);\r\n\t        this._calNextShapeStartPos(_boNameShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成BO事件决策\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createEventDecision = function () {\r\n\t\r\n\t        //如果没有BO事件决策，则返回\r\n\t        if (!this._data.boEventArr) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var _boEventArr = this._data.boEventArr,\r\n\t            _boEventLen = _boEventArr.length,\r\n\t            _eventShape,\r\n\t            _eventOpts = {\r\n\t                startPos: this._nextStartPos,\r\n\t                clickable: this._boEventClickable,\r\n\t                popupOpts: this._boEventPopupOpts\r\n\t            };\r\n\t\r\n\t        for (var i = 0; i < _boEventLen; i++) {\r\n\t            _eventShape = new EventDecision(_boEventArr[i], _eventOpts);\r\n\t            this._group.add(_eventShape.getShape());\r\n\t            this._calNextShapeStartPos(_eventShape.getShape());\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成BO属性\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createBoAttr = function () {\r\n\t        //如果没有BO属性，则返回\r\n\t        if (!this._data.boAttrArr) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var _boAttrArr = this._data.boAttrArr,\r\n\t            _boAttrLen = _boAttrArr.length,\r\n\t            _boAttrShape, _lineShape,\r\n\t            _attrEventStartPos = {x: this._nextStartPos.x + Const.BO_NODE_WIDTH / 2, y: this._nextStartPos.y};\r\n\t\r\n\t        for (var i = 0; i < _boAttrLen; i++) {\r\n\t            if (i == 0) {\r\n\t                _lineShape = Line.BoLine(this._nextStartPos); //实线\r\n\t            }\r\n\t            else {\r\n\t                _lineShape = Line.AttrLine(this._nextStartPos);//虚线\r\n\t            }\r\n\t\r\n\t            this._group.add(_lineShape);\r\n\t\r\n\t            this._calNextShapeStartPos(_lineShape);\r\n\t\r\n\t            _boAttrShape = new BoAttr(_boAttrArr[i],\r\n\t                {\r\n\t                    startPos: this._nextStartPos,\r\n\t                    displayDataType: this._displayAttrDataType,\r\n\t                    displayEventDecision: this._displayAttrEvent,\r\n\t                    eventClickable: this._attrEventClickable,\r\n\t                    eventPopupOpts: this._attrEventPopupOpts\r\n\t                }\r\n\t            );\r\n\t            this._group.add(_boAttrShape.getShape());\r\n\t            this._calNextShapeStartPos(_boAttrShape.getShape())\r\n\t        }\r\n\t\r\n\t        if (this._displayAttrEvent) {\r\n\t            _lineShape = Line.AttrEventLine(_attrEventStartPos,\r\n\t                this._nextStartPos.y - _attrEventStartPos.y\r\n\t            );\r\n\t            this._group.add(_lineShape);\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 计算下一个图形的开始位置，以及BO矩形的高度\r\n\t     * @param curShape 当前图形\r\n\t     * @private\r\n\t     */\r\n\t    boProto._calNextShapeStartPos = function (curShape) {\r\n\t        //下一图形起始位置\r\n\t        this._nextStartPos.y += curShape.getBoundingRect().height;\r\n\t\r\n\t        //BO矩形高度增加\r\n\t        this._boShapeHeight += curShape.getBoundingRect().height;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 生成BO矩形\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createBoShape = function () {\r\n\t        var height = this._boShapeHeight > Const.BO_NODE_DEFAULT_HEIGHT ?\r\n\t                this._boShapeHeight : Const.BO_NODE_DEFAULT_HEIGHT,\r\n\t            shape = new graphic.Rect({\r\n\t                position: [this._oriStartPos.x, this._oriStartPos.y],\r\n\t\r\n\t                shape: {\r\n\t                    r: 5,\r\n\t                    width: Const.BO_NODE_WIDTH,\r\n\t                    height: height\r\n\t                },\r\n\t\r\n\t                style: {\r\n\t                    brushType: 'both',\r\n\t                    fill: this._isCurrent ? '#66CC99' : 'white',\r\n\t                    stroke: '#000000',\r\n\t                    lineWidth: 1,\r\n\t                    lineCape: 'round'\r\n\t                },\r\n\t\r\n\t                zlevel: -1\r\n\t            });\r\n\t\r\n\t        if (this._boClickable) {\r\n\t            shape._data = this._data;\r\n\t            shape._boPopupOpts = this._boPopupOpts;\r\n\t\r\n\t            shape.clickable = this._boClickable;\r\n\t            shape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t        this._group.add(shape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 点击事件\r\n\t     * @private\r\n\t     */\r\n\t    boProto._click = function () {\r\n\t        var options = fish.extend(\r\n\t            {\r\n\t                viewOption: {\r\n\t                    DATA: this._data\r\n\t                },\r\n\t                width: 800,\r\n\t                height: 500\r\n\t            }, this._boPopupOpts);\r\n\t\r\n\t        fish.popupView(options);\r\n\t    };\r\n\t\r\n\t    module.exports = BO;\r\n\t\r\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    module.exports = {\r\n\t        BO_NODE_WIDTH: 180,    //BO矩形宽度\r\n\t        BO_NODE_DEFAULT_HEIGHT: 60,\t//BO矩形默认高度，即只有BO名字的情况\r\n\t        BO_NODE_OFFSET_X: 90, //BO矩形的水平偏移量=矩形宽度的一般\r\n\t        BO_NODE_OFFSET_Y: 50, //BO矩形的垂直偏移量\r\n\t\r\n\t        BO_NAME_FONT: 'bold 18px Arial', //'normal 16px verdana',    //BO名字文本样式,\r\n\t        BO_NAME_PADDING_TOP: 10,   //BO名字与矩形上边框的距离\r\n\t        BO_NAME_PADDING_BOTTOM: 15,   //BO名字与下一个控件（事件决策或者横线）的距离\r\n\t\r\n\t        BO_EVENT_HEIGHT: 20,   //BO事件决策多边形高度\r\n\t        BO_EVENT_WIDTH: 140,   //BO事件决策多边形宽度\r\n\t        BO_EVENT_FONT: 'normal 14px Arial',  //BO事件决策名字文本样式\r\n\t\r\n\t        BO_ATTR_FONT: 'normal 14px Arial',   //BO属性名字文本样式\r\n\t        BO_ATTR_PADDING_TOP: 5,   //BO属性名字与矩形上边框的距离\r\n\t        BO_ATTR_PADDING_BOTTOM: 5,   //BO属性名字与下一个控件（事件决策或者横线）的距离\r\n\t        BO_ATTR_PADDING_LEFT: 5,   //BO属性名字与矩形左边框的距离\r\n\t        BO_ATTR_DATA_TYPE_PADDING_RIGHT: 5, //BO属性数据类型与矩形右边框的距离\r\n\t        BO_ATTR_EVENT_WIDTH: 135,   //BO属性事件决策多边形宽度\r\n\t\r\n\t        LINE_DASH: 10,  //虚线\r\n\t        RELATION_OFFSET: 40,   //关联关系的初始偏移量，即第一段折线宽度\r\n\t        RELATION_ARROW_WIDTH: 10,  //关联关系三角箭头水平宽度\r\n\t        RELATION_ARROW_HEIGHT: 5,  //关联关系三角箭头垂直高度的一半\r\n\t        RELATION_TEXT_OFFSET_X: 10, //关联关系文字说明水平偏移量\r\n\t        RELATION_TEXT_OFFSET_Y: 5 //关联关系文字说明垂直偏移量\r\n\t    };\r\n\t\r\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO名字\r\n\t * @module fish-topo-bo/node/BoName\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(40);\r\n\t    var graphic = __webpack_require__(42);\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param {String} text, BO名字\r\n\t     * @param {{x: number, y: number}} startPos, 起始位置\r\n\t     * @returns {zrender/graphic/Text}\r\n\t     * @constructor\r\n\t     */\r\n\t    function BoName(text, startPos) {\r\n\t        var x = startPos.x,\r\n\t            y = startPos.y + Const.BO_NAME_PADDING_TOP, //文字到矩形上边框的距离 padding-top=10\r\n\t\r\n\t            shape = new graphic.Text({\r\n\t                style: {\r\n\t                    text: text,\r\n\t                    textFont: Const.BO_NAME_FONT,\r\n\t                    textAlign: 'left',  //靠左开始，便于计算位置\r\n\t                    textBaseline: 'top'\r\n\t                },\r\n\t\r\n\t                position: [x, y]\r\n\t            });\r\n\t\r\n\t        //文字居中显示，重新计算文本水平起始位置 = 矩形水平起始位置 + (BO矩形宽度 - 文本宽度)/2\r\n\t        shape.position[0] += (Const.BO_NODE_WIDTH - shape.getBoundingRect().width) / 2;\r\n\t\r\n\t        //重新设置BO名字图形高度 = 文本高度 + padding-top + padding-bottom\r\n\t        shape.getBoundingRect().height += Const.BO_NAME_PADDING_TOP + Const.BO_NAME_PADDING_BOTTOM;\r\n\t\r\n\t        return shape;\r\n\t    }\r\n\t\r\n\t    module.exports = BoName;\r\n\t\r\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(6);\r\n\t\r\n\t    var pathTool = __webpack_require__(43);\r\n\t    var round = Math.round;\r\n\t    var Path = __webpack_require__(44);\r\n\t    var colorTool = __webpack_require__(20);\r\n\t    var matrix = __webpack_require__(14);\r\n\t    var vector = __webpack_require__(15);\r\n\t    var Gradient = __webpack_require__(56);\r\n\t    var Draggable = __webpack_require__(8);\r\n\t\r\n\t    var graphic = {};\r\n\t    graphic.Util = zrUtil;\r\n\t    graphic.Group = __webpack_require__(11);\r\n\t\r\n\t    graphic.Image = __webpack_require__(35);\r\n\t\r\n\t    graphic.Text = __webpack_require__(57);\r\n\t\r\n\t    graphic.textContain = __webpack_require__(38);\r\n\t\r\n\t    graphic.Circle = __webpack_require__(58);\r\n\t\r\n\t    graphic.Sector = __webpack_require__(59);\r\n\t\r\n\t    graphic.Ring = __webpack_require__(60);\r\n\t\r\n\t    graphic.Polygon = __webpack_require__(61);\r\n\t\r\n\t    graphic.Polyline = __webpack_require__(65);\r\n\t\r\n\t    graphic.Rect = __webpack_require__(66);\r\n\t\r\n\t    graphic.Line = __webpack_require__(68);\r\n\t\r\n\t    graphic.BezierCurve = __webpack_require__(69);\r\n\t\r\n\t    graphic.Arc = __webpack_require__(70);\r\n\t\r\n\t    graphic.LinearGradient = __webpack_require__(71);\r\n\t\r\n\t    graphic.RadialGradient = __webpack_require__(72);\r\n\t\r\n\t    graphic.BoundingRect = __webpack_require__(24);\r\n\t\r\n\t    /**\r\n\t     * Extend shape with parameters\r\n\t     */\r\n\t    graphic.extendShape = function (opts) {\r\n\t        return Path.extend(opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Extend path\r\n\t     */\r\n\t    graphic.extendPath = function (pathData, opts) {\r\n\t        return pathTool.extendFromString(pathData, opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Create a path element from path data string\r\n\t     * @param {string} pathData\r\n\t     * @param {Object} opts\r\n\t     * @param {module:zrender/core/BoundingRect} rect\r\n\t     * @param {string} [layout=cover] 'center' or 'cover'\r\n\t     */\r\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\r\n\t        var path = pathTool.createFromString(pathData, opts);\r\n\t        Draggable.call(path);\r\n\t        var boundingRect = path.getBoundingRect();\r\n\t        if (rect) {\r\n\t            var aspect = boundingRect.width / boundingRect.height;\r\n\t\r\n\t            if (layout === 'center') {\r\n\t                // Set rect to center, keep width / height ratio.\r\n\t                var width = rect.height * aspect;\r\n\t                var height;\r\n\t                if (width <= rect.width) {\r\n\t                    height = rect.height;\r\n\t                }\r\n\t                else {\r\n\t                    width = rect.width;\r\n\t                    height = width / aspect;\r\n\t                }\r\n\t                var cx = rect.x + rect.width / 2;\r\n\t                var cy = rect.y + rect.height / 2;\r\n\t\r\n\t                rect.x = cx - width / 2;\r\n\t                rect.y = cy - height / 2;\r\n\t                rect.width = width;\r\n\t                rect.height = height;\r\n\t            }\r\n\t\r\n\t            this.resizePath(path, rect);\r\n\t        }\r\n\t\r\n\t        zrUtil.inherits(path, Draggable);\r\n\t        return path;\r\n\t    };\r\n\t\r\n\t    graphic.mergePath = pathTool.mergePath;\r\n\t\r\n\t    /**\r\n\t     * Resize a path to fit the rect\r\n\t     * @param {module:zrender/graphic/Path} path\r\n\t     * @param {Object} rect\r\n\t     */\r\n\t    graphic.resizePath = function (path, rect) {\r\n\t        if (!path.applyTransform) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var pathRect = path.getBoundingRect();\r\n\t\r\n\t        var m = pathRect.calculateTransform(rect);\r\n\t\r\n\t        path.applyTransform(m);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize line for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x1]\r\n\t     * @param {number} [param.shape.y1]\r\n\t     * @param {number} [param.shape.x2]\r\n\t     * @param {number} [param.shape.y2]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeLine = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t\r\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n\t        }\r\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n\t        }\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize rect for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x]\r\n\t     * @param {number} [param.shape.y]\r\n\t     * @param {number} [param.shape.width]\r\n\t     * @param {number} [param.shape.height]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeRect = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t        var originX = shape.x;\r\n\t        var originY = shape.y;\r\n\t        var originWidth = shape.width;\r\n\t        var originHeight = shape.height;\r\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n\t        shape.width = Math.max(\r\n\t            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n\t            originWidth === 0 ? 0 : 1\r\n\t        );\r\n\t        shape.height = Math.max(\r\n\t            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n\t            originHeight === 0 ? 0 : 1\r\n\t        );\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize for canvas\r\n\t     *\r\n\t     * @param {number} position Coordinate, such as x, y\r\n\t     * @param {number} lineWidth Should be nonnegative integer.\r\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\r\n\t     * @return {number} Optimized position.\r\n\t     */\r\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\r\n\t        // otherwise line will be fuzzy in canvas.\r\n\t        var doubledPosition = round(position * 2);\r\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n\t            ? doubledPosition / 2\r\n\t            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    function doSingleEnterHover(el) {\r\n\t        if (el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t        if (el.__hoverStlDirty) {\r\n\t            var stroke = el.style.stroke;\r\n\t            var fill = el.style.fill;\r\n\t\r\n\t            // Create hoverStyle on mouseover\r\n\t            var hoverStyle = el.__hoverStl;\r\n\t            var lift = colorTool.lift;\r\n\t            hoverStyle.fill = hoverStyle.fill\r\n\t                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n\t            hoverStyle.stroke = hoverStyle.stroke\r\n\t                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\t\r\n\t            var normalStyle = {};\r\n\t            for (var name in hoverStyle) {\r\n\t                if (hoverStyle.hasOwnProperty(name)) {\r\n\t                    normalStyle[name] = el.style[name];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            el.__normalStl = normalStyle;\r\n\t\r\n\t            el.__hoverStlDirty = false;\r\n\t        }\r\n\t        el.setStyle(el.__hoverStl);\r\n\t        el.z2 += 1;\r\n\t\r\n\t        el.__isHover = true;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doSingleLeaveHover(el) {\r\n\t        if (!el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var normalStl = el.__normalStl;\r\n\t        normalStl && el.setStyle(normalStl);\r\n\t        el.z2 -= 1;\r\n\t\r\n\t        el.__isHover = false;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doEnterHover(el) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleEnterHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleEnterHover(el);\r\n\t    }\r\n\t    graphic.doEnterHover = doEnterHover;\r\n\t    function doLeaveHover(el) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleLeaveHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleLeaveHover(el);\r\n\t    }\r\n\t    graphic.doLeaveHover = doLeaveHover;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function setElementHoverStl(el, hoverStl) {\r\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n\t        // Often used when item group has a label element and it's hoverStyle is different\r\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n\t        el.__hoverStlDirty = true;\r\n\t    }\r\n\t    graphic.setElementHoverStl = setElementHoverStl;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOver() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOut() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function enterEmphasis() {\r\n\t        this.__isEmphasis = true;\r\n\t        doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function leaveEmphasis() {\r\n\t        this.__isEmphasis = false;\r\n\t        doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Set hover style of element\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} [hoverStyle]\r\n\t     */\r\n\t    graphic.setHoverStyle = function (el, hoverStyle) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    setElementHoverStl(child, hoverStyle);\r\n\t                }\r\n\t            })\r\n\t            : setElementHoverStl(el, hoverStyle);\r\n\t        // Remove previous bound handlers\r\n\t        el.on('mouseover', onElementMouseOver)\r\n\t          .on('mouseout', onElementMouseOut);\r\n\t\r\n\t        // Emphasis, normal can be triggered manually\r\n\t        el.on('emphasis', enterEmphasis)\r\n\t          .on('normal', leaveEmphasis);\r\n\t    };\r\n\t\r\n\t    graphic.setNormalStyle = function(el, options) {\r\n\t        if (el.__normalStl) {\r\n\t            for (var name in options) {\r\n\t                if (el.__normalStl.hasOwnProperty(name)) {\r\n\t                    el.__normalStl[name] = options[name];\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Set text option in the style\r\n\t     * @param {Object} textStyle\r\n\t     * @param {module:echarts/model/Model} labelModel\r\n\t     * @param {string} color\r\n\t     */\r\n\t    graphic.setText = function (textStyle, labelModel, color) {\r\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n\t        var textStyleModel = labelModel.getModel('textStyle');\r\n\t        zrUtil.extend(textStyle, {\r\n\t            textDistance: labelModel.getShallow('distance') || 5,\r\n\t            textFont: textStyleModel.getFont(),\r\n\t            textPosition: labelPosition,\r\n\t            textFill: textStyleModel.getTextColor() || labelColor\r\n\t        });\r\n\t    };\r\n\t\r\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n\t        var postfix = isUpdate ? 'Update' : '';\r\n\t        var duration = animatableModel\r\n\t            && animatableModel.getShallow('animationDuration' + postfix);\r\n\t        var animationEasing = animatableModel\r\n\t            && animatableModel.getShallow('animationEasing' + postfix);\r\n\t\r\n\t        animatableModel && animatableModel.getShallow('animation')\r\n\t            ? el.animateTo(props, duration, animationEasing, cb)\r\n\t            : (el.attr(props), cb && cb());\r\n\t    }\r\n\t    /**\r\n\t     * Update graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\t\r\n\t    /**\r\n\t     * Init graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\t\r\n\t    /**\r\n\t     * Get transform matrix of target (param target),\r\n\t     * in coordinate of its ancestor (param ancestor)\r\n\t     *\r\n\t     * @param {module:zrender/mixin/Transformable} target\r\n\t     * @param {module:zrender/mixin/Transformable} ancestor\r\n\t     */\r\n\t    graphic.getTransform = function (target, ancestor) {\r\n\t        var mat = matrix.identity([]);\r\n\t\r\n\t        while (target && target !== ancestor) {\r\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\r\n\t            target = target.parent;\r\n\t        }\r\n\t\r\n\t        return mat;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Apply transform to an vertex.\r\n\t     * @param {Array.<number>} vertex [x, y]\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {Array.<number>} [x, y]\r\n\t     */\r\n\t    graphic.applyTransform = function (vertex, transform, invert) {\r\n\t        if (invert) {\r\n\t            transform = matrix.invert([], transform);\r\n\t        }\r\n\t        return vector.applyTransform([], vertex, transform);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n\t     */\r\n\t    graphic.transformDirection = function (direction, transform, invert) {\r\n\t\r\n\t        // Pick a base, ensure that transform result will not be (0, 0).\r\n\t        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n\t        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\t\r\n\t        var vertex = [\r\n\t            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n\t            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n\t        ];\r\n\t\r\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\t\r\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n\t            ? (vertex[0] > 0 ? 'right' : 'left')\r\n\t            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n\t    };\r\n\t\r\n\t    module.exports = graphic;\r\n\t\r\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Path = __webpack_require__(44);\n\t    var PathProxy = __webpack_require__(45);\n\t    var transformPath = __webpack_require__(55);\n\t    var matrix = __webpack_require__(14);\n\t\n\t    // command chars\n\t    var cc = [\n\t        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n\t        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n\t    ];\n\t\n\t    var mathSqrt = Math.sqrt;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var PI = Math.PI;\n\t\n\t    var vMag = function(v) {\n\t        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t    };\n\t    var vRatio = function(u, v) {\n\t        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t    };\n\t    var vAngle = function(u, v) {\n\t        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n\t                * Math.acos(vRatio(u, v));\n\t    };\n\t\n\t    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t        var psi = psiDeg * (PI / 180.0);\n\t        var xp = mathCos(psi) * (x1 - x2) / 2.0\n\t                 + mathSin(psi) * (y1 - y2) / 2.0;\n\t        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n\t                 + mathCos(psi) * (y1 - y2) / 2.0;\n\t\n\t        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\t\n\t        if (lambda > 1) {\n\t            rx *= mathSqrt(lambda);\n\t            ry *= mathSqrt(lambda);\n\t        }\n\t\n\t        var f = (fa === fs ? -1 : 1)\n\t            * mathSqrt((((rx * rx) * (ry * ry))\n\t                    - ((rx * rx) * (yp * yp))\n\t                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n\t                    + (ry * ry) * (xp * xp))\n\t                ) || 0;\n\t\n\t        var cxp = f * rx * yp / ry;\n\t        var cyp = f * -ry * xp / rx;\n\t\n\t        var cx = (x1 + x2) / 2.0\n\t                 + mathCos(psi) * cxp\n\t                 - mathSin(psi) * cyp;\n\t        var cy = (y1 + y2) / 2.0\n\t                + mathSin(psi) * cxp\n\t                + mathCos(psi) * cyp;\n\t\n\t        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n\t        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n\t        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n\t        var dTheta = vAngle(u, v);\n\t\n\t        if (vRatio(u, v) <= -1) {\n\t            dTheta = PI;\n\t        }\n\t        if (vRatio(u, v) >= 1) {\n\t            dTheta = 0;\n\t        }\n\t        if (fs === 0 && dTheta > 0) {\n\t            dTheta = dTheta - 2 * PI;\n\t        }\n\t        if (fs === 1 && dTheta < 0) {\n\t            dTheta = dTheta + 2 * PI;\n\t        }\n\t\n\t        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t    }\n\t\n\t    function createPathProxyFromString(data) {\n\t        if (!data) {\n\t            return [];\n\t        }\n\t\n\t        // command string\n\t        var cs = data.replace(/-/g, ' -')\n\t            .replace(/  /g, ' ')\n\t            .replace(/ /g, ',')\n\t            .replace(/,,/g, ',');\n\t\n\t        var n;\n\t        // create pipes so that we can split the data\n\t        for (n = 0; n < cc.length; n++) {\n\t            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t        }\n\t\n\t        // create array\n\t        var arr = cs.split('|');\n\t        // init context point\n\t        var cpx = 0;\n\t        var cpy = 0;\n\t\n\t        var path = new PathProxy();\n\t        var CMD = PathProxy.CMD;\n\t\n\t        var prevCmd;\n\t        for (n = 1; n < arr.length; n++) {\n\t            var str = arr[n];\n\t            var c = str.charAt(0);\n\t            var off = 0;\n\t            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t            var cmd;\n\t\n\t            if (p.length > 0 && p[0] === '') {\n\t                p.shift();\n\t            }\n\t\n\t            for (var i = 0; i < p.length; i++) {\n\t                p[i] = parseFloat(p[i]);\n\t            }\n\t            while (off < p.length && !isNaN(p[off])) {\n\t                if (isNaN(p[0])) {\n\t                    break;\n\t                }\n\t                var ctlPtx;\n\t                var ctlPty;\n\t\n\t                var rx;\n\t                var ry;\n\t                var psi;\n\t                var fa;\n\t                var fs;\n\t\n\t                var x1 = cpx;\n\t                var y1 = cpy;\n\t\n\t                // convert l, H, h, V, and v to L\n\t                switch (c) {\n\t                    case 'l':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'L':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'm':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'l';\n\t                        break;\n\t                    case 'M':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'L';\n\t                        break;\n\t                    case 'h':\n\t                        cpx += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'H':\n\t                        cpx = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'v':\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'V':\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'C':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n\t                        );\n\t                        cpx = p[off - 2];\n\t                        cpy = p[off - 1];\n\t                        break;\n\t                    case 'c':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy\n\t                        );\n\t                        cpx += p[off - 2];\n\t                        cpy += p[off - 1];\n\t                        break;\n\t                    case 'S':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 's':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = cpx + p[off++];\n\t                        y1 = cpy + p[off++];\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'Q':\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'q':\n\t                        x1 = p[off++] + cpx;\n\t                        y1 = p[off++] + cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'T':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 't':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 'A':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                    case 'a':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                }\n\t            }\n\t\n\t            if (c === 'z' || c === 'Z') {\n\t                cmd = CMD.Z;\n\t                path.addData(cmd);\n\t            }\n\t\n\t            prevCmd = cmd;\n\t        }\n\t\n\t        path.toStatic();\n\t\n\t        return path;\n\t    }\n\t\n\t    // TODO Optimize double memory cost problem\n\t    function createPathOptions(str, opts) {\n\t        var pathProxy = createPathProxyFromString(str);\n\t        var transform;\n\t        opts = opts || {};\n\t        opts.buildPath = function (path) {\n\t            path.setData(pathProxy.data);\n\t            transform && transformPath(path, transform);\n\t            // Svg and vml renderer don't have context\n\t            var ctx = path.getContext();\n\t            if (ctx) {\n\t                path.rebuildPath(ctx);\n\t            }\n\t        };\n\t\n\t        opts.applyTransform = function (m) {\n\t            if (!transform) {\n\t                transform = matrix.create();\n\t            }\n\t            matrix.mul(transform, m, transform);\n\t            this.dirty(true);\n\t        };\n\t\n\t        return opts;\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Create a Path object from path string data\n\t         * http://www.w3.org/TR/SVG/paths.html#PathData\n\t         * @param  {Object} opts Other options\n\t         */\n\t        createFromString: function (str, opts) {\n\t            return new Path(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Create a Path class from path string data\n\t         * @param  {string} str\n\t         * @param  {Object} opts Other options\n\t         */\n\t        extendFromString: function (str, opts) {\n\t            return Path.extend(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Merge multiple paths\n\t         */\n\t        // TODO Apply transform\n\t        // TODO stroke dash\n\t        // TODO Optimize double memory cost problem\n\t        mergePath: function (pathEls, opts) {\n\t            var pathList = [];\n\t            var len = pathEls.length;\n\t            for (var i = 0; i < len; i++) {\n\t                var pathEl = pathEls[i];\n\t                if (pathEl.__dirty) {\n\t                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t                }\n\t                pathList.push(pathEl.path);\n\t            }\n\t\n\t            var pathBundle = new Path(opts);\n\t            pathBundle.buildPath = function (path) {\n\t                path.appendPath(pathList);\n\t                // Svg and vml renderer don't have context\n\t                var ctx = path.getContext();\n\t                if (ctx) {\n\t                    path.rebuildPath(ctx);\n\t                }\n\t            };\n\t\n\t            return pathBundle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Path element\n\t * @module zrender/graphic/Path\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(36);\n\t    var zrUtil = __webpack_require__(6);\n\t    var PathProxy = __webpack_require__(45);\n\t    var pathContain = __webpack_require__(48);\n\t\n\t    var Pattern = __webpack_require__(34);\n\t    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\t\n\t    var abs = Math.abs;\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Path\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function Path(opts) {\n\t        Displayable.call(this, opts);\n\t\n\t        /**\n\t         * @type {module:zrender/core/PathProxy}\n\t         * @readOnly\n\t         */\n\t        this.path = new PathProxy();\n\t    }\n\t\n\t    Path.prototype = {\n\t\n\t        constructor: Path,\n\t\n\t        type: 'path',\n\t\n\t        __dirtyPath: true,\n\t\n\t        strokeContainThreshold: 5,\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var path = this.path;\n\t            var hasStroke = style.hasStroke();\n\t            var hasFill = style.hasFill();\n\t            var fill = style.fill;\n\t            var stroke = style.stroke;\n\t            var hasFillGradient = hasFill && !!(fill.colorStops);\n\t            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n\t            var hasFillPattern = hasFill && !!(fill.image);\n\t            var hasStrokePattern = hasStroke && !!(stroke.image);\n\t\n\t            style.bind(ctx, this, prevEl);\n\t            this.setTransform(ctx);\n\t\n\t            if (this.__dirty) {\n\t                var rect = this.getBoundingRect();\n\t                // Update gradient because bounding rect may changed\n\t                if (hasFillGradient) {\n\t                    this._fillGradient = style.getGradient(ctx, fill, rect);\n\t                }\n\t                if (hasStrokeGradient) {\n\t                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t                }\n\t            }\n\t            // Use the gradient or pattern\n\t            if (hasFillGradient) {\n\t                // PENDING If may have affect the state\n\t                ctx.fillStyle = this._fillGradient;\n\t            }\n\t            else if (hasFillPattern) {\n\t                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t            }\n\t            if (hasStrokeGradient) {\n\t                ctx.strokeStyle = this._strokeGradient;\n\t            }\n\t            else if (hasStrokePattern) {\n\t                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t            }\n\t\n\t            var lineDash = style.lineDash;\n\t            var lineDashOffset = style.lineDashOffset;\n\t\n\t            var ctxLineDash = !!ctx.setLineDash;\n\t\n\t            // Update path sx, sy\n\t            var scale = this.getGlobalScale();\n\t            path.setScale(scale[0], scale[1]);\n\t\n\t            // Proxy context\n\t            // Rebuild path in following 2 cases\n\t            // 1. Path is dirty\n\t            // 2. Path needs javascript implemented lineDash stroking.\n\t            //    In this case, lineDash information will not be saved in PathProxy\n\t            if (this.__dirtyPath || (\n\t                lineDash && !ctxLineDash && hasStroke\n\t            )) {\n\t                path = this.path.beginPath(ctx);\n\t\n\t                // Setting line dash before build path\n\t                if (lineDash && !ctxLineDash) {\n\t                    path.setLineDash(lineDash);\n\t                    path.setLineDashOffset(lineDashOffset);\n\t                }\n\t\n\t                this.buildPath(path, this.shape, false);\n\t\n\t                // Clear path dirty flag\n\t                this.__dirtyPath = false;\n\t            }\n\t            else {\n\t                // Replay path building\n\t                ctx.beginPath();\n\t                this.path.rebuildPath(ctx);\n\t            }\n\t\n\t            hasFill && path.fill(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                ctx.setLineDash(lineDash);\n\t                ctx.lineDashOffset = lineDashOffset;\n\t            }\n\t\n\t            hasStroke && path.stroke(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                // PENDING\n\t                // Remove lineDash\n\t                ctx.setLineDash([]);\n\t            }\n\t\n\t\n\t            this.restoreTransform(ctx);\n\t\n\t            // Draw rect text\n\t            if (style.text != null) {\n\t                // var rect = this.getBoundingRect();\n\t                this.drawRectText(ctx, this.getBoundingRect());\n\t            }\n\t        },\n\t\n\t        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n\t        // Like in circle\n\t        buildPath: function (ctx, shapeCfg, inBundle) {},\n\t\n\t        getBoundingRect: function () {\n\t            var rect = this._rect;\n\t            var style = this.style;\n\t            var needsUpdateRect = !rect;\n\t            if (needsUpdateRect) {\n\t                var path = this.path;\n\t                if (this.__dirtyPath) {\n\t                    path.beginPath();\n\t                    this.buildPath(path, this.shape, false);\n\t                }\n\t                rect = path.getBoundingRect();\n\t            }\n\t            this._rect = rect;\n\t\n\t            if (style.hasStroke()) {\n\t                // Needs update rect with stroke lineWidth when\n\t                // 1. Element changes scale or lineWidth\n\t                // 2. Shape is changed\n\t                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t                if (this.__dirty || needsUpdateRect) {\n\t                    rectWithStroke.copy(rect);\n\t                    // FIXME Must after updateTransform\n\t                    var w = style.lineWidth;\n\t                    // PENDING, Min line width is needed when line is horizontal or vertical\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t\n\t                    // Only add extra hover lineWidth when there are no fill\n\t                    if (!style.hasFill()) {\n\t                        w = Math.max(w, this.strokeContainThreshold || 4);\n\t                    }\n\t                    // Consider line width\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        rectWithStroke.width += w / lineScale;\n\t                        rectWithStroke.height += w / lineScale;\n\t                        rectWithStroke.x -= w / lineScale / 2;\n\t                        rectWithStroke.y -= w / lineScale / 2;\n\t                    }\n\t                }\n\t\n\t                // Return rect with stroke\n\t                return rectWithStroke;\n\t            }\n\t\n\t            return rect;\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var localPos = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            var style = this.style;\n\t            x = localPos[0];\n\t            y = localPos[1];\n\t\n\t            if (rect.contain(x, y)) {\n\t                var pathData = this.path.data;\n\t                if (style.hasStroke()) {\n\t                    var lineWidth = style.lineWidth;\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        // Only add extra hover lineWidth when there are no fill\n\t                        if (!style.hasFill()) {\n\t                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t                        }\n\t                        if (pathContain.containStroke(\n\t                            pathData, lineWidth / lineScale, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t                if (style.hasFill()) {\n\t                    return pathContain.contain(pathData, x, y);\n\t                }\n\t            }\n\t            return false;\n\t        },\n\t\n\t        /**\n\t         * @param  {boolean} dirtyPath\n\t         */\n\t        dirty: function (dirtyPath) {\n\t            if (dirtyPath == null) {\n\t                dirtyPath = true;\n\t            }\n\t            // Only mark dirty, not mark clean\n\t            if (dirtyPath) {\n\t                this.__dirtyPath = dirtyPath;\n\t                this._rect = null;\n\t            }\n\t\n\t            this.__dirty = true;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t\n\t            // Used as a clipping path\n\t            if (this.__clipTarget) {\n\t                this.__clipTarget.dirty();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Alias for animate('shape')\n\t         * @param {boolean} loop\n\t         */\n\t        animateShape: function (loop) {\n\t            return this.animate('shape', loop);\n\t        },\n\t\n\t        // Overwrite attrKV\n\t        attrKV: function (key, value) {\n\t            // FIXME\n\t            if (key === 'shape') {\n\t                this.setShape(value);\n\t                this.__dirtyPath = true;\n\t                this._rect = null;\n\t            }\n\t            else {\n\t                Displayable.prototype.attrKV.call(this, key, value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setShape: function (key, value) {\n\t            var shape = this.shape;\n\t            // Path from string may not have shape\n\t            if (shape) {\n\t                if (zrUtil.isObject(key)) {\n\t                    for (var name in key) {\n\t                        if (key.hasOwnProperty(name)) {\n\t                            shape[name] = key[name];\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    shape[key] = value;\n\t                }\n\t                this.dirty(true);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        getLineScale: function () {\n\t            var m = this.transform;\n\t            // Get the line scale.\n\t            // Determinant of `m` means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n\t                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n\t                : 1;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * 扩展一个 Path element, 比如星形，圆等。\n\t     * Extend a path element\n\t     * @param {Object} props\n\t     * @param {string} props.type Path type\n\t     * @param {Function} props.init Initialize\n\t     * @param {Function} props.buildPath Overwrite buildPath method\n\t     * @param {Object} [props.style] Extended default style config\n\t     * @param {Object} [props.shape] Extended default shape config\n\t     */\n\t    Path.extend = function (defaults) {\n\t        var Sub = function (opts) {\n\t            Path.call(this, opts);\n\t\n\t            if (defaults.style) {\n\t                // Extend default style\n\t                this.style.extendFrom(defaults.style, false);\n\t            }\n\t\n\t            // Extend default shape\n\t            var defaultShape = defaults.shape;\n\t            if (defaultShape) {\n\t                this.shape = this.shape || {};\n\t                var thisShape = this.shape;\n\t                for (var name in defaultShape) {\n\t                    if (\n\t                        ! thisShape.hasOwnProperty(name)\n\t                        && defaultShape.hasOwnProperty(name)\n\t                    ) {\n\t                        thisShape[name] = defaultShape[name];\n\t                    }\n\t                }\n\t            }\n\t\n\t            defaults.init && defaults.init.call(this, opts);\n\t        };\n\t\n\t        zrUtil.inherits(Sub, Path);\n\t\n\t        // FIXME 不能 extend position, rotation 等引用对象\n\t        for (var name in defaults) {\n\t            // Extending prototype values and methods\n\t            if (name !== 'style' && name !== 'shape') {\n\t                Sub.prototype[name] = defaults[name];\n\t            }\n\t        }\n\t\n\t        return Sub;\n\t    };\n\t\n\t    zrUtil.inherits(Path, Displayable);\n\t\n\t    module.exports = Path;\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n\t * 可以用于 isInsidePath 判断以及获取boundingRect\n\t *\n\t * @module zrender/core/PathProxy\n\t * @author Yi Shen (http://www.github.com/pissang)\n\t */\n\t\n\t // TODO getTotalLength, getPointAtLength\n\t\n\t\n\t    var curve = __webpack_require__(46);\n\t    var vec2 = __webpack_require__(15);\n\t    var bbox = __webpack_require__(47);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var dpr = __webpack_require__(23).devicePixelRatio;\n\t\n\t    var CMD = {\n\t        M: 1,\n\t        L: 2,\n\t        C: 3,\n\t        Q: 4,\n\t        A: 5,\n\t        Z: 6,\n\t        // Rect\n\t        R: 7\n\t    };\n\t\n\t    var min = [];\n\t    var max = [];\n\t    var min2 = [];\n\t    var max2 = [];\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathCos = Math.cos;\n\t    var mathSin = Math.sin;\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAbs = Math.abs;\n\t\n\t    var hasTypedArray = typeof Float32Array != 'undefined';\n\t\n\t    /**\n\t     * @alias module:zrender/core/PathProxy\n\t     * @constructor\n\t     */\n\t    var PathProxy = function () {\n\t\n\t        /**\n\t         * Path data. Stored as flat array\n\t         * @type {Array.<Object>}\n\t         */\n\t        this.data = [];\n\t\n\t        this._len = 0;\n\t\n\t        this._ctx = null;\n\t\n\t        this._xi = 0;\n\t        this._yi = 0;\n\t\n\t        this._x0 = 0;\n\t        this._y0 = 0;\n\t\n\t        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t        this._ux = 0;\n\t        this._uy = 0;\n\t    };\n\t\n\t    /**\n\t     * 快速计算Path包围盒（并不是最小包围盒）\n\t     * @return {Object}\n\t     */\n\t    PathProxy.prototype = {\n\t\n\t        constructor: PathProxy,\n\t\n\t        _lineDash: null,\n\t\n\t        _dashOffset: 0,\n\t\n\t        _dashIdx: 0,\n\t\n\t        _dashSum: 0,\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        setScale: function (sx, sy) {\n\t            this._ux = mathAbs(1 / dpr / sx) || 0;\n\t            this._uy = mathAbs(1 / dpr / sy) || 0;\n\t        },\n\t\n\t        getContext: function () {\n\t            return this._ctx;\n\t        },\n\t\n\t        /**\n\t         * @param  {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        beginPath: function (ctx) {\n\t\n\t            this._ctx = ctx;\n\t\n\t            ctx && ctx.beginPath();\n\t\n\t            ctx && (this.dpr = ctx.dpr);\n\t\n\t            // Reset\n\t            this._len = 0;\n\t\n\t            if (this._lineDash) {\n\t                this._lineDash = null;\n\t\n\t                this._dashOffset = 0;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        moveTo: function (x, y) {\n\t            this.addData(CMD.M, x, y);\n\t            this._ctx && this._ctx.moveTo(x, y);\n\t\n\t            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n\t            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n\t            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n\t            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\t            this._x0 = x;\n\t            this._y0 = y;\n\t\n\t            this._xi = x;\n\t            this._yi = y;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        lineTo: function (x, y) {\n\t            var exceedUnit = mathAbs(x - this._xi) > this._ux\n\t                || mathAbs(y - this._yi) > this._uy\n\t                // Force draw the first segment\n\t                || this._len < 5;\n\t\n\t            this.addData(CMD.L, x, y);\n\t\n\t            if (this._ctx && exceedUnit) {\n\t                this._needsDash() ? this._dashedLineTo(x, y)\n\t                    : this._ctx.lineTo(x, y);\n\t            }\n\t            if (exceedUnit) {\n\t                this._xi = x;\n\t                this._yi = y;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @param  {number} x3\n\t         * @param  {number} y3\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n\t                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t            }\n\t            this._xi = x3;\n\t            this._yi = y3;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        quadraticCurveTo: function (x1, y1, x2, y2) {\n\t            this.addData(CMD.Q, x1, y1, x2, y2);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n\t                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t            }\n\t            this._xi = x2;\n\t            this._yi = y2;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} cx\n\t         * @param  {number} cy\n\t         * @param  {number} r\n\t         * @param  {number} startAngle\n\t         * @param  {number} endAngle\n\t         * @param  {boolean} anticlockwise\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t            this.addData(\n\t                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n\t            );\n\t            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t\n\t            this._xi = mathCos(endAngle) * r + cx;\n\t            this._yi = mathSin(endAngle) * r + cx;\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        arcTo: function (x1, y1, x2, y2, radius) {\n\t            if (this._ctx) {\n\t                this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        rect: function (x, y, w, h) {\n\t            this._ctx && this._ctx.rect(x, y, w, h);\n\t            this.addData(CMD.R, x, y, w, h);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        closePath: function () {\n\t            this.addData(CMD.Z);\n\t\n\t            var ctx = this._ctx;\n\t            var x0 = this._x0;\n\t            var y0 = this._y0;\n\t            if (ctx) {\n\t                this._needsDash() && this._dashedLineTo(x0, y0);\n\t                ctx.closePath();\n\t            }\n\t\n\t            this._xi = x0;\n\t            this._yi = y0;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n\t         * stroke 同样\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        fill: function (ctx) {\n\t            ctx && ctx.fill();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        stroke: function (ctx) {\n\t            ctx && ctx.stroke();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * 必须在其它绘制命令前调用\n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDash: function (lineDash) {\n\t            if (lineDash instanceof Array) {\n\t                this._lineDash = lineDash;\n\t\n\t                this._dashIdx = 0;\n\t\n\t                var lineDashSum = 0;\n\t                for (var i = 0; i < lineDash.length; i++) {\n\t                    lineDashSum += lineDash[i];\n\t                }\n\t                this._dashSum = lineDashSum;\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 必须在其它绘制命令前调用\n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDashOffset: function (offset) {\n\t            this._dashOffset = offset;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         *\n\t         * @return {boolean}\n\t         */\n\t        len: function () {\n\t            return this._len;\n\t        },\n\t\n\t        /**\n\t         * 直接设置 Path 数据\n\t         */\n\t        setData: function (data) {\n\t\n\t            var len = data.length;\n\t\n\t            if (! (this.data && this.data.length == len) && hasTypedArray) {\n\t                this.data = new Float32Array(len);\n\t            }\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                this.data[i] = data[i];\n\t            }\n\t\n\t            this._len = len;\n\t        },\n\t\n\t        /**\n\t         * 添加子路径\n\t         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n\t         */\n\t        appendPath: function (path) {\n\t            if (!(path instanceof Array)) {\n\t                path = [path];\n\t            }\n\t            var len = path.length;\n\t            var appendSize = 0;\n\t            var offset = this._len;\n\t            for (var i = 0; i < len; i++) {\n\t                appendSize += path[i].len();\n\t            }\n\t            if (hasTypedArray && (this.data instanceof Float32Array)) {\n\t                this.data = new Float32Array(offset + appendSize);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                var appendPathData = path[i].data;\n\t                for (var k = 0; k < appendPathData.length; k++) {\n\t                    this.data[offset++] = appendPathData[k];\n\t                }\n\t            }\n\t            this._len = offset;\n\t        },\n\t\n\t        /**\n\t         * 填充 Path 数据。\n\t         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n\t         */\n\t        addData: function (cmd) {\n\t            var data = this.data;\n\t            if (this._len + arguments.length > data.length) {\n\t                // 因为之前的数组已经转换成静态的 Float32Array\n\t                // 所以不够用时需要扩展一个新的动态数组\n\t                this._expandData();\n\t                data = this.data;\n\t            }\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                data[this._len++] = arguments[i];\n\t            }\n\t\n\t            this._prevCmd = cmd;\n\t        },\n\t\n\t        _expandData: function () {\n\t            // Only if data is Float32Array\n\t            if (!(this.data instanceof Array)) {\n\t                var newData = [];\n\t                for (var i = 0; i < this._len; i++) {\n\t                    newData[i] = this.data[i];\n\t                }\n\t                this.data = newData;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * If needs js implemented dashed line\n\t         * @return {boolean}\n\t         * @private\n\t         */\n\t        _needsDash: function () {\n\t            return this._lineDash;\n\t        },\n\t\n\t        _dashedLineTo: function (x1, y1) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var dx = x1 - x0;\n\t            var dy = y1 - y0;\n\t            var dist = mathSqrt(dx * dx + dy * dy);\n\t            var x = x0;\n\t            var y = y0;\n\t            var dash;\n\t            var nDash = lineDash.length;\n\t            var idx;\n\t            dx /= dist;\n\t            dy /= dist;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            x -= offset * dx;\n\t            y -= offset * dy;\n\t\n\t            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n\t            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n\t                idx = this._dashIdx;\n\t                dash = lineDash[idx];\n\t                x += dx * dash;\n\t                y += dy * dash;\n\t                this._dashIdx = (idx + 1) % nDash;\n\t                // Skip positive offset\n\t                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n\t                    continue;\n\t                }\n\t                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n\t                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n\t                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n\t                );\n\t            }\n\t            // Offset for next lineTo\n\t            dx = x - x1;\n\t            dy = y - y1;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        // Not accurate dashed line to\n\t        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var t;\n\t            var dx;\n\t            var dy;\n\t            var cubicAt = curve.cubicAt;\n\t            var bezierLen = 0;\n\t            var idx = this._dashIdx;\n\t            var nDash = lineDash.length;\n\t\n\t            var x;\n\t            var y;\n\t\n\t            var tmpLen = 0;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            // Bezier approx length\n\t            for (t = 0; t < 1; t += 0.1) {\n\t                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n\t                    - cubicAt(x0, x1, x2, x3, t);\n\t                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n\t                    - cubicAt(y0, y1, y2, y3, t);\n\t                bezierLen += mathSqrt(dx * dx + dy * dy);\n\t            }\n\t\n\t            // Find idx after add offset\n\t            for (; idx < nDash; idx++) {\n\t                tmpLen += lineDash[idx];\n\t                if (tmpLen > offset) {\n\t                    break;\n\t                }\n\t            }\n\t            t = (tmpLen - offset) / bezierLen;\n\t\n\t            while (t <= 1) {\n\t\n\t                x = cubicAt(x0, x1, x2, x3, t);\n\t                y = cubicAt(y0, y1, y2, y3, t);\n\t\n\t                // Use line to approximate dashed bezier\n\t                // Bad result if dash is long\n\t                idx % 2 ? ctx.moveTo(x, y)\n\t                    : ctx.lineTo(x, y);\n\t\n\t                t += lineDash[idx] / bezierLen;\n\t\n\t                idx = (idx + 1) % nDash;\n\t            }\n\t\n\t            // Finish the last segment and calculate the new offset\n\t            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n\t            dx = x3 - x;\n\t            dy = y3 - y;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            var x3 = x2;\n\t            var y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (this._xi + 2 * x1) / 3;\n\t            y1 = (this._yi + 2 * y1) / 3;\n\t\n\t            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t        },\n\t\n\t        /**\n\t         * 转成静态的 Float32Array 减少堆内存占用\n\t         * Convert dynamic array to static Float32Array\n\t         */\n\t        toStatic: function () {\n\t            var data = this.data;\n\t            if (data instanceof Array) {\n\t                data.length = this._len;\n\t                if (hasTypedArray) {\n\t                    this.data = new Float32Array(data);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function () {\n\t            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t\n\t            var data = this.data;\n\t            var xi = 0;\n\t            var yi = 0;\n\t            var x0 = 0;\n\t            var y0 = 0;\n\t\n\t            for (var i = 0; i < data.length;) {\n\t                var cmd = data[i++];\n\t\n\t                if (i == 1) {\n\t                    // 如果第一个命令是 L, C, Q\n\t                    // 则 previous point 同绘制命令的第一个 point\n\t                    //\n\t                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                    xi = data[i];\n\t                    yi = data[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t                        // 在 closePath 的时候使用\n\t                        x0 = data[i++];\n\t                        y0 = data[i++];\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        min2[0] = x0;\n\t                        min2[1] = y0;\n\t                        max2[0] = x0;\n\t                        max2[1] = y0;\n\t                        break;\n\t                    case CMD.L:\n\t                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.C:\n\t                        bbox.fromCubic(\n\t                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.Q:\n\t                        bbox.fromQuadratic(\n\t                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.A:\n\t                        // TODO Arc 判断的开销比较大\n\t                        var cx = data[i++];\n\t                        var cy = data[i++];\n\t                        var rx = data[i++];\n\t                        var ry = data[i++];\n\t                        var startAngle = data[i++];\n\t                        var endAngle = data[i++] + startAngle;\n\t                        // TODO Arc 旋转\n\t                        var psi = data[i++];\n\t                        var anticlockwise = 1 - data[i++];\n\t\n\t                        if (i == 1) {\n\t                            // 直接使用 arc 命令\n\t                            // 第一个命令起点还未定义\n\t                            x0 = mathCos(startAngle) * rx + cx;\n\t                            y0 = mathSin(startAngle) * ry + cy;\n\t                        }\n\t\n\t                        bbox.fromArc(\n\t                            cx, cy, rx, ry, startAngle, endAngle,\n\t                            anticlockwise, min2, max2\n\t                        );\n\t\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = data[i++];\n\t                        y0 = yi = data[i++];\n\t                        var width = data[i++];\n\t                        var height = data[i++];\n\t                        // Use fromLine\n\t                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t                        break;\n\t                    case CMD.Z:\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        break;\n\t                }\n\t\n\t                // Union\n\t                vec2.min(min, min, min2);\n\t                vec2.max(max, max, max2);\n\t            }\n\t\n\t            // No data\n\t            if (i === 0) {\n\t                min[0] = min[1] = max[0] = max[1] = 0;\n\t            }\n\t\n\t            return new BoundingRect(\n\t                min[0], min[1], max[0] - min[0], max[1] - min[1]\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Rebuild path from current data\n\t         * Rebuild path will not consider javascript implemented line dash.\n\t         * @param {CanvasRenderingContext} ctx\n\t         */\n\t        rebuildPath: function (ctx) {\n\t            var d = this.data;\n\t            var x0, y0;\n\t            var xi, yi;\n\t            var x, y;\n\t            var ux = this._ux;\n\t            var uy = this._uy;\n\t            var len = this._len;\n\t            for (var i = 0; i < len;) {\n\t                var cmd = d[i++];\n\t\n\t                if (i == 1) {\n\t                    // 如果第一个命令是 L, C, Q\n\t                    // 则 previous point 同绘制命令的第一个 point\n\t                    //\n\t                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                    xi = d[i];\n\t                    yi = d[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        x0 = xi = d[i++];\n\t                        y0 = yi = d[i++];\n\t                        ctx.moveTo(xi, yi);\n\t                        break;\n\t                    case CMD.L:\n\t                        x = d[i++];\n\t                        y = d[i++];\n\t                        // Not draw too small seg between\n\t                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t                            ctx.lineTo(x, y);\n\t                            xi = x;\n\t                            yi = y;\n\t                        }\n\t                        break;\n\t                    case CMD.C:\n\t                        ctx.bezierCurveTo(\n\t                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n\t                        );\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.Q:\n\t                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.A:\n\t                        var cx = d[i++];\n\t                        var cy = d[i++];\n\t                        var rx = d[i++];\n\t                        var ry = d[i++];\n\t                        var theta = d[i++];\n\t                        var dTheta = d[i++];\n\t                        var psi = d[i++];\n\t                        var fs = d[i++];\n\t                        var r = (rx > ry) ? rx : ry;\n\t                        var scaleX = (rx > ry) ? 1 : rx / ry;\n\t                        var scaleY = (rx > ry) ? ry / rx : 1;\n\t                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n\t                        var endAngle = theta + dTheta;\n\t                        if (isEllipse) {\n\t                            ctx.translate(cx, cy);\n\t                            ctx.rotate(psi);\n\t                            ctx.scale(scaleX, scaleY);\n\t                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t                            ctx.scale(1 / scaleX, 1 / scaleY);\n\t                            ctx.rotate(-psi);\n\t                            ctx.translate(-cx, -cy);\n\t                        }\n\t                        else {\n\t                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t                        }\n\t\n\t                        if (i == 1) {\n\t                            // 直接使用 arc 命令\n\t                            // 第一个命令起点还未定义\n\t                            x0 = mathCos(theta) * rx + cx;\n\t                            y0 = mathSin(theta) * ry + cy;\n\t                        }\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = d[i];\n\t                        y0 = yi = d[i + 1];\n\t                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t                        break;\n\t                    case CMD.Z:\n\t                        ctx.closePath();\n\t                        xi = x0;\n\t                        yi = y0;\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    PathProxy.CMD = CMD;\n\t\n\t    module.exports = PathProxy;\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 曲线辅助模块\n\t * @module zrender/core/curve\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(15);\n\t    var v2Create = vec2.create;\n\t    var v2DistSquare = vec2.distSquare;\n\t    var mathPow = Math.pow;\n\t    var mathSqrt = Math.sqrt;\n\t\n\t    var EPSILON = 1e-8;\n\t    var EPSILON_NUMERIC = 1e-4;\n\t\n\t    var THREE_SQRT = mathSqrt(3);\n\t    var ONE_THIRD = 1 / 3;\n\t\n\t    // 临时变量\n\t    var _v0 = v2Create();\n\t    var _v1 = v2Create();\n\t    var _v2 = v2Create();\n\t    // var _v3 = vec2.create();\n\t\n\t    function isAroundZero(val) {\n\t        return val > -EPSILON && val < EPSILON;\n\t    }\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * 计算三次贝塞尔值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return onet * onet * (onet * p0 + 3 * t * p1)\n\t             + t * t * (t * p3 + 3 * onet * p2);\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔导数值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return 3 * (\n\t            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n\t            + (p3 - p2) * t * t\n\t        );\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔方程根，使用盛金公式\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} val\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} 有效根数目\n\t     */\n\t    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t        // Evaluate roots of cubic functions\n\t        var a = p3 + 3 * (p1 - p2) - p0;\n\t        var b = 3 * (p2 - p1 * 2 + p0);\n\t        var c = 3 * (p1  - p0);\n\t        var d = p0 - val;\n\t\n\t        var A = b * b - 3 * a * c;\n\t        var B = b * c - 9 * a * d;\n\t        var C = c * c - 3 * b * d;\n\t\n\t        var n = 0;\n\t\n\t        if (isAroundZero(A) && isAroundZero(B)) {\n\t            if (isAroundZero(b)) {\n\t                roots[0] = 0;\n\t            }\n\t            else {\n\t                var t1 = -c / b;  //t1, t2, t3, b is not zero\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = B * B - 4 * A * C;\n\t\n\t            if (isAroundZero(disc)) {\n\t                var K = B / A;\n\t                var t1 = -b / a + K;  // t1, a is not zero\n\t                var t2 = -K / 2;  // t2, t3\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t                if (Y1 < 0) {\n\t                    Y1 = -mathPow(-Y1, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y1 = mathPow(Y1, ONE_THIRD);\n\t                }\n\t                if (Y2 < 0) {\n\t                    Y2 = -mathPow(-Y2, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y2 = mathPow(Y2, ONE_THIRD);\n\t                }\n\t                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else {\n\t                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t                var theta = Math.acos(T) / 3;\n\t                var ASqrt = mathSqrt(A);\n\t                var tmp = Math.cos(theta);\n\t\n\t                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t                if (t3 >= 0 && t3 <= 1) {\n\t                    roots[n++] = t3;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔方程极限值的位置\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {Array.<number>} extrema\n\t     * @return {number} 有效数目\n\t     */\n\t    function cubicExtrema(p0, p1, p2, p3, extrema) {\n\t        var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t        var c = 3 * p1 - 3 * p0;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <=1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                extrema[0] = -b / (2 * a);\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    extrema[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 细分三次贝塞尔曲线\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p23 = (p3 - p2) * t + p2;\n\t\n\t        var p012 = (p12 - p01) * t + p01;\n\t        var p123 = (p23 - p12) * t + p12;\n\t\n\t        var p0123 = (p123 - p012) * t + p012;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        out[3] = p0123;\n\t        // Seg1\n\t        out[4] = p0123;\n\t        out[5] = p123;\n\t        out[6] = p23;\n\t        out[7] = p3;\n\t    }\n\t\n\t    /**\n\t     * 投射点到三次贝塞尔曲线上，返回投射距离。\n\t     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} [out] 投射点\n\t     * @return {number}\n\t     */\n\t    function cubicProjectPoint(\n\t        x0, y0, x1, y1, x2, y2, x3, y3,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        var prev;\n\t        var next;\n\t        var d1;\n\t        var d2;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        // 先粗略估计一下可能的最小距离的 t 值\n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t            d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            prev = t - interval;\n\t            next = t + interval;\n\t            // t - interval\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t\n\t            d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t                d2 = v2DistSquare(_v2, _v0);\n\t\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = cubicAt(x0, x1, x2, x3, t);\n\t            out[1] = cubicAt(y0, y1, y2, y3, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔值\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticAt(p0, p1, p2, t) {\n\t        var onet = 1 - t;\n\t        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔导数值\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticDerivativeAt(p0, p1, p2, t) {\n\t        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔方程根\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} 有效根数目\n\t     */\n\t    function quadraticRootAt(p0, p1, p2, val, roots) {\n\t        var a = p0 - 2 * p1 + p2;\n\t        var b = 2 * (p1 - p0);\n\t        var c = p0 - val;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                var t1 = -b / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 计算二次贝塞尔方程极限值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @return {number}\n\t     */\n\t    function quadraticExtremum(p0, p1, p2) {\n\t        var divider = p0 + p2 - 2 * p1;\n\t        if (divider === 0) {\n\t            // p1 is center of p0 and p2\n\t            return 0.5;\n\t        }\n\t        else {\n\t            return (p0 - p1) / divider;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 细分二次贝塞尔曲线\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function quadraticSubdivide(p0, p1, p2, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p012 = (p12 - p01) * t + p01;\n\t\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t\n\t        // Seg1\n\t        out[3] = p012;\n\t        out[4] = p12;\n\t        out[5] = p2;\n\t    }\n\t\n\t    /**\n\t     * 投射点到二次贝塞尔曲线上，返回投射距离。\n\t     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} out 投射点\n\t     * @return {number}\n\t     */\n\t    function quadraticProjectPoint(\n\t        x0, y0, x1, y1, x2, y2,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        // 先粗略估计一下可能的最小距离的 t 值\n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t            _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t            var d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            var prev = t - interval;\n\t            var next = t + interval;\n\t            // t - interval\n\t            _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t\n\t            var d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = quadraticAt(x0, x1, x2, next);\n\t                _v2[1] = quadraticAt(y0, y1, y2, next);\n\t                var d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = quadraticAt(x0, x1, x2, t);\n\t            out[1] = quadraticAt(y0, y1, y2, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        cubicAt: cubicAt,\n\t\n\t        cubicDerivativeAt: cubicDerivativeAt,\n\t\n\t        cubicRootAt: cubicRootAt,\n\t\n\t        cubicExtrema: cubicExtrema,\n\t\n\t        cubicSubdivide: cubicSubdivide,\n\t\n\t        cubicProjectPoint: cubicProjectPoint,\n\t\n\t        quadraticAt: quadraticAt,\n\t\n\t        quadraticDerivativeAt: quadraticDerivativeAt,\n\t\n\t        quadraticRootAt: quadraticRootAt,\n\t\n\t        quadraticExtremum: quadraticExtremum,\n\t\n\t        quadraticSubdivide: quadraticSubdivide,\n\t\n\t        quadraticProjectPoint: quadraticProjectPoint\n\t    };\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author Yi Shen(https://github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(15);\n\t    var curve = __webpack_require__(46);\n\t\n\t    var bbox = {};\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t\n\t    var start = vec2.create();\n\t    var end = vec2.create();\n\t    var extremity = vec2.create();\n\t\n\t    var PI2 = Math.PI * 2;\n\t    /**\n\t     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n\t     * @module zrender/core/bbox\n\t     * @param {Array<Object>} points 顶点数组\n\t     * @param {number} min\n\t     * @param {number} max\n\t     */\n\t    bbox.fromPoints = function(points, min, max) {\n\t        if (points.length === 0) {\n\t            return;\n\t        }\n\t        var p = points[0];\n\t        var left = p[0];\n\t        var right = p[0];\n\t        var top = p[1];\n\t        var bottom = p[1];\n\t        var i;\n\t\n\t        for (i = 1; i < points.length; i++) {\n\t            p = points[i];\n\t            left = mathMin(left, p[0]);\n\t            right = mathMax(right, p[0]);\n\t            top = mathMin(top, p[1]);\n\t            bottom = mathMax(bottom, p[1]);\n\t        }\n\t\n\t        min[0] = left;\n\t        min[1] = top;\n\t        max[0] = right;\n\t        max[1] = bottom;\n\t    };\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n\t        min[0] = mathMin(x0, x1);\n\t        min[1] = mathMin(y0, y1);\n\t        max[0] = mathMax(x0, x1);\n\t        max[1] = mathMax(y0, y1);\n\t    };\n\t\n\t    var xDim = [];\n\t    var yDim = [];\n\t    /**\n\t     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromCubic = function(\n\t        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n\t    ) {\n\t        var cubicExtrema = curve.cubicExtrema;\n\t        var cubicAt = curve.cubicAt;\n\t        var i;\n\t        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t        min[0] = Infinity;\n\t        min[1] = Infinity;\n\t        max[0] = -Infinity;\n\t        max[1] = -Infinity;\n\t\n\t        for (i = 0; i < n; i++) {\n\t            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t            min[0] = mathMin(x, min[0]);\n\t            max[0] = mathMax(x, max[0]);\n\t        }\n\t        n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t        for (i = 0; i < n; i++) {\n\t            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t            min[1] = mathMin(y, min[1]);\n\t            max[1] = mathMax(y, max[1]);\n\t        }\n\t\n\t        min[0] = mathMin(x0, min[0]);\n\t        max[0] = mathMax(x0, max[0]);\n\t        min[0] = mathMin(x3, min[0]);\n\t        max[0] = mathMax(x3, max[0]);\n\t\n\t        min[1] = mathMin(y0, min[1]);\n\t        max[1] = mathMax(y0, max[1]);\n\t        min[1] = mathMin(y3, min[1]);\n\t        max[1] = mathMax(y3, max[1]);\n\t    };\n\t\n\t    /**\n\t     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n\t        var quadraticExtremum = curve.quadraticExtremum;\n\t        var quadraticAt = curve.quadraticAt;\n\t        // Find extremities, where derivative in x dim or y dim is zero\n\t        var tx =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n\t            );\n\t        var ty =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n\t            );\n\t\n\t        var x = quadraticAt(x0, x1, x2, tx);\n\t        var y = quadraticAt(y0, y1, y2, ty);\n\t\n\t        min[0] = mathMin(x0, x2, x);\n\t        min[1] = mathMin(y0, y2, y);\n\t        max[0] = mathMax(x0, x2, x);\n\t        max[1] = mathMax(y0, y2, y);\n\t    };\n\t\n\t    /**\n\t     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n\t     * @method\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {number} rx\n\t     * @param {number} ry\n\t     * @param {number} startAngle\n\t     * @param {number} endAngle\n\t     * @param {number} anticlockwise\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromArc = function (\n\t        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n\t    ) {\n\t        var vec2Min = vec2.min;\n\t        var vec2Max = vec2.max;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t\n\t\n\t        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n\t            // Is a circle\n\t            min[0] = x - rx;\n\t            min[1] = y - ry;\n\t            max[0] = x + rx;\n\t            max[1] = y + ry;\n\t            return;\n\t        }\n\t\n\t        start[0] = mathCos(startAngle) * rx + x;\n\t        start[1] = mathSin(startAngle) * ry + y;\n\t\n\t        end[0] = mathCos(endAngle) * rx + x;\n\t        end[1] = mathSin(endAngle) * ry + y;\n\t\n\t        vec2Min(min, start, end);\n\t        vec2Max(max, start, end);\n\t\n\t        // Thresh to [0, Math.PI * 2]\n\t        startAngle = startAngle % (PI2);\n\t        if (startAngle < 0) {\n\t            startAngle = startAngle + PI2;\n\t        }\n\t        endAngle = endAngle % (PI2);\n\t        if (endAngle < 0) {\n\t            endAngle = endAngle + PI2;\n\t        }\n\t\n\t        if (startAngle > endAngle && !anticlockwise) {\n\t            endAngle += PI2;\n\t        }\n\t        else if (startAngle < endAngle && anticlockwise) {\n\t            startAngle += PI2;\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = endAngle;\n\t            endAngle = startAngle;\n\t            startAngle = tmp;\n\t        }\n\t\n\t        // var number = 0;\n\t        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t            if (angle > startAngle) {\n\t                extremity[0] = mathCos(angle) * rx + x;\n\t                extremity[1] = mathSin(angle) * ry + y;\n\t\n\t                vec2Min(min, extremity, min);\n\t                vec2Max(max, extremity, max);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = bbox;\n\t\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var CMD = __webpack_require__(45).CMD;\n\t    var line = __webpack_require__(49);\n\t    var cubic = __webpack_require__(50);\n\t    var quadratic = __webpack_require__(51);\n\t    var arc = __webpack_require__(52);\n\t    var normalizeRadian = __webpack_require__(53).normalizeRadian;\n\t    var curve = __webpack_require__(46);\n\t\n\t    var windingLine = __webpack_require__(54);\n\t\n\t    var containStroke = line.containStroke;\n\t\n\t    var PI2 = Math.PI * 2;\n\t\n\t    var EPSILON = 1e-4;\n\t\n\t    function isAroundEqual(a, b) {\n\t        return Math.abs(a - b) < EPSILON;\n\t    }\n\t\n\t    // 临时数组\n\t    var roots = [-1, -1, -1];\n\t    var extrema = [-1, -1];\n\t\n\t    function swapExtrema() {\n\t        var tmp = extrema[0];\n\t        extrema[0] = extrema[1];\n\t        extrema[1] = tmp;\n\t    }\n\t\n\t    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2 && y > y3)\n\t            || (y < y0 && y < y1 && y < y2 && y < y3)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var w = 0;\n\t            var nExtrema = -1;\n\t            var y0_, y1_;\n\t            for (var i = 0; i < nRoots; i++) {\n\t                var t = roots[i];\n\t\n\t                // Avoid winding error when intersection point is the connect point of two line of polygon\n\t                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t                if (x_ < x) { // Quick reject\n\t                    continue;\n\t                }\n\t                if (nExtrema < 0) {\n\t                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t                        swapExtrema();\n\t                    }\n\t                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t                    if (nExtrema > 1) {\n\t                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t                    }\n\t                }\n\t                if (nExtrema == 2) {\n\t                    // 分成三段单调函数\n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else if (t < extrema[1]) {\n\t                        w += y1_ < y0_ ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y1_ ? unit : -unit;\n\t                    }\n\t                }\n\t                else {\n\t                    // 分成两段单调函数\n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y0_ ? unit : -unit;\n\t                    }\n\t                }\n\t            }\n\t            return w;\n\t        }\n\t    }\n\t\n\t    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2)\n\t            || (y < y0 && y < y1 && y < y2)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var t = curve.quadraticExtremum(y0, y1, y2);\n\t            if (t >= 0 && t <= 1) {\n\t                var w = 0;\n\t                var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t                for (var i = 0; i < nRoots; i++) {\n\t                    // Remove one endpoint.\n\t                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\t\n\t                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t                    if (x_ < x) {   // Quick reject\n\t                        continue;\n\t                    }\n\t                    if (roots[i] < t) {\n\t                        w += y_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y2 < y_ ? unit : -unit;\n\t                    }\n\t                }\n\t                return w;\n\t            }\n\t            else {\n\t                // Remove one endpoint.\n\t                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t                if (x_ < x) {   // Quick reject\n\t                    return 0;\n\t                }\n\t                return y2 < y0 ? unit : -unit;\n\t            }\n\t        }\n\t    }\n\t\n\t    // TODO\n\t    // Arc 旋转\n\t    function windingArc(\n\t        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n\t    ) {\n\t        y -= cy;\n\t        if (y > r || y < -r) {\n\t            return 0;\n\t        }\n\t        var tmp = Math.sqrt(r * r - y * y);\n\t        roots[0] = -tmp;\n\t        roots[1] = tmp;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff < 1e-4) {\n\t            return 0;\n\t        }\n\t        if (diff % PI2 < 1e-4) {\n\t            // Is a circle\n\t            startAngle = 0;\n\t            endAngle = PI2;\n\t            var dir = anticlockwise ? 1 : -1;\n\t            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t                return dir;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t\n\t        if (anticlockwise) {\n\t            var tmp = startAngle;\n\t            startAngle = normalizeRadian(endAngle);\n\t            endAngle = normalizeRadian(tmp);\n\t        }\n\t        else {\n\t            startAngle = normalizeRadian(startAngle);\n\t            endAngle = normalizeRadian(endAngle);\n\t        }\n\t        if (startAngle > endAngle) {\n\t            endAngle += PI2;\n\t        }\n\t\n\t        var w = 0;\n\t        for (var i = 0; i < 2; i++) {\n\t            var x_ = roots[i];\n\t            if (x_ + cx > x) {\n\t                var angle = Math.atan2(y, x_);\n\t                var dir = anticlockwise ? 1 : -1;\n\t                if (angle < 0) {\n\t                    angle = PI2 + angle;\n\t                }\n\t                if (\n\t                    (angle >= startAngle && angle <= endAngle)\n\t                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n\t                ) {\n\t                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t                        dir = -dir;\n\t                    }\n\t                    w += dir;\n\t                }\n\t            }\n\t        }\n\t        return w;\n\t    }\n\t\n\t    function containPath(data, lineWidth, isStroke, x, y) {\n\t        var w = 0;\n\t        var xi = 0;\n\t        var yi = 0;\n\t        var x0 = 0;\n\t        var y0 = 0;\n\t\n\t        for (var i = 0; i < data.length;) {\n\t            var cmd = data[i++];\n\t            // Begin a new subpath\n\t            if (cmd === CMD.M && i > 1) {\n\t                // Close previous subpath\n\t                if (!isStroke) {\n\t                    w += windingLine(xi, yi, x0, y0, x, y);\n\t                }\n\t                // 如果被任何一个 subpath 包含\n\t                // if (w !== 0) {\n\t                //     return true;\n\t                // }\n\t            }\n\t\n\t            if (i == 1) {\n\t                // 如果第一个命令是 L, C, Q\n\t                // 则 previous point 同绘制命令的第一个 point\n\t                //\n\t                // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                xi = data[i];\n\t                yi = data[i + 1];\n\t\n\t                x0 = xi;\n\t                y0 = yi;\n\t            }\n\t\n\t            switch (cmd) {\n\t                case CMD.M:\n\t                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t                    // 在 closePath 的时候使用\n\t                    x0 = data[i++];\n\t                    y0 = data[i++];\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t                case CMD.L:\n\t                    if (isStroke) {\n\t                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n\t                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.C:\n\t                    if (isStroke) {\n\t                        if (cubic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingCubic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.Q:\n\t                    if (isStroke) {\n\t                        if (quadratic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingQuadratic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.A:\n\t                    // TODO Arc 判断的开销比较大\n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var theta = data[i++];\n\t                    var dTheta = data[i++];\n\t                    // TODO Arc 旋转\n\t                    var psi = data[i++];\n\t                    var anticlockwise = 1 - data[i++];\n\t                    var x1 = Math.cos(theta) * rx + cx;\n\t                    var y1 = Math.sin(theta) * ry + cy;\n\t                    // 不是直接使用 arc 命令\n\t                    if (i > 1) {\n\t                        w += windingLine(xi, yi, x1, y1, x, y);\n\t                    }\n\t                    else {\n\t                        // 第一个命令起点还未定义\n\t                        x0 = x1;\n\t                        y0 = y1;\n\t                    }\n\t                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\t                    var _x = (x - cx) * ry / rx + cx;\n\t                    if (isStroke) {\n\t                        if (arc.containStroke(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            lineWidth, _x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingArc(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            _x, y\n\t                        );\n\t                    }\n\t                    xi = Math.cos(theta + dTheta) * rx + cx;\n\t                    yi = Math.sin(theta + dTheta) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = data[i++];\n\t                    y0 = yi = data[i++];\n\t                    var width = data[i++];\n\t                    var height = data[i++];\n\t                    var x1 = x0 + width;\n\t                    var y1 = y0 + height;\n\t                    if (isStroke) {\n\t                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n\t                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n\t                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n\t                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n\t                        ) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // FIXME Clockwise ?\n\t                        w += windingLine(x1, y0, x1, y1, x, y);\n\t                        w += windingLine(x0, y1, x0, y0, x, y);\n\t                    }\n\t                    break;\n\t                case CMD.Z:\n\t                    if (isStroke) {\n\t                        if (containStroke(\n\t                            xi, yi, x0, y0, lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // Close a subpath\n\t                        w += windingLine(xi, yi, x0, y0, x, y);\n\t                        // 如果被任何一个 subpath 包含\n\t                        // FIXME subpaths may overlap\n\t                        // if (w !== 0) {\n\t                        //     return true;\n\t                        // }\n\t                    }\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t            }\n\t        }\n\t        if (!isStroke && !isAroundEqual(yi, y0)) {\n\t            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t        }\n\t        return w !== 0;\n\t    }\n\t\n\t    module.exports = {\n\t        contain: function (pathData, x, y) {\n\t            return containPath(pathData, 0, false, x, y);\n\t        },\n\t\n\t        containStroke: function (pathData, lineWidth, x, y) {\n\t            return containPath(pathData, lineWidth, true, x, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = {\n\t        /**\n\t         * 线段包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            var _a = 0;\n\t            var _b = x0;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l)\n\t                || (y < y0 - _l && y < y1 - _l)\n\t                || (x > x0 + _l && x > x1 + _l)\n\t                || (x < x0 - _l && x < x1 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t\n\t            if (x0 !== x1) {\n\t                _a = (y0 - y1) / (x0 - x1);\n\t                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n\t            }\n\t            else {\n\t                return Math.abs(x - x0) <= _l / 2;\n\t            }\n\t            var tmp = _a * x - y + _b;\n\t            var _s = tmp * tmp / (_a * _a + 1);\n\t            return _s <= _l / 2 * _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(46);\n\t\n\t    module.exports = {\n\t        /**\n\t         * 三次贝塞尔曲线描边包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  x3\n\t         * @param  {number}  y3\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.cubicProjectPoint(\n\t                x0, y0, x1, y1, x2, y2, x3, y3,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(46);\n\t\n\t    module.exports = {\n\t        /**\n\t         * 二次贝塞尔曲线描边包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.quadraticProjectPoint(\n\t                x0, y0, x1, y1, x2, y2,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var normalizeRadian = __webpack_require__(53).normalizeRadian;\n\t    var PI2 = Math.PI * 2;\n\t\n\t    module.exports = {\n\t        /**\n\t         * 圆弧描边包含判断\n\t         * @param  {number}  cx\n\t         * @param  {number}  cy\n\t         * @param  {number}  r\n\t         * @param  {number}  startAngle\n\t         * @param  {number}  endAngle\n\t         * @param  {boolean}  anticlockwise\n\t         * @param  {number} lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {Boolean}\n\t         */\n\t        containStroke: function (\n\t            cx, cy, r, startAngle, endAngle, anticlockwise,\n\t            lineWidth, x, y\n\t        ) {\n\t\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t\n\t            x -= cx;\n\t            y -= cy;\n\t            var d = Math.sqrt(x * x + y * y);\n\t\n\t            if ((d - _l > r) || (d + _l < r)) {\n\t                return false;\n\t            }\n\t            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n\t                // Is a circle\n\t                return true;\n\t            }\n\t            if (anticlockwise) {\n\t                var tmp = startAngle;\n\t                startAngle = normalizeRadian(endAngle);\n\t                endAngle = normalizeRadian(tmp);\n\t            } else {\n\t                startAngle = normalizeRadian(startAngle);\n\t                endAngle = normalizeRadian(endAngle);\n\t            }\n\t            if (startAngle > endAngle) {\n\t                endAngle += PI2;\n\t            }\n\t\n\t            var angle = Math.atan2(y, x);\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return (angle >= startAngle && angle <= endAngle)\n\t                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n\t        }\n\t    };\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var PI2 = Math.PI * 2;\n\t    module.exports = {\n\t        normalizeRadian: function(angle) {\n\t            angle %= PI2;\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n\t        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n\t            return 0;\n\t        }\n\t        // Ignore horizontal line\n\t        if (y1 === y0) {\n\t            return 0;\n\t        }\n\t        var dir = y1 < y0 ? 1 : -1;\n\t        var t = (y - y0) / (y1 - y0);\n\t\n\t        // Avoid winding error when intersection point is the connect point of two line of polygon\n\t        if (t === 1 || t === 0) {\n\t            dir = y1 < y0 ? 0.5 : -0.5;\n\t        }\n\t\n\t        var x_ = t * (x1 - x0) + x0;\n\t\n\t        return x_ > x ? dir : 0;\n\t    };\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var CMD = __webpack_require__(45).CMD;\n\t    var vec2 = __webpack_require__(15);\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t\n\t    var points = [[], [], []];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAtan2 = Math.atan2;\n\t    function transformPath(path, m) {\n\t        var data = path.data;\n\t        var cmd;\n\t        var nPoint;\n\t        var i;\n\t        var j;\n\t        var k;\n\t        var p;\n\t\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var R = CMD.R;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t\n\t        for (i = 0, j = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            j = i;\n\t            nPoint = 0;\n\t\n\t            switch (cmd) {\n\t                case M:\n\t                    nPoint = 1;\n\t                    break;\n\t                case L:\n\t                    nPoint = 1;\n\t                    break;\n\t                case C:\n\t                    nPoint = 3;\n\t                    break;\n\t                case Q:\n\t                    nPoint = 2;\n\t                    break;\n\t                case A:\n\t                    var x = m[4];\n\t                    var y = m[5];\n\t                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n\t                    // cx\n\t                    data[i++] += x;\n\t                    // cy\n\t                    data[i++] += y;\n\t                    // Scale rx and ry\n\t                    // FIXME Assume psi is 0 here\n\t                    data[i++] *= sx;\n\t                    data[i++] *= sy;\n\t\n\t                    // Start angle\n\t                    data[i++] += angle;\n\t                    // end angle\n\t                    data[i++] += angle;\n\t                    // FIXME psi\n\t                    i += 2;\n\t                    j = i;\n\t                    break;\n\t                case R:\n\t                    // x0, y0\n\t                    p[0] = data[i++];\n\t                    p[1] = data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t                    // x1, y1\n\t                    p[0] += data[i++];\n\t                    p[1] += data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t            }\n\t\n\t            for (k = 0; k < nPoint; k++) {\n\t                var p = points[k];\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t\n\t                v2ApplyTransform(p, p, m);\n\t                // Write back\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = transformPath;\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    /**\n\t     * @param {Array.<Object>} colorStops\n\t     */\n\t    var Gradient = function (colorStops) {\n\t\n\t        this.colorStops = colorStops || [];\n\t    };\n\t\n\t    Gradient.prototype = {\n\t\n\t        constructor: Gradient,\n\t\n\t        addColorStop: function (offset, color) {\n\t            this.colorStops.push({\n\t\n\t                offset: offset,\n\t\n\t                color: color\n\t            });\n\t        }\n\t    };\n\t\n\t    module.exports = Gradient;\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Text element\n\t * @module zrender/graphic/Text\n\t *\n\t * TODO Wrapping\n\t *\n\t * Text not support gradient\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(36);\n\t    var zrUtil = __webpack_require__(6);\n\t    var textContain = __webpack_require__(38);\n\t\n\t    /**\n\t     * @alias zrender/graphic/Text\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    var Text = function (opts) {\n\t        Displayable.call(this, opts);\n\t    };\n\t\n\t    Text.prototype = {\n\t\n\t        constructor: Text,\n\t\n\t        type: 'text',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var x = style.x || 0;\n\t            var y = style.y || 0;\n\t            // Convert to string\n\t            var text = style.text;\n\t\n\t            // Convert to string\n\t            text != null && (text += '');\n\t\n\t            // Always bind style\n\t            style.bind(ctx, this, prevEl);\n\t\n\t            if (text) {\n\t\n\t                this.setTransform(ctx);\n\t\n\t                var textBaseline;\n\t                var textAlign = style.textAlign;\n\t                var font = style.textFont || style.font;\n\t                if (style.textVerticalAlign) {\n\t                    var rect = textContain.getBoundingRect(\n\t                        text, font, style.textAlign, 'top'\n\t                    );\n\t                    // Ignore textBaseline\n\t                    textBaseline = 'middle';\n\t                    switch (style.textVerticalAlign) {\n\t                        case 'middle':\n\t                            y -= rect.height / 2 - rect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= rect.height - rect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += rect.lineHeight / 2;\n\t                    }\n\t                }\n\t                else {\n\t                    textBaseline = style.textBaseline;\n\t                }\n\t\n\t                // TODO Invalid font\n\t                ctx.font = font || '12px sans-serif';\n\t                ctx.textAlign = textAlign || 'left';\n\t                // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t                if (ctx.textAlign !== textAlign) {\n\t                    ctx.textAlign = 'left';\n\t                }\n\t                // FIXME in text contain default is top\n\t                ctx.textBaseline = textBaseline || 'alphabetic';\n\t                // Use canvas default alphabetic baseline\n\t                if (ctx.textBaseline !== textBaseline) {\n\t                    ctx.textBaseline = 'alphabetic';\n\t                }\n\t\n\t                var lineHeight = textContain.measureText('国', ctx.font).width;\n\t\n\t                var textLines = text.split('\\n');\n\t                for (var i = 0; i < textLines.length; i++) {\n\t                    // Fill after stroke so the outline will not cover the main part.\n\t                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n\t                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n\t                    y += lineHeight;\n\t                }\n\t\n\t                this.restoreTransform(ctx);\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t            if (!this._rect) {\n\t                var textVerticalAlign = style.textVerticalAlign;\n\t                var rect = textContain.getBoundingRect(\n\t                    style.text + '', style.textFont || style.font, style.textAlign,\n\t                    textVerticalAlign ? 'top' : style.textBaseline\n\t                );\n\t                switch (textVerticalAlign) {\n\t                    case 'middle':\n\t                        rect.y -= rect.height / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        rect.y -= rect.height;\n\t                        break;\n\t                }\n\t                rect.x += style.x || 0;\n\t                rect.y += style.y || 0;\n\t                if (style.hasStroke()) {\n\t                    var w = style.lineWidth;\n\t                    rect.x -= w / 2;\n\t                    rect.y -= w / 2;\n\t                    rect.width += w;\n\t                    rect.height += w;\n\t                }\n\t                this._rect = rect;\n\t            }\n\t\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Text, Displayable);\n\t\n\t    module.exports = Text;\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 圆形\n\t * @module zrender/shape/Circle\n\t */\n\t\n\t\n\t\n\t    module.exports = __webpack_require__(44).extend({\n\t\n\t        type: 'circle',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0\n\t        },\n\t\n\t\n\t        buildPath : function (ctx, shape, inBundle) {\n\t            // Better stroking in ShapeBundle\n\t            // Always do it may have performence issue ( fill may be 2x more cost)\n\t            if (inBundle) {\n\t                ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            }\n\t            // Better stroking in ShapeBundle\n\t            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 扇形\n\t * @module zrender/graphic/shape/Sector\n\t */\n\t\n\t\n\t\n\t    var env = __webpack_require__(5);\n\t    var Path = __webpack_require__(44);\n\t\n\t    var shadowTemp = [\n\t        ['shadowBlur', 0],\n\t        ['shadowColor', '#000'],\n\t        ['shadowOffsetX', 0],\n\t        ['shadowOffsetY', 0]\n\t    ];\n\t\n\t    module.exports = Path.extend({\n\t\n\t        type: 'sector',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r0: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\n\t            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\n\t            // where exception \"unexpected call to method or property access\"\n\t            // might be thrown when calling ctx.fill after a path whose area size\n\t            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\n\t            // (e.g.,\n\t            //  ctx.moveTo(10, 10);\n\t            //  ctx.lineTo(20, 10);\n\t            //  ctx.closePath();\n\t            //  ctx.clip();\n\t            //  ctx.shadowBlur = 10;\n\t            //  ...\n\t            //  ctx.fill();\n\t            // )\n\t            ? function () {\n\t                var clipPaths = this.__clipPaths;\n\t                var style = this.style;\n\t                var modified;\n\t\n\t                if (clipPaths) {\n\t                    for (var i = 0; i < clipPaths.length; i++) {\n\t                        var shape = clipPaths[i] && clipPaths[i].shape;\n\t                        if (shape && shape.startAngle === shape.endAngle) {\n\t                            for (var j = 0; j < shadowTemp.length; j++) {\n\t                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n\t                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n\t                            }\n\t                            modified = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t\n\t                Path.prototype.brush.apply(this, arguments);\n\t\n\t                if (modified) {\n\t                    for (var j = 0; j < shadowTemp.length; j++) {\n\t                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n\t                    }\n\t                }\n\t            }\n\t            : Path.prototype.brush,\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r0 = Math.max(shape.r0 || 0, 0);\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t\n\t            ctx.lineTo(unitX * r + x, unitY * r + y);\n\t\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t\n\t            ctx.lineTo(\n\t                Math.cos(endAngle) * r0 + x,\n\t                Math.sin(endAngle) * r0 + y\n\t            );\n\t\n\t            if (r0 !== 0) {\n\t                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t            }\n\t\n\t            ctx.closePath();\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 圆环\n\t * @module zrender/graphic/shape/Ring\n\t */\n\t\n\t\n\t    module.exports = __webpack_require__(44).extend({\n\t\n\t        type: 'ring',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            r0: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var PI2 = Math.PI * 2;\n\t            ctx.moveTo(x + shape.r, y);\n\t            ctx.arc(x, y, shape.r, 0, PI2, false);\n\t            ctx.moveTo(x + shape.r0, y);\n\t            ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 多边形\n\t * @module zrender/shape/Polygon\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(62);\n\t\n\t    module.exports = __webpack_require__(44).extend({\n\t        \n\t        type: 'polygon',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, true);\n\t        }\n\t    });\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var smoothSpline = __webpack_require__(63);\n\t    var smoothBezier = __webpack_require__(64);\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape, closePath) {\n\t            var points = shape.points;\n\t            var smooth = shape.smooth;\n\t            if (points && points.length >= 2) {\n\t                if (smooth && smooth !== 'spline') {\n\t                    var controlPoints = smoothBezier(\n\t                        points, smooth, closePath, shape.smoothConstraint\n\t                    );\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    var len = points.length;\n\t                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t                        var cp1 = controlPoints[i * 2];\n\t                        var cp2 = controlPoints[i * 2 + 1];\n\t                        var p = points[(i + 1) % len];\n\t                        ctx.bezierCurveTo(\n\t                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n\t                        );\n\t                    }\n\t                }\n\t                else {\n\t                    if (smooth === 'spline') {\n\t                        points = smoothSpline(points, closePath);\n\t                    }\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    for (var i = 1, l = points.length; i < l; i++) {\n\t                        ctx.lineTo(points[i][0], points[i][1]);\n\t                    }\n\t                }\n\t\n\t                closePath && ctx.closePath();\n\t            }\n\t        }\n\t    };\n\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Catmull-Rom spline 插值折线\n\t * @module zrender/shape/util/smoothSpline\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t    var vec2 = __webpack_require__(15);\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/shape/util/smoothSpline\n\t     * @param {Array} points 线段顶点数组\n\t     * @param {boolean} isLoop\n\t     * @return {Array}\n\t     */\n\t    module.exports = function (points, isLoop) {\n\t        var len = points.length;\n\t        var ret = [];\n\t\n\t        var distance = 0;\n\t        for (var i = 1; i < len; i++) {\n\t            distance += vec2.distance(points[i - 1], points[i]);\n\t        }\n\t\n\t        var segs = distance / 2;\n\t        segs = segs < len ? len : segs;\n\t        for (var i = 0; i < segs; i++) {\n\t            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t            var idx = Math.floor(pos);\n\t\n\t            var w = pos - idx;\n\t\n\t            var p0;\n\t            var p1 = points[idx % len];\n\t            var p2;\n\t            var p3;\n\t            if (!isLoop) {\n\t                p0 = points[idx === 0 ? idx : idx - 1];\n\t                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t            }\n\t            else {\n\t                p0 = points[(idx - 1 + len) % len];\n\t                p2 = points[(idx + 1) % len];\n\t                p3 = points[(idx + 2) % len];\n\t            }\n\t\n\t            var w2 = w * w;\n\t            var w3 = w * w2;\n\t\n\t            ret.push([\n\t                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n\t                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n\t            ]);\n\t        }\n\t        return ret;\n\t    };\n\t\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 贝塞尔平滑曲线\n\t * @module zrender/shape/util/smoothBezier\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(15);\n\t    var v2Min = vec2.min;\n\t    var v2Max = vec2.max;\n\t    var v2Scale = vec2.scale;\n\t    var v2Distance = vec2.distance;\n\t    var v2Add = vec2.add;\n\t\n\t    /**\n\t     * 贝塞尔平滑曲线\n\t     * @alias module:zrender/shape/util/smoothBezier\n\t     * @param {Array} points 线段顶点数组\n\t     * @param {number} smooth 平滑等级, 0-1\n\t     * @param {boolean} isLoop\n\t     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n\t     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n\t     *                           整个折线的包围盒做一个并集用来约束控制点。\n\t     * @param {Array} 计算出来的控制点数组\n\t     */\n\t    module.exports = function (points, smooth, isLoop, constraint) {\n\t        var cps = [];\n\t\n\t        var v = [];\n\t        var v1 = [];\n\t        var v2 = [];\n\t        var prevPoint;\n\t        var nextPoint;\n\t\n\t        var min, max;\n\t        if (constraint) {\n\t            min = [Infinity, Infinity];\n\t            max = [-Infinity, -Infinity];\n\t            for (var i = 0, len = points.length; i < len; i++) {\n\t                v2Min(min, min, points[i]);\n\t                v2Max(max, max, points[i]);\n\t            }\n\t            // 与指定的包围盒做并集\n\t            v2Min(min, min, constraint[0]);\n\t            v2Max(max, max, constraint[1]);\n\t        }\n\t\n\t        for (var i = 0, len = points.length; i < len; i++) {\n\t            var point = points[i];\n\t\n\t            if (isLoop) {\n\t                prevPoint = points[i ? i - 1 : len - 1];\n\t                nextPoint = points[(i + 1) % len];\n\t            }\n\t            else {\n\t                if (i === 0 || i === len - 1) {\n\t                    cps.push(vec2.clone(points[i]));\n\t                    continue;\n\t                }\n\t                else {\n\t                    prevPoint = points[i - 1];\n\t                    nextPoint = points[i + 1];\n\t                }\n\t            }\n\t\n\t            vec2.sub(v, nextPoint, prevPoint);\n\t\n\t            // use degree to scale the handle length\n\t            v2Scale(v, v, smooth);\n\t\n\t            var d0 = v2Distance(point, prevPoint);\n\t            var d1 = v2Distance(point, nextPoint);\n\t            var sum = d0 + d1;\n\t            if (sum !== 0) {\n\t                d0 /= sum;\n\t                d1 /= sum;\n\t            }\n\t\n\t            v2Scale(v1, v, -d0);\n\t            v2Scale(v2, v, d1);\n\t            var cp0 = v2Add([], point, v1);\n\t            var cp1 = v2Add([], point, v2);\n\t            if (constraint) {\n\t                v2Max(cp0, cp0, min);\n\t                v2Min(cp0, cp0, max);\n\t                v2Max(cp1, cp1, min);\n\t                v2Min(cp1, cp1, max);\n\t            }\n\t            cps.push(cp0);\n\t            cps.push(cp1);\n\t        }\n\t\n\t        if (isLoop) {\n\t            cps.push(cps.shift());\n\t        }\n\t\n\t        return cps;\n\t    };\n\t\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/graphic/shape/Polyline\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(62);\n\t\n\t    module.exports = __webpack_require__(44).extend({\n\t        \n\t        type: 'polyline',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, false);\n\t        }\n\t    });\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 矩形\n\t * @module zrender/graphic/shape/Rect\n\t */\n\t\n\t\n\t    var roundRectHelper = __webpack_require__(67);\n\t\n\t    module.exports = __webpack_require__(44).extend({\n\t\n\t        type: 'rect',\n\t\n\t        shape: {\n\t            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n\t            // r缩写为1         相当于 [1, 1, 1, 1]\n\t            // r缩写为[1]       相当于 [1, 1, 1, 1]\n\t            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n\t            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n\t            r: 0,\n\t\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            if (!shape.r) {\n\t                ctx.rect(x, y, width, height);\n\t            }\n\t            else {\n\t                roundRectHelper.buildPath(ctx, shape);\n\t            }\n\t            ctx.closePath();\n\t            return;\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            var r = shape.r;\n\t            var r1;\n\t            var r2;\n\t            var r3;\n\t            var r4;\n\t\n\t            // Convert width and height to positive for better borderRadius\n\t            if (width < 0) {\n\t                x = x + width;\n\t                width = -width;\n\t            }\n\t            if (height < 0) {\n\t                y = y + height;\n\t                height = -height;\n\t            }\n\t\n\t            if (typeof r === 'number') {\n\t                r1 = r2 = r3 = r4 = r;\n\t            }\n\t            else if (r instanceof Array) {\n\t                if (r.length === 1) {\n\t                    r1 = r2 = r3 = r4 = r[0];\n\t                }\n\t                else if (r.length === 2) {\n\t                    r1 = r3 = r[0];\n\t                    r2 = r4 = r[1];\n\t                }\n\t                else if (r.length === 3) {\n\t                    r1 = r[0];\n\t                    r2 = r4 = r[1];\n\t                    r3 = r[2];\n\t                }\n\t                else {\n\t                    r1 = r[0];\n\t                    r2 = r[1];\n\t                    r3 = r[2];\n\t                    r4 = r[3];\n\t                }\n\t            }\n\t            else {\n\t                r1 = r2 = r3 = r4 = 0;\n\t            }\n\t\n\t            var total;\n\t            if (r1 + r2 > width) {\n\t                total = r1 + r2;\n\t                r1 *= width / total;\n\t                r2 *= width / total;\n\t            }\n\t            if (r3 + r4 > width) {\n\t                total = r3 + r4;\n\t                r3 *= width / total;\n\t                r4 *= width / total;\n\t            }\n\t            if (r2 + r3 > height) {\n\t                total = r2 + r3;\n\t                r2 *= height / total;\n\t                r3 *= height / total;\n\t            }\n\t            if (r1 + r4 > height) {\n\t                total = r1 + r4;\n\t                r1 *= height / total;\n\t                r4 *= height / total;\n\t            }\n\t            ctx.moveTo(x + r1, y);\n\t            ctx.lineTo(x + width - r2, y);\n\t            r2 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y, x + width, y + r2\n\t            );\n\t            ctx.lineTo(x + width, y + height - r3);\n\t            r3 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y + height, x + width - r3, y + height\n\t            );\n\t            ctx.lineTo(x + r4, y + height);\n\t            r4 !== 0 && ctx.quadraticCurveTo(\n\t                x, y + height, x, y + height - r4\n\t            );\n\t            ctx.lineTo(x, y + r1);\n\t            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 直线\n\t * @module zrender/graphic/shape/Line\n\t */\n\t\n\t    module.exports = __webpack_require__(44).extend({\n\t\n\t        type: 'line',\n\t\n\t        shape: {\n\t            // Start point\n\t            x1: 0,\n\t            y1: 0,\n\t            // End point\n\t            x2: 0,\n\t            y2: 0,\n\t\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var percent = shape.percent;\n\t\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (percent < 1) {\n\t                x2 = x1 * (1 - percent) + x2 * percent;\n\t                y2 = y1 * (1 - percent) + y2 * percent;\n\t            }\n\t            ctx.lineTo(x2, y2);\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} percent\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (p) {\n\t            var shape = this.shape;\n\t            return [\n\t                shape.x1 * (1 - p) + shape.x2 * p,\n\t                shape.y1 * (1 - p) + shape.y2 * p\n\t            ];\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 贝塞尔曲线\n\t * @module zrender/shape/BezierCurve\n\t */\n\t\n\t\n\t    var curveTool = __webpack_require__(46);\n\t    var vec2 = __webpack_require__(15);\n\t    var quadraticSubdivide = curveTool.quadraticSubdivide;\n\t    var cubicSubdivide = curveTool.cubicSubdivide;\n\t    var quadraticAt = curveTool.quadraticAt;\n\t    var cubicAt = curveTool.cubicAt;\n\t    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n\t    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\t\n\t    var out = [];\n\t\n\t    function someVectorAt(shape, t, isTangent) {\n\t        var cpx2 = shape.cpx2;\n\t        var cpy2 = shape.cpy2;\n\t        if (cpx2 === null || cpy2 === null) {\n\t            return [\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n\t            ];\n\t        }\n\t        else {\n\t            return [\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n\t            ];\n\t        }\n\t    }\n\t    module.exports = __webpack_require__(44).extend({\n\t\n\t        type: 'bezier-curve',\n\t\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            cpx1: 0,\n\t            cpy1: 0,\n\t            // cpx2: 0,\n\t            // cpy2: 0\n\t\n\t            // Curve show percent, for animating\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var cpx1 = shape.cpx1;\n\t            var cpy1 = shape.cpy1;\n\t            var cpx2 = shape.cpx2;\n\t            var cpy2 = shape.cpy2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (cpx2 == null || cpy2 == null) {\n\t                if (percent < 1) {\n\t                    quadraticSubdivide(\n\t                        x1, cpx1, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    x2 = out[2];\n\t                    quadraticSubdivide(\n\t                        y1, cpy1, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    y2 = out[2];\n\t                }\n\t\n\t                ctx.quadraticCurveTo(\n\t                    cpx1, cpy1,\n\t                    x2, y2\n\t                );\n\t            }\n\t            else {\n\t                if (percent < 1) {\n\t                    cubicSubdivide(\n\t                        x1, cpx1, cpx2, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    cpx2 = out[2];\n\t                    x2 = out[3];\n\t                    cubicSubdivide(\n\t                        y1, cpy1, cpy2, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    cpy2 = out[2];\n\t                    y2 = out[3];\n\t                }\n\t                ctx.bezierCurveTo(\n\t                    cpx1, cpy1,\n\t                    cpx2, cpy2,\n\t                    x2, y2\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (t) {\n\t            return someVectorAt(this.shape, t, false);\n\t        },\n\t\n\t        /**\n\t         * Get tangent at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        tangentAt: function (t) {\n\t            var p = someVectorAt(this.shape, t, true);\n\t            return vec2.normalize(p, p);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 圆弧\n\t * @module zrender/graphic/shape/Arc\n\t */\n\t \n\t\n\t    module.exports = __webpack_require__(44).extend({\n\t\n\t        type: 'arc',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        style: {\n\t\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t        }\n\t    });\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(6);\n\t\n\t    var Gradient = __webpack_require__(56);\n\t\n\t    /**\n\t     * x, y, x2, y2 are all percent from 0 to 1\n\t     * @param {number} [x=0]\n\t     * @param {number} [y=0]\n\t     * @param {number} [x2=1]\n\t     * @param {number} [y2=0]\n\t     * @param {Array.<Object>} colorStops\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t        this.x = x == null ? 0 : x;\n\t\n\t        this.y = y == null ? 0 : y;\n\t\n\t        this.x2 = x2 == null ? 1 : x2;\n\t\n\t        this.y2 = y2 == null ? 0 : y2;\n\t\n\t        // Can be cloned\n\t        this.type = 'linear';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    LinearGradient.prototype = {\n\t\n\t        constructor: LinearGradient\n\t    };\n\t\n\t    zrUtil.inherits(LinearGradient, Gradient);\n\t\n\t    module.exports = LinearGradient;\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(6);\n\t\n\t    var Gradient = __webpack_require__(56);\n\t\n\t    /**\n\t     * x, y, r are all percent from 0 to 1\n\t     * @param {number} [x=0.5]\n\t     * @param {number} [y=0.5]\n\t     * @param {number} [r=0.5]\n\t     * @param {Array.<Object>} [colorStops]\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t        this.x = x == null ? 0.5 : x;\n\t\n\t        this.y = y == null ? 0.5 : y;\n\t\n\t        this.r = r == null ? 0.5 : r;\n\t\n\t        // Can be cloned\n\t        this.type = 'radial';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    RadialGradient.prototype = {\n\t\n\t        constructor: RadialGradient\n\t    };\n\t\n\t    zrUtil.inherits(RadialGradient, Gradient);\n\t\n\t    module.exports = RadialGradient;\n\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 事件决策多边形\r\n\t * @module fish-topo-bo/node/EventDecisionNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(40);\r\n\t    var graphic = __webpack_require__(42);\r\n\t\r\n\t    function EventDecisionNode(data, opts) {\r\n\t        /**\r\n\t         * BO属性数据\r\n\t         * @type {Object}\r\n\t         * @private\r\n\t         */\r\n\t        this._data = data;\r\n\t\r\n\t        /**\r\n\t         * 起始位置坐标\r\n\t         * @type {startPos}\r\n\t         * @private\r\n\t         */\r\n\t        this._startPos = opts.startPos;\r\n\t\r\n\t        this._type = opts.type || 'boEvent';\r\n\t\r\n\t        /**\r\n\t         * 是否支持点击\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._clickable = opts.clickable || false;\r\n\t        this._popupOpts = opts.popupOpts;\r\n\t\r\n\t        /**\r\n\t         * Group容器\r\n\t         * @type zrender/graphic/Group\r\n\t         * @private\r\n\t         */\r\n\t        this._group = new graphic.Group();\r\n\t        this._group.name = this._data.id;\r\n\t\r\n\t        //生成BO属性图形\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t    var eventProto = EventDecisionNode.prototype;\r\n\t\r\n\t    /**\r\n\t     * 获取关系整体图形\r\n\t     * @returns {zrender/graphic/Group}\r\n\t     */\r\n\t    eventProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成事件决策图形\r\n\t     * @private\r\n\t     */\r\n\t    eventProto._render = function () {\r\n\t        //多边形\r\n\t        this._createEventShape();\r\n\t        //文字\r\n\t        this._createEVentName();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 事件决策多边形\r\n\t     * @private\r\n\t     */\r\n\t    eventProto._createEventShape = function () {\r\n\t\r\n\t        //多边形高度\r\n\t        var height = Const.BO_EVENT_HEIGHT,\r\n\t            x = this._startPos.x + 1,\r\n\t            y = this._startPos.y,\r\n\t            width = this._type == 'boEvent' ? Const.BO_EVENT_WIDTH : Const.BO_ATTR_EVENT_WIDTH,\r\n\t\r\n\t            shape = new graphic.Polygon({\r\n\t                name: this._data.id,\r\n\t                shape: {\r\n\t                    points: [\r\n\t                        [x, y],\r\n\t                        [x + width - 10, y],\r\n\t                        [x + width, y + height / 2],\r\n\t                        [x + width - 10, y + height],\r\n\t                        [x, y + height]]\r\n\t                },\r\n\t\r\n\t                style: {\r\n\t                    fill: '#FFCCCC',\r\n\t                    stroke: '#000000',\r\n\t                    lineWidth: 0.75\r\n\t                }\r\n\t\r\n\t            });\r\n\t\r\n\t        if (this._clickable) {\r\n\t            shape.clickable = this._clickable;\r\n\t            shape._data = this._data;\r\n\t            shape._popupOpts = this._popupOpts;\r\n\t            shape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t\r\n\t        this._group.add(shape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 点击事件\r\n\t     * @private\r\n\t     */\r\n\t    eventProto._click = function () {\r\n\t        var options = fish.extend(\r\n\t            {\r\n\t                viewOption: {\r\n\t                    DATA: this._data\r\n\t                },\r\n\t                width: 800,\r\n\t                height: 500\r\n\t            }, this._popupOpts);\r\n\t\r\n\t        fish.popupView(options);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 事件决策名称\r\n\t     * @private\r\n\t     */\r\n\t    eventProto._createEVentName = function () {\r\n\t        var x = this._startPos.x + (this._type == 'boEvent' ? Const.BO_ATTR_PADDING_LEFT : 15),\r\n\t            y = this._startPos.y,\r\n\t\r\n\t            eventNameShape = new graphic.Text({\r\n\t                style: {\r\n\t                    text: this._data.name,\r\n\t                    textFont: Const.BO_EVENT_FONT,\r\n\t                    textAlign: 'left',  //靠左开始，便于计算位置\r\n\t                    textBaseline: 'top'\r\n\t                },\r\n\t\r\n\t                position: [x, y]\r\n\t            });\r\n\t\r\n\t        if (this._clickable) {\r\n\t            eventNameShape.clickable = this._clickable;\r\n\t            eventNameShape._data = this._data;\r\n\t            eventNameShape._popupOpts = this._popupOpts;\r\n\t            eventNameShape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t        this._group.add(eventNameShape);\r\n\t    };\r\n\t\r\n\t    module.exports = EventDecisionNode;\r\n\t\r\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO矩形内部的横线，分为实线和虚线两种\r\n\t * @module fish-topo-bo/node/LineNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t\r\n\t    var Const = __webpack_require__(40);\r\n\t    var graphic = __webpack_require__(42);\r\n\t    var util = __webpack_require__(6);\r\n\t    /**\r\n\t     * BO名字下面的实现\r\n\t     * @param {{x: *, y: *}} startPos, 开始坐标\r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @constructor\r\n\t     */\r\n\t    function BoLine(startPos) {\r\n\t\r\n\t        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y};\r\n\t\r\n\t        return _line(startPos, endPos);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * BO属性之间的虚线\r\n\t     * @param {{x: *, y: *}} startPos, 开始坐标\r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @constructor\r\n\t     */\r\n\t    function AttrLine(startPos) {\r\n\t\r\n\t        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y},\r\n\t            style = {lineDash: [Const.LINE_DASH]};\r\n\t\r\n\t        return _line(startPos, endPos, style);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * BO属性与BO事件决策之间的垂直虚线\r\n\t     * @param {{x: *, y: *}} startPos, 开始坐标\r\n\t     * @param {int} attrHeight, 高度\r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @constructor\r\n\t     */\r\n\t    function AttrEventLine(startPos, attrHeight) {\r\n\t        var endPos = {x: startPos.x, y: startPos.y + attrHeight},\r\n\t            style = {lineDash: [Const.LINE_DASH]};\r\n\t\r\n\t        return _line(startPos, endPos, style);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 画线\r\n\t     * @param {{x: *, y: *}} startPos, 开始坐标\r\n\t     * @param {{x: *, y: *}} endPos, 结束坐标\r\n\t     * @param {Object} style, 样式,可空\r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @private\r\n\t     */\r\n\t    function _line(startPos, endPos, style) {\r\n\t\r\n\t        var _style = {\r\n\t            strokeColor: '#000000',\r\n\t            lineWidth: 0.5,\r\n\t            percent: 1\r\n\t        };\r\n\t\r\n\t        util.extend(_style, style);\r\n\t\r\n\t        var shape = new graphic.Line({\r\n\t            shape: {\r\n\t                // Start point\r\n\t                x1: startPos.x,\r\n\t                y1: startPos.y,\r\n\t\r\n\t                // End point\r\n\t                x2: endPos.x,\r\n\t                y2: endPos.y,\r\n\t\r\n\t                percent: 1\r\n\t            },\r\n\t\r\n\t            style: _style\r\n\t        });\r\n\t\r\n\t        return shape;\r\n\t    }\r\n\t\r\n\t\r\n\t    module.exports = {\r\n\t        BoLine: BoLine,\r\n\t        AttrLine: AttrLine,\r\n\t        AttrEventLine: AttrEventLine\r\n\t    };\r\n\t\r\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO属性\r\n\t * 1.BO属性名字\r\n\t * 2.BO属性数据类型\r\n\t * 3.BO属性事件决策\r\n\t * @module fish-topo-bo/node/BoAttrNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(40);\r\n\t    var EventDecision = __webpack_require__(73);\r\n\t    var graphic = __webpack_require__(42);\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param {{\r\n\t     *          id: String bo属性标识,\r\n\t     *          code: String bo属性编码\r\n\t     *          keyValue: boolean 是否为主键,\r\n\t     *          dataType: String 属性数据类型,\r\n\t     *          boAttrEventArr:[] 属性事件决策数组\r\n\t     *          }} boAttrData BO属性数据对象,\r\n\t     * @param {{\r\n\t     *          startPos: {x: number, y: number}起始位置,\r\n\t     *          displayDataType: boolean 是否显示数据类型,\r\n\t     *          displayEventDecision: boolean 是否显示事件决策,\r\n\t     *          eventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false,\r\n\t     *          eventPopupOpts: Object 点击BO属性事件决策弹出页面参数，url,width,height等,\r\n\t     *          }} opts\r\n\t     * @constructor\r\n\t     */\r\n\t    function BoAttr(boAttrData, opts) {\r\n\t        /**\r\n\t         * BO属性数据\r\n\t         * @type {Object}\r\n\t         * @private\r\n\t         */\r\n\t        this._data = boAttrData;\r\n\t\r\n\t        /**\r\n\t         * 是否为主键\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._keyValue = boAttrData.keyValue || false;\r\n\t\r\n\t        /**\r\n\t         * 起始位置坐标\r\n\t         * @type {startPos}\r\n\t         * @private\r\n\t         */\r\n\t        this._startPos = opts.startPos;\r\n\t\r\n\t        /**\r\n\t         * 是否显示数据类型\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayDataType = opts.displayDataType || false;\r\n\t\r\n\t        /**\r\n\t         * 是否显示事件决策\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayEventDecision = opts.displayEventDecision || false;\r\n\t\r\n\t        /**\r\n\t         * 是否支持点击\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._eventClickable = opts.eventClickable || false;\r\n\t        this._eventPopupOpts = opts.eventPopupOpts;\r\n\t\r\n\t        /**\r\n\t         * Group容器\r\n\t         * @type zrender/graphic/Group\r\n\t         * @private\r\n\t         */\r\n\t        this._group = new graphic.Group();\r\n\t        this._group.name = this._data.id;\r\n\t\r\n\t        //生成BO属性图形\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t    var boAttrProto = BoAttr.prototype;\r\n\t\r\n\t    /**\r\n\t     * 获取关系整体图形\r\n\t     * @returns {zrender/graphic/Group}\r\n\t     */\r\n\t    boAttrProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 生成BO属性图形\r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._render = function () {\r\n\t        //属性名字\r\n\t        this._createText();\r\n\t\r\n\t        //属性数据类型\r\n\t        this._createDataType();\r\n\t\r\n\t        //属性事件决策\r\n\t        this._createEventDecision();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 属性名字\r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._createText = function () {\r\n\t\r\n\t        var x = this._startPos.x + Const.BO_ATTR_PADDING_LEFT,\r\n\t            y = this._startPos.y,\r\n\t\r\n\t            attrNameShape = new graphic.Text({\r\n\t                style: {\r\n\t                    text: this._data.name,\r\n\t                    textFont: Const.BO_ATTR_FONT,\r\n\t                    textAlign: 'left',  //靠左开始，便于计算位置\r\n\t                    textBaseline: 'top',\r\n\t                    //lineWidth: 1,\r\n\t                    fill: this._keyValue ? 'red' : 'black'\r\n\t                },\r\n\t\r\n\t                position: [x, y]\r\n\t            });\r\n\t\r\n\t        //重新设置图形高度 = 文本高度 + padding-top + padding-bottom\r\n\t        attrNameShape.getBoundingRect().height += Const.BO_ATTR_PADDING_TOP + Const.BO_ATTR_PADDING_BOTTOM;\r\n\t        //重新设置图形高度 = BO矩形宽度，用于后续Relation画图计算\r\n\t        attrNameShape.getBoundingRect().width = Const.BO_NODE_WIDTH;\r\n\t\r\n\t        //重新设置B起始水平坐标 = 减去偏移量\r\n\t        attrNameShape.getBoundingRect().x += -Const.BO_ATTR_PADDING_LEFT;\r\n\t        //attrNameShape.getBoundingRect().y = + attrNameShape.position[1];\r\n\t\r\n\t        this._group.add(attrNameShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 属性数据类型\r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._createDataType = function () {\r\n\t        if (!this._displayDataType) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var x = this._startPos.x + Const.BO_NODE_WIDTH - 10,\r\n\t            y = this._startPos.y,\r\n\t            textAlign = 'right';\r\n\t\r\n\t        //如果还要显示事件决策，则宽度重新计算\r\n\t        if (this._displayEventDecision) {\r\n\t            textAlign = 'left';\r\n\t            x = this._startPos.x + Const.BO_NODE_WIDTH / 3;\r\n\t        }\r\n\t\r\n\t        var _dataTypeShape = new graphic.Text({\r\n\t            style: {\r\n\t                text: this._data.dataType || '',\r\n\t                textFont: Const.BO_ATTR_FONT,\r\n\t                textAlign: textAlign,  //靠左开始，便于计算位置\r\n\t                textBaseline: 'top',\r\n\t                lineWidth: 1\r\n\t            },\r\n\t\r\n\t            position: [x, y]\r\n\t        });\r\n\t\r\n\t        this._group.add(_dataTypeShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 属性事件决策\r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._createEventDecision = function () {\r\n\t        if (!this._displayEventDecision) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var _boAttrEventArr = this._data.boAttrEventArr || [],\r\n\t            _boAttrEventLen = _boAttrEventArr.length,\r\n\t            padding = (_boAttrEventLen > 1) ? 10 : 0,\r\n\t            _startPos = {\r\n\t                x: this._startPos.x + Const.BO_NODE_WIDTH / 2 + Const.BO_ATTR_EVENT_WIDTH * (_boAttrEventLen - 1) - padding,\r\n\t                y: this._startPos.y\r\n\t            };\r\n\t\r\n\t        //从右向左画，\r\n\t        for (var i = _boAttrEventLen - 1; i >= 0; i--) {\r\n\t            this._group.add(new EventDecision(_boAttrEventArr[i], {\r\n\t                startPos: _startPos,\r\n\t                type: 'boAttrEvent',\r\n\t                clickable: this._eventClickable,\r\n\t                popupOpts: this._eventPopupOpts\r\n\t            }).getShape());\r\n\t            _startPos = {x: _startPos.x - Const.BO_ATTR_EVENT_WIDTH + 10, y: _startPos.y};\r\n\t        }\r\n\t        /*_startPos = {\r\n\t         x: this._startPos.x + Const.BO_NODE_WIDTH / 2,\r\n\t         y: this._startPos.y};\r\n\t\r\n\t         for (var i = 0; i < _boAttrEventLen; i++) {\r\n\t         this._group.add(event.BoAttrEvent(_boAttrEventArr[i], _startPos, i + 2));\r\n\t         _startPos = {x: _startPos.x + Const.BO_ATTR_EVENT_WIDTH - 5, y: _startPos.y};\r\n\t         }*/\r\n\t\r\n\t\r\n\t    };\r\n\t\r\n\t    module.exports = BoAttr;\r\n\t\r\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 用来创建关联关系\r\n\t * 关联关系包括折线、箭头、关系文字说明\r\n\t * @module fish-topo-bo/node/Relation\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(40);\r\n\t    var graphic = __webpack_require__(42);\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param sourceShape, 开始图形\r\n\t     * @param targetShape, 目标图形\r\n\t     * @param {String} sourceText, 关系开始文字说明,可空\r\n\t     * @param {String} targetText, 关系结束文字说明,可空\r\n\t     * @constructor\r\n\t     */\r\n\t    function Relation(sourceShape, targetShape, sourceText, targetText) {\r\n\t        this._sourceText = sourceText;\r\n\t        this._targetText = targetText;\r\n\t\r\n\t        this._group = new graphic.Group();\r\n\t\r\n\t        //左侧开始位置\r\n\t        this._lStartPos = {\r\n\t            x: sourceShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //左侧结束位置\r\n\t        this._lEndPos = {\r\n\t            x: targetShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //右侧开始位置\r\n\t        this._rStartPos = {\r\n\t            x: sourceShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //右侧结束位置\r\n\t        this._rEndPos = {\r\n\t            x: targetShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //判断画线方向\r\n\t        this._leftDirection = this._lStartPos.x - this._lEndPos.x <= 0;\r\n\t\r\n\t        //生成图形\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t    var relationProto = Relation.prototype;\r\n\t\r\n\t    /**\r\n\t     * 获取关系整体图形\r\n\t     * @returns {*}\r\n\t     */\r\n\t    relationProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成关系整体图形\r\n\t     * @private\r\n\t     */\r\n\t    relationProto._render = function () {\r\n\t        //画线\r\n\t        this._createLine();\r\n\t\r\n\t        //箭头\r\n\t        this._createArrow();\r\n\t\r\n\t        //关系说明文字\r\n\t        this._createText();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成关系折线\r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createLine = function () {\r\n\t        var _linePoints = [];\r\n\t\r\n\t        if (this._leftDirection) {\r\n\t            //第一点\r\n\t            _linePoints.push([this._lStartPos.x, this._lStartPos.y]);\r\n\t            //第二点\r\n\t            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lStartPos.y]);\r\n\t            //第三点\r\n\t            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lEndPos.y]);\r\n\t            //第四点\r\n\t            _linePoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n\t        }\r\n\t        else {\r\n\t            //第一点\r\n\t            _linePoints.push([this._rStartPos.x, this._rStartPos.y]);\r\n\t            //第二点\r\n\t            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._lStartPos.y]);\r\n\t            //第三点\r\n\t            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._rEndPos.y]);\r\n\t            //第四点\r\n\t            _linePoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n\t        }\r\n\t\r\n\t        var _lineShape = new graphic.Polyline({\r\n\t            shape: {\r\n\t                points: _linePoints\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                //fill: 'blue',\r\n\t                stroke: 'blue'\r\n\t            }\r\n\t        });\r\n\t\r\n\t        this._group.add(_lineShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成箭头图形\r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createArrow = function () {\r\n\t        var _arrowPoints = [];\r\n\t\r\n\t        if (this._leftDirection) {\r\n\t            //右侧第一点\r\n\t            _arrowPoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n\t            //下面第二点\r\n\t            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n\t            //上面第三点\r\n\t            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n\t        }\r\n\t        else {\r\n\t            //左侧第一点\r\n\t            _arrowPoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n\t            //下面第二点\r\n\t            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n\t            //上面第三点\r\n\t            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n\t        }\r\n\t\r\n\t        var _arrowShape = new graphic.Polyline({\r\n\t            shape: {\r\n\t                points: _arrowPoints\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                fill: 'blue',\r\n\t                stroke: 'blue'\r\n\t            }\r\n\t        });\r\n\t\r\n\t        this._group.add(_arrowShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成文字说明\r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createText = function () {\r\n\t        var _sourceTextPos,\r\n\t            _targetTextPos,\r\n\t            _textAlign;\r\n\t\r\n\t        if (this._leftDirection) {\r\n\t            _sourceTextPos = [this._lStartPos.x - 10, this._lStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _targetTextPos = [this._lEndPos.x - 10 - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _textAlign = 'right';\r\n\t        }\r\n\t        else {\r\n\t            _sourceTextPos = [this._rStartPos.x + 10, this._rStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _targetTextPos = [this._rEndPos.x + 10 + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _textAlign = 'left';\r\n\t        }\r\n\t\r\n\t        //开始文字\r\n\t        if (this._sourceText) {\r\n\t            var _srcTextShape = new graphic.Text({\r\n\t                position: _sourceTextPos,\r\n\t\r\n\t                style: {\r\n\t                    text: this._sourceText,\r\n\t                    textFont: Const.BO_ATTR_FONT,\r\n\t                    textAlign: _textAlign,\r\n\t                    textBaseline: 'buttom',\r\n\t                    lineWidth: 1\r\n\t                }\r\n\t            });\r\n\t            this._group.add(_srcTextShape);\r\n\t        }\r\n\t\r\n\t        //结束文字\r\n\t        if (this._targetText) {\r\n\t            var _targetTextShape = new graphic.Text({\r\n\t                position: _targetTextPos,\r\n\t\r\n\t                style: {\r\n\t                    text: this._targetText,\r\n\t                    textFont: Const.BO_ATTR_FONT,\r\n\t                    textAlign: _textAlign,\r\n\t                    textBaseline: 'buttom',\r\n\t                    lineWidth: 1\r\n\t                }\r\n\t            });\r\n\t            this._group.add(_targetTextShape);\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    module.exports = Relation;\r\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    __webpack_require__(78);\n\t    __webpack_require__(3).registerPainter('vml', __webpack_require__(80));\n\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// http://www.w3.org/TR/NOTE-VML\n\t// TODO Use proxy like svg instead of overwrite brush methods\n\t\n\t\n\tif (!__webpack_require__(5).canvasSupported) {\n\t    var vec2 = __webpack_require__(15);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var CMD = __webpack_require__(45).CMD;\n\t    var colorTool = __webpack_require__(20);\n\t    var textContain = __webpack_require__(38);\n\t    var RectText = __webpack_require__(37);\n\t    var Displayable = __webpack_require__(36);\n\t    var ZImage = __webpack_require__(35);\n\t    var Text = __webpack_require__(57);\n\t    var Path = __webpack_require__(44);\n\t\n\t    var Gradient = __webpack_require__(56);\n\t\n\t    var vmlCore = __webpack_require__(79);\n\t\n\t    var round = Math.round;\n\t    var sqrt = Math.sqrt;\n\t    var abs = Math.abs;\n\t    var cos = Math.cos;\n\t    var sin = Math.sin;\n\t    var mathMax = Math.max;\n\t\n\t    var applyTransform = vec2.applyTransform;\n\t\n\t    var comma = ',';\n\t    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\t\n\t    var Z = 21600;\n\t    var Z2 = Z / 2;\n\t\n\t    var ZLEVEL_BASE = 100000;\n\t    var Z_BASE = 1000;\n\t\n\t    var initRootElStyle = function (el) {\n\t        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n\t        el.coordsize = Z + ','  + Z;\n\t        el.coordorigin = '0,0';\n\t    };\n\t\n\t    var encodeHtmlAttribute = function (s) {\n\t        return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n\t    };\n\t\n\t    var rgb2Str = function (r, g, b) {\n\t        return 'rgb(' + [r, g, b].join(',') + ')';\n\t    };\n\t\n\t    var append = function (parent, child) {\n\t        if (child && parent && child.parentNode !== parent) {\n\t            parent.appendChild(child);\n\t        }\n\t    };\n\t\n\t    var remove = function (parent, child) {\n\t        if (child && parent && child.parentNode === parent) {\n\t            parent.removeChild(child);\n\t        }\n\t    };\n\t\n\t    var getZIndex = function (zlevel, z, z2) {\n\t        // z 的取值范围为 [0, 1000]\n\t        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n\t    };\n\t\n\t    var parsePercent = function (value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    };\n\t\n\t    /***************************************************\n\t     * PATH\n\t     **************************************************/\n\t\n\t    var setColorAndOpacity = function (el, color, opacity) {\n\t        var colorArr = colorTool.parse(color);\n\t        opacity = +opacity;\n\t        if (isNaN(opacity)) {\n\t            opacity = 1;\n\t        }\n\t        if (colorArr) {\n\t            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n\t            el.opacity = opacity * colorArr[3];\n\t        }\n\t    };\n\t\n\t    var getColorAndAlpha = function (color) {\n\t        var colorArr = colorTool.parse(color);\n\t        return [\n\t            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),\n\t            colorArr[3]\n\t        ];\n\t    };\n\t\n\t    var updateFillNode = function (el, style, zrEl) {\n\t        // TODO pattern\n\t        var fill = style.fill;\n\t        if (fill != null) {\n\t            // Modified from excanvas\n\t            if (fill instanceof Gradient) {\n\t                var gradientType;\n\t                var angle = 0;\n\t                var focus = [0, 0];\n\t                // additional offset\n\t                var shift = 0;\n\t                // scale factor for offset\n\t                var expansion = 1;\n\t                var rect = zrEl.getBoundingRect();\n\t                var rectWidth = rect.width;\n\t                var rectHeight = rect.height;\n\t                if (fill.type === 'linear') {\n\t                    gradientType = 'gradient';\n\t                    var transform = zrEl.transform;\n\t                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\t                    if (transform) {\n\t                        applyTransform(p0, p0, transform);\n\t                        applyTransform(p1, p1, transform);\n\t                    }\n\t                    var dx = p1[0] - p0[0];\n\t                    var dy = p1[1] - p0[1];\n\t                    angle = Math.atan2(dx, dy) * 180 / Math.PI;\n\t                    // The angle should be a non-negative number.\n\t                    if (angle < 0) {\n\t                        angle += 360;\n\t                    }\n\t\n\t                    // Very small angles produce an unexpected result because they are\n\t                    // converted to a scientific notation string.\n\t                    if (angle < 1e-6) {\n\t                        angle = 0;\n\t                    }\n\t                }\n\t                else {\n\t                    gradientType = 'gradientradial';\n\t                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t                    var transform = zrEl.transform;\n\t                    var scale = zrEl.scale;\n\t                    var width = rectWidth;\n\t                    var height = rectHeight;\n\t                    focus = [\n\t                        // Percent in bounding rect\n\t                        (p0[0] - rect.x) / width,\n\t                        (p0[1] - rect.y) / height\n\t                    ];\n\t                    if (transform) {\n\t                        applyTransform(p0, p0, transform);\n\t                    }\n\t\n\t                    width /= scale[0] * Z;\n\t                    height /= scale[1] * Z;\n\t                    var dimension = mathMax(width, height);\n\t                    shift = 2 * 0 / dimension;\n\t                    expansion = 2 * fill.r / dimension - shift;\n\t                }\n\t\n\t                // We need to sort the color stops in ascending order by offset,\n\t                // otherwise IE won't interpret it correctly.\n\t                var stops = fill.colorStops.slice();\n\t                stops.sort(function(cs1, cs2) {\n\t                    return cs1.offset - cs2.offset;\n\t                });\n\t\n\t                var length = stops.length;\n\t                // Color and alpha list of first and last stop\n\t                var colorAndAlphaList = [];\n\t                var colors = [];\n\t                for (var i = 0; i < length; i++) {\n\t                    var stop = stops[i];\n\t                    var colorAndAlpha = getColorAndAlpha(stop.color);\n\t                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\t                    if (i === 0 || i === length - 1) {\n\t                        colorAndAlphaList.push(colorAndAlpha);\n\t                    }\n\t                }\n\t\n\t                if (length >= 2) {\n\t                    var color1 = colorAndAlphaList[0][0];\n\t                    var color2 = colorAndAlphaList[1][0];\n\t                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n\t                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\t\n\t                    el.type = gradientType;\n\t                    el.method = 'none';\n\t                    el.focus = '100%';\n\t                    el.angle = angle;\n\t                    el.color = color1;\n\t                    el.color2 = color2;\n\t                    el.colors = colors.join(',');\n\t                    // When colors attribute is used, the meanings of opacity and o:opacity2\n\t                    // are reversed.\n\t                    el.opacity = opacity2;\n\t                    // FIXME g_o_:opacity ?\n\t                    el.opacity2 = opacity1;\n\t                }\n\t                if (gradientType === 'radial') {\n\t                    el.focusposition = focus.join(',');\n\t                }\n\t            }\n\t            else {\n\t                // FIXME Change from Gradient fill to color fill\n\t                setColorAndOpacity(el, fill, style.opacity);\n\t            }\n\t        }\n\t    };\n\t\n\t    var updateStrokeNode = function (el, style) {\n\t        // if (style.lineJoin != null) {\n\t        //     el.joinstyle = style.lineJoin;\n\t        // }\n\t        // if (style.miterLimit != null) {\n\t        //     el.miterlimit = style.miterLimit * Z;\n\t        // }\n\t        // if (style.lineCap != null) {\n\t        //     el.endcap = style.lineCap;\n\t        // }\n\t        if (style.lineDash != null) {\n\t            el.dashstyle = style.lineDash.join(' ');\n\t        }\n\t        if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n\t            setColorAndOpacity(el, style.stroke, style.opacity);\n\t        }\n\t    };\n\t\n\t    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n\t        var isFill = type == 'fill';\n\t        var el = vmlEl.getElementsByTagName(type)[0];\n\t        // Stroke must have lineWidth\n\t        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {\n\t            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';\n\t            // FIXME Remove before updating, or set `colors` will throw error\n\t            if (style[type] instanceof Gradient) {\n\t                remove(vmlEl, el);\n\t            }\n\t            if (!el) {\n\t                el = vmlCore.createNode(type);\n\t            }\n\t\n\t            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n\t            append(vmlEl, el);\n\t        }\n\t        else {\n\t            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n\t            remove(vmlEl, el);\n\t        }\n\t    };\n\t\n\t    var points = [[], [], []];\n\t    var pathDataToString = function (data, m) {\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t\n\t        var str = [];\n\t        var nPoint;\n\t        var cmdStr;\n\t        var cmd;\n\t        var i;\n\t        var xi;\n\t        var yi;\n\t        for (i = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            cmdStr = '';\n\t            nPoint = 0;\n\t            switch (cmd) {\n\t                case M:\n\t                    cmdStr = ' m ';\n\t                    nPoint = 1;\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    points[0][0] = xi;\n\t                    points[0][1] = yi;\n\t                    break;\n\t                case L:\n\t                    cmdStr = ' l ';\n\t                    nPoint = 1;\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    points[0][0] = xi;\n\t                    points[0][1] = yi;\n\t                    break;\n\t                case Q:\n\t                case C:\n\t                    cmdStr = ' c ';\n\t                    nPoint = 3;\n\t                    var x1 = data[i++];\n\t                    var y1 = data[i++];\n\t                    var x2 = data[i++];\n\t                    var y2 = data[i++];\n\t                    var x3;\n\t                    var y3;\n\t                    if (cmd === Q) {\n\t                        // Convert quadratic to cubic using degree elevation\n\t                        x3 = x2;\n\t                        y3 = y2;\n\t                        x2 = (x2 + 2 * x1) / 3;\n\t                        y2 = (y2 + 2 * y1) / 3;\n\t                        x1 = (xi + 2 * x1) / 3;\n\t                        y1 = (yi + 2 * y1) / 3;\n\t                    }\n\t                    else {\n\t                        x3 = data[i++];\n\t                        y3 = data[i++];\n\t                    }\n\t                    points[0][0] = x1;\n\t                    points[0][1] = y1;\n\t                    points[1][0] = x2;\n\t                    points[1][1] = y2;\n\t                    points[2][0] = x3;\n\t                    points[2][1] = y3;\n\t\n\t                    xi = x3;\n\t                    yi = y3;\n\t                    break;\n\t                case A:\n\t                    var x = 0;\n\t                    var y = 0;\n\t                    var sx = 1;\n\t                    var sy = 1;\n\t                    var angle = 0;\n\t                    if (m) {\n\t                        // Extract SRT from matrix\n\t                        x = m[4];\n\t                        y = m[5];\n\t                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t                        angle = Math.atan2(-m[1] / sy, m[0] / sx);\n\t                    }\n\t\n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var startAngle = data[i++] + angle;\n\t                    var endAngle = data[i++] + startAngle + angle;\n\t                    // FIXME\n\t                    // var psi = data[i++];\n\t                    i++;\n\t                    var clockwise = data[i++];\n\t\n\t                    var x0 = cx + cos(startAngle) * rx;\n\t                    var y0 = cy + sin(startAngle) * ry;\n\t\n\t                    var x1 = cx + cos(endAngle) * rx;\n\t                    var y1 = cy + sin(endAngle) * ry;\n\t\n\t                    var type = clockwise ? ' wa ' : ' at ';\n\t                    if (Math.abs(x0 - x1) < 1e-4) {\n\t                        // IE won't render arches drawn counter clockwise if x0 == x1.\n\t                        if (Math.abs(endAngle - startAngle) > 1e-2) {\n\t                            // Offset x0 by 1/80 of a pixel. Use something\n\t                            // that can be represented in binary\n\t                            if (clockwise) {\n\t                                x0 += 270 / Z;\n\t                            }\n\t                        }\n\t                        else {\n\t                            // Avoid case draw full circle\n\t                            if (Math.abs(y0 - cy) < 1e-4) {\n\t                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {\n\t                                    y1 -= 270 / Z;\n\t                                }\n\t                                else {\n\t                                    y1 += 270 / Z;\n\t                                }\n\t                            }\n\t                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {\n\t                                x1 += 270 / Z;\n\t                            }\n\t                            else {\n\t                                x1 -= 270 / Z;\n\t                            }\n\t                        }\n\t                    }\n\t                    str.push(\n\t                        type,\n\t                        round(((cx - rx) * sx + x) * Z - Z2), comma,\n\t                        round(((cy - ry) * sy + y) * Z - Z2), comma,\n\t                        round(((cx + rx) * sx + x) * Z - Z2), comma,\n\t                        round(((cy + ry) * sy + y) * Z - Z2), comma,\n\t                        round((x0 * sx + x) * Z - Z2), comma,\n\t                        round((y0 * sy + y) * Z - Z2), comma,\n\t                        round((x1 * sx + x) * Z - Z2), comma,\n\t                        round((y1 * sy + y) * Z - Z2)\n\t                    );\n\t\n\t                    xi = x1;\n\t                    yi = y1;\n\t                    break;\n\t                case CMD.R:\n\t                    var p0 = points[0];\n\t                    var p1 = points[1];\n\t                    // x0, y0\n\t                    p0[0] = data[i++];\n\t                    p0[1] = data[i++];\n\t                    // x1, y1\n\t                    p1[0] = p0[0] + data[i++];\n\t                    p1[1] = p0[1] + data[i++];\n\t\n\t                    if (m) {\n\t                        applyTransform(p0, p0, m);\n\t                        applyTransform(p1, p1, m);\n\t                    }\n\t\n\t                    p0[0] = round(p0[0] * Z - Z2);\n\t                    p1[0] = round(p1[0] * Z - Z2);\n\t                    p0[1] = round(p0[1] * Z - Z2);\n\t                    p1[1] = round(p1[1] * Z - Z2);\n\t                    str.push(\n\t                        // x0, y0\n\t                        ' m ', p0[0], comma, p0[1],\n\t                        // x1, y0\n\t                        ' l ', p1[0], comma, p0[1],\n\t                        // x1, y1\n\t                        ' l ', p1[0], comma, p1[1],\n\t                        // x0, y1\n\t                        ' l ', p0[0], comma, p1[1]\n\t                    );\n\t                    break;\n\t                case CMD.Z:\n\t                    // FIXME Update xi, yi\n\t                    str.push(' x ');\n\t            }\n\t\n\t            if (nPoint > 0) {\n\t                str.push(cmdStr);\n\t                for (var k = 0; k < nPoint; k++) {\n\t                    var p = points[k];\n\t\n\t                    m && applyTransform(p, p, m);\n\t                    // 不 round 会非常慢\n\t                    str.push(\n\t                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),\n\t                        k < nPoint - 1 ? comma : ''\n\t                    );\n\t                }\n\t            }\n\t        }\n\t\n\t        return str.join('');\n\t    };\n\t\n\t    // Rewrite the original path method\n\t    Path.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t\n\t        var vmlEl = this._vmlEl;\n\t        if (!vmlEl) {\n\t            vmlEl = vmlCore.createNode('shape');\n\t            initRootElStyle(vmlEl);\n\t\n\t            this._vmlEl = vmlEl;\n\t        }\n\t\n\t        updateFillAndStroke(vmlEl, 'fill', style, this);\n\t        updateFillAndStroke(vmlEl, 'stroke', style, this);\n\t\n\t        var m = this.transform;\n\t        var needTransform = m != null;\n\t        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\t        if (strokeEl) {\n\t            var lineWidth = style.lineWidth;\n\t            // Get the line scale.\n\t            // Determinant of this.m_ means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            if (needTransform && !style.strokeNoScale) {\n\t                var det = m[0] * m[3] - m[1] * m[2];\n\t                lineWidth *= sqrt(abs(det));\n\t            }\n\t            strokeEl.weight = lineWidth + 'px';\n\t        }\n\t\n\t        var path = this.path;\n\t        if (this.__dirtyPath) {\n\t            path.beginPath();\n\t            this.buildPath(path, this.shape);\n\t            path.toStatic();\n\t            this.__dirtyPath = false;\n\t        }\n\t\n\t        vmlEl.path = pathDataToString(path.data, this.transform);\n\t\n\t        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Append to root\n\t        append(vmlRoot, vmlEl);\n\t\n\t        // Text\n\t        if (style.text != null) {\n\t            this.drawRectText(vmlRoot, this.getBoundingRect());\n\t        }\n\t        else {\n\t            this.removeRectText(vmlRoot);\n\t        }\n\t    };\n\t\n\t    Path.prototype.onRemove = function (vmlRoot) {\n\t        remove(vmlRoot, this._vmlEl);\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    Path.prototype.onAdd = function (vmlRoot) {\n\t        append(vmlRoot, this._vmlEl);\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t\n\t    /***************************************************\n\t     * IMAGE\n\t     **************************************************/\n\t    var isImage = function (img) {\n\t        // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n\t        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';\n\t        // return img instanceof Image;\n\t    };\n\t\n\t    // Rewrite the original path method\n\t    ZImage.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t        var image = style.image;\n\t\n\t        // Image original width, height\n\t        var ow;\n\t        var oh;\n\t\n\t        if (isImage(image)) {\n\t            var src = image.src;\n\t            if (src === this._imageSrc) {\n\t                ow = this._imageWidth;\n\t                oh = this._imageHeight;\n\t            }\n\t            else {\n\t                var imageRuntimeStyle = image.runtimeStyle;\n\t                var oldRuntimeWidth = imageRuntimeStyle.width;\n\t                var oldRuntimeHeight = imageRuntimeStyle.height;\n\t                imageRuntimeStyle.width = 'auto';\n\t                imageRuntimeStyle.height = 'auto';\n\t\n\t                // get the original size\n\t                ow = image.width;\n\t                oh = image.height;\n\t\n\t                // and remove overides\n\t                imageRuntimeStyle.width = oldRuntimeWidth;\n\t                imageRuntimeStyle.height = oldRuntimeHeight;\n\t\n\t                // Caching image original width, height and src\n\t                this._imageSrc = src;\n\t                this._imageWidth = ow;\n\t                this._imageHeight = oh;\n\t            }\n\t            image = src;\n\t        }\n\t        else {\n\t            if (image === this._imageSrc) {\n\t                ow = this._imageWidth;\n\t                oh = this._imageHeight;\n\t            }\n\t        }\n\t        if (!image) {\n\t            return;\n\t        }\n\t\n\t        var x = style.x || 0;\n\t        var y = style.y || 0;\n\t\n\t        var dw = style.width;\n\t        var dh = style.height;\n\t\n\t        var sw = style.sWidth;\n\t        var sh = style.sHeight;\n\t        var sx = style.sx || 0;\n\t        var sy = style.sy || 0;\n\t\n\t        var hasCrop = sw && sh;\n\t\n\t        var vmlEl = this._vmlEl;\n\t        if (!vmlEl) {\n\t            // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n\t            // vmlEl = vmlCore.createNode('group');\n\t            vmlEl = vmlCore.doc.createElement('div');\n\t            initRootElStyle(vmlEl);\n\t\n\t            this._vmlEl = vmlEl;\n\t        }\n\t\n\t        var vmlElStyle = vmlEl.style;\n\t        var hasRotation = false;\n\t        var m;\n\t        var scaleX = 1;\n\t        var scaleY = 1;\n\t        if (this.transform) {\n\t            m = this.transform;\n\t            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t\n\t            hasRotation = m[1] || m[2];\n\t        }\n\t        if (hasRotation) {\n\t            // If filters are necessary (rotation exists), create them\n\t            // filters are bog-slow, so only create them if abbsolutely necessary\n\t            // The following check doesn't account for skews (which don't exist\n\t            // in the canvas spec (yet) anyway.\n\t            // From excanvas\n\t            var p0 = [x, y];\n\t            var p1 = [x + dw, y];\n\t            var p2 = [x, y + dh];\n\t            var p3 = [x + dw, y + dh];\n\t            applyTransform(p0, p0, m);\n\t            applyTransform(p1, p1, m);\n\t            applyTransform(p2, p2, m);\n\t            applyTransform(p3, p3, m);\n\t\n\t            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n\t            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\t\n\t            var transformFilter = [];\n\t            transformFilter.push('M11=', m[0] / scaleX, comma,\n\t                        'M12=', m[2] / scaleY, comma,\n\t                        'M21=', m[1] / scaleX, comma,\n\t                        'M22=', m[3] / scaleY, comma,\n\t                        'Dx=', round(x * scaleX + m[4]), comma,\n\t                        'Dy=', round(y * scaleY + m[5]));\n\t\n\t            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';\n\t            // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n\t            vmlElStyle.filter = imageTransformPrefix + '.Matrix('\n\t                + transformFilter.join('') + ', SizingMethod=clip)';\n\t\n\t        }\n\t        else {\n\t            if (m) {\n\t                x = x * scaleX + m[4];\n\t                y = y * scaleY + m[5];\n\t            }\n\t            vmlElStyle.filter = '';\n\t            vmlElStyle.left = round(x) + 'px';\n\t            vmlElStyle.top = round(y) + 'px';\n\t        }\n\t\n\t        var imageEl = this._imageEl;\n\t        var cropEl = this._cropEl;\n\t\n\t        if (!imageEl) {\n\t            imageEl = vmlCore.doc.createElement('div');\n\t            this._imageEl = imageEl;\n\t        }\n\t        var imageELStyle = imageEl.style;\n\t        if (hasCrop) {\n\t            // Needs know image original width and height\n\t            if (! (ow && oh)) {\n\t                var tmpImage = new Image();\n\t                var self = this;\n\t                tmpImage.onload = function () {\n\t                    tmpImage.onload = null;\n\t                    ow = tmpImage.width;\n\t                    oh = tmpImage.height;\n\t                    // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\t                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\t\n\t                    // Caching image original width, height and src\n\t                    self._imageWidth = ow;\n\t                    self._imageHeight = oh;\n\t                    self._imageSrc = image;\n\t                };\n\t                tmpImage.src = image;\n\t            }\n\t            else {\n\t                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\t            }\n\t\n\t            if (! cropEl) {\n\t                cropEl = vmlCore.doc.createElement('div');\n\t                cropEl.style.overflow = 'hidden';\n\t                this._cropEl = cropEl;\n\t            }\n\t            var cropElStyle = cropEl.style;\n\t            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n\t            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n\t            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='\n\t                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';\n\t\n\t            if (! cropEl.parentNode) {\n\t                vmlEl.appendChild(cropEl);\n\t            }\n\t            if (imageEl.parentNode != cropEl) {\n\t                cropEl.appendChild(imageEl);\n\t            }\n\t        }\n\t        else {\n\t            imageELStyle.width = round(scaleX * dw) + 'px';\n\t            imageELStyle.height = round(scaleY * dh) + 'px';\n\t\n\t            vmlEl.appendChild(imageEl);\n\t\n\t            if (cropEl && cropEl.parentNode) {\n\t                vmlEl.removeChild(cropEl);\n\t                this._cropEl = null;\n\t            }\n\t        }\n\t\n\t        var filterStr = '';\n\t        var alpha = style.opacity;\n\t        if (alpha < 1) {\n\t            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n\t        }\n\t        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\t\n\t        imageELStyle.filter = filterStr;\n\t\n\t        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Append to root\n\t        append(vmlRoot, vmlEl);\n\t\n\t        // Text\n\t        if (style.text != null) {\n\t            this.drawRectText(vmlRoot, this.getBoundingRect());\n\t        }\n\t    };\n\t\n\t    ZImage.prototype.onRemove = function (vmlRoot) {\n\t        remove(vmlRoot, this._vmlEl);\n\t\n\t        this._vmlEl = null;\n\t        this._cropEl = null;\n\t        this._imageEl = null;\n\t\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    ZImage.prototype.onAdd = function (vmlRoot) {\n\t        append(vmlRoot, this._vmlEl);\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t\n\t\n\t    /***************************************************\n\t     * TEXT\n\t     **************************************************/\n\t\n\t    var DEFAULT_STYLE_NORMAL = 'normal';\n\t\n\t    var fontStyleCache = {};\n\t    var fontStyleCacheCount = 0;\n\t    var MAX_FONT_CACHE_SIZE = 100;\n\t    var fontEl = document.createElement('div');\n\t\n\t    var getFontStyle = function (fontString) {\n\t        var fontStyle = fontStyleCache[fontString];\n\t        if (!fontStyle) {\n\t            // Clear cache\n\t            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n\t                fontStyleCacheCount = 0;\n\t                fontStyleCache = {};\n\t            }\n\t\n\t            var style = fontEl.style;\n\t            var fontFamily;\n\t            try {\n\t                style.font = fontString;\n\t                fontFamily = style.fontFamily.split(',')[0];\n\t            }\n\t            catch (e) {\n\t            }\n\t\n\t            fontStyle = {\n\t                style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n\t                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n\t                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n\t                size: parseFloat(style.fontSize || 12) | 0,\n\t                family: fontFamily || 'Microsoft YaHei'\n\t            };\n\t\n\t            fontStyleCache[fontString] = fontStyle;\n\t            fontStyleCacheCount++;\n\t        }\n\t        return fontStyle;\n\t    };\n\t\n\t    var textMeasureEl;\n\t    // Overwrite measure text method\n\t    textContain.measureText = function (text, textFont) {\n\t        var doc = vmlCore.doc;\n\t        if (!textMeasureEl) {\n\t            textMeasureEl = doc.createElement('div');\n\t            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'\n\t                + 'padding:0;margin:0;border:none;white-space:pre;';\n\t            vmlCore.doc.body.appendChild(textMeasureEl);\n\t        }\n\t\n\t        try {\n\t            textMeasureEl.style.font = textFont;\n\t        } catch (ex) {\n\t            // Ignore failures to set to invalid font.\n\t        }\n\t        textMeasureEl.innerHTML = '';\n\t        // Don't use innerHTML or innerText because they allow markup/whitespace.\n\t        textMeasureEl.appendChild(doc.createTextNode(text));\n\t        return {\n\t            width: textMeasureEl.offsetWidth\n\t        };\n\t    };\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\t\n\t        var style = this.style;\n\t        var text = style.text;\n\t        // Convert to string\n\t        text != null && (text += '');\n\t        if (!text) {\n\t            return;\n\t        }\n\t\n\t        var x;\n\t        var y;\n\t        var align = style.textAlign;\n\t        var fontStyle = getFontStyle(style.textFont);\n\t        // FIXME encodeHtmlAttribute ?\n\t        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '\n\t            + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\t\n\t        var baseline = style.textBaseline;\n\t        var verticalAlign = style.textVerticalAlign;\n\t\n\t        textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t\n\t        // Transform rect to view space\n\t        var m = this.transform;\n\t        // Ignore transform for text in other element\n\t        if (m && !fromTextEl) {\n\t            tmpRect.copy(rect);\n\t            tmpRect.applyTransform(m);\n\t            rect = tmpRect;\n\t        }\n\t\n\t        if (!fromTextEl) {\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t            }\n\t            else {\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, textRect, distance\n\t                );\n\t                x = res.x;\n\t                y = res.y;\n\t\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t        }\n\t        else {\n\t            x = rect.x;\n\t            y = rect.y;\n\t        }\n\t        if (verticalAlign) {\n\t            switch (verticalAlign) {\n\t                case 'middle':\n\t                    y -= textRect.height / 2;\n\t                    break;\n\t                case 'bottom':\n\t                    y -= textRect.height;\n\t                    break;\n\t                // 'top'\n\t            }\n\t            // Ignore baseline\n\t            baseline = 'top';\n\t        }\n\t\n\t        var fontSize = fontStyle.size;\n\t        // 1.75 is an arbitrary number, as there is no info about the text baseline\n\t        switch (baseline) {\n\t            case 'hanging':\n\t            case 'top':\n\t                y += fontSize / 1.75;\n\t                break;\n\t            case 'middle':\n\t                break;\n\t            default:\n\t            // case null:\n\t            // case 'alphabetic':\n\t            // case 'ideographic':\n\t            // case 'bottom':\n\t                y -= fontSize / 2.25;\n\t                break;\n\t        }\n\t        switch (align) {\n\t            case 'left':\n\t                break;\n\t            case 'center':\n\t                x -= textRect.width / 2;\n\t                break;\n\t            case 'right':\n\t                x -= textRect.width;\n\t                break;\n\t            // case 'end':\n\t                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n\t                // break;\n\t            // case 'start':\n\t                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n\t                // break;\n\t            // default:\n\t            //     align = 'left';\n\t        }\n\t\n\t        var createNode = vmlCore.createNode;\n\t\n\t        var textVmlEl = this._textVmlEl;\n\t        var pathEl;\n\t        var textPathEl;\n\t        var skewEl;\n\t        if (!textVmlEl) {\n\t            textVmlEl = createNode('line');\n\t            pathEl = createNode('path');\n\t            textPathEl = createNode('textpath');\n\t            skewEl = createNode('skew');\n\t\n\t            // FIXME Why here is not cammel case\n\t            // Align 'center' seems wrong\n\t            textPathEl.style['v-text-align'] = 'left';\n\t\n\t            initRootElStyle(textVmlEl);\n\t\n\t            pathEl.textpathok = true;\n\t            textPathEl.on = true;\n\t\n\t            textVmlEl.from = '0 0';\n\t            textVmlEl.to = '1000 0.05';\n\t\n\t            append(textVmlEl, skewEl);\n\t            append(textVmlEl, pathEl);\n\t            append(textVmlEl, textPathEl);\n\t\n\t            this._textVmlEl = textVmlEl;\n\t        }\n\t        else {\n\t            // 这里是在前面 appendChild 保证顺序的前提下\n\t            skewEl = textVmlEl.firstChild;\n\t            pathEl = skewEl.nextSibling;\n\t            textPathEl = pathEl.nextSibling;\n\t        }\n\t\n\t        var coords = [x, y];\n\t        var textVmlElStyle = textVmlEl.style;\n\t        // Ignore transform for text in other element\n\t        if (m && fromTextEl) {\n\t            applyTransform(coords, coords, m);\n\t\n\t            skewEl.on = true;\n\t\n\t            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +\n\t            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';\n\t\n\t            // Text position\n\t            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);\n\t            // Left top point as origin\n\t            skewEl.origin = '0 0';\n\t\n\t            textVmlElStyle.left = '0px';\n\t            textVmlElStyle.top = '0px';\n\t        }\n\t        else {\n\t            skewEl.on = false;\n\t            textVmlElStyle.left = round(x) + 'px';\n\t            textVmlElStyle.top = round(y) + 'px';\n\t        }\n\t\n\t        textPathEl.string = encodeHtmlAttribute(text);\n\t        // TODO\n\t        try {\n\t            textPathEl.style.font = font;\n\t        }\n\t        // Error font format\n\t        catch (e) {}\n\t\n\t        updateFillAndStroke(textVmlEl, 'fill', {\n\t            fill: fromTextEl ? style.fill : style.textFill,\n\t            opacity: style.opacity\n\t        }, this);\n\t        updateFillAndStroke(textVmlEl, 'stroke', {\n\t            stroke: fromTextEl ? style.stroke : style.textStroke,\n\t            opacity: style.opacity,\n\t            lineDash: style.lineDash\n\t        }, this);\n\t\n\t        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Attached to root\n\t        append(vmlRoot, textVmlEl);\n\t    };\n\t\n\t    var removeRectText = function (vmlRoot) {\n\t        remove(vmlRoot, this._textVmlEl);\n\t        this._textVmlEl = null;\n\t    };\n\t\n\t    var appendRectText = function (vmlRoot) {\n\t        append(vmlRoot, this._textVmlEl);\n\t    };\n\t\n\t    var list = [RectText, Displayable, ZImage, Path, Text];\n\t\n\t    // In case Displayable has been mixed in RectText\n\t    for (var i = 0; i < list.length; i++) {\n\t        var proto = list[i].prototype;\n\t        proto.drawRectText = drawRectText;\n\t        proto.removeRectText = removeRectText;\n\t        proto.appendRectText = appendRectText;\n\t    }\n\t\n\t    Text.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t        if (style.text != null) {\n\t            this.drawRectText(vmlRoot, {\n\t                x: style.x || 0, y: style.y || 0,\n\t                width: 0, height: 0\n\t            }, this.getBoundingRect(), true);\n\t        }\n\t        else {\n\t            this.removeRectText(vmlRoot);\n\t        }\n\t    };\n\t\n\t    Text.prototype.onRemove = function (vmlRoot) {\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    Text.prototype.onAdd = function (vmlRoot) {\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t}\n\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\tif (!__webpack_require__(5).canvasSupported) {\n\t    var urn = 'urn:schemas-microsoft-com:vml';\n\t\n\t    var createNode;\n\t    var win = window;\n\t    var doc = win.document;\n\t\n\t    var vmlInited = false;\n\t\n\t    try {\n\t        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n\t        createNode = function (tagName) {\n\t            return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n\t        };\n\t    }\n\t    catch (e) {\n\t        createNode = function (tagName) {\n\t            return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n\t        };\n\t    }\n\t\n\t    // From raphael\n\t    var initVML = function () {\n\t        if (vmlInited) {\n\t            return;\n\t        }\n\t        vmlInited = true;\n\t\n\t        var styleSheets = doc.styleSheets;\n\t        if (styleSheets.length < 31) {\n\t            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n\t        }\n\t        else {\n\t            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n\t            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n\t        }\n\t    };\n\t\n\t    // Not useing return to avoid error when converting to CommonJS module\n\t    module.exports = {\n\t        doc: doc,\n\t        initVML: initVML,\n\t        createNode: createNode\n\t    };\n\t}\n\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * VML Painter.\n\t *\n\t * @module zrender/vml/Painter\n\t */\n\t\n\t\n\t\n\t    var zrLog = __webpack_require__(22);\n\t    var vmlCore = __webpack_require__(79);\n\t\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/vml/Painter\n\t     */\n\t    function VMLPainter(root, storage) {\n\t\n\t        vmlCore.initVML();\n\t\n\t        this.root = root;\n\t\n\t        this.storage = storage;\n\t\n\t        var vmlViewport = document.createElement('div');\n\t\n\t        var vmlRoot = document.createElement('div');\n\t\n\t        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\t\n\t        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\t\n\t        root.appendChild(vmlViewport);\n\t\n\t        this._vmlRoot = vmlRoot;\n\t        this._vmlViewport = vmlViewport;\n\t\n\t        this.resize();\n\t\n\t        // Modify storage\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t\n\t            oldDelFromMap.call(storage, elId);\n\t\n\t            if (el) {\n\t                el.onRemove && el.onRemove(vmlRoot);\n\t            }\n\t        };\n\t\n\t        storage.addToMap = function (el) {\n\t            // Displayable already has a vml node\n\t            el.onAdd && el.onAdd(vmlRoot);\n\t\n\t            oldAddToMap.call(storage, el);\n\t        };\n\t\n\t        this._firstPaint = true;\n\t    }\n\t\n\t    VMLPainter.prototype = {\n\t\n\t        constructor: VMLPainter,\n\t\n\t        /**\n\t         * @return {HTMLDivElement}\n\t         */\n\t        getViewportRoot: function () {\n\t            return this._vmlViewport;\n\t        },\n\t\n\t        /**\n\t         * 刷新\n\t         */\n\t        refresh: function () {\n\t\n\t            var list = this.storage.getDisplayList(true, true);\n\t\n\t            this._paintList(list);\n\t        },\n\t\n\t        _paintList: function (list) {\n\t            var vmlRoot = this._vmlRoot;\n\t            for (var i = 0; i < list.length; i++) {\n\t                var el = list[i];\n\t                if (el.invisible || el.ignore) {\n\t                    if (!el.__alreadyNotVisible) {\n\t                        el.onRemove(vmlRoot);\n\t                    }\n\t                    // Set as already invisible\n\t                    el.__alreadyNotVisible = true;\n\t                }\n\t                else {\n\t                    if (el.__alreadyNotVisible) {\n\t                        el.onAdd(vmlRoot);\n\t                    }\n\t                    el.__alreadyNotVisible = false;\n\t                    if (el.__dirty) {\n\t                        el.beforeBrush && el.beforeBrush();\n\t                        (el.brushVML || el.brush).call(el, vmlRoot);\n\t                        el.afterBrush && el.afterBrush();\n\t                    }\n\t                }\n\t                el.__dirty = false;\n\t            }\n\t\n\t            if (this._firstPaint) {\n\t                // Detached from document at first time\n\t                // to avoid page refreshing too many times\n\t\n\t                // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n\t                this._vmlViewport.appendChild(vmlRoot);\n\t                this._firstPaint = false;\n\t            }\n\t        },\n\t\n\t        resize: function (width, height) {\n\t            var width = width == null ? this._getWidth() : width;\n\t            var height = height == null ? this._getHeight() : height;\n\t\n\t            if (this._width != width || this._height != height) {\n\t                this._width = width;\n\t                this._height = height;\n\t\n\t                var vmlViewportStyle = this._vmlViewport.style;\n\t                vmlViewportStyle.width = width + 'px';\n\t                vmlViewportStyle.height = height + 'px';\n\t            }\n\t        },\n\t\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t\n\t            this._vmlRoot =\n\t            this._vmlViewport =\n\t            this.storage = null;\n\t        },\n\t\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t\n\t        clear: function () {\n\t            if (this._vmlViewport) {\n\t                this.root.removeChild(this._vmlViewport);\n\t            }\n\t        },\n\t\n\t        _getWidth: function () {\n\t            var root = this.root;\n\t            var stl = root.currentStyle;\n\t\n\t            return ((root.clientWidth || parseInt10(stl.width))\n\t                    - parseInt10(stl.paddingLeft)\n\t                    - parseInt10(stl.paddingRight)) | 0;\n\t        },\n\t\n\t        _getHeight: function () {\n\t            var root = this.root;\n\t            var stl = root.currentStyle;\n\t\n\t            return ((root.clientHeight || parseInt10(stl.height))\n\t                    - parseInt10(stl.paddingTop)\n\t                    - parseInt10(stl.paddingBottom)) | 0;\n\t        }\n\t    };\n\t\n\t    // Not supported methods\n\t    function createMethodNotSupport(method) {\n\t        return function () {\n\t            zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n\t        };\n\t    }\n\t\n\t    var notSupportedMethods = [\n\t        'getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers',\n\t        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'\n\t    ];\n\t\n\t    for (var i = 0; i < notSupportedMethods.length; i++) {\n\t        var name = notSupportedMethods[i];\n\t        VMLPainter.prototype[name] = createMethodNotSupport(name);\n\t    }\n\t\n\t    module.exports = VMLPainter;\n\n\n/***/ }\n/******/ ])\n});\n;\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d999bf11626ecda66fa4\n **/","/**\r\n * Export fishTopo as CommonJS module\r\n */\r\nmodule.exports = require('./lib/fish-topo-bo/lib/FishTopoBo.js');\r\n//兼容IE8 引入VML 如果不需要兼容IE8请删除\r\nrequire('zrender/lib/vml/vml');\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.bo.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\r\n * Created by majianan on 16/5/19.\r\n *\r\n */\r\n\r\n    var zr = require('zrender/lib/zrender');\r\n    var util = require('zrender/lib/core/util');\r\n    var BoNode = require('./node/BoNode');\r\n    var Relation = require('./node/Relation');\r\n    var Const = require('./models/Const');\r\n    var graphic = require(\"../../fish-topo-core/lib/graphic.js\");\r\n    var eventTool = require('zrender/lib/core/event');\r\n\r\n    function FishTopoBo(dom, opts) {\r\n        /**\r\n         * 缩放\r\n         * @type {number}\r\n         */\r\n        this.nowZoom = 1;\r\n        this.canScale = true;\r\n\r\n        /**\r\n         * 初始化zrender\r\n         */\r\n        this._zr = zr.init(dom, {\r\n            renderer: opts.renderer || 'canvas',\r\n            devicePixelRatio: opts.devicePixelRatio\r\n        });\r\n    }\r\n\r\n    var fishTopoProto = FishTopoBo.prototype;\r\n\r\n    /**\r\n     * 初始化\r\n     */\r\n    fishTopoProto.init = function () {\r\n        this.group = new graphic.Group();\r\n        this.groupDrag(this.group);\r\n        this._zr.add(this.group);\r\n        this.zrScale();\r\n    };\r\n\r\n    /**\r\n     * 调整尺寸  在窗口大小发生改变时需要手工调用\r\n     */\r\n    fishTopoProto.resize = function () {\r\n        this._zr.resize();\r\n    };\r\n\r\n    /**\r\n     * 添加BO\r\n     * @param {Object} boData, bo数据\r\n     * @param {{\r\n     *          startPos: {x: number, y: number} 起始位置,\r\n     *          displayAttrDataType: boolean 是否显示属性数据类型,\r\n     *          displayAttrEvent: boolean 是否显示属性事件决策,\r\n     *          boClickable: boolean BO是否支持点击事件, 可空 默认false\r\n     *          boPopupUrl: String 点击BO弹出页面地址\r\n     *          boEventClickable: boolean BO事件决策是否支持点击事件, 可空 默认false\r\n     *          boEventPopupUrl: String 点击BO事件决策弹出页面地址\r\n     *          attrEventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false\r\n     *          attrEventPopupUrl: String 点击BO属性事件决策弹出页面地址\r\n     *          isCurrent: boolean 是否为当前BO\r\n     *          }} opts\r\n     * @returns {*}\r\n     */\r\n    fishTopoProto.addBo = function (boData, opts) {\r\n        //设置BO父子关系，便于后续整体移动\r\n        this._setParent(boData);\r\n\r\n        //layout BO的布局信息，x,y左上角起始坐标, level:层级\r\n        boData.layout = {\r\n            x: opts.startPos.x,\r\n            y: opts.startPos.y,\r\n            level: 1\r\n        };\r\n\r\n        //计算BO的X坐标\r\n        this._bfs(boData);\r\n\r\n        //按照起始坐标整体左移\r\n        this._moveRightByParent(boData, opts.startPos.x - boData.layout.x);\r\n\r\n        //画BO\r\n        var boNode = new BoNode(boData, opts);\r\n        this.group.add(boNode.getShape());\r\n\r\n        //创建子BO\r\n        this.addChildBo(boNode, opts);\r\n\r\n        return boNode;\r\n    };\r\n\r\n    /**\r\n     * 设置BO的父子关系\r\n     * @param {Object} boData BO数据\r\n     * @private\r\n     */\r\n    fishTopoProto._setParent = function (boData) {\r\n        if (boData.child) {\r\n            var childCnt = boData.child.length,\r\n                childBoArr = boData.child;\r\n            for (var i = 0; i < childCnt; i++) {\r\n                childBoArr[i].parent = boData;\r\n                if (childBoArr[i + 1]) {\r\n                    childBoArr[i].next = childBoArr[i + 1];\r\n                }\r\n                //设置最后子节点的next=下一个父节点的第一个子节点\r\n                else if (boData.next && boData.next.child) {\r\n                    childBoArr[i].next = boData.next.child[0];\r\n                }\r\n                this._setParent(childBoArr[i]);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * Breadth-First-Search 计算X坐标\r\n     * 由于BO宽度定死，可以在画图之前计算每个BO的起始X坐标\r\n     * 每个BO的高度根据显示内容不固定，因此需要根据实际的父BO高度才能计算本身的起始Y坐标\r\n     * @param boData\r\n     * @private\r\n     */\r\n    fishTopoProto._bfs = function (boData) {\r\n        //用于保存每个level的最大坐标值\r\n        this._levelMaxPos = {};\r\n\r\n        this._queue = [];   //存放BO数据\r\n        this._queue.push(boData);\r\n\r\n        while (this._queue.length > 0) {\r\n            var tmp = this._queue.shift();\r\n            //console.log('BO[' + tmp.name + '] {x: ' + tmp.layout.x + ', level: ' + tmp.layout.level + '} ');\r\n            //console.log('    ***Before this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\r\n            //该level第一个节点\r\n            if (!this._levelMaxPos[tmp.layout.level]) {\r\n                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n            }\r\n            //当前就是最右侧的节点\r\n            else if (this._levelMaxPos[tmp.layout.level].x + Const.BO_NODE_WIDTH <= tmp.layout.x) {\r\n                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n            }\r\n            //当前节点与之前的节点有交叉，则需要连同父节点整体向右移动\r\n            else {\r\n                this._moveRightByChild(tmp, this._levelMaxPos[tmp.layout.level].x - tmp.layout.x + Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X)\r\n                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n            }\r\n\r\n            //console.log('    ***After this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\r\n            //存在子节点，计算子节点坐标，同时添加到队列中，以便后续计算调整x坐标\r\n            if (tmp.child) {\r\n                var childCnt = tmp.child.length;\r\n\r\n                for (var i = 0; i < childCnt; i++) {\r\n\r\n                    tmp.child[i].layout = {\r\n                        x: tmp.layout.x - (Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X) * ((childCnt - 1) / 2 - i),\r\n                        level: tmp.layout.level + 1\r\n                    };\r\n\r\n                    this._queue.push(tmp.child[i]);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 子节点右移时，同时下一个子节点，以及父节点都同时移动\r\n     * @param boData\r\n     * @param width\r\n     * @private\r\n     */\r\n    fishTopoProto._moveRightByChild = function (boData, width) {\r\n        if (boData) {\r\n\r\n            if (!boData.layout.moved) {\r\n\r\n                if (boData.layout.level == 1) {\r\n                    boData.layout.x += width / 2;\r\n                } else {\r\n                    boData.layout.x += width;\r\n                }\r\n\r\n                boData.layout.moved = true;\r\n            }\r\n            //当前节点的下一节点整体右移\r\n            this._moveRightByPrevious(boData.next, width);\r\n            //当前节点的父节点整体右移\r\n            this._moveRightByChild(boData.parent, width);\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 前一个节点右移的时候，所有后面的节点整体右移\r\n     * @param boData\r\n     * @param width\r\n     * @private\r\n     */\r\n    fishTopoProto._moveRightByPrevious = function (boData, width) {\r\n        if (boData) {\r\n            boData.layout.x += width;\r\n            //当前节点的所有后续节点整体右移\r\n            this._moveRightByPrevious(boData.next, width);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 父节点右移时，所有子节点整体右移\r\n     * @param boData\r\n     * @param width\r\n     * @private\r\n     */\r\n    fishTopoProto._moveRightByParent = function (boData, width) {\r\n        if (boData) {\r\n            boData.layout.x += width;\r\n            if (boData.child) {\r\n                for (var i = 0; i < boData.child.length; i++) {\r\n                    this._moveRightByParent(boData.child[i], width);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 添加子BO\r\n     * @param {BoNode} parentBoNode\r\n     * @param {Object} opts\r\n     * @private\r\n     */\r\n    fishTopoProto.addChildBo = function (parentBoNode, opts) {\r\n\r\n        this._queue = []; //需要根据BO节点的实际高度计算自己点的起始Y坐标，因此存放的是BoNode图形\r\n        this._queue.push(parentBoNode);\r\n\r\n        while (this._queue.length > 0) {\r\n            var tmp = this._queue.shift(),\r\n                boNodeHeight = tmp.getShape().getBoundingRect().height;\r\n            //console.log('Parent BO[' + tmp.getData().name + '] {y: ' + tmp.getLayout().y + ', level: ' + tmp.getLayout().level + ', boNodeHeight:' + boNodeHeight + '} ');\r\n            //console.log('    ***Before this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\r\n            //如果是该Level第一个节点，或者当低于原来的节点\r\n            if (!this._levelMaxPos[tmp.getLayout().level].y ||\r\n                this._levelMaxPos[tmp.getLayout().level].y < tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y) {\r\n                this._levelMaxPos[tmp.getLayout().level].y = tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y;\r\n            }\r\n\r\n            //console.log('    ***After this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\r\n            if (tmp.getData().child) {\r\n\r\n                var childBoArr = tmp.getData().child,\r\n                    childCnt = childBoArr.length,\r\n                    boNode,\r\n                    relationNode;\r\n\r\n                //该level所有子节点的起始Y坐标都相同\r\n                opts.startPos.y = this._levelMaxPos[tmp.getLayout().level].y;\r\n                for (var i = 0; i < childCnt; i++) {\r\n                    opts.startPos.x = childBoArr[i].layout.x;\r\n                    childBoArr[i].layout.y = opts.startPos.y;\r\n                    boNode = new BoNode(childBoArr[i], opts);\r\n                    //console.log('Child BO[' + boNode.getData().name + '] {y: ' + opts.startPos.y + ', level: ' + boNode.getLayout().level + '} ');\r\n\r\n                    this.group.add(boNode.getShape());\r\n                    this._queue.push(boNode);\r\n\r\n                    //BO关系\r\n                    if (childBoArr[i].relation) {\r\n                        var _relationLen = childBoArr[i].relation.length;\r\n                        for (var j = 0; j < _relationLen; j++) {\r\n                            var sourceId = childBoArr[i].relation[j].sourceId,\r\n                                targetId = childBoArr[i].relation[j].targetId,\r\n                                sourceText = childBoArr[i].relation[j].sourceText,\r\n                                targetText = childBoArr[i].relation[j].targetText;\r\n\r\n                            relationNode = new Relation(\r\n                                boNode.getShape().childOfName(sourceId),\r\n                                tmp.getShape().childOfName(targetId),\r\n                                sourceText,\r\n                                targetText\r\n                            );\r\n                            this.group.add(relationNode.getShape());\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 设置当前BO为特殊样式\r\n     * @param {String} boId, BO标识\r\n     * @param {Object} style, BO特殊样式,可空\r\n     */\r\n    fishTopoProto.setCurrentBo = function (boId, style) {\r\n        var length = this.group.childCount();\r\n        for (var i = 0; i < length; i++) {\r\n            if (this.group.childAt(i).name == boId) {\r\n                this.group.childAt(i).setCurrent(style);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 清空\r\n     */\r\n    fishTopoProto.clear = function () {\r\n        this._zr.clear();\r\n        this.group = new graphic.Group();\r\n        this._zr.add(this.group);\r\n    };\r\n\r\n    /**\r\n     * 缩放功能\r\n     * @param type\r\n     */\r\n    fishTopoProto.zrScale = function (type) {\r\n        var that = this;\r\n        if (type) {\r\n            if (type == \"narrowing\") {\r\n                var zoomDelta = 1 / 1.1;\r\n                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }\r\n            if (type == \"enlarge\") {\r\n                var zoomDelta = 1.1;\r\n                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }\r\n        } else {\r\n            that._zr.on('mousewheel', function (e) {\r\n                eventTool.stop(e.event);\r\n                var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\r\n                zoom(zoomDelta, e.offsetX, e.offsetY);\r\n            });\r\n        }\r\n        ;\r\n        function zoom(zoomDelta, zoomX, zoomY) {\r\n            if (that.canScale == false) {\r\n                return;\r\n            }\r\n            var target = that.group;\r\n            if (target) {\r\n                var pos = target.position;\r\n                var scale = target.scale;\r\n                var newZoom = that._zoom = that._zoom || 1;\r\n                newZoom *= zoomDelta;\r\n                var zoomScale = newZoom / that._zoom;\r\n                // if(newZoom>2.6||newZoom<0.38){\r\n                //     return;\r\n                // };\r\n                that._zoom = newZoom;\r\n\r\n                that.nowZoom = newZoom;\r\n                // Keep the mouse center when scaling\r\n                pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\r\n                pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\r\n                scale[0] *= zoomScale;\r\n                scale[1] *= zoomScale;\r\n                target.attr(\"position\", [pos[0], pos[1]]);\r\n                target.attr(\"scale\", [scale[0], scale[1]]);\r\n                //that.minimap.updateSelectionPosition(pos,zoomScale);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 拖拽Group\r\n     */\r\n    fishTopoProto.groupDrag = function () {\r\n        var that = this;\r\n        that._zr.on(\"mousedown\", function (e) {\r\n            groupDragFunction(e);\r\n            e.cancelBubble = true;\r\n        });\r\n        function groupDragFunction(e) {\r\n            var startX = e.event.clientX;\r\n            var startY = e.event.clientY;\r\n            var moveFunction = function (e) {\r\n                moveDrag(e);\r\n            }\r\n            var nowGroupPosition = that.group.position;\r\n            var groupPositionX = that.group.position[0];\r\n            var groupPositionY = that.group.position[1];\r\n            var alarmPositionX, alarmPositionY;\r\n\r\n            function moveDrag(e) {\r\n                var width = that.group.getBoundingRect().width * that.nowZoom;\r\n                var height = that.group.getBoundingRect().height * that.nowZoom;\r\n                var gx = that.group.getBoundingRect().x * that.nowZoom;\r\n                var gy = that.group.getBoundingRect().y * that.nowZoom;\r\n                var min = [10 - (width + gx), 10 - (height + gy)];\r\n                var max = [(that._zr.getWidth() - gx) - 10, (that._zr.getHeight() - gy) - 10];\r\n                var sX = (e.event.clientX - startX) * (that.nowZoom);\r\n                var sY = (e.event.clientY - startY) * (that.nowZoom);\r\n                nowGroupPosition[0] = groupPositionX + (sX);\r\n                nowGroupPosition[1] = groupPositionY + (sY);\r\n                if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] < min[0] || nowGroupPosition[1] < min[1]) {\r\n                    return;\r\n                } else {\r\n                    that.group.attr(\"position\", nowGroupPosition);\r\n                }\r\n            }\r\n\r\n            that._zr.on('mousemove', moveFunction);\r\n            var upFunction = function (e) {\r\n                endDrag(e);\r\n            }\r\n\r\n            function endDrag(e) {\r\n                that._zr.off('mousemove', moveFunction);\r\n                that._zr.off('mouseup', upFunction);\r\n                that._zr.off(\"globalout\", upFunction);\r\n            }\r\n\r\n            that._zr.on('mouseup', upFunction);\r\n            that._zr.on(\"globalout\", upFunction);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 拖拽\r\n     * @param node\r\n     */\r\n    fishTopoProto.drag = function (node) {\r\n        var that = this;\r\n        node.on(\"mousedown\", function (e) {\r\n            if (this.isdraggable == false) {\r\n                return;\r\n            }\r\n            groupDragFunction(e);\r\n            e.cancelBubble = true;\r\n        });\r\n        function groupDragFunction(e) {\r\n            var startX = e.event.clientX;\r\n            var startY = e.event.clientY;\r\n            var moveFunction = function (e) {\r\n                moveDrag(e);\r\n            }\r\n            var nowGroupPosition = node.position;\r\n            var groupPositionX = node.position[0];\r\n            var groupPositionY = node.position[1];\r\n            var alarmPositionX, alarmPositionY;\r\n            if (node.alarm) {\r\n                var newAlarmPosition = node.alarm.position;\r\n                alarmPositionX = node.alarm.position[0];\r\n                alarmPositionY = node.alarm.position[1];\r\n            }\r\n            ;\r\n            function moveDrag(e) {\r\n                var sX = (e.event.clientX - startX) / (that.nowZoom);\r\n                var sY = (e.event.clientY - startY) / (that.nowZoom);\r\n                if (node.parent && node.parent instanceof GroupNode) {\r\n                    //放入node现有数值，用于重绘group\r\n                    var nodeMessage = {\r\n                        width: node.shape.width,\r\n                        height: node.shape.height,\r\n                        position: node.position,\r\n                        nodeXY: [node.shape.x, node.shape.y],\r\n                        movePosition: [groupPositionX, groupPositionY],\r\n                        moveX: sX,\r\n                        moveY: sY\r\n                    };\r\n                    var groupNode = node.parent;\r\n                    groupNode.reDraw(nodeMessage, node);\r\n                } else {\r\n                    nowGroupPosition[0] = groupPositionX + (sX);\r\n                    nowGroupPosition[1] = groupPositionY + (sY);\r\n                    node.attr(\"position\", nowGroupPosition);\r\n                    if (node.alarm) {\r\n                        var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm.getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect().height - 3];\r\n                        node.alarm.attr(\"position\", newAlarmPosition);\r\n                    }\r\n                    ;\r\n                }\r\n                ConnectionManager.refreshLineByNode(node);\r\n            }\r\n\r\n            that._zr.on('mousemove', moveFunction);\r\n            var upFunction = function (e) {\r\n                endDrag(e);\r\n            }\r\n            //拖拽结束\r\n            function endDrag(e) {\r\n                that._zr.off('mousemove', moveFunction);\r\n                that._zr.off('mouseup', upFunction);\r\n                that._zr.off(\"globalout\", upFunction);\r\n                //布局重新计算\r\n                if (node.layout) {\r\n                    that.layoutNode(\"tree\", {\"node\": node});\r\n                }\r\n                if (that.forceLayoutOption) {\r\n                    var nodes = that.forceLayoutOption.allNodes;\r\n                    if (_.indexOf(nodes, node) != -1) {\r\n                        that.layoutNode(\"force\", this.forceLayoutOption);\r\n                    }\r\n                }\r\n                ;\r\n            }\r\n\r\n            that._zr.on('mouseup', upFunction);\r\n            that._zr.on(\"globalout\", upFunction);\r\n        }\r\n    };\r\n\r\n\r\n    // ---------对外暴露fishTopoBo------------------\r\n    var idBase = new Date() - 0;\r\n    var instances = {};\r\n    var DOM_ATTRIBUTE_KEY = '_fishTopoBo_instance_';\r\n    var fishTopoBo = {\r\n        /**\r\n         * @type {number}\r\n         */\r\n        version: '1.0.0',\r\n        dependencies: {\r\n            zrender: '3.0.4'\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @param {HTMLDomElement} dom\r\n     * @param {Object} opts\r\n     */\r\n    fishTopoBo.init = function (dom, opts) {\r\n        if (!dom) {\r\n            throw new Error('Initialize failed: invalid dom.');\r\n        }\r\n\r\n        opts = opts || {};\r\n        // Default value\r\n        util.defaults(opts,\r\n            {\r\n                type: \"bpmn\",\r\n                showGridLine: true,\r\n                devicePixelRatio: 1,\r\n                gridLineSpacing:10\r\n            }\r\n        );\r\n\r\n        var fishTopoBo = new FishTopoBo(dom, opts);\r\n        fishTopoBo.init();\r\n\r\n        fishTopoBo.id = 'ft_' + idBase++;\r\n        instances[fishTopoBo.id] = fishTopoBo;\r\n\r\n        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoBo.id);\r\n\r\n        return fishTopoBo;\r\n    };\r\n\r\n\r\n    /**\r\n     * @param  {HTMLDomElement} dom\r\n     * @return {fishTopo}\r\n     */\r\n    fishTopoBo.getInstanceByDom = function (dom) {\r\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n        return instances[key];\r\n    };\r\n\r\n    /**\r\n     * Dispose a fishTopo instance\r\n     * @param  {module:fishTopo|HTMLDomElement|string} fishTopo\r\n     */\r\n    fishTopoBo.dispose = function (chart) {\r\n        var topo;\r\n        if (zrUtil.isDom(chart)) {\r\n            topo = fishTopoBo.getInstanceByDom(chart);\r\n        }\r\n        else if (typeof chart === 'string') {\r\n            topo = instances[chart];\r\n        }\r\n        if ((topo instanceof fishTopoBo) && !topo.isDisposed()) {\r\n            topo.dispose();\r\n        }\r\n    };\r\n\r\n    module.exports = fishTopoBo;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/FishTopoBo.js\n ** module id = 2\n ** module chunks = 0\n **/","/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n    var zrUtil = require('./core/util');\n\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: require('./Painter')\n    };\n\n    var instances = {};    // ZRender实例map索引\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.4.1';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        // TODO WebGL\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        // 修改 storage.delFromMap, 每次删除元素之前删除动画\n        // FIXME 有点ugly\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToMap = function (el) {\n            oldAddToMap.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * 获取实例唯一标识\n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * 添加元素\n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * 删除元素\n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, dpr) {\n            return this.painter.pathToImage(e, dpr);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default'] 例如 crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/zrender.js\n ** module id = 3\n ** module chunks = 0\n **/","/**\n * zrender: 生成唯一id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/guid.js\n ** module id = 4\n ** module chunks = 0\n **/","/**\n * echarts设备环境识别\n *\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // 原生canvas支持，改极端点了\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n                // events currently. So we dont use that on other browsers unless tested sufficiently.\n                // Although IE 10 supports pointer event, it use old style and is different from the\n                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n                && (browser.edge || (browser.ie && browser.version >= 11))\n        };\n    }\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/env.js\n ** module id = 5\n ** module chunks = 0\n **/","/**\n * @module zrender/core/util\n */\n\n\n    // 用于处理merge时无法遍历Date等对象的问题\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuiltInObject(sourceProp)\n                    && !isBuiltInObject(targetProp)\n                    && !isPrimitive(sourceProp)\n                    && !isPrimitive(targetProp)\n                ) {\n                    // 如果需要递归覆盖，就递归调用merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * 查询数组中元素的index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * 构造类继承关系\n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz 源类\n     * @param {Function} baseClazz 基类\n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * 数组或对象遍历\n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * 数组映射\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * 数组过滤\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * 数组项查找\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuiltInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * Whether is exactly NaN. Notice isNaN('a') returns true.\n     * @param {*} value\n     * @return {boolean}\n     */\n    function eqNaN(value) {\n        return value !== value;\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var primitiveKey = '__ec_primitive__';\n    /**\n     * Set an object as primitive to be ignored traversing children in clone or merge\n     */\n    function setAsPrimitive(obj) {\n        obj[primitiveKey] = true;\n    }\n\n    function isPrimitive(obj) {\n        return obj[primitiveKey];\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuiltInObject: isBuiltInObject,\n        isDom: isDom,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        assert: assert,\n        setAsPrimitive: setAsPrimitive,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/util.js\n ** module id = 6\n ** module chunks = 0\n **/","'use strict';\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n\n    var Eventful = require('./mixin/Eventful');\n\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n            var proxy = this.proxy;\n\n            this._hovered = hovered;\n\n            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = null;\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * 设置默认的cursor style\n         * @param {string} [cursorStyle='default'] 例如 crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * 事件分发代理\n         *\n         * @private\n         * @param {Object} targetEl 目标图形元素\n         * @param {string} eventName 事件名称\n         * @param {Object} event 事件对象\n         */\n        dispatchToElement: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\n            var el = targetEl;\n\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                // 冒泡到顶级 zrender 对象\n                this.trigger(eventName, eventPacket);\n                // 分发事件到用户自定义层\n                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                if (!list[i].silent\n                 && list[i] !== exclude\n                 // getDisplayList may include ignored item in VML mode\n                 && !list[i].ignore\n                 && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n\n            if (name === 'mousedown') {\n                this._downel = hovered;\n                // In case click triggered before mouseup\n                this._upel = hovered;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hovered;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            while (el) {\n                // If ancestor is silent or clipped by ancestor\n                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n                    return false;\n                }\n                el = el.parent;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Handler.js\n ** module id = 7\n ** module chunks = 0\n **/","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    module.exports = Draggable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Draggable.js\n ** module id = 8\n ** module chunks = 0\n **/","/**\n * 事件扩展\n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * 事件分发器\n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * 单次触发绑定，trigger后销毁\n         *\n         * @param {string} event 事件名\n         * @param {Function} handler 响应函数\n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 绑定事件\n         * @param {string} event 事件名\n         * @param {Function} handler 事件处理函数\n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 是否绑定了事件\n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * 解绑事件\n         * @param {string} event 事件名\n         * @param {Function} [handler] 事件处理函数\n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * 事件分发\n         *\n         * @param {string} type 事件类型\n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * 带有context的事件分发, 最后一个参数是事件回调的context\n         * @param {string} type 事件类型\n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    // 对象可以通过 onxxxx 绑定事件\n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Eventful.js\n ** module id = 9\n ** module chunks = 0\n **/","'use strict';\n/**\n * Storage内容仓库模块\n * @module zrender/Storage\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = require('./core/util');\n    var env = require('./core/env');\n\n    var Group = require('./container/Group');\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     * 内容仓库 (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        // 所有常规形状，id索引的map\n        this._elements = {};\n\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * 返回所有图形的绘制队列\n         * @param {boolean} [update=false] 是否在返回前更新该数组\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n         *\n         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * 更新图形的绘制队列。\n         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var userSetClipPath = el.clipPath;\n            if (userSetClipPath) {\n\n                // FIXME 效率影响\n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                // Recursively add clip path\n                while (currentClipPath) {\n                    // clipPath 的变换是基于使用这个 clipPath 的元素\n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n\n                    clipPaths.push(currentClipPath);\n\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.clipPath;\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * 添加图形(Shape)或者组(Group)到根节点\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            // Element has been added\n            if (this._elements[el.id]) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToMap(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * 删除指定的图形(Shape)或者组(Group)\n         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage\n         */\n        delRoot: function (elId) {\n            if (elId == null) {\n                // 不指定elId清空\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._elements = {};\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (elId instanceof Array) {\n                for (var i = 0, l = elId.length; i < l; i++) {\n                    this.delRoot(elId[i]);\n                }\n                return;\n            }\n\n            var el;\n            if (typeof(elId) == 'string') {\n                el = this._elements[elId];\n            }\n            else {\n                el = elId;\n            }\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromMap(el.id);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToMap: function (el) {\n            if (el instanceof Group) {\n                el.__storage = this;\n            }\n            el.dirty(false);\n\n            this._elements[el.id] = el;\n\n            return this;\n        },\n\n        get: function (elId) {\n            return this._elements[elId];\n        },\n\n        delFromMap: function (elId) {\n            var elements = this._elements;\n            var el = elements[elId];\n            if (el) {\n                delete elements[elId];\n                if (el instanceof Group) {\n                    el.__storage = null;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * 清空并且释放Storage\n         */\n        dispose: function () {\n            this._elements =\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Storage.js\n ** module id = 10\n ** module chunks = 0\n **/","/**\n * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * 所有子孙元素是否响应鼠标事件\n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         * 获取指定 index 的儿子节点\n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * 获取指定名字的儿子节点\n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * 添加子节点到最后\n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         * 添加子节点在 nextSibling 之前\n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToMap(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * 移除子节点\n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromMap(child.id);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * 移除所有子节点\n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * 遍历所有子节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * 深度优先遍历所有子孙节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/container/Group.js\n ** module id = 11\n ** module chunks = 0\n **/","'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * 画布元素ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * 元素类型\n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * 元素名字\n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n         * 该路径会继承被裁减对象的变换\n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // 添加动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // 移除动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Element.js\n ** module id = 12\n ** module chunks = 0\n **/","'use strict';\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * 平移\n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * 旋转\n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * 缩放\n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * 旋转和缩放的原点\n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * 判断是否需要有坐标变换\n     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // 应用父节点变换\n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // 保存这个变换矩阵\n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = this.origin;\n\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n    /**\n     * 将自己的transform应用到context上\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n\n    var tmpTransform = [];\n\n    /**\n     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     * 变换坐标位置到 shape 的局部坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * 变换局部坐标位置到全局坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    module.exports = Transformable;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Transformable.js\n ** module id = 13\n ** module chunks = 0\n **/","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2矩阵操作类\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * 创建一个单位矩阵\n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * 设置矩阵为单位矩阵\n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * 复制矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * 矩阵相乘\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * 平移变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * 旋转变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * 缩放变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * 求逆矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/matrix.js\n ** module id = 14\n ** module chunks = 0\n **/","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * 二维向量类\n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * 创建一个向量\n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * 复制向量数据\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 克隆一个向量\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 设置向量的两个项\n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} 结果\n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * 向量相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * 向量缩放后相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * 向量相减\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * 向量长度\n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * 向量长度平方\n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * 向量乘法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * 向量除法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * 向量点乘\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * 向量缩放\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * 向量归一化\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * 计算向量间距离\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * 向量距离平方\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * 求负向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * 插值两个点\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * 矩阵左乘向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * 求两个向量最小值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * 求两个向量最大值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/vector.js\n ** module id = 15\n ** module chunks = 0\n **/","'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * 动画\n         *\n         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\n         * @param {boolean} [loop] 动画是否循环\n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Animatable.js\n ** module id = 16\n ** module chunks = 0\n **/","/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = (\n                isValueArray\n                && isArrayLike(firstVal[0])\n            )\n            ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * 设置动画关键帧\n         * @param  {number} time 关键帧时间，单位是ms\n         * @param  {Object} props 关键帧的属性值，key-value表示\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * 添加动画每一帧的回调函数\n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        pause: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].pause();\n            }\n            this._paused = true;\n        },\n\n        resume: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].resume();\n            }\n            this._paused = false;\n        },\n\n        isPaused: function () {\n            return !!this._paused;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * 开始执行动画\n         * @param  {string|Function} easing\n         *         动画缓动函数，详见{@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * 设置动画延迟开始的时间\n         * @param  {number} time 单位ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * 添加动画结束的回调\n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/Animator.js\n ** module id = 17\n ** module chunks = 0\n **/","/**\n * 动画主控制器\n * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n * @config life(1000) 动画时长\n * @config delay(0) 动画延迟时间\n * @config loop(true)\n * @config gap(0) 循环的间隔时间\n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = require('./easing');\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // 生命周期\n        this._life = options.life || 1000;\n        // 延时\n        this._delay = options.delay || 0;\n        // 开始时间\n        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n        this._initialized = false;\n\n        // 是否循环\n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n\n        this._pausedTime = 0;\n        this._paused = false;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime, deltaTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            if (this._paused) {\n                this._pausedTime += deltaTime;\n                return;\n            }\n\n            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n\n            // 还没开始\n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // 结束\n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // 重新开始周期\n                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n                    return 'restart';\n                }\n\n                // 动画完成将这个控制器标识为待删除\n                // 在Animation.update中进行批量删除\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._pausedTime = 0;\n\n            this._needsRemove = false;\n        },\n\n        fire: function (eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        },\n\n        pause: function () {\n            this._paused = true;\n        },\n\n        resume: function () {\n            this._paused = false;\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/Clip.js\n ** module id = 18\n ** module chunks = 0\n **/","/**\n * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // 三次方的缓动（t^3）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // 四次方的缓动（t^4）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // 五次方的缓动（t^5）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // 正弦曲线的缓动（sin(t)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 指数曲线的缓动（2^t）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // 圆形曲线的缓动（sqrt(1-t^2)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // 创建类似于弹簧在停止前来回振荡的动画\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // 创建弹跳效果\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/easing.js\n ** module id = 19\n ** module chunks = 0\n **/","/**\n * @module zrender/tool/color\n */\n\n\n    var LRU = require('../core/LRU');\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    function setRgba(out, r, g, b, a) {\n        out[0] = r; out[1] = g; out[2] = b; out[3] = a;\n        return out;\n    }\n    function copyRgba(out, a) {\n        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n        return out;\n    }\n    var colorCache = new LRU(20);\n    var lastRemovedArr = null;\n    function putToCache(colorStr, rgbaArr) {\n        // Reuse removed array\n        if (lastRemovedArr) {\n            copyRgba(lastRemovedArr, rgbaArr);\n        }\n        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n    }\n    /**\n     * @param {string} colorStr\n     * @param {Array.<number>} out\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr, rgbaArr) {\n        if (!colorStr) {\n            return;\n        }\n        rgbaArr = rgbaArr || [];\n\n        var cached = colorCache.get(colorStr);\n        if (cached) {\n            return copyRgba(rgbaArr, cached);\n        }\n\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            copyRgba(rgbaArr, kCSSColorTable[str]);\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    setRgba(rgbaArr,\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    );\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsla':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsl':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                default:\n                    return;\n            }\n        }\n\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla, rgba) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        rgba = rgba || [];\n        setRgba(rgba,\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),\n            1\n        );\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        out = out || [0, 0, 0, 0];\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return out;\n        }\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssFloat(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color. (If input illegal, return undefined).\n     */\n    function stringify(arrColor, type) {\n        if (!arrColor) {\n            return;\n        }\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/tool/color.js\n ** module id = 20\n ** module chunks = 0\n **/","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function () {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function (val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function (entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            entry.next = null;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function (entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function () {\n        return this._len;\n    };\n\n    /**\n     * Clear list\n     */\n    linkedListProto.clear = function () {\n        this.head = this.tail = null;\n        this._len = 0;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function (val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function (maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n\n        this._lastRemovedEntry = null;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     * @return {} Removed value\n     */\n    LRUProto.put = function (key, value) {\n        var list = this._list;\n        var map = this._map;\n        var removed = null;\n        if (map[key] == null) {\n            var len = list.len();\n            // Reuse last removed entry\n            var entry = this._lastRemovedEntry;\n\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n\n                removed = leastUsedEntry.value;\n                this._lastRemovedEntry = leastUsedEntry;\n            }\n\n            if (entry) {\n                entry.value = value;\n            }\n            else {\n                entry = new Entry(value);\n            }\n            entry.key = key;\n            list.insertEntry(entry);\n            map[key] = entry;\n        }\n\n        return removed;\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function (key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function () {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/LRU.js\n ** module id = 21\n ** module chunks = 0\n **/","\n        var config = require('../config');\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/log.js\n ** module id = 22\n ** module chunks = 0\n **/","\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config默认配置项\n     * @exports zrender/config\n     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debug日志选项：catchBrushException为true下有效\n         * 0 : 不生成debug数据，发布用\n         * 1 : 异常抛出，调试用\n         * 2 : 控制台输出，调试用\n         */\n        debugMode: 0,\n\n        // retina 屏幕优化\n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/config.js\n ** module id = 23\n ** module chunks = 0\n **/","'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // 矩阵右乘\n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/BoundingRect.js\n ** module id = 24\n ** module chunks = 0\n **/","// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/timsort.js\n ** module id = 25\n ** module chunks = 0\n **/","'use strict';\n/**\n * 动画主类, 调度和管理所有动画控制器\n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n\n    var requestAnimationFrame = require('./requestAnimationFrame');\n\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         * 添加 clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         * 添加 animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time, delta);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * 开始运行动画\n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * 停止运行动画\n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * 清除所有动画片段\n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] 是否循环播放动画\n         * @param  {Function} [options.getter=null]\n         *         如果指定getter函数，会通过getter函数取属性值\n         * @param  {Function} [options.setter=null]\n         *         如果指定setter函数，会通过setter函数设置属性值\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            this.addAnimator(animator);\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/Animation.js\n ** module id = 26\n ** module chunks = 0\n **/","'use strict';\n/**\n * 事件辅助类\n * @module zrender/core/event\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = require('../mixin/Eventful');\n    var env = require('./env');\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * preventDefault and stopPropagation.\n     * Notice: do not do that in zrender. Upper application\n     * do that if necessary.\n     *\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event对象\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // 做向上兼容\n        Dispatcher: Eventful\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/event.js\n ** module id = 27\n ** module chunks = 0\n **/","\n\n    module.exports = (typeof window !== 'undefined' &&\n                                    (window.requestAnimationFrame\n                                    || window.msRequestAnimationFrame\n                                    || window.mozRequestAnimationFrame\n                                    || window.webkitRequestAnimationFrame))\n                                || function (func) {\n                                    setTimeout(func, 16);\n                                };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/requestAnimationFrame.js\n ** module id = 28\n ** module chunks = 0\n **/","\n\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerEventNames = {\n        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n    };\n\n    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n        var nm = name.replace('mouse', 'pointer');\n        return pointerEventNames[nm] ? nm : name;\n    });\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null),\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        // Do not do any preventDefault here. Upper application do that if necessary.\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n        }\n    }\n\n    // function onMSGestureChange(proxy, event) {\n    //     if (event.translationX || event.translationY) {\n    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n    //     }\n    //     if (event.scale !== 1) {\n    //         event.pinchX = event.offsetX;\n    //         event.pinchY = event.offsetY;\n    //         event.pinchScale = event.scale;\n    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n    //     }\n    // }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // 忽略包含在root中的dom引起的mouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch开始响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered, and must before `mousedown` triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch移动响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch结束响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        },\n\n        pointerdown: function (event) {\n            domHandlers.mousedown.call(this, event);\n\n            // if (useMSGuesture(this, event)) {\n            //     this._msGesture.addPointer(event.pointerId);\n            // }\n        },\n\n        pointermove: function (event) {\n            // FIXME\n            // pointermove is so sensitive that it always triggered when\n            // tap(click) on touch screen, which affect some judgement in\n            // upper application. So, we dont support mousemove on MS touch\n            // device yet.\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mousemove.call(this, event);\n            }\n        },\n\n        pointerup: function (event) {\n            domHandlers.mouseup.call(this, event);\n        },\n\n        pointerout: function (event) {\n            // pointerout will be triggered when tap on touch screen\n            // (IE11+/Edge on MS Surface) after click event triggered,\n            // which is inconsistent with the mousout behavior we defined\n            // in touchend. So we unify them.\n            // (check domHandlers.touchend for detailed explanation)\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n\n    // function useMSGuesture(handlerProxy, event) {\n    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n    // }\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * 为控制类实例初始化dom 事件处理函数\n     *\n     * @inner\n     * @param {module:zrender/Handler} instance 控制类实例\n     */\n    function initDomHandler(instance) {\n        zrUtil.each(touchHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(pointerHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(mouseHandlerNames, function (name) {\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        });\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (env.pointerEventsSupported) { // Only IE11+/Edge\n            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n            // at the same time.\n            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n            // screen, which do not occurs in pointer event.\n            // So we use pointer event to both detect touch gesture and mouse behavior.\n            mountHandlers(pointerHandlerNames, this);\n\n            // FIXME\n            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n            // which does not prevent defuault behavior occasionally (which may cause view port\n            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n            // touch screen. And we only support click behavior on MS touch screen now.\n\n            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n            // We dont support touch on IE on win7.\n            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n            // if (typeof MSGesture === 'function') {\n            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n            // }\n        }\n        else {\n            if (env.touchEventsSupported) {\n                mountHandlers(touchHandlerNames, this);\n                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n            }\n\n            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n            // mouse event can not be handle in those devices.\n            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n            // mouseevent after touch event triggered, see `setTouchTimer`.\n            mountHandlers(mouseHandlerNames, this);\n        }\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/dom/HandlerProxy.js\n ** module id = 29\n ** module chunks = 0\n **/","'use strict';\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = require('./event');\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/GestureMgr.js\n ** module id = 30\n ** module chunks = 0\n **/","'use strict';\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n\n    var Layer = require('./Layer');\n\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.__builtin__) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            var path = clipPath.path;\n\n            clipPath.setTransform(ctx);\n            path.beginPath(ctx);\n            clipPath.buildPath(path, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root 绘图容器\n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * 绘图容器\n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            if (opts.width != null) {\n                root.width = opts.width;\n            }\n            if (opts.height != null) {\n                root.height = opts.height;\n            }\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n\n            this._domRoot = root;\n        }\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._domRoot;\n        },\n\n        /**\n         * 刷新\n         * @param {boolean} [paintAll=false] 强制绘制所有displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.__builtin__ && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuiltinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuiltinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.__builtin__) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.__builtin__ = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            layersMap[zlevel] = layer;\n\n            // Vitual layer will not directly show on the screen.\n            // (It can be a WebGL layer and assigned to a ZImage element)\n            // But it still under management of zrender.\n            if (!layer.virtual) {\n                if (prevLayer) {\n                    var prevDom = prevLayer.dom;\n                    if (prevDom.nextSibling) {\n                        domRoot.insertBefore(\n                            layer.dom,\n                            prevDom.nextSibling\n                        );\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n                else {\n                    if (domRoot.firstChild) {\n                        domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n            }\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuiltinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (!layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * 获取所有已创建的层\n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuiltinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // 层中的元素数量有发生变化\n            this.eachBuiltinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * 清除hover层外所有内容\n         */\n        clear: function () {\n            this.eachBuiltinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * 修改指定zlevel的绘制参数\n         *\n         * @param {string} zlevel\n         * @param {Object} config 配置对象\n         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * 删除指定层\n         * @param {number} zlevel 层所在的zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * 区域大小变化后重绘\n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // 优化没有实际改变的resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * 清除单独的一个层\n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * 释放\n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            return imageLayer.dom;\n        },\n        /**\n         * 获取绘图区域宽度\n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * 获取绘图区域高度\n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        pathToImage: function (path, dpr) {\n            dpr = dpr || this.dpr;\n\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            var rect = path.getBoundingRect();\n            var style = path.style;\n            var shadowBlurSize = style.shadowBlur;\n            var shadowOffsetX = style.shadowOffsetX;\n            var shadowOffsetY = style.shadowOffsetY;\n            var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\n            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n            var width = rect.width + leftMargin + rightMargin;\n            var height = rect.height + topMargin + bottomMargin;\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.scale(dpr, dpr);\n            ctx.clearRect(0, 0, width, height);\n            ctx.dpr = dpr;\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [leftMargin - rect.x, topMargin - rect.y];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            path.updateTransform();\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Painter.js\n ** module id = 31\n ** module chunks = 0\n **/","/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * 创建dom\n     *\n     * @inner\n     * @param {string} id dom id 待用\n     * @param {string} type dom type，such as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // 没append呢，请原谅我这样写，清晰~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id不作为索引用，避免可能造成的重名，定义为私有属性\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * 每次清空画布的颜色\n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * 是否开启动态模糊\n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * 清空该层画布\n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Layer.js\n ** module id = 32\n ** module chunks = 0\n **/","/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        // var size =\n        var x = obj.x;\n        var x2 = obj.x2;\n        var y = obj.y;\n        var y2 = obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x;\n        var y = obj.y;\n        var r = obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * [x, y]\n         * @type {Array.<number>}\n         */\n        textOffset: null,\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Style.js\n ** module id = 33\n ** module chunks = 0\n **/","\n\n    var Pattern = function (image, repeat) {\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n\n        return this._canvasPattern\n            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n    };\n\n    module.exports = Pattern;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Pattern.js\n ** module id = 34\n ** module chunks = 0\n **/","/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // 图片已经加载完成\n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // 图片加载失败\n                if (!image.width || !image.height) {\n                    return;\n                }\n                var width = style.width;\n                var height = style.height;\n                var aspect = image.width / image.height;\n                if (width == null && height != null) {\n                    // Keep image/height ratio\n                    width = height * aspect;\n                }\n                else if (height == null && width != null) {\n                    height = width / aspect;\n                }\n                else if (width == null && height == null) {\n                    width = image.width;\n                    height = image.height;\n                }\n\n                // 设置transform\n                this.setTransform(ctx);\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Image.js\n ** module id = 35\n ** module chunks = 0\n **/","/**\n * 可绘制的图形基类\n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = require('../core/util');\n\n    var Style = require('./Style');\n\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * z层level，决定绘画在哪层canvas中\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * 是否可拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * 是否正在拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * 是否相应鼠标事件\n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * 图形绘制方法\n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * 获取最小包围盒\n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         * 判断坐标 x, y 是否在图形上\n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         * 判断坐标 x, y 是否在图形的包围盒上\n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * 标记图形元素为脏，并且在下一帧重绘\n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * 图形是否会触发事件\n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO, 通过 bind 绑定的事件\n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Displayable.js\n ** module id = 36\n ** module chunks = 0\n **/","/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var textOffset = style.textOffset;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            if (textOffset) {\n                x += textOffset[0];\n                y += textOffset[1];\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                    // Fill after stroke so the outline will not cover the main part.\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                textFill && ctx.fillText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/mixin/RectText.js\n ** module id = 37\n ** module chunks = 0\n **/","\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME 高度计算比较粗暴\n        var lineHeight = getTextWidth('国', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var halfHeight = height / 2 - textHeight / 2;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('国', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/text.js\n ** module id = 38\n ** module chunks = 0\n **/","/**\r\n * BO节点\r\n * 1.BO是一个矩形\r\n * 2.BO有名字\r\n * 3.BO有事件决策[]，双击事件决策弹出详情\r\n * 4.BO有外键属性[]\r\n * 5.BO有子BO\r\n * 6.当前BO特殊颜色显示\r\n * 7.双击BO弹出BO属性以及属性事件决策页面\r\n * @module fish-topo-bo/node/BoNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var BoName = require('../node/BoName');\r\n    var EventDecision = require('../node/EventDecisionNode');\r\n    var Line = require('../node/LineNode');\r\n    var BoAttr = require('../node/BoAttrNode');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n\r\n    /**\r\n     *\r\n     * @param {{\r\n     *          id: String BO主键,\r\n     *          name: String BO名字,\r\n     *          boEventArr: [] BO事件决策数组,\r\n     *          boAttrArr: [] BO属性数组\r\n     *          }} boData, bo数据对象\r\n     * @param {{\r\n     *          startPos: {x: number, y: number} 起始位置,\r\n     *          displayAttrDataType: boolean 是否显示属性数据类型,\r\n     *          displayAttrEvent: boolean 是否显示属性事件决策,\r\n     *          boClickable: boolean BO是否支持点击事件, 可空 默认false\r\n     *          boPopupOpts: Object BO弹出页面参数，url,width,height等\r\n     *          boEventClickable: boolean BO事件决策是否支持点击事件, 可空 默认false\r\n     *          boEventPopupOpts: Object BO事件决策弹出页面参数，url,width,height等\r\n     *          attrEventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false\r\n     *          attrEventPopupOpts: Object 点击BO属性事件决策弹出页面参数，url,width,height等\r\n     *          isCurrent: boolean 是否为当前BO\r\n     *          viewOption: 参数\r\n     *          }} opts\r\n     * @constructor\r\n     */\r\n    function BO(boData, opts) {\r\n\r\n        /**\r\n         * BO数据\r\n         * @type {Object}\r\n         * @private\r\n         */\r\n        this._data = boData;\r\n        this._data.viewOption = {};\r\n        fish.extend(this._data.viewOption, opts.viewOption||{});\r\n\r\n        /**\r\n         * 初始坐标，用于最后画BO矩形\r\n         * @type {{x: number, y: number}}\r\n         * @private\r\n         */\r\n        this._oriStartPos = opts.startPos;\r\n\r\n        /**\r\n         * 每个控件的起始参照坐标，每个控件画完之后都会重新计算\r\n         * @type {{x: number, y: number}}\r\n         * @private\r\n         */\r\n        this._nextStartPos = {\r\n            x: opts.startPos.x,\r\n            y: opts.startPos.y\r\n        };\r\n\r\n        /**\r\n         * 是否显示属性数据类型\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayAttrDataType = opts.displayAttrDataType || false;\r\n\r\n        /**\r\n         * 是否显示属性事件决策\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayAttrEvent = opts.displayAttrEvent || false;\r\n\r\n        //TODO\r\n        if (this._displayAttrEvent) {\r\n            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 3;\r\n        } else if (this._displayAttrDataType) {\r\n            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 1.5;\r\n        }\r\n\r\n        /**\r\n         * 是否支持点击\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._boClickable = opts.boClickable || false;\r\n        this._boPopupOpts = opts.boPopupOpts;\r\n        this._boEventClickable = opts.boEventClickable || false;\r\n        this._boEventPopupOpts = opts.boEventPopupOpts;\r\n        this._attrEventClickable = opts.attrEventClickable || false;\r\n        this._attrEventPopupOpts = opts.attrEventPopupOpts;\r\n\r\n        /**\r\n         * 是否是当前BO，当前BO特殊颜色显示\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._isCurrent = opts.isCurrent || false;\r\n\r\n\r\n        /**\r\n         * BO矩形高度，根据实际内容计算\r\n         * @type {number}\r\n         * @private\r\n         */\r\n        this._boShapeHeight = 0;\r\n\r\n        /**\r\n         * Group容器\r\n         * @type zrender/graphic/Group\r\n         * @private\r\n         */\r\n        this._group = new graphic.Group();\r\n        this._group.name = this._data.id;\r\n        this._group.setCurrent = function (style) {\r\n            //Group最后一个是BO矩形\r\n            var _boShape = this.childAt(this.childCount() - 1);\r\n\r\n            if (style) {\r\n                fish.extend(_boShape.style, style);\r\n            } else {\r\n                //默认效果\r\n                _boShape.style.fill = '#66CC99';\r\n            }\r\n\r\n        };\r\n\r\n        this._render();\r\n    }\r\n\r\n\r\n    var boProto = BO.prototype;\r\n\r\n    /**\r\n     * 获取BO整体图形\r\n     * @returns {zrender/graphic/Group}\r\n     */\r\n    boProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n    /**\r\n     * 获取数据\r\n     * @returns {Object}\r\n     */\r\n    boProto.getData = function () {\r\n        return this._data;\r\n    };\r\n\r\n    boProto.getLayout = function () {\r\n        return this._data.layout;\r\n    };\r\n\r\n\r\n\r\n    /**\r\n     * 设置当前BO特殊演示显示\r\n     */\r\n    boProto.setCurrent = function () {\r\n        //BO矩形是最后一个图形\r\n        this.childAt(this.childCount - 1).style.fill = '#66CC99'\r\n    };\r\n\r\n    /**\r\n     * 生成BO整体图形\r\n     * @private\r\n     */\r\n    boProto._render = function () {\r\n        //BO名字\r\n        this._createBoName();\r\n\r\n        //BO事件决策\r\n        this._createEventDecision();\r\n\r\n        //BO属性\r\n        this._createBoAttr();\r\n\r\n        //BO矩形\r\n        this._createBoShape();\r\n\r\n        //TODO\r\n        Const.BO_NODE_WIDTH = 180;\r\n    };\r\n\r\n\r\n    /**\r\n     * 生成BO名字文本\r\n     * @private\r\n     */\r\n    boProto._createBoName = function () {\r\n        var _boNameShape = BoName(this._data.name, this._nextStartPos);\r\n\r\n        if (this._boClickable) {\r\n            _boNameShape.clickable = this._boClickable;\r\n            _boNameShape._data = this._data;\r\n            _boNameShape._boPopupOpts = this._boPopupOpts;\r\n            _boNameShape.onclick = this._click;\r\n        }\r\n\r\n        this._group.add(_boNameShape);\r\n        this._calNextShapeStartPos(_boNameShape);\r\n    };\r\n\r\n    /**\r\n     * 生成BO事件决策\r\n     * @private\r\n     */\r\n    boProto._createEventDecision = function () {\r\n\r\n        //如果没有BO事件决策，则返回\r\n        if (!this._data.boEventArr) {\r\n            return;\r\n        }\r\n\r\n        var _boEventArr = this._data.boEventArr,\r\n            _boEventLen = _boEventArr.length,\r\n            _eventShape,\r\n            _eventOpts = {\r\n                startPos: this._nextStartPos,\r\n                clickable: this._boEventClickable,\r\n                popupOpts: this._boEventPopupOpts\r\n            };\r\n\r\n        for (var i = 0; i < _boEventLen; i++) {\r\n            _eventShape = new EventDecision(_boEventArr[i], _eventOpts);\r\n            this._group.add(_eventShape.getShape());\r\n            this._calNextShapeStartPos(_eventShape.getShape());\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 生成BO属性\r\n     * @private\r\n     */\r\n    boProto._createBoAttr = function () {\r\n        //如果没有BO属性，则返回\r\n        if (!this._data.boAttrArr) {\r\n            return;\r\n        }\r\n\r\n        var _boAttrArr = this._data.boAttrArr,\r\n            _boAttrLen = _boAttrArr.length,\r\n            _boAttrShape, _lineShape,\r\n            _attrEventStartPos = {x: this._nextStartPos.x + Const.BO_NODE_WIDTH / 2, y: this._nextStartPos.y};\r\n\r\n        for (var i = 0; i < _boAttrLen; i++) {\r\n            if (i == 0) {\r\n                _lineShape = Line.BoLine(this._nextStartPos); //实线\r\n            }\r\n            else {\r\n                _lineShape = Line.AttrLine(this._nextStartPos);//虚线\r\n            }\r\n\r\n            this._group.add(_lineShape);\r\n\r\n            this._calNextShapeStartPos(_lineShape);\r\n\r\n            _boAttrShape = new BoAttr(_boAttrArr[i],\r\n                {\r\n                    startPos: this._nextStartPos,\r\n                    displayDataType: this._displayAttrDataType,\r\n                    displayEventDecision: this._displayAttrEvent,\r\n                    eventClickable: this._attrEventClickable,\r\n                    eventPopupOpts: this._attrEventPopupOpts\r\n                }\r\n            );\r\n            this._group.add(_boAttrShape.getShape());\r\n            this._calNextShapeStartPos(_boAttrShape.getShape())\r\n        }\r\n\r\n        if (this._displayAttrEvent) {\r\n            _lineShape = Line.AttrEventLine(_attrEventStartPos,\r\n                this._nextStartPos.y - _attrEventStartPos.y\r\n            );\r\n            this._group.add(_lineShape);\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * 计算下一个图形的开始位置，以及BO矩形的高度\r\n     * @param curShape 当前图形\r\n     * @private\r\n     */\r\n    boProto._calNextShapeStartPos = function (curShape) {\r\n        //下一图形起始位置\r\n        this._nextStartPos.y += curShape.getBoundingRect().height;\r\n\r\n        //BO矩形高度增加\r\n        this._boShapeHeight += curShape.getBoundingRect().height;\r\n    };\r\n\r\n\r\n    /**\r\n     * 生成BO矩形\r\n     * @private\r\n     */\r\n    boProto._createBoShape = function () {\r\n        var height = this._boShapeHeight > Const.BO_NODE_DEFAULT_HEIGHT ?\r\n                this._boShapeHeight : Const.BO_NODE_DEFAULT_HEIGHT,\r\n            shape = new graphic.Rect({\r\n                position: [this._oriStartPos.x, this._oriStartPos.y],\r\n\r\n                shape: {\r\n                    r: 5,\r\n                    width: Const.BO_NODE_WIDTH,\r\n                    height: height\r\n                },\r\n\r\n                style: {\r\n                    brushType: 'both',\r\n                    fill: this._isCurrent ? '#66CC99' : 'white',\r\n                    stroke: '#000000',\r\n                    lineWidth: 1,\r\n                    lineCape: 'round'\r\n                },\r\n\r\n                zlevel: -1\r\n            });\r\n\r\n        if (this._boClickable) {\r\n            shape._data = this._data;\r\n            shape._boPopupOpts = this._boPopupOpts;\r\n\r\n            shape.clickable = this._boClickable;\r\n            shape.onclick = this._click;\r\n        }\r\n\r\n        this._group.add(shape);\r\n    };\r\n\r\n    /**\r\n     * 点击事件\r\n     * @private\r\n     */\r\n    boProto._click = function () {\r\n        var options = fish.extend(\r\n            {\r\n                viewOption: {\r\n                    DATA: this._data\r\n                },\r\n                width: 800,\r\n                height: 500\r\n            }, this._boPopupOpts);\r\n\r\n        fish.popupView(options);\r\n    };\r\n\r\n    module.exports = BO;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/BoNode.js\n ** module id = 39\n ** module chunks = 0\n **/","/**\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    module.exports = {\r\n        BO_NODE_WIDTH: 180,    //BO矩形宽度\r\n        BO_NODE_DEFAULT_HEIGHT: 60,\t//BO矩形默认高度，即只有BO名字的情况\r\n        BO_NODE_OFFSET_X: 90, //BO矩形的水平偏移量=矩形宽度的一般\r\n        BO_NODE_OFFSET_Y: 50, //BO矩形的垂直偏移量\r\n\r\n        BO_NAME_FONT: 'bold 18px Arial', //'normal 16px verdana',    //BO名字文本样式,\r\n        BO_NAME_PADDING_TOP: 10,   //BO名字与矩形上边框的距离\r\n        BO_NAME_PADDING_BOTTOM: 15,   //BO名字与下一个控件（事件决策或者横线）的距离\r\n\r\n        BO_EVENT_HEIGHT: 20,   //BO事件决策多边形高度\r\n        BO_EVENT_WIDTH: 140,   //BO事件决策多边形宽度\r\n        BO_EVENT_FONT: 'normal 14px Arial',  //BO事件决策名字文本样式\r\n\r\n        BO_ATTR_FONT: 'normal 14px Arial',   //BO属性名字文本样式\r\n        BO_ATTR_PADDING_TOP: 5,   //BO属性名字与矩形上边框的距离\r\n        BO_ATTR_PADDING_BOTTOM: 5,   //BO属性名字与下一个控件（事件决策或者横线）的距离\r\n        BO_ATTR_PADDING_LEFT: 5,   //BO属性名字与矩形左边框的距离\r\n        BO_ATTR_DATA_TYPE_PADDING_RIGHT: 5, //BO属性数据类型与矩形右边框的距离\r\n        BO_ATTR_EVENT_WIDTH: 135,   //BO属性事件决策多边形宽度\r\n\r\n        LINE_DASH: 10,  //虚线\r\n        RELATION_OFFSET: 40,   //关联关系的初始偏移量，即第一段折线宽度\r\n        RELATION_ARROW_WIDTH: 10,  //关联关系三角箭头水平宽度\r\n        RELATION_ARROW_HEIGHT: 5,  //关联关系三角箭头垂直高度的一半\r\n        RELATION_TEXT_OFFSET_X: 10, //关联关系文字说明水平偏移量\r\n        RELATION_TEXT_OFFSET_Y: 5 //关联关系文字说明垂直偏移量\r\n    };\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/models/Const.js\n ** module id = 40\n ** module chunks = 0\n **/","/**\r\n * BO名字\r\n * @module fish-topo-bo/node/BoName\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n    /**\r\n     *\r\n     * @param {String} text, BO名字\r\n     * @param {{x: number, y: number}} startPos, 起始位置\r\n     * @returns {zrender/graphic/Text}\r\n     * @constructor\r\n     */\r\n    function BoName(text, startPos) {\r\n        var x = startPos.x,\r\n            y = startPos.y + Const.BO_NAME_PADDING_TOP, //文字到矩形上边框的距离 padding-top=10\r\n\r\n            shape = new graphic.Text({\r\n                style: {\r\n                    text: text,\r\n                    textFont: Const.BO_NAME_FONT,\r\n                    textAlign: 'left',  //靠左开始，便于计算位置\r\n                    textBaseline: 'top'\r\n                },\r\n\r\n                position: [x, y]\r\n            });\r\n\r\n        //文字居中显示，重新计算文本水平起始位置 = 矩形水平起始位置 + (BO矩形宽度 - 文本宽度)/2\r\n        shape.position[0] += (Const.BO_NODE_WIDTH - shape.getBoundingRect().width) / 2;\r\n\r\n        //重新设置BO名字图形高度 = 文本高度 + padding-top + padding-bottom\r\n        shape.getBoundingRect().height += Const.BO_NAME_PADDING_TOP + Const.BO_NAME_PADDING_BOTTOM;\r\n\r\n        return shape;\r\n    }\r\n\r\n    module.exports = BoName;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/BoName.js\n ** module id = 41\n ** module chunks = 0\n **/","'use strict';\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var pathTool = require('zrender/lib/tool/path');\r\n    var round = Math.round;\r\n    var Path = require('zrender/lib/graphic/Path');\r\n    var colorTool = require('zrender/lib/tool/color');\r\n    var matrix = require('zrender/lib/core/matrix');\r\n    var vector = require('zrender/lib/core/vector');\r\n    var Gradient = require('zrender/lib/graphic/Gradient');\r\n    var Draggable = require('zrender/lib/mixin/Draggable');\r\n\r\n    var graphic = {};\r\n    graphic.Util = zrUtil;\r\n    graphic.Group = require('zrender/lib/container/Group');\r\n\r\n    graphic.Image = require('zrender/lib/graphic/Image');\r\n\r\n    graphic.Text = require('zrender/lib/graphic/Text');\r\n\r\n    graphic.textContain = require('zrender/lib/contain/text');\r\n\r\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\r\n\r\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\r\n\r\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\r\n\r\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\r\n\r\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\r\n\r\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\r\n\r\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\r\n\r\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\r\n\r\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\r\n\r\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\r\n\r\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\r\n\r\n    graphic.BoundingRect = require('zrender/lib/core/BoundingRect');\r\n\r\n    /**\r\n     * Extend shape with parameters\r\n     */\r\n    graphic.extendShape = function (opts) {\r\n        return Path.extend(opts);\r\n    };\r\n\r\n    /**\r\n     * Extend path\r\n     */\r\n    graphic.extendPath = function (pathData, opts) {\r\n        return pathTool.extendFromString(pathData, opts);\r\n    };\r\n\r\n    /**\r\n     * Create a path element from path data string\r\n     * @param {string} pathData\r\n     * @param {Object} opts\r\n     * @param {module:zrender/core/BoundingRect} rect\r\n     * @param {string} [layout=cover] 'center' or 'cover'\r\n     */\r\n    graphic.makePath = function (pathData, opts, rect, layout) {\r\n        var path = pathTool.createFromString(pathData, opts);\r\n        Draggable.call(path);\r\n        var boundingRect = path.getBoundingRect();\r\n        if (rect) {\r\n            var aspect = boundingRect.width / boundingRect.height;\r\n\r\n            if (layout === 'center') {\r\n                // Set rect to center, keep width / height ratio.\r\n                var width = rect.height * aspect;\r\n                var height;\r\n                if (width <= rect.width) {\r\n                    height = rect.height;\r\n                }\r\n                else {\r\n                    width = rect.width;\r\n                    height = width / aspect;\r\n                }\r\n                var cx = rect.x + rect.width / 2;\r\n                var cy = rect.y + rect.height / 2;\r\n\r\n                rect.x = cx - width / 2;\r\n                rect.y = cy - height / 2;\r\n                rect.width = width;\r\n                rect.height = height;\r\n            }\r\n\r\n            this.resizePath(path, rect);\r\n        }\r\n\r\n        zrUtil.inherits(path, Draggable);\r\n        return path;\r\n    };\r\n\r\n    graphic.mergePath = pathTool.mergePath;\r\n\r\n    /**\r\n     * Resize a path to fit the rect\r\n     * @param {module:zrender/graphic/Path} path\r\n     * @param {Object} rect\r\n     */\r\n    graphic.resizePath = function (path, rect) {\r\n        if (!path.applyTransform) {\r\n            return;\r\n        }\r\n\r\n        var pathRect = path.getBoundingRect();\r\n\r\n        var m = pathRect.calculateTransform(rect);\r\n\r\n        path.applyTransform(m);\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize line for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x1]\r\n     * @param {number} [param.shape.y1]\r\n     * @param {number} [param.shape.x2]\r\n     * @param {number} [param.shape.y2]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeLine = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n\r\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n        }\r\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n        }\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize rect for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x]\r\n     * @param {number} [param.shape.y]\r\n     * @param {number} [param.shape.width]\r\n     * @param {number} [param.shape.height]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeRect = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n        var originX = shape.x;\r\n        var originY = shape.y;\r\n        var originWidth = shape.width;\r\n        var originHeight = shape.height;\r\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n        shape.width = Math.max(\r\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n            originWidth === 0 ? 0 : 1\r\n        );\r\n        shape.height = Math.max(\r\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n            originHeight === 0 ? 0 : 1\r\n        );\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize for canvas\r\n     *\r\n     * @param {number} position Coordinate, such as x, y\r\n     * @param {number} lineWidth Should be nonnegative integer.\r\n     * @param {boolean=} positiveOrNegative Default false (negative).\r\n     * @return {number} Optimized position.\r\n     */\r\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n        // Assure that (position + lineWidth / 2) is near integer edge,\r\n        // otherwise line will be fuzzy in canvas.\r\n        var doubledPosition = round(position * 2);\r\n        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n            ? doubledPosition / 2\r\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    function doSingleEnterHover(el) {\r\n        if (el.__isHover) {\r\n            return;\r\n        }\r\n        if (el.__hoverStlDirty) {\r\n            var stroke = el.style.stroke;\r\n            var fill = el.style.fill;\r\n\r\n            // Create hoverStyle on mouseover\r\n            var hoverStyle = el.__hoverStl;\r\n            var lift = colorTool.lift;\r\n            hoverStyle.fill = hoverStyle.fill\r\n                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n            hoverStyle.stroke = hoverStyle.stroke\r\n                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\r\n            var normalStyle = {};\r\n            for (var name in hoverStyle) {\r\n                if (hoverStyle.hasOwnProperty(name)) {\r\n                    normalStyle[name] = el.style[name];\r\n                }\r\n            }\r\n\r\n            el.__normalStl = normalStyle;\r\n\r\n            el.__hoverStlDirty = false;\r\n        }\r\n        el.setStyle(el.__hoverStl);\r\n        el.z2 += 1;\r\n\r\n        el.__isHover = true;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doSingleLeaveHover(el) {\r\n        if (!el.__isHover) {\r\n            return;\r\n        }\r\n\r\n        var normalStl = el.__normalStl;\r\n        normalStl && el.setStyle(normalStl);\r\n        el.z2 -= 1;\r\n\r\n        el.__isHover = false;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doEnterHover(el) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleEnterHover(child);\r\n                }\r\n            })\r\n            : doSingleEnterHover(el);\r\n    }\r\n    graphic.doEnterHover = doEnterHover;\r\n    function doLeaveHover(el) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleLeaveHover(child);\r\n                }\r\n            })\r\n            : doSingleLeaveHover(el);\r\n    }\r\n    graphic.doLeaveHover = doLeaveHover;\r\n    /**\r\n     * @inner\r\n     */\r\n    function setElementHoverStl(el, hoverStl) {\r\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n        // Often used when item group has a label element and it's hoverStyle is different\r\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n        el.__hoverStlDirty = true;\r\n    }\r\n    graphic.setElementHoverStl = setElementHoverStl;\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOver() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOut() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function enterEmphasis() {\r\n        this.__isEmphasis = true;\r\n        doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function leaveEmphasis() {\r\n        this.__isEmphasis = false;\r\n        doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * Set hover style of element\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} [hoverStyle]\r\n     */\r\n    graphic.setHoverStyle = function (el, hoverStyle) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    setElementHoverStl(child, hoverStyle);\r\n                }\r\n            })\r\n            : setElementHoverStl(el, hoverStyle);\r\n        // Remove previous bound handlers\r\n        el.on('mouseover', onElementMouseOver)\r\n          .on('mouseout', onElementMouseOut);\r\n\r\n        // Emphasis, normal can be triggered manually\r\n        el.on('emphasis', enterEmphasis)\r\n          .on('normal', leaveEmphasis);\r\n    };\r\n\r\n    graphic.setNormalStyle = function(el, options) {\r\n        if (el.__normalStl) {\r\n            for (var name in options) {\r\n                if (el.__normalStl.hasOwnProperty(name)) {\r\n                    el.__normalStl[name] = options[name];\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Set text option in the style\r\n     * @param {Object} textStyle\r\n     * @param {module:echarts/model/Model} labelModel\r\n     * @param {string} color\r\n     */\r\n    graphic.setText = function (textStyle, labelModel, color) {\r\n        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n        var textStyleModel = labelModel.getModel('textStyle');\r\n        zrUtil.extend(textStyle, {\r\n            textDistance: labelModel.getShallow('distance') || 5,\r\n            textFont: textStyleModel.getFont(),\r\n            textPosition: labelPosition,\r\n            textFill: textStyleModel.getTextColor() || labelColor\r\n        });\r\n    };\r\n\r\n    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n        var postfix = isUpdate ? 'Update' : '';\r\n        var duration = animatableModel\r\n            && animatableModel.getShallow('animationDuration' + postfix);\r\n        var animationEasing = animatableModel\r\n            && animatableModel.getShallow('animationEasing' + postfix);\r\n\r\n        animatableModel && animatableModel.getShallow('animation')\r\n            ? el.animateTo(props, duration, animationEasing, cb)\r\n            : (el.attr(props), cb && cb());\r\n    }\r\n    /**\r\n     * Update graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\r\n    /**\r\n     * Init graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\r\n    /**\r\n     * Get transform matrix of target (param target),\r\n     * in coordinate of its ancestor (param ancestor)\r\n     *\r\n     * @param {module:zrender/mixin/Transformable} target\r\n     * @param {module:zrender/mixin/Transformable} ancestor\r\n     */\r\n    graphic.getTransform = function (target, ancestor) {\r\n        var mat = matrix.identity([]);\r\n\r\n        while (target && target !== ancestor) {\r\n            matrix.mul(mat, target.getLocalTransform(), mat);\r\n            target = target.parent;\r\n        }\r\n\r\n        return mat;\r\n    };\r\n\r\n    /**\r\n     * Apply transform to an vertex.\r\n     * @param {Array.<number>} vertex [x, y]\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {Array.<number>} [x, y]\r\n     */\r\n    graphic.applyTransform = function (vertex, transform, invert) {\r\n        if (invert) {\r\n            transform = matrix.invert([], transform);\r\n        }\r\n        return vector.applyTransform([], vertex, transform);\r\n    };\r\n\r\n    /**\r\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n     */\r\n    graphic.transformDirection = function (direction, transform, invert) {\r\n\r\n        // Pick a base, ensure that transform result will not be (0, 0).\r\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\r\n        var vertex = [\r\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n        ];\r\n\r\n        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\r\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n            ? (vertex[0] > 0 ? 'right' : 'left')\r\n            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n    };\r\n\r\n    module.exports = graphic;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/graphic.js\n ** module id = 42\n ** module chunks = 0\n **/","\n\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n    var matrix = require('../core/matrix');\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var transform;\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            path.setData(pathProxy.data);\n            transform && transformPath(path, transform);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            if (!transform) {\n                transform = matrix.create();\n            }\n            matrix.mul(transform, m, transform);\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (pathEl.__dirty) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/tool/path.js\n ** module id = 43\n ** module chunks = 0\n **/","/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect = this.getBoundingRect();\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || (\n                lineDash && !ctxLineDash && hasStroke\n            )) {\n                path = this.path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     * 扩展一个 Path element, 比如星形，圆等。\n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME 不能 extend position, rotation 等引用对象\n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Path.js\n ** module id = 44\n ** module chunks = 0\n **/","'use strict';\n/**\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n * 可以用于 isInsidePath 判断以及获取boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n\n        this._len = 0;\n\n        this._ctx = null;\n\n        this._xi = 0;\n        this._yi = 0;\n\n        this._x0 = 0;\n        this._y0 = 0;\n\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        this._ux = 0;\n        this._uy = 0;\n    };\n\n    /**\n     * 快速计算Path包围盒（并不是最小包围盒）\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            this._len = 0;\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._yi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n         * stroke 同样\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         * 直接设置 Path 数据\n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * 添加子路径\n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         * 填充 Path 数据。\n         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n         */\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                // 因为之前的数组已经转换成静态的 Float32Array\n                // 所以不够用时需要扩展一个新的动态数组\n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         * 转成静态的 Float32Array 减少堆内存占用\n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                        // 在 closePath 的时候使用\n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc 判断的开销比较大\n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc 旋转\n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/PathProxy.js\n ** module id = 45\n ** module chunks = 0\n **/","'use strict';\n/**\n * 曲线辅助模块\n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // 临时变量\n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * 计算三次贝塞尔值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * 计算三次贝塞尔导数值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * 计算三次贝塞尔方程根，使用盛金公式\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算三次贝塞尔方程极限值的位置\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} 有效数目\n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 细分三次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * 投射点到三次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] 投射点\n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * 计算二次方贝塞尔值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * 计算二次方贝塞尔导数值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * 计算二次方贝塞尔方程根\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算二次贝塞尔方程极限值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * 细分二次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * 投射点到二次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out 投射点\n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/curve.js\n ** module id = 46\n ** module chunks = 0\n **/","/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points 顶点数组\n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/bbox.js\n ** module id = 47\n ** module chunks = 0\n **/","'use strict';\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n\n    var windingLine = require('./windingLine');\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // 临时数组\n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // 分成三段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // 分成两段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc 旋转\n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                // 如果被任何一个 subpath 包含\n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                // 如果第一个命令是 L, C, Q\n                // 则 previous point 同绘制命令的第一个 point\n                //\n                // 第一个命令为 Arc 的情况下会在后面特殊处理\n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                    // 在 closePath 的时候使用\n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc 判断的开销比较大\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc 旋转\n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    // 不是直接使用 arc 命令\n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // 第一个命令起点还未定义\n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        // 如果被任何一个 subpath 包含\n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/path.js\n ** module id = 48\n ** module chunks = 0\n **/","\n    module.exports = {\n        /**\n         * 线段包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/line.js\n ** module id = 49\n ** module chunks = 0\n **/","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * 三次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/cubic.js\n ** module id = 50\n ** module chunks = 0\n **/","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * 二次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/quadratic.js\n ** module id = 51\n ** module chunks = 0\n **/","\n\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * 圆弧描边包含判断\n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/arc.js\n ** module id = 52\n ** module chunks = 0\n **/","\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/util.js\n ** module id = 53\n ** module chunks = 0\n **/","\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/windingLine.js\n ** module id = 54\n ** module chunks = 0\n **/","\n\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i++] += x;\n                    // cy\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/tool/transformPath.js\n ** module id = 55\n ** module chunks = 0\n **/","\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Gradient.js\n ** module id = 56\n ** module chunks = 0\n **/","/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                // FIXME in text contain default is top\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('国', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    // Fill after stroke so the outline will not cover the main part.\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (!this._rect) {\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                if (style.hasStroke()) {\n                    var w = style.lineWidth;\n                    rect.x -= w / 2;\n                    rect.y -= w / 2;\n                    rect.width += w;\n                    rect.height += w;\n                }\n                this._rect = rect;\n            }\n\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Text.js\n ** module id = 57\n ** module chunks = 0\n **/","'use strict';\n/**\n * 圆形\n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Circle.js\n ** module id = 58\n ** module chunks = 0\n **/","/**\n * 扇形\n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    var env = require('../../core/env');\n    var Path = require('../Path');\n\n    var shadowTemp = [\n        ['shadowBlur', 0],\n        ['shadowColor', '#000'],\n        ['shadowOffsetX', 0],\n        ['shadowOffsetY', 0]\n    ];\n\n    module.exports = Path.extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\n            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\n            // where exception \"unexpected call to method or property access\"\n            // might be thrown when calling ctx.fill after a path whose area size\n            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\n            // (e.g.,\n            //  ctx.moveTo(10, 10);\n            //  ctx.lineTo(20, 10);\n            //  ctx.closePath();\n            //  ctx.clip();\n            //  ctx.shadowBlur = 10;\n            //  ...\n            //  ctx.fill();\n            // )\n            ? function () {\n                var clipPaths = this.__clipPaths;\n                var style = this.style;\n                var modified;\n\n                if (clipPaths) {\n                    for (var i = 0; i < clipPaths.length; i++) {\n                        var shape = clipPaths[i] && clipPaths[i].shape;\n                        if (shape && shape.startAngle === shape.endAngle) {\n                            for (var j = 0; j < shadowTemp.length; j++) {\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n                            }\n                            modified = true;\n                            break;\n                        }\n                    }\n                }\n\n                Path.prototype.brush.apply(this, arguments);\n\n                if (modified) {\n                    for (var j = 0; j < shadowTemp.length; j++) {\n                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n                    }\n                }\n            }\n            : Path.prototype.brush,\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Sector.js\n ** module id = 59\n ** module chunks = 0\n **/","/**\n * 圆环\n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Ring.js\n ** module id = 60\n ** module chunks = 0\n **/","/**\n * 多边形\n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Polygon.js\n ** module id = 61\n ** module chunks = 0\n **/","\n\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/poly.js\n ** module id = 62\n ** module chunks = 0\n **/","/**\n * Catmull-Rom spline 插值折线\n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = require('../../core/vector');\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points 线段顶点数组\n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/smoothSpline.js\n ** module id = 63\n ** module chunks = 0\n **/","/**\n * 贝塞尔平滑曲线\n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * 贝塞尔平滑曲线\n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points 线段顶点数组\n     * @param {number} smooth 平滑等级, 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n     *                           整个折线的包围盒做一个并集用来约束控制点。\n     * @param {Array} 计算出来的控制点数组\n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // 与指定的包围盒做并集\n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/smoothBezier.js\n ** module id = 64\n ** module chunks = 0\n **/","/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Polyline.js\n ** module id = 65\n ** module chunks = 0\n **/","/**\n * 矩形\n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = require('../helper/roundRect');\n\n    module.exports = require('../Path').extend({\n\n        type: 'rect',\n\n        shape: {\n            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n            // r缩写为1         相当于 [1, 1, 1, 1]\n            // r缩写为[1]       相当于 [1, 1, 1, 1]\n            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Rect.js\n ** module id = 66\n ** module chunks = 0\n **/","\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/roundRect.js\n ** module id = 67\n ** module chunks = 0\n **/","/**\n * 直线\n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = require('../Path').extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Line.js\n ** module id = 68\n ** module chunks = 0\n **/","'use strict';\n/**\n * 贝塞尔曲线\n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = require('../Path').extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/BezierCurve.js\n ** module id = 69\n ** module chunks = 0\n **/","/**\n * 圆弧\n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = require('../Path').extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Arc.js\n ** module id = 70\n ** module chunks = 0\n **/","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/LinearGradient.js\n ** module id = 71\n ** module chunks = 0\n **/","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/RadialGradient.js\n ** module id = 72\n ** module chunks = 0\n **/","/**\r\n * 事件决策多边形\r\n * @module fish-topo-bo/node/EventDecisionNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n    function EventDecisionNode(data, opts) {\r\n        /**\r\n         * BO属性数据\r\n         * @type {Object}\r\n         * @private\r\n         */\r\n        this._data = data;\r\n\r\n        /**\r\n         * 起始位置坐标\r\n         * @type {startPos}\r\n         * @private\r\n         */\r\n        this._startPos = opts.startPos;\r\n\r\n        this._type = opts.type || 'boEvent';\r\n\r\n        /**\r\n         * 是否支持点击\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._clickable = opts.clickable || false;\r\n        this._popupOpts = opts.popupOpts;\r\n\r\n        /**\r\n         * Group容器\r\n         * @type zrender/graphic/Group\r\n         * @private\r\n         */\r\n        this._group = new graphic.Group();\r\n        this._group.name = this._data.id;\r\n\r\n        //生成BO属性图形\r\n        this._render();\r\n    }\r\n\r\n    var eventProto = EventDecisionNode.prototype;\r\n\r\n    /**\r\n     * 获取关系整体图形\r\n     * @returns {zrender/graphic/Group}\r\n     */\r\n    eventProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n    /**\r\n     * 生成事件决策图形\r\n     * @private\r\n     */\r\n    eventProto._render = function () {\r\n        //多边形\r\n        this._createEventShape();\r\n        //文字\r\n        this._createEVentName();\r\n    };\r\n\r\n    /**\r\n     * 事件决策多边形\r\n     * @private\r\n     */\r\n    eventProto._createEventShape = function () {\r\n\r\n        //多边形高度\r\n        var height = Const.BO_EVENT_HEIGHT,\r\n            x = this._startPos.x + 1,\r\n            y = this._startPos.y,\r\n            width = this._type == 'boEvent' ? Const.BO_EVENT_WIDTH : Const.BO_ATTR_EVENT_WIDTH,\r\n\r\n            shape = new graphic.Polygon({\r\n                name: this._data.id,\r\n                shape: {\r\n                    points: [\r\n                        [x, y],\r\n                        [x + width - 10, y],\r\n                        [x + width, y + height / 2],\r\n                        [x + width - 10, y + height],\r\n                        [x, y + height]]\r\n                },\r\n\r\n                style: {\r\n                    fill: '#FFCCCC',\r\n                    stroke: '#000000',\r\n                    lineWidth: 0.75\r\n                }\r\n\r\n            });\r\n\r\n        if (this._clickable) {\r\n            shape.clickable = this._clickable;\r\n            shape._data = this._data;\r\n            shape._popupOpts = this._popupOpts;\r\n            shape.onclick = this._click;\r\n        }\r\n\r\n\r\n        this._group.add(shape);\r\n    };\r\n\r\n    /**\r\n     * 点击事件\r\n     * @private\r\n     */\r\n    eventProto._click = function () {\r\n        var options = fish.extend(\r\n            {\r\n                viewOption: {\r\n                    DATA: this._data\r\n                },\r\n                width: 800,\r\n                height: 500\r\n            }, this._popupOpts);\r\n\r\n        fish.popupView(options);\r\n    };\r\n\r\n    /**\r\n     * 事件决策名称\r\n     * @private\r\n     */\r\n    eventProto._createEVentName = function () {\r\n        var x = this._startPos.x + (this._type == 'boEvent' ? Const.BO_ATTR_PADDING_LEFT : 15),\r\n            y = this._startPos.y,\r\n\r\n            eventNameShape = new graphic.Text({\r\n                style: {\r\n                    text: this._data.name,\r\n                    textFont: Const.BO_EVENT_FONT,\r\n                    textAlign: 'left',  //靠左开始，便于计算位置\r\n                    textBaseline: 'top'\r\n                },\r\n\r\n                position: [x, y]\r\n            });\r\n\r\n        if (this._clickable) {\r\n            eventNameShape.clickable = this._clickable;\r\n            eventNameShape._data = this._data;\r\n            eventNameShape._popupOpts = this._popupOpts;\r\n            eventNameShape.onclick = this._click;\r\n        }\r\n\r\n        this._group.add(eventNameShape);\r\n    };\r\n\r\n    module.exports = EventDecisionNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/EventDecisionNode.js\n ** module id = 73\n ** module chunks = 0\n **/","/**\r\n * BO矩形内部的横线，分为实线和虚线两种\r\n * @module fish-topo-bo/node/LineNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var util = require('zrender/lib/core/util');\r\n    /**\r\n     * BO名字下面的实现\r\n     * @param {{x: *, y: *}} startPos, 开始坐标\r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @constructor\r\n     */\r\n    function BoLine(startPos) {\r\n\r\n        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y};\r\n\r\n        return _line(startPos, endPos);\r\n    }\r\n\r\n    /**\r\n     * BO属性之间的虚线\r\n     * @param {{x: *, y: *}} startPos, 开始坐标\r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @constructor\r\n     */\r\n    function AttrLine(startPos) {\r\n\r\n        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y},\r\n            style = {lineDash: [Const.LINE_DASH]};\r\n\r\n        return _line(startPos, endPos, style);\r\n    }\r\n\r\n    /**\r\n     * BO属性与BO事件决策之间的垂直虚线\r\n     * @param {{x: *, y: *}} startPos, 开始坐标\r\n     * @param {int} attrHeight, 高度\r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @constructor\r\n     */\r\n    function AttrEventLine(startPos, attrHeight) {\r\n        var endPos = {x: startPos.x, y: startPos.y + attrHeight},\r\n            style = {lineDash: [Const.LINE_DASH]};\r\n\r\n        return _line(startPos, endPos, style);\r\n    }\r\n\r\n    /**\r\n     * 画线\r\n     * @param {{x: *, y: *}} startPos, 开始坐标\r\n     * @param {{x: *, y: *}} endPos, 结束坐标\r\n     * @param {Object} style, 样式,可空\r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @private\r\n     */\r\n    function _line(startPos, endPos, style) {\r\n\r\n        var _style = {\r\n            strokeColor: '#000000',\r\n            lineWidth: 0.5,\r\n            percent: 1\r\n        };\r\n\r\n        util.extend(_style, style);\r\n\r\n        var shape = new graphic.Line({\r\n            shape: {\r\n                // Start point\r\n                x1: startPos.x,\r\n                y1: startPos.y,\r\n\r\n                // End point\r\n                x2: endPos.x,\r\n                y2: endPos.y,\r\n\r\n                percent: 1\r\n            },\r\n\r\n            style: _style\r\n        });\r\n\r\n        return shape;\r\n    }\r\n\r\n\r\n    module.exports = {\r\n        BoLine: BoLine,\r\n        AttrLine: AttrLine,\r\n        AttrEventLine: AttrEventLine\r\n    };\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/LineNode.js\n ** module id = 74\n ** module chunks = 0\n **/","/**\r\n * BO属性\r\n * 1.BO属性名字\r\n * 2.BO属性数据类型\r\n * 3.BO属性事件决策\r\n * @module fish-topo-bo/node/BoAttrNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var EventDecision = require('../node/EventDecisionNode');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n    /**\r\n     *\r\n     * @param {{\r\n     *          id: String bo属性标识,\r\n     *          code: String bo属性编码\r\n     *          keyValue: boolean 是否为主键,\r\n     *          dataType: String 属性数据类型,\r\n     *          boAttrEventArr:[] 属性事件决策数组\r\n     *          }} boAttrData BO属性数据对象,\r\n     * @param {{\r\n     *          startPos: {x: number, y: number}起始位置,\r\n     *          displayDataType: boolean 是否显示数据类型,\r\n     *          displayEventDecision: boolean 是否显示事件决策,\r\n     *          eventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false,\r\n     *          eventPopupOpts: Object 点击BO属性事件决策弹出页面参数，url,width,height等,\r\n     *          }} opts\r\n     * @constructor\r\n     */\r\n    function BoAttr(boAttrData, opts) {\r\n        /**\r\n         * BO属性数据\r\n         * @type {Object}\r\n         * @private\r\n         */\r\n        this._data = boAttrData;\r\n\r\n        /**\r\n         * 是否为主键\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._keyValue = boAttrData.keyValue || false;\r\n\r\n        /**\r\n         * 起始位置坐标\r\n         * @type {startPos}\r\n         * @private\r\n         */\r\n        this._startPos = opts.startPos;\r\n\r\n        /**\r\n         * 是否显示数据类型\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayDataType = opts.displayDataType || false;\r\n\r\n        /**\r\n         * 是否显示事件决策\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayEventDecision = opts.displayEventDecision || false;\r\n\r\n        /**\r\n         * 是否支持点击\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._eventClickable = opts.eventClickable || false;\r\n        this._eventPopupOpts = opts.eventPopupOpts;\r\n\r\n        /**\r\n         * Group容器\r\n         * @type zrender/graphic/Group\r\n         * @private\r\n         */\r\n        this._group = new graphic.Group();\r\n        this._group.name = this._data.id;\r\n\r\n        //生成BO属性图形\r\n        this._render();\r\n    }\r\n\r\n    var boAttrProto = BoAttr.prototype;\r\n\r\n    /**\r\n     * 获取关系整体图形\r\n     * @returns {zrender/graphic/Group}\r\n     */\r\n    boAttrProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n\r\n    /**\r\n     * 生成BO属性图形\r\n     * @private\r\n     */\r\n    boAttrProto._render = function () {\r\n        //属性名字\r\n        this._createText();\r\n\r\n        //属性数据类型\r\n        this._createDataType();\r\n\r\n        //属性事件决策\r\n        this._createEventDecision();\r\n    };\r\n\r\n    /**\r\n     * 属性名字\r\n     * @private\r\n     */\r\n    boAttrProto._createText = function () {\r\n\r\n        var x = this._startPos.x + Const.BO_ATTR_PADDING_LEFT,\r\n            y = this._startPos.y,\r\n\r\n            attrNameShape = new graphic.Text({\r\n                style: {\r\n                    text: this._data.name,\r\n                    textFont: Const.BO_ATTR_FONT,\r\n                    textAlign: 'left',  //靠左开始，便于计算位置\r\n                    textBaseline: 'top',\r\n                    //lineWidth: 1,\r\n                    fill: this._keyValue ? 'red' : 'black'\r\n                },\r\n\r\n                position: [x, y]\r\n            });\r\n\r\n        //重新设置图形高度 = 文本高度 + padding-top + padding-bottom\r\n        attrNameShape.getBoundingRect().height += Const.BO_ATTR_PADDING_TOP + Const.BO_ATTR_PADDING_BOTTOM;\r\n        //重新设置图形高度 = BO矩形宽度，用于后续Relation画图计算\r\n        attrNameShape.getBoundingRect().width = Const.BO_NODE_WIDTH;\r\n\r\n        //重新设置B起始水平坐标 = 减去偏移量\r\n        attrNameShape.getBoundingRect().x += -Const.BO_ATTR_PADDING_LEFT;\r\n        //attrNameShape.getBoundingRect().y = + attrNameShape.position[1];\r\n\r\n        this._group.add(attrNameShape);\r\n    };\r\n\r\n    /**\r\n     * 属性数据类型\r\n     * @private\r\n     */\r\n    boAttrProto._createDataType = function () {\r\n        if (!this._displayDataType) {\r\n            return;\r\n        }\r\n\r\n        var x = this._startPos.x + Const.BO_NODE_WIDTH - 10,\r\n            y = this._startPos.y,\r\n            textAlign = 'right';\r\n\r\n        //如果还要显示事件决策，则宽度重新计算\r\n        if (this._displayEventDecision) {\r\n            textAlign = 'left';\r\n            x = this._startPos.x + Const.BO_NODE_WIDTH / 3;\r\n        }\r\n\r\n        var _dataTypeShape = new graphic.Text({\r\n            style: {\r\n                text: this._data.dataType || '',\r\n                textFont: Const.BO_ATTR_FONT,\r\n                textAlign: textAlign,  //靠左开始，便于计算位置\r\n                textBaseline: 'top',\r\n                lineWidth: 1\r\n            },\r\n\r\n            position: [x, y]\r\n        });\r\n\r\n        this._group.add(_dataTypeShape);\r\n    };\r\n\r\n    /**\r\n     * 属性事件决策\r\n     * @private\r\n     */\r\n    boAttrProto._createEventDecision = function () {\r\n        if (!this._displayEventDecision) {\r\n            return;\r\n        }\r\n\r\n        var _boAttrEventArr = this._data.boAttrEventArr || [],\r\n            _boAttrEventLen = _boAttrEventArr.length,\r\n            padding = (_boAttrEventLen > 1) ? 10 : 0,\r\n            _startPos = {\r\n                x: this._startPos.x + Const.BO_NODE_WIDTH / 2 + Const.BO_ATTR_EVENT_WIDTH * (_boAttrEventLen - 1) - padding,\r\n                y: this._startPos.y\r\n            };\r\n\r\n        //从右向左画，\r\n        for (var i = _boAttrEventLen - 1; i >= 0; i--) {\r\n            this._group.add(new EventDecision(_boAttrEventArr[i], {\r\n                startPos: _startPos,\r\n                type: 'boAttrEvent',\r\n                clickable: this._eventClickable,\r\n                popupOpts: this._eventPopupOpts\r\n            }).getShape());\r\n            _startPos = {x: _startPos.x - Const.BO_ATTR_EVENT_WIDTH + 10, y: _startPos.y};\r\n        }\r\n        /*_startPos = {\r\n         x: this._startPos.x + Const.BO_NODE_WIDTH / 2,\r\n         y: this._startPos.y};\r\n\r\n         for (var i = 0; i < _boAttrEventLen; i++) {\r\n         this._group.add(event.BoAttrEvent(_boAttrEventArr[i], _startPos, i + 2));\r\n         _startPos = {x: _startPos.x + Const.BO_ATTR_EVENT_WIDTH - 5, y: _startPos.y};\r\n         }*/\r\n\r\n\r\n    };\r\n\r\n    module.exports = BoAttr;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/BoAttrNode.js\n ** module id = 75\n ** module chunks = 0\n **/","/**\r\n * 用来创建关联关系\r\n * 关联关系包括折线、箭头、关系文字说明\r\n * @module fish-topo-bo/node/Relation\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n    /**\r\n     *\r\n     * @param sourceShape, 开始图形\r\n     * @param targetShape, 目标图形\r\n     * @param {String} sourceText, 关系开始文字说明,可空\r\n     * @param {String} targetText, 关系结束文字说明,可空\r\n     * @constructor\r\n     */\r\n    function Relation(sourceShape, targetShape, sourceText, targetText) {\r\n        this._sourceText = sourceText;\r\n        this._targetText = targetText;\r\n\r\n        this._group = new graphic.Group();\r\n\r\n        //左侧开始位置\r\n        this._lStartPos = {\r\n            x: sourceShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //左侧结束位置\r\n        this._lEndPos = {\r\n            x: targetShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //右侧开始位置\r\n        this._rStartPos = {\r\n            x: sourceShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //右侧结束位置\r\n        this._rEndPos = {\r\n            x: targetShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //判断画线方向\r\n        this._leftDirection = this._lStartPos.x - this._lEndPos.x <= 0;\r\n\r\n        //生成图形\r\n        this._render();\r\n    }\r\n\r\n    var relationProto = Relation.prototype;\r\n\r\n    /**\r\n     * 获取关系整体图形\r\n     * @returns {*}\r\n     */\r\n    relationProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n    /**\r\n     * 生成关系整体图形\r\n     * @private\r\n     */\r\n    relationProto._render = function () {\r\n        //画线\r\n        this._createLine();\r\n\r\n        //箭头\r\n        this._createArrow();\r\n\r\n        //关系说明文字\r\n        this._createText();\r\n    };\r\n\r\n    /**\r\n     * 生成关系折线\r\n     * @private\r\n     */\r\n    relationProto._createLine = function () {\r\n        var _linePoints = [];\r\n\r\n        if (this._leftDirection) {\r\n            //第一点\r\n            _linePoints.push([this._lStartPos.x, this._lStartPos.y]);\r\n            //第二点\r\n            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lStartPos.y]);\r\n            //第三点\r\n            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lEndPos.y]);\r\n            //第四点\r\n            _linePoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n        }\r\n        else {\r\n            //第一点\r\n            _linePoints.push([this._rStartPos.x, this._rStartPos.y]);\r\n            //第二点\r\n            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._lStartPos.y]);\r\n            //第三点\r\n            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._rEndPos.y]);\r\n            //第四点\r\n            _linePoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n        }\r\n\r\n        var _lineShape = new graphic.Polyline({\r\n            shape: {\r\n                points: _linePoints\r\n            },\r\n\r\n            style: {\r\n                //fill: 'blue',\r\n                stroke: 'blue'\r\n            }\r\n        });\r\n\r\n        this._group.add(_lineShape);\r\n    };\r\n\r\n    /**\r\n     * 生成箭头图形\r\n     * @private\r\n     */\r\n    relationProto._createArrow = function () {\r\n        var _arrowPoints = [];\r\n\r\n        if (this._leftDirection) {\r\n            //右侧第一点\r\n            _arrowPoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n            //下面第二点\r\n            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n            //上面第三点\r\n            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n        }\r\n        else {\r\n            //左侧第一点\r\n            _arrowPoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n            //下面第二点\r\n            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n            //上面第三点\r\n            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n        }\r\n\r\n        var _arrowShape = new graphic.Polyline({\r\n            shape: {\r\n                points: _arrowPoints\r\n            },\r\n\r\n            style: {\r\n                fill: 'blue',\r\n                stroke: 'blue'\r\n            }\r\n        });\r\n\r\n        this._group.add(_arrowShape);\r\n    };\r\n\r\n    /**\r\n     * 生成文字说明\r\n     * @private\r\n     */\r\n    relationProto._createText = function () {\r\n        var _sourceTextPos,\r\n            _targetTextPos,\r\n            _textAlign;\r\n\r\n        if (this._leftDirection) {\r\n            _sourceTextPos = [this._lStartPos.x - 10, this._lStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _targetTextPos = [this._lEndPos.x - 10 - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _textAlign = 'right';\r\n        }\r\n        else {\r\n            _sourceTextPos = [this._rStartPos.x + 10, this._rStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _targetTextPos = [this._rEndPos.x + 10 + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _textAlign = 'left';\r\n        }\r\n\r\n        //开始文字\r\n        if (this._sourceText) {\r\n            var _srcTextShape = new graphic.Text({\r\n                position: _sourceTextPos,\r\n\r\n                style: {\r\n                    text: this._sourceText,\r\n                    textFont: Const.BO_ATTR_FONT,\r\n                    textAlign: _textAlign,\r\n                    textBaseline: 'buttom',\r\n                    lineWidth: 1\r\n                }\r\n            });\r\n            this._group.add(_srcTextShape);\r\n        }\r\n\r\n        //结束文字\r\n        if (this._targetText) {\r\n            var _targetTextShape = new graphic.Text({\r\n                position: _targetTextPos,\r\n\r\n                style: {\r\n                    text: this._targetText,\r\n                    textFont: Const.BO_ATTR_FONT,\r\n                    textAlign: _textAlign,\r\n                    textBaseline: 'buttom',\r\n                    lineWidth: 1\r\n                }\r\n            });\r\n            this._group.add(_targetTextShape);\r\n        }\r\n\r\n    };\r\n\r\n    module.exports = Relation;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/Relation.js\n ** module id = 76\n ** module chunks = 0\n **/","\n    require('./graphic');\n    require('../zrender').registerPainter('vml', require('./Painter'));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/vml/vml.js\n ** module id = 77\n ** module chunks = 0\n **/","// http://www.w3.org/TR/NOTE-VML\n// TODO Use proxy like svg instead of overwrite brush methods\n\n\nif (!require('../core/env').canvasSupported) {\n    var vec2 = require('../core/vector');\n    var BoundingRect = require('../core/BoundingRect');\n    var CMD = require('../core/PathProxy').CMD;\n    var colorTool = require('../tool/color');\n    var textContain = require('../contain/text');\n    var RectText = require('../graphic/mixin/RectText');\n    var Displayable = require('../graphic/Displayable');\n    var ZImage = require('../graphic/Image');\n    var Text = require('../graphic/Text');\n    var Path = require('../graphic/Path');\n\n    var Gradient = require('../graphic/Gradient');\n\n    var vmlCore = require('./core');\n\n    var round = Math.round;\n    var sqrt = Math.sqrt;\n    var abs = Math.abs;\n    var cos = Math.cos;\n    var sin = Math.sin;\n    var mathMax = Math.max;\n\n    var applyTransform = vec2.applyTransform;\n\n    var comma = ',';\n    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\n    var Z = 21600;\n    var Z2 = Z / 2;\n\n    var ZLEVEL_BASE = 100000;\n    var Z_BASE = 1000;\n\n    var initRootElStyle = function (el) {\n        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n        el.coordsize = Z + ','  + Z;\n        el.coordorigin = '0,0';\n    };\n\n    var encodeHtmlAttribute = function (s) {\n        return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n    };\n\n    var rgb2Str = function (r, g, b) {\n        return 'rgb(' + [r, g, b].join(',') + ')';\n    };\n\n    var append = function (parent, child) {\n        if (child && parent && child.parentNode !== parent) {\n            parent.appendChild(child);\n        }\n    };\n\n    var remove = function (parent, child) {\n        if (child && parent && child.parentNode === parent) {\n            parent.removeChild(child);\n        }\n    };\n\n    var getZIndex = function (zlevel, z, z2) {\n        // z 的取值范围为 [0, 1000]\n        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n    };\n\n    var parsePercent = function (value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    };\n\n    /***************************************************\n     * PATH\n     **************************************************/\n\n    var setColorAndOpacity = function (el, color, opacity) {\n        var colorArr = colorTool.parse(color);\n        opacity = +opacity;\n        if (isNaN(opacity)) {\n            opacity = 1;\n        }\n        if (colorArr) {\n            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n            el.opacity = opacity * colorArr[3];\n        }\n    };\n\n    var getColorAndAlpha = function (color) {\n        var colorArr = colorTool.parse(color);\n        return [\n            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),\n            colorArr[3]\n        ];\n    };\n\n    var updateFillNode = function (el, style, zrEl) {\n        // TODO pattern\n        var fill = style.fill;\n        if (fill != null) {\n            // Modified from excanvas\n            if (fill instanceof Gradient) {\n                var gradientType;\n                var angle = 0;\n                var focus = [0, 0];\n                // additional offset\n                var shift = 0;\n                // scale factor for offset\n                var expansion = 1;\n                var rect = zrEl.getBoundingRect();\n                var rectWidth = rect.width;\n                var rectHeight = rect.height;\n                if (fill.type === 'linear') {\n                    gradientType = 'gradient';\n                    var transform = zrEl.transform;\n                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n                    if (transform) {\n                        applyTransform(p0, p0, transform);\n                        applyTransform(p1, p1, transform);\n                    }\n                    var dx = p1[0] - p0[0];\n                    var dy = p1[1] - p0[1];\n                    angle = Math.atan2(dx, dy) * 180 / Math.PI;\n                    // The angle should be a non-negative number.\n                    if (angle < 0) {\n                        angle += 360;\n                    }\n\n                    // Very small angles produce an unexpected result because they are\n                    // converted to a scientific notation string.\n                    if (angle < 1e-6) {\n                        angle = 0;\n                    }\n                }\n                else {\n                    gradientType = 'gradientradial';\n                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n                    var transform = zrEl.transform;\n                    var scale = zrEl.scale;\n                    var width = rectWidth;\n                    var height = rectHeight;\n                    focus = [\n                        // Percent in bounding rect\n                        (p0[0] - rect.x) / width,\n                        (p0[1] - rect.y) / height\n                    ];\n                    if (transform) {\n                        applyTransform(p0, p0, transform);\n                    }\n\n                    width /= scale[0] * Z;\n                    height /= scale[1] * Z;\n                    var dimension = mathMax(width, height);\n                    shift = 2 * 0 / dimension;\n                    expansion = 2 * fill.r / dimension - shift;\n                }\n\n                // We need to sort the color stops in ascending order by offset,\n                // otherwise IE won't interpret it correctly.\n                var stops = fill.colorStops.slice();\n                stops.sort(function(cs1, cs2) {\n                    return cs1.offset - cs2.offset;\n                });\n\n                var length = stops.length;\n                // Color and alpha list of first and last stop\n                var colorAndAlphaList = [];\n                var colors = [];\n                for (var i = 0; i < length; i++) {\n                    var stop = stops[i];\n                    var colorAndAlpha = getColorAndAlpha(stop.color);\n                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n                    if (i === 0 || i === length - 1) {\n                        colorAndAlphaList.push(colorAndAlpha);\n                    }\n                }\n\n                if (length >= 2) {\n                    var color1 = colorAndAlphaList[0][0];\n                    var color2 = colorAndAlphaList[1][0];\n                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\n                    el.type = gradientType;\n                    el.method = 'none';\n                    el.focus = '100%';\n                    el.angle = angle;\n                    el.color = color1;\n                    el.color2 = color2;\n                    el.colors = colors.join(',');\n                    // When colors attribute is used, the meanings of opacity and o:opacity2\n                    // are reversed.\n                    el.opacity = opacity2;\n                    // FIXME g_o_:opacity ?\n                    el.opacity2 = opacity1;\n                }\n                if (gradientType === 'radial') {\n                    el.focusposition = focus.join(',');\n                }\n            }\n            else {\n                // FIXME Change from Gradient fill to color fill\n                setColorAndOpacity(el, fill, style.opacity);\n            }\n        }\n    };\n\n    var updateStrokeNode = function (el, style) {\n        // if (style.lineJoin != null) {\n        //     el.joinstyle = style.lineJoin;\n        // }\n        // if (style.miterLimit != null) {\n        //     el.miterlimit = style.miterLimit * Z;\n        // }\n        // if (style.lineCap != null) {\n        //     el.endcap = style.lineCap;\n        // }\n        if (style.lineDash != null) {\n            el.dashstyle = style.lineDash.join(' ');\n        }\n        if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n            setColorAndOpacity(el, style.stroke, style.opacity);\n        }\n    };\n\n    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n        var isFill = type == 'fill';\n        var el = vmlEl.getElementsByTagName(type)[0];\n        // Stroke must have lineWidth\n        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {\n            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';\n            // FIXME Remove before updating, or set `colors` will throw error\n            if (style[type] instanceof Gradient) {\n                remove(vmlEl, el);\n            }\n            if (!el) {\n                el = vmlCore.createNode(type);\n            }\n\n            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n            append(vmlEl, el);\n        }\n        else {\n            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n            remove(vmlEl, el);\n        }\n    };\n\n    var points = [[], [], []];\n    var pathDataToString = function (data, m) {\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        var str = [];\n        var nPoint;\n        var cmdStr;\n        var cmd;\n        var i;\n        var xi;\n        var yi;\n        for (i = 0; i < data.length;) {\n            cmd = data[i++];\n            cmdStr = '';\n            nPoint = 0;\n            switch (cmd) {\n                case M:\n                    cmdStr = ' m ';\n                    nPoint = 1;\n                    xi = data[i++];\n                    yi = data[i++];\n                    points[0][0] = xi;\n                    points[0][1] = yi;\n                    break;\n                case L:\n                    cmdStr = ' l ';\n                    nPoint = 1;\n                    xi = data[i++];\n                    yi = data[i++];\n                    points[0][0] = xi;\n                    points[0][1] = yi;\n                    break;\n                case Q:\n                case C:\n                    cmdStr = ' c ';\n                    nPoint = 3;\n                    var x1 = data[i++];\n                    var y1 = data[i++];\n                    var x2 = data[i++];\n                    var y2 = data[i++];\n                    var x3;\n                    var y3;\n                    if (cmd === Q) {\n                        // Convert quadratic to cubic using degree elevation\n                        x3 = x2;\n                        y3 = y2;\n                        x2 = (x2 + 2 * x1) / 3;\n                        y2 = (y2 + 2 * y1) / 3;\n                        x1 = (xi + 2 * x1) / 3;\n                        y1 = (yi + 2 * y1) / 3;\n                    }\n                    else {\n                        x3 = data[i++];\n                        y3 = data[i++];\n                    }\n                    points[0][0] = x1;\n                    points[0][1] = y1;\n                    points[1][0] = x2;\n                    points[1][1] = y2;\n                    points[2][0] = x3;\n                    points[2][1] = y3;\n\n                    xi = x3;\n                    yi = y3;\n                    break;\n                case A:\n                    var x = 0;\n                    var y = 0;\n                    var sx = 1;\n                    var sy = 1;\n                    var angle = 0;\n                    if (m) {\n                        // Extract SRT from matrix\n                        x = m[4];\n                        y = m[5];\n                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n                        angle = Math.atan2(-m[1] / sy, m[0] / sx);\n                    }\n\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var startAngle = data[i++] + angle;\n                    var endAngle = data[i++] + startAngle + angle;\n                    // FIXME\n                    // var psi = data[i++];\n                    i++;\n                    var clockwise = data[i++];\n\n                    var x0 = cx + cos(startAngle) * rx;\n                    var y0 = cy + sin(startAngle) * ry;\n\n                    var x1 = cx + cos(endAngle) * rx;\n                    var y1 = cy + sin(endAngle) * ry;\n\n                    var type = clockwise ? ' wa ' : ' at ';\n                    if (Math.abs(x0 - x1) < 1e-4) {\n                        // IE won't render arches drawn counter clockwise if x0 == x1.\n                        if (Math.abs(endAngle - startAngle) > 1e-2) {\n                            // Offset x0 by 1/80 of a pixel. Use something\n                            // that can be represented in binary\n                            if (clockwise) {\n                                x0 += 270 / Z;\n                            }\n                        }\n                        else {\n                            // Avoid case draw full circle\n                            if (Math.abs(y0 - cy) < 1e-4) {\n                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {\n                                    y1 -= 270 / Z;\n                                }\n                                else {\n                                    y1 += 270 / Z;\n                                }\n                            }\n                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {\n                                x1 += 270 / Z;\n                            }\n                            else {\n                                x1 -= 270 / Z;\n                            }\n                        }\n                    }\n                    str.push(\n                        type,\n                        round(((cx - rx) * sx + x) * Z - Z2), comma,\n                        round(((cy - ry) * sy + y) * Z - Z2), comma,\n                        round(((cx + rx) * sx + x) * Z - Z2), comma,\n                        round(((cy + ry) * sy + y) * Z - Z2), comma,\n                        round((x0 * sx + x) * Z - Z2), comma,\n                        round((y0 * sy + y) * Z - Z2), comma,\n                        round((x1 * sx + x) * Z - Z2), comma,\n                        round((y1 * sy + y) * Z - Z2)\n                    );\n\n                    xi = x1;\n                    yi = y1;\n                    break;\n                case CMD.R:\n                    var p0 = points[0];\n                    var p1 = points[1];\n                    // x0, y0\n                    p0[0] = data[i++];\n                    p0[1] = data[i++];\n                    // x1, y1\n                    p1[0] = p0[0] + data[i++];\n                    p1[1] = p0[1] + data[i++];\n\n                    if (m) {\n                        applyTransform(p0, p0, m);\n                        applyTransform(p1, p1, m);\n                    }\n\n                    p0[0] = round(p0[0] * Z - Z2);\n                    p1[0] = round(p1[0] * Z - Z2);\n                    p0[1] = round(p0[1] * Z - Z2);\n                    p1[1] = round(p1[1] * Z - Z2);\n                    str.push(\n                        // x0, y0\n                        ' m ', p0[0], comma, p0[1],\n                        // x1, y0\n                        ' l ', p1[0], comma, p0[1],\n                        // x1, y1\n                        ' l ', p1[0], comma, p1[1],\n                        // x0, y1\n                        ' l ', p0[0], comma, p1[1]\n                    );\n                    break;\n                case CMD.Z:\n                    // FIXME Update xi, yi\n                    str.push(' x ');\n            }\n\n            if (nPoint > 0) {\n                str.push(cmdStr);\n                for (var k = 0; k < nPoint; k++) {\n                    var p = points[k];\n\n                    m && applyTransform(p, p, m);\n                    // 不 round 会非常慢\n                    str.push(\n                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),\n                        k < nPoint - 1 ? comma : ''\n                    );\n                }\n            }\n        }\n\n        return str.join('');\n    };\n\n    // Rewrite the original path method\n    Path.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n\n        var vmlEl = this._vmlEl;\n        if (!vmlEl) {\n            vmlEl = vmlCore.createNode('shape');\n            initRootElStyle(vmlEl);\n\n            this._vmlEl = vmlEl;\n        }\n\n        updateFillAndStroke(vmlEl, 'fill', style, this);\n        updateFillAndStroke(vmlEl, 'stroke', style, this);\n\n        var m = this.transform;\n        var needTransform = m != null;\n        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n        if (strokeEl) {\n            var lineWidth = style.lineWidth;\n            // Get the line scale.\n            // Determinant of this.m_ means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            if (needTransform && !style.strokeNoScale) {\n                var det = m[0] * m[3] - m[1] * m[2];\n                lineWidth *= sqrt(abs(det));\n            }\n            strokeEl.weight = lineWidth + 'px';\n        }\n\n        var path = this.path;\n        if (this.__dirtyPath) {\n            path.beginPath();\n            this.buildPath(path, this.shape);\n            path.toStatic();\n            this.__dirtyPath = false;\n        }\n\n        vmlEl.path = pathDataToString(path.data, this.transform);\n\n        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Append to root\n        append(vmlRoot, vmlEl);\n\n        // Text\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, this.getBoundingRect());\n        }\n        else {\n            this.removeRectText(vmlRoot);\n        }\n    };\n\n    Path.prototype.onRemove = function (vmlRoot) {\n        remove(vmlRoot, this._vmlEl);\n        this.removeRectText(vmlRoot);\n    };\n\n    Path.prototype.onAdd = function (vmlRoot) {\n        append(vmlRoot, this._vmlEl);\n        this.appendRectText(vmlRoot);\n    };\n\n    /***************************************************\n     * IMAGE\n     **************************************************/\n    var isImage = function (img) {\n        // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';\n        // return img instanceof Image;\n    };\n\n    // Rewrite the original path method\n    ZImage.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n        var image = style.image;\n\n        // Image original width, height\n        var ow;\n        var oh;\n\n        if (isImage(image)) {\n            var src = image.src;\n            if (src === this._imageSrc) {\n                ow = this._imageWidth;\n                oh = this._imageHeight;\n            }\n            else {\n                var imageRuntimeStyle = image.runtimeStyle;\n                var oldRuntimeWidth = imageRuntimeStyle.width;\n                var oldRuntimeHeight = imageRuntimeStyle.height;\n                imageRuntimeStyle.width = 'auto';\n                imageRuntimeStyle.height = 'auto';\n\n                // get the original size\n                ow = image.width;\n                oh = image.height;\n\n                // and remove overides\n                imageRuntimeStyle.width = oldRuntimeWidth;\n                imageRuntimeStyle.height = oldRuntimeHeight;\n\n                // Caching image original width, height and src\n                this._imageSrc = src;\n                this._imageWidth = ow;\n                this._imageHeight = oh;\n            }\n            image = src;\n        }\n        else {\n            if (image === this._imageSrc) {\n                ow = this._imageWidth;\n                oh = this._imageHeight;\n            }\n        }\n        if (!image) {\n            return;\n        }\n\n        var x = style.x || 0;\n        var y = style.y || 0;\n\n        var dw = style.width;\n        var dh = style.height;\n\n        var sw = style.sWidth;\n        var sh = style.sHeight;\n        var sx = style.sx || 0;\n        var sy = style.sy || 0;\n\n        var hasCrop = sw && sh;\n\n        var vmlEl = this._vmlEl;\n        if (!vmlEl) {\n            // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n            // vmlEl = vmlCore.createNode('group');\n            vmlEl = vmlCore.doc.createElement('div');\n            initRootElStyle(vmlEl);\n\n            this._vmlEl = vmlEl;\n        }\n\n        var vmlElStyle = vmlEl.style;\n        var hasRotation = false;\n        var m;\n        var scaleX = 1;\n        var scaleY = 1;\n        if (this.transform) {\n            m = this.transform;\n            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\n            hasRotation = m[1] || m[2];\n        }\n        if (hasRotation) {\n            // If filters are necessary (rotation exists), create them\n            // filters are bog-slow, so only create them if abbsolutely necessary\n            // The following check doesn't account for skews (which don't exist\n            // in the canvas spec (yet) anyway.\n            // From excanvas\n            var p0 = [x, y];\n            var p1 = [x + dw, y];\n            var p2 = [x, y + dh];\n            var p3 = [x + dw, y + dh];\n            applyTransform(p0, p0, m);\n            applyTransform(p1, p1, m);\n            applyTransform(p2, p2, m);\n            applyTransform(p3, p3, m);\n\n            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\n            var transformFilter = [];\n            transformFilter.push('M11=', m[0] / scaleX, comma,\n                        'M12=', m[2] / scaleY, comma,\n                        'M21=', m[1] / scaleX, comma,\n                        'M22=', m[3] / scaleY, comma,\n                        'Dx=', round(x * scaleX + m[4]), comma,\n                        'Dy=', round(y * scaleY + m[5]));\n\n            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';\n            // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n            vmlElStyle.filter = imageTransformPrefix + '.Matrix('\n                + transformFilter.join('') + ', SizingMethod=clip)';\n\n        }\n        else {\n            if (m) {\n                x = x * scaleX + m[4];\n                y = y * scaleY + m[5];\n            }\n            vmlElStyle.filter = '';\n            vmlElStyle.left = round(x) + 'px';\n            vmlElStyle.top = round(y) + 'px';\n        }\n\n        var imageEl = this._imageEl;\n        var cropEl = this._cropEl;\n\n        if (!imageEl) {\n            imageEl = vmlCore.doc.createElement('div');\n            this._imageEl = imageEl;\n        }\n        var imageELStyle = imageEl.style;\n        if (hasCrop) {\n            // Needs know image original width and height\n            if (! (ow && oh)) {\n                var tmpImage = new Image();\n                var self = this;\n                tmpImage.onload = function () {\n                    tmpImage.onload = null;\n                    ow = tmpImage.width;\n                    oh = tmpImage.height;\n                    // Adjust image width and height to fit the ratio destinationSize / sourceSize\n                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\n                    // Caching image original width, height and src\n                    self._imageWidth = ow;\n                    self._imageHeight = oh;\n                    self._imageSrc = image;\n                };\n                tmpImage.src = image;\n            }\n            else {\n                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n            }\n\n            if (! cropEl) {\n                cropEl = vmlCore.doc.createElement('div');\n                cropEl.style.overflow = 'hidden';\n                this._cropEl = cropEl;\n            }\n            var cropElStyle = cropEl.style;\n            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='\n                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';\n\n            if (! cropEl.parentNode) {\n                vmlEl.appendChild(cropEl);\n            }\n            if (imageEl.parentNode != cropEl) {\n                cropEl.appendChild(imageEl);\n            }\n        }\n        else {\n            imageELStyle.width = round(scaleX * dw) + 'px';\n            imageELStyle.height = round(scaleY * dh) + 'px';\n\n            vmlEl.appendChild(imageEl);\n\n            if (cropEl && cropEl.parentNode) {\n                vmlEl.removeChild(cropEl);\n                this._cropEl = null;\n            }\n        }\n\n        var filterStr = '';\n        var alpha = style.opacity;\n        if (alpha < 1) {\n            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n        }\n        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\n        imageELStyle.filter = filterStr;\n\n        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Append to root\n        append(vmlRoot, vmlEl);\n\n        // Text\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, this.getBoundingRect());\n        }\n    };\n\n    ZImage.prototype.onRemove = function (vmlRoot) {\n        remove(vmlRoot, this._vmlEl);\n\n        this._vmlEl = null;\n        this._cropEl = null;\n        this._imageEl = null;\n\n        this.removeRectText(vmlRoot);\n    };\n\n    ZImage.prototype.onAdd = function (vmlRoot) {\n        append(vmlRoot, this._vmlEl);\n        this.appendRectText(vmlRoot);\n    };\n\n\n    /***************************************************\n     * TEXT\n     **************************************************/\n\n    var DEFAULT_STYLE_NORMAL = 'normal';\n\n    var fontStyleCache = {};\n    var fontStyleCacheCount = 0;\n    var MAX_FONT_CACHE_SIZE = 100;\n    var fontEl = document.createElement('div');\n\n    var getFontStyle = function (fontString) {\n        var fontStyle = fontStyleCache[fontString];\n        if (!fontStyle) {\n            // Clear cache\n            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n                fontStyleCacheCount = 0;\n                fontStyleCache = {};\n            }\n\n            var style = fontEl.style;\n            var fontFamily;\n            try {\n                style.font = fontString;\n                fontFamily = style.fontFamily.split(',')[0];\n            }\n            catch (e) {\n            }\n\n            fontStyle = {\n                style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n                size: parseFloat(style.fontSize || 12) | 0,\n                family: fontFamily || 'Microsoft YaHei'\n            };\n\n            fontStyleCache[fontString] = fontStyle;\n            fontStyleCacheCount++;\n        }\n        return fontStyle;\n    };\n\n    var textMeasureEl;\n    // Overwrite measure text method\n    textContain.measureText = function (text, textFont) {\n        var doc = vmlCore.doc;\n        if (!textMeasureEl) {\n            textMeasureEl = doc.createElement('div');\n            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'\n                + 'padding:0;margin:0;border:none;white-space:pre;';\n            vmlCore.doc.body.appendChild(textMeasureEl);\n        }\n\n        try {\n            textMeasureEl.style.font = textFont;\n        } catch (ex) {\n            // Ignore failures to set to invalid font.\n        }\n        textMeasureEl.innerHTML = '';\n        // Don't use innerHTML or innerText because they allow markup/whitespace.\n        textMeasureEl.appendChild(doc.createTextNode(text));\n        return {\n            width: textMeasureEl.offsetWidth\n        };\n    };\n\n    var tmpRect = new BoundingRect();\n\n    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\n        var style = this.style;\n        var text = style.text;\n        // Convert to string\n        text != null && (text += '');\n        if (!text) {\n            return;\n        }\n\n        var x;\n        var y;\n        var align = style.textAlign;\n        var fontStyle = getFontStyle(style.textFont);\n        // FIXME encodeHtmlAttribute ?\n        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '\n            + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\n        var baseline = style.textBaseline;\n        var verticalAlign = style.textVerticalAlign;\n\n        textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n        // Transform rect to view space\n        var m = this.transform;\n        // Ignore transform for text in other element\n        if (m && !fromTextEl) {\n            tmpRect.copy(rect);\n            tmpRect.applyTransform(m);\n            rect = tmpRect;\n        }\n\n        if (!fromTextEl) {\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n\n                align = align || 'left';\n                baseline = baseline || 'top';\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n        }\n        else {\n            x = rect.x;\n            y = rect.y;\n        }\n        if (verticalAlign) {\n            switch (verticalAlign) {\n                case 'middle':\n                    y -= textRect.height / 2;\n                    break;\n                case 'bottom':\n                    y -= textRect.height;\n                    break;\n                // 'top'\n            }\n            // Ignore baseline\n            baseline = 'top';\n        }\n\n        var fontSize = fontStyle.size;\n        // 1.75 is an arbitrary number, as there is no info about the text baseline\n        switch (baseline) {\n            case 'hanging':\n            case 'top':\n                y += fontSize / 1.75;\n                break;\n            case 'middle':\n                break;\n            default:\n            // case null:\n            // case 'alphabetic':\n            // case 'ideographic':\n            // case 'bottom':\n                y -= fontSize / 2.25;\n                break;\n        }\n        switch (align) {\n            case 'left':\n                break;\n            case 'center':\n                x -= textRect.width / 2;\n                break;\n            case 'right':\n                x -= textRect.width;\n                break;\n            // case 'end':\n                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n                // break;\n            // case 'start':\n                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n                // break;\n            // default:\n            //     align = 'left';\n        }\n\n        var createNode = vmlCore.createNode;\n\n        var textVmlEl = this._textVmlEl;\n        var pathEl;\n        var textPathEl;\n        var skewEl;\n        if (!textVmlEl) {\n            textVmlEl = createNode('line');\n            pathEl = createNode('path');\n            textPathEl = createNode('textpath');\n            skewEl = createNode('skew');\n\n            // FIXME Why here is not cammel case\n            // Align 'center' seems wrong\n            textPathEl.style['v-text-align'] = 'left';\n\n            initRootElStyle(textVmlEl);\n\n            pathEl.textpathok = true;\n            textPathEl.on = true;\n\n            textVmlEl.from = '0 0';\n            textVmlEl.to = '1000 0.05';\n\n            append(textVmlEl, skewEl);\n            append(textVmlEl, pathEl);\n            append(textVmlEl, textPathEl);\n\n            this._textVmlEl = textVmlEl;\n        }\n        else {\n            // 这里是在前面 appendChild 保证顺序的前提下\n            skewEl = textVmlEl.firstChild;\n            pathEl = skewEl.nextSibling;\n            textPathEl = pathEl.nextSibling;\n        }\n\n        var coords = [x, y];\n        var textVmlElStyle = textVmlEl.style;\n        // Ignore transform for text in other element\n        if (m && fromTextEl) {\n            applyTransform(coords, coords, m);\n\n            skewEl.on = true;\n\n            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +\n            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';\n\n            // Text position\n            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);\n            // Left top point as origin\n            skewEl.origin = '0 0';\n\n            textVmlElStyle.left = '0px';\n            textVmlElStyle.top = '0px';\n        }\n        else {\n            skewEl.on = false;\n            textVmlElStyle.left = round(x) + 'px';\n            textVmlElStyle.top = round(y) + 'px';\n        }\n\n        textPathEl.string = encodeHtmlAttribute(text);\n        // TODO\n        try {\n            textPathEl.style.font = font;\n        }\n        // Error font format\n        catch (e) {}\n\n        updateFillAndStroke(textVmlEl, 'fill', {\n            fill: fromTextEl ? style.fill : style.textFill,\n            opacity: style.opacity\n        }, this);\n        updateFillAndStroke(textVmlEl, 'stroke', {\n            stroke: fromTextEl ? style.stroke : style.textStroke,\n            opacity: style.opacity,\n            lineDash: style.lineDash\n        }, this);\n\n        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Attached to root\n        append(vmlRoot, textVmlEl);\n    };\n\n    var removeRectText = function (vmlRoot) {\n        remove(vmlRoot, this._textVmlEl);\n        this._textVmlEl = null;\n    };\n\n    var appendRectText = function (vmlRoot) {\n        append(vmlRoot, this._textVmlEl);\n    };\n\n    var list = [RectText, Displayable, ZImage, Path, Text];\n\n    // In case Displayable has been mixed in RectText\n    for (var i = 0; i < list.length; i++) {\n        var proto = list[i].prototype;\n        proto.drawRectText = drawRectText;\n        proto.removeRectText = removeRectText;\n        proto.appendRectText = appendRectText;\n    }\n\n    Text.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, {\n                x: style.x || 0, y: style.y || 0,\n                width: 0, height: 0\n            }, this.getBoundingRect(), true);\n        }\n        else {\n            this.removeRectText(vmlRoot);\n        }\n    };\n\n    Text.prototype.onRemove = function (vmlRoot) {\n        this.removeRectText(vmlRoot);\n    };\n\n    Text.prototype.onAdd = function (vmlRoot) {\n        this.appendRectText(vmlRoot);\n    };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/vml/graphic.js\n ** module id = 78\n ** module chunks = 0\n **/","\n\nif (!require('../core/env').canvasSupported) {\n    var urn = 'urn:schemas-microsoft-com:vml';\n\n    var createNode;\n    var win = window;\n    var doc = win.document;\n\n    var vmlInited = false;\n\n    try {\n        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n        createNode = function (tagName) {\n            return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n        };\n    }\n    catch (e) {\n        createNode = function (tagName) {\n            return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n        };\n    }\n\n    // From raphael\n    var initVML = function () {\n        if (vmlInited) {\n            return;\n        }\n        vmlInited = true;\n\n        var styleSheets = doc.styleSheets;\n        if (styleSheets.length < 31) {\n            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n        }\n        else {\n            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n        }\n    };\n\n    // Not useing return to avoid error when converting to CommonJS module\n    module.exports = {\n        doc: doc,\n        initVML: initVML,\n        createNode: createNode\n    };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/vml/core.js\n ** module id = 79\n ** module chunks = 0\n **/","/**\n * VML Painter.\n *\n * @module zrender/vml/Painter\n */\n\n\n\n    var zrLog = require('../core/log');\n    var vmlCore = require('./core');\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    /**\n     * @alias module:zrender/vml/Painter\n     */\n    function VMLPainter(root, storage) {\n\n        vmlCore.initVML();\n\n        this.root = root;\n\n        this.storage = storage;\n\n        var vmlViewport = document.createElement('div');\n\n        var vmlRoot = document.createElement('div');\n\n        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\n        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\n        root.appendChild(vmlViewport);\n\n        this._vmlRoot = vmlRoot;\n        this._vmlViewport = vmlViewport;\n\n        this.resize();\n\n        // Modify storage\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            if (el) {\n                el.onRemove && el.onRemove(vmlRoot);\n            }\n        };\n\n        storage.addToMap = function (el) {\n            // Displayable already has a vml node\n            el.onAdd && el.onAdd(vmlRoot);\n\n            oldAddToMap.call(storage, el);\n        };\n\n        this._firstPaint = true;\n    }\n\n    VMLPainter.prototype = {\n\n        constructor: VMLPainter,\n\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._vmlViewport;\n        },\n\n        /**\n         * 刷新\n         */\n        refresh: function () {\n\n            var list = this.storage.getDisplayList(true, true);\n\n            this._paintList(list);\n        },\n\n        _paintList: function (list) {\n            var vmlRoot = this._vmlRoot;\n            for (var i = 0; i < list.length; i++) {\n                var el = list[i];\n                if (el.invisible || el.ignore) {\n                    if (!el.__alreadyNotVisible) {\n                        el.onRemove(vmlRoot);\n                    }\n                    // Set as already invisible\n                    el.__alreadyNotVisible = true;\n                }\n                else {\n                    if (el.__alreadyNotVisible) {\n                        el.onAdd(vmlRoot);\n                    }\n                    el.__alreadyNotVisible = false;\n                    if (el.__dirty) {\n                        el.beforeBrush && el.beforeBrush();\n                        (el.brushVML || el.brush).call(el, vmlRoot);\n                        el.afterBrush && el.afterBrush();\n                    }\n                }\n                el.__dirty = false;\n            }\n\n            if (this._firstPaint) {\n                // Detached from document at first time\n                // to avoid page refreshing too many times\n\n                // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n                this._vmlViewport.appendChild(vmlRoot);\n                this._firstPaint = false;\n            }\n        },\n\n        resize: function (width, height) {\n            var width = width == null ? this._getWidth() : width;\n            var height = height == null ? this._getHeight() : height;\n\n            if (this._width != width || this._height != height) {\n                this._width = width;\n                this._height = height;\n\n                var vmlViewportStyle = this._vmlViewport.style;\n                vmlViewportStyle.width = width + 'px';\n                vmlViewportStyle.height = height + 'px';\n            }\n        },\n\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this._vmlRoot =\n            this._vmlViewport =\n            this.storage = null;\n        },\n\n        getWidth: function () {\n            return this._width;\n        },\n\n        getHeight: function () {\n            return this._height;\n        },\n\n        clear: function () {\n            if (this._vmlViewport) {\n                this.root.removeChild(this._vmlViewport);\n            }\n        },\n\n        _getWidth: function () {\n            var root = this.root;\n            var stl = root.currentStyle;\n\n            return ((root.clientWidth || parseInt10(stl.width))\n                    - parseInt10(stl.paddingLeft)\n                    - parseInt10(stl.paddingRight)) | 0;\n        },\n\n        _getHeight: function () {\n            var root = this.root;\n            var stl = root.currentStyle;\n\n            return ((root.clientHeight || parseInt10(stl.height))\n                    - parseInt10(stl.paddingTop)\n                    - parseInt10(stl.paddingBottom)) | 0;\n        }\n    };\n\n    // Not supported methods\n    function createMethodNotSupport(method) {\n        return function () {\n            zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n        };\n    }\n\n    var notSupportedMethods = [\n        'getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers',\n        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'\n    ];\n\n    for (var i = 0; i < notSupportedMethods.length; i++) {\n        var name = notSupportedMethods[i];\n        VMLPainter.prototype[name] = createMethodNotSupport(name);\n    }\n\n    module.exports = VMLPainter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/vml/Painter.js\n ** module id = 80\n ** module chunks = 0\n **/"],"sourceRoot":"/source/"}