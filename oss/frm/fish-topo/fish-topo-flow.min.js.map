{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","fish-topo-flow.js","webpack:/webpack/bootstrap e3773754ce41a5176349","webpack:///index.flow.js","webpack:///lib/fish-topo-flow/lib/FishTopoFlow.js","webpack:///lib/fish-topo-core/lib/polyfill.js","webpack:///lib/fish-topo-core/lib/graphic.js","webpack:///~/.3.6.3@zrender/lib/core/util.js","webpack:///~/.3.6.3@zrender/lib/tool/path.js","webpack:///~/.3.6.3@zrender/lib/graphic/Path.js","webpack:///~/.3.6.3@zrender/lib/graphic/Displayable.js","webpack:///~/.3.6.3@zrender/lib/graphic/Style.js","webpack:///~/.3.6.3@zrender/lib/Element.js","webpack:///~/.3.6.3@zrender/lib/core/guid.js","webpack:///~/.3.6.3@zrender/lib/mixin/Eventful.js","webpack:///~/.3.6.3@zrender/lib/mixin/Transformable.js","webpack:///~/.3.6.3@zrender/lib/core/matrix.js","webpack:///~/.3.6.3@zrender/lib/core/vector.js","webpack:///~/.3.6.3@zrender/lib/mixin/Animatable.js","webpack:///~/.3.6.3@zrender/lib/animation/Animator.js","webpack:///~/.3.6.3@zrender/lib/animation/Clip.js","webpack:///~/.3.6.3@zrender/lib/animation/easing.js","webpack:///~/.3.6.3@zrender/lib/tool/color.js","webpack:///~/.3.6.3@zrender/lib/core/LRU.js","webpack:///~/.3.6.3@zrender/lib/core/log.js","webpack:///~/.3.6.3@zrender/lib/config.js","webpack:///~/.3.6.3@zrender/lib/graphic/mixin/RectText.js","webpack:///~/.3.6.3@zrender/lib/graphic/helper/text.js","webpack:///~/.3.6.3@zrender/lib/contain/text.js","webpack:///~/.3.6.3@zrender/lib/core/BoundingRect.js","webpack:///~/.3.6.3@zrender/lib/graphic/helper/image.js","webpack:///~/.3.6.3@zrender/lib/graphic/helper/roundRect.js","webpack:///~/.3.6.3@zrender/lib/core/PathProxy.js","webpack:///~/.3.6.3@zrender/lib/core/curve.js","webpack:///~/.3.6.3@zrender/lib/core/bbox.js","webpack:///~/.3.6.3@zrender/lib/contain/path.js","webpack:///~/.3.6.3@zrender/lib/contain/line.js","webpack:///~/.3.6.3@zrender/lib/contain/cubic.js","webpack:///~/.3.6.3@zrender/lib/contain/quadratic.js","webpack:///~/.3.6.3@zrender/lib/contain/arc.js","webpack:///~/.3.6.3@zrender/lib/contain/util.js","webpack:///~/.3.6.3@zrender/lib/contain/windingLine.js","webpack:///~/.3.6.3@zrender/lib/graphic/Pattern.js","webpack:///~/.3.6.3@zrender/lib/tool/transformPath.js","webpack:///~/.3.6.3@zrender/lib/graphic/Gradient.js","webpack:///~/.3.6.3@zrender/lib/mixin/Draggable.js","webpack:///~/.3.6.3@zrender/lib/container/Group.js","webpack:///~/.3.6.3@zrender/lib/graphic/Image.js","webpack:///~/.3.6.3@zrender/lib/graphic/Text.js","webpack:///~/.3.6.3@zrender/lib/graphic/shape/Circle.js","webpack:///~/.3.6.3@zrender/lib/graphic/shape/Sector.js","webpack:///~/.3.6.3@zrender/lib/graphic/helper/fixClipWithShadow.js","webpack:///~/.3.6.3@zrender/lib/core/env.js","webpack:///~/.3.6.3@zrender/lib/graphic/shape/Ring.js","webpack:///~/.3.6.3@zrender/lib/graphic/shape/Polygon.js","webpack:///~/.3.6.3@zrender/lib/graphic/helper/poly.js","webpack:///~/.3.6.3@zrender/lib/graphic/helper/smoothSpline.js","webpack:///~/.3.6.3@zrender/lib/graphic/helper/smoothBezier.js","webpack:///~/.3.6.3@zrender/lib/graphic/shape/Polyline.js","webpack:///~/.3.6.3@zrender/lib/graphic/shape/Rect.js","webpack:///~/.3.6.3@zrender/lib/graphic/shape/Line.js","webpack:///~/.3.6.3@zrender/lib/graphic/shape/BezierCurve.js","webpack:///~/.3.6.3@zrender/lib/graphic/shape/Arc.js","webpack:///~/.3.6.3@zrender/lib/graphic/LinearGradient.js","webpack:///~/.3.6.3@zrender/lib/graphic/RadialGradient.js","webpack:///~/.3.6.3@zrender/lib/graphic/States.js","webpack:///lib/fish-topo-core/lib/minimap.js","webpack:///lib/fish-topo-core/lib/util.js","webpack:///lib/fish-topo-core/lib/Point.js","webpack:///lib/fish-topo-core/lib/LineStruct.js","webpack:///lib/fish-topo-flow/lib/ExtensionApi.js","webpack:///~/.3.6.3@zrender/lib/zrender.js","webpack:///~/.3.6.3@zrender/lib/Handler.js","webpack:///~/.3.6.3@zrender/lib/Storage.js","webpack:///~/.3.6.3@zrender/lib/core/timsort.js","webpack:///~/.3.6.3@zrender/lib/animation/Animation.js","webpack:///~/.3.6.3@zrender/lib/core/event.js","webpack:///~/.3.6.3@zrender/lib/animation/requestAnimationFrame.js","webpack:///~/.3.6.3@zrender/lib/dom/HandlerProxy.js","webpack:///~/.3.6.3@zrender/lib/core/GestureMgr.js","webpack:///~/.3.6.3@zrender/lib/Painter.js","webpack:///~/.3.6.3@zrender/lib/Layer.js","webpack:///lib/fish-topo-core/lib/manager/OperationNode.js","webpack:///lib/fish-topo-core/lib/Node.js","webpack:///lib/fish-topo-core/lib/shapes/Connector.js","webpack:///lib/fish-topo-core/lib/shapes/Symbol.js","webpack:///lib/fish-topo-core/lib/shapes/Handle.js","webpack:///lib/fish-topo-core/lib/shapes/EffectLine.js","webpack:///lib/fish-topo-core/lib/shapes/ConnectionPoint.js","webpack:///lib/fish-topo-core/lib/model.js","webpack:///lib/fish-topo-core/lib/clazz.js","webpack:///lib/fish-topo-core/lib/manager/IconOperation.js","webpack:///lib/fish-topo-flow/lib/manager/FlowConnectionManager.js","webpack:///lib/fish-topo-core/lib/manager/ConnectionManager.js","webpack:///lib/fish-topo-core/lib/Log.js","webpack:///lib/fish-topo-flow/lib/util/FlowConstants.js","webpack:///lib/fish-topo-flow/lib/util/FlowUtil.js","webpack:///lib/fish-topo-flow/lib/node/GroupNode.js","webpack:///lib/fish-topo-flow/lib/node/flowNode.js","webpack:///lib/fish-topo-flow/lib/node/Rect.js","webpack:///lib/fish-topo-flow/lib/node/Circle.js","webpack:///lib/fish-topo-flow/lib/node/Image.js","webpack:///lib/fish-topo-flow/lib/node/Text.js","webpack:///lib/fish-topo-flow/lib/node/Sector.js","webpack:///lib/fish-topo-flow/lib/node/Ring.js","webpack:///lib/fish-topo-flow/lib/node/Ellipse.js","webpack:///lib/fish-topo-flow/lib/node/Heart.js","webpack:///lib/fish-topo-flow/lib/node/Droplet.js","webpack:///lib/fish-topo-flow/lib/node/Rose.js","webpack:///lib/fish-topo-flow/lib/node/Isogon.js","webpack:///lib/fish-topo-flow/lib/node/Polygon.js","webpack:///lib/fish-topo-flow/lib/node/Line.js","webpack:///lib/fish-topo-flow/lib/node/Polyline.js","webpack:///lib/fish-topo-flow/lib/node/BezierCurve.js","webpack:///lib/fish-topo-flow/lib/node/Arc.js","webpack:///lib/fish-topo-flow/lib/node/Star.js","webpack:///lib/fish-topo-flow/lib/node/Trochoid.js","webpack:///lib/fish-topo-flow/lib/node/Path.js","webpack:///lib/fish-topo-flow/lib/node/IconButton.js","webpack:///lib/fish-topo-flow/lib/link/flowLink.js","webpack:///lib/fish-topo-flow/lib/link/Link.js","webpack:///lib/fish-topo-flow/lib/Flow.js","webpack:///lib/fish-topo-flow/lib/link/Fold.js","webpack:///lib/fish-topo-flow/lib/link/Curve.js","webpack:///lib/fish-topo-core/lib/manager/LineOperationManager.js","webpack:///lib/fish-topo-flow/lib/layout/layout.js","webpack:///lib/fish-topo-flow/lib/layout/HLayout.js","webpack:///lib/fish-topo-flow/lib/layout/VLayout.js","webpack:///lib/fish-topo-flow/lib/layout/TreeLayout.js","webpack:///lib/fish-topo-flow/lib/data/Tree.js","webpack:///lib/fish-topo-flow/lib/layout/treeHelper.js","webpack:///lib/fish-topo-flow/lib/layout/ForceLayout.js","webpack:///lib/fish-topo-flow/lib/layout/forceHelper.js","webpack:///lib/fish-topo-core/lib/ImagePool.js","webpack:///lib/fish-topo-flow/lib/tooltip/TooltipView.js","webpack:///lib/fish-topo-flow/lib/tooltip/TooltipContent.js","webpack:///lib/fish-topo-flow/lib/tooltip/globalListener.js","webpack:///lib/fish-topo-flow/lib/tooltip/TooltipModel.js","webpack:///~/.3.6.3@zrender/lib/vml/vml.js","webpack:///~/.3.6.3@zrender/lib/vml/graphic.js","webpack:///~/.3.6.3@zrender/lib/vml/core.js","webpack:///~/.3.6.3@zrender/lib/vml/Painter.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","FishTopoFlow","dom","opts","group","_dom","nowZoom","canScale","eagleEye","eagleEyeNode","initScaleRatio","operationNode","selectedNode","allNodes","minimap","_api","ExtensionAPI","connectionManager","FlowConnectionManager","lineOperationManager","LineOperationManager","_zr","zrender","init","renderer","devicePixelRatio","_tooltipView","ToolTipView","TooltipModel","tooltip","Shape","graphic","model","Model","set","Constants","ELEMENT_TYPE","MODE","options","Eventful","Minimap","util","Point","zrUtil","OperationNode","FlowUtil","eventTool","Connector","Flow","flowNode","flowLink","layout","textContain","ImagePool","actions","keyCode","ENTER","ESCAPE","fishTopoProto","prototype","getDom","getZr","getWidth","getHeight","isDisposed","_disposed","dispose","instances","resize","dispatchAction","payload","type","option","key","value","arguments","length","clone","get","setRoam","Group","isBg","roam","zrMove","add","zrScale","connectors","on","e","_removeOperationNode","shape","target","isLink","connector","clearSelectCon","_isLineOperationIcon","hideAllLineOperation","bind","nodeTarget","isNode","params","event","trigger","argument","bindOperation","lineNode","off","toJson","fromJson","json","clear","setBackground","BACKGROUND","layoutRootNode","CHILDS","addNode","node","opt","_trigger","addConnectorAttrEvent","isGroupNode","willRender","groupOptions","OPTIONS","mergedImage","groupReplaceImage","Image","style","image","text","textPosition","position","drag","_relationImage","setTimeout","hide","merged","each","child","addNodeAttrEvent","childDraggable","isUndefined","selectable","relative","_handleRelativePostion","hoverStyle","setHoverStyle","hoverAnimation","isAnimationEnabled","addHoverAnimation","that","isEdit","linkModify","connectorForbidEdit","textEditable","connectorEdit","attr","targeNode","nodeClickHandler","cancelBubble","isInGroup","parentNode","parent","nodeEdit","push","parentEl","containerInfo","width","height","getBoundingRect","positionElement","padding","boundingMode","bounding","_getParentZr","parentZr","remove","cleanup","i","deleteSelectCon","connectorMap","addLineIcon","addIcon","lineDefaultIcon","addLineDeleteIcon","addLineChangeIcon","addDeleteIcon","addChangeLineTypeIcon","changeSelectConnectorType","lineType","nextLineType","line","selConnector","originLineType","arrLineType","TYPE_STRAIGHT","TYPE_JAGGED","TYPE_CURVE","index","indexOf","deleteLine","merge","nextLine","createConnectorByNodes","startNode","endNode","icons","initOperationNode","ARROW_DRAGSTART","x","offsetX","y","offsetY","arrow","rEndPoint","manageTempConnector","ARROW_DRAG","ARROW_DRAGEND","isHover","rectContain","findHover","list","excludes","isExclude","ignore","targetNode","show","removeTempConnector","connectOptions","data","DELETE_CLICK","removeNode","delNode","lineOperationIcon","deleteByLine","splice","linkType","Link","callback","isFunction","apply","concat","shapeRect","getRect","refreshPostion","_groupDragHandler","nowGroupPosition","groupPositionX","groupPositionY","moveHandler","gx","gy","min","max","sX","sY","updataSelectionPosition","endDragHandler","draggingTarget","isdraggable","_nodeDragHandler","isMove","_startX","_startY","nodeMessage","movePosition","moveX","moveY","modifyGroupRect","alarm","newAlarmPosition","refreshLineByNode","truncPosition","openEagleEye","createNode","creatNode","userData","setUserData","childOfName","name","arrResult","childrenNode","childrenLine","j","findElements","cb","context","arr","childL","imageUrl","isRepeat","substr","document","createElement","getContext","imageShape","Rect","fill","cursor","z","backgroundColor","gridLineGroup","gridLine","backgroundImage","backgroundRepeat","imageShape1","scale","opacity","pixel","widthLen","parseInt","lineX","Line","x1","y1","x2","y2","lineDash","draggable","heightLen","lineY","createLink","creatLink","USERDATA","thisConnector","lineText","textarea","createTextArea","border","innerHTML","setStyle","appendChild","textRect","textFont","lineHeight","top","left","focus","select","$","_textareaResize","thisNode","isNotSetText","nodeText","nodeRect","maxWidth","offestI","textAlign","offestP","onkeyup","blur","onblur","handleWrap","whiteSpace","overflow","spellcheck","spanNode","content","split","result","val","valLength","innerVal","tempWidth","conWidth","pre","innerI","charAt","Number","substring","removeChild","minWidth","scrollHeight","setShape","createAlarm","creatAlarm","stroke","textFill","textBaseline","groupWidth","groupHeight","points","Polyline","textBackground","groupPosition","ALARM","RELATIONID","ID","toDataURL","Circle","initScale","groupMaxWidth","groupMaxHeight","rangeWidth","rangeHeight","initRatio","pos","Math","abs","distance","zoomDelta1","zoom","zoomDelta","isNaN","zoomScale","_zoom","setScale","stop","wheelDelta","zoomX","zoomY","newZoom","toFixed","updataSelection","groupScale","imgSrc","updataMap","selection","addEventListener","startX","clientX","startY","clientY","minimapLeft","minimapTop","eagleEyeMove","updataGroupPosition","eagleEyeUp","removeEventListener","mixin","idBase","Date","DOM_ATTRIBUTE_KEY","fishTopoFlow","version","dependencies","Error","defaults","beforeDelete","beforeCreate","setAttribute","getInstanceByDom","getAttribute","chart","topo","isDom","registerFlowNode","link","constants","initImagePool","Function","oThis","TypeError","aArgs","Array","slice","fToBind","fNOP","fBound","window","Element","String","endsWith","searchString","subjectString","toString","isFinite","floor","lastIndex","doSingleEnterHover","el","__isHover","__hoverStlDirty","__hoverStl","lift","colorTool","Gradient","normalStyle","hasOwnProperty","__normalStl","z2","doSingleLeaveHover","normalStl","doEnterHover","traverse","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","props","animatableModel","postfix","duration","getShallow","animationEasing","animateTo","pathTool","round","Path","matrix","vector","Draggable","Util","Text","Sector","Ring","Polygon","BezierCurve","Arc","LinearGradient","RadialGradient","BoundingRect","States","extendShape","extend","extendPath","pathData","extendFromString","makePath","rect","path","createFromString","boundingRect","aspect","cx","cy","resizePath","inherits","mergePath","applyTransform","pathRect","calculateTransform","subPixelOptimizeLine","param","subPixelOptimize","lineWidth","subPixelOptimizeRect","originX","originY","originWidth","originHeight","positiveOrNegative","doubledPosition","setNormalStyle","setText","textStyle","labelModel","color","labelPosition","labelColor","textStyleModel","getModel","textDistance","getFont","getTextColor","updateProps","curry","initProps","getTransform","ancestor","mat","identity","mul","getLocalTransform","vertex","transform","invert","transformDirection","direction","hBase","vBase","source","typeStr","objToString","len","TYPED_ARRAY","Ctor","constructor","from","BUILTIN_OBJECT","isPrimitive","overwrite","isObject","targetProp","sourceProp","isArray","isBuiltInObject","mergeAll","targetAndSources","overlay","createCanvas","_ctx","array","clazz","baseClazz","F","clazzPrototype","prop","superClass","isArrayLike","obj","forEach","nativeForEach","map","nativeMap","reduce","memo","nativeReduce","filter","nativeFilter","find","func","args","nativeSlice","isString","nodeType","ownerDocument","eqNaN","retrieve","values","retrieve2","value0","value1","retrieve3","value2","normalizeCssArray","assert","condition","message","setAsPrimitive","primitiveKey","HashMap","createHashMap","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","Object","arrayProto","HASH_MAP_PREFIX","HASH_MAP_PREFIX_LENGTH","prefixedKey","removeKey","noop","processArc","fa","fs","rx","ry","psiDeg","cmd","psi","PI","xp","mathCos","mathSin","yp","lambda","mathSqrt","f","cxp","cyp","theta","vAngle","u","v","dTheta","vRatio","addData","createPathProxyFromString","n","cs","replace","cc","RegExp","prevCmd","cpx","cpy","PathProxy","CMD","str","shift","parseFloat","ctlPtx","ctlPty","L","M","C","Q","A","Z","toStatic","createPathOptions","pathProxy","buildPath","setData","ctx","rebuildPath","transformPath","dirty","sqrt","sin","cos","vMag","acos","pathEls","pathList","pathEl","createPathProxy","__dirtyPath","pathBundle","appendPath","Displayable","pathContain","Pattern","getCanvasPattern","pathProxyForDraw","strokeContainThreshold","brush","prevEl","hasStroke","hasFill","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","__dirty","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDashOffset","ctxLineDash","setLineDash","getGlobalScale","beginPath","setLineDashOffset","restoreTransform","drawRectText","shapeCfg","inBundle","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","copy","w","lineScale","strokeNoScale","getLineScale","contain","localPos","transformCoordToLocal","containStroke","dirtyPath","__zr","refresh","__clipTarget","animateShape","loop","animate","attrKV","Sub","extendFrom","defaultShape","thisShape","Style","__clipPaths","RectText","invisible","zlevel","dragging","silent","culling","rectHover","progressive","beforeBrush","afterBrush","coord","animateStyle","useStyle","createLinearGradient","global","canvasGradient","createRadialGradient","r","STYLE_COMMON_PROPS","host","shadowBlur","shadowOffsetX","shadowOffsetY","font","fontStyle","fontWeight","fontSize","fontFamily","textTag","textStroke","textWidth","textHeight","textStrokeWidth","textLineHeight","textOffset","textVerticalAlign","textShadowColor","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textBoxShadowColor","textBoxShadowBlur","textBoxShadowOffsetX","textBoxShadowOffsetY","transformText","textRotation","textOrigin","textBackgroundColor","textBorderColor","textBorderWidth","textBorderRadius","textPadding","rich","truncate","blend","prevStyle","firstDraw","styleName","globalAlpha","globalCompositeOperation","otherStyle","newStyle","method","colorStops","addColorStop","offset","styleProto","guid","Transformable","Animatable","clipPath","drift","dx","dy","decomposeTransform","beforeUpdate","afterUpdate","update","updateTransform","setClipPath","zr","addSelfToZr","removeClipPath","removeSelfFromZr","animators","animation","addAnimator","removeAnimator","idStart","arrySlice","_$handlers","one","handler","_h","h","isSilent","newList","l","argLen","triggerWithContext","isNotAroundZero","EPSILON","mIdentity","rotation","origin","transformableProto","needLocalTransform","parentHasTransform","create","invTransform","dpr","tmpTransform","sx","sy","atan2","v2","transformCoordToGlobal","rotate","ArrayCtor","Float32Array","out","m1","m2","out0","out1","out2","out3","out4","out5","translate","a","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","b","v1","scaleAndAdd","sub","lenSquare","div","dot","s","normalize","d","distanceSquare","negate","lerp","t","lengthSquare","dist","distSquare","Animator","log","animatingShape","pathSplitted","animator","during","done","stopAnimation","forwardToLast","time","delay","easing","forceAnimate","count","_animateToShallow","start","objShallow","propertyCount","when","defaultGetter","defaultSetter","interpolateNumber","p0","p1","percent","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isArraySame","catmullRomInterpolateArray","p2","p3","t2","t3","catmullRomInterpolate","v0","cloneValue","ret","rgba2String","rgba","join","getArrayDim","keyframes","lastValue","createTrackClip","oneTrackDone","propName","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","sort","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","parse","_target","lastFrame","lastFramePercent","onframe","frame","range","clip","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","pause","_paused","resume","isPaused","_doneCallback","doneList","lastClip","self","clipCount","addClip","oldOnFrame","clipList","removeClip","getClips","_life","_initialized","gap","onrestart","_pausedTime","easingFuncs","step","globalTime","deltaTime","_startTime","easingFunc","schedule","fire","restart","_needsRemove","remainder","eventType","arg","linear","k","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","pow","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseCssFloat","cssHueToRgb","lerpNumber","setRgba","g","copyRgba","putToCache","colorStr","rgbaArr","lastRemovedArr","colorCache","put","cached","toLowerCase","kCSSColorTable","op","ep","fname","alpha","pop","hsla2rgba","iv","hsla","rgba2hsla","H","S","R","G","B","vMin","vMax","delta","deltaR","deltaG","deltaB","level","colorArr","stringify","toHex","fastLerp","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","fullOutput","modifyHSL","modifyAlpha","arrColor","LRU","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","fastMapToColor","mapToColor","LinkedList","head","tail","_len","linkedListProto","insert","entry","Entry","insertEntry","next","prev","maxSize","_list","_map","_maxSize","_lastRemovedEntry","LRUProto","removed","leastUsedEntry","config","debugMode","console","textHelper","tmpRect","normalizeTextStyle","needDrawText","save","renderText","restore","normalizeStyle","makeFont","VALID_TEXT_ALIGN","VALID_TEXT_VERTICAL_ALIGN","renderPlainText","hostEl","setCtx","DEFAULT_FONT","contentBlock","__textCotentBlock","parsePlainText","outerHeight","textLines","lines","boxPos","getBoxPosition","baseX","baseY","applyTextRotation","boxY","adjustTextY","textX","textY","needDrawBg","needDrawBackground","outerWidth","boxX","adjustTextX","drawBackground","getTextXForPadding","getStroke","getFill","strokeText","fillText","renderRichText","parseRichText","drawRichText","contentWidth","xLeft","lineTop","xRight","token","tokens","tokenCount","usedWidth","lineXLeft","lineXRight","placeToken","tokenStyle","isLineHolder","isPlainBg","roundRectHelper","closePath","imageHelper","createOrUpdateImage","onBgImageLoaded","isImageReady","drawImage","blockHeiht","parsePercent","res","adjustTextPositionOnRect","maxValue","lastIndexOf","right","center","bottom","middle","helper","getTextWidth","textWidthCache","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getTextRect","getRichTextRect","getPlainTextRect","halfHeight","truncateText","containerWidth","ellipsis","prepareTruncateOptions","truncateSingleLine","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","getLineHeight","truncOuterHeight","truncOuterWidth","STYLE_REG","exec","matchedIndex","pushTokens","contentHeight","pendingList","stlPadding","truncateWidth","truncateHeight","tokenHeight","tokenWidth","tokenWidthNotSpecified","percentWidth","bgImg","findExistImage","paddingW","remianTruncWidth","block","isEmptyStr","strs","tokensLen","vec2","v2ApplyTransform","mathMin","mathMax","union","other","lt","rb","lb","rt","maxX","maxY","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","imageOnLoad","cachedImgObj","__cachedImgObj","onload","pending","pendingWrap","cbPayload","globalImageCache","newImageOrSrc","__zrImageSrc","src","r1","r2","r3","r4","total","moveTo","lineTo","quadraticCurveTo","curve","bbox","min2","max2","mathAbs","hasTypedArray","notSaveData","_saveData","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","x3","y3","_dashedBezierTo","_dashedQuadraticTo","arc","startAngle","endAngle","anticlockwise","arcTo","radius","x0","y0","lineDashSum","appendSize","appendPathData","_expandData","_prevCmd","newData","dash","idx","dashSum","nDash","cubicAt","bezierLen","tmpLen","MAX_VALUE","xi","yi","fromLine","fromCubic","fromQuadratic","fromArc","ux","uy","scaleX","scaleY","isEllipse","isAroundZero","onet","cubicDerivativeAt","cubicRootAt","roots","t1","disc","K","discSqrt","Y1","Y2","mathPow","ONE_THIRD","T","ASqrt","tmp","THREE_SQRT","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","d1","d2","interval","Infinity","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","v2Create","end","extremity","PI2","fromPoints","xDim","yDim","tx","ty","vec2Min","vec2Max","diff","angle","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","x_","windingQuadratic","y_","windingArc","dir","normalizeRadian","containPath","isStroke","windingLine","cubic","quadratic","_x","_l","_a","_b","_s","repeat","createPattern","nPoint","mathAtan2","_dragStart","_drag","_dragEnd","topTarget","_draggingTarget","_y","dispatchToElement","dropTarget","lastDropTarget","_dropTarget","_children","__storage","isGroup","children","childAt","childCount","_doAdd","addBefore","nextSibling","storage","addToStorage","addChildrenToStorage","delFromStorage","delChildrenFromStorage","removeAll","eachChild","includeChildren","tmpMat","childRect","ZImage","_image","sWidth","sHeight","shadowColor","fixClipWithShadow","r0","clockwise","unitX","unitY","env","shadowTemp","orignalBrush","browser","ie","modified","clipPaths","detect","ua","os","firefox","match","edge","weChat","test","canvasSupported","touchEventsSupported","pointerEventsSupported","navigator","userAgent","polyHelper","smooth","smoothConstraint","smoothSpline","smoothBezier","controlPoints","cp1","cp2","interpolate","isLoop","segs","w2","w3","v2Min","v2Max","v2Scale","v2Distance","v2Add","constraint","prevPoint","nextPoint","cps","point","d0","sum","cp0","pointAt","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","curveTool","tangentAt","globalCoord","vec2Copy","transitionProperties","TransitionObject","_fromStr","property","GraphicStates","_states","_el","_subStates","_transitionAnimators","initialState","_initialState","optsStates","states","state","_addState","setState","_currentState","transition","_extendFromInitial","transiting","_stopTransition","prevState","onleave","onenter","getState","transitionState","styleShapeReg","propPathMap","transitionCfg","animatingCount","animationDone","_animProp","subProp","subStates","subPropKey","stateObj","elObj","availableProp","transitionAnimators","dealy","addSubStates","removeSubStates","bigCanvas","ratio","groupRatio","img","selectPosition","render","eagleEyeNodeWidth","eagleEyeNodeHeight","marginTop","marginLeft","background","backgroundSize","selectWidth","selectHeight","offectLeft","offectTop","newGroup","positionX","positionY","getUUID","chars","uuid","rnd","random","getMaxLineLength","getPolylineLength","lenght","NaN","orthogonalPath","lineIntersectsLine","l1","l2","startPoint","endPoint","contains","a1","b1","a2","b2","polylineIntersectsRectangle","bounds","closedPolyline","tempLine","tempLine1","scorePath","score","signum","forwardPath","traslatePoints","isRevert","newPoints","point1","rotationMatrix","mReturn","translationMatrix","scaleMatrix","getEndPoint","getConnectorPoints","getSoltPoints","tangentRotation","collinearity","precission","determinant","enhancedRound","number","decimals","getLength","getAngle","centerPoint","outsidePoint","atan","isCalcParent","boundRect","randomColor","arrHex","strHex","collinearReduction","cloneArray","template","settings","oldSettings","templateSettings","matcher","escape","noMatch","evaluate","escaper","escapeChar","variable","isEmpty","Class","StackedMap","createNew","stack","arrKey","keys","removeItem","item","removeTop","escapes","'","\\","\r","\n"," "," ","proto","member","fn","base","subclass","load","o","newPoint","loadArray","oldX","oldY","equals","anotherPoint","near","getPoints","oType","newLine","contructor","anotherLine","endX","endY","closestX","closestY","getPoint","Xp","Yp","instance","apiList","delInstance","Handler","Storage","Animation","HandlerProxy","useVML","painterCtors","canvas","ZRender","getInstance","registerPainter","rendererType","vml","painter","handerProxy","getViewportRoot","stage","flush","_needsRefresh","oldDelFromStorage","oldAddToStorage","getId","addRoot","delRoot","configLayer","zLevel","refreshImmediately","_needsRefreshHover","refreshHoverImmediately","addHover","refreshHover","removeHover","clearHover","clearAnimation","pathToImage","setCursorStyle","cursorStyle","eventName","eventHandler","makeEventPacket","eveType","targetInfo","zrX","zrY","gestureEvent","pinchX","pinchY","pinchScale","zrDelta","zrByTouch","which","EmptyProxy","displayable","SILENT","handlerNames","proxy","painterRoot","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","lastHovered","lastHoveredTarget","hovered","hoveredTarget","setCursor","mouseout","innerDom","element","toElement","relatedTarget","dispatch","eventArgs","eventPacket","eachOtherLayer","layer","exclude","getDisplayList","hoverCheckResult","_downEl","_downPoint","_upEl","shapeCompareFunc","timsort","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","displayList","_updateAndAddDisplayable","userSetClipPath","currentClipPath","parentClipPath","_renderList","displayableSortFunc","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","mid","pivot","gallopLeft","hint","lastOffset","maxOffset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","Dispatcher","requestAnimationFrame","_clips","_running","_time","_pauseStart","clips","_update","getTime","deferredEvents","deferredClips","_startLoop","getBoundingClientRect","clientToLocal","calculate","defaultGetZrXY","layerX","layerY","box","normalizeEvent","isTouch","touch","targetTouches","changedTouches","detail","button","undefined","MOUSE_EVENT_REG","isDomLevel2","attachEvent","detachEvent","notLeftMouse","preventDefault","stopPropagation","returnValue","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","eventNameFix","processGesture","gestureMgr","_gestureMgr","gestureInfo","recognize","setTouchTimer","_touching","clearTimeout","_touchTimer","isPointerFromTouch","pointerType","initDomHandler","makeMouseHandler","touchHandlerNames","_handlers","domHandlers","pointerHandlerNames","mouseHandlerNames","HandlerDomProxy","mountHandlers","GestureMgr","TOUCH_CLICK_DELAY","pointerEventNames","pointerdown","pointerup","pointermove","pointerout","nm","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","pointPair","eventUtil","_track","_doTrack","_recognize","touches","trackItem","recognizers","pinch","track","pinchEnd","pinchPre","pinchCenter","parseInt10","isLayerValid","__builtin__","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","createRoot","domRoot","cssText","Layer","MAX_PROGRESSIVE_LAYER_NUMBER","Painter","singleCanvas","nodeName","toUpperCase","_opts","_singleCanvas","rootStyle","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","initContext","_domRoot","_getSize","_progressiveLayers","_hoverlayer","_hoverElements","getType","isSingleCanvas","getViewportRootOffset","viewportRoot","offsetLeft","offsetTop","paintAll","_paintList","_startProgessive","__hoverMir","elMirror","__from","hoverElements","hoverLayer","getLayer","scope","originalEl","_doPaintEl","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuiltinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","virtual","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","elCount","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","display","clearLayer","getRenderedCanvas","findAndDrawOtherLayer","smaller","larger","intermediateLayer","renderToCanvas","imageLayer","pixelRatio","clearColor","whIdx","wh","cwh","plt","prb","stl","defaultView","getComputedStyle","shadowBlurSize","leftMargin","rightMargin","topMargin","bottomMargin","clearRect","pathTransform","ImageShape","imgShape","returnFalse","createDom","newDom","newDomStyle","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","__currentValues","createBackBuffer","clearAll","haveMotionBLur","clearColorGradientOrPattern","__canvasGradient","fillRect","api","forbidEdit","Node","icon","symbolUtil","DEL","opicons","STRAIGHT","STRAIGHT_IMG","JAGGED","JAGGED_IMG","CURVE","CURVE_IMG","DEL_SVG","STRAIGHT_SVG","JAGGED_SVG","CURVE_SVG","renderBase","renderOther","createOperation","me","selectStyle","virtualRect","isSelfComputePos","operationIcons","opIconInstance","operationIcon","iconPath","MOUSE_EVENT_NAMES","eveName","createSymbol","rbPoint","nodeItem","refreshPositionOther","nodeShapeX","nodeSahpeY","resourceId","drawText","textName","bpmnInfo","refreshText","toJSON","defaultOptions","symbol","size","NORMAL_COLOR","both","SELECTED_COLOR","arrowHoverStyle","startPos","endPos","startOffset","endOffset","escapeDistance","autoChangePosition","textPos","handles","conPointsGroup","groupCurve","Handle","EffectLine","ConnectionPoint","RADIUS","START_NODE","END_NODE","LEFT","RIGHT","TOP","BOTTOM","SEPERATOR","arrPoints","turningPoints","modifyCurve","textPoint","getTextPostion","refreshFromToSymbol","renderFromToSymbol","curveLine","polyLine","createHoverStyle","createAllconnectionPoint","shapeSetHandle","symbolTo","symbolFrom","effect","textPostion","arrOffset","midPoint","getTextRotation","sRect","eRect","sConnectorPoint","eConnectorPoint","connectionPointCreate","TYPE_CONNECTOR","conPoint","clearHandles","handleShape","isCollineaityFirst","isCollineaitySecond","symbolType","symbolSize","symbolZIndex","symbolPath","middleX","middleY","ellapsedDistance","segment","missingDistance","error","walked","rest","currentSegmentLength","segmentPercent","refreshModel","iconNode","sol","getCurvePoint","willDelCurves","cntCurve","cure","P","divide","nr","callee","multiply","q1","q_01","q_02","q_03","q0","q2","q_31","q_32","q_33","q3","Triangle","Diamond","Pin","tanX","tanY","cpLen","cpLen2","Arrow","symbolCtors","roundRect","square","circle","diamond","pin","triangle","symbolShapeMakers","symbolBuildProxies","Symbol","proxySymbol","symbolPathSetColor","symbolStyle","symbolShape","__isEmptyBrush","setColor","visible","actionConnector","anotherHandle","newX","newY","deltaY","deltaX","_lastFrame","_lastFramePercent","initSymbol","curveUtil","EffectLineProto","period","__t","groupCurveAnimate","updateSymbolPositionPolyline","setAnimationPointsPolyline","setAnimationPointsBezierCurve","updateSymbolPositionBezierCurve","__p1","__p2","__cp1","__cp2","_points","accLenArr","_offsets","_length","__lastFramePercent","offsets","OVER_COLOR","CONNECTED_COLOR","TYPE_FIGURE","anotherConnectionPoint","parentModel","extraOpt","clazzUtil","getDefaultOption","optList","defaultOption","__defaultOption","mergeOption","ignoreParent","fieldName","fieldArray","currentRef","thisParentModel","restoreData","enableClassExtend","superCall","methodName","superApply","TYPE_DELIMITER","IS_CONTAINER","parseClassType","componentType","main","RootClass","preConstruct","ExtendedClass","enableClassManagement","entity","makeContainer","container","registerClass","Clazz","getClass","componentTypeMain","subType","throwWhenNotFound","getClassesByMainType","hasClass","getAllClassMainTypes","types","hasSubTypes","registerWhenExtend","originalExtend","IconOperation","DEL_IMG","CHANGE_LINE_TYPE_IMG","ConnectionManager","bundleOffset","bundleGap","handleConnectorEvent","getTwoNodeId","handleConnectorShrink","arrCons","dockers","arrStartEndPoint","getStartEndPoint","unshift","refreshConnector","refreshCons","handleConnectorPoints","handleConnectorModel","arrSplit","selected","CONNECTION","START_ID","END_ID","isShrink","con","cons","half","oPoints","refreshConsStraight","arrConnectResult","secondPoint","thirdPoint","upHalf","secPoint","thdPoint","boundOffsetXY","isPositive","resultPoint","setModel","startNodeOutgoing","countLinePos","toggleLineByNode","isShow","connection","startPosNow","posIsChange","endPosNow","newPos","tempConnector","Log","solutions","connector2Points","isNotInSameGroup","sBounds","eBounds","calcPointExpression","expression","figureEscapeDistance","info","startExitPoint","endExitPoint","potentialExits","gapIndex","s0","s1","s1_1","s1_2","s2_1","s2_1_1","s2_1_2","s2_2","s2_2_1","s2_2_2","s2_3","eastExits","eastExit","s2_3_1","s2_3_2","s2_4","northExits","northExit","s2_4_1","s2_4_2","s2_5","westExits","westExit","s2_5_1","s2_5_2","s2_6","southExits","southExit","s2_6_1","s2_6_2","orthogonalSolution","solution","forwardSolutions","temp","nonIntersectionSolutions","innerLines","firstSolution","nrOfPoints","sameNrPointsSolution","solIndex","smoothCurve","groupEnd","solTurningPoints","startMiddlePoint","getMiddle","a3","a4","endMiddlePoint","solType","reducedSolution","LOG_LEVEL_NONE","LOG_LEVEL_DEBUG","LOG_LEVEL_INFO","LOG_LEVEL_ERROR","debug","title","RELATION_IMAGE","GROUP","TREE_ROOT","DOCKERS","STYLE_LINETYPE","LINEOPERATIONICON","LINK","FOLD","jsonArr","GroupNode","childArr","childNode","fishTopoflow","childShapes","isChild","elementType","relationNode","findNodeById","relationId","createdGroup","childs","nodeForLayout","startNodeId","endNodeId","thisLink","createByPoint","nodeId","retNode","url","nodeCtors","Ellipse","Heart","Droplet","Rose","Isogon","Star","Trochoid","IconButton","_trim","all","toCamelCase","upperCaseFirst","group1","formatTpl","tpl","paramsList","encode","seriesLen","$vars","alias","TPL_VAR_ALIAS","wrapVar","encodeHTML","seriesIdx","makeGetter","hostObj","varName","genModel","RECT_NAME","setLayout","setProperties","Layout","run","minLength","minX","minY","nowNodePosition","isIcon","relationImagePosition","cloneImagePosition","onEmphasis","onNormal","jQuery","resultDeferrd","Deferred","promise","isLoaded","reject","sx2","sy2","resolve","ZText","ox","oy","radian","dStep","deg","xStart","yStart","ri","location","num","ZPath","borderColor","borderWidth","itemSize","showTitle","iconStyle","normal","emphasis","__title","Fold","Curve","translateLinkOptions","FLOW_TYPE","RECT","IMAGE","TEXT","CIRCLE","SECTOR","RING","POLYGON","POLYLINE","LINE","BEZIERCURVE","ARC","SCENE","getUserData","isRect","isImage","isText","isCircle","arrPos","lineOperations","lineOperation","creatOperation","pointPosition","arrLength","totalLength","previousValue","currentValue","connectorPosition","attachLine","flowUtil","HLayout","VLayout","TreeLayout","ForceLayout","Tree","addCustomLayout","customLayout","getLayoutRect","positionInfo","containerRect","margin","containerHeight","verticalMargin","horizontalMargin","hv","elPos","currentLineMaxSize","nextX","nextChild","nextChildRect","newline","maxHeight","nextY","orient","nodePadding","layerPadding","rootLocation","animateTime","lineStyle","fishTopo","_layerOffsets","_hideNodes","TreeData","TreeHelper","layoutByRootNode","rootNode","traverseNode","treeData","childrenData","nodeData","rootTreeData","doLayout","isNotBuildLink","rootData","tree","fromOptionData","_buildNode","_setTreeShape","_buildAllLink","treeNode","_buildLinkByParent","createLinkFunction","doneCallback","animateCount","treeHelper","rootX","rootY","zrWidth","zrHeight","originRootX","treeNodeCount","__x","__y","_toggleShrink","createNodeFunction","_defaultCreateNodeFunction","_childShow","lable","parentTreeNode","childLength","_buildLink","startTreeNode","endTreeNode","paramObj","linkStyle","addChild","newTreeNode","refreshPositionAndLine","toggleChild","toggleTreeNode","findTreeNodeByNode","returnTreeNode","eachTreeNode","_hideToggle","removeChildren","removeAllChildren","updateDepthAndHeight","changePosition","targetIndex","nowIndex","TreeNode","depth","getNodeById","getSubTree","buildHierarchy","dataNode","fromDataSource","dataSource","rootItem","_findChildItem","childItem","childTreeNode","treeNodesMap","to","_updateNodeXPosition","_updateNodeYPosition","_shiftSubtree","prevLayerHeight","layerHeight","repulsion","gravity","edgeLength","once","layoutAnimation","preservedPoints","forceHelper","forceData","nodes","allLinks","_buildLinks","links","_forceIns","_startForceLayoutIteration","datas","_addNodeEvent","forceLayout","warmUp","_layouting","setFixed","setUnfixed","rep","n1","n2","curveness","forceInstance","oldStep","fixed","stopped","_layoutTimeout","edges","pp","friction","v12","nLen","repFact","config_default","thread","linkHead","linkNode","pool","emptyFn","tries","_helpers","setAttr","dataset","getAttr","initPool","notice","getNode","executeLink","onerror","appendNode","free","status","setSrc","shiftNode","getFree","setNode","_load","srcs","success","_info","task","tr","TooltipView","tooltipModel","_tooltipContent","TooltipContent","_tooltipModel","_alwaysShowContent","_initGloablListener","calcTooltipPosition","contentSize","domWidth","domHeight","rectWidth","rectHeight","refixTooltipPosition","viewWidth","viewHeight","gapH","gapV","clientWidth","clientHeight","isCenterAlign","align","confineTooltipPosition","globalListener","triggerOn","register","currTrigger","_tryShow","_hide","_showComponentItemTooltip","_lastDataByCoordSys","uid","manuallyHideTip","unregister","tooltipContent","hideLater","tooltipOpt","formatter","subTooltipModel","defaultHtml","asyncTicket","_showOrMove","_showTooltipContent","_showTimout","positionExpr","_ticket","html","cbTicket","setContent","_updatePosition","getSize","vAlign","viewSize","layoutRect","pos1","pos2","assembleTransition","transitionCurve","transitionText","vendors","vendorPrefix","assembleFont","assembleCssText","transitionDuration","zrColor","borderName","camelCase","_container","_show","_hideTimeout","onmouseenter","_enterable","_inContent","onmousemove","onmouseleave","_hideDelay","gCssText","currentStyle","setEnterable","enterable","initGlobalListeners","useHandler","dis","makeDispatchAction","records","record","dispatchTooltipFinally","pendings","initialized","doEnter","onLeave","actuallyPayload","showLen","showTip","hideLen","hideTip","showContent","alwaysShowContent","displayMode","confine","showDelay","hideDelay","borderRadius","extraCssText","vmlCore","comma","imageTransformPrefix","Z2","ZLEVEL_BASE","Z_BASE","initRootElStyle","coordsize","coordorigin","encodeHtmlAttribute","rgb2Str","append","getZIndex","setColorAndOpacity","getColorAndAlpha","updateFillNode","zrEl","gradientType","expansion","dimension","stops","cs1","cs2","colorAndAlphaList","colorAndAlpha","color1","color2","opacity1","opacity2","focusposition","updateStrokeNode","dashstyle","updateFillAndStroke","vmlEl","isFill","getElementsByTagName","pathDataToString","cmdStr","brushVML","vmlRoot","_vmlEl","needTransform","strokeEl","weight","zIndex","removeRectText","onRemove","onAdd","appendRectText","tagName","ow","oh","_imageSrc","_imageWidth","_imageHeight","imageRuntimeStyle","runtimeStyle","oldRuntimeWidth","oldRuntimeHeight","dw","dh","sw","sh","hasCrop","doc","vmlElStyle","hasRotation","transformFilter","imageEl","_imageEl","cropEl","_cropEl","imageELStyle","tmpImage","cropElStyle","filterStr","textMeasureEl","DEFAULT_STYLE_NORMAL","fontStyleCache","fontStyleCacheCount","MAX_FONT_CACHE_SIZE","fontEl","getFontStyle","fontString","variant","fontVariant","family","body","ex","createTextNode","offsetWidth","fromTextEl","verticalAlign","textPathEl","skewEl","textVmlEl","_textVmlEl","textpathok","coords","textVmlElStyle","string","urn","win","vmlInited","namespaces","zrvml","initVML","styleSheets","createStyleSheet","addRule","VMLPainter","vmlViewport","_vmlRoot","_vmlViewport","_firstPaint","createMethodNotSupport","zrLog","__alreadyNotVisible","_getWidth","_getHeight","vmlViewportStyle","paddingLeft","paddingRight","paddingTop","paddingBottom","notSupportedMethods"],"mappings":"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","file":"fish-topo-flow.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoFlow\"] = factory();\n\telse\n\t\troot[\"fishTopoFlow\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoFlow\"] = factory();\n\telse\n\t\troot[\"fishTopoFlow\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Export fishTopo as CommonJS module\r\n\t */\r\n\tmodule.exports = __webpack_require__(2);\r\n\t//兼容IE8 引入VML 如果不需要兼容IE8请删除\r\n\t__webpack_require__(136);\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * fishtopo流程实例\r\n\t * @class fish.topo.FishTopoFlow\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *      var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event click\r\n\t * 节点或者线段的click事件\r\n\t * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          this.fishTopo.on(\"click\", function(event) {\r\n\t *              console.log(\"点击的是：\" + event.target.model.get('elementType'));\r\n\t *          });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event dblclick\r\n\t * 节点或者线段的双击事件\r\n\t * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          this.fishTopo.on(\"dblclick\", function(event) {\r\n\t *              console.log(\"双击的是：\" + event.target.model.get('elementType'));\r\n\t *          });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event create\r\n\t * 节点与线段创建完毕的事件\r\n\t * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          this.fishTopo.on(\"create\", function(e) {\r\n\t *               if (me.fishTopo.Flow.isLink(e.target.model)) {\r\n\t *                  console.log(\"线段创建完毕：\" + e.target.model);\r\n\t *               }\r\n\t *          });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event delete\r\n\t * 节点与线段创建完毕的事件\r\n\t * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          //节点删除完毕事件\r\n\t *          this.fishTopo.on(\"delete\", function(event) {\r\n\t *              console.log(\"删除的是：\" + event.target.model.get('elementType'));\r\n\t *          });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event dropDrag\r\n\t * 节点移动完成的事件\r\n\t * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          //节点移动结束事件\r\n\t            this.fishTopo.on(\"dropDrag\", function(event) {\r\n\t                console.log(\"移动的节点是：\"+event.target.model.get('elementType'));\r\n\t            });\r\n\t */\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t    __webpack_require__(3);\r\n\t    var graphic = __webpack_require__(4);\r\n\t    var Minimap = __webpack_require__(64);\r\n\t    var util = __webpack_require__(65);\r\n\t    var Point = __webpack_require__(66);\r\n\t    var ExtensionAPI = __webpack_require__(68);\r\n\t    var Eventful = __webpack_require__(12);\r\n\t    var zrender = __webpack_require__(69);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var OperationNode = __webpack_require__(80);\r\n\t    var FlowConnectionManager = __webpack_require__(90);\r\n\t    var FlowUtil = __webpack_require__(94);\r\n\t    var Constants = __webpack_require__(93);\r\n\t    var Model = __webpack_require__(87);\r\n\t    var eventTool = __webpack_require__(74);\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var LineOperationManager = __webpack_require__(122);\r\n\t    var Flow = __webpack_require__(119);\r\n\t    var flowNode = __webpack_require__(96);\r\n\t    var flowLink = __webpack_require__(117);\r\n\t    var layout = __webpack_require__(123);\r\n\t    var textContain = __webpack_require__(26);\r\n\t    var ImagePool = __webpack_require__(131);\r\n\t    var ToolTipView = __webpack_require__(132);\r\n\t    var TooltipModel = __webpack_require__(135);\r\n\t    var actions = {};\r\n\t    var keyCode = {ENTER:13, ESCAPE:27}\r\n\t    function FishTopoFlow(dom, opts) {\r\n\t        this.id;\r\n\t        this.group = null;\r\n\t        this._dom = dom;\r\n\t        this.nowZoom = 1;\r\n\t        this.canScale = true;\r\n\t        this.eagleEye = false;\r\n\t        this.eagleEyeNode = null;\r\n\t        this.initScaleRatio = 1;\r\n\t        this.operationNode = null;\r\n\t        this.selectedNode = null;\r\n\t        this.allNodes = [];\r\n\t        this.minimap = null;\r\n\t        this._api = new ExtensionAPI(this);\r\n\t        this.connectionManager = new FlowConnectionManager(this._api);\r\n\t        this.lineOperationManager = new LineOperationManager(this.connectionManager,this._api);\r\n\t        this._zr = zrender.init(dom, {\r\n\t            renderer: opts.renderer || 'canvas',\r\n\t            devicePixelRatio: opts.devicePixelRatio\r\n\t        });\r\n\t        this._tooltipView = new ToolTipView(new TooltipModel(opts.tooltip),this._api);\r\n\t        this.Shape = graphic;\r\n\t        this.model = new Model({});\r\n\t        this.model.set(Constants.ELEMENT_TYPE, \"scene\");\r\n\t        this.model.set(Constants.MODE, \"normal\");\r\n\t        this.options = opts;\r\n\t        Eventful.call(this);\r\n\t    }\r\n\t\r\n\t    var fishTopoProto = FishTopoFlow.prototype;\r\n\t\r\n\t    /**\r\n\t     * 获取 fishTopo 实例容器的 dom 节点\r\n\t     * @return {HTMLElement}\r\n\t     */\r\n\t    fishTopoProto.getDom = function () {\r\n\t        return this._dom;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto.getZr = function () {\r\n\t        return this._zr;\r\n\t    };\r\n\t    /**\r\n\t     * 获取 fishTopo 实例容器的宽度。\r\n\t     * @return {number}\r\n\t     */\r\n\t    fishTopoProto.getWidth = function () {\r\n\t        return this._zr.getWidth();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取 fishTopo 实例容器的高度。\r\n\t     * @return {number}\r\n\t     */\r\n\t    fishTopoProto.getHeight = function () {\r\n\t        return this._zr.getHeight();\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 当前实例是否已经被释放。\r\n\t     * @return {boolean}\r\n\t     */\r\n\t    fishTopoProto.isDisposed = function () {\r\n\t        return this._disposed;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 释放 当前实例\r\n\t     */\r\n\t    fishTopoProto.dispose = function () {\r\n\t        this._disposed = true;\r\n\t\r\n\t        this._zr.dispose();\r\n\t\r\n\t        instances[this.id] = null;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 调整尺寸  在窗口大小发生改变时需要手工调用\r\n\t     * @param {number} width 宽度\r\n\t     * @param {number} height 高度\r\n\t     */\r\n\t    fishTopoProto.resize = function () {\r\n\t        this._zr.resize();\r\n\t\r\n\t    };\r\n\t\r\n\t    fishTopoProto.dispatchAction = function (payload) {\r\n\t        if(!actions[payload.type]) {\r\n\t            return;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method option\r\n\t     * 修改画布的选项\r\n\t     * @param {String} key 键  如：roam linkModify  textEditable等\r\n\t     * @param {Boolean|String|Function} value 选项值\r\n\t     */\r\n\t    fishTopoProto.option = function(key,value) {\r\n\t        var model = new Model(this.options);\r\n\t        if (arguments.length === 0) {\r\n\t            return zrUtil.clone(this.options);\r\n\t        } else if (arguments.length === 1) {\r\n\t            return model.get(key);\r\n\t        } else if (arguments.length === 2) {\r\n\t            if (key === \"roam\") {\r\n\t                this.setRoam(value);\r\n\t            }\r\n\t            return model.set(key,value);\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    fishTopoProto.init = function () {\r\n\t        this.group = new graphic.Group();\r\n\t        this.group.isBg = true;\r\n\t\r\n\t        // 鼠标平移操作\r\n\t        if ((this.options.roam === true) || (this.options.roam === 'move')) {\r\n\t            this.zrMove();\r\n\t        }\r\n\t\r\n\t        this._zr.add(this.group);\r\n\t\r\n\t        //是否允许鼠标滚轮放大缩小\r\n\t        if ((this.options.roam === true) || (this.options.roam === 'scale')) {\r\n\t            this.zrScale();\r\n\t        }\r\n\t\r\n\t        this.connectionManager.connectors = [];\r\n\t        //mouseup 会在各个node或线的click事件之点执行  在选中节点或线前 先清空选中效果\r\n\t        this._zr.on(\"mouseup\", function (e) { // clearSelect\r\n\t            // 1. 清空节点的选中效果\r\n\t            this._removeOperationNode();\r\n\t            // 2. 点击的线 ，则直接返回\r\n\t            var shape = e.target;\r\n\t            if (shape && shape.model && Flow.isLink(shape.model)) {\r\n\t                return;\r\n\t            }\r\n\t            if (shape && shape.connector instanceof Connector) {\r\n\t                return;\r\n\t            }\r\n\t            // 3. 清空连接线\r\n\t            this.connectionManager.clearSelectCon();\r\n\t            // 4. 点击的是线上操作按钮，则直接返回\r\n\t            if (shape && shape._isLineOperationIcon && shape._isLineOperationIcon == true) {\r\n\t                return;\r\n\t            }\r\n\t            // 5.隐藏线上操作图标\r\n\t            this.lineOperationManager.hideAllLineOperation();\r\n\t        }.bind(this));\r\n\t\r\n\t        this._zr.on(\"click\", function (e) {\r\n\t            var nodeTarget = e.target;\r\n\t            var shape;\r\n\t            if (nodeTarget) {\r\n\t                shape = nodeTarget.model;\r\n\t            }\r\n\t            if ((nodeTarget && shape && Flow.isLink(shape)) || (nodeTarget && shape && Flow.isNode(\r\n\t                    shape))) {\r\n\t                return;\r\n\t            }\r\n\t            var params = {};\r\n\t            params.event = e;\r\n\t            params.type = \"click\";\r\n\t            params.target = this;\r\n\t            this._api.trigger(params.type, params);\r\n\t        }.bind(this));\r\n\t        this.on('conPointsGroup:click', function (argument) {\r\n\t            this.lineOperationManager.bindOperation(argument.lineNode);\r\n\t        }.bind(this));\r\n\t    };\r\n\t\r\n\t    fishTopoProto.setRoam = function (value) {\r\n\t        //是否允许鼠标滚轮放大缩小\r\n\t        if ((value === true) || (value === 'move')) {\r\n\t            this.zrMove();\r\n\t        }\r\n\t        if ((value === true) || (value === 'scale')) {\r\n\t            this.zrScale();\r\n\t        }\r\n\t        if (value === false ) {\r\n\t            this._zr.off(\"mousedown\");  //禁止 拖拽画布\r\n\t            this._zr.off(\"mousewheel\");//禁止用户缩放画布\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method toJson\r\n\t     * 导出json\r\n\t     * @return {Object} json对象\r\n\t     */\r\n\t    fishTopoProto.toJson = function () {\r\n\t        return FlowUtil.toJson(this.model, this.group);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method fromJson\r\n\t     * 导入json\r\n\t     * @param  {Object} json对象\r\n\t     */\r\n\t    fishTopoProto.fromJson = function (json) {\r\n\t        this.clear();\r\n\t        var model = new Model(json);\r\n\t        this.setBackground(model.get(Constants.BACKGROUND));\r\n\t        var layoutRootNode = [];\r\n\t        FlowUtil.fromJson(this, this.group, model.get(Constants.CHILDS), false, layoutRootNode);\r\n\t        // for (var i = 0; i < layoutRootNode.length; i++) {\r\n\t        //     this.layoutNode(\"tree\", {\r\n\t        //         \"node\": layoutRootNode[i],\r\n\t        //         \"type\": layoutRootNode[i].treeType\r\n\t        //     });\r\n\t        // }\r\n\t    };\r\n\t    /**\r\n\t     * 添加节点或线段到画布 同add方法\r\n\t     * @method addNode\r\n\t     * @param {Object} node createNode或createLink返回的对象\r\n\t     * @param {Object} [option] 参数对象\r\n\t     * @param {Boolean} [option.trigger] 是否触发 beforeCreate事件\r\n\t     * @returns {Object} 返回添加成功的节点 ，如被用户取消之类则 返回null\r\n\t     */\r\n\t    /**\r\n\t     * 添加节点或线段到画布 同addNode方法\r\n\t     * @method add\r\n\t     * @param {Object} node createNode或createLink返回的对象\r\n\t     * @param {Object} [option] 参数对象\r\n\t     * @param {Boolean} [option.trigger] 是否触发 beforeCreate事件\r\n\t     * @returns {Object} 返回添加成功的节点 ，如被用户取消之类则 返回null\r\n\t     */\r\n\t    fishTopoProto.add = fishTopoProto.addNode = function (node,options) {\r\n\t        if (!node) return null;\r\n\t\r\n\t        var opt = options || {};\r\n\t        if(opt.trigger !==false && (!this._trigger('beforeCreate', {target:node}))) {\r\n\t            return null;\r\n\t        }\r\n\t        if (node instanceof Connector) {\r\n\t            this.addConnectorAttrEvent(node);\r\n\t        } else {\r\n\t            if (Flow.isGroupNode(node)) {\r\n\t                node.willRender();\r\n\t                var groupOptions = node.model.get(Constants.OPTIONS);\r\n\t                if (groupOptions.mergedImage) {\r\n\t                    var groupReplaceImage = new flowNode.Image({\r\n\t                        style: {\r\n\t                            image: groupOptions.mergedImage,\r\n\t                            text: groupOptions.style.text,\r\n\t                            textPosition: 'bottom'\r\n\t                        },\r\n\t                        position: [-5000, -5000]\r\n\t                    });\r\n\t                    this.drag(groupReplaceImage);\r\n\t                    node._relationImage = groupReplaceImage;\r\n\t                    this.group.add(groupReplaceImage);\r\n\t                    setTimeout(function () {\r\n\t                        groupReplaceImage.hide();\r\n\t                    }, 300);\r\n\t                    node.on('dblclick', function () {\r\n\t                        node.merged();\r\n\t                    })\r\n\t                }\r\n\t                //遍历组中所有节点\r\n\t                node.each(function (child) {\r\n\t                        if (child instanceof Connector) {\r\n\t                            this.addConnectorAttrEvent(child);\r\n\t                        } else {\r\n\t                            this.addNodeAttrEvent(child, groupOptions.childDraggable);\r\n\t                            if (util.isUndefined(child.selectable)) {\r\n\t                                child.selectable = false;  //组内默认不可选中\r\n\t                            }\r\n\t                            if (child.relative) {\r\n\t                                this._handleRelativePostion(child)\r\n\t                            }\r\n\t                            if (child.hoverStyle) {\r\n\t                                graphic.setHoverStyle(child);\r\n\t                            }\r\n\t                        }\r\n\t                        this._trigger(\"create\", {target:child});\r\n\t                }, this);\r\n\t            }\r\n\t            this.addNodeAttrEvent(node, true);\r\n\t        }\r\n\t        this._trigger(\"create\", {target:node});\r\n\t\r\n\t        if (node.hoverStyle) {\r\n\t            graphic.setHoverStyle(node);\r\n\t        }\r\n\t\r\n\t        this.group.add(node);\r\n\t        if (node.relative) {  //必须在加入画布后执行\r\n\t            this._handleRelativePostion(node)\r\n\t        }\r\n\t        if (node.hoverAnimation && this.options.isAnimationEnabled) {\r\n\t            flowNode.addHoverAnimation(node);\r\n\t        }\r\n\t        return node;\r\n\t    };\r\n\t\r\n\t    fishTopoProto.addConnectorAttrEvent = function (connector) {\r\n\t        var that = this;\r\n\t        connector.options.isEdit = !!this.options.linkModify;\r\n\t        connector.on(\"mousedown\", function () {\r\n\t            this.connectionManager.connectorForbidEdit(!this.options.linkModify);\r\n\t            this.isNode = false;\r\n\t        }.bind(this));\r\n\t        this.connectionManager.add(connector);\r\n\t        //支持双击编辑\r\n\t        connector.on(\"dblclick\", function () {\r\n\t            if (typeof this.options.text.textEditable == \"undefined\") {\r\n\t                if (that.options.textEditable) {\r\n\t                    that.connectorEdit(this);\r\n\t                }\r\n\t            } else {\r\n\t                if (this.options.text.textEditable) {\r\n\t                    that.connectorEdit(this);\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t    }\r\n\t\r\n\t    fishTopoProto.addNodeAttrEvent = function (node, childDraggable) {\r\n\t        var that = this;\r\n\t        if (childDraggable) {\r\n\t            this.drag(node);\r\n\t        }\r\n\t\r\n\t        node.attr(\"operationIcons\", node.model.get('options.operationIcons'));\r\n\t\r\n\t        //侦听节点的click dblclick事件，选中，并派发出去\r\n\t        node.on('click', function (event) {\r\n\t            var targeNode = this;\r\n\t            that.nodeClickHandler(targeNode);\r\n\t\r\n\t            var params = {};\r\n\t            params.event = event;\r\n\t            params.type = 'click';\r\n\t            params.target = targeNode;\r\n\t            that._api.trigger(params.type, params);\r\n\t            event.cancelBubble = true;\r\n\t\r\n\t            //判断一下是否是组内成组的点击事件，如果是的话，那组也也派发一下\r\n\t            if (Flow.isInGroup(targeNode)) {\r\n\t                var parentNode = targeNode.parent;\r\n\t                parentNode.trigger('click', {event:event, type:'click',target:parentNode});\r\n\t            }\r\n\t        });\r\n\t        node.on('dblclick', function (e) {\r\n\t            var targeNode = this;\r\n\t            if (!targeNode.style || (typeof targeNode.style.textEditable == \"undefined\")) {\r\n\t                if (that.options.textEditable) {\r\n\t                    that.nodeEdit(targeNode);\r\n\t                }\r\n\t            } else {\r\n\t                if (targeNode.style.textEditable) {\r\n\t                    that.nodeEdit(targeNode);\r\n\t                }\r\n\t            }\r\n\t            var params = {};\r\n\t            params.event = e;\r\n\t            params.type = 'dblclick';\r\n\t            params.target = targeNode;\r\n\t            that._api.trigger(params.type, params);\r\n\t\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t\r\n\t        this.allNodes.push(node);\r\n\t    }\r\n\t\r\n\t    fishTopoProto._handleRelativePostion = function(node) {\r\n\t        var parentEl = node.parent;\r\n\t        var containerInfo = parentEl === this.group\r\n\t            ? {\r\n\t                width:this._api.getWidth(),\r\n\t                height:this._api.getHeight()\r\n\t            }\r\n\t            : {\r\n\t                width:parentEl.getBoundingRect().width,\r\n\t                height:parentEl.getBoundingRect().height\r\n\t            }\r\n\t        layout.positionElement(node, node.relative, containerInfo, node.relative.padding, {boundingMode:node.relative.bounding||'all'});\r\n\t    }\r\n\t\r\n\t    fishTopoProto._getParentZr = function(node) {\r\n\t        var parentZr = null;\r\n\t        if (node && node.parent) {\r\n\t            parentZr = node.parent;\r\n\t        } else {\r\n\t            parentZr = this.group;\r\n\t        }\r\n\t        return parentZr;\r\n\t    }\r\n\t\r\n\t    fishTopoProto._removeOperationNode = function() {\r\n\t        if (this.operationNode) {\r\n\t            this.group.remove(this.operationNode);\r\n\t            this.operationNode.cleanup();\r\n\t            this.operationNode = null;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 清空当前实例，会移除实例中所有的节点与线\r\n\t     * @method clear\r\n\t     */\r\n\t    fishTopoProto.clear = function () {\r\n\t        for (var i = 0; i < this.allNodes.length; i++) {\r\n\t            var parentZr = this._getParentZr(this.allNodes[i]);\r\n\t            this.connectionManager.deleteSelectCon(this.allNodes[i], parentZr)\r\n\t        }\r\n\t        this.connectionManager.connectorMap.clear();\r\n\t        this.allNodes = [];\r\n\t        this.operationNode = null;\r\n\t        this.selectedNode = null;\r\n\t        this.connectionManager.connectors = [];\r\n\t        this._zr.clear();\r\n\t        this.group = new graphic.Group();\r\n\t        this.group.isBg = true;\r\n\t        this._zr.add(this.group);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建连线的小图标操作\r\n\t     * @param {string} key 小图标的名称\r\n\t     * @param {Object} options 小图标的相关参数\r\n\t     * @param {String} [options.icon] 小图标路径\r\n\t     * @param {Object} [options.lineNode] 线段实例\r\n\t     * @param {Function} [options.callback] 点击后的回调\r\n\t     *\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *                  this.fishTopo.addIcon(\"icon1\", {\r\n\t     *                      icon: \"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_ca79a146.png\",\r\n\t     *                      lineNode: lineNode,\r\n\t     *                      callback: function(event) {\r\n\t     *                          alert(JSON.stringify(event.data))\r\n\t     *                      },\r\n\t     *                  });\r\n\t     */\r\n\t    fishTopoProto.addLineIcon = fishTopoProto.addIcon = function (key, options) {\r\n\t        this.lineOperationManager.addIcon(key, options);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建连线的默认删除操作\r\n\t     * @param  {Object} lineNode 线\r\n\t     *\r\n\t     *  **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      fishTopo.lineDefaultIcon(lineNode);\r\n\t     */\r\n\t    fishTopoProto.lineDefaultIcon = function (lineNode) {\r\n\t        this.addLineDeleteIcon(lineNode);\r\n\t        this.addLineChangeIcon(lineNode);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建连线的默认删除操作\r\n\t     * @param  {Object} lineNode 线\r\n\t     * @param {Object} [options] 连线操作的选项\r\n\t     *\r\n\t     *  **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      fishTopo.addLineChangeIcon(lineNode);\r\n\t     */\r\n\t    fishTopoProto.addLineDeleteIcon = function (lineNode,options) {\r\n\t        //创建删除\r\n\t        this.lineOperationManager.addDeleteIcon(lineNode,options);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建连线的默认切换类型操作\r\n\t     * @param  {Object} lineNode 线\r\n\t     * @param {Object} [options] 连线操作的选项\r\n\t     *\r\n\t     *  **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      fishTopo.addLineChangeIcon(lineNode);\r\n\t     */\r\n\t    fishTopoProto.addLineChangeIcon = function (lineNode,options) {\r\n\t        this.lineOperationManager.addChangeLineTypeIcon(lineNode,options);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 变更当前线的类型，如果不传则按顺序取下一个类型。先删除原来的线段 再增加一种类型的线段\r\n\t     * @param {String} lineType 欲变更线的类型\r\n\t     */\r\n\t    fishTopoProto.changeSelectConnectorType = function(lineType) {\r\n\t        var nextLineType = lineType;\r\n\t        var line = this.connectionManager.selConnector;\r\n\t        var originLineType = line.options.style.lineType;\r\n\t        if (nextLineType) {\r\n\t            if (nextLineType == originLineType) {\r\n\t                return;\r\n\t            }\r\n\t        } else {\r\n\t            var arrLineType = [Connector.TYPE_STRAIGHT, Connector.TYPE_JAGGED, Connector.TYPE_CURVE];\r\n\t            var index = zrUtil.indexOf(arrLineType, originLineType);\r\n\t            nextLineType = arrLineType[(index + 1) % arrLineType.length];\r\n\t        }\r\n\t\r\n\t        //this.remove(line, {trigger:false}); 这样会删除icons\r\n\t        this.connectionManager.deleteLine(this._getParentZr(line));\r\n\t        this.lineOperationManager.hideAllLineOperation();\r\n\t\r\n\t        zrUtil.merge(line.options.style, {lineType: nextLineType}, true);\r\n\t        var nextLine = this.createConnectorByNodes(line.startNode, line.endNode, line.options);\r\n\t        if (nextLine) {\r\n\t            nextLine.icons = line.icons;\r\n\t            nextLine.on('Connector:click', function () {\r\n\t                this.lineOperationManager.bindOperation(nextLine);\r\n\t            }.bind(this));\r\n\t        }\r\n\t    }\r\n\t\r\n\t    fishTopoProto.initOperationNode = function (node) {\r\n\t        this.operationNode = new OperationNode(node, this.group, this._api);\r\n\t\r\n\t        this.operationNode.on(OperationNode.ARROW_DRAGSTART, function (e) {\r\n\t            var x = (e.event.offsetX - this.group.position[0]) / this.nowZoom;\r\n\t            var y = (e.event.offsetY - this.group.position[1]) / this.nowZoom;\r\n\t            //拖拽开始先把 箭头图标 给隐藏\r\n\t            var arrow = e.event.target;\r\n\t            arrow.hide();\r\n\t            var rEndPoint = new Point(x, y);\r\n\t            var connector = this.connectionManager.manageTempConnector(this.selectedNode, rEndPoint,\r\n\t                arrow.lineType);\r\n\t            this.group.add(connector);\r\n\t            e.cancelBubble = true;\r\n\t        }.bind(this));\r\n\t\r\n\t        // 侦听 箭头 拖拽事件\r\n\t        this.operationNode.on(OperationNode.ARROW_DRAG, function (e) {\r\n\t            var x = (e.event.offsetX - this.group.position[0]) / this.nowZoom;\r\n\t            var y = (e.event.offsetY - this.group.position[1]) / this.nowZoom;\r\n\t            var arrow = e.event.target;\r\n\t            var rEndPoint = new Point(x, y);\r\n\t            this.connectionManager.manageTempConnector(this.selectedNode, rEndPoint, arrow.lineType);\r\n\t            e.cancelBubble = true;\r\n\t        }.bind(this));\r\n\t\r\n\t        //侦听 箭头 拖拽结束事件 画线\r\n\t        this.operationNode.on(OperationNode.ARROW_DRAGEND, function (e) {\r\n\t            e.cancelBubble = true;\r\n\t            var x = e.event.offsetX;\r\n\t            var y = e.event.offsetY;\r\n\t            var targetNode = null;\r\n\t            //拖拽结束先把 箭头图标 给显示\r\n\t            var arrow = e.event.target;\r\n\t            arrow.show();\r\n\t            //删除临时线\r\n\t            this.connectionManager.removeTempConnector(this.group);\r\n\t\r\n\t            //1.如果是子节点 内 节点拖拽 则 增加排除子节点的参数\r\n\t            targetNode = findHover(this.allNodes, x, y);\r\n\t\r\n\t            function isHover(node, x, y) {\r\n\t                return node.rectContain(x, y);\r\n\t            }\r\n\t\r\n\t            function findHover(list, x, y, excludes) {\r\n\t                for (var i = list.length - 1; i >= 0; i--) {\r\n\t                    if (isExclude(excludes, list[i]) //list[i] !== exclude\r\n\t                        // getDisplayList may include ignored item in VML mode\r\n\t                        &&\r\n\t                        !list[i].ignore && isHover(list[i], x, y)) {\r\n\t                        return list[i];\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t\r\n\t            function isExclude(excludes, node) {\r\n\t                return zrUtil.indexOf(excludes, node) == -1;\r\n\t            }\r\n\t\r\n\t            //2.如果找到目标结点 则画线\r\n\t            if (targetNode && (this.selectedNode != targetNode)) {\r\n\t                var connectOptions;\r\n\t                if (e.data) {\r\n\t                    connectOptions = e.data;\r\n\t                } else {\r\n\t                    connectOptions = {\r\n\t                        style: {\r\n\t                            lineType: arrow.lineType\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t                if(!this._trigger('beforeCreate', {target:this.selectedNode,endNode:targetNode,connectOptions:connectOptions})) {\r\n\t                    return null;\r\n\t                }\r\n\t                this.createConnectorByNodes(this.selectedNode, targetNode, connectOptions);\r\n\t            }\r\n\t        }.bind(this));\r\n\t\r\n\t        //删除按钮点击事件\r\n\t        this.operationNode.on(OperationNode.DELETE_CLICK, function () {\r\n\t            this.removeNode(this.selectedNode);\r\n\t        }.bind(this));\r\n\t        this.group.add(this.operationNode);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 移除场景中的某个节点或者线段,同removeNode\r\n\t     * @method remove\r\n\t     * @param  {Object} node or link 待删除的节点或者线段\r\n\t     * @param {Object} [options] 参数\r\n\t     * @param {Boolean} [options.trigger=true] 是否触发删除事件\r\n\t     *\r\n\t     *  **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      fishTopo.remove(peopleNode);\r\n\t     */\r\n\t\r\n\t    /**\r\n\t     * 移除场景中的某个节点或者线段,同remove\r\n\t     * @method removeNode\r\n\t     * @param  {Object} node or link 待删除的节点或者线段\r\n\t     * @param {Object} [options] 参数\r\n\t     * @param {Boolean} [options.trigger=true] 是否触发删除事件\r\n\t     *\r\n\t     *  **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      fishTopo.removeNode(peopleNode);\r\n\t     */\r\n\t    fishTopoProto.remove = fishTopoProto.removeNode = function (delNode, options) {\r\n\t        var opt = options || {};\r\n\t        if(opt.trigger !==false && (!this._trigger('beforeDelete', {target:delNode}))) {\r\n\t            return;\r\n\t        }\r\n\t        var parentZr = this._getParentZr(delNode);\r\n\t        if (delNode instanceof Connector) {\r\n\t            // 1.1 删除线段上的操作图标\r\n\t            zrUtil.each(delNode.icons, function(lineOperationIcon) {\r\n\t                parentZr.remove(lineOperationIcon);\r\n\t            })\r\n\t            // 1.2 删除当前选中线段\r\n\t            this.connectionManager.deleteByLine(delNode,parentZr);\r\n\t        } else {\r\n\t            //2.1 删除节点\r\n\t            parentZr.remove(delNode);\r\n\t            //2.2 从allNodes数组中删除\r\n\t            for (var i = 0; i < this.allNodes.length; i++) {\r\n\t                if (delNode.id == this.allNodes[i].id) {\r\n\t                    this.allNodes.splice(i, 1);\r\n\t                }\r\n\t            }\r\n\t            //2.3 删除和节点相关联的线段\r\n\t            this.connectionManager.deleteSelectCon(delNode, this.group);\r\n\t            //2.4 删除节点操作\r\n\t            this._removeOperationNode();\r\n\t        }\r\n\t\r\n\t        //3. 清空连接线上的调整位置按钮\r\n\t        this.connectionManager.clearSelectCon();\r\n\t        //4. 清空连接线上的操作按钮\r\n\t        this.lineOperationManager.hideAllLineOperation();\r\n\t        //4. 派发删除事件\r\n\t         this._trigger(\"delete\", {target:delNode});\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 根据节点创建连线\r\n\t     * @method createConnectorByNodes\r\n\t     * @param  {Object} startNode 开始节点\r\n\t     * @param  {Object} endNode   结束节点\r\n\t     * @param  {Object} options 线段选项 参见{@link fishTopoFlow.link#constructor 构造函数options参数}\r\n\t     */\r\n\t    fishTopoProto.createConnectorByNodes = function (startNode, endNode, options) {\r\n\t\r\n\t        var linkType = options.style.lineType || Connector.TYPE_STRAIGHT;\r\n\t        if (!flowLink[linkType]) {\r\n\t            return null;\r\n\t        }\r\n\t        var Link = flowLink[linkType];\r\n\t        var connector = new Link(startNode, endNode, options);\r\n\t        this.connectionManager.add(connector);\r\n\t\r\n\t        if (startNode.parent && endNode.parent) {\r\n\t            endNode.parent.add(connector);\r\n\t        } else {\r\n\t            this.group.add(connector);\r\n\t        }\r\n\t\r\n\t        connector.on(\"mousedown\", function () {\r\n\t            this.connectionManager.connectorForbidEdit(!this.options.linkModify);\r\n\t            this.isNode = false;\r\n\t        }.bind(this));\r\n\t        connector.on(\"dblclick\", function () {\r\n\t            if (this.options.textEditable) {\r\n\t                this.connectorEdit(this);\r\n\t            }\r\n\t        }.bind(this));\r\n\t\r\n\t        this._trigger(\"create\", {target:connector});\r\n\t        return connector;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 派发创建完成事件  返回fales则取消\r\n\t     */\r\n\t    fishTopoProto._trigger = function(type, event, data) {\r\n\t        var callback = this.options[type];\r\n\t\r\n\t        if (data === void 0) data = {};\r\n\t        if (event === null) {\r\n\t            event = {type:type, target:this}\r\n\t        } else {\r\n\t            event.type = type;\r\n\t        }\r\n\t        event.data = data;\r\n\t        this._api.trigger(event.type, event);\r\n\t        return !(zrUtil.isFunction(callback) && callback.apply(this, [event].concat(data)) === false);\r\n\t    }\r\n\t\r\n\t\r\n\t    fishTopoProto.nodeClickHandler = function (node) {\r\n\t        // 鼠标点下 将操作框 移到对应的节点上\r\n\t        if (node.selectable === false) {\r\n\t            if (Flow.isInGroup(node)) {\r\n\t                var group = node.parent;\r\n\t                if (group.selectable === false) {\r\n\t                    return;\r\n\t                } else {\r\n\t                    node = group;   // 如果有组的话，就针对组进行处理\r\n\t                }\r\n\t            } else {\r\n\t                return;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        this.selectedNode = node;\r\n\t        var shapeRect = util.getRect(node);\r\n\t        if (!this.operationNode) {\r\n\t            this.initOperationNode(node);\r\n\t        }\r\n\t        // 在存在子流程的情况下 需要把node也传递一下\r\n\t        this.operationNode.refreshPostion(node, shapeRect);\r\n\t    };\r\n\t\r\n\t    fishTopoProto._groupDragHandler = function (x, y) {\r\n\t        // flow中最外层的group移动操作\r\n\t        var nowGroupPosition = this.group.position;\r\n\t        var groupPositionX = this.group.position[0];\r\n\t        var groupPositionY = this.group.position[1];\r\n\t\r\n\t        var moveHandler = function (event) {\r\n\t            var width = this.group.getBoundingRect().width * this.nowZoom;\r\n\t            var height = this.group.getBoundingRect().height * this.nowZoom;\r\n\t            var gx = this.group.getBoundingRect().x * this.nowZoom;\r\n\t            var gy = this.group.getBoundingRect().y * this.nowZoom;\r\n\t            var min = [10 - (width + gx), 10 - (height + gy)];\r\n\t            var max = [(this._zr.getWidth() - gx) - 10, (this._zr.getHeight() - gy) - 10];\r\n\t            var sX = event.offsetX - x;\r\n\t            var sY = event.offsetY - y;\r\n\t            nowGroupPosition[0] = groupPositionX + sX;\r\n\t            nowGroupPosition[1] = groupPositionY + sY;\r\n\t            if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] <\r\n\t                min[0] || nowGroupPosition[1] < min[1]) {\r\n\t                return;\r\n\t            } else {\r\n\t                this.group.attr(\"position\", nowGroupPosition);\r\n\t                if (this.eagleEye == true) {\r\n\t                    this.minimap.updataSelectionPosition(nowGroupPosition, this.nowZoom);\r\n\t                }\r\n\t            }\r\n\t        }.bind(this);\r\n\t        this._zr.on('mousemove', moveHandler);\r\n\t\r\n\t        var endDragHandler = function () {\r\n\t            this._zr.off('mousemove', moveHandler);\r\n\t            this._zr.off('mouseup', endDragHandler);\r\n\t            this._zr.off(\"globalout\", endDragHandler);\r\n\t        }.bind(this);\r\n\t        this._zr.on('mouseup', endDragHandler);\r\n\t        this._zr.on(\"globalout\", endDragHandler);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 节点的移动操作, 为何要自己实现拖动？zredner Group不支持拖动，只能自己实现\r\n\t     */\r\n\t    fishTopoProto.drag = function (node) {\r\n\t        var that = this; // zrender中的一个bug event.target不会带group 只能用that 不能用bind(this)\r\n\t        node.on(\"mousedown\", function (event) {\r\n\t            var draggingTarget = this;\r\n\t            //如果加了属性 draggable:false 则不可以拖动\r\n\t            if (draggingTarget.isdraggable == false) {\r\n\t                return;\r\n\t            }\r\n\t            that._nodeDragHandler(draggingTarget, event.offsetX, event.offsetY);\r\n\t            event.cancelBubble = true;\r\n\t        });\r\n\t    };\r\n\t\r\n\t    fishTopoProto._nodeDragHandler = function (node, x, y) {\r\n\t        var isMove = 0;\r\n\t        var nowGroupPosition = node.position;\r\n\t        var groupPositionX = node.position[0];\r\n\t        var groupPositionY = node.position[1];\r\n\t        node._startX = x;\r\n\t        node._startY = y;\r\n\t\r\n\t        node.trigger(\"dragstart\");\r\n\t        // 1、侦听移动事件\r\n\t\r\n\t        var moveHandler = function (event) {\r\n\t            event.cancelBubble = true;\r\n\t            var sX = (event.offsetX - node._startX) / (this.nowZoom);\r\n\t            var sY = (event.offsetY - node._startY) / (this.nowZoom);\r\n\t\r\n\t            if ((sX != 0) || (sY != 0)) {\r\n\t                isMove = 1;\r\n\t            }\r\n\t            node.trigger(\"drag\");\r\n\t            // 1.1处理组内的情况（如果节点拖动，组也跟着变）\r\n\t            if (Flow.isInGroup(node)) {\r\n\t                //放入node现有数值，用于重绘group\r\n\t                var nodeMessage = {\r\n\t                    width: node.shape.width,\r\n\t                    height: node.shape.height,\r\n\t                    position: node.position,\r\n\t                    movePosition: [groupPositionX, groupPositionY],\r\n\t                    moveX: sX,\r\n\t                    moveY: sY,\r\n\t                    node: node\r\n\t                };\r\n\t                node.parent.modifyGroupRect(nodeMessage);\r\n\t            }\r\n\t            nowGroupPosition[0] = groupPositionX + sX;\r\n\t            nowGroupPosition[1] = groupPositionY + sY;\r\n\t            node.attr(\"position\", nowGroupPosition);\r\n\t            // 1.2 处理告警的情况 （告警随着节点移动）\r\n\t            if (node.alarm) {\r\n\t                var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm\r\n\t                        .getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect()\r\n\t                    .height - 3\r\n\t                ];\r\n\t                node.alarm.attr(\"position\", newAlarmPosition);\r\n\t            }\r\n\t            // 1.4 触发点击\r\n\t            this.nodeClickHandler(node);\r\n\t            // 1.5 刷新连线\r\n\t            this.connectionManager.refreshLineByNode(node);\r\n\t        }.bind(this);\r\n\t        this._zr.on('mousemove', moveHandler);\r\n\t\r\n\t\r\n\t\r\n\t        //2. 拖拽结束\r\n\t        var endDragHandler = function () {\r\n\t            if (node.model) {\r\n\t                node.model.set(\"options.position\", FlowUtil.truncPosition(node.position));\r\n\t            }\r\n\t\r\n\t            this._zr.off('mousemove', moveHandler);\r\n\t            this._zr.off('mouseup', endDragHandler);\r\n\t            this._zr.off(\"globalout\", endDragHandler);\r\n\t\r\n\t            //2.1 缩微图\r\n\t            if (isMove == 1) {\r\n\t                this._trigger(\"dropDrag\", {target:node});\r\n\t                node.trigger(\"dragend\");\r\n\t                if (this.eagleEye == true) {\r\n\t                    this.openEagleEye(this.eagleEyeNode);\r\n\t                }\r\n\t            }\r\n\t        }.bind(this);\r\n\t        this._zr.on('mouseup', endDragHandler);\r\n\t        this._zr.on('globalout', endDragHandler);\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 创建节点\r\n\t     * @method createNode\r\n\t     * @param  {String} type 类型 eg. 'Rect'、'Circle'、'Image'、'Group'、'Text'等\r\n\t     * @param  {Object} opt 节点选项 详见{@link fishTopoFlow.node Config options}\r\n\t     * @param {Object} userData 用户传递的业务数据\r\n\t     * @return {Object} 创建的节点对象\r\n\t     *\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      var rect = this.fishTopo.createNode(\"Rect\", { //矩形\r\n\t     *          shape: {\r\n\t     *              width: 100,\r\n\t     *              height: 60,\r\n\t     *          },\r\n\t     *          style: {\r\n\t     *              text: \"基本矩形\",\r\n\t     *              fill: \"#167CFF\",\r\n\t     *              stroke: \"rgb(255,255,255)\",\r\n\t     *              textFont: '14px Microsoft YaHei'\r\n\t     *          },\r\n\t     *          position: [180, 100],\r\n\t     *          operationIcons: [{ name: 'DEL' },\r\n\t     *              { name: 'STRAIGHT' },\r\n\t     *              { name: 'JAGGED' },\r\n\t     *              { name: 'CURVE' },\r\n\t     *              {\r\n\t     *                  name: \"custom1\",\r\n\t     *                  iconPath: \"img/host.png\",\r\n\t     *                  callback: function(e) { alert(e.data.name + \" clicked\") }  //e.node是当前的节点\r\n\t     *              }\r\n\t     *          ]\r\n\t     *      });\r\n\t     */\r\n\t    fishTopoProto.createNode = fishTopoProto.creatNode = function (type, opt, userData) {\r\n\t        if (!flowNode[type]) {\r\n\t            return null;\r\n\t        }\r\n\t        var Shape = flowNode[type];\r\n\t        var node = new Shape(opt);\r\n\t\r\n\t        Flow.setUserData(node, userData);\r\n\t        return node;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 根据name获取节点\r\n\t     * @param  {String} name 在创建节点中  name属性设置的值\r\n\t     * @return {Object}      name对应的节点\r\n\t     */\r\n\t    fishTopoProto.childOfName = function (name) {\r\n\t        var arrResult = [];\r\n\t        var childrenNode = this.allNodes;\r\n\t        var childrenLine = this.connectionManager.connectors;\r\n\t        for (var i = 0; i < childrenNode.length; i++) {\r\n\t            if (childrenNode[i].model.get(\"options.name\") && childrenNode[i].model.get(\"options.name\") ==\r\n\t                name) {\r\n\t                arrResult.push(childrenNode[i]);\r\n\t            } else if (childrenNode[i].model.get(\"userData.name\") == name) {\r\n\t                arrResult.push(childrenNode[i]);\r\n\t            }\r\n\t        }\r\n\t        for (var j = 0; j < childrenLine.length; j++) {\r\n\t            if (childrenLine[j].model.get(\"options.name\") && childrenLine[j].model.get(\"options.name\") ==\r\n\t                name) {\r\n\t                arrResult.push(childrenLine[j]);\r\n\t            } else if (childrenLine[j].model.get(\"userData.name\") == name) {\r\n\t                arrResult.push(childrenLine[j]);\r\n\t            }\r\n\t        }\r\n\t        if (arrResult.length > 1) {\r\n\t            return arrResult;\r\n\t        } else {\r\n\t            return arrResult[0];\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 查找场景中的对象   例如: x坐标大于100的节点 findElements(function(node){ return node.position[0] > 100; });\r\n\t     * @param  {Function} cb      回调函数 参数为遍历的节点\r\n\t     * @param  {Object}   context 回调函数执行的上下文\r\n\t     * @return {Array}           返回查找到的对象\r\n\t     */\r\n\t    fishTopoProto.findElements = function (cb, context) {\r\n\t        var childrenNode = this.allNodes;\r\n\t        var childrenLine = this.connectionManager.connectors;\r\n\t        var arr = [];\r\n\t        for (var i = 0; i < childrenNode.length; i++) {\r\n\t            var child = childrenNode[i];\r\n\t            if (cb.call(context, child, i)) {\r\n\t                arr.push(child);\r\n\t            }\r\n\t        }\r\n\t        for (var j = 0; j < childrenLine.length; j++) {\r\n\t            var childL = childrenLine[j];\r\n\t            if (cb.call(context, childL, j)) {\r\n\t                arr.push(childL);\r\n\t            }\r\n\t        }\r\n\t        return arr;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 设置背景色  或 背景图片\r\n\t     * @param {string} imageUrl 背景色  或 背景图片 eg. 'img/bg.jpg'，为‘gridLine’时网格背景\r\n\t     * @param {string} isRepeat 是否重复背景  如果重复的话，将使用css的repeat 因为canvas不支持repeat\r\n\t     */\r\n\t    fishTopoProto.setBackground = function (imageUrl, isRepeat) {\r\n\t        if (imageUrl && imageUrl.length > 0) {\r\n\t            this.model.set(Constants.BACKGROUND, imageUrl);\r\n\t            if (imageUrl.substr(0, 1) == \"#\" || imageUrl.substr(0, 4) == \"rgba\") { //如果是颜色创建rect为背景\r\n\t                if (!document.createElement('canvas').getContext) {\r\n\t                    this._dom.style.backgroundColor = imageUrl;\r\n\t                } else {\r\n\t                    var imageShape = new this.Shape.Rect({\r\n\t                        shape: {\r\n\t                            width: this._zr.getWidth(),\r\n\t                            height: this._zr.getHeight()\r\n\t                        },\r\n\t                        style: {\r\n\t                            fill: imageUrl\r\n\t                        },\r\n\t                        cursor: 'default',\r\n\t                        z: -1\r\n\t                    });\r\n\t                    this._zr.add(imageShape);\r\n\t                }\r\n\t\r\n\t            } else if (imageUrl == \"gridLine\") {\r\n\t                this.gridLineGroup = new graphic.Group();\r\n\t                this.gridLine(0.2);\r\n\t                this._zr.add(this.gridLineGroup);\r\n\t            } else {\r\n\t                if (!document.createElement('canvas').getContext || isRepeat) {\r\n\t                    this._dom.style.backgroundImage = \"url(\" + imageUrl + \")\";\r\n\t                    this._dom.style.backgroundRepeat = \"repeat\";\r\n\t                } else {\r\n\t                    var imageShape1 = new this.Shape.Image({ //如果是图片创建image为背景\r\n\t                        position: [0, 0],\r\n\t                        scale: [1, 1],\r\n\t                        style: {\r\n\t                            x: 0,\r\n\t                            y: 0,\r\n\t                            image: imageUrl,\r\n\t                            width: this._zr.getWidth(),\r\n\t                            height: this._zr.getHeight()\r\n\t                        },\r\n\t                        cursor: 'default',\r\n\t                        z: -1\r\n\t                    });\r\n\t                    this._zr.add(imageShape1);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    //背景网格线\r\n\t    fishTopoProto.gridLine = function (opacity) {\r\n\t        var pixel = 10;\r\n\t        var widthLen = parseInt(this.getWidth() / pixel);\r\n\t        for (var x = 0; x <= widthLen; x++) {\r\n\t            var lineX = new graphic.Line({\r\n\t                shape: {\r\n\t                    x1: x * pixel,\r\n\t                    y1: 0,\r\n\t                    x2: x * pixel,\r\n\t                    y2: this.getHeight()\r\n\t                },\r\n\t                style: {\r\n\t                    lineDash: [1],\r\n\t                    opacity: opacity\r\n\t                },\r\n\t                z: 0,\r\n\t                draggable: false,\r\n\t                cursor: 'default'\r\n\t            });\r\n\t            this.gridLineGroup.add(lineX);\r\n\t        }\r\n\t\r\n\t        var heightLen = parseInt(this.getHeight() / pixel, pixel);\r\n\t        for (var y = 0; y <= heightLen; y++) {\r\n\t            var lineY = new graphic.Line({\r\n\t                shape: {\r\n\t                    x1: 0,\r\n\t                    y1: y * pixel,\r\n\t                    x2: this.getWidth(),\r\n\t                    y2: y * pixel\r\n\t                },\r\n\t                style: {\r\n\t                    lineDash: [1],\r\n\t                    opacity: opacity\r\n\t                },\r\n\t                z: 0,\r\n\t                draggable: false,\r\n\t                cursor: 'default'\r\n\t            });\r\n\t            this.gridLineGroup.add(lineY);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建线段\r\n\t     * @method createLink\r\n\t     * @param  {Object} startNode 开始节点\r\n\t     * @param  {Object} endNode   结束节点\r\n\t     * @param  {Object} options 线段选项\r\n\t     * @param {Object} [options.style] 节点的样式\r\n\t     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n\t     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n\t     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n\t     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n\t     * @param {Object} [options.symbol] 线段的箭头\r\n\t     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n\t     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n\t     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n\t     * @param {Object} [options.text] 线段上的文字\r\n\t     * @param {String} [options.text.text] 线段上的文字内容\r\n\t     * @param {String} [options.text.color] 线段上的文字颜色\r\n\t     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n\t     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n\t     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {String} [options.position] 指定线段位置\r\n\t     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n\t     * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n\t     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n\t     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n\t     * @param {Object} [options.effect] 线上动态效果\r\n\t     * @param {String} [options.effect.show] 是否显示箭头动效\r\n\t     * @param {Number} [options.effect.period] 动效移动速度\r\n\t     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n\t     * @param {Number} [options.z] [连线的层级，越大越在前面显示]\r\n\t     * @param {Object} userData 用户传递的业务数据\r\n\t     * @return {Object} 创建的线段对象\r\n\t     *\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      var link = me.fishTopo.createLink(startNode, endNode, {\r\n\t     *              symbol: { type: 'arrow', size: 10, color: \"rgb(0,200,255)\" }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t     *              style: { lineWidth: 3, stroke: \"rgb(0,200,255)\", lineDash: [3,3], lineType: \"jagged\"  }, //样式\r\n\t     *              text: {\r\n\t     *                  text: text,\r\n\t     *                  color: '#ffffff',\r\n\t     *                  textPos:textPos,//文字位置可选值 'start','center','end',默认值为center\r\n\t     *                  xOffset:10, //文字位置x偏移量\r\n\t     *              },\r\n\t     *              pos:'right,left',\r\n\t     *              effect: {\r\n\t     *                  show: true,//是否显示箭头动效\r\n\t     *                  period: 6,//箭头速度\r\n\t     *              },\r\n\t     *              position:{\r\n\t     *                    escapeDistance:[50,30],  //第一条折线的长度，最后一条折线的长度\r\n\t     *                    points:[\"x1,y1\",\"x2,y2\"]  不使用自动计算 指定连线的位置数组\r\n\t     *              },\r\n\t     *              z: 0\r\n\t     *          });\r\n\t     */\r\n\t    fishTopoProto.createLink = fishTopoProto.creatLink = function (startNode, endNode, options, userData) {\r\n\t        var linkType = Connector.TYPE_STRAIGHT;\r\n\t        if (options && options.style && options.style.lineType) {\r\n\t            linkType = options.style.lineType\r\n\t        }\r\n\t\r\n\t        if (!flowLink[linkType]) {\r\n\t            return null;\r\n\t        }\r\n\t        var Link = flowLink[linkType];\r\n\t        var connector = new Link(startNode, endNode, options);\r\n\t        if (userData) {\r\n\t            connector.model.set(Constants.USERDATA, zrUtil.clone(userData));\r\n\t        }\r\n\t\r\n\t        return connector;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 根据节点刷新节点所连的线（重新计算线的位置）\r\n\t     * @param  {Object} node [节点]\r\n\t     */\r\n\t    fishTopoProto.refreshLineByNode = function (node) {\r\n\t        this.connectionManager.refreshLineByNode(node);\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 线上文字编辑\r\n\t     */\r\n\t    fishTopoProto.connectorEdit = function (thisConnector) {\r\n\t        var lineText = thisConnector.childOfName('lineText');\r\n\t        if (!lineText) {\r\n\t            return;\r\n\t        }\r\n\t        var textarea = this.createTextArea();\r\n\t        textarea.style.width = 1.1 * util.getRect(lineText).width * this.nowZoom + \"px\";\r\n\t        textarea.style.height = (util.getRect(lineText).height || 12) * this.nowZoom + \"px\";\r\n\t        textarea.style.border = \"1px solid #000000\";\r\n\t        textarea.innerHTML = lineText.style.text;\r\n\t        thisConnector.setStyle({\r\n\t            text: {\r\n\t                text: \"\"\r\n\t            }\r\n\t        })\r\n\t        this._dom.appendChild(textarea);\r\n\t        this._dom.style.position = \"relative\";\r\n\t        var textRect = textContain.getBoundingRect(lineText.style.text, lineText.style.textFont);\r\n\t        textarea.style.lineHeight = (textRect.lineHeight || 14) + \"px\";\r\n\t        textarea.style.top = (lineText.position[1] - util.getRect(lineText).height) * this.nowZoom + this.group\r\n\t            .position[1] + \"px\";\r\n\t        textarea.style.left = (lineText.position[0] - 0.05 * util.getRect(lineText).width) * this.nowZoom +\r\n\t            this.group.position[0] + \"px\";\r\n\t        textarea.focus();\r\n\t        textarea.select();\r\n\t        $(textarea).on(\"keyup\", zrUtil.bind(function (e) {\r\n\t            var textRect = textContain.getBoundingRect(lineText.style.text, lineText.style.textFont);\r\n\t            this._textareaResize(textRect, textarea, e);\r\n\t        }, this));\r\n\t        $(textarea).on(\"focusout\", function () {\r\n\t            thisConnector.setStyle({\r\n\t                text: {\r\n\t                    text: textarea.value || \"\"\r\n\t                }\r\n\t            })\r\n\t            textarea.remove();\r\n\t        })\r\n\t    };\r\n\t    /**\r\n\t     * @private\r\n\t     * 节点上文字编辑\r\n\t     */\r\n\t    fishTopoProto.nodeEdit = function (thisNode) {\r\n\t        var isNotSetText = false;\r\n\t        var textarea = this.createTextArea();\r\n\t        var nodeText = zrUtil.clone(thisNode.style.text);\r\n\t        var textRect = textContain.getBoundingRect(nodeText, thisNode.style.textFont);\r\n\t        textarea.style.width = 2 * textRect.width * this.nowZoom + \"px\";\r\n\t        textarea.style.height = (2 * textRect.height || 12) * this.nowZoom + \"px\";\r\n\t        var nodeRect = util.getRect(thisNode);\r\n\t        textarea.style.maxWidth = 1.2 * nodeRect.width * this.nowZoom + \"px\";\r\n\t        textarea.style.lineHeight = (1.2 * textRect.lineHeight || 12) + \"px\";\r\n\t        textarea.style.border = \"1px solid #000000\";\r\n\t        textarea.innerHTML = thisNode.style.text;\r\n\t        this.setStyle(thisNode, {text: \"\"});  //先把节点文本给清空，否则删除文本框中文字的时候，会显示出来\r\n\t        this._dom.appendChild(textarea);\r\n\t        this._dom.style.position = \"relative\";\r\n\t        var offestI = 1;\r\n\t        if (thisNode.style.textAlign == \"left\") {\r\n\t            offestI = 0;\r\n\t        }\r\n\t        if (thisNode.style.textAlign == \"right\") {\r\n\t            offestI = 2;\r\n\t        }\r\n\t        var offestP = 0;\r\n\t        if (thisNode.style.textPosition && thisNode.style.textPosition == \"bottom\") {\r\n\t            offestP = 1;\r\n\t            textarea.style.maxWidth = 3 * 1.1 * nodeRect.width * this.nowZoom + \"px\";\r\n\t        }\r\n\t        if (thisNode.style.textPosition && thisNode.style.textPosition == \"top\") {\r\n\t            offestP = -1;\r\n\t            textarea.style.maxWidth = 3 * 1.1 * nodeRect.width * this.nowZoom + \"px\";\r\n\t        }\r\n\t        textarea.style.top = (nodeRect.y - textRect.height / 2 + offestP * (nodeRect.height - textRect.height /\r\n\t            2)) * this.nowZoom + this.group.position[1] + \"px\";\r\n\t        textarea.style.left = (nodeRect.x - offestI * textRect.width / 2 - 0.05 * textRect.width) * this.nowZoom +\r\n\t            this.group.position[0] + \"px\";\r\n\t        textarea.focus();\r\n\t        textarea.select();\r\n\t        textarea.onkeyup = function() {\r\n\t            if (event.keyCode == keyCode.ESCAPE) {\r\n\t                isNotSetText = true;\r\n\t                textarea.blur();\r\n\t            } else {\r\n\t                var textRect = textContain.getBoundingRect(textarea.value, thisNode.style.textFont);\r\n\t                this._textareaResize(textRect, textarea, textarea.style.maxWidth);\r\n\t            }\r\n\t        }.bind(this);\r\n\t\r\n\t        textarea.onblur = function() {\r\n\t            if (!isNotSetText) {\r\n\t                var text = this.handleWrap(textarea.value, textarea.style.maxWidth);\r\n\t                this.setStyle(thisNode, {text: text});\r\n\t            } else {\r\n\t                this.setStyle(thisNode, {text: nodeText});\r\n\t            }\r\n\t            textarea.remove();\r\n\t        }.bind(this);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 创建文本域\r\n\t     */\r\n\t    fishTopoProto.createTextArea = function () {\r\n\t        var textarea = document.createElement(\"textarea\");\r\n\t        textarea.style.position = \"absolute\";\r\n\t        textarea.style.padding = \"6px\";\r\n\t        textarea.style.resize = \"none\";\r\n\t        textarea.style.whiteSpace = \"pre\";\r\n\t        textarea.style.lineHeight = \"125%\";\r\n\t        textarea.style.overflow = \"hidden\";\r\n\t        textarea.style.border = \"0\";\r\n\t        textarea.spellcheck = false;\r\n\t        return textarea;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 处理textarea自动换行\r\n\t     */\r\n\t    fishTopoProto.handleWrap = function (value, width) {\r\n\t        var spanNode = document.createElement(\"span\");\r\n\t        spanNode.style.position = \"absolute\";\r\n\t        spanNode.style.overflow = \"hidden\";\r\n\t        spanNode.style.border = \"0\";\r\n\t        spanNode.style.padding = \"0\";\r\n\t        spanNode.style.left = \"0\";\r\n\t        spanNode.style.top = \"0\";\r\n\t        this._dom.appendChild(spanNode);\r\n\t        var content = value.split(\"\\n\");\r\n\t        var result = \"\";\r\n\t        $.each(content, function (i, val) {\r\n\t            var valLength = val.length;\r\n\t            if (valLength == 0) {\r\n\t                //result += \"\\n\";\r\n\t            } else {\r\n\t                var pre = \"\",\r\n\t                    innerVal, tempWidth, conWidth;\r\n\t                for (var innerI = 0; innerI < valLength; innerI++) {\r\n\t                    innerVal = val.charAt(innerI);\r\n\t                    $(spanNode).text($(spanNode).text() + innerVal);\r\n\t                    tempWidth = $(spanNode).width(); //获取添加字符后隐藏域的宽度\r\n\t                    conWidth = Number(width.substring(0, width.length - 2));\r\n\t                    if (tempWidth > conWidth) {\r\n\t                        result += pre; //如果追加字符后隐藏域宽度大于TextArea宽度，则表明该字符为下一行字符，\r\n\t                        result += \"\\n\";\r\n\t                        $(spanNode).text(innerVal);\r\n\t                        pre = innerVal;\r\n\t                    } else if (innerI == valLength - 1) {\r\n\t                        result += pre + innerVal; //最后一个字符\r\n\t                        if (i < content.length - 1) {\r\n\t                            result += \"\\n\";\r\n\t                        }\r\n\t                        $(spanNode).text(\"\");\r\n\t                        pre = \"\";\r\n\t                    } else {\r\n\t                        pre += innerVal; //依次追加到pre变量中\r\n\t                    }\r\n\t\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t        this._dom.removeChild(spanNode);\r\n\t        return result;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 文本域自适应高宽\r\n\t     */\r\n\t    fishTopoProto._textareaResize = function (textRect, textarea, width) {\r\n\t        var minWidth = 0;\r\n\t        textarea.style.width = 0;\r\n\t        textarea.style.width = (1.1 * textRect.width) * this.nowZoom + \"px\";\r\n\t        if (width < 60) {\r\n\t            minWidth = width;\r\n\t        } else {\r\n\t            minWidth = 60\r\n\t        }\r\n\t        if (textRect.width <= minWidth) {\r\n\t            textarea.style.width = minWidth + \"px\";\r\n\t        }\r\n\t        textarea.style.height = \"0px\";\r\n\t        textarea.style.height = textarea.scrollHeight + 'px';\r\n\t        if (textarea.scrollHeight <= 0) {\r\n\t            textarea.style.height = \"12px\";\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method setStyle\r\n\t     * 节点更改style里的属性\r\n\t     * @param {String} name 节点style里的某个属性名称\r\n\t     * @param {String} string 节点style里的某个属性名称对应的值\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *          //节点设置文字\r\n\t     *         fishtopo.setStyle(node,{text:\"例子\"});\r\n\t     */\r\n\t    fishTopoProto.setStyle = function (node, options) {\r\n\t        node.setStyle(options);\r\n\t        zrUtil.merge(node.model.get(\"options.style\"), options, true);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method setShape\r\n\t     * 节点更改shape里的属性\r\n\t     * @param {String} name 节点shape里的某个属性名称\r\n\t     * @param {String} string 节点shape里的某个属性名称对应的值\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *          //矩形节点设置宽\r\n\t     *         fishtopo.setShape(node,{width:100});\r\n\t     */\r\n\t    fishTopoProto.setShape = function (node, options) {\r\n\t        node.setShape(options);\r\n\t        zrUtil.merge(node.model.get(\"options.shape\"), options, true);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 创建节点上面的警告\r\n\t     * @method createAlarm\r\n\t     * @param  {Object} node 节点\r\n\t     * @param  {Object} opt  选项值\r\n\t     * @param  {Object} [opt.text] 警告的文字\r\n\t     * @param  {Object} [opt.textFont] 警告的文字的字体\r\n\t     * @param  {Object} [opt.textFill] 警告的文字的颜色\r\n\t     * @param  {Object} [opt.textBackground] 警告的背景的颜色\r\n\t     * @return {Object} 返回节点上的警告\r\n\t     *\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *          this.fishTopo.createAlarm(s1,{\r\n\t     *          text:\"2 W\",\r\n\t     *          textFont:\"4px Microsoft YaHei\",\r\n\t     *          textFill:\"#FFFFFF\",\r\n\t     *          textBackground:\"rgba(255,0,0,0.6)\"\r\n\t     *      });//创建小图片和节点绑定\r\n\t     */\r\n\t    fishTopoProto.createAlarm = fishTopoProto.creatAlarm = function (node, opt) {\r\n\t        var group = this.createNode(\"Group\", {\r\n\t            style: {\r\n\t                fill: 'rgba(0,0,0,0)',\r\n\t                stroke: 'rgba(0,0,0,0)'\r\n\t            }\r\n\t        });\r\n\t        group.isdraggable = false;\r\n\t        var text = this.createNode(\"Text\", { //文字\r\n\t            style: {\r\n\t                text: opt.text,\r\n\t                textFont: opt.textFont,\r\n\t                fill: opt.textFill,\r\n\t                textBaseline: \"top\" //垂直对齐,\r\n\t            },\r\n\t            selectable: false,\r\n\t            position: [2, 0],\r\n\t            z: 2\r\n\t        });\r\n\t        text.isdraggable = false;\r\n\t        group.add(text);\r\n\t        if (Flow.isInGroup(node)) {\r\n\t            node.parent.add(group);\r\n\t        } else {\r\n\t            this.group.add(group);\r\n\t        }\r\n\t        var groupWidth = group.getBoundingRect().width + 2;\r\n\t        var groupHeight = group.getBoundingRect().height + 6;\r\n\t        var points = [\r\n\t            [0, 0],\r\n\t            [groupWidth, 0],\r\n\t            [groupWidth, groupHeight],\r\n\t            [groupWidth - 3, groupHeight],\r\n\t            [groupWidth - 6, groupHeight + 3],\r\n\t            [groupWidth - 9, groupHeight],\r\n\t            [0, groupHeight],\r\n\t            [0, 0]\r\n\t        ];\r\n\t        var Polyline = this.createNode(\"Polyline\", {\r\n\t            shape: {\r\n\t                points: points\r\n\t            },\r\n\t            style: {\r\n\t                fill: opt.textBackground,\r\n\t                stroke: opt.textBackground\r\n\t            },\r\n\t            selectable: false,\r\n\t            z: 1\r\n\t        });\r\n\t        Polyline.isdraggable = false;\r\n\t        group.add(Polyline);\r\n\t        var groupPosition = [node.position[0] + node.getBoundingRect().width - (group.getBoundingRect().width -\r\n\t            6), node.position[1] - group.getBoundingRect().height - 3];\r\n\t        group.attr(\"position\", groupPosition);\r\n\t        node.alarm = group;\r\n\t        //设置模型 给json序列化用\r\n\t        var model = new Model({});\r\n\t        model.set(Constants.ELEMENT_TYPE, Constants.ALARM);\r\n\t        model.set(Constants.OPTIONS, zrUtil.clone(opt));\r\n\t        model.set(Constants.RELATIONID, node.model.get(Constants.ID));\r\n\t        group.model = model;\r\n\t        return group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 返回当前画布的数据\r\n\t     */\r\n\t    fishTopoProto.toDataURL = function (opts) {\r\n\t        return FlowUtil.toDataURL(this._zr, opts);\r\n\t    };\r\n\t\r\n\t    fishTopoProto.zrMove = function () {\r\n\t        this._zr.on(\"mousedown\", function (e) { //点击在节点上或者线上不进行平移操作\r\n\t            if ((e.target && e.target.model) || (e.target && e.target.lineType && e.target.parent) ||\r\n\t                (e.target && e.target.connector instanceof Connector) || (e.target && e.target instanceof graphic\r\n\t                    .Circle)) {\r\n\t                return;\r\n\t            } else {\r\n\t                this._groupDragHandler(e.offsetX, e.offsetY);\r\n\t            }\r\n\t        }.bind(this));\r\n\t    }\r\n\t\r\n\t    fishTopoProto.initScale = function () {\r\n\t        var groupMaxWidth = this.group.getBoundingRect().width;\r\n\t        var groupMaxHeight = this.group.getBoundingRect().height;\r\n\t        var rangeWidth = this.getWidth();\r\n\t        var rangeHeight = this.getHeight();\r\n\t        var initRatio = 1,\r\n\t            pos = [];\r\n\t        if (groupMaxWidth / groupMaxHeight > rangeWidth / rangeHeight) {\r\n\t            if (groupMaxWidth > rangeWidth) {\r\n\t                initRatio = rangeWidth / groupMaxWidth;\r\n\t            }\r\n\t        } else {\r\n\t            if (groupMaxHeight > rangeHeight) {\r\n\t                initRatio = rangeHeight / groupMaxHeight;\r\n\t            }\r\n\t        }\r\n\t        pos[0] = Math.abs(this.group.getBoundingRect().x) * initRatio;\r\n\t        pos[1] = Math.abs(this.group.getBoundingRect().y) * initRatio;\r\n\t        this.group.attr(\"position\", [pos[0], pos[1]]);\r\n\t        this.group.attr(\"scale\", [initRatio, initRatio]);\r\n\t        this.initScaleRatio = initRatio;\r\n\t        var distance = [pos[0], pos[1], this.initScaleRatio, groupMaxWidth, groupMaxHeight];\r\n\t        return distance;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 放大或者缩小\r\n\t     * @param  {String|Number} type 当为字符串时 \"enlarge\"放大  \"narrowing\"缩小  当为数值时 缩放的比例  建议0.3-1.7\r\n\t     */\r\n\t    fishTopoProto.zrScale = function (type) {\r\n\t        if (type) {\r\n\t            if (type == \"narrowing\") {\r\n\t                var zoomDelta1 = -0.07;\r\n\t                this.zoom(zoomDelta1, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }\r\n\t            if (type == \"enlarge\") {\r\n\t                var zoomDelta = 0.07;\r\n\t                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }\r\n\t            if (!isNaN(type)) {\r\n\t                var target = this.group;\r\n\t                if (target) {\r\n\t                    var zoomScale = type;\r\n\t                    this._zoom = type;\r\n\t                    this.nowZoom = type;\r\n\t                    this.setScale(this._zr.getWidth() / 2, this._zr.getHeight() / 2, zoomScale);\r\n\t                }\r\n\t            }\r\n\t        } else {\r\n\t            this._zr.on('mousewheel', zrUtil.bind(function (e) {\r\n\t                eventTool.stop(e.event);\r\n\t                var zoomDelta = e.wheelDelta > 0 ? 0.07 : -0.07;\r\n\t                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }, this));\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto.zoom = function (zoomDelta, zoomX, zoomY) {\r\n\t        if (this.canScale == false) {\r\n\t            return;\r\n\t        }\r\n\t        var target = this.group;\r\n\t        if (target) {\r\n\t\r\n\t            var newZoom = this._zoom = this._zoom || 1;\r\n\t            newZoom += zoomDelta;\r\n\t\r\n\t            newZoom = Number(newZoom.toFixed(2));\r\n\t            var zoomScale = newZoom / this._zoom;\r\n\t            if (newZoom > 1.7 || newZoom < 0.3) {\r\n\t                return;\r\n\t            }\r\n\t            this._zoom = newZoom;\r\n\t\r\n\t            this.nowZoom = newZoom;\r\n\t            this.setScale(zoomX, zoomY, zoomScale);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto.setScale = function (zoomX, zoomY, zoomScale) {\r\n\t        var target = this.group;\r\n\t        var pos = target.position;\r\n\t        var scale = target.scale;\r\n\t        // Keep the mouse center when scaling\r\n\t        pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\r\n\t        pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\r\n\t        scale[0] *= zoomScale;\r\n\t        scale[1] *= zoomScale;\r\n\t        target.attr(\"position\", [pos[0], pos[1]]);\r\n\t        target.attr(\"scale\", [scale[0], scale[1]]);\r\n\t        if (this.eagleEye == true) {\r\n\t            this.minimap.updataSelection(pos[0], pos[1], zoomScale, this.nowZoom);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 鹰眼图\r\n\t     * @param  {HTMLElement} eagleEyeNode 显示鹰眼图的div元素\r\n\t     */\r\n\t    fishTopoProto.openEagleEye = function (eagleEyeNode) {\r\n\t        this.eagleEye = true;\r\n\t        this.eagleEyeNode = eagleEyeNode;\r\n\t        var groupPosition = zrUtil.clone(this.group.position);\r\n\t        var groupScale = zrUtil.clone(this.group.scale);\r\n\t        this.group.attr(\"position\", [0, 0]);\r\n\t        this.group.attr(\"scale\", [1, 1]);\r\n\t        var distance = this.initScale();\r\n\t        var imgSrc = this.toDataURL();\r\n\t        this.group.attr(\"position\", groupPosition);\r\n\t        this.group.attr(\"scale\", groupScale);\r\n\t        if (this.minimap) {\r\n\t            this.minimap.updataMap(imgSrc, this.group.getBoundingRect());\r\n\t        } else {\r\n\t            this.minimap = new Minimap(this, this.group.position, this.group.getBoundingRect(),\r\n\t                eagleEyeNode, distance, imgSrc);\r\n\t            setTimeout(zrUtil.bind(function () {\r\n\t                this.openEagleEye(this.eagleEyeNode)\r\n\t            }, this), 10);\r\n\t        }\r\n\t        this.minimap.selection.addEventListener(\"mousedown\", function (e) {\r\n\t            var startX = e.clientX;\r\n\t            var startY = e.clientY;\r\n\t            var minimapLeft = Number(this.minimap.selection.style.left.substring(0, this.minimap.selection\r\n\t                .style.left.length - 2));\r\n\t            var minimapTop = Number(this.minimap.selection.style.top.substring(0, this.minimap.selection\r\n\t                .style.top.length - 2));\r\n\t            var eagleEyeMove = function (e) {\r\n\t                var offsetX = e.clientX - startX;\r\n\t                var offsetY = e.clientY - startY;\r\n\t                this.minimap.selection.style.left = minimapLeft + offsetX + \"px\";\r\n\t                this.minimap.selection.style.top = minimapTop + offsetY + \"px\";\r\n\t                this.minimap.updataGroupPosition(this.group, this.nowZoom);\r\n\t            }.bind(this);\r\n\t\r\n\t            this.minimap.selection.addEventListener(\"mousemove\", eagleEyeMove);\r\n\t\r\n\t            var eagleEyeUp = function () {\r\n\t                this.minimap.selection.removeEventListener(\"mousemove\", eagleEyeMove);\r\n\t                this.minimap.selection.removeEventListener(\"mouseup\", eagleEyeUp);\r\n\t            }.bind(this);\r\n\t            this.minimap.selection.addEventListener(\"mouseup\", eagleEyeUp);\r\n\t        }.bind(this))\r\n\t    };\r\n\t\r\n\t\r\n\t\r\n\t    zrUtil.mixin(FishTopoFlow, Eventful);\r\n\t\r\n\t    // ---------对外暴露fishTopoFlow------------------\r\n\t    var idBase = new Date() - 0;\r\n\t    var instances = {};\r\n\t    var DOM_ATTRIBUTE_KEY = '_fishTopoFlow_instance_';\r\n\t\r\n\t    /**\r\n\t     * fishTopoFlow全局对象，如果是amd方式加载，则直接返回\r\n\t     * @class fishTopoFlow\r\n\t     * @singleton\r\n\t     *\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t     */\r\n\t    var fishTopoFlow = {\r\n\t        /**\r\n\t         * 版本号\r\n\t         * @type {String}\r\n\t         */\r\n\t        version: '2.2.1',\r\n\t        dependencies: {\r\n\t            zrender: '3.6.3'\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 初始化dom元素为 flow对象\r\n\t     * @member fishTopoFlow\r\n\t     * @param {HTMLElement} dom  一个div元素\r\n\t     * @param {Object} opts  传递的选项参数\r\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg' or 'vml'\r\n\t     * @param {number} [opts.devicePixelRatio=1] retina 屏幕优化\r\n\t     * @param {boolean} [opts.linkModify=false] 是否允许调整线段\r\n\t     * @param {boolean} [opts.textEditable=false] 是否允许双击节点编辑文字\r\n\t     * @param {boolean} [opts.roam=true] 是否开启鼠标缩放和平移漫游。默认开启。如果只想要开启缩放或者平移，可以设置成 'scale' 或者 'move'。设置成 true 为都开启\r\n\t     * @param {Object} [opts.tooltip] tooltip配置项\r\n\t     * @param {boolean} [opts.tooltip.show] tooltip配置项:控制tooltip是否显示\r\n\t     * @param {boolean} [opts.isAnimationEnabled=true] 是否开启动画,默认为true\r\n\t     * @param {Function} [opts.beforeDelete] 删除节点或边线 之前的回调，如果返回false则不进行后续的删除操作\r\n\t     * @param {Object} [opts.beforeCreate] 创建节点或边线 之前的回调，如果返回false则不进行后续的删除操作\r\n\t     * @return {fish.topo.FishTopoFlow}\r\n\t     */\r\n\t    fishTopoFlow.init = function (dom, opts) {\r\n\t        if (!dom) {\r\n\t            throw new Error('Initialize failed: invalid dom.');\r\n\t        }\r\n\t\r\n\t        opts = opts || {};\r\n\t        // Default value\r\n\t        zrUtil.defaults(opts, {\r\n\t            type: \"flow\",\r\n\t            devicePixelRatio: 1,\r\n\t            linkModify: false,\r\n\t            textEditable: false,\r\n\t            roam: true,\r\n\t            tooltip: {\r\n\t                show:true\r\n\t            },  //覆盖tooltipModel\r\n\t            isAnimationEnabled: true,\r\n\t            beforeDelete: null,  // 删除之前的事件\r\n\t            beforeCreate:null   //创建节点或连线之前的事件\r\n\t        });\r\n\t\r\n\t        var fishTopoFlow = new FishTopoFlow(dom, opts);\r\n\t        fishTopoFlow.init();\r\n\t        fishTopoFlow.Flow = Flow;\r\n\t        fishTopoFlow.id = 'ft_' + idBase++;\r\n\t        instances[fishTopoFlow.id] = fishTopoFlow;\r\n\t\r\n\t        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoFlow.id);\r\n\t\r\n\t        return fishTopoFlow;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 获取 dom 容器上的实例。\r\n\t     * @member fishTopoFlow\r\n\t     * @param  {HTMLElement} dom 一个div元素\r\n\t     * @return {fish.topo.FishTopoFlow}\r\n\t     */\r\n\t    fishTopoFlow.getInstanceByDom = function (dom) {\r\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n\t        return instances[key];\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 销毁实例，实例销毁后无法再被使用。\r\n\t     *\r\n\t     * @member fishTopoFlow\r\n\t     * @param  {Object|string} chart fishTopoBpmn实例 或 fishTopoBpmn的id\r\n\t     */\r\n\t    fishTopoFlow.dispose = function (chart) {\r\n\t        var topo;\r\n\t        if (zrUtil.isDom(chart)) {\r\n\t            topo = fishTopoFlow.getInstanceByDom(chart);\r\n\t        } else if (typeof chart === 'string') {\r\n\t            topo = instances[chart];\r\n\t        }\r\n\t        if ((topo instanceof fishTopoFlow) && !topo.isDisposed()) {\r\n\t            topo.dispose();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    //暴露出去的类\r\n\t    fishTopoFlow.graphic = graphic;\r\n\t    fishTopoFlow.node = FlowUtil.registerFlowNode(flowNode);\r\n\t    fishTopoFlow.link = flowLink;\r\n\t\r\n\t    fishTopoFlow.layout = layout;\r\n\t    fishTopoFlow.Flow = Flow;\r\n\t    fishTopoFlow.constants = Constants;\r\n\t    fishTopoFlow.util = util;\r\n\t    fishTopoFlow.util['initImagePool'] = ImagePool.initImagePool;\r\n\t    zrUtil.each([\r\n\t            'map', 'each', 'filter', 'indexOf', 'inherits',\r\n\t            'reduce', 'filter', 'bind', 'curry', 'isArray',\r\n\t            'isString', 'isObject', 'isFunction', 'extend',\r\n\t            'merge', \"mergeAll\"\r\n\t        ],\r\n\t        function (name) {\r\n\t            fishTopoFlow.util[name] = zrUtil[name];\r\n\t        }\r\n\t    );\r\n\t\r\n\t    module.exports = fishTopoFlow;\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t\r\n\t    //polyfill bind\r\n\t    if (!Function.prototype.bind) {\r\n\t        Function.prototype.bind = function(oThis) {\r\n\t            if (typeof this !== \"function\") {\r\n\t                // closest thing possible to the ECMAScript 5 internal IsCallable function\r\n\t                throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\r\n\t            }\r\n\t\r\n\t            var aArgs = Array.prototype.slice.call(arguments, 1),\r\n\t                fToBind = this,\r\n\t                fNOP = function() {},\r\n\t                fBound = function() {\r\n\t                    return fToBind.apply(this instanceof fNOP && oThis ? this : oThis || window,\r\n\t                        aArgs.concat(Array.prototype.slice.call(arguments)));\r\n\t                };\r\n\t\r\n\t            fNOP.prototype = this.prototype;\r\n\t            fBound.prototype = new fNOP();\r\n\t\r\n\t            return fBound;\r\n\t        };\r\n\t    }\r\n\t\r\n\t    //polyfill remove\r\n\t    if (!('remove' in Element.prototype)) {\r\n\t        Element.prototype.remove = function() {\r\n\t            if (this.parentNode) {\r\n\t                this.parentNode.removeChild(this);\r\n\t            }\r\n\t        };\r\n\t    }\r\n\t\r\n\t    if (!String.prototype.endsWith) {\r\n\t    String.prototype.endsWith = function(searchString, position) {\r\n\t        var subjectString = this.toString();\r\n\t        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\r\n\t            position = subjectString.length;\r\n\t        }\r\n\t        position -= searchString.length;\r\n\t        var lastIndex = subjectString.indexOf(searchString, position);\r\n\t        return lastIndex !== -1 && lastIndex === position;\r\n\t    };\r\n\t    }\r\n\t\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t\r\n\t    var pathTool = __webpack_require__(6);\r\n\t    var round = Math.round;\r\n\t    var Path = __webpack_require__(7);\r\n\t    var colorTool = __webpack_require__(20);\r\n\t    var matrix = __webpack_require__(14);\r\n\t    var vector = __webpack_require__(15);\r\n\t    var Gradient = __webpack_require__(42);\r\n\t    var Draggable = __webpack_require__(43);\r\n\t\r\n\t    var graphic = {};\r\n\t    graphic.Util = zrUtil;\r\n\t    graphic.Group = __webpack_require__(44);\r\n\t\r\n\t    graphic.Image = __webpack_require__(45);\r\n\t\r\n\t    graphic.Text = __webpack_require__(46);\r\n\t\r\n\t    graphic.textContain = __webpack_require__(26);\r\n\t\r\n\t    graphic.Circle = __webpack_require__(47);\r\n\t\r\n\t    graphic.Sector = __webpack_require__(48);\r\n\t\r\n\t    graphic.Ring = __webpack_require__(51);\r\n\t\r\n\t    graphic.Polygon = __webpack_require__(52);\r\n\t\r\n\t    graphic.Polyline = __webpack_require__(56);\r\n\t\r\n\t    graphic.Rect = __webpack_require__(57);\r\n\t\r\n\t    graphic.Line = __webpack_require__(58);\r\n\t\r\n\t    graphic.BezierCurve = __webpack_require__(59);\r\n\t\r\n\t    graphic.Arc = __webpack_require__(60);\r\n\t\r\n\t    graphic.LinearGradient = __webpack_require__(61);\r\n\t\r\n\t    graphic.RadialGradient = __webpack_require__(62);\r\n\t\r\n\t    graphic.BoundingRect = __webpack_require__(27);\r\n\t    graphic.States = __webpack_require__(63);\r\n\t    /**\r\n\t     * Extend shape with parameters\r\n\t     */\r\n\t    graphic.extendShape = function (opts) {\r\n\t        return Path.extend(opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Extend path\r\n\t     */\r\n\t    graphic.extendPath = function (pathData, opts) {\r\n\t        return pathTool.extendFromString(pathData, opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Create a path element from path data string\r\n\t     * @param {string} pathData\r\n\t     * @param {Object} opts\r\n\t     * @param {module:zrender/core/BoundingRect} rect\r\n\t     * @param {string} [layout=cover] 'center' or 'cover'\r\n\t     */\r\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\r\n\t        var path = pathTool.createFromString(pathData, opts);\r\n\t        Draggable.call(path);\r\n\t        var boundingRect = path.getBoundingRect();\r\n\t        if (rect) {\r\n\t            var aspect = boundingRect.width / boundingRect.height;\r\n\t\r\n\t            if (layout === 'center') {\r\n\t                // Set rect to center, keep width / height ratio.\r\n\t                var width = rect.height * aspect;\r\n\t                var height;\r\n\t                if (width <= rect.width) {\r\n\t                    height = rect.height;\r\n\t                }\r\n\t                else {\r\n\t                    width = rect.width;\r\n\t                    height = width / aspect;\r\n\t                }\r\n\t                var cx = rect.x + rect.width / 2;\r\n\t                var cy = rect.y + rect.height / 2;\r\n\t\r\n\t                rect.x = cx - width / 2;\r\n\t                rect.y = cy - height / 2;\r\n\t                rect.width = width;\r\n\t                rect.height = height;\r\n\t            }\r\n\t\r\n\t            this.resizePath(path, rect);\r\n\t        }\r\n\t\r\n\t        zrUtil.inherits(path, Draggable);\r\n\t        return path;\r\n\t    };\r\n\t\r\n\t    graphic.mergePath = pathTool.mergePath;\r\n\t\r\n\t    /**\r\n\t     * Resize a path to fit the rect\r\n\t     * @param {module:zrender/graphic/Path} path\r\n\t     * @param {Object} rect\r\n\t     */\r\n\t    graphic.resizePath = function (path, rect) {\r\n\t        if (!path.applyTransform) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var pathRect = path.getBoundingRect();\r\n\t\r\n\t        var m = pathRect.calculateTransform(rect);\r\n\t\r\n\t        path.applyTransform(m);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize line for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x1]\r\n\t     * @param {number} [param.shape.y1]\r\n\t     * @param {number} [param.shape.x2]\r\n\t     * @param {number} [param.shape.y2]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeLine = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t\r\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n\t        }\r\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n\t        }\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize rect for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x]\r\n\t     * @param {number} [param.shape.y]\r\n\t     * @param {number} [param.shape.width]\r\n\t     * @param {number} [param.shape.height]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeRect = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t        var originX = shape.x;\r\n\t        var originY = shape.y;\r\n\t        var originWidth = shape.width;\r\n\t        var originHeight = shape.height;\r\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n\t        shape.width = Math.max(\r\n\t            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n\t            originWidth === 0 ? 0 : 1\r\n\t        );\r\n\t        shape.height = Math.max(\r\n\t            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n\t            originHeight === 0 ? 0 : 1\r\n\t        );\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize for canvas\r\n\t     *\r\n\t     * @param {number} position Coordinate, such as x, y\r\n\t     * @param {number} lineWidth Should be nonnegative integer.\r\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\r\n\t     * @return {number} Optimized position.\r\n\t     */\r\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\r\n\t        // otherwise line will be fuzzy in canvas.\r\n\t        var doubledPosition = round(position * 2);\r\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n\t            ? doubledPosition / 2\r\n\t            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    function doSingleEnterHover(el) {\r\n\t        if (el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t        if (el.__hoverStlDirty) {\r\n\t            var stroke = el.style.stroke;\r\n\t            var fill = el.style.fill;\r\n\t\r\n\t            // Create hoverStyle on mouseover\r\n\t            var hoverStyle = el.__hoverStl;\r\n\t            var lift = colorTool.lift;\r\n\t            hoverStyle.fill = hoverStyle.fill\r\n\t                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n\t            hoverStyle.stroke = hoverStyle.stroke\r\n\t                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\t\r\n\t            var normalStyle = {};\r\n\t            for (var name in hoverStyle) {\r\n\t                if (hoverStyle.hasOwnProperty(name)) {\r\n\t                    normalStyle[name] = el.style[name];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            el.__normalStl = normalStyle;\r\n\t\r\n\t            el.__hoverStlDirty = false;\r\n\t        }\r\n\t        el.setStyle(el.__hoverStl);\r\n\t        el.z2 += 1;\r\n\t\r\n\t        el.__isHover = true;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doSingleLeaveHover(el) {\r\n\t        if (!el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var normalStl = el.__normalStl;\r\n\t        normalStl && el.setStyle(normalStl);\r\n\t        el.z2 -= 1;\r\n\t\r\n\t        el.__isHover = false;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doEnterHover(el) {\r\n\t        (el.type === 'group' || el.type === 'GroupNode')\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleEnterHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleEnterHover(el);\r\n\t    }\r\n\t    graphic.doEnterHover = doEnterHover;\r\n\t    function doLeaveHover(el) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleLeaveHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleLeaveHover(el);\r\n\t    }\r\n\t    graphic.doLeaveHover = doLeaveHover;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function setElementHoverStl(el, hoverStl) {\r\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n\t        // Often used when item group has a label element and it's hoverStyle is different\r\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n\t        el.__hoverStlDirty = true;\r\n\t    }\r\n\t    graphic.setElementHoverStl = setElementHoverStl;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOver() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOut() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function enterEmphasis() {\r\n\t        this.__isEmphasis = true;\r\n\t        doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function leaveEmphasis() {\r\n\t        this.__isEmphasis = false;\r\n\t        doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Set hover style of element\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} [hoverStyle]\r\n\t     */\r\n\t    graphic.setHoverStyle = function (el, hoverStyle) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    setElementHoverStl(child, hoverStyle);\r\n\t                }\r\n\t            })\r\n\t            : setElementHoverStl(el, hoverStyle);\r\n\t        // Remove previous bound handlers\r\n\t        el.on('mouseover', onElementMouseOver)\r\n\t          .on('mouseout', onElementMouseOut);\r\n\t\r\n\t        // Emphasis, normal can be triggered manually\r\n\t        el.on('emphasis', enterEmphasis)\r\n\t          .on('normal', leaveEmphasis);\r\n\t    };\r\n\t\r\n\t    graphic.setNormalStyle = function(el, options) {\r\n\t        if (el.__normalStl) {\r\n\t            for (var name in options) {\r\n\t                if (el.__normalStl.hasOwnProperty(name)) {\r\n\t                    el.__normalStl[name] = options[name];\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Set text option in the style\r\n\t     * @param {Object} textStyle\r\n\t     * @param {module:echarts/model/Model} labelModel\r\n\t     * @param {string} color\r\n\t     */\r\n\t    graphic.setText = function (textStyle, labelModel, color) {\r\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n\t        var textStyleModel = labelModel.getModel('textStyle');\r\n\t        zrUtil.extend(textStyle, {\r\n\t            textDistance: labelModel.getShallow('distance') || 5,\r\n\t            textFont: textStyleModel.getFont(),\r\n\t            textPosition: labelPosition,\r\n\t            textFill: textStyleModel.getTextColor() || labelColor\r\n\t        });\r\n\t    };\r\n\t\r\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n\t        var postfix = isUpdate ? 'Update' : '';\r\n\t        var duration = animatableModel\r\n\t            && animatableModel.getShallow('animationDuration' + postfix);\r\n\t        var animationEasing = animatableModel\r\n\t            && animatableModel.getShallow('animationEasing' + postfix);\r\n\t\r\n\t        animatableModel && animatableModel.getShallow('animation')\r\n\t            ? el.animateTo(props, duration, animationEasing, cb)\r\n\t            : (el.attr(props), cb && cb());\r\n\t    }\r\n\t    /**\r\n\t     * Update graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\t\r\n\t    /**\r\n\t     * Init graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\t\r\n\t    /**\r\n\t     * Get transform matrix of target (param target),\r\n\t     * in coordinate of its ancestor (param ancestor)\r\n\t     *\r\n\t     * @param {module:zrender/mixin/Transformable} target\r\n\t     * @param {module:zrender/mixin/Transformable} ancestor\r\n\t     */\r\n\t    graphic.getTransform = function (target, ancestor) {\r\n\t        var mat = matrix.identity([]);\r\n\t\r\n\t        while (target && target !== ancestor) {\r\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\r\n\t            target = target.parent;\r\n\t        }\r\n\t\r\n\t        return mat;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Apply transform to an vertex.\r\n\t     * @param {Array.<number>} vertex [x, y]\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {Array.<number>} [x, y]\r\n\t     */\r\n\t    graphic.applyTransform = function (vertex, transform, invert) {\r\n\t        if (invert) {\r\n\t            transform = matrix.invert([], transform);\r\n\t        }\r\n\t        return vector.applyTransform([], vertex, transform);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n\t     */\r\n\t    graphic.transformDirection = function (direction, transform, invert) {\r\n\t\r\n\t        // Pick a base, ensure that transform result will not be (0, 0).\r\n\t        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n\t        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\t\r\n\t        var vertex = [\r\n\t            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n\t            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n\t        ];\r\n\t\r\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\t\r\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n\t            ? (vertex[0] > 0 ? 'right' : 'left')\r\n\t            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n\t    };\r\n\t\r\n\t    module.exports = graphic;\r\n\t\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * @module zrender/core/util\n\t */\n\t\n\t\n\t    // 用于处理merge时无法遍历Date等对象的问题\n\t    var BUILTIN_OBJECT = {\n\t        '[object Function]': 1,\n\t        '[object RegExp]': 1,\n\t        '[object Date]': 1,\n\t        '[object Error]': 1,\n\t        '[object CanvasGradient]': 1,\n\t        '[object CanvasPattern]': 1,\n\t        // For node-canvas\n\t        '[object Image]': 1,\n\t        '[object Canvas]': 1\n\t    };\n\t\n\t    var TYPED_ARRAY = {\n\t        '[object Int8Array]': 1,\n\t        '[object Uint8Array]': 1,\n\t        '[object Uint8ClampedArray]': 1,\n\t        '[object Int16Array]': 1,\n\t        '[object Uint16Array]': 1,\n\t        '[object Int32Array]': 1,\n\t        '[object Uint32Array]': 1,\n\t        '[object Float32Array]': 1,\n\t        '[object Float64Array]': 1\n\t    };\n\t\n\t    var objToString = Object.prototype.toString;\n\t\n\t    var arrayProto = Array.prototype;\n\t    var nativeForEach = arrayProto.forEach;\n\t    var nativeFilter = arrayProto.filter;\n\t    var nativeSlice = arrayProto.slice;\n\t    var nativeMap = arrayProto.map;\n\t    var nativeReduce = arrayProto.reduce;\n\t\n\t    /**\n\t     * Those data types can be cloned:\n\t     *     Plain object, Array, TypedArray, number, string, null, undefined.\n\t     * Those data types will be assgined using the orginal data:\n\t     *     BUILTIN_OBJECT\n\t     * Instance of user defined class will be cloned to a plain object, without\n\t     * properties in prototype.\n\t     * Other data types is not supported (not sure what will happen).\n\t     *\n\t     * Caution: do not support clone Date, for performance consideration.\n\t     * (There might be a large number of date in `series.data`).\n\t     * So date should not be modified in and out of echarts.\n\t     *\n\t     * @param {*} source\n\t     * @return {*} new\n\t     */\n\t    function clone(source) {\n\t        if (source == null || typeof source != 'object') {\n\t            return source;\n\t        }\n\t\n\t        var result = source;\n\t        var typeStr = objToString.call(source);\n\t\n\t        if (typeStr === '[object Array]') {\n\t            result = [];\n\t            for (var i = 0, len = source.length; i < len; i++) {\n\t                result[i] = clone(source[i]);\n\t            }\n\t        }\n\t        else if (TYPED_ARRAY[typeStr]) {\n\t            var Ctor = source.constructor;\n\t            if (source.constructor.from) {\n\t                result = Ctor.from(source);\n\t            }\n\t            else {\n\t                result = new Ctor(source.length);\n\t                for (var i = 0, len = source.length; i < len; i++) {\n\t                    result[i] = clone(source[i]);\n\t                }\n\t            }\n\t        }\n\t        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n\t            result = {};\n\t            for (var key in source) {\n\t                if (source.hasOwnProperty(key)) {\n\t                    result[key] = clone(source[key]);\n\t                }\n\t            }\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolean} [overwrite=false]\n\t     */\n\t    function merge(target, source, overwrite) {\n\t        // We should escapse that source is string\n\t        // and enter for ... in ...\n\t        if (!isObject(source) || !isObject(target)) {\n\t            return overwrite ? clone(source) : target;\n\t        }\n\t\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                var targetProp = target[key];\n\t                var sourceProp = source[key];\n\t\n\t                if (isObject(sourceProp)\n\t                    && isObject(targetProp)\n\t                    && !isArray(sourceProp)\n\t                    && !isArray(targetProp)\n\t                    && !isDom(sourceProp)\n\t                    && !isDom(targetProp)\n\t                    && !isBuiltInObject(sourceProp)\n\t                    && !isBuiltInObject(targetProp)\n\t                    && !isPrimitive(sourceProp)\n\t                    && !isPrimitive(targetProp)\n\t                ) {\n\t                    // 如果需要递归覆盖，就递归调用merge\n\t                    merge(targetProp, sourceProp, overwrite);\n\t                }\n\t                else if (overwrite || !(key in target)) {\n\t                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n\t                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n\t                    target[key] = clone(source[key], true);\n\t                }\n\t            }\n\t        }\n\t\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t     * @param {boolean} [overwrite=false]\n\t     * @return {*} target\n\t     */\n\t    function mergeAll(targetAndSources, overwrite) {\n\t        var result = targetAndSources[0];\n\t        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t            result = merge(result, targetAndSources[i], overwrite);\n\t        }\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function extend(target, source) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolean} [overlay=false]\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function defaults(target, source, overlay) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)\n\t                && (overlay ? source[key] != null : target[key] == null)\n\t            ) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    function createCanvas() {\n\t        return document.createElement('canvas');\n\t    }\n\t    // FIXME\n\t    var _ctx;\n\t    function getContext() {\n\t        if (!_ctx) {\n\t            // Use util.createCanvas instead of createCanvas\n\t            // because createCanvas may be overwritten in different environment\n\t            _ctx = util.createCanvas().getContext('2d');\n\t        }\n\t        return _ctx;\n\t    }\n\t\n\t    /**\n\t     * 查询数组中元素的index\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function indexOf(array, value) {\n\t        if (array) {\n\t            if (array.indexOf) {\n\t                return array.indexOf(value);\n\t            }\n\t            for (var i = 0, len = array.length; i < len; i++) {\n\t                if (array[i] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    /**\n\t     * 构造类继承关系\n\t     *\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} clazz 源类\n\t     * @param {Function} baseClazz 基类\n\t     */\n\t    function inherits(clazz, baseClazz) {\n\t        var clazzPrototype = clazz.prototype;\n\t        function F() {}\n\t        F.prototype = baseClazz.prototype;\n\t        clazz.prototype = new F();\n\t\n\t        for (var prop in clazzPrototype) {\n\t            clazz.prototype[prop] = clazzPrototype[prop];\n\t        }\n\t        clazz.prototype.constructor = clazz;\n\t        clazz.superClass = baseClazz;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Function} target\n\t     * @param {Object|Function} sorce\n\t     * @param {boolean} overlay\n\t     */\n\t    function mixin(target, source, overlay) {\n\t        target = 'prototype' in target ? target.prototype : target;\n\t        source = 'prototype' in source ? source.prototype : source;\n\t\n\t        defaults(target, source, overlay);\n\t    }\n\t\n\t    /**\n\t     * Consider typed array.\n\t     * @param {Array|TypedArray} data\n\t     */\n\t    function isArrayLike(data) {\n\t        if (! data) {\n\t            return;\n\t        }\n\t        if (typeof data == 'string') {\n\t            return false;\n\t        }\n\t        return typeof data.length == 'number';\n\t    }\n\t\n\t    /**\n\t     * 数组或对象遍历\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     */\n\t    function each(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.forEach && obj.forEach === nativeForEach) {\n\t            obj.forEach(cb, context);\n\t        }\n\t        else if (obj.length === +obj.length) {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                cb.call(context, obj[i], i, obj);\n\t            }\n\t        }\n\t        else {\n\t            for (var key in obj) {\n\t                if (obj.hasOwnProperty(key)) {\n\t                    cb.call(context, obj[key], key, obj);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组映射\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function map(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.map && obj.map === nativeMap) {\n\t            return obj.map(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                result.push(cb.call(context, obj[i], i, obj));\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {Object} [memo]\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function reduce(obj, cb, memo, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.reduce && obj.reduce === nativeReduce) {\n\t            return obj.reduce(cb, memo, context);\n\t        }\n\t        else {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                memo = cb.call(context, memo, obj[i], i, obj);\n\t            }\n\t            return memo;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组过滤\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function filter(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.filter && obj.filter === nativeFilter) {\n\t            return obj.filter(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                if (cb.call(context, obj[i], i, obj)) {\n\t                    result.push(obj[i]);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组项查找\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function find(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        for (var i = 0, len = obj.length; i < len; i++) {\n\t            if (cb.call(context, obj[i], i, obj)) {\n\t                return obj[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @param {*} context\n\t     * @return {Function}\n\t     */\n\t    function bind(func, context) {\n\t        var args = nativeSlice.call(arguments, 2);\n\t        return function () {\n\t            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @return {Function}\n\t     */\n\t    function curry(func) {\n\t        var args = nativeSlice.call(arguments, 1);\n\t        return function () {\n\t            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isArray(value) {\n\t        return objToString.call(value) === '[object Array]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isFunction(value) {\n\t        return typeof value === 'function';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isString(value) {\n\t        return objToString.call(value) === '[object String]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isObject(value) {\n\t        // Avoid a V8 JIT bug in Chrome 19-20.\n\t        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t        var type = typeof value;\n\t        return type === 'function' || (!!value && type == 'object');\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isBuiltInObject(value) {\n\t        return !!BUILTIN_OBJECT[objToString.call(value)];\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isDom(value) {\n\t        return typeof value === 'object'\n\t            && typeof value.nodeType === 'number'\n\t            && typeof value.ownerDocument === 'object';\n\t    }\n\t\n\t    /**\n\t     * Whether is exactly NaN. Notice isNaN('a') returns true.\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function eqNaN(value) {\n\t        return value !== value;\n\t    }\n\t\n\t    /**\n\t     * If value1 is not null, then return value1, otherwise judget rest of values.\n\t     * Low performance.\n\t     * @memberOf module:zrender/core/util\n\t     * @return {*} Final value\n\t     */\n\t    function retrieve(values) {\n\t        for (var i = 0, len = arguments.length; i < len; i++) {\n\t            if (arguments[i] != null) {\n\t                return arguments[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    function retrieve2(value0, value1) {\n\t        return value0 != null\n\t            ? value0\n\t            : value1;\n\t    }\n\t\n\t    function retrieve3(value0, value1, value2) {\n\t        return value0 != null\n\t            ? value0\n\t            : value1 != null\n\t            ? value1\n\t            : value2;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} arr\n\t     * @param {number} startIndex\n\t     * @param {number} endIndex\n\t     * @return {Array}\n\t     */\n\t    function slice() {\n\t        return Function.call.apply(nativeSlice, arguments);\n\t    }\n\t\n\t    /**\n\t     * Normalize css liked array configuration\n\t     * e.g.\n\t     *  3 => [3, 3, 3, 3]\n\t     *  [4, 2] => [4, 2, 4, 2]\n\t     *  [4, 3, 2] => [4, 3, 2, 3]\n\t     * @param {number|Array.<number>} val\n\t     * @return {Array.<number>}\n\t     */\n\t    function normalizeCssArray(val) {\n\t        if (typeof (val) === 'number') {\n\t            return [val, val, val, val];\n\t        }\n\t        var len = val.length;\n\t        if (len === 2) {\n\t            // vertical | horizontal\n\t            return [val[0], val[1], val[0], val[1]];\n\t        }\n\t        else if (len === 3) {\n\t            // top | horizontal | bottom\n\t            return [val[0], val[1], val[2], val[1]];\n\t        }\n\t        return val;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {boolean} condition\n\t     * @param {string} message\n\t     */\n\t    function assert(condition, message) {\n\t        if (!condition) {\n\t            throw new Error(message);\n\t        }\n\t    }\n\t\n\t    var primitiveKey = '__ec_primitive__';\n\t    /**\n\t     * Set an object as primitive to be ignored traversing children in clone or merge\n\t     */\n\t    function setAsPrimitive(obj) {\n\t        obj[primitiveKey] = true;\n\t    }\n\t\n\t    function isPrimitive(obj) {\n\t        return obj[primitiveKey];\n\t    }\n\t\n\t    /**\n\t     * @constructor\n\t     * @param {Object} obj Only apply `ownProperty`.\n\t     */\n\t    function HashMap(obj) {\n\t        obj && each(obj, function (value, key) {\n\t            this.set(key, value);\n\t        }, this);\n\t    }\n\t\n\t    // Add prefix to avoid conflict with Object.prototype.\n\t    var HASH_MAP_PREFIX = '_ec_';\n\t    var HASH_MAP_PREFIX_LENGTH = 4;\n\t\n\t    HashMap.prototype = {\n\t        constructor: HashMap,\n\t        // Do not provide `has` method to avoid defining what is `has`.\n\t        // (We usually treat `null` and `undefined` as the same, different\n\t        // from ES6 Map).\n\t        get: function (key) {\n\t            return this[HASH_MAP_PREFIX + key];\n\t        },\n\t        set: function (key, value) {\n\t            this[HASH_MAP_PREFIX + key] = value;\n\t            // Comparing with invocation chaining, `return value` is more commonly\n\t            // used in this case: `var someVal = map.set('a', genVal());`\n\t            return value;\n\t        },\n\t        // Although util.each can be performed on this hashMap directly, user\n\t        // should not use the exposed keys, who are prefixed.\n\t        each: function (cb, context) {\n\t            context !== void 0 && (cb = bind(cb, context));\n\t            for (var prefixedKey in this) {\n\t                this.hasOwnProperty(prefixedKey)\n\t                    && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n\t            }\n\t        },\n\t        // Do not use this method if performance sensitive.\n\t        removeKey: function (key) {\n\t            delete this[HASH_MAP_PREFIX + key];\n\t        }\n\t    };\n\t\n\t    function createHashMap(obj) {\n\t        return new HashMap(obj);\n\t    }\n\t\n\t    var util = {\n\t        inherits: inherits,\n\t        mixin: mixin,\n\t        clone: clone,\n\t        merge: merge,\n\t        mergeAll: mergeAll,\n\t        extend: extend,\n\t        defaults: defaults,\n\t        getContext: getContext,\n\t        createCanvas: createCanvas,\n\t        indexOf: indexOf,\n\t        slice: slice,\n\t        find: find,\n\t        isArrayLike: isArrayLike,\n\t        each: each,\n\t        map: map,\n\t        reduce: reduce,\n\t        filter: filter,\n\t        bind: bind,\n\t        curry: curry,\n\t        isArray: isArray,\n\t        isString: isString,\n\t        isObject: isObject,\n\t        isFunction: isFunction,\n\t        isBuiltInObject: isBuiltInObject,\n\t        isDom: isDom,\n\t        eqNaN: eqNaN,\n\t        retrieve: retrieve,\n\t        retrieve2: retrieve2,\n\t        retrieve3: retrieve3,\n\t        assert: assert,\n\t        setAsPrimitive: setAsPrimitive,\n\t        createHashMap: createHashMap,\n\t        normalizeCssArray: normalizeCssArray,\n\t        noop: function () {}\n\t    };\n\t    module.exports = util;\n\t\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Path = __webpack_require__(7);\n\t    var PathProxy = __webpack_require__(30);\n\t    var transformPath = __webpack_require__(41);\n\t\n\t    // command chars\n\t    var cc = [\n\t        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n\t        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n\t    ];\n\t\n\t    var mathSqrt = Math.sqrt;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var PI = Math.PI;\n\t\n\t    var vMag = function(v) {\n\t        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t    };\n\t    var vRatio = function(u, v) {\n\t        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t    };\n\t    var vAngle = function(u, v) {\n\t        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n\t                * Math.acos(vRatio(u, v));\n\t    };\n\t\n\t    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t        var psi = psiDeg * (PI / 180.0);\n\t        var xp = mathCos(psi) * (x1 - x2) / 2.0\n\t                 + mathSin(psi) * (y1 - y2) / 2.0;\n\t        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n\t                 + mathCos(psi) * (y1 - y2) / 2.0;\n\t\n\t        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\t\n\t        if (lambda > 1) {\n\t            rx *= mathSqrt(lambda);\n\t            ry *= mathSqrt(lambda);\n\t        }\n\t\n\t        var f = (fa === fs ? -1 : 1)\n\t            * mathSqrt((((rx * rx) * (ry * ry))\n\t                    - ((rx * rx) * (yp * yp))\n\t                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n\t                    + (ry * ry) * (xp * xp))\n\t                ) || 0;\n\t\n\t        var cxp = f * rx * yp / ry;\n\t        var cyp = f * -ry * xp / rx;\n\t\n\t        var cx = (x1 + x2) / 2.0\n\t                 + mathCos(psi) * cxp\n\t                 - mathSin(psi) * cyp;\n\t        var cy = (y1 + y2) / 2.0\n\t                + mathSin(psi) * cxp\n\t                + mathCos(psi) * cyp;\n\t\n\t        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n\t        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n\t        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n\t        var dTheta = vAngle(u, v);\n\t\n\t        if (vRatio(u, v) <= -1) {\n\t            dTheta = PI;\n\t        }\n\t        if (vRatio(u, v) >= 1) {\n\t            dTheta = 0;\n\t        }\n\t        if (fs === 0 && dTheta > 0) {\n\t            dTheta = dTheta - 2 * PI;\n\t        }\n\t        if (fs === 1 && dTheta < 0) {\n\t            dTheta = dTheta + 2 * PI;\n\t        }\n\t\n\t        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t    }\n\t\n\t    function createPathProxyFromString(data) {\n\t        if (!data) {\n\t            return [];\n\t        }\n\t\n\t        // command string\n\t        var cs = data.replace(/-/g, ' -')\n\t            .replace(/  /g, ' ')\n\t            .replace(/ /g, ',')\n\t            .replace(/,,/g, ',');\n\t\n\t        var n;\n\t        // create pipes so that we can split the data\n\t        for (n = 0; n < cc.length; n++) {\n\t            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t        }\n\t\n\t        // create array\n\t        var arr = cs.split('|');\n\t        // init context point\n\t        var cpx = 0;\n\t        var cpy = 0;\n\t\n\t        var path = new PathProxy();\n\t        var CMD = PathProxy.CMD;\n\t\n\t        var prevCmd;\n\t        for (n = 1; n < arr.length; n++) {\n\t            var str = arr[n];\n\t            var c = str.charAt(0);\n\t            var off = 0;\n\t            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t            var cmd;\n\t\n\t            if (p.length > 0 && p[0] === '') {\n\t                p.shift();\n\t            }\n\t\n\t            for (var i = 0; i < p.length; i++) {\n\t                p[i] = parseFloat(p[i]);\n\t            }\n\t            while (off < p.length && !isNaN(p[off])) {\n\t                if (isNaN(p[0])) {\n\t                    break;\n\t                }\n\t                var ctlPtx;\n\t                var ctlPty;\n\t\n\t                var rx;\n\t                var ry;\n\t                var psi;\n\t                var fa;\n\t                var fs;\n\t\n\t                var x1 = cpx;\n\t                var y1 = cpy;\n\t\n\t                // convert l, H, h, V, and v to L\n\t                switch (c) {\n\t                    case 'l':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'L':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'm':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'l';\n\t                        break;\n\t                    case 'M':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'L';\n\t                        break;\n\t                    case 'h':\n\t                        cpx += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'H':\n\t                        cpx = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'v':\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'V':\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'C':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n\t                        );\n\t                        cpx = p[off - 2];\n\t                        cpy = p[off - 1];\n\t                        break;\n\t                    case 'c':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy\n\t                        );\n\t                        cpx += p[off - 2];\n\t                        cpy += p[off - 1];\n\t                        break;\n\t                    case 'S':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 's':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = cpx + p[off++];\n\t                        y1 = cpy + p[off++];\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'Q':\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'q':\n\t                        x1 = p[off++] + cpx;\n\t                        y1 = p[off++] + cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'T':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 't':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 'A':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                    case 'a':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                }\n\t            }\n\t\n\t            if (c === 'z' || c === 'Z') {\n\t                cmd = CMD.Z;\n\t                path.addData(cmd);\n\t            }\n\t\n\t            prevCmd = cmd;\n\t        }\n\t\n\t        path.toStatic();\n\t\n\t        return path;\n\t    }\n\t\n\t    // TODO Optimize double memory cost problem\n\t    function createPathOptions(str, opts) {\n\t        var pathProxy = createPathProxyFromString(str);\n\t        opts = opts || {};\n\t        opts.buildPath = function (path) {\n\t            if (path.setData) {\n\t                path.setData(pathProxy.data);\n\t                // Svg and vml renderer don't have context\n\t                var ctx = path.getContext();\n\t                if (ctx) {\n\t                    path.rebuildPath(ctx);\n\t                }\n\t            }\n\t            else {\n\t                var ctx = path;\n\t                pathProxy.rebuildPath(ctx);\n\t            }\n\t        };\n\t\n\t        opts.applyTransform = function (m) {\n\t            transformPath(pathProxy, m);\n\t\n\t            this.dirty(true);\n\t        };\n\t\n\t        return opts;\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Create a Path object from path string data\n\t         * http://www.w3.org/TR/SVG/paths.html#PathData\n\t         * @param  {Object} opts Other options\n\t         */\n\t        createFromString: function (str, opts) {\n\t            return new Path(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Create a Path class from path string data\n\t         * @param  {string} str\n\t         * @param  {Object} opts Other options\n\t         */\n\t        extendFromString: function (str, opts) {\n\t            return Path.extend(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Merge multiple paths\n\t         */\n\t        // TODO Apply transform\n\t        // TODO stroke dash\n\t        // TODO Optimize double memory cost problem\n\t        mergePath: function (pathEls, opts) {\n\t            var pathList = [];\n\t            var len = pathEls.length;\n\t            for (var i = 0; i < len; i++) {\n\t                var pathEl = pathEls[i];\n\t                if (!pathEl.path) {\n\t                    pathEl.createPathProxy();\n\t                }\n\t                if (pathEl.__dirtyPath) {\n\t                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t                }\n\t                pathList.push(pathEl.path);\n\t            }\n\t\n\t            var pathBundle = new Path(opts);\n\t            // Need path proxy.\n\t            pathBundle.createPathProxy();\n\t            pathBundle.buildPath = function (path) {\n\t                path.appendPath(pathList);\n\t                // Svg and vml renderer don't have context\n\t                var ctx = path.getContext();\n\t                if (ctx) {\n\t                    path.rebuildPath(ctx);\n\t                }\n\t            };\n\t\n\t            return pathBundle;\n\t        }\n\t    };\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Path element\n\t * @module zrender/graphic/Path\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(8);\n\t    var zrUtil = __webpack_require__(5);\n\t    var PathProxy = __webpack_require__(30);\n\t    var pathContain = __webpack_require__(33);\n\t\n\t    var Pattern = __webpack_require__(40);\n\t    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\t\n\t    var abs = Math.abs;\n\t\n\t    var pathProxyForDraw = new PathProxy(true);\n\t    /**\n\t     * @alias module:zrender/graphic/Path\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function Path(opts) {\n\t        Displayable.call(this, opts);\n\t\n\t        /**\n\t         * @type {module:zrender/core/PathProxy}\n\t         * @readOnly\n\t         */\n\t        this.path = null;\n\t    }\n\t\n\t    Path.prototype = {\n\t\n\t        constructor: Path,\n\t\n\t        type: 'path',\n\t\n\t        __dirtyPath: true,\n\t\n\t        strokeContainThreshold: 5,\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var path = this.path || pathProxyForDraw;\n\t            var hasStroke = style.hasStroke();\n\t            var hasFill = style.hasFill();\n\t            var fill = style.fill;\n\t            var stroke = style.stroke;\n\t            var hasFillGradient = hasFill && !!(fill.colorStops);\n\t            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n\t            var hasFillPattern = hasFill && !!(fill.image);\n\t            var hasStrokePattern = hasStroke && !!(stroke.image);\n\t\n\t            style.bind(ctx, this, prevEl);\n\t            this.setTransform(ctx);\n\t\n\t            if (this.__dirty) {\n\t                var rect;\n\t                // Update gradient because bounding rect may changed\n\t                if (hasFillGradient) {\n\t                    rect = rect || this.getBoundingRect();\n\t                    this._fillGradient = style.getGradient(ctx, fill, rect);\n\t                }\n\t                if (hasStrokeGradient) {\n\t                    rect = rect || this.getBoundingRect();\n\t                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t                }\n\t            }\n\t            // Use the gradient or pattern\n\t            if (hasFillGradient) {\n\t                // PENDING If may have affect the state\n\t                ctx.fillStyle = this._fillGradient;\n\t            }\n\t            else if (hasFillPattern) {\n\t                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t            }\n\t            if (hasStrokeGradient) {\n\t                ctx.strokeStyle = this._strokeGradient;\n\t            }\n\t            else if (hasStrokePattern) {\n\t                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t            }\n\t\n\t            var lineDash = style.lineDash;\n\t            var lineDashOffset = style.lineDashOffset;\n\t\n\t            var ctxLineDash = !!ctx.setLineDash;\n\t\n\t            // Update path sx, sy\n\t            var scale = this.getGlobalScale();\n\t            path.setScale(scale[0], scale[1]);\n\t\n\t            // Proxy context\n\t            // Rebuild path in following 2 cases\n\t            // 1. Path is dirty\n\t            // 2. Path needs javascript implemented lineDash stroking.\n\t            //    In this case, lineDash information will not be saved in PathProxy\n\t            if (this.__dirtyPath\n\t                || (lineDash && !ctxLineDash && hasStroke)\n\t            ) {\n\t                path.beginPath(ctx);\n\t\n\t                // Setting line dash before build path\n\t                if (lineDash && !ctxLineDash) {\n\t                    path.setLineDash(lineDash);\n\t                    path.setLineDashOffset(lineDashOffset);\n\t                }\n\t\n\t                this.buildPath(path, this.shape, false);\n\t\n\t                // Clear path dirty flag\n\t                if (this.path) {\n\t                    this.__dirtyPath = false;\n\t                }\n\t            }\n\t            else {\n\t                // Replay path building\n\t                ctx.beginPath();\n\t                this.path.rebuildPath(ctx);\n\t            }\n\t\n\t            hasFill && path.fill(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                ctx.setLineDash(lineDash);\n\t                ctx.lineDashOffset = lineDashOffset;\n\t            }\n\t\n\t            hasStroke && path.stroke(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                // PENDING\n\t                // Remove lineDash\n\t                ctx.setLineDash([]);\n\t            }\n\t\n\t            this.restoreTransform(ctx);\n\t\n\t            // Draw rect text\n\t            if (style.text != null) {\n\t                this.drawRectText(ctx, this.getBoundingRect());\n\t            }\n\t        },\n\t\n\t        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n\t        // Like in circle\n\t        buildPath: function (ctx, shapeCfg, inBundle) {},\n\t\n\t        createPathProxy: function () {\n\t            this.path = new PathProxy();\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            var rect = this._rect;\n\t            var style = this.style;\n\t            var needsUpdateRect = !rect;\n\t            if (needsUpdateRect) {\n\t                var path = this.path;\n\t                if (!path) {\n\t                    // Create path on demand.\n\t                    path = this.path = new PathProxy();\n\t                }\n\t                if (this.__dirtyPath) {\n\t                    path.beginPath();\n\t                    this.buildPath(path, this.shape, false);\n\t                }\n\t                rect = path.getBoundingRect();\n\t            }\n\t            this._rect = rect;\n\t\n\t            if (style.hasStroke()) {\n\t                // Needs update rect with stroke lineWidth when\n\t                // 1. Element changes scale or lineWidth\n\t                // 2. Shape is changed\n\t                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t                if (this.__dirty || needsUpdateRect) {\n\t                    rectWithStroke.copy(rect);\n\t                    // FIXME Must after updateTransform\n\t                    var w = style.lineWidth;\n\t                    // PENDING, Min line width is needed when line is horizontal or vertical\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t\n\t                    // Only add extra hover lineWidth when there are no fill\n\t                    if (!style.hasFill()) {\n\t                        w = Math.max(w, this.strokeContainThreshold || 4);\n\t                    }\n\t                    // Consider line width\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        rectWithStroke.width += w / lineScale;\n\t                        rectWithStroke.height += w / lineScale;\n\t                        rectWithStroke.x -= w / lineScale / 2;\n\t                        rectWithStroke.y -= w / lineScale / 2;\n\t                    }\n\t                }\n\t\n\t                // Return rect with stroke\n\t                return rectWithStroke;\n\t            }\n\t\n\t            return rect;\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var localPos = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            var style = this.style;\n\t            x = localPos[0];\n\t            y = localPos[1];\n\t\n\t            if (rect.contain(x, y)) {\n\t                var pathData = this.path.data;\n\t                if (style.hasStroke()) {\n\t                    var lineWidth = style.lineWidth;\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        // Only add extra hover lineWidth when there are no fill\n\t                        if (!style.hasFill()) {\n\t                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t                        }\n\t                        if (pathContain.containStroke(\n\t                            pathData, lineWidth / lineScale, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t                if (style.hasFill()) {\n\t                    return pathContain.contain(pathData, x, y);\n\t                }\n\t            }\n\t            return false;\n\t        },\n\t\n\t        /**\n\t         * @param  {boolean} dirtyPath\n\t         */\n\t        dirty: function (dirtyPath) {\n\t            if (dirtyPath == null) {\n\t                dirtyPath = true;\n\t            }\n\t            // Only mark dirty, not mark clean\n\t            if (dirtyPath) {\n\t                this.__dirtyPath = dirtyPath;\n\t                this._rect = null;\n\t            }\n\t\n\t            this.__dirty = true;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t\n\t            // Used as a clipping path\n\t            if (this.__clipTarget) {\n\t                this.__clipTarget.dirty();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Alias for animate('shape')\n\t         * @param {boolean} loop\n\t         */\n\t        animateShape: function (loop) {\n\t            return this.animate('shape', loop);\n\t        },\n\t\n\t        // Overwrite attrKV\n\t        attrKV: function (key, value) {\n\t            // FIXME\n\t            if (key === 'shape') {\n\t                this.setShape(value);\n\t                this.__dirtyPath = true;\n\t                this._rect = null;\n\t            }\n\t            else {\n\t                Displayable.prototype.attrKV.call(this, key, value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setShape: function (key, value) {\n\t            var shape = this.shape;\n\t            // Path from string may not have shape\n\t            if (shape) {\n\t                if (zrUtil.isObject(key)) {\n\t                    for (var name in key) {\n\t                        if (key.hasOwnProperty(name)) {\n\t                            shape[name] = key[name];\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    shape[key] = value;\n\t                }\n\t                this.dirty(true);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        getLineScale: function () {\n\t            var m = this.transform;\n\t            // Get the line scale.\n\t            // Determinant of `m` means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n\t                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n\t                : 1;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * 扩展一个 Path element, 比如星形，圆等。\n\t     * Extend a path element\n\t     * @param {Object} props\n\t     * @param {string} props.type Path type\n\t     * @param {Function} props.init Initialize\n\t     * @param {Function} props.buildPath Overwrite buildPath method\n\t     * @param {Object} [props.style] Extended default style config\n\t     * @param {Object} [props.shape] Extended default shape config\n\t     */\n\t    Path.extend = function (defaults) {\n\t        var Sub = function (opts) {\n\t            Path.call(this, opts);\n\t\n\t            if (defaults.style) {\n\t                // Extend default style\n\t                this.style.extendFrom(defaults.style, false);\n\t            }\n\t\n\t            // Extend default shape\n\t            var defaultShape = defaults.shape;\n\t            if (defaultShape) {\n\t                this.shape = this.shape || {};\n\t                var thisShape = this.shape;\n\t                for (var name in defaultShape) {\n\t                    if (\n\t                        ! thisShape.hasOwnProperty(name)\n\t                        && defaultShape.hasOwnProperty(name)\n\t                    ) {\n\t                        thisShape[name] = defaultShape[name];\n\t                    }\n\t                }\n\t            }\n\t\n\t            defaults.init && defaults.init.call(this, opts);\n\t        };\n\t\n\t        zrUtil.inherits(Sub, Path);\n\t\n\t        // FIXME 不能 extend position, rotation 等引用对象\n\t        for (var name in defaults) {\n\t            // Extending prototype values and methods\n\t            if (name !== 'style' && name !== 'shape') {\n\t                Sub.prototype[name] = defaults[name];\n\t            }\n\t        }\n\t\n\t        return Sub;\n\t    };\n\t\n\t    zrUtil.inherits(Path, Displayable);\n\t\n\t    module.exports = Path;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 可绘制的图形基类\n\t * Base class of all displayable graphic objects\n\t * @module zrender/graphic/Displayable\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(5);\n\t\n\t    var Style = __webpack_require__(9);\n\t\n\t    var Element = __webpack_require__(10);\n\t    var RectText = __webpack_require__(24);\n\t    // var Stateful = require('./mixin/Stateful');\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Displayable\n\t     * @extends module:zrender/Element\n\t     * @extends module:zrender/graphic/mixin/RectText\n\t     */\n\t    function Displayable(opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        // Extend properties\n\t        for (var name in opts) {\n\t            if (\n\t                opts.hasOwnProperty(name) &&\n\t                name !== 'style'\n\t            ) {\n\t                this[name] = opts[name];\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/graphic/Style}\n\t         */\n\t        this.style = new Style(opts.style, this);\n\t\n\t        this._rect = null;\n\t        // Shapes for cascade clipping.\n\t        this.__clipPaths = [];\n\t\n\t        // FIXME Stateful must be mixined after style is setted\n\t        // Stateful.call(this, opts);\n\t    }\n\t\n\t    Displayable.prototype = {\n\t\n\t        constructor: Displayable,\n\t\n\t        type: 'displayable',\n\t\n\t        /**\n\t         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n\t         * Dirty flag. From which painter will determine if this displayable object needs brush\n\t         * @name module:zrender/graphic/Displayable#__dirty\n\t         * @type {boolean}\n\t         */\n\t        __dirty: true,\n\t\n\t        /**\n\t         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n\t         * If ignore drawing of the displayable object. Mouse event will still be triggered\n\t         * @name module:/zrender/graphic/Displayable#invisible\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        invisible: false,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z: 0,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z2: 0,\n\t\n\t        /**\n\t         * z层level，决定绘画在哪层canvas中\n\t         * @name module:/zrender/graphic/Displayable#zlevel\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        zlevel: 0,\n\t\n\t        /**\n\t         * 是否可拖拽\n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        draggable: false,\n\t\n\t        /**\n\t         * 是否正在拖拽\n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        dragging: false,\n\t\n\t        /**\n\t         * 是否相应鼠标事件\n\t         * @name module:/zrender/graphic/Displayable#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * If enable culling\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        culling: false,\n\t\n\t        /**\n\t         * Mouse cursor when hovered\n\t         * @name module:/zrender/graphic/Displayable#cursor\n\t         * @type {string}\n\t         */\n\t        cursor: 'pointer',\n\t\n\t        /**\n\t         * If hover area is bounding rect\n\t         * @name module:/zrender/graphic/Displayable#rectHover\n\t         * @type {string}\n\t         */\n\t        rectHover: false,\n\t\n\t        /**\n\t         * Render the element progressively when the value >= 0,\n\t         * usefull for large data.\n\t         * @type {number}\n\t         */\n\t        progressive: -1,\n\t\n\t        beforeBrush: function (ctx) {},\n\t\n\t        afterBrush: function (ctx) {},\n\t\n\t        /**\n\t         * 图形绘制方法\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         */\n\t        // Interface\n\t        brush: function (ctx, prevEl) {},\n\t\n\t        /**\n\t         * 获取最小包围盒\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        // Interface\n\t        getBoundingRect: function () {},\n\t\n\t        /**\n\t         * 判断坐标 x, y 是否在图形上\n\t         * If displayable element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        contain: function (x, y) {\n\t            return this.rectContain(x, y);\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            cb.call(context, this);\n\t        },\n\t\n\t        /**\n\t         * 判断坐标 x, y 是否在图形的包围盒上\n\t         * If bounding rect of element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        rectContain: function (x, y) {\n\t            var coord = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            return rect.contain(coord[0], coord[1]);\n\t        },\n\t\n\t        /**\n\t         * 标记图形元素为脏，并且在下一帧重绘\n\t         * Mark displayable element dirty and refresh next frame\n\t         */\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t\n\t            this._rect = null;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * 图形是否会触发事件\n\t         * If displayable object binded any event\n\t         * @return {boolean}\n\t         */\n\t        // TODO, 通过 bind 绑定的事件\n\t        // isSilent: function () {\n\t        //     return !(\n\t        //         this.hoverable || this.draggable\n\t        //         || this.onmousemove || this.onmouseover || this.onmouseout\n\t        //         || this.onmousedown || this.onmouseup || this.onclick\n\t        //         || this.ondragenter || this.ondragover || this.ondragleave\n\t        //         || this.ondrop\n\t        //     );\n\t        // },\n\t        /**\n\t         * Alias for animate('style')\n\t         * @param {boolean} loop\n\t         */\n\t        animateStyle: function (loop) {\n\t            return this.animate('style', loop);\n\t        },\n\t\n\t        attrKV: function (key, value) {\n\t            if (key !== 'style') {\n\t                Element.prototype.attrKV.call(this, key, value);\n\t            }\n\t            else {\n\t                this.style.set(value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setStyle: function (key, value) {\n\t            this.style.set(key, value);\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Use given style object\n\t         * @param  {Object} obj\n\t         */\n\t        useStyle: function (obj) {\n\t            this.style = new Style(obj, this);\n\t            this.dirty(false);\n\t            return this;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Displayable, Element);\n\t\n\t    zrUtil.mixin(Displayable, RectText);\n\t    // zrUtil.mixin(Displayable, Stateful);\n\t\n\t    module.exports = Displayable;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * @module zrender/graphic/Style\n\t */\n\t\n\t\n\t    var STYLE_COMMON_PROPS = [\n\t        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n\t        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n\t    ];\n\t\n\t    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t\n\t    var Style = function (opts, host) {\n\t        this.extendFrom(opts, false);\n\t        this.host = host;\n\t    };\n\t\n\t    function createLinearGradient(ctx, obj, rect) {\n\t        var x = obj.x == null ? 0 : obj.x;\n\t        var x2 = obj.x2 == null ? 1 : obj.x2;\n\t        var y = obj.y == null ? 0 : obj.y;\n\t        var y2 = obj.y2 == null ? 0 : obj.y2;\n\t\n\t        if (!obj.global) {\n\t            x = x * rect.width + rect.x;\n\t            x2 = x2 * rect.width + rect.x;\n\t            y = y * rect.height + rect.y;\n\t            y2 = y2 * rect.height + rect.y;\n\t        }\n\t\n\t        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t    function createRadialGradient(ctx, obj, rect) {\n\t        var width = rect.width;\n\t        var height = rect.height;\n\t        var min = Math.min(width, height);\n\t\n\t        var x = obj.x == null ? 0.5 : obj.x;\n\t        var y = obj.y == null ? 0.5 : obj.y;\n\t        var r = obj.r == null ? 0.5 : obj.r;\n\t        if (!obj.global) {\n\t            x = x * width + rect.x;\n\t            y = y * height + rect.y;\n\t            r = r * min;\n\t        }\n\t\n\t        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t\n\t    Style.prototype = {\n\t\n\t        constructor: Style,\n\t\n\t        /**\n\t         * @type {module:zrender/graphic/Displayable}\n\t         */\n\t        host: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        fill: '#000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        stroke: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        opacity: 1,\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         */\n\t        lineDash: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineDashOffset: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowBlur: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetX: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetY: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineWidth: 1,\n\t\n\t        /**\n\t         * If stroke ignore scale\n\t         * @type {Boolean}\n\t         */\n\t        strokeNoScale: false,\n\t\n\t        // Bounding rect text configuration\n\t        // Not affected by element transform\n\t        /**\n\t         * @type {string}\n\t         */\n\t        text: null,\n\t\n\t        /**\n\t         * If `fontSize` or `fontFamily` exists, `font` will be reset by\n\t         * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n\t         * So do not visit it directly in upper application (like echarts),\n\t         * but use `contain/text#makeFont` instead.\n\t         * @type {string}\n\t         */\n\t        font: null,\n\t\n\t        /**\n\t         * The same as font. Use font please.\n\t         * @deprecated\n\t         * @type {string}\n\t         */\n\t        textFont: null,\n\t\n\t        /**\n\t         * It helps merging respectively, rather than parsing an entire font string.\n\t         * @type {string}\n\t         */\n\t        fontStyle: null,\n\t\n\t        /**\n\t         * It helps merging respectively, rather than parsing an entire font string.\n\t         * @type {string}\n\t         */\n\t        fontWeight: null,\n\t\n\t        /**\n\t         * It helps merging respectively, rather than parsing an entire font string.\n\t         * Should be 12 but not '12px'.\n\t         * @type {number}\n\t         */\n\t        fontSize: null,\n\t\n\t        /**\n\t         * It helps merging respectively, rather than parsing an entire font string.\n\t         * @type {string}\n\t         */\n\t        fontFamily: null,\n\t\n\t        /**\n\t         * Reserved for special functinality, like 'hr'.\n\t         * @type {string}\n\t         */\n\t        textTag: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textFill: '#000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textStroke: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        textWidth: null,\n\t\n\t        /**\n\t         * Only for textBackground.\n\t         * @type {number}\n\t         */\n\t        textHeight: null,\n\t\n\t        /**\n\t         * textStroke may be set as some color as a default\n\t         * value in upper applicaion, where the default value\n\t         * of textStrokeWidth should be 0 to make sure that\n\t         * user can choose to do not use text stroke.\n\t         * @type {number}\n\t         */\n\t        textStrokeWidth: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        textLineHeight: null,\n\t\n\t        /**\n\t         * 'inside', 'left', 'right', 'top', 'bottom'\n\t         * [x, y]\n\t         * Based on x, y of rect.\n\t         * @type {string|Array.<number>}\n\t         * @default 'inside'\n\t         */\n\t        textPosition: 'inside',\n\t\n\t        /**\n\t         * If not specified, use the boundingRect of a `displayable`.\n\t         * @type {Object}\n\t         */\n\t        textRect: null,\n\t\n\t        /**\n\t         * [x, y]\n\t         * @type {Array.<number>}\n\t         */\n\t        textOffset: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textAlign: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textVerticalAlign: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        textDistance: 5,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textShadowColor: 'transparent',\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        textShadowBlur: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetX: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetY: 0,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textBoxShadowColor: 'transparent',\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        textBoxShadowBlur: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        textBoxShadowOffsetX: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        textBoxShadowOffsetY: 0,\n\t\n\t        /**\n\t         * Whether transform text.\n\t         * Only useful in Path and Image element\n\t         * @type {boolean}\n\t         */\n\t        transformText: false,\n\t\n\t        /**\n\t         * Text rotate around position of Path or Image\n\t         * Only useful in Path and Image element and transformText is false.\n\t         */\n\t        textRotation: 0,\n\t\n\t        /**\n\t         * Text origin of text rotation, like [10, 40].\n\t         * Based on x, y of rect.\n\t         * Useful in label rotation of circular symbol.\n\t         * By default, this origin is textPosition.\n\t         * Can be 'center'.\n\t         * @type {string|Array.<number>}\n\t         */\n\t        textOrigin: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textBackgroundColor: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textBorderColor: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        textBorderWidth: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        textBorderRadius: 0,\n\t\n\t        /**\n\t         * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n\t         * @type {number|Array.<number>}\n\t         */\n\t        textPadding: null,\n\t\n\t        /**\n\t         * Text styles for rich text.\n\t         * @type {Object}\n\t         */\n\t        rich: null,\n\t\n\t        /**\n\t         * {outerWidth, outerHeight, ellipsis, placeholder}\n\t         * @type {Object}\n\t         */\n\t        truncate: null,\n\t\n\t        /**\n\t         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t         * @type {string}\n\t         */\n\t        blend: null,\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         */\n\t        bind: function (ctx, el, prevEl) {\n\t            var style = this;\n\t            var prevStyle = prevEl && prevEl.style;\n\t            var firstDraw = !prevStyle;\n\t\n\t            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t                var prop = STYLE_COMMON_PROPS[i];\n\t                var styleName = prop[0];\n\t\n\t                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t                    // FIXME Invalid property value will cause style leak from previous element.\n\t                    ctx[styleName] = style[styleName] || prop[1];\n\t                }\n\t            }\n\t\n\t            if ((firstDraw || style.fill !== prevStyle.fill)) {\n\t                ctx.fillStyle = style.fill;\n\t            }\n\t            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n\t                ctx.strokeStyle = style.stroke;\n\t            }\n\t            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n\t                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t            }\n\t\n\t            if ((firstDraw || style.blend !== prevStyle.blend)) {\n\t                ctx.globalCompositeOperation = style.blend || 'source-over';\n\t            }\n\t            if (this.hasStroke()) {\n\t                var lineWidth = style.lineWidth;\n\t                ctx.lineWidth = lineWidth / (\n\t                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n\t                );\n\t            }\n\t        },\n\t\n\t        hasFill: function () {\n\t            var fill = this.fill;\n\t            return fill != null && fill !== 'none';\n\t        },\n\t\n\t        hasStroke: function () {\n\t            var stroke = this.stroke;\n\t            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t        },\n\t\n\t        /**\n\t         * Extend from other style\n\t         * @param {zrender/graphic/Style} otherStyle\n\t         * @param {boolean} overwrite true: overwrirte any way.\n\t         *                            false: overwrite only when !target.hasOwnProperty\n\t         *                            others: overwrite when property is not null/undefined.\n\t         */\n\t        extendFrom: function (otherStyle, overwrite) {\n\t            if (otherStyle) {\n\t                for (var name in otherStyle) {\n\t                    if (otherStyle.hasOwnProperty(name)\n\t                        && (overwrite === true\n\t                            || (\n\t                                overwrite === false\n\t                                    ? !this.hasOwnProperty(name)\n\t                                    : otherStyle[name] != null\n\t                            )\n\t                        )\n\t                    ) {\n\t                        this[name] = otherStyle[name];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Batch setting style with a given object\n\t         * @param {Object|string} obj\n\t         * @param {*} [obj]\n\t         */\n\t        set: function (obj, value) {\n\t            if (typeof obj === 'string') {\n\t                this[obj] = value;\n\t            }\n\t            else {\n\t                this.extendFrom(obj, true);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clone\n\t         * @return {zrender/graphic/Style} [description]\n\t         */\n\t        clone: function () {\n\t            var newStyle = new this.constructor();\n\t            newStyle.extendFrom(this, true);\n\t            return newStyle;\n\t        },\n\t\n\t        getGradient: function (ctx, obj, rect) {\n\t            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t            var canvasGradient = method(ctx, obj, rect);\n\t            var colorStops = obj.colorStops;\n\t            for (var i = 0; i < colorStops.length; i++) {\n\t                canvasGradient.addColorStop(\n\t                    colorStops[i].offset, colorStops[i].color\n\t                );\n\t            }\n\t            return canvasGradient;\n\t        }\n\t\n\t    };\n\t\n\t    var styleProto = Style.prototype;\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t        var prop = STYLE_COMMON_PROPS[i];\n\t        if (!(prop[0] in styleProto)) {\n\t            styleProto[prop[0]] = prop[1];\n\t        }\n\t    }\n\t\n\t    // Provide for others\n\t    Style.getGradient = styleProto.getGradient;\n\t\n\t    module.exports = Style;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/Element\n\t */\n\t\n\t\n\t    var guid = __webpack_require__(11);\n\t    var Eventful = __webpack_require__(12);\n\t    var Transformable = __webpack_require__(13);\n\t    var Animatable = __webpack_require__(16);\n\t    var zrUtil = __webpack_require__(5);\n\t\n\t    /**\n\t     * @alias module:zrender/Element\n\t     * @constructor\n\t     * @extends {module:zrender/mixin/Animatable}\n\t     * @extends {module:zrender/mixin/Transformable}\n\t     * @extends {module:zrender/mixin/Eventful}\n\t     */\n\t    var Element = function (opts) {\n\t\n\t        Transformable.call(this, opts);\n\t        Eventful.call(this, opts);\n\t        Animatable.call(this, opts);\n\t\n\t        /**\n\t         * 画布元素ID\n\t         * @type {string}\n\t         */\n\t        this.id = opts.id || guid();\n\t    };\n\t\n\t    Element.prototype = {\n\t\n\t        /**\n\t         * 元素类型\n\t         * Element type\n\t         * @type {string}\n\t         */\n\t        type: 'element',\n\t\n\t        /**\n\t         * 元素名字\n\t         * Element name\n\t         * @type {string}\n\t         */\n\t        name: '',\n\t\n\t        /**\n\t         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n\t         * ZRender instance will be assigned when element is associated with zrender\n\t         * @name module:/zrender/Element#__zr\n\t         * @type {module:zrender/ZRender}\n\t         */\n\t        __zr: null,\n\t\n\t        /**\n\t         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n\t         * If ignore drawing and events of the element object\n\t         * @name module:/zrender/Element#ignore\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        ignore: false,\n\t\n\t        /**\n\t         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n\t         * 该路径会继承被裁减对象的变换\n\t         * @type {module:zrender/graphic/Path}\n\t         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n\t         * @readOnly\n\t         */\n\t        clipPath: null,\n\t\n\t        /**\n\t         * Drift element\n\t         * @param  {number} dx dx on the global space\n\t         * @param  {number} dy dy on the global space\n\t         */\n\t        drift: function (dx, dy) {\n\t            switch (this.draggable) {\n\t                case 'horizontal':\n\t                    dy = 0;\n\t                    break;\n\t                case 'vertical':\n\t                    dx = 0;\n\t                    break;\n\t            }\n\t\n\t            var m = this.transform;\n\t            if (!m) {\n\t                m = this.transform = [1, 0, 0, 1, 0, 0];\n\t            }\n\t            m[4] += dx;\n\t            m[5] += dy;\n\t\n\t            this.decomposeTransform();\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         * Hook before update\n\t         */\n\t        beforeUpdate: function () {},\n\t        /**\n\t         * Hook after update\n\t         */\n\t        afterUpdate: function () {},\n\t        /**\n\t         * Update each frame\n\t         */\n\t        update: function () {\n\t            this.updateTransform();\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {},\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        attrKV: function (key, value) {\n\t            if (key === 'position' || key === 'scale' || key === 'origin') {\n\t                // Copy the array\n\t                if (value) {\n\t                    var target = this[key];\n\t                    if (!target) {\n\t                        target = this[key] = [];\n\t                    }\n\t                    target[0] = value[0];\n\t                    target[1] = value[1];\n\t                }\n\t            }\n\t            else {\n\t                this[key] = value;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Hide the element\n\t         */\n\t        hide: function () {\n\t            this.ignore = true;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * Show the element\n\t         */\n\t        show: function () {\n\t            this.ignore = false;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * @param {string|Object} key\n\t         * @param {*} value\n\t         */\n\t        attr: function (key, value) {\n\t            if (typeof key === 'string') {\n\t                this.attrKV(key, value);\n\t            }\n\t            else if (zrUtil.isObject(key)) {\n\t                for (var name in key) {\n\t                    if (key.hasOwnProperty(name)) {\n\t                        this.attrKV(name, key[name]);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.dirty(false);\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/graphic/Path} clipPath\n\t         */\n\t        setClipPath: function (clipPath) {\n\t            var zr = this.__zr;\n\t            if (zr) {\n\t                clipPath.addSelfToZr(zr);\n\t            }\n\t\n\t            // Remove previous clip path\n\t            if (this.clipPath && this.clipPath !== clipPath) {\n\t                this.removeClipPath();\n\t            }\n\t\n\t            this.clipPath = clipPath;\n\t            clipPath.__zr = zr;\n\t            clipPath.__clipTarget = this;\n\t\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         */\n\t        removeClipPath: function () {\n\t            var clipPath = this.clipPath;\n\t            if (clipPath) {\n\t                if (clipPath.__zr) {\n\t                    clipPath.removeSelfFromZr(clipPath.__zr);\n\t                }\n\t\n\t                clipPath.__zr = null;\n\t                clipPath.__clipTarget = null;\n\t                this.clipPath = null;\n\t\n\t                this.dirty(false);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        addSelfToZr: function (zr) {\n\t            this.__zr = zr;\n\t            // 添加动画\n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.addAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.addSelfToZr(zr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Remove self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        removeSelfFromZr: function (zr) {\n\t            this.__zr = null;\n\t            // 移除动画\n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.removeAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.removeSelfFromZr(zr);\n\t            }\n\t        }\n\t    };\n\t\n\t    zrUtil.mixin(Element, Animatable);\n\t    zrUtil.mixin(Element, Transformable);\n\t    zrUtil.mixin(Element, Eventful);\n\t\n\t    module.exports = Element;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * zrender: 生成唯一id\n\t *\n\t * @author errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var idStart = 0x0907;\n\t\n\t    module.exports = function () {\n\t        return idStart++;\n\t    };\n\t\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * 事件扩展\n\t * @module zrender/mixin/Eventful\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var arrySlice = Array.prototype.slice;\n\t\n\t    /**\n\t     * 事件分发器\n\t     * @alias module:zrender/mixin/Eventful\n\t     * @constructor\n\t     */\n\t    var Eventful = function () {\n\t        this._$handlers = {};\n\t    };\n\t\n\t    Eventful.prototype = {\n\t\n\t        constructor: Eventful,\n\t\n\t        /**\n\t         * 单次触发绑定，trigger后销毁\n\t         *\n\t         * @param {string} event 事件名\n\t         * @param {Function} handler 响应函数\n\t         * @param {Object} context\n\t         */\n\t        one: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: true,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 绑定事件\n\t         * @param {string} event 事件名\n\t         * @param {Function} handler 事件处理函数\n\t         * @param {Object} [context]\n\t         */\n\t        on: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: false,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 是否绑定了事件\n\t         * @param  {string}  event\n\t         * @return {boolean}\n\t         */\n\t        isSilent: function (event) {\n\t            var _h = this._$handlers;\n\t            return _h[event] && _h[event].length;\n\t        },\n\t\n\t        /**\n\t         * 解绑事件\n\t         * @param {string} event 事件名\n\t         * @param {Function} [handler] 事件处理函数\n\t         */\n\t        off: function (event, handler) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!event) {\n\t                this._$handlers = {};\n\t                return this;\n\t            }\n\t\n\t            if (handler) {\n\t                if (_h[event]) {\n\t                    var newList = [];\n\t                    for (var i = 0, l = _h[event].length; i < l; i++) {\n\t                        if (_h[event][i]['h'] != handler) {\n\t                            newList.push(_h[event][i]);\n\t                        }\n\t                    }\n\t                    _h[event] = newList;\n\t                }\n\t\n\t                if (_h[event] && _h[event].length === 0) {\n\t                    delete _h[event];\n\t                }\n\t            }\n\t            else {\n\t                delete _h[event];\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 事件分发\n\t         *\n\t         * @param {string} type 事件类型\n\t         */\n\t        trigger: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 3) {\n\t                    args = arrySlice.call(args, 1);\n\t                }\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(_h[i]['ctx']);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(_h[i]['ctx'], args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 带有context的事件分发, 最后一个参数是事件回调的context\n\t         * @param {string} type 事件类型\n\t         */\n\t        triggerWithContext: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 4) {\n\t                    args = arrySlice.call(args, 1, args.length - 1);\n\t                }\n\t                var ctx = args[args.length - 1];\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(ctx);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(ctx, args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(ctx, args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(ctx, args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    // 对象可以通过 onxxxx 绑定事件\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onclick\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseout\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousemove\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousewheel\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousedown\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseup\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrag\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragstart\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragend\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragenter\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragleave\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrop\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t\n\t    module.exports = Eventful;\n\t\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 提供变换扩展\n\t * @module zrender/mixin/Transformable\n\t * @author pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var matrix = __webpack_require__(14);\n\t    var vector = __webpack_require__(15);\n\t    var mIdentity = matrix.identity;\n\t\n\t    var EPSILON = 5e-5;\n\t\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/mixin/Transformable\n\t     * @constructor\n\t     */\n\t    var Transformable = function (opts) {\n\t        opts = opts || {};\n\t        // If there are no given position, rotation, scale\n\t        if (!opts.position) {\n\t            /**\n\t             * 平移\n\t             * @type {Array.<number>}\n\t             * @default [0, 0]\n\t             */\n\t            this.position = [0, 0];\n\t        }\n\t        if (opts.rotation == null) {\n\t            /**\n\t             * 旋转\n\t             * @type {Array.<number>}\n\t             * @default 0\n\t             */\n\t            this.rotation = 0;\n\t        }\n\t        if (!opts.scale) {\n\t            /**\n\t             * 缩放\n\t             * @type {Array.<number>}\n\t             * @default [1, 1]\n\t             */\n\t            this.scale = [1, 1];\n\t        }\n\t        /**\n\t         * 旋转和缩放的原点\n\t         * @type {Array.<number>}\n\t         * @default null\n\t         */\n\t        this.origin = this.origin || null;\n\t    };\n\t\n\t    var transformableProto = Transformable.prototype;\n\t    transformableProto.transform = null;\n\t\n\t    /**\n\t     * 判断是否需要有坐标变换\n\t     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n\t     */\n\t    transformableProto.needLocalTransform = function () {\n\t        return isNotAroundZero(this.rotation)\n\t            || isNotAroundZero(this.position[0])\n\t            || isNotAroundZero(this.position[1])\n\t            || isNotAroundZero(this.scale[0] - 1)\n\t            || isNotAroundZero(this.scale[1] - 1);\n\t    };\n\t\n\t    transformableProto.updateTransform = function () {\n\t        var parent = this.parent;\n\t        var parentHasTransform = parent && parent.transform;\n\t        var needLocalTransform = this.needLocalTransform();\n\t\n\t        var m = this.transform;\n\t        if (!(needLocalTransform || parentHasTransform)) {\n\t            m && mIdentity(m);\n\t            return;\n\t        }\n\t\n\t        m = m || matrix.create();\n\t\n\t        if (needLocalTransform) {\n\t            this.getLocalTransform(m);\n\t        }\n\t        else {\n\t            mIdentity(m);\n\t        }\n\t\n\t        // 应用父节点变换\n\t        if (parentHasTransform) {\n\t            if (needLocalTransform) {\n\t                matrix.mul(m, parent.transform, m);\n\t            }\n\t            else {\n\t                matrix.copy(m, parent.transform);\n\t            }\n\t        }\n\t        // 保存这个变换矩阵\n\t        this.transform = m;\n\t\n\t        this.invTransform = this.invTransform || matrix.create();\n\t        matrix.invert(this.invTransform, m);\n\t    };\n\t\n\t    transformableProto.getLocalTransform = function (m) {\n\t        return Transformable.getLocalTransform(this, m);\n\t    };\n\t\n\t    /**\n\t     * 将自己的transform应用到context上\n\t     * @param {CanvasRenderingContext2D} ctx\n\t     */\n\t    transformableProto.setTransform = function (ctx) {        \n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        if (m) {\n\t            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t        }\n\t        else {\n\t            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t        }\n\t    };\n\t\n\t    transformableProto.restoreTransform = function (ctx) {\n\t        var dpr = ctx.dpr || 1;\n\t        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t    };\n\t\n\t    var tmpTransform = [];\n\t\n\t    /**\n\t     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n\t     */\n\t    transformableProto.decomposeTransform = function () {\n\t        if (!this.transform) {\n\t            return;\n\t        }\n\t        var parent = this.parent;\n\t        var m = this.transform;\n\t        if (parent && parent.transform) {\n\t            // Get local transform and decompose them to position, scale, rotation\n\t            matrix.mul(tmpTransform, parent.invTransform, m);\n\t            m = tmpTransform;\n\t        }\n\t        var sx = m[0] * m[0] + m[1] * m[1];\n\t        var sy = m[2] * m[2] + m[3] * m[3];\n\t        var position = this.position;\n\t        var scale = this.scale;\n\t        if (isNotAroundZero(sx - 1)) {\n\t            sx = Math.sqrt(sx);\n\t        }\n\t        if (isNotAroundZero(sy - 1)) {\n\t            sy = Math.sqrt(sy);\n\t        }\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        position[0] = m[4];\n\t        position[1] = m[5];\n\t        scale[0] = sx;\n\t        scale[1] = sy;\n\t        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t    };\n\t\n\t    /**\n\t     * Get global scale\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.getGlobalScale = function () {\n\t        var m = this.transform;\n\t        if (!m) {\n\t            return [1, 1];\n\t        }\n\t        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        return [sx, sy];\n\t    };\n\t    /**\n\t     * 变换坐标位置到 shape 的局部坐标空间\n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToLocal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var invTransform = this.invTransform;\n\t        if (invTransform) {\n\t            vector.applyTransform(v2, v2, invTransform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    /**\n\t     * 变换局部坐标位置到全局坐标空间\n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToGlobal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var transform = this.transform;\n\t        if (transform) {\n\t            vector.applyTransform(v2, v2, transform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    /**\n\t     * @static\n\t     * @param {Object} target\n\t     * @param {Array.<number>} target.origin\n\t     * @param {number} target.rotation\n\t     * @param {Array.<number>} target.position\n\t     * @param {Array.<number>} [m]\n\t     */\n\t    Transformable.getLocalTransform = function (target, m) {\n\t        m = m || [];\n\t        mIdentity(m);\n\t\n\t        var origin = target.origin;\n\t        var scale = target.scale || [1, 1];\n\t        var rotation = target.rotation || 0;\n\t        var position = target.position || [0, 0];\n\t\n\t        if (origin) {\n\t            // Translate to origin\n\t            m[4] -= origin[0];\n\t            m[5] -= origin[1];\n\t        }\n\t        matrix.scale(m, m, scale);\n\t        if (rotation) {\n\t            matrix.rotate(m, m, rotation);\n\t        }\n\t        if (origin) {\n\t            // Translate back from origin\n\t            m[4] += origin[0];\n\t            m[5] += origin[1];\n\t        }\n\t\n\t        m[4] += position[0];\n\t        m[5] += position[1];\n\t\n\t        return m;\n\t    };\n\t\n\t    module.exports = Transformable;\n\t\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t    /**\n\t     * 3x2矩阵操作类\n\t     * @exports zrender/tool/matrix\n\t     */\n\t    var matrix = {\n\t        /**\n\t         * 创建一个单位矩阵\n\t         * @return {Float32Array|Array.<number>}\n\t         */\n\t        create : function() {\n\t            var out = new ArrayCtor(6);\n\t            matrix.identity(out);\n\t\n\t            return out;\n\t        },\n\t        /**\n\t         * 设置矩阵为单位矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         */\n\t        identity : function(out) {\n\t            out[0] = 1;\n\t            out[1] = 0;\n\t            out[2] = 0;\n\t            out[3] = 1;\n\t            out[4] = 0;\n\t            out[5] = 0;\n\t            return out;\n\t        },\n\t        /**\n\t         * 复制矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m\n\t         */\n\t        copy: function(out, m) {\n\t            out[0] = m[0];\n\t            out[1] = m[1];\n\t            out[2] = m[2];\n\t            out[3] = m[3];\n\t            out[4] = m[4];\n\t            out[5] = m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * 矩阵相乘\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m1\n\t         * @param {Float32Array|Array.<number>} m2\n\t         */\n\t        mul : function (out, m1, m2) {\n\t            // Consider matrix.mul(m, m2, m);\n\t            // where out is the same as m2.\n\t            // So use temp variable to escape error.\n\t            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t            out[0] = out0;\n\t            out[1] = out1;\n\t            out[2] = out2;\n\t            out[3] = out3;\n\t            out[4] = out4;\n\t            out[5] = out5;\n\t            return out;\n\t        },\n\t        /**\n\t         * 平移变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        translate : function(out, a, v) {\n\t            out[0] = a[0];\n\t            out[1] = a[1];\n\t            out[2] = a[2];\n\t            out[3] = a[3];\n\t            out[4] = a[4] + v[0];\n\t            out[5] = a[5] + v[1];\n\t            return out;\n\t        },\n\t        /**\n\t         * 旋转变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {number} rad\n\t         */\n\t        rotate : function(out, a, rad) {\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t            var st = Math.sin(rad);\n\t            var ct = Math.cos(rad);\n\t\n\t            out[0] = aa * ct + ab * st;\n\t            out[1] = -aa * st + ab * ct;\n\t            out[2] = ac * ct + ad * st;\n\t            out[3] = -ac * st + ct * ad;\n\t            out[4] = ct * atx + st * aty;\n\t            out[5] = ct * aty - st * atx;\n\t            return out;\n\t        },\n\t        /**\n\t         * 缩放变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        scale : function(out, a, v) {\n\t            var vx = v[0];\n\t            var vy = v[1];\n\t            out[0] = a[0] * vx;\n\t            out[1] = a[1] * vy;\n\t            out[2] = a[2] * vx;\n\t            out[3] = a[3] * vy;\n\t            out[4] = a[4] * vx;\n\t            out[5] = a[5] * vy;\n\t            return out;\n\t        },\n\t        /**\n\t         * 求逆矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         */\n\t        invert : function(out, a) {\n\t\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t\n\t            var det = aa * ad - ab * ac;\n\t            if (!det) {\n\t                return null;\n\t            }\n\t            det = 1.0 / det;\n\t\n\t            out[0] = ad * det;\n\t            out[1] = -ab * det;\n\t            out[2] = -ac * det;\n\t            out[3] = aa * det;\n\t            out[4] = (ac * aty - ad * atx) * det;\n\t            out[5] = (ab * atx - aa * aty) * det;\n\t            return out;\n\t        }\n\t    };\n\t\n\t    module.exports = matrix;\n\t\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t\n\t    /**\n\t     * @typedef {Float32Array|Array.<number>} Vector2\n\t     */\n\t    /**\n\t     * 二维向量类\n\t     * @exports zrender/tool/vector\n\t     */\n\t    var vector = {\n\t        /**\n\t         * 创建一个向量\n\t         * @param {number} [x=0]\n\t         * @param {number} [y=0]\n\t         * @return {Vector2}\n\t         */\n\t        create: function (x, y) {\n\t            var out = new ArrayCtor(2);\n\t            if (x == null) {\n\t                x = 0;\n\t            }\n\t            if (y == null) {\n\t                y = 0;\n\t            }\n\t            out[0] = x;\n\t            out[1] = y;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 复制向量数据\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        copy: function (out, v) {\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 克隆一个向量\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        clone: function (v) {\n\t            var out = new ArrayCtor(2);\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 设置向量的两个项\n\t         * @param {Vector2} out\n\t         * @param {number} a\n\t         * @param {number} b\n\t         * @return {Vector2} 结果\n\t         */\n\t        set: function (out, a, b) {\n\t            out[0] = a;\n\t            out[1] = b;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量相加\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        add: function (out, v1, v2) {\n\t            out[0] = v1[0] + v2[0];\n\t            out[1] = v1[1] + v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量缩放后相加\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} a\n\t         */\n\t        scaleAndAdd: function (out, v1, v2, a) {\n\t            out[0] = v1[0] + v2[0] * a;\n\t            out[1] = v1[1] + v2[1] * a;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量相减\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        sub: function (out, v1, v2) {\n\t            out[0] = v1[0] - v2[0];\n\t            out[1] = v1[1] - v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量长度\n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        len: function (v) {\n\t            return Math.sqrt(this.lenSquare(v));\n\t        },\n\t\n\t        /**\n\t         * 向量长度平方\n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        lenSquare: function (v) {\n\t            return v[0] * v[0] + v[1] * v[1];\n\t        },\n\t\n\t        /**\n\t         * 向量乘法\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        mul: function (out, v1, v2) {\n\t            out[0] = v1[0] * v2[0];\n\t            out[1] = v1[1] * v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量除法\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        div: function (out, v1, v2) {\n\t            out[0] = v1[0] / v2[0];\n\t            out[1] = v1[1] / v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量点乘\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        dot: function (v1, v2) {\n\t            return v1[0] * v2[0] + v1[1] * v2[1];\n\t        },\n\t\n\t        /**\n\t         * 向量缩放\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {number} s\n\t         */\n\t        scale: function (out, v, s) {\n\t            out[0] = v[0] * s;\n\t            out[1] = v[1] * s;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量归一化\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        normalize: function (out, v) {\n\t            var d = vector.len(v);\n\t            if (d === 0) {\n\t                out[0] = 0;\n\t                out[1] = 0;\n\t            }\n\t            else {\n\t                out[0] = v[0] / d;\n\t                out[1] = v[1] / d;\n\t            }\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 计算向量间距离\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distance: function (v1, v2) {\n\t            return Math.sqrt(\n\t                (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n\t            );\n\t        },\n\t\n\t        /**\n\t         * 向量距离平方\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distanceSquare: function (v1, v2) {\n\t            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t        },\n\t\n\t        /**\n\t         * 求负向量\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        negate: function (out, v) {\n\t            out[0] = -v[0];\n\t            out[1] = -v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 插值两个点\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} t\n\t         */\n\t        lerp: function (out, v1, v2, t) {\n\t            out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t            out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 矩阵左乘向量\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {Vector2} m\n\t         */\n\t        applyTransform: function (out, v, m) {\n\t            var x = v[0];\n\t            var y = v[1];\n\t            out[0] = m[0] * x + m[2] * y + m[4];\n\t            out[1] = m[1] * x + m[3] * y + m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * 求两个向量最小值\n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        min: function (out, v1, v2) {\n\t            out[0] = Math.min(v1[0], v2[0]);\n\t            out[1] = Math.min(v1[1], v2[1]);\n\t            return out;\n\t        },\n\t        /**\n\t         * 求两个向量最大值\n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        max: function (out, v1, v2) {\n\t            out[0] = Math.max(v1[0], v2[0]);\n\t            out[1] = Math.max(v1[1], v2[1]);\n\t            return out;\n\t        }\n\t    };\n\t\n\t    vector.length = vector.len;\n\t    vector.lengthSquare = vector.lenSquare;\n\t    vector.dist = vector.distance;\n\t    vector.distSquare = vector.distanceSquare;\n\t\n\t    module.exports = vector;\n\t\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/mixin/Animatable\n\t */\n\t\n\t\n\t    var Animator = __webpack_require__(17);\n\t    var util = __webpack_require__(5);\n\t    var isString = util.isString;\n\t    var isFunction = util.isFunction;\n\t    var isObject = util.isObject;\n\t    var log = __webpack_require__(22);\n\t\n\t    /**\n\t     * @alias modue:zrender/mixin/Animatable\n\t     * @constructor\n\t     */\n\t    var Animatable = function () {\n\t\n\t        /**\n\t         * @type {Array.<module:zrender/animation/Animator>}\n\t         * @readOnly\n\t         */\n\t        this.animators = [];\n\t    };\n\t\n\t    Animatable.prototype = {\n\t\n\t        constructor: Animatable,\n\t\n\t        /**\n\t         * 动画\n\t         *\n\t         * @param {string} path The path to fetch value from object, like 'a.b.c'.\n\t         * @param {boolean} [loop] Whether to loop animation.\n\t         * @return {module:zrender/animation/Animator}\n\t         * @example:\n\t         *     el.animate('style', false)\n\t         *         .when(1000, {x: 10} )\n\t         *         .done(function(){ // Animation done })\n\t         *         .start()\n\t         */\n\t        animate: function (path, loop) {\n\t            var target;\n\t            var animatingShape = false;\n\t            var el = this;\n\t            var zr = this.__zr;\n\t            if (path) {\n\t                var pathSplitted = path.split('.');\n\t                var prop = el;\n\t                // If animating shape\n\t                animatingShape = pathSplitted[0] === 'shape';\n\t                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t                    if (!prop) {\n\t                        continue;\n\t                    }\n\t                    prop = prop[pathSplitted[i]];\n\t                }\n\t                if (prop) {\n\t                    target = prop;\n\t                }\n\t            }\n\t            else {\n\t                target = el;\n\t            }\n\t\n\t            if (!target) {\n\t                log(\n\t                    'Property \"'\n\t                    + path\n\t                    + '\" is not existed in element '\n\t                    + el.id\n\t                );\n\t                return;\n\t            }\n\t\n\t            var animators = el.animators;\n\t\n\t            var animator = new Animator(target, loop);\n\t\n\t            animator.during(function (target) {\n\t                el.dirty(animatingShape);\n\t            })\n\t            .done(function () {\n\t                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t                animators.splice(util.indexOf(animators, animator), 1);\n\t            });\n\t\n\t            animators.push(animator);\n\t\n\t            // If animate after added to the zrender\n\t            if (zr) {\n\t                zr.animation.addAnimator(animator);\n\t            }\n\t\n\t            return animator;\n\t        },\n\t\n\t        /**\n\t         * 停止动画\n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stopAnimation: function (forwardToLast) {\n\t            var animators = this.animators;\n\t            var len = animators.length;\n\t            for (var i = 0; i < len; i++) {\n\t                animators[i].stop(forwardToLast);\n\t            }\n\t            animators.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Caution: this method will stop previous animation.\n\t         * So do not use this method to one element twice before\n\t         * animation starts, unless you know what you are doing.\n\t         * @param {Object} target\n\t         * @param {number} [time=500] Time in ms\n\t         * @param {string} [easing='linear']\n\t         * @param {number} [delay=0]\n\t         * @param {Function} [callback]\n\t         * @param {Function} [forceAnimate] Prevent stop animation and callback\n\t         *        immediently when target values are the same as current values.\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el.animateTo({\n\t         *      position: [10, 10]\n\t         *  }, function () { // done })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n\t         *  el.animateTo({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100, 'cubicOut', function () { // done })\n\t         */\n\t         // TODO Return animation key\n\t        animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n\t            // animateTo(target, time, easing, callback);\n\t            if (isString(delay)) {\n\t                callback = easing;\n\t                easing = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, delay, callback);\n\t            else if (isFunction(easing)) {\n\t                callback = easing;\n\t                easing = 'linear';\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, callback);\n\t            else if (isFunction(delay)) {\n\t                callback = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, callback)\n\t            else if (isFunction(time)) {\n\t                callback = time;\n\t                time = 500;\n\t            }\n\t            // animateTo(target)\n\t            else if (!time) {\n\t                time = 500;\n\t            }\n\t            // Stop all previous animations\n\t            this.stopAnimation();\n\t            this._animateToShallow('', this, target, time, delay, easing, callback);\n\t\n\t            // Animators may be removed immediately after start\n\t            // if there is nothing to animate\n\t            var animators = this.animators.slice();\n\t            var count = animators.length;\n\t            function done() {\n\t                count--;\n\t                if (!count) {\n\t                    callback && callback();\n\t                }\n\t            }\n\t\n\t            // No animators. This should be checked before animators[i].start(),\n\t            // because 'done' may be executed immediately if no need to animate.\n\t            if (!count) {\n\t                callback && callback();\n\t            }\n\t            // Start after all animators created\n\t            // Incase any animator is done immediately when all animation properties are not changed\n\t            for (var i = 0; i < animators.length; i++) {\n\t                animators[i]\n\t                    .done(done)\n\t                    .start(easing, forceAnimate);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {string} path=''\n\t         * @param {Object} source=this\n\t         * @param {Object} target\n\t         * @param {number} [time=500]\n\t         * @param {number} [delay=0]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el._animateToShallow({\n\t         *      position: [10, 10]\n\t         *  })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms\n\t         *  el._animateToShallow({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100)\n\t         */\n\t        _animateToShallow: function (path, source, target, time, delay) {\n\t            var objShallow = {};\n\t            var propertyCount = 0;\n\t            for (var name in target) {\n\t                if (!target.hasOwnProperty(name)) {\n\t                    continue;\n\t                }\n\t\n\t                if (source[name] != null) {\n\t                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n\t                        this._animateToShallow(\n\t                            path ? path + '.' + name : name,\n\t                            source[name],\n\t                            target[name],\n\t                            time,\n\t                            delay\n\t                        );\n\t                    }\n\t                    else {\n\t                        objShallow[name] = target[name];\n\t                        propertyCount++;\n\t                    }\n\t                }\n\t                else if (target[name] != null) {\n\t                    // Attr directly if not has property\n\t                    // FIXME, if some property not needed for element ?\n\t                    if (!path) {\n\t                        this.attr(name, target[name]);\n\t                    }\n\t                    else {  // Shape or style\n\t                        var props = {};\n\t                        props[path] = {};\n\t                        props[path][name] = target[name];\n\t                        this.attr(props);\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (propertyCount > 0) {\n\t                this.animate(path, false)\n\t                    .when(time == null ? 500 : time, objShallow)\n\t                    .delay(delay || 0);\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    module.exports = Animatable;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/animation/Animator\n\t */\n\t\n\t\n\t    var Clip = __webpack_require__(18);\n\t    var color = __webpack_require__(20);\n\t    var util = __webpack_require__(5);\n\t    var isArrayLike = util.isArrayLike;\n\t\n\t    var arraySlice = Array.prototype.slice;\n\t\n\t    function defaultGetter(target, key) {\n\t        return target[key];\n\t    }\n\t\n\t    function defaultSetter(target, key, value) {\n\t        target[key] = value;\n\t    }\n\t\n\t    /**\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} percent\n\t     * @return {number}\n\t     */\n\t    function interpolateNumber(p0, p1, percent) {\n\t        return (p1 - p0) * percent + p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {string} p0\n\t     * @param  {string} p1\n\t     * @param  {number} percent\n\t     * @return {string}\n\t     */\n\t    function interpolateString(p0, p1, percent) {\n\t        return percent > 0.5 ? p1 : p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {number} percent\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function interpolateArray(p0, p1, percent, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t            }\n\t        }\n\t        else {\n\t            var len2 = len && p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = interpolateNumber(\n\t                        p0[i][j], p1[i][j], percent\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    // arr0 is source array, arr1 is target array.\n\t    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t    function fillArr(arr0, arr1, arrDim) {\n\t        var arr0Len = arr0.length;\n\t        var arr1Len = arr1.length;\n\t        if (arr0Len !== arr1Len) {\n\t            // FIXME Not work for TypedArray\n\t            var isPreviousLarger = arr0Len > arr1Len;\n\t            if (isPreviousLarger) {\n\t                // Cut the previous\n\t                arr0.length = arr1Len;\n\t            }\n\t            else {\n\t                // Fill the previous\n\t                for (var i = arr0Len; i < arr1Len; i++) {\n\t                    arr0.push(\n\t                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n\t                    );\n\t                }\n\t            }\n\t        }\n\t        // Handling NaN value\n\t        var len2 = arr0[0] && arr0[0].length;\n\t        for (var i = 0; i < arr0.length; i++) {\n\t            if (arrDim === 1) {\n\t                if (isNaN(arr0[i])) {\n\t                    arr0[i] = arr1[i];\n\t                }\n\t            }\n\t            else {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (isNaN(arr0[i][j])) {\n\t                        arr0[i][j] = arr1[i][j];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} arr0\n\t     * @param  {Array} arr1\n\t     * @param  {number} arrDim\n\t     * @return {boolean}\n\t     */\n\t    function isArraySame(arr0, arr1, arrDim) {\n\t        if (arr0 === arr1) {\n\t            return true;\n\t        }\n\t        var len = arr0.length;\n\t        if (len !== arr1.length) {\n\t            return false;\n\t        }\n\t        if (arrDim === 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                if (arr0[i] !== arr1[i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var len2 = arr0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (arr0[i][j] !== arr1[i][j]) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate array\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {Array} p2\n\t     * @param  {Array} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function catmullRomInterpolateArray(\n\t        p0, p1, p2, p3, t, t2, t3, out, arrDim\n\t    ) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = catmullRomInterpolate(\n\t                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n\t                );\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = catmullRomInterpolate(\n\t                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n\t                        t, t2, t3\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate number\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @return {number}\n\t     */\n\t    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    function cloneValue(value) {\n\t        if (isArrayLike(value)) {\n\t            var len = value.length;\n\t            if (isArrayLike(value[0])) {\n\t                var ret = [];\n\t                for (var i = 0; i < len; i++) {\n\t                    ret.push(arraySlice.call(value[i]));\n\t                }\n\t                return ret;\n\t            }\n\t\n\t            return arraySlice.call(value);\n\t        }\n\t\n\t        return value;\n\t    }\n\t\n\t    function rgba2String(rgba) {\n\t        rgba[0] = Math.floor(rgba[0]);\n\t        rgba[1] = Math.floor(rgba[1]);\n\t        rgba[2] = Math.floor(rgba[2]);\n\t\n\t        return 'rgba(' + rgba.join(',') + ')';\n\t    }\n\t\n\t    function getArrayDim(keyframes) {\n\t        var lastValue = keyframes[keyframes.length - 1].value;\n\t        return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n\t    }\n\t\n\t    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n\t        var getter = animator._getter;\n\t        var setter = animator._setter;\n\t        var useSpline = easing === 'spline';\n\t\n\t        var trackLen = keyframes.length;\n\t        if (!trackLen) {\n\t            return;\n\t        }\n\t        // Guess data type\n\t        var firstVal = keyframes[0].value;\n\t        var isValueArray = isArrayLike(firstVal);\n\t        var isValueColor = false;\n\t        var isValueString = false;\n\t\n\t        // For vertices morphing\n\t        var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n\t\n\t        var trackMaxTime;\n\t        // Sort keyframe as ascending\n\t        keyframes.sort(function(a, b) {\n\t            return a.time - b.time;\n\t        });\n\t\n\t        trackMaxTime = keyframes[trackLen - 1].time;\n\t        // Percents of each keyframe\n\t        var kfPercents = [];\n\t        // Value of each keyframe\n\t        var kfValues = [];\n\t        var prevValue = keyframes[0].value;\n\t        var isAllValueEqual = true;\n\t        for (var i = 0; i < trackLen; i++) {\n\t            kfPercents.push(keyframes[i].time / trackMaxTime);\n\t            // Assume value is a color when it is a string\n\t            var value = keyframes[i].value;\n\t\n\t            // Check if value is equal, deep check if value is array\n\t            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n\t                || (!isValueArray && value === prevValue))) {\n\t                isAllValueEqual = false;\n\t            }\n\t            prevValue = value;\n\t\n\t            // Try converting a string to a color array\n\t            if (typeof value == 'string') {\n\t                var colorArray = color.parse(value);\n\t                if (colorArray) {\n\t                    value = colorArray;\n\t                    isValueColor = true;\n\t                }\n\t                else {\n\t                    isValueString = true;\n\t                }\n\t            }\n\t            kfValues.push(value);\n\t        }\n\t        if (!forceAnimate && isAllValueEqual) {\n\t            return;\n\t        }\n\t\n\t        var lastValue = kfValues[trackLen - 1];\n\t        // Polyfill array and NaN value\n\t        for (var i = 0; i < trackLen - 1; i++) {\n\t            if (isValueArray) {\n\t                fillArr(kfValues[i], lastValue, arrDim);\n\t            }\n\t            else {\n\t                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t                    kfValues[i] = lastValue;\n\t                }\n\t            }\n\t        }\n\t        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\t\n\t        // Cache the key of last frame to speed up when\n\t        // animation playback is sequency\n\t        var lastFrame = 0;\n\t        var lastFramePercent = 0;\n\t        var start;\n\t        var w;\n\t        var p0;\n\t        var p1;\n\t        var p2;\n\t        var p3;\n\t\n\t        if (isValueColor) {\n\t            var rgba = [0, 0, 0, 0];\n\t        }\n\t\n\t        var onframe = function (target, percent) {\n\t            // Find the range keyframes\n\t            // kf1-----kf2---------current--------kf3\n\t            // find kf2 and kf3 and do interpolation\n\t            var frame;\n\t            // In the easing function like elasticOut, percent may less than 0\n\t            if (percent < 0) {\n\t                frame = 0;\n\t            }\n\t            else if (percent < lastFramePercent) {\n\t                // Start from next key\n\t                // PENDING start from lastFrame ?\n\t                start = Math.min(lastFrame + 1, trackLen - 1);\n\t                for (frame = start; frame >= 0; frame--) {\n\t                    if (kfPercents[frame] <= percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                // PENDING really need to do this ?\n\t                frame = Math.min(frame, trackLen - 2);\n\t            }\n\t            else {\n\t                for (frame = lastFrame; frame < trackLen; frame++) {\n\t                    if (kfPercents[frame] > percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                frame = Math.min(frame - 1, trackLen - 2);\n\t            }\n\t            lastFrame = frame;\n\t            lastFramePercent = percent;\n\t\n\t            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n\t            if (range === 0) {\n\t                return;\n\t            }\n\t            else {\n\t                w = (percent - kfPercents[frame]) / range;\n\t            }\n\t            if (useSpline) {\n\t                p1 = kfValues[frame];\n\t                p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t                if (isValueArray) {\n\t                    catmullRomInterpolateArray(\n\t                        p0, p1, p2, p3, w, w * w, w * w * w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        value = catmullRomInterpolateArray(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(p1, p2, w);\n\t                    }\n\t                    else {\n\t                        value = catmullRomInterpolate(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w\n\t                        );\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t            else {\n\t                if (isValueArray) {\n\t                    interpolateArray(\n\t                        kfValues[frame], kfValues[frame + 1], w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        interpolateArray(\n\t                            kfValues[frame], kfValues[frame + 1], w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    else {\n\t                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t        };\n\t\n\t        var clip = new Clip({\n\t            target: animator._target,\n\t            life: trackMaxTime,\n\t            loop: animator._loop,\n\t            delay: animator._delay,\n\t            onframe: onframe,\n\t            ondestroy: oneTrackDone\n\t        });\n\t\n\t        if (easing && easing !== 'spline') {\n\t            clip.easing = easing;\n\t        }\n\t\n\t        return clip;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animator\n\t     * @constructor\n\t     * @param {Object} target\n\t     * @param {boolean} loop\n\t     * @param {Function} getter\n\t     * @param {Function} setter\n\t     */\n\t    var Animator = function(target, loop, getter, setter) {\n\t        this._tracks = {};\n\t        this._target = target;\n\t\n\t        this._loop = loop || false;\n\t\n\t        this._getter = getter || defaultGetter;\n\t        this._setter = setter || defaultSetter;\n\t\n\t        this._clipCount = 0;\n\t\n\t        this._delay = 0;\n\t\n\t        this._doneList = [];\n\t\n\t        this._onframeList = [];\n\t\n\t        this._clipList = [];\n\t    };\n\t\n\t    Animator.prototype = {\n\t        /**\n\t         * 设置动画关键帧\n\t         * @param  {number} time 关键帧时间，单位是ms\n\t         * @param  {Object} props 关键帧的属性值，key-value表示\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        when: function(time /* ms */, props) {\n\t            var tracks = this._tracks;\n\t            for (var propName in props) {\n\t                if (!props.hasOwnProperty(propName)) {\n\t                    continue;\n\t                }\n\t\n\t                if (!tracks[propName]) {\n\t                    tracks[propName] = [];\n\t                    // Invalid value\n\t                    var value = this._getter(this._target, propName);\n\t                    if (value == null) {\n\t                        // zrLog('Invalid property ' + propName);\n\t                        continue;\n\t                    }\n\t                    // If time is 0\n\t                    //  Then props is given initialize value\n\t                    // Else\n\t                    //  Initialize value from current prop value\n\t                    if (time !== 0) {\n\t                        tracks[propName].push({\n\t                            time: 0,\n\t                            value: cloneValue(value)\n\t                        });\n\t                    }\n\t                }\n\t                tracks[propName].push({\n\t                    time: time,\n\t                    value: props[propName]\n\t                });\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * 添加动画每一帧的回调函数\n\t         * @param  {Function} callback\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        during: function (callback) {\n\t            this._onframeList.push(callback);\n\t            return this;\n\t        },\n\t\n\t        pause: function () {\n\t            for (var i = 0; i < this._clipList.length; i++) {\n\t                this._clipList[i].pause();\n\t            }\n\t            this._paused = true;\n\t        },\n\t\n\t        resume: function () {\n\t            for (var i = 0; i < this._clipList.length; i++) {\n\t                this._clipList[i].resume();\n\t            }\n\t            this._paused = false;\n\t        },\n\t\n\t        isPaused: function () {\n\t            return !!this._paused;\n\t        },\n\t\n\t        _doneCallback: function () {\n\t            // Clear all tracks\n\t            this._tracks = {};\n\t            // Clear all clips\n\t            this._clipList.length = 0;\n\t\n\t            var doneList = this._doneList;\n\t            var len = doneList.length;\n\t            for (var i = 0; i < len; i++) {\n\t                doneList[i].call(this);\n\t            }\n\t        },\n\t        /**\n\t         * 开始执行动画\n\t         * @param  {string|Function} [easing]\n\t         *         动画缓动函数，详见{@link module:zrender/animation/easing}\n\t         * @param  {boolean} forceAnimate\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        start: function (easing, forceAnimate) {\n\t\n\t            var self = this;\n\t            var clipCount = 0;\n\t\n\t            var oneTrackDone = function() {\n\t                clipCount--;\n\t                if (!clipCount) {\n\t                    self._doneCallback();\n\t                }\n\t            };\n\t\n\t            var lastClip;\n\t            for (var propName in this._tracks) {\n\t                if (!this._tracks.hasOwnProperty(propName)) {\n\t                    continue;\n\t                }\n\t                var clip = createTrackClip(\n\t                    this, easing, oneTrackDone,\n\t                    this._tracks[propName], propName, forceAnimate\n\t                );\n\t                if (clip) {\n\t                    this._clipList.push(clip);\n\t                    clipCount++;\n\t\n\t                    // If start after added to animation\n\t                    if (this.animation) {\n\t                        this.animation.addClip(clip);\n\t                    }\n\t\n\t                    lastClip = clip;\n\t                }\n\t            }\n\t\n\t            // Add during callback on the last clip\n\t            if (lastClip) {\n\t                var oldOnFrame = lastClip.onframe;\n\t                lastClip.onframe = function (target, percent) {\n\t                    oldOnFrame(target, percent);\n\t\n\t                    for (var i = 0; i < self._onframeList.length; i++) {\n\t                        self._onframeList[i](target, percent);\n\t                    }\n\t                };\n\t            }\n\t\n\t            // This optimization will help the case that in the upper application\n\t            // the view may be refreshed frequently, where animation will be\n\t            // called repeatly but nothing changed.\n\t            if (!clipCount) {\n\t                this._doneCallback();\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * 停止动画\n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stop: function (forwardToLast) {\n\t            var clipList = this._clipList;\n\t            var animation = this.animation;\n\t            for (var i = 0; i < clipList.length; i++) {\n\t                var clip = clipList[i];\n\t                if (forwardToLast) {\n\t                    // Move to last frame before stop\n\t                    clip.onframe(this._target, 1);\n\t                }\n\t                animation && animation.removeClip(clip);\n\t            }\n\t            clipList.length = 0;\n\t        },\n\t        /**\n\t         * 设置动画延迟开始的时间\n\t         * @param  {number} time 单位ms\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        delay: function (time) {\n\t            this._delay = time;\n\t            return this;\n\t        },\n\t        /**\n\t         * 添加动画结束的回调\n\t         * @param  {Function} cb\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        done: function(cb) {\n\t            if (cb) {\n\t                this._doneList.push(cb);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/animation/Clip>}\n\t         */\n\t        getClips: function () {\n\t            return this._clipList;\n\t        }\n\t    };\n\t\n\t    module.exports = Animator;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 动画主控制器\n\t * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n\t * @config life(1000) 动画时长\n\t * @config delay(0) 动画延迟时间\n\t * @config loop(true)\n\t * @config gap(0) 循环的间隔时间\n\t * @config onframe\n\t * @config easing(optional)\n\t * @config ondestroy(optional)\n\t * @config onrestart(optional)\n\t *\n\t * TODO pause\n\t */\n\t\n\t\n\t    var easingFuncs = __webpack_require__(19);\n\t\n\t    function Clip(options) {\n\t\n\t        this._target = options.target;\n\t\n\t        // 生命周期\n\t        this._life = options.life || 1000;\n\t        // 延时\n\t        this._delay = options.delay || 0;\n\t        // 开始时间\n\t        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n\t        this._initialized = false;\n\t\n\t        // 是否循环\n\t        this.loop = options.loop == null ? false : options.loop;\n\t\n\t        this.gap = options.gap || 0;\n\t\n\t        this.easing = options.easing || 'Linear';\n\t\n\t        this.onframe = options.onframe;\n\t        this.ondestroy = options.ondestroy;\n\t        this.onrestart = options.onrestart;\n\t\n\t        this._pausedTime = 0;\n\t        this._paused = false;\n\t    }\n\t\n\t    Clip.prototype = {\n\t\n\t        constructor: Clip,\n\t\n\t        step: function (globalTime, deltaTime) {\n\t            // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t            // PENDING\n\t            if (!this._initialized) {\n\t                this._startTime = globalTime + this._delay;\n\t                this._initialized = true;\n\t            }\n\t\n\t            if (this._paused) {\n\t                this._pausedTime += deltaTime;\n\t                return;\n\t            }\n\t\n\t            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n\t\n\t            // 还没开始\n\t            if (percent < 0) {\n\t                return;\n\t            }\n\t\n\t            percent = Math.min(percent, 1);\n\t\n\t            var easing = this.easing;\n\t            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t            var schedule = typeof easingFunc === 'function'\n\t                ? easingFunc(percent)\n\t                : percent;\n\t\n\t            this.fire('frame', schedule);\n\t\n\t            // 结束\n\t            if (percent == 1) {\n\t                if (this.loop) {\n\t                    this.restart (globalTime);\n\t                    // 重新开始周期\n\t                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\t                    return 'restart';\n\t                }\n\t\n\t                // 动画完成将这个控制器标识为待删除\n\t                // 在Animation.update中进行批量删除\n\t                this._needsRemove = true;\n\t                return 'destroy';\n\t            }\n\t\n\t            return null;\n\t        },\n\t\n\t        restart: function (globalTime) {\n\t            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n\t            this._startTime = globalTime - remainder + this.gap;\n\t            this._pausedTime = 0;\n\t\n\t            this._needsRemove = false;\n\t        },\n\t\n\t        fire: function (eventType, arg) {\n\t            eventType = 'on' + eventType;\n\t            if (this[eventType]) {\n\t                this[eventType](this._target, arg);\n\t            }\n\t        },\n\t\n\t        pause: function () {\n\t            this._paused = true;\n\t        },\n\t\n\t        resume: function () {\n\t            this._paused = false;\n\t        }\n\t    };\n\t\n\t    module.exports = Clip;\n\t\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n\t * @see http://sole.github.io/tween.js/examples/03_graphs.html\n\t * @exports zrender/animation/easing\n\t */\n\t\n\t    var easing = {\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        linear: function (k) {\n\t            return k;\n\t        },\n\t\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticIn: function (k) {\n\t            return k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticOut: function (k) {\n\t            return k * (2 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k;\n\t            }\n\t            return -0.5 * (--k * (k - 2) - 1);\n\t        },\n\t\n\t        // 三次方的缓动（t^3）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicIn: function (k) {\n\t            return k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicOut: function (k) {\n\t            return --k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k + 2);\n\t        },\n\t\n\t        // 四次方的缓动（t^4）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticIn: function (k) {\n\t            return k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticOut: function (k) {\n\t            return 1 - (--k * k * k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k;\n\t            }\n\t            return -0.5 * ((k -= 2) * k * k * k - 2);\n\t        },\n\t\n\t        // 五次方的缓动（t^5）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticIn: function (k) {\n\t            return k * k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticOut: function (k) {\n\t            return --k * k * k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t        },\n\t\n\t        // 正弦曲线的缓动（sin(t)）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalIn: function (k) {\n\t            return 1 - Math.cos(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalOut: function (k) {\n\t            return Math.sin(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalInOut: function (k) {\n\t            return 0.5 * (1 - Math.cos(Math.PI * k));\n\t        },\n\t\n\t        // 指数曲线的缓动（2^t）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialIn: function (k) {\n\t            return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialOut: function (k) {\n\t            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialInOut: function (k) {\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * Math.pow(1024, k - 1);\n\t            }\n\t            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t        },\n\t\n\t        // 圆形曲线的缓动（sqrt(1-t^2)）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularIn: function (k) {\n\t            return 1 - Math.sqrt(1 - k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularOut: function (k) {\n\t            return Math.sqrt(1 - (--k * k));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t            }\n\t            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t        },\n\t\n\t        // 创建类似于弹簧在停止前来回振荡的动画\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticIn: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return -(a * Math.pow(2, 10 * (k -= 1)) *\n\t                        Math.sin((k - s) * (2 * Math.PI) / p));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return (a * Math.pow(2, -10 * k) *\n\t                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticInOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p));\n\t            }\n\t            return a * Math.pow(2, -10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\n\t        },\n\t\n\t        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backIn: function (k) {\n\t            var s = 1.70158;\n\t            return k * k * ((s + 1) * k - s);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backOut: function (k) {\n\t            var s = 1.70158;\n\t            return --k * k * ((s + 1) * k + s) + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backInOut: function (k) {\n\t            var s = 1.70158 * 1.525;\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * (k * k * ((s + 1) * k - s));\n\t            }\n\t            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t        },\n\t\n\t        // 创建弹跳效果\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceIn: function (k) {\n\t            return 1 - easing.bounceOut(1 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceOut: function (k) {\n\t            if (k < (1 / 2.75)) {\n\t                return 7.5625 * k * k;\n\t            }\n\t            else if (k < (2 / 2.75)) {\n\t                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t            }\n\t            else if (k < (2.5 / 2.75)) {\n\t                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t            }\n\t            else {\n\t                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t            }\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceInOut: function (k) {\n\t            if (k < 0.5) {\n\t                return easing.bounceIn(k * 2) * 0.5;\n\t            }\n\t            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t        }\n\t    };\n\t\n\t    module.exports = easing;\n\t\n\t\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/tool/color\n\t */\n\t\n\t\n\t    var LRU = __webpack_require__(21);\n\t\n\t    var kCSSColorTable = {\n\t        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n\t        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n\t        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n\t        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n\t        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n\t        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n\t        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n\t        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n\t        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n\t        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n\t        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n\t        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n\t        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n\t        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n\t        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n\t        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n\t        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n\t        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n\t        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n\t        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n\t        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n\t        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n\t        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n\t        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n\t        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n\t        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n\t        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n\t        'gray': [128,128,128,1], 'green': [0,128,0,1],\n\t        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n\t        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n\t        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n\t        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n\t        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n\t        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n\t        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n\t        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n\t        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n\t        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n\t        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n\t        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n\t        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n\t        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n\t        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n\t        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n\t        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n\t        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n\t        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n\t        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n\t        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n\t        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n\t        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n\t        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n\t        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n\t        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n\t        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n\t        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n\t        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n\t        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n\t        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n\t        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n\t        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n\t        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n\t        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n\t        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n\t        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n\t        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n\t        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n\t        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n\t        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n\t        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n\t        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n\t        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n\t        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n\t        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n\t    };\n\t\n\t    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 255 ? 255 : i;\n\t    }\n\t\n\t    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 360 ? 360 : i;\n\t    }\n\t\n\t    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n\t        return f < 0 ? 0 : f > 1 ? 1 : f;\n\t    }\n\t\n\t    function parseCssInt(str) {  // int or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssByte(parseFloat(str) / 100 * 255);\n\t        }\n\t        return clampCssByte(parseInt(str, 10));\n\t    }\n\t\n\t    function parseCssFloat(str) {  // float or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssFloat(parseFloat(str) / 100);\n\t        }\n\t        return clampCssFloat(parseFloat(str));\n\t    }\n\t\n\t    function cssHueToRgb(m1, m2, h) {\n\t        if (h < 0) {\n\t            h += 1;\n\t        }\n\t        else if (h > 1) {\n\t            h -= 1;\n\t        }\n\t\n\t        if (h * 6 < 1) {\n\t            return m1 + (m2 - m1) * h * 6;\n\t        }\n\t        if (h * 2 < 1) {\n\t            return m2;\n\t        }\n\t        if (h * 3 < 2) {\n\t            return m1 + (m2 - m1) * (2/3 - h) * 6;\n\t        }\n\t        return m1;\n\t    }\n\t\n\t    function lerpNumber(a, b, p) {\n\t        return a + (b - a) * p;\n\t    }\n\t\n\t    function setRgba(out, r, g, b, a) {\n\t        out[0] = r; out[1] = g; out[2] = b; out[3] = a;\n\t        return out;\n\t    }\n\t    function copyRgba(out, a) {\n\t        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n\t        return out;\n\t    }\n\t    var colorCache = new LRU(20);\n\t    var lastRemovedArr = null;\n\t    function putToCache(colorStr, rgbaArr) {\n\t        // Reuse removed array\n\t        if (lastRemovedArr) {\n\t            copyRgba(lastRemovedArr, rgbaArr);\n\t        }\n\t        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n\t    }\n\t    /**\n\t     * @param {string} colorStr\n\t     * @param {Array.<number>} out\n\t     * @return {Array.<number>}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function parse(colorStr, rgbaArr) {\n\t        if (!colorStr) {\n\t            return;\n\t        }\n\t        rgbaArr = rgbaArr || [];\n\t\n\t        var cached = colorCache.get(colorStr);\n\t        if (cached) {\n\t            return copyRgba(rgbaArr, cached);\n\t        }\n\t\n\t        // colorStr may be not string\n\t        colorStr = colorStr + '';\n\t        // Remove all whitespace, not compliant, but should just be more accepting.\n\t        var str = colorStr.replace(/ /g, '').toLowerCase();\n\t\n\t        // Color keywords (and transparent) lookup.\n\t        if (str in kCSSColorTable) {\n\t            copyRgba(rgbaArr, kCSSColorTable[str]);\n\t            putToCache(colorStr, rgbaArr);\n\t            return rgbaArr;\n\t        }\n\t\n\t        // #abc and #abc123 syntax.\n\t        if (str.charAt(0) === '#') {\n\t            if (str.length === 4) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xfff)) {\n\t                    setRgba(rgbaArr, 0, 0, 0, 1);\n\t                    return;  // Covers NaN.\n\t                }\n\t                setRgba(rgbaArr,\n\t                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n\t                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n\t                    (iv & 0xf) | ((iv & 0xf) << 4),\n\t                    1\n\t                );\n\t                putToCache(colorStr, rgbaArr);\n\t                return rgbaArr;\n\t            }\n\t            else if (str.length === 7) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xffffff)) {\n\t                    setRgba(rgbaArr, 0, 0, 0, 1);\n\t                    return;  // Covers NaN.\n\t                }\n\t                setRgba(rgbaArr,\n\t                    (iv & 0xff0000) >> 16,\n\t                    (iv & 0xff00) >> 8,\n\t                    iv & 0xff,\n\t                    1\n\t                );\n\t                putToCache(colorStr, rgbaArr);\n\t                return rgbaArr;\n\t            }\n\t\n\t            return;\n\t        }\n\t        var op = str.indexOf('('), ep = str.indexOf(')');\n\t        if (op !== -1 && ep + 1 === str.length) {\n\t            var fname = str.substr(0, op);\n\t            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t            var alpha = 1;  // To allow case fallthrough.\n\t            switch (fname) {\n\t                case 'rgba':\n\t                    if (params.length !== 4) {\n\t                        setRgba(rgbaArr, 0, 0, 0, 1);\n\t                        return;\n\t                    }\n\t                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n\t                // Fall through.\n\t                case 'rgb':\n\t                    if (params.length !== 3) {\n\t                        setRgba(rgbaArr, 0, 0, 0, 1);\n\t                        return;\n\t                    }\n\t                    setRgba(rgbaArr,\n\t                        parseCssInt(params[0]),\n\t                        parseCssInt(params[1]),\n\t                        parseCssInt(params[2]),\n\t                        alpha\n\t                    );\n\t                    putToCache(colorStr, rgbaArr);\n\t                    return rgbaArr;\n\t                case 'hsla':\n\t                    if (params.length !== 4) {\n\t                        setRgba(rgbaArr, 0, 0, 0, 1);\n\t                        return;\n\t                    }\n\t                    params[3] = parseCssFloat(params[3]);\n\t                    hsla2rgba(params, rgbaArr);\n\t                    putToCache(colorStr, rgbaArr);\n\t                    return rgbaArr;\n\t                case 'hsl':\n\t                    if (params.length !== 3) {\n\t                        setRgba(rgbaArr, 0, 0, 0, 1);\n\t                        return;\n\t                    }\n\t                    hsla2rgba(params, rgbaArr);\n\t                    putToCache(colorStr, rgbaArr);\n\t                    return rgbaArr;\n\t                default:\n\t                    return;\n\t            }\n\t        }\n\t\n\t        setRgba(rgbaArr, 0, 0, 0, 1);\n\t        return;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} hsla\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} rgba\n\t     */\n\t    function hsla2rgba(hsla, rgba) {\n\t        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n\t        // NOTE(deanm): According to the CSS spec s/l should only be\n\t        // percentages, but we don't bother and let float or percentage.\n\t        var s = parseCssFloat(hsla[1]);\n\t        var l = parseCssFloat(hsla[2]);\n\t        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t        var m1 = l * 2 - m2;\n\t\n\t        rgba = rgba || [];\n\t        setRgba(rgba,\n\t            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),\n\t            1\n\t        );\n\t\n\t        if (hsla.length === 4) {\n\t            rgba[3] = hsla[3];\n\t        }\n\t\n\t        return rgba;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} hsla\n\t     */\n\t    function rgba2hsla(rgba) {\n\t        if (!rgba) {\n\t            return;\n\t        }\n\t\n\t        // RGB from 0 to 255\n\t        var R = rgba[0] / 255;\n\t        var G = rgba[1] / 255;\n\t        var B = rgba[2] / 255;\n\t\n\t        var vMin = Math.min(R, G, B); // Min. value of RGB\n\t        var vMax = Math.max(R, G, B); // Max. value of RGB\n\t        var delta = vMax - vMin; // Delta RGB value\n\t\n\t        var L = (vMax + vMin) / 2;\n\t        var H;\n\t        var S;\n\t        // HSL results from 0 to 1\n\t        if (delta === 0) {\n\t            H = 0;\n\t            S = 0;\n\t        }\n\t        else {\n\t            if (L < 0.5) {\n\t                S = delta / (vMax + vMin);\n\t            }\n\t            else {\n\t                S = delta / (2 - vMax - vMin);\n\t            }\n\t\n\t            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n\t            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n\t            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\t\n\t            if (R === vMax) {\n\t                H = deltaB - deltaG;\n\t            }\n\t            else if (G === vMax) {\n\t                H = (1 / 3) + deltaR - deltaB;\n\t            }\n\t            else if (B === vMax) {\n\t                H = (2 / 3) + deltaG - deltaR;\n\t            }\n\t\n\t            if (H < 0) {\n\t                H += 1;\n\t            }\n\t\n\t            if (H > 1) {\n\t                H -= 1;\n\t            }\n\t        }\n\t\n\t        var hsla = [H * 360, S, L];\n\t\n\t        if (rgba[3] != null) {\n\t            hsla.push(rgba[3]);\n\t        }\n\t\n\t        return hsla;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number} level\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function lift(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            for (var i = 0; i < 3; i++) {\n\t                if (level < 0) {\n\t                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t                }\n\t                else {\n\t                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n\t                }\n\t            }\n\t            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function toHex(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Map value to color. Faster than lerp methods because color is represented by rgba array.\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<Array.<number>>} colors List of rgba color array\n\t     * @param {Array.<number>} [out] Mapped gba color array\n\t     * @return {Array.<number>} will be null/undefined if input illegal.\n\t     */\n\t    function fastLerp(normalizedValue, colors, out) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t\n\t        out = out || [];\n\t\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = colors[leftIndex];\n\t        var rightColor = colors[rightIndex];\n\t        var dv = value - leftIndex;\n\t        out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n\t        out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n\t        out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n\t        out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n\t\n\t        return out;\n\t    }\n\t\n\t    /**\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {boolean=} fullOutput Default false.\n\t     * @return {(string|Object)} Result color. If fullOutput,\n\t     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function lerp(normalizedValue, colors, fullOutput) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = parse(colors[leftIndex]);\n\t        var rightColor = parse(colors[rightIndex]);\n\t        var dv = value - leftIndex;\n\t\n\t        var color = stringify(\n\t            [\n\t                clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),\n\t                clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),\n\t                clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),\n\t                clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))\n\t            ],\n\t            'rgba'\n\t        );\n\t\n\t        return fullOutput\n\t            ? {\n\t                color: color,\n\t                leftIndex: leftIndex,\n\t                rightIndex: rightIndex,\n\t                value: value\n\t            }\n\t            : color;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} h 0 ~ 360, ignore when null.\n\t     * @param {number=} s 0 ~ 1, ignore when null.\n\t     * @param {number=} l 0 ~ 1, ignore when null.\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyHSL(color, h, s, l) {\n\t        color = parse(color);\n\t\n\t        if (color) {\n\t            color = rgba2hsla(color);\n\t            h != null && (color[0] = clampCssAngle(h));\n\t            s != null && (color[1] = parseCssFloat(s));\n\t            l != null && (color[2] = parseCssFloat(l));\n\t\n\t            return stringify(hsla2rgba(color), 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} alpha 0 ~ 1\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyAlpha(color, alpha) {\n\t        color = parse(color);\n\t\n\t        if (color && alpha != null) {\n\t            color[3] = clampCssFloat(alpha);\n\t            return stringify(color, 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} arrColor like [12,33,44,0.4]\n\t     * @param {string} type 'rgba', 'hsva', ...\n\t     * @return {string} Result color. (If input illegal, return undefined).\n\t     */\n\t    function stringify(arrColor, type) {\n\t        if (!arrColor || !arrColor.length) {\n\t            return;\n\t        }\n\t        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t            colorStr += ',' + arrColor[3];\n\t        }\n\t        return type + '(' + colorStr + ')';\n\t    }\n\t\n\t    module.exports = {\n\t        parse: parse,\n\t        lift: lift,\n\t        toHex: toHex,\n\t        fastLerp: fastLerp,\n\t        fastMapToColor: fastLerp, // Deprecated\n\t        lerp: lerp,\n\t        mapToColor: lerp, // Deprecated\n\t        modifyHSL: modifyHSL,\n\t        modifyAlpha: modifyAlpha,\n\t        stringify: stringify\n\t    };\n\t\n\t\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\n\t// Simple LRU cache use doubly linked list\n\t// @module zrender/core/LRU\n\t\n\t\n\t    /**\n\t     * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t     * @constructor\n\t     */\n\t    var LinkedList = function () {\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.head = null;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.tail = null;\n\t\n\t        this._len = 0;\n\t    };\n\t\n\t    var linkedListProto = LinkedList.prototype;\n\t    /**\n\t     * Insert a new value at the tail\n\t     * @param  {} val\n\t     * @return {module:zrender/core/LRU~Entry}\n\t     */\n\t    linkedListProto.insert = function (val) {\n\t        var entry = new Entry(val);\n\t        this.insertEntry(entry);\n\t        return entry;\n\t    };\n\t\n\t    /**\n\t     * Insert an entry at the tail\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.insertEntry = function (entry) {\n\t        if (!this.head) {\n\t            this.head = this.tail = entry;\n\t        }\n\t        else {\n\t            this.tail.next = entry;\n\t            entry.prev = this.tail;\n\t            entry.next = null;\n\t            this.tail = entry;\n\t        }\n\t        this._len++;\n\t    };\n\t\n\t    /**\n\t     * Remove entry.\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.remove = function (entry) {\n\t        var prev = entry.prev;\n\t        var next = entry.next;\n\t        if (prev) {\n\t            prev.next = next;\n\t        }\n\t        else {\n\t            // Is head\n\t            this.head = next;\n\t        }\n\t        if (next) {\n\t            next.prev = prev;\n\t        }\n\t        else {\n\t            // Is tail\n\t            this.tail = prev;\n\t        }\n\t        entry.next = entry.prev = null;\n\t        this._len--;\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    linkedListProto.len = function () {\n\t        return this._len;\n\t    };\n\t\n\t    /**\n\t     * Clear list\n\t     */\n\t    linkedListProto.clear = function () {\n\t        this.head = this.tail = null;\n\t        this._len = 0;\n\t    };\n\t\n\t    /**\n\t     * @constructor\n\t     * @param {} val\n\t     */\n\t    var Entry = function (val) {\n\t        /**\n\t         * @type {}\n\t         */\n\t        this.value = val;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.next;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.prev;\n\t    };\n\t\n\t    /**\n\t     * LRU Cache\n\t     * @constructor\n\t     * @alias module:zrender/core/LRU\n\t     */\n\t    var LRU = function (maxSize) {\n\t\n\t        this._list = new LinkedList();\n\t\n\t        this._map = {};\n\t\n\t        this._maxSize = maxSize || 10;\n\t\n\t        this._lastRemovedEntry = null;\n\t    };\n\t\n\t    var LRUProto = LRU.prototype;\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @param  {} value\n\t     * @return {} Removed value\n\t     */\n\t    LRUProto.put = function (key, value) {\n\t        var list = this._list;\n\t        var map = this._map;\n\t        var removed = null;\n\t        if (map[key] == null) {\n\t            var len = list.len();\n\t            // Reuse last removed entry\n\t            var entry = this._lastRemovedEntry;\n\t\n\t            if (len >= this._maxSize && len > 0) {\n\t                // Remove the least recently used\n\t                var leastUsedEntry = list.head;\n\t                list.remove(leastUsedEntry);\n\t                delete map[leastUsedEntry.key];\n\t\n\t                removed = leastUsedEntry.value;\n\t                this._lastRemovedEntry = leastUsedEntry;\n\t            }\n\t\n\t            if (entry) {\n\t                entry.value = value;\n\t            }\n\t            else {\n\t                entry = new Entry(value);\n\t            }\n\t            entry.key = key;\n\t            list.insertEntry(entry);\n\t            map[key] = entry;\n\t        }\n\t\n\t        return removed;\n\t    };\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @return {}\n\t     */\n\t    LRUProto.get = function (key) {\n\t        var entry = this._map[key];\n\t        var list = this._list;\n\t        if (entry != null) {\n\t            // Put the latest used entry in the tail\n\t            if (entry !== list.tail) {\n\t                list.remove(entry);\n\t                list.insertEntry(entry);\n\t            }\n\t\n\t            return entry.value;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Clear the cache\n\t     */\n\t    LRUProto.clear = function () {\n\t        this._list.clear();\n\t        this._map = {};\n\t    };\n\t\n\t    module.exports = LRU;\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t        var config = __webpack_require__(23);\n\t\n\t        /**\n\t         * @exports zrender/tool/log\n\t         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t         */\n\t        module.exports = function() {\n\t            if (config.debugMode === 0) {\n\t                return;\n\t            }\n\t            else if (config.debugMode == 1) {\n\t                for (var k in arguments) {\n\t                    throw new Error(arguments[k]);\n\t                }\n\t            }\n\t            else if (config.debugMode > 1) {\n\t                for (var k in arguments) {\n\t                    console.log(arguments[k]);\n\t                }\n\t            }\n\t        };\n\t\n\t        /* for debug\n\t        return function(mes) {\n\t            document.getElementById('wrong-message').innerHTML =\n\t                mes + ' ' + (new Date() - 0)\n\t                + '<br/>'\n\t                + document.getElementById('wrong-message').innerHTML;\n\t        };\n\t        */\n\t    \n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\n\t\n\t    var dpr = 1;\n\t    // If in browser environment\n\t    if (typeof window !== 'undefined') {\n\t        dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t    }\n\t    /**\n\t     * config默认配置项\n\t     * @exports zrender/config\n\t     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t     */\n\t    var config = {\n\t        /**\n\t         * debug日志选项：catchBrushException为true下有效\n\t         * 0 : 不生成debug数据，发布用\n\t         * 1 : 异常抛出，调试用\n\t         * 2 : 控制台输出，调试用\n\t         */\n\t        debugMode: 0,\n\t\n\t        // retina 屏幕优化\n\t        devicePixelRatio: dpr\n\t    };\n\t    module.exports = config;\n\t\n\t\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Mixin for drawing text in a element bounding rect\n\t * @module zrender/mixin/RectText\n\t */\n\t\n\t\n\t\n\t    var textHelper = __webpack_require__(25);\n\t    var BoundingRect = __webpack_require__(27);\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var RectText = function () {};\n\t\n\t    RectText.prototype = {\n\t\n\t        constructor: RectText,\n\t\n\t        /**\n\t         * Draw text in a rect with specified position.\n\t         * @param  {CanvasRenderingContext2D} ctx\n\t         * @param  {Object} rect Displayable rect\n\t         */\n\t        drawRectText: function (ctx, rect) {\n\t            var style = this.style;\n\t\n\t            rect = style.textRect || rect;\n\t\n\t            // Optimize, avoid normalize every time.\n\t            this.__dirty && textHelper.normalizeTextStyle(style, true);\n\t\n\t            var text = style.text;\n\t\n\t            // Convert to string\n\t            text != null && (text += '');\n\t\n\t            if (!textHelper.needDrawText(text, style)) {\n\t                return;\n\t            }\n\t\n\t            // FIXME\n\t            ctx.save();\n\t\n\t            // Transform rect to view space\n\t            var transform = this.transform;\n\t            if (!style.transformText) {\n\t                if (transform) {\n\t                    tmpRect.copy(rect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = tmpRect;\n\t                }\n\t            }\n\t            else {\n\t                this.setTransform(ctx);\n\t            }\n\t\n\t            // transformText and textRotation can not be used at the same time.\n\t            textHelper.renderText(this, ctx, text, style, rect);\n\t\n\t            ctx.restore();\n\t        }\n\t    };\n\t\n\t    module.exports = RectText;\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var textContain = __webpack_require__(26);\n\t    var util = __webpack_require__(5);\n\t    var roundRectHelper = __webpack_require__(29);\n\t    var imageHelper = __webpack_require__(28);\n\t\n\t    var retrieve3 = util.retrieve3;\n\t    var retrieve2 = util.retrieve2;\n\t\n\t    // TODO: Have not support 'start', 'end' yet.\n\t    var VALID_TEXT_ALIGN = {left: 1, right: 1, center: 1};\n\t    var VALID_TEXT_VERTICAL_ALIGN = {top: 1, bottom: 1, middle: 1};\n\t\n\t    var helper = {};\n\t\n\t    /**\n\t     * @param {module:zrender/graphic/Style} style\n\t     * @return {module:zrender/graphic/Style} The input style.\n\t     */\n\t    helper.normalizeTextStyle = function (style) {\n\t        normalizeStyle(style);\n\t        util.each(style.rich, normalizeStyle);\n\t        return style;\n\t    };\n\t\n\t    function normalizeStyle(style) {\n\t        if (style) {\n\t\n\t            style.font = textContain.makeFont(style);\n\t\n\t            var textAlign = style.textAlign;\n\t            textAlign === 'middle' && (textAlign = 'center');\n\t            style.textAlign = (\n\t                textAlign == null || VALID_TEXT_ALIGN[textAlign]\n\t            ) ? textAlign : 'left';\n\t\n\t            // Compatible with textBaseline.\n\t            var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n\t            textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n\t            style.textVerticalAlign = (\n\t                textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign]\n\t            ) ? textVerticalAlign : 'top';\n\t\n\t            var textPadding = style.textPadding;\n\t            if (textPadding) {\n\t                style.textPadding = util.normalizeCssArray(style.textPadding);\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {CanvasRenderingContext2D} ctx\n\t     * @param {string} text\n\t     * @param {module:zrender/graphic/Style} style\n\t     * @param {Object|boolean} [rect] {x, y, width, height}\n\t     *                  If set false, rect text is not used.\n\t     */\n\t    helper.renderText = function (hostEl, ctx, text, style, rect) {\n\t        style.rich\n\t            ? renderRichText(hostEl, ctx, text, style, rect)\n\t            : renderPlainText(hostEl, ctx, text, style, rect);\n\t    };\n\t\n\t    function renderPlainText(hostEl, ctx, text, style, rect) {\n\t        var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n\t\n\t        var textPadding = style.textPadding;\n\t\n\t        var contentBlock = hostEl.__textCotentBlock;\n\t        if (!contentBlock || hostEl.__dirty) {\n\t            contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(\n\t                text, font, textPadding, style.truncate\n\t            );\n\t        }\n\t\n\t        var outerHeight = contentBlock.outerHeight;\n\t\n\t        var textLines = contentBlock.lines;\n\t        var lineHeight = contentBlock.lineHeight;\n\t\n\t        var boxPos = getBoxPosition(outerHeight, style, rect);\n\t        var baseX = boxPos.baseX;\n\t        var baseY = boxPos.baseY;\n\t        var textAlign = boxPos.textAlign;\n\t        var textVerticalAlign = boxPos.textVerticalAlign;\n\t\n\t        // Origin of textRotation should be the base point of text drawing.\n\t        applyTextRotation(ctx, style, rect, baseX, baseY);\n\t\n\t        var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n\t        var textX = baseX;\n\t        var textY = boxY;\n\t\n\t        var needDrawBg = needDrawBackground(style);\n\t        if (needDrawBg || textPadding) {\n\t            // Consider performance, do not call getTextWidth util necessary.\n\t            var textWidth = textContain.getWidth(text, font);\n\t            var outerWidth = textWidth;\n\t            textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n\t            var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n\t\n\t            needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\t\n\t            if (textPadding) {\n\t                textX = getTextXForPadding(baseX, textAlign, textPadding);\n\t                textY += textPadding[0];\n\t            }\n\t        }\n\t\n\t        setCtx(ctx, 'textAlign', textAlign || 'left');\n\t        // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n\t        // text will offset downward a little bit in font \"Microsoft YaHei\".\n\t        setCtx(ctx, 'textBaseline', 'middle');\n\t\n\t        // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\t        setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n\t        setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n\t        setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n\t        setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0);\n\t\n\t        // `textBaseline` is set as 'middle'.\n\t        textY += lineHeight / 2;\n\t\n\t        var textStrokeWidth = style.textStrokeWidth;\n\t        var textStroke = getStroke(style.textStroke, textStrokeWidth);\n\t        var textFill = getFill(style.textFill);\n\t\n\t        if (textStroke) {\n\t            setCtx(ctx, 'lineWidth', textStrokeWidth);\n\t            setCtx(ctx, 'strokeStyle', textStroke);\n\t        }\n\t        if (textFill) {\n\t            setCtx(ctx, 'fillStyle', textFill);\n\t        }\n\t\n\t        for (var i = 0; i < textLines.length; i++) {\n\t            // Fill after stroke so the outline will not cover the main part.\n\t            textStroke && ctx.strokeText(textLines[i], textX, textY);\n\t            textFill && ctx.fillText(textLines[i], textX, textY);\n\t            textY += lineHeight;\n\t        }\n\t    }\n\t\n\t    function renderRichText(hostEl, ctx, text, style, rect) {\n\t        var contentBlock = hostEl.__textCotentBlock;\n\t\n\t        if (!contentBlock || hostEl.__dirty) {\n\t            contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n\t        }\n\t\n\t        drawRichText(hostEl, ctx, contentBlock, style, rect);\n\t    }\n\t\n\t    function drawRichText(hostEl, ctx, contentBlock, style, rect) {\n\t        var contentWidth = contentBlock.width;\n\t        var outerWidth = contentBlock.outerWidth;\n\t        var outerHeight = contentBlock.outerHeight;\n\t        var textPadding = style.textPadding;\n\t\n\t        var boxPos = getBoxPosition(outerHeight, style, rect);\n\t        var baseX = boxPos.baseX;\n\t        var baseY = boxPos.baseY;\n\t        var textAlign = boxPos.textAlign;\n\t        var textVerticalAlign = boxPos.textVerticalAlign;\n\t\n\t        // Origin of textRotation should be the base point of text drawing.\n\t        applyTextRotation(ctx, style, rect, baseX, baseY);\n\t\n\t        var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n\t        var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n\t        var xLeft = boxX;\n\t        var lineTop = boxY;\n\t        if (textPadding) {\n\t            xLeft += textPadding[3];\n\t            lineTop += textPadding[0];\n\t        }\n\t        var xRight = xLeft + contentWidth;\n\t\n\t        needDrawBackground(style) && drawBackground(\n\t            hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight\n\t        );\n\t\n\t        for (var i = 0; i < contentBlock.lines.length; i++) {\n\t            var line = contentBlock.lines[i];\n\t            var tokens = line.tokens;\n\t            var tokenCount = tokens.length;\n\t            var lineHeight = line.lineHeight;\n\t            var usedWidth = line.width;\n\t\n\t            var leftIndex = 0;\n\t            var lineXLeft = xLeft;\n\t            var lineXRight = xRight;\n\t            var rightIndex = tokenCount - 1;\n\t            var token;\n\t\n\t            while (\n\t                leftIndex < tokenCount\n\t                && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')\n\t            ) {\n\t                placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n\t                usedWidth -= token.width;\n\t                lineXLeft += token.width;\n\t                leftIndex++;\n\t            }\n\t\n\t            while (\n\t                rightIndex >= 0\n\t                && (token = tokens[rightIndex], token.textAlign === 'right')\n\t            ) {\n\t                placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n\t                usedWidth -= token.width;\n\t                lineXRight -= token.width;\n\t                rightIndex--;\n\t            }\n\t\n\t            // The other tokens are placed as textAlign 'center' if there is enough space.\n\t            lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\t            while (leftIndex <= rightIndex) {\n\t                token = tokens[leftIndex];\n\t                // Consider width specified by user, use 'center' rather than 'left'.\n\t                placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n\t                lineXLeft += token.width;\n\t                leftIndex++;\n\t            }\n\t\n\t            lineTop += lineHeight;\n\t        }\n\t    }\n\t\n\t    function applyTextRotation(ctx, style, rect, x, y) {\n\t        // textRotation only apply in RectText.\n\t        if (rect && style.textRotation) {\n\t            var origin = style.textOrigin;\n\t            if (origin === 'center') {\n\t                x = rect.width / 2 + rect.x;\n\t                y = rect.height / 2 + rect.y;\n\t            }\n\t            else if (origin) {\n\t                x = origin[0] + rect.x;\n\t                y = origin[1] + rect.y;\n\t            }\n\t\n\t            ctx.translate(x, y);\n\t            // Positive: anticlockwise\n\t            ctx.rotate(-style.textRotation);\n\t            ctx.translate(-x, -y);\n\t        }\n\t    }\n\t\n\t    function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n\t        var tokenStyle = style.rich[token.styleName] || {};\n\t\n\t        // 'ctx.textBaseline' is always set as 'middle', for sake of\n\t        // the bias of \"Microsoft YaHei\".\n\t        var textVerticalAlign = token.textVerticalAlign;\n\t        var y = lineTop + lineHeight / 2;\n\t        if (textVerticalAlign === 'top') {\n\t            y = lineTop + token.height / 2;\n\t        }\n\t        else if (textVerticalAlign === 'bottom') {\n\t            y = lineTop + lineHeight - token.height / 2;\n\t        }\n\t\n\t        !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(\n\t            hostEl,\n\t            ctx,\n\t            tokenStyle,\n\t            textAlign === 'right'\n\t                ? x - token.width\n\t                : textAlign === 'center'\n\t                ? x - token.width / 2\n\t                : x,\n\t            y - token.height / 2,\n\t            token.width,\n\t            token.height\n\t        );\n\t\n\t        var textPadding = token.textPadding;\n\t        if (textPadding) {\n\t            x = getTextXForPadding(x, textAlign, textPadding);\n\t            y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n\t        }\n\t\n\t        setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n\t        setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n\t        setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n\t        setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n\t\n\t        setCtx(ctx, 'textAlign', textAlign);\n\t        // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n\t        // text will offset downward a little bit in font \"Microsoft YaHei\".\n\t        setCtx(ctx, 'textBaseline', 'middle');\n\t\n\t        setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n\t\n\t        var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n\t        var textFill = getFill(tokenStyle.textFill || style.textFill);\n\t        var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth);\n\t\n\t        // Fill after stroke so the outline will not cover the main part.\n\t        if (textStroke) {\n\t            setCtx(ctx, 'lineWidth', textStrokeWidth);\n\t            setCtx(ctx, 'strokeStyle', textStroke);\n\t            ctx.strokeText(token.text, x, y);\n\t        }\n\t        if (textFill) {\n\t            setCtx(ctx, 'fillStyle', textFill);\n\t            ctx.fillText(token.text, x, y);\n\t        }\n\t    }\n\t\n\t    function needDrawBackground(style) {\n\t        return style.textBackgroundColor\n\t            || (style.textBorderWidth && style.textBorderColor);\n\t    }\n\t\n\t    // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n\t    // shape: {x, y, width, height}\n\t    function drawBackground(hostEl, ctx, style, x, y, width, height) {\n\t        var textBackgroundColor = style.textBackgroundColor;\n\t        var textBorderWidth = style.textBorderWidth;\n\t        var textBorderColor = style.textBorderColor;\n\t        var isPlainBg = util.isString(textBackgroundColor);\n\t\n\t        setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n\t        setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n\t        setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n\t        setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\t\n\t        if (isPlainBg || (textBorderWidth && textBorderColor)) {\n\t            ctx.beginPath();\n\t            var textBorderRadius = style.textBorderRadius;\n\t            if (!textBorderRadius) {\n\t                ctx.rect(x, y, width, height);\n\t            }\n\t            else {\n\t                roundRectHelper.buildPath(ctx, {\n\t                    x: x, y: y, width: width, height: height, r: textBorderRadius\n\t                });\n\t            }\n\t            ctx.closePath();\n\t        }\n\t\n\t        if (isPlainBg) {\n\t            setCtx(ctx, 'fillStyle', textBackgroundColor);\n\t            ctx.fill();\n\t        }\n\t        else if (util.isObject(textBackgroundColor)) {\n\t            var image = textBackgroundColor.image;\n\t\n\t            image = imageHelper.createOrUpdateImage(\n\t                image, null, hostEl, onBgImageLoaded, textBackgroundColor\n\t            );\n\t            if (image && imageHelper.isImageReady(image)) {\n\t                ctx.drawImage(image, x, y, width, height);\n\t            }\n\t        }\n\t\n\t        if (textBorderWidth && textBorderColor) {\n\t            setCtx(ctx, 'lineWidth', textBorderWidth);\n\t            setCtx(ctx, 'strokeStyle', textBorderColor);\n\t            ctx.stroke();\n\t        }\n\t    }\n\t\n\t    function onBgImageLoaded(image, textBackgroundColor) {\n\t        // Replace image, so that `contain/text.js#parseRichText`\n\t        // will get correct result in next tick.\n\t        textBackgroundColor.image = image;\n\t    }\n\t\n\t    function getBoxPosition(blockHeiht, style, rect) {\n\t        var baseX = style.x || 0;\n\t        var baseY = style.y || 0;\n\t        var textAlign = style.textAlign;\n\t        var textVerticalAlign = style.textVerticalAlign;\n\t\n\t        // Text position represented by coord\n\t        if (rect) {\n\t            var textPosition = style.textPosition;\n\t            if (textPosition instanceof Array) {\n\t                // Percent\n\t                baseX = rect.x + parsePercent(textPosition[0], rect.width);\n\t                baseY = rect.y + parsePercent(textPosition[1], rect.height);\n\t            }\n\t            else {\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, style.textDistance\n\t                );\n\t                baseX = res.x;\n\t                baseY = res.y;\n\t                // Default align and baseline when has textPosition\n\t                textAlign = textAlign || res.textAlign;\n\t                textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n\t            }\n\t\n\t            // textOffset is only support in RectText, otherwise\n\t            // we have to adjust boundingRect for textOffset.\n\t            var textOffset = style.textOffset;\n\t            if (textOffset) {\n\t                baseX += textOffset[0];\n\t                baseY += textOffset[1];\n\t            }\n\t        }\n\t\n\t        return {\n\t            baseX: baseX,\n\t            baseY: baseY,\n\t            textAlign: textAlign,\n\t            textVerticalAlign: textVerticalAlign\n\t        };\n\t    }\n\t\n\t    function setCtx(ctx, prop, value) {\n\t        // FIXME ??? performance try\n\t        // if (ctx.__currentValues[prop] !== value) {\n\t            // ctx[prop] = ctx.__currentValues[prop] = value;\n\t        ctx[prop] = value;\n\t        // }\n\t        return ctx[prop];\n\t    }\n\t\n\t    /**\n\t     * @param {string} [stroke] If specified, do not check style.textStroke.\n\t     * @param {string} [lineWidth] If specified, do not check style.textStroke.\n\t     * @param {number} style\n\t     */\n\t    var getStroke = helper.getStroke = function (stroke, lineWidth) {\n\t        return (stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none')\n\t            ? null\n\t            // TODO pattern and gradient?\n\t            : (stroke.image || stroke.colorStops)\n\t            ? '#000'\n\t            : stroke;\n\t    };\n\t\n\t    var getFill = helper.getFill = function (fill) {\n\t        return (fill == null || fill === 'none')\n\t            ? null\n\t            // TODO pattern and gradient?\n\t            : (fill.image || fill.colorStops)\n\t            ? '#000'\n\t            : fill;\n\t    };\n\t\n\t    function parsePercent(value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    }\n\t\n\t    function getTextXForPadding(x, textAlign, textPadding) {\n\t        return textAlign === 'right'\n\t            ? (x - textPadding[1])\n\t            : textAlign === 'center'\n\t            ? (x + textPadding[3] / 2 - textPadding[1] / 2)\n\t            : (x + textPadding[3]);\n\t    }\n\t\n\t    /**\n\t     * @param {string} text\n\t     * @param {module:zrender/Style} style\n\t     * @return {boolean}\n\t     */\n\t    helper.needDrawText = function (text, style) {\n\t        return text != null\n\t            && (text\n\t                || style.textBackgroundColor\n\t                || (style.textBorderWidth && style.textBorderColor)\n\t                || style.textPadding\n\t            );\n\t    };\n\t\n\t    module.exports = helper;\n\t\n\t\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var util = __webpack_require__(5);\n\t    var BoundingRect = __webpack_require__(27);\n\t    var imageHelper = __webpack_require__(28);\n\t\n\t    var textWidthCache = {};\n\t    var textWidthCacheCounter = 0;\n\t\n\t    var TEXT_CACHE_MAX = 5000;\n\t    var STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\n\t    var DEFAULT_FONT = '12px sans-serif';\n\t\n\t    var retrieve2 = util.retrieve2;\n\t    var retrieve3 = util.retrieve3;\n\t\n\t    /**\n\t     * @public\n\t     * @param {string} text\n\t     * @param {string} font\n\t     * @return {number} width\n\t     */\n\t    function getTextWidth(text, font) {\n\t        font = font || DEFAULT_FONT;\n\t        var key = text + ':' + font;\n\t        if (textWidthCache[key]) {\n\t            return textWidthCache[key];\n\t        }\n\t\n\t        var textLines = (text + '').split('\\n');\n\t        var width = 0;\n\t\n\t        for (var i = 0, l = textLines.length; i < l; i++) {\n\t            // textContain.measureText may be overrided in SVG or VML\n\t            width = Math.max(textContain.measureText(textLines[i], font).width, width);\n\t        }\n\t\n\t        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t            textWidthCacheCounter = 0;\n\t            textWidthCache = {};\n\t        }\n\t        textWidthCacheCounter++;\n\t        textWidthCache[key] = width;\n\t\n\t        return width;\n\t    }\n\t\n\t    /**\n\t     * @public\n\t     * @param {string} text\n\t     * @param {string} font\n\t     * @param {string} [textAlign='left']\n\t     * @param {string} [textVerticalAlign='top']\n\t     * @param {Array.<number>} [textPadding]\n\t     * @param {Object} [rich]\n\t     * @param {Object} [truncate]\n\t     * @return {Object} {x, y, width, height, lineHeight}\n\t     */\n\t    function getTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n\t        return rich\n\t            ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate)\n\t            : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n\t    }\n\t\n\t    function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n\t        var contentBlock = parsePlainText(text, font, textPadding, truncate);\n\t        var outerWidth = getTextWidth(text, font);\n\t        if (textPadding) {\n\t            outerWidth += textPadding[1] + textPadding[3];\n\t        }\n\t        var outerHeight = contentBlock.outerHeight;\n\t\n\t        var x = adjustTextX(0, outerWidth, textAlign);\n\t        var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\t\n\t        var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n\t        rect.lineHeight = contentBlock.lineHeight;\n\t\n\t        return rect;\n\t    }\n\t\n\t    function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n\t        var contentBlock = parseRichText(text, {\n\t            rich: rich,\n\t            truncate: truncate,\n\t            font: font,\n\t            textAlign: textAlign,\n\t            textPadding: textPadding\n\t        });\n\t        var outerWidth = contentBlock.outerWidth;\n\t        var outerHeight = contentBlock.outerHeight;\n\t\n\t        var x = adjustTextX(0, outerWidth, textAlign);\n\t        var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\t\n\t        return new BoundingRect(x, y, outerWidth, outerHeight);\n\t    }\n\t\n\t    /**\n\t     * @public\n\t     * @param {number} x\n\t     * @param {number} width\n\t     * @param {string} [textAlign='left']\n\t     * @return {number} Adjusted x.\n\t     */\n\t    function adjustTextX(x, width, textAlign) {\n\t        // FIXME Right to left language\n\t        if (textAlign === 'right') {\n\t            x -= width;\n\t        }\n\t        else if (textAlign === 'center') {\n\t            x -= width / 2;\n\t        }\n\t        return x;\n\t    }\n\t\n\t    /**\n\t     * @public\n\t     * @param {number} y\n\t     * @param {number} height\n\t     * @param {string} [textVerticalAlign='top']\n\t     * @return {number} Adjusted y.\n\t     */\n\t    function adjustTextY(y, height, textVerticalAlign) {\n\t        if (textVerticalAlign === 'middle') {\n\t            y -= height / 2;\n\t        }\n\t        else if (textVerticalAlign === 'bottom') {\n\t            y -= height;\n\t        }\n\t        return y;\n\t    }\n\t\n\t    /**\n\t     * @public\n\t     * @param {stirng} textPosition\n\t     * @param {Object} rect {x, y, width, height}\n\t     * @param {number} distance\n\t     * @return {Object} {x, y, textAlign, textVerticalAlign}\n\t     */\n\t    function adjustTextPositionOnRect(textPosition, rect, distance) {\n\t\n\t        var x = rect.x;\n\t        var y = rect.y;\n\t\n\t        var height = rect.height;\n\t        var width = rect.width;\n\t        var halfHeight = height / 2;\n\t\n\t        var textAlign = 'left';\n\t        var textVerticalAlign = 'top';\n\t\n\t        switch (textPosition) {\n\t            case 'left':\n\t                x -= distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                textVerticalAlign = 'middle';\n\t                break;\n\t            case 'right':\n\t                x += distance + width;\n\t                y += halfHeight;\n\t                textVerticalAlign = 'middle';\n\t                break;\n\t            case 'top':\n\t                x += width / 2;\n\t                y -= distance;\n\t                textAlign = 'center';\n\t                textVerticalAlign = 'bottom';\n\t                break;\n\t            case 'bottom':\n\t                x += width / 2;\n\t                y += height + distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'inside':\n\t                x += width / 2;\n\t                y += halfHeight;\n\t                textAlign = 'center';\n\t                textVerticalAlign = 'middle';\n\t                break;\n\t            case 'insideLeft':\n\t                x += distance;\n\t                y += halfHeight;\n\t                textVerticalAlign = 'middle';\n\t                break;\n\t            case 'insideRight':\n\t                x += width - distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                textVerticalAlign = 'middle';\n\t                break;\n\t            case 'insideTop':\n\t                x += width / 2;\n\t                y += distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideBottom':\n\t                x += width / 2;\n\t                y += height - distance;\n\t                textAlign = 'center';\n\t                textVerticalAlign = 'bottom';\n\t                break;\n\t            case 'insideTopLeft':\n\t                x += distance;\n\t                y += distance;\n\t                break;\n\t            case 'insideTopRight':\n\t                x += width - distance;\n\t                y += distance;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideBottomLeft':\n\t                x += distance;\n\t                y += height - distance;\n\t                textVerticalAlign = 'bottom';\n\t                break;\n\t            case 'insideBottomRight':\n\t                x += width - distance;\n\t                y += height - distance;\n\t                textAlign = 'right';\n\t                textVerticalAlign = 'bottom';\n\t                break;\n\t        }\n\t\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            textAlign: textAlign,\n\t            textVerticalAlign: textVerticalAlign\n\t        };\n\t    }\n\t\n\t    /**\n\t     * Show ellipsis if overflow.\n\t     *\n\t     * @public\n\t     * @param  {string} text\n\t     * @param  {string} containerWidth\n\t     * @param  {string} font\n\t     * @param  {number} [ellipsis='...']\n\t     * @param  {Object} [options]\n\t     * @param  {number} [options.maxIterations=3]\n\t     * @param  {number} [options.minChar=0] If truncate result are less\n\t     *                  then minChar, ellipsis will not show, which is\n\t     *                  better for user hint in some cases.\n\t     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t     * @return {string}\n\t     */\n\t    function truncateText(text, containerWidth, font, ellipsis, options) {\n\t        if (!containerWidth) {\n\t            return '';\n\t        }\n\t\n\t        var textLines = (text + '').split('\\n');\n\t        options = prepareTruncateOptions(containerWidth, font, ellipsis, options);\n\t\n\t        // FIXME\n\t        // It is not appropriate that every line has '...' when truncate multiple lines.\n\t        for (var i = 0, len = textLines.length; i < len; i++) {\n\t            textLines[i] = truncateSingleLine(textLines[i], options);\n\t        }\n\t\n\t        return textLines.join('\\n');\n\t    }\n\t\n\t    function prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n\t        options = util.extend({}, options);\n\t\n\t        options.font = font;\n\t        var ellipsis = retrieve2(ellipsis, '...');\n\t        options.maxIterations = retrieve2(options.maxIterations, 2);\n\t        var minChar = options.minChar = retrieve2(options.minChar, 0);\n\t        // FIXME\n\t        // Other languages?\n\t        options.cnCharWidth = getTextWidth('国', font);\n\t        // FIXME\n\t        // Consider proportional font?\n\t        var ascCharWidth = options.ascCharWidth = getTextWidth('a', font);\n\t        options.placeholder = retrieve2(options.placeholder, '');\n\t\n\t        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\t        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\t        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t            contentWidth -= ascCharWidth;\n\t        }\n\t\n\t        var ellipsisWidth = getTextWidth(ellipsis);\n\t        if (ellipsisWidth > contentWidth) {\n\t            ellipsis = '';\n\t            ellipsisWidth = 0;\n\t        }\n\t\n\t        contentWidth = containerWidth - ellipsisWidth;\n\t\n\t        options.ellipsis = ellipsis;\n\t        options.ellipsisWidth = ellipsisWidth;\n\t        options.contentWidth = contentWidth;\n\t        options.containerWidth = containerWidth;\n\t\n\t        return options;\n\t    }\n\t\n\t    function truncateSingleLine(textLine, options) {\n\t        var containerWidth = options.containerWidth;\n\t        var font = options.font;\n\t        var contentWidth = options.contentWidth;\n\t\n\t        if (!containerWidth) {\n\t            return '';\n\t        }\n\t\n\t        var lineWidth = getTextWidth(textLine, font);\n\t\n\t        if (lineWidth <= containerWidth) {\n\t            return textLine;\n\t        }\n\t\n\t        for (var j = 0;; j++) {\n\t            if (lineWidth <= contentWidth || j >= options.maxIterations) {\n\t                textLine += options.ellipsis;\n\t                break;\n\t            }\n\t\n\t            var subLength = j === 0\n\t                ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth)\n\t                : lineWidth > 0\n\t                ? Math.floor(textLine.length * contentWidth / lineWidth)\n\t                : 0;\n\t\n\t            textLine = textLine.substr(0, subLength);\n\t            lineWidth = getTextWidth(textLine, font);\n\t        }\n\t\n\t        if (textLine === '') {\n\t            textLine = options.placeholder;\n\t        }\n\t\n\t        return textLine;\n\t    }\n\t\n\t    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t        var width = 0;\n\t        var i = 0;\n\t        for (var len = text.length; i < len && width < contentWidth; i++) {\n\t            var charCode = text.charCodeAt(i);\n\t            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n\t        }\n\t        return i;\n\t    }\n\t\n\t    /**\n\t     * @public\n\t     * @param {string} font\n\t     * @return {number} line height\n\t     */\n\t    function getLineHeight(font) {\n\t        // FIXME A rough approach.\n\t        return getTextWidth('国', font);\n\t    }\n\t\n\t    /**\n\t     * @public\n\t     * @param {string} text\n\t     * @param {string} font\n\t     * @return {Object} width\n\t     */\n\t    function measureText(text, font) {\n\t        var ctx = util.getContext();\n\t        ctx.font = font || DEFAULT_FONT;\n\t        return ctx.measureText(text);\n\t    }\n\t\n\t    /**\n\t     * @public\n\t     * @param {string} text\n\t     * @param {string} font\n\t     * @param {Object} [truncate]\n\t     * @return {Object} block: {lineHeight, lines, height, outerHeight}\n\t     *  Notice: for performance, do not calculate outerWidth util needed.\n\t     */\n\t    function parsePlainText(text, font, padding, truncate) {\n\t        text != null && (text += '');\n\t\n\t        var lineHeight = getLineHeight(font);\n\t        var lines = text ? text.split('\\n') : [];\n\t        var height = lines.length * lineHeight;\n\t        var outerHeight = height;\n\t\n\t        if (padding) {\n\t            outerHeight += padding[0] + padding[2];\n\t        }\n\t\n\t        if (text && truncate) {\n\t            var truncOuterHeight = truncate.outerHeight;\n\t            var truncOuterWidth = truncate.outerWidth;\n\t            if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n\t                text = '';\n\t                lines = [];\n\t            }\n\t            else if (truncOuterWidth != null) {\n\t                var options = prepareTruncateOptions(\n\t                    truncOuterWidth - (padding ? padding[1] + padding[3] : 0),\n\t                    font,\n\t                    truncate.ellipsis,\n\t                    {minChar: truncate.minChar, placeholder: truncate.placeholder}\n\t                );\n\t\n\t                // FIXME\n\t                // It is not appropriate that every line has '...' when truncate multiple lines.\n\t                for (var i = 0, len = lines.length; i < len; i++) {\n\t                    lines[i] = truncateSingleLine(lines[i], options);\n\t                }\n\t            }\n\t        }\n\t\n\t        return {\n\t            lines: lines,\n\t            height: height,\n\t            outerHeight: outerHeight,\n\t            lineHeight: lineHeight\n\t        };\n\t    }\n\t\n\t    /**\n\t     * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n\t     * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n\t     *\n\t     * @public\n\t     * @param {string} text\n\t     * @param {Object} style\n\t     * @return {Object} block\n\t     * {\n\t     *      width,\n\t     *      height,\n\t     *      lines: [{\n\t     *          lineHeight,\n\t     *          width,\n\t     *          tokens: [[{\n\t     *              styleName,\n\t     *              text,\n\t     *              width,      // include textPadding\n\t     *              height,     // include textPadding\n\t     *              textWidth, // pure text width\n\t     *              textHeight, // pure text height\n\t     *              lineHeihgt,\n\t     *              font,\n\t     *              textAlign,\n\t     *              textVerticalAlign\n\t     *          }], [...], ...]\n\t     *      }, ...]\n\t     * }\n\t     * If styleName is undefined, it is plain text.\n\t     */\n\t    function parseRichText(text, style) {\n\t        var contentBlock = {lines: [], width: 0, height: 0};\n\t\n\t        text != null && (text += '');\n\t        if (!text) {\n\t            return contentBlock;\n\t        }\n\t\n\t        var lastIndex = STYLE_REG.lastIndex = 0;\n\t        var result;\n\t        while ((result = STYLE_REG.exec(text)) != null)  {\n\t            var matchedIndex = result.index;\n\t            if (matchedIndex > lastIndex) {\n\t                pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n\t            }\n\t            pushTokens(contentBlock, result[2], result[1]);\n\t            lastIndex = STYLE_REG.lastIndex;\n\t        }\n\t\n\t        if (lastIndex < text.length) {\n\t            pushTokens(contentBlock, text.substring(lastIndex, text.length));\n\t        }\n\t\n\t        var lines = contentBlock.lines;\n\t        var contentHeight = 0;\n\t        var contentWidth = 0;\n\t        // For `textWidth: 100%`\n\t        var pendingList = [];\n\t\n\t        var stlPadding = style.textPadding;\n\t\n\t        var truncate = style.truncate;\n\t        var truncateWidth = truncate && truncate.outerWidth;\n\t        var truncateHeight = truncate && truncate.outerHeight;\n\t        if (stlPadding) {\n\t            truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n\t            truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n\t        }\n\t\n\t        // Calculate layout info of tokens.\n\t        for (var i = 0; i < lines.length; i++) {\n\t            var line = lines[i];\n\t            var lineHeight = 0;\n\t            var lineWidth = 0;\n\t\n\t            for (var j = 0; j < line.tokens.length; j++) {\n\t                var token = line.tokens[j];\n\t                var tokenStyle = token.styleName && style.rich[token.styleName] || {};\n\t                // textPadding should not inherit from style.\n\t                var textPadding = token.textPadding = tokenStyle.textPadding;\n\t\n\t                // textFont has been asigned to font by `normalizeStyle`.\n\t                var font = token.font = tokenStyle.font || style.font;\n\t\n\t                // textHeight can be used when textVerticalAlign is specified in token.\n\t                var tokenHeight = token.textHeight = retrieve2(\n\t                    // textHeight should not be inherited, consider it can be specified\n\t                    // as box height of the block.\n\t                    tokenStyle.textHeight, textContain.getLineHeight(font)\n\t                );\n\t                textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n\t                token.height = tokenHeight;\n\t                token.lineHeight = retrieve3(\n\t                    tokenStyle.textLineHeight, style.textLineHeight, tokenHeight\n\t                );\n\t\n\t                token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n\t                token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\t\n\t                if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n\t                    return {lines: [], width: 0, height: 0};\n\t                }\n\t\n\t                token.textWidth = textContain.getWidth(token.text, font);\n\t                var tokenWidth = tokenStyle.textWidth;\n\t                var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto';\n\t\n\t                // Percent width, can be `100%`, can be used in drawing separate\n\t                // line when box width is needed to be auto.\n\t                if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n\t                    token.percentWidth = tokenWidth;\n\t                    pendingList.push(token);\n\t                    tokenWidth = 0;\n\t                    // Do not truncate in this case, because there is no user case\n\t                    // and it is too complicated.\n\t                }\n\t                else {\n\t                    if (tokenWidthNotSpecified) {\n\t                        tokenWidth = token.textWidth;\n\t\n\t                        // FIXME: If image is not loaded and textWidth is not specified, calling\n\t                        // `getBoundingRect()` will not get correct result.\n\t                        var textBackgroundColor = tokenStyle.textBackgroundColor;\n\t                        var bgImg = textBackgroundColor && textBackgroundColor.image;\n\t\n\t                        // Use cases:\n\t                        // (1) If image is not loaded, it will be loaded at render phase and call\n\t                        // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n\t                        // image, and then the right size will be calculated here at the next tick.\n\t                        // See `graphic/helper/text.js`.\n\t                        // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n\t                        // use `imageHelper.findExistImage` to find cached image.\n\t                        // `imageHelper.findExistImage` will always be called here before\n\t                        // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n\t                        // which ensures that image will not be rendered before correct size calcualted.\n\t                        if (bgImg) {\n\t                            bgImg = imageHelper.findExistImage(bgImg);\n\t                            if (imageHelper.isImageReady(bgImg)) {\n\t                                tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n\t                            }\n\t                        }\n\t                    }\n\t\n\t                    var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n\t                    tokenWidth += paddingW;\n\t\n\t                    var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\t\n\t                    if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n\t                        if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n\t                            token.text = '';\n\t                            token.textWidth = tokenWidth = 0;\n\t                        }\n\t                        else {\n\t                            token.text = truncateText(\n\t                                token.text, remianTruncWidth - paddingW, font, truncate.ellipsis,\n\t                                {minChar: truncate.minChar}\n\t                            );\n\t                            token.textWidth = textContain.getWidth(token.text, font);\n\t                            tokenWidth = token.textWidth + paddingW;\n\t                        }\n\t                    }\n\t                }\n\t\n\t                lineWidth += (token.width = tokenWidth);\n\t                tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n\t            }\n\t\n\t            line.width = lineWidth;\n\t            line.lineHeight = lineHeight;\n\t            contentHeight += lineHeight;\n\t            contentWidth = Math.max(contentWidth, lineWidth);\n\t        }\n\t\n\t        contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n\t        contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\t\n\t        if (stlPadding) {\n\t            contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n\t            contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n\t        }\n\t\n\t        for (var i = 0; i < pendingList.length; i++) {\n\t            var token = pendingList[i];\n\t            var percentWidth = token.percentWidth;\n\t            // Should not base on outerWidth, because token can not be placed out of padding.\n\t            token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n\t        }\n\t\n\t        return contentBlock;\n\t    }\n\t\n\t    function pushTokens(block, str, styleName) {\n\t        var isEmptyStr = str === '';\n\t        var strs = str.split('\\n');\n\t        var lines = block.lines;\n\t\n\t        for (var i = 0; i < strs.length; i++) {\n\t            var text = strs[i];\n\t            var token = {\n\t                styleName: styleName,\n\t                text: text,\n\t                isLineHolder: !text && !isEmptyStr\n\t            };\n\t\n\t            // The first token should be appended to the last line.\n\t            if (!i) {\n\t                var tokens = (lines[lines.length - 1] || (lines[0] = {tokens: []})).tokens;\n\t\n\t                // Consider cases:\n\t                // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n\t                // (which is a placeholder) should be replaced by new token.\n\t                // (2) A image backage, where token likes {a|}.\n\t                // (3) A redundant '' will affect textAlign in line.\n\t                // (4) tokens with the same tplName should not be merged, because\n\t                // they should be displayed in different box (with border and padding).\n\t                var tokensLen = tokens.length;\n\t                (tokensLen === 1 && tokens[0].isLineHolder)\n\t                    ? (tokens[0] = token)\n\t                    // Consider text is '', only insert when it is the \"lineHolder\" or\n\t                    // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n\t                    : ((text || !tokensLen || isEmptyStr) && tokens.push(token));\n\t            }\n\t            // Other tokens always start a new line.\n\t            else {\n\t                // If there is '', insert it as a placeholder.\n\t                lines.push({tokens: [token]});\n\t            }\n\t        }\n\t    }\n\t\n\t    function makeFont(style) {\n\t        // FIXME in node-canvas fontWeight is before fontStyle\n\t        // Use `fontSize` `fontFamily` to check whether font properties are defined.\n\t        return (style.fontSize || style.fontFamily) && [\n\t            style.fontStyle,\n\t            style.fontWeight,\n\t            (style.fontSize || 12) + 'px',\n\t            // If font properties are defined, `fontFamily` should not be ignored.\n\t            style.fontFamily || 'sans-serif'\n\t        ].join(' ') || style.textFont || style.font;\n\t    }\n\t\n\t    var textContain = {\n\t\n\t        getWidth: getTextWidth,\n\t\n\t        getBoundingRect: getTextRect,\n\t\n\t        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\t\n\t        truncateText: truncateText,\n\t\n\t        measureText: measureText,\n\t\n\t        getLineHeight: getLineHeight,\n\t\n\t        parsePlainText: parsePlainText,\n\t\n\t        parseRichText: parseRichText,\n\t\n\t        adjustTextX: adjustTextX,\n\t\n\t        adjustTextY: adjustTextY,\n\t\n\t        makeFont: makeFont,\n\t\n\t        DEFAULT_FONT: DEFAULT_FONT\n\t    };\n\t\n\t    module.exports = textContain;\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module echarts/core/BoundingRect\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(15);\n\t    var matrix = __webpack_require__(14);\n\t\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    /**\n\t     * @alias module:echarts/core/BoundingRect\n\t     */\n\t    function BoundingRect(x, y, width, height) {\n\t\n\t        if (width < 0) {\n\t            x = x + width;\n\t            width = -width;\n\t        }\n\t        if (height < 0) {\n\t            y = y + height;\n\t            height = -height;\n\t        }\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.x = x;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.y = y;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.width = width;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.height = height;\n\t    }\n\t\n\t    BoundingRect.prototype = {\n\t\n\t        constructor: BoundingRect,\n\t\n\t        /**\n\t         * @param {module:echarts/core/BoundingRect} other\n\t         */\n\t        union: function (other) {\n\t            var x = mathMin(other.x, this.x);\n\t            var y = mathMin(other.y, this.y);\n\t\n\t            this.width = mathMax(\n\t                    other.x + other.width,\n\t                    this.x + this.width\n\t                ) - x;\n\t            this.height = mathMax(\n\t                    other.y + other.height,\n\t                    this.y + this.height\n\t                ) - y;\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} m\n\t         * @methods\n\t         */\n\t        applyTransform: (function () {\n\t            var lt = [];\n\t            var rb = [];\n\t            var lb = [];\n\t            var rt = [];\n\t            return function (m) {\n\t                // In case usage like this\n\t                // el.getBoundingRect().applyTransform(el.transform)\n\t                // And element has no transform\n\t                if (!m) {\n\t                    return;\n\t                }\n\t                lt[0] = lb[0] = this.x;\n\t                lt[1] = rt[1] = this.y;\n\t                rb[0] = rt[0] = this.x + this.width;\n\t                rb[1] = lb[1] = this.y + this.height;\n\t\n\t                v2ApplyTransform(lt, lt, m);\n\t                v2ApplyTransform(rb, rb, m);\n\t                v2ApplyTransform(lb, lb, m);\n\t                v2ApplyTransform(rt, rt, m);\n\t\n\t                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n\t                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n\t                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n\t                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n\t                this.width = maxX - this.x;\n\t                this.height = maxY - this.y;\n\t            };\n\t        })(),\n\t\n\t        /**\n\t         * Calculate matrix of transforming from self to target rect\n\t         * @param  {module:zrender/core/BoundingRect} b\n\t         * @return {Array.<number>}\n\t         */\n\t        calculateTransform: function (b) {\n\t            var a = this;\n\t            var sx = b.width / a.width;\n\t            var sy = b.height / a.height;\n\t\n\t            var m = matrix.create();\n\t\n\t            // 矩阵右乘\n\t            matrix.translate(m, m, [-a.x, -a.y]);\n\t            matrix.scale(m, m, [sx, sy]);\n\t            matrix.translate(m, m, [b.x, b.y]);\n\t\n\t            return m;\n\t        },\n\t\n\t        /**\n\t         * @param {(module:echarts/core/BoundingRect|Object)} b\n\t         * @return {boolean}\n\t         */\n\t        intersect: function (b) {\n\t            if (!b) {\n\t                return false;\n\t            }\n\t\n\t            if (!(b instanceof BoundingRect)) {\n\t                // Normalize negative width/height.\n\t                b = BoundingRect.create(b);\n\t            }\n\t\n\t            var a = this;\n\t            var ax0 = a.x;\n\t            var ax1 = a.x + a.width;\n\t            var ay0 = a.y;\n\t            var ay1 = a.y + a.height;\n\t\n\t            var bx0 = b.x;\n\t            var bx1 = b.x + b.width;\n\t            var by0 = b.y;\n\t            var by1 = b.y + b.height;\n\t\n\t            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var rect = this;\n\t            return x >= rect.x\n\t                && x <= (rect.x + rect.width)\n\t                && y >= rect.y\n\t                && y <= (rect.y + rect.height);\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/core/BoundingRect}\n\t         */\n\t        clone: function () {\n\t            return new BoundingRect(this.x, this.y, this.width, this.height);\n\t        },\n\t\n\t        /**\n\t         * Copy from another rect\n\t         */\n\t        copy: function (other) {\n\t            this.x = other.x;\n\t            this.y = other.y;\n\t            this.width = other.width;\n\t            this.height = other.height;\n\t        },\n\t\n\t        plain: function () {\n\t            return {\n\t                x: this.x,\n\t                y: this.y,\n\t                width: this.width,\n\t                height: this.height\n\t            };\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {Object|module:zrender/core/BoundingRect} rect\n\t     * @param {number} rect.x\n\t     * @param {number} rect.y\n\t     * @param {number} rect.width\n\t     * @param {number} rect.height\n\t     * @return {module:zrender/core/BoundingRect}\n\t     */\n\t    BoundingRect.create = function (rect) {\n\t        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n\t    };\n\t\n\t    module.exports = BoundingRect;\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var LRU = __webpack_require__(21);\n\t    var globalImageCache = new LRU(50);\n\t\n\t    var helper = {};\n\t\n\t    /**\n\t     * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n\t     * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n\t     */\n\t    helper.findExistImage = function (newImageOrSrc) {\n\t        if (typeof newImageOrSrc === 'string') {\n\t            var cachedImgObj = globalImageCache.get(newImageOrSrc);\n\t            return cachedImgObj && cachedImgObj.image;\n\t        }\n\t        else {\n\t            return newImageOrSrc;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Caution: User should cache loaded images, but not just count on LRU.\n\t     * Consider if required images more than LRU size, will dead loop occur?\n\t     *\n\t     * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n\t     * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n\t     * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n\t     * @param {Function} [cb] params: (image, cbPayload)\n\t     * @param {Object} [cbPayload] Payload on cb calling.\n\t     * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n\t     */\n\t    helper.createOrUpdateImage = function (newImageOrSrc, image, hostEl, cb, cbPayload) {\n\t        if (!newImageOrSrc) {\n\t            return image;\n\t        }\n\t        else if (typeof newImageOrSrc === 'string') {\n\t\n\t            // Image should not be loaded repeatly.\n\t            if ((image && image.__zrImageSrc === newImageOrSrc) || !hostEl) {\n\t                return image;\n\t            }\n\t\n\t            // Only when there is no existent image or existent image src\n\t            // is different, this method is responsible for load.\n\t            var cachedImgObj = globalImageCache.get(newImageOrSrc);\n\t\n\t            var pendingWrap = {hostEl: hostEl, cb: cb, cbPayload: cbPayload};\n\t\n\t            if (cachedImgObj) {\n\t                image = cachedImgObj.image;\n\t                !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n\t            }\n\t            else {\n\t                !image && (image = new Image());\n\t                image.onload = imageOnLoad;\n\t\n\t                globalImageCache.put(\n\t                    newImageOrSrc,\n\t                    image.__cachedImgObj = {\n\t                        image: image,\n\t                        pending: [pendingWrap]\n\t                    }\n\t                );\n\t\n\t                image.src = image.__zrImageSrc = newImageOrSrc;\n\t            }\n\t\n\t            return image;\n\t        }\n\t        // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t        else {\n\t            return newImageOrSrc;\n\t        }\n\t    };\n\t\n\t    function imageOnLoad() {\n\t        var cachedImgObj = this.__cachedImgObj;\n\t        this.onload = this.__cachedImgObj = null;\n\t\n\t        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t            var pendingWrap = cachedImgObj.pending[i];\n\t            var cb = pendingWrap.cb;\n\t            cb && cb(this, pendingWrap.cbPayload);\n\t            pendingWrap.hostEl.dirty();\n\t        }\n\t        cachedImgObj.pending.length = 0;\n\t    }\n\t\n\t    var isImageReady = helper.isImageReady = function (image) {\n\t        return image && image.width && image.height;\n\t    };\n\t\n\t    module.exports = helper;\n\t\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            var r = shape.r;\n\t            var r1;\n\t            var r2;\n\t            var r3;\n\t            var r4;\n\t\n\t            // Convert width and height to positive for better borderRadius\n\t            if (width < 0) {\n\t                x = x + width;\n\t                width = -width;\n\t            }\n\t            if (height < 0) {\n\t                y = y + height;\n\t                height = -height;\n\t            }\n\t\n\t            if (typeof r === 'number') {\n\t                r1 = r2 = r3 = r4 = r;\n\t            }\n\t            else if (r instanceof Array) {\n\t                if (r.length === 1) {\n\t                    r1 = r2 = r3 = r4 = r[0];\n\t                }\n\t                else if (r.length === 2) {\n\t                    r1 = r3 = r[0];\n\t                    r2 = r4 = r[1];\n\t                }\n\t                else if (r.length === 3) {\n\t                    r1 = r[0];\n\t                    r2 = r4 = r[1];\n\t                    r3 = r[2];\n\t                }\n\t                else {\n\t                    r1 = r[0];\n\t                    r2 = r[1];\n\t                    r3 = r[2];\n\t                    r4 = r[3];\n\t                }\n\t            }\n\t            else {\n\t                r1 = r2 = r3 = r4 = 0;\n\t            }\n\t\n\t            var total;\n\t            if (r1 + r2 > width) {\n\t                total = r1 + r2;\n\t                r1 *= width / total;\n\t                r2 *= width / total;\n\t            }\n\t            if (r3 + r4 > width) {\n\t                total = r3 + r4;\n\t                r3 *= width / total;\n\t                r4 *= width / total;\n\t            }\n\t            if (r2 + r3 > height) {\n\t                total = r2 + r3;\n\t                r2 *= height / total;\n\t                r3 *= height / total;\n\t            }\n\t            if (r1 + r4 > height) {\n\t                total = r1 + r4;\n\t                r1 *= height / total;\n\t                r4 *= height / total;\n\t            }\n\t            ctx.moveTo(x + r1, y);\n\t            ctx.lineTo(x + width - r2, y);\n\t            r2 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y, x + width, y + r2\n\t            );\n\t            ctx.lineTo(x + width, y + height - r3);\n\t            r3 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y + height, x + width - r3, y + height\n\t            );\n\t            ctx.lineTo(x + r4, y + height);\n\t            r4 !== 0 && ctx.quadraticCurveTo(\n\t                x, y + height, x, y + height - r4\n\t            );\n\t            ctx.lineTo(x, y + r1);\n\t            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t        }\n\t    };\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n\t * 可以用于 isInsidePath 判断以及获取boundingRect\n\t *\n\t * @module zrender/core/PathProxy\n\t * @author Yi Shen (http://www.github.com/pissang)\n\t */\n\t\n\t // TODO getTotalLength, getPointAtLength\n\t\n\t\n\t    var curve = __webpack_require__(31);\n\t    var vec2 = __webpack_require__(15);\n\t    var bbox = __webpack_require__(32);\n\t    var BoundingRect = __webpack_require__(27);\n\t    var dpr = __webpack_require__(23).devicePixelRatio;\n\t\n\t    var CMD = {\n\t        M: 1,\n\t        L: 2,\n\t        C: 3,\n\t        Q: 4,\n\t        A: 5,\n\t        Z: 6,\n\t        // Rect\n\t        R: 7\n\t    };\n\t\n\t    // var CMD_MEM_SIZE = {\n\t    //     M: 3,\n\t    //     L: 3,\n\t    //     C: 7,\n\t    //     Q: 5,\n\t    //     A: 9,\n\t    //     R: 5,\n\t    //     Z: 1\n\t    // };\n\t\n\t    var min = [];\n\t    var max = [];\n\t    var min2 = [];\n\t    var max2 = [];\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathCos = Math.cos;\n\t    var mathSin = Math.sin;\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAbs = Math.abs;\n\t\n\t    var hasTypedArray = typeof Float32Array != 'undefined';\n\t\n\t    /**\n\t     * @alias module:zrender/core/PathProxy\n\t     * @constructor\n\t     */\n\t    var PathProxy = function (notSaveData) {\n\t\n\t        this._saveData = !(notSaveData || false);\n\t\n\t        if (this._saveData) {\n\t            /**\n\t             * Path data. Stored as flat array\n\t             * @type {Array.<Object>}\n\t             */\n\t            this.data = [];\n\t        }\n\t\n\t        this._ctx = null;\n\t    };\n\t\n\t    /**\n\t     * 快速计算Path包围盒（并不是最小包围盒）\n\t     * @return {Object}\n\t     */\n\t    PathProxy.prototype = {\n\t\n\t        constructor: PathProxy,\n\t\n\t        _xi: 0,\n\t        _yi: 0,\n\t\n\t        _x0: 0,\n\t        _y0: 0,\n\t        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t        _ux: 0,\n\t        _uy: 0,\n\t\n\t        _len: 0,\n\t\n\t        _lineDash: null,\n\t\n\t        _dashOffset: 0,\n\t\n\t        _dashIdx: 0,\n\t\n\t        _dashSum: 0,\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        setScale: function (sx, sy) {\n\t            this._ux = mathAbs(1 / dpr / sx) || 0;\n\t            this._uy = mathAbs(1 / dpr / sy) || 0;\n\t        },\n\t\n\t        getContext: function () {\n\t            return this._ctx;\n\t        },\n\t\n\t        /**\n\t         * @param  {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        beginPath: function (ctx) {\n\t\n\t            this._ctx = ctx;\n\t\n\t            ctx && ctx.beginPath();\n\t\n\t            ctx && (this.dpr = ctx.dpr);\n\t\n\t            // Reset\n\t            if (this._saveData) {\n\t                this._len = 0;\n\t            }\n\t\n\t            if (this._lineDash) {\n\t                this._lineDash = null;\n\t\n\t                this._dashOffset = 0;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        moveTo: function (x, y) {\n\t            this.addData(CMD.M, x, y);\n\t            this._ctx && this._ctx.moveTo(x, y);\n\t\n\t            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n\t            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n\t            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n\t            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\t            this._x0 = x;\n\t            this._y0 = y;\n\t\n\t            this._xi = x;\n\t            this._yi = y;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        lineTo: function (x, y) {\n\t            var exceedUnit = mathAbs(x - this._xi) > this._ux\n\t                || mathAbs(y - this._yi) > this._uy\n\t                // Force draw the first segment\n\t                || this._len < 5;\n\t\n\t            this.addData(CMD.L, x, y);\n\t\n\t            if (this._ctx && exceedUnit) {\n\t                this._needsDash() ? this._dashedLineTo(x, y)\n\t                    : this._ctx.lineTo(x, y);\n\t            }\n\t            if (exceedUnit) {\n\t                this._xi = x;\n\t                this._yi = y;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @param  {number} x3\n\t         * @param  {number} y3\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n\t                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t            }\n\t            this._xi = x3;\n\t            this._yi = y3;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        quadraticCurveTo: function (x1, y1, x2, y2) {\n\t            this.addData(CMD.Q, x1, y1, x2, y2);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n\t                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t            }\n\t            this._xi = x2;\n\t            this._yi = y2;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} cx\n\t         * @param  {number} cy\n\t         * @param  {number} r\n\t         * @param  {number} startAngle\n\t         * @param  {number} endAngle\n\t         * @param  {boolean} anticlockwise\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t            this.addData(\n\t                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n\t            );\n\t            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t\n\t            this._xi = mathCos(endAngle) * r + cx;\n\t            this._yi = mathSin(endAngle) * r + cx;\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        arcTo: function (x1, y1, x2, y2, radius) {\n\t            if (this._ctx) {\n\t                this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        rect: function (x, y, w, h) {\n\t            this._ctx && this._ctx.rect(x, y, w, h);\n\t            this.addData(CMD.R, x, y, w, h);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        closePath: function () {\n\t            this.addData(CMD.Z);\n\t\n\t            var ctx = this._ctx;\n\t            var x0 = this._x0;\n\t            var y0 = this._y0;\n\t            if (ctx) {\n\t                this._needsDash() && this._dashedLineTo(x0, y0);\n\t                ctx.closePath();\n\t            }\n\t\n\t            this._xi = x0;\n\t            this._yi = y0;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n\t         * stroke 同样\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        fill: function (ctx) {\n\t            ctx && ctx.fill();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        stroke: function (ctx) {\n\t            ctx && ctx.stroke();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * 必须在其它绘制命令前调用\n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDash: function (lineDash) {\n\t            if (lineDash instanceof Array) {\n\t                this._lineDash = lineDash;\n\t\n\t                this._dashIdx = 0;\n\t\n\t                var lineDashSum = 0;\n\t                for (var i = 0; i < lineDash.length; i++) {\n\t                    lineDashSum += lineDash[i];\n\t                }\n\t                this._dashSum = lineDashSum;\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 必须在其它绘制命令前调用\n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDashOffset: function (offset) {\n\t            this._dashOffset = offset;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         *\n\t         * @return {boolean}\n\t         */\n\t        len: function () {\n\t            return this._len;\n\t        },\n\t\n\t        /**\n\t         * 直接设置 Path 数据\n\t         */\n\t        setData: function (data) {\n\t\n\t            var len = data.length;\n\t\n\t            if (! (this.data && this.data.length == len) && hasTypedArray) {\n\t                this.data = new Float32Array(len);\n\t            }\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                this.data[i] = data[i];\n\t            }\n\t\n\t            this._len = len;\n\t        },\n\t\n\t        /**\n\t         * 添加子路径\n\t         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n\t         */\n\t        appendPath: function (path) {\n\t            if (!(path instanceof Array)) {\n\t                path = [path];\n\t            }\n\t            var len = path.length;\n\t            var appendSize = 0;\n\t            var offset = this._len;\n\t            for (var i = 0; i < len; i++) {\n\t                appendSize += path[i].len();\n\t            }\n\t            if (hasTypedArray && (this.data instanceof Float32Array)) {\n\t                this.data = new Float32Array(offset + appendSize);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                var appendPathData = path[i].data;\n\t                for (var k = 0; k < appendPathData.length; k++) {\n\t                    this.data[offset++] = appendPathData[k];\n\t                }\n\t            }\n\t            this._len = offset;\n\t        },\n\t\n\t        /**\n\t         * 填充 Path 数据。\n\t         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n\t         */\n\t        addData: function (cmd) {\n\t            if (!this._saveData) {\n\t                return;\n\t            }\n\t\n\t            var data = this.data;\n\t            if (this._len + arguments.length > data.length) {\n\t                // 因为之前的数组已经转换成静态的 Float32Array\n\t                // 所以不够用时需要扩展一个新的动态数组\n\t                this._expandData();\n\t                data = this.data;\n\t            }\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                data[this._len++] = arguments[i];\n\t            }\n\t\n\t            this._prevCmd = cmd;\n\t        },\n\t\n\t        _expandData: function () {\n\t            // Only if data is Float32Array\n\t            if (!(this.data instanceof Array)) {\n\t                var newData = [];\n\t                for (var i = 0; i < this._len; i++) {\n\t                    newData[i] = this.data[i];\n\t                }\n\t                this.data = newData;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * If needs js implemented dashed line\n\t         * @return {boolean}\n\t         * @private\n\t         */\n\t        _needsDash: function () {\n\t            return this._lineDash;\n\t        },\n\t\n\t        _dashedLineTo: function (x1, y1) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var dx = x1 - x0;\n\t            var dy = y1 - y0;\n\t            var dist = mathSqrt(dx * dx + dy * dy);\n\t            var x = x0;\n\t            var y = y0;\n\t            var dash;\n\t            var nDash = lineDash.length;\n\t            var idx;\n\t            dx /= dist;\n\t            dy /= dist;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            x -= offset * dx;\n\t            y -= offset * dy;\n\t\n\t            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n\t            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n\t                idx = this._dashIdx;\n\t                dash = lineDash[idx];\n\t                x += dx * dash;\n\t                y += dy * dash;\n\t                this._dashIdx = (idx + 1) % nDash;\n\t                // Skip positive offset\n\t                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n\t                    continue;\n\t                }\n\t                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n\t                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n\t                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n\t                );\n\t            }\n\t            // Offset for next lineTo\n\t            dx = x - x1;\n\t            dy = y - y1;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        // Not accurate dashed line to\n\t        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var t;\n\t            var dx;\n\t            var dy;\n\t            var cubicAt = curve.cubicAt;\n\t            var bezierLen = 0;\n\t            var idx = this._dashIdx;\n\t            var nDash = lineDash.length;\n\t\n\t            var x;\n\t            var y;\n\t\n\t            var tmpLen = 0;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            // Bezier approx length\n\t            for (t = 0; t < 1; t += 0.1) {\n\t                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n\t                    - cubicAt(x0, x1, x2, x3, t);\n\t                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n\t                    - cubicAt(y0, y1, y2, y3, t);\n\t                bezierLen += mathSqrt(dx * dx + dy * dy);\n\t            }\n\t\n\t            // Find idx after add offset\n\t            for (; idx < nDash; idx++) {\n\t                tmpLen += lineDash[idx];\n\t                if (tmpLen > offset) {\n\t                    break;\n\t                }\n\t            }\n\t            t = (tmpLen - offset) / bezierLen;\n\t\n\t            while (t <= 1) {\n\t\n\t                x = cubicAt(x0, x1, x2, x3, t);\n\t                y = cubicAt(y0, y1, y2, y3, t);\n\t\n\t                // Use line to approximate dashed bezier\n\t                // Bad result if dash is long\n\t                idx % 2 ? ctx.moveTo(x, y)\n\t                    : ctx.lineTo(x, y);\n\t\n\t                t += lineDash[idx] / bezierLen;\n\t\n\t                idx = (idx + 1) % nDash;\n\t            }\n\t\n\t            // Finish the last segment and calculate the new offset\n\t            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n\t            dx = x3 - x;\n\t            dy = y3 - y;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            var x3 = x2;\n\t            var y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (this._xi + 2 * x1) / 3;\n\t            y1 = (this._yi + 2 * y1) / 3;\n\t\n\t            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t        },\n\t\n\t        /**\n\t         * 转成静态的 Float32Array 减少堆内存占用\n\t         * Convert dynamic array to static Float32Array\n\t         */\n\t        toStatic: function () {\n\t            var data = this.data;\n\t            if (data instanceof Array) {\n\t                data.length = this._len;\n\t                if (hasTypedArray) {\n\t                    this.data = new Float32Array(data);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function () {\n\t            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t\n\t            var data = this.data;\n\t            var xi = 0;\n\t            var yi = 0;\n\t            var x0 = 0;\n\t            var y0 = 0;\n\t\n\t            for (var i = 0; i < data.length;) {\n\t                var cmd = data[i++];\n\t\n\t                if (i == 1) {\n\t                    // 如果第一个命令是 L, C, Q\n\t                    // 则 previous point 同绘制命令的第一个 point\n\t                    //\n\t                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                    xi = data[i];\n\t                    yi = data[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t                        // 在 closePath 的时候使用\n\t                        x0 = data[i++];\n\t                        y0 = data[i++];\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        min2[0] = x0;\n\t                        min2[1] = y0;\n\t                        max2[0] = x0;\n\t                        max2[1] = y0;\n\t                        break;\n\t                    case CMD.L:\n\t                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.C:\n\t                        bbox.fromCubic(\n\t                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.Q:\n\t                        bbox.fromQuadratic(\n\t                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.A:\n\t                        // TODO Arc 判断的开销比较大\n\t                        var cx = data[i++];\n\t                        var cy = data[i++];\n\t                        var rx = data[i++];\n\t                        var ry = data[i++];\n\t                        var startAngle = data[i++];\n\t                        var endAngle = data[i++] + startAngle;\n\t                        // TODO Arc 旋转\n\t                        var psi = data[i++];\n\t                        var anticlockwise = 1 - data[i++];\n\t\n\t                        if (i == 1) {\n\t                            // 直接使用 arc 命令\n\t                            // 第一个命令起点还未定义\n\t                            x0 = mathCos(startAngle) * rx + cx;\n\t                            y0 = mathSin(startAngle) * ry + cy;\n\t                        }\n\t\n\t                        bbox.fromArc(\n\t                            cx, cy, rx, ry, startAngle, endAngle,\n\t                            anticlockwise, min2, max2\n\t                        );\n\t\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = data[i++];\n\t                        y0 = yi = data[i++];\n\t                        var width = data[i++];\n\t                        var height = data[i++];\n\t                        // Use fromLine\n\t                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t                        break;\n\t                    case CMD.Z:\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        break;\n\t                }\n\t\n\t                // Union\n\t                vec2.min(min, min, min2);\n\t                vec2.max(max, max, max2);\n\t            }\n\t\n\t            // No data\n\t            if (i === 0) {\n\t                min[0] = min[1] = max[0] = max[1] = 0;\n\t            }\n\t\n\t            return new BoundingRect(\n\t                min[0], min[1], max[0] - min[0], max[1] - min[1]\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Rebuild path from current data\n\t         * Rebuild path will not consider javascript implemented line dash.\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         */\n\t        rebuildPath: function (ctx) {\n\t            var d = this.data;\n\t            var x0, y0;\n\t            var xi, yi;\n\t            var x, y;\n\t            var ux = this._ux;\n\t            var uy = this._uy;\n\t            var len = this._len;\n\t            for (var i = 0; i < len;) {\n\t                var cmd = d[i++];\n\t\n\t                if (i == 1) {\n\t                    // 如果第一个命令是 L, C, Q\n\t                    // 则 previous point 同绘制命令的第一个 point\n\t                    //\n\t                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                    xi = d[i];\n\t                    yi = d[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        x0 = xi = d[i++];\n\t                        y0 = yi = d[i++];\n\t                        ctx.moveTo(xi, yi);\n\t                        break;\n\t                    case CMD.L:\n\t                        x = d[i++];\n\t                        y = d[i++];\n\t                        // Not draw too small seg between\n\t                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t                            ctx.lineTo(x, y);\n\t                            xi = x;\n\t                            yi = y;\n\t                        }\n\t                        break;\n\t                    case CMD.C:\n\t                        ctx.bezierCurveTo(\n\t                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n\t                        );\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.Q:\n\t                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.A:\n\t                        var cx = d[i++];\n\t                        var cy = d[i++];\n\t                        var rx = d[i++];\n\t                        var ry = d[i++];\n\t                        var theta = d[i++];\n\t                        var dTheta = d[i++];\n\t                        var psi = d[i++];\n\t                        var fs = d[i++];\n\t                        var r = (rx > ry) ? rx : ry;\n\t                        var scaleX = (rx > ry) ? 1 : rx / ry;\n\t                        var scaleY = (rx > ry) ? ry / rx : 1;\n\t                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n\t                        var endAngle = theta + dTheta;\n\t                        if (isEllipse) {\n\t                            ctx.translate(cx, cy);\n\t                            ctx.rotate(psi);\n\t                            ctx.scale(scaleX, scaleY);\n\t                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t                            ctx.scale(1 / scaleX, 1 / scaleY);\n\t                            ctx.rotate(-psi);\n\t                            ctx.translate(-cx, -cy);\n\t                        }\n\t                        else {\n\t                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t                        }\n\t\n\t                        if (i == 1) {\n\t                            // 直接使用 arc 命令\n\t                            // 第一个命令起点还未定义\n\t                            x0 = mathCos(theta) * rx + cx;\n\t                            y0 = mathSin(theta) * ry + cy;\n\t                        }\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = d[i];\n\t                        y0 = yi = d[i + 1];\n\t                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t                        break;\n\t                    case CMD.Z:\n\t                        ctx.closePath();\n\t                        xi = x0;\n\t                        yi = y0;\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    PathProxy.CMD = CMD;\n\t\n\t    module.exports = PathProxy;\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 曲线辅助模块\n\t * @module zrender/core/curve\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(15);\n\t    var v2Create = vec2.create;\n\t    var v2DistSquare = vec2.distSquare;\n\t    var mathPow = Math.pow;\n\t    var mathSqrt = Math.sqrt;\n\t\n\t    var EPSILON = 1e-8;\n\t    var EPSILON_NUMERIC = 1e-4;\n\t\n\t    var THREE_SQRT = mathSqrt(3);\n\t    var ONE_THIRD = 1 / 3;\n\t\n\t    // 临时变量\n\t    var _v0 = v2Create();\n\t    var _v1 = v2Create();\n\t    var _v2 = v2Create();\n\t    // var _v3 = vec2.create();\n\t\n\t    function isAroundZero(val) {\n\t        return val > -EPSILON && val < EPSILON;\n\t    }\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * 计算三次贝塞尔值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return onet * onet * (onet * p0 + 3 * t * p1)\n\t             + t * t * (t * p3 + 3 * onet * p2);\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔导数值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return 3 * (\n\t            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n\t            + (p3 - p2) * t * t\n\t        );\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔方程根，使用盛金公式\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} val\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} 有效根数目\n\t     */\n\t    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t        // Evaluate roots of cubic functions\n\t        var a = p3 + 3 * (p1 - p2) - p0;\n\t        var b = 3 * (p2 - p1 * 2 + p0);\n\t        var c = 3 * (p1  - p0);\n\t        var d = p0 - val;\n\t\n\t        var A = b * b - 3 * a * c;\n\t        var B = b * c - 9 * a * d;\n\t        var C = c * c - 3 * b * d;\n\t\n\t        var n = 0;\n\t\n\t        if (isAroundZero(A) && isAroundZero(B)) {\n\t            if (isAroundZero(b)) {\n\t                roots[0] = 0;\n\t            }\n\t            else {\n\t                var t1 = -c / b;  //t1, t2, t3, b is not zero\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = B * B - 4 * A * C;\n\t\n\t            if (isAroundZero(disc)) {\n\t                var K = B / A;\n\t                var t1 = -b / a + K;  // t1, a is not zero\n\t                var t2 = -K / 2;  // t2, t3\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t                if (Y1 < 0) {\n\t                    Y1 = -mathPow(-Y1, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y1 = mathPow(Y1, ONE_THIRD);\n\t                }\n\t                if (Y2 < 0) {\n\t                    Y2 = -mathPow(-Y2, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y2 = mathPow(Y2, ONE_THIRD);\n\t                }\n\t                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else {\n\t                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t                var theta = Math.acos(T) / 3;\n\t                var ASqrt = mathSqrt(A);\n\t                var tmp = Math.cos(theta);\n\t\n\t                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t                if (t3 >= 0 && t3 <= 1) {\n\t                    roots[n++] = t3;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔方程极限值的位置\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {Array.<number>} extrema\n\t     * @return {number} 有效数目\n\t     */\n\t    function cubicExtrema(p0, p1, p2, p3, extrema) {\n\t        var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t        var c = 3 * p1 - 3 * p0;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <=1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                extrema[0] = -b / (2 * a);\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    extrema[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 细分三次贝塞尔曲线\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p23 = (p3 - p2) * t + p2;\n\t\n\t        var p012 = (p12 - p01) * t + p01;\n\t        var p123 = (p23 - p12) * t + p12;\n\t\n\t        var p0123 = (p123 - p012) * t + p012;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        out[3] = p0123;\n\t        // Seg1\n\t        out[4] = p0123;\n\t        out[5] = p123;\n\t        out[6] = p23;\n\t        out[7] = p3;\n\t    }\n\t\n\t    /**\n\t     * 投射点到三次贝塞尔曲线上，返回投射距离。\n\t     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} [out] 投射点\n\t     * @return {number}\n\t     */\n\t    function cubicProjectPoint(\n\t        x0, y0, x1, y1, x2, y2, x3, y3,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        var prev;\n\t        var next;\n\t        var d1;\n\t        var d2;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        // 先粗略估计一下可能的最小距离的 t 值\n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t            d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            prev = t - interval;\n\t            next = t + interval;\n\t            // t - interval\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t\n\t            d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t                d2 = v2DistSquare(_v2, _v0);\n\t\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = cubicAt(x0, x1, x2, x3, t);\n\t            out[1] = cubicAt(y0, y1, y2, y3, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔值\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticAt(p0, p1, p2, t) {\n\t        var onet = 1 - t;\n\t        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔导数值\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticDerivativeAt(p0, p1, p2, t) {\n\t        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔方程根\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} 有效根数目\n\t     */\n\t    function quadraticRootAt(p0, p1, p2, val, roots) {\n\t        var a = p0 - 2 * p1 + p2;\n\t        var b = 2 * (p1 - p0);\n\t        var c = p0 - val;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                var t1 = -b / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 计算二次贝塞尔方程极限值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @return {number}\n\t     */\n\t    function quadraticExtremum(p0, p1, p2) {\n\t        var divider = p0 + p2 - 2 * p1;\n\t        if (divider === 0) {\n\t            // p1 is center of p0 and p2\n\t            return 0.5;\n\t        }\n\t        else {\n\t            return (p0 - p1) / divider;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 细分二次贝塞尔曲线\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function quadraticSubdivide(p0, p1, p2, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p012 = (p12 - p01) * t + p01;\n\t\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t\n\t        // Seg1\n\t        out[3] = p012;\n\t        out[4] = p12;\n\t        out[5] = p2;\n\t    }\n\t\n\t    /**\n\t     * 投射点到二次贝塞尔曲线上，返回投射距离。\n\t     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} out 投射点\n\t     * @return {number}\n\t     */\n\t    function quadraticProjectPoint(\n\t        x0, y0, x1, y1, x2, y2,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        // 先粗略估计一下可能的最小距离的 t 值\n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t            _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t            var d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            var prev = t - interval;\n\t            var next = t + interval;\n\t            // t - interval\n\t            _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t\n\t            var d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = quadraticAt(x0, x1, x2, next);\n\t                _v2[1] = quadraticAt(y0, y1, y2, next);\n\t                var d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = quadraticAt(x0, x1, x2, t);\n\t            out[1] = quadraticAt(y0, y1, y2, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        cubicAt: cubicAt,\n\t\n\t        cubicDerivativeAt: cubicDerivativeAt,\n\t\n\t        cubicRootAt: cubicRootAt,\n\t\n\t        cubicExtrema: cubicExtrema,\n\t\n\t        cubicSubdivide: cubicSubdivide,\n\t\n\t        cubicProjectPoint: cubicProjectPoint,\n\t\n\t        quadraticAt: quadraticAt,\n\t\n\t        quadraticDerivativeAt: quadraticDerivativeAt,\n\t\n\t        quadraticRootAt: quadraticRootAt,\n\t\n\t        quadraticExtremum: quadraticExtremum,\n\t\n\t        quadraticSubdivide: quadraticSubdivide,\n\t\n\t        quadraticProjectPoint: quadraticProjectPoint\n\t    };\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author Yi Shen(https://github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(15);\n\t    var curve = __webpack_require__(31);\n\t\n\t    var bbox = {};\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t\n\t    var start = vec2.create();\n\t    var end = vec2.create();\n\t    var extremity = vec2.create();\n\t\n\t    var PI2 = Math.PI * 2;\n\t    /**\n\t     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n\t     * @module zrender/core/bbox\n\t     * @param {Array<Object>} points 顶点数组\n\t     * @param {number} min\n\t     * @param {number} max\n\t     */\n\t    bbox.fromPoints = function(points, min, max) {\n\t        if (points.length === 0) {\n\t            return;\n\t        }\n\t        var p = points[0];\n\t        var left = p[0];\n\t        var right = p[0];\n\t        var top = p[1];\n\t        var bottom = p[1];\n\t        var i;\n\t\n\t        for (i = 1; i < points.length; i++) {\n\t            p = points[i];\n\t            left = mathMin(left, p[0]);\n\t            right = mathMax(right, p[0]);\n\t            top = mathMin(top, p[1]);\n\t            bottom = mathMax(bottom, p[1]);\n\t        }\n\t\n\t        min[0] = left;\n\t        min[1] = top;\n\t        max[0] = right;\n\t        max[1] = bottom;\n\t    };\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n\t        min[0] = mathMin(x0, x1);\n\t        min[1] = mathMin(y0, y1);\n\t        max[0] = mathMax(x0, x1);\n\t        max[1] = mathMax(y0, y1);\n\t    };\n\t\n\t    var xDim = [];\n\t    var yDim = [];\n\t    /**\n\t     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromCubic = function(\n\t        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n\t    ) {\n\t        var cubicExtrema = curve.cubicExtrema;\n\t        var cubicAt = curve.cubicAt;\n\t        var i;\n\t        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t        min[0] = Infinity;\n\t        min[1] = Infinity;\n\t        max[0] = -Infinity;\n\t        max[1] = -Infinity;\n\t\n\t        for (i = 0; i < n; i++) {\n\t            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t            min[0] = mathMin(x, min[0]);\n\t            max[0] = mathMax(x, max[0]);\n\t        }\n\t        n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t        for (i = 0; i < n; i++) {\n\t            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t            min[1] = mathMin(y, min[1]);\n\t            max[1] = mathMax(y, max[1]);\n\t        }\n\t\n\t        min[0] = mathMin(x0, min[0]);\n\t        max[0] = mathMax(x0, max[0]);\n\t        min[0] = mathMin(x3, min[0]);\n\t        max[0] = mathMax(x3, max[0]);\n\t\n\t        min[1] = mathMin(y0, min[1]);\n\t        max[1] = mathMax(y0, max[1]);\n\t        min[1] = mathMin(y3, min[1]);\n\t        max[1] = mathMax(y3, max[1]);\n\t    };\n\t\n\t    /**\n\t     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n\t        var quadraticExtremum = curve.quadraticExtremum;\n\t        var quadraticAt = curve.quadraticAt;\n\t        // Find extremities, where derivative in x dim or y dim is zero\n\t        var tx =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n\t            );\n\t        var ty =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n\t            );\n\t\n\t        var x = quadraticAt(x0, x1, x2, tx);\n\t        var y = quadraticAt(y0, y1, y2, ty);\n\t\n\t        min[0] = mathMin(x0, x2, x);\n\t        min[1] = mathMin(y0, y2, y);\n\t        max[0] = mathMax(x0, x2, x);\n\t        max[1] = mathMax(y0, y2, y);\n\t    };\n\t\n\t    /**\n\t     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n\t     * @method\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {number} rx\n\t     * @param {number} ry\n\t     * @param {number} startAngle\n\t     * @param {number} endAngle\n\t     * @param {number} anticlockwise\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromArc = function (\n\t        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n\t    ) {\n\t        var vec2Min = vec2.min;\n\t        var vec2Max = vec2.max;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t\n\t\n\t        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n\t            // Is a circle\n\t            min[0] = x - rx;\n\t            min[1] = y - ry;\n\t            max[0] = x + rx;\n\t            max[1] = y + ry;\n\t            return;\n\t        }\n\t\n\t        start[0] = mathCos(startAngle) * rx + x;\n\t        start[1] = mathSin(startAngle) * ry + y;\n\t\n\t        end[0] = mathCos(endAngle) * rx + x;\n\t        end[1] = mathSin(endAngle) * ry + y;\n\t\n\t        vec2Min(min, start, end);\n\t        vec2Max(max, start, end);\n\t\n\t        // Thresh to [0, Math.PI * 2]\n\t        startAngle = startAngle % (PI2);\n\t        if (startAngle < 0) {\n\t            startAngle = startAngle + PI2;\n\t        }\n\t        endAngle = endAngle % (PI2);\n\t        if (endAngle < 0) {\n\t            endAngle = endAngle + PI2;\n\t        }\n\t\n\t        if (startAngle > endAngle && !anticlockwise) {\n\t            endAngle += PI2;\n\t        }\n\t        else if (startAngle < endAngle && anticlockwise) {\n\t            startAngle += PI2;\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = endAngle;\n\t            endAngle = startAngle;\n\t            startAngle = tmp;\n\t        }\n\t\n\t        // var number = 0;\n\t        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t            if (angle > startAngle) {\n\t                extremity[0] = mathCos(angle) * rx + x;\n\t                extremity[1] = mathSin(angle) * ry + y;\n\t\n\t                vec2Min(min, extremity, min);\n\t                vec2Max(max, extremity, max);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = bbox;\n\t\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var CMD = __webpack_require__(30).CMD;\n\t    var line = __webpack_require__(34);\n\t    var cubic = __webpack_require__(35);\n\t    var quadratic = __webpack_require__(36);\n\t    var arc = __webpack_require__(37);\n\t    var normalizeRadian = __webpack_require__(38).normalizeRadian;\n\t    var curve = __webpack_require__(31);\n\t\n\t    var windingLine = __webpack_require__(39);\n\t\n\t    var containStroke = line.containStroke;\n\t\n\t    var PI2 = Math.PI * 2;\n\t\n\t    var EPSILON = 1e-4;\n\t\n\t    function isAroundEqual(a, b) {\n\t        return Math.abs(a - b) < EPSILON;\n\t    }\n\t\n\t    // 临时数组\n\t    var roots = [-1, -1, -1];\n\t    var extrema = [-1, -1];\n\t\n\t    function swapExtrema() {\n\t        var tmp = extrema[0];\n\t        extrema[0] = extrema[1];\n\t        extrema[1] = tmp;\n\t    }\n\t\n\t    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2 && y > y3)\n\t            || (y < y0 && y < y1 && y < y2 && y < y3)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var w = 0;\n\t            var nExtrema = -1;\n\t            var y0_, y1_;\n\t            for (var i = 0; i < nRoots; i++) {\n\t                var t = roots[i];\n\t\n\t                // Avoid winding error when intersection point is the connect point of two line of polygon\n\t                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t                if (x_ < x) { // Quick reject\n\t                    continue;\n\t                }\n\t                if (nExtrema < 0) {\n\t                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t                        swapExtrema();\n\t                    }\n\t                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t                    if (nExtrema > 1) {\n\t                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t                    }\n\t                }\n\t                if (nExtrema == 2) {\n\t                    // 分成三段单调函数\n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else if (t < extrema[1]) {\n\t                        w += y1_ < y0_ ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y1_ ? unit : -unit;\n\t                    }\n\t                }\n\t                else {\n\t                    // 分成两段单调函数\n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y0_ ? unit : -unit;\n\t                    }\n\t                }\n\t            }\n\t            return w;\n\t        }\n\t    }\n\t\n\t    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2)\n\t            || (y < y0 && y < y1 && y < y2)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var t = curve.quadraticExtremum(y0, y1, y2);\n\t            if (t >= 0 && t <= 1) {\n\t                var w = 0;\n\t                var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t                for (var i = 0; i < nRoots; i++) {\n\t                    // Remove one endpoint.\n\t                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\t\n\t                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t                    if (x_ < x) {   // Quick reject\n\t                        continue;\n\t                    }\n\t                    if (roots[i] < t) {\n\t                        w += y_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y2 < y_ ? unit : -unit;\n\t                    }\n\t                }\n\t                return w;\n\t            }\n\t            else {\n\t                // Remove one endpoint.\n\t                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t                if (x_ < x) {   // Quick reject\n\t                    return 0;\n\t                }\n\t                return y2 < y0 ? unit : -unit;\n\t            }\n\t        }\n\t    }\n\t\n\t    // TODO\n\t    // Arc 旋转\n\t    function windingArc(\n\t        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n\t    ) {\n\t        y -= cy;\n\t        if (y > r || y < -r) {\n\t            return 0;\n\t        }\n\t        var tmp = Math.sqrt(r * r - y * y);\n\t        roots[0] = -tmp;\n\t        roots[1] = tmp;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff < 1e-4) {\n\t            return 0;\n\t        }\n\t        if (diff % PI2 < 1e-4) {\n\t            // Is a circle\n\t            startAngle = 0;\n\t            endAngle = PI2;\n\t            var dir = anticlockwise ? 1 : -1;\n\t            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t                return dir;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t\n\t        if (anticlockwise) {\n\t            var tmp = startAngle;\n\t            startAngle = normalizeRadian(endAngle);\n\t            endAngle = normalizeRadian(tmp);\n\t        }\n\t        else {\n\t            startAngle = normalizeRadian(startAngle);\n\t            endAngle = normalizeRadian(endAngle);\n\t        }\n\t        if (startAngle > endAngle) {\n\t            endAngle += PI2;\n\t        }\n\t\n\t        var w = 0;\n\t        for (var i = 0; i < 2; i++) {\n\t            var x_ = roots[i];\n\t            if (x_ + cx > x) {\n\t                var angle = Math.atan2(y, x_);\n\t                var dir = anticlockwise ? 1 : -1;\n\t                if (angle < 0) {\n\t                    angle = PI2 + angle;\n\t                }\n\t                if (\n\t                    (angle >= startAngle && angle <= endAngle)\n\t                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n\t                ) {\n\t                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t                        dir = -dir;\n\t                    }\n\t                    w += dir;\n\t                }\n\t            }\n\t        }\n\t        return w;\n\t    }\n\t\n\t    function containPath(data, lineWidth, isStroke, x, y) {\n\t        var w = 0;\n\t        var xi = 0;\n\t        var yi = 0;\n\t        var x0 = 0;\n\t        var y0 = 0;\n\t\n\t        for (var i = 0; i < data.length;) {\n\t            var cmd = data[i++];\n\t            // Begin a new subpath\n\t            if (cmd === CMD.M && i > 1) {\n\t                // Close previous subpath\n\t                if (!isStroke) {\n\t                    w += windingLine(xi, yi, x0, y0, x, y);\n\t                }\n\t                // 如果被任何一个 subpath 包含\n\t                // if (w !== 0) {\n\t                //     return true;\n\t                // }\n\t            }\n\t\n\t            if (i == 1) {\n\t                // 如果第一个命令是 L, C, Q\n\t                // 则 previous point 同绘制命令的第一个 point\n\t                //\n\t                // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                xi = data[i];\n\t                yi = data[i + 1];\n\t\n\t                x0 = xi;\n\t                y0 = yi;\n\t            }\n\t\n\t            switch (cmd) {\n\t                case CMD.M:\n\t                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t                    // 在 closePath 的时候使用\n\t                    x0 = data[i++];\n\t                    y0 = data[i++];\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t                case CMD.L:\n\t                    if (isStroke) {\n\t                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n\t                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.C:\n\t                    if (isStroke) {\n\t                        if (cubic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingCubic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.Q:\n\t                    if (isStroke) {\n\t                        if (quadratic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingQuadratic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.A:\n\t                    // TODO Arc 判断的开销比较大\n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var theta = data[i++];\n\t                    var dTheta = data[i++];\n\t                    // TODO Arc 旋转\n\t                    var psi = data[i++];\n\t                    var anticlockwise = 1 - data[i++];\n\t                    var x1 = Math.cos(theta) * rx + cx;\n\t                    var y1 = Math.sin(theta) * ry + cy;\n\t                    // 不是直接使用 arc 命令\n\t                    if (i > 1) {\n\t                        w += windingLine(xi, yi, x1, y1, x, y);\n\t                    }\n\t                    else {\n\t                        // 第一个命令起点还未定义\n\t                        x0 = x1;\n\t                        y0 = y1;\n\t                    }\n\t                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\t                    var _x = (x - cx) * ry / rx + cx;\n\t                    if (isStroke) {\n\t                        if (arc.containStroke(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            lineWidth, _x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingArc(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            _x, y\n\t                        );\n\t                    }\n\t                    xi = Math.cos(theta + dTheta) * rx + cx;\n\t                    yi = Math.sin(theta + dTheta) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = data[i++];\n\t                    y0 = yi = data[i++];\n\t                    var width = data[i++];\n\t                    var height = data[i++];\n\t                    var x1 = x0 + width;\n\t                    var y1 = y0 + height;\n\t                    if (isStroke) {\n\t                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n\t                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n\t                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n\t                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n\t                        ) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // FIXME Clockwise ?\n\t                        w += windingLine(x1, y0, x1, y1, x, y);\n\t                        w += windingLine(x0, y1, x0, y0, x, y);\n\t                    }\n\t                    break;\n\t                case CMD.Z:\n\t                    if (isStroke) {\n\t                        if (containStroke(\n\t                            xi, yi, x0, y0, lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // Close a subpath\n\t                        w += windingLine(xi, yi, x0, y0, x, y);\n\t                        // 如果被任何一个 subpath 包含\n\t                        // FIXME subpaths may overlap\n\t                        // if (w !== 0) {\n\t                        //     return true;\n\t                        // }\n\t                    }\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t            }\n\t        }\n\t        if (!isStroke && !isAroundEqual(yi, y0)) {\n\t            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t        }\n\t        return w !== 0;\n\t    }\n\t\n\t    module.exports = {\n\t        contain: function (pathData, x, y) {\n\t            return containPath(pathData, 0, false, x, y);\n\t        },\n\t\n\t        containStroke: function (pathData, lineWidth, x, y) {\n\t            return containPath(pathData, lineWidth, true, x, y);\n\t        }\n\t    };\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports) {\n\n\t\n\t    module.exports = {\n\t        /**\n\t         * 线段包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            var _a = 0;\n\t            var _b = x0;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l)\n\t                || (y < y0 - _l && y < y1 - _l)\n\t                || (x > x0 + _l && x > x1 + _l)\n\t                || (x < x0 - _l && x < x1 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t\n\t            if (x0 !== x1) {\n\t                _a = (y0 - y1) / (x0 - x1);\n\t                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n\t            }\n\t            else {\n\t                return Math.abs(x - x0) <= _l / 2;\n\t            }\n\t            var tmp = _a * x - y + _b;\n\t            var _s = tmp * tmp / (_a * _a + 1);\n\t            return _s <= _l / 2 * _l / 2;\n\t        }\n\t    };\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(31);\n\t\n\t    module.exports = {\n\t        /**\n\t         * 三次贝塞尔曲线描边包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  x3\n\t         * @param  {number}  y3\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.cubicProjectPoint(\n\t                x0, y0, x1, y1, x2, y2, x3, y3,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(31);\n\t\n\t    module.exports = {\n\t        /**\n\t         * 二次贝塞尔曲线描边包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.quadraticProjectPoint(\n\t                x0, y0, x1, y1, x2, y2,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var normalizeRadian = __webpack_require__(38).normalizeRadian;\n\t    var PI2 = Math.PI * 2;\n\t\n\t    module.exports = {\n\t        /**\n\t         * 圆弧描边包含判断\n\t         * @param  {number}  cx\n\t         * @param  {number}  cy\n\t         * @param  {number}  r\n\t         * @param  {number}  startAngle\n\t         * @param  {number}  endAngle\n\t         * @param  {boolean}  anticlockwise\n\t         * @param  {number} lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {Boolean}\n\t         */\n\t        containStroke: function (\n\t            cx, cy, r, startAngle, endAngle, anticlockwise,\n\t            lineWidth, x, y\n\t        ) {\n\t\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t\n\t            x -= cx;\n\t            y -= cy;\n\t            var d = Math.sqrt(x * x + y * y);\n\t\n\t            if ((d - _l > r) || (d + _l < r)) {\n\t                return false;\n\t            }\n\t            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n\t                // Is a circle\n\t                return true;\n\t            }\n\t            if (anticlockwise) {\n\t                var tmp = startAngle;\n\t                startAngle = normalizeRadian(endAngle);\n\t                endAngle = normalizeRadian(tmp);\n\t            } else {\n\t                startAngle = normalizeRadian(startAngle);\n\t                endAngle = normalizeRadian(endAngle);\n\t            }\n\t            if (startAngle > endAngle) {\n\t                endAngle += PI2;\n\t            }\n\t\n\t            var angle = Math.atan2(y, x);\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return (angle >= startAngle && angle <= endAngle)\n\t                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n\t        }\n\t    };\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports) {\n\n\t\n\t\n\t    var PI2 = Math.PI * 2;\n\t    module.exports = {\n\t        normalizeRadian: function(angle) {\n\t            angle %= PI2;\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle;\n\t        }\n\t    };\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports) {\n\n\t\n\t    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n\t        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n\t            return 0;\n\t        }\n\t        // Ignore horizontal line\n\t        if (y1 === y0) {\n\t            return 0;\n\t        }\n\t        var dir = y1 < y0 ? 1 : -1;\n\t        var t = (y - y0) / (y1 - y0);\n\t\n\t        // Avoid winding error when intersection point is the connect point of two line of polygon\n\t        if (t === 1 || t === 0) {\n\t            dir = y1 < y0 ? 0.5 : -0.5;\n\t        }\n\t\n\t        var x_ = t * (x1 - x0) + x0;\n\t\n\t        return x_ > x ? dir : 0;\n\t    };\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports) {\n\n\t\n\t\n\t    var Pattern = function (image, repeat) {\n\t        // Should do nothing more in this constructor. Because gradient can be\n\t        // declard by `color: {image: ...}`, where this constructor will not be called.\n\t\n\t        this.image = image;\n\t        this.repeat = repeat;\n\t\n\t        // Can be cloned\n\t        this.type = 'pattern';\n\t    };\n\t\n\t    Pattern.prototype.getCanvasPattern = function (ctx) {\n\t        return ctx.createPattern(this.image, this.repeat || 'repeat');\n\t    };\n\t\n\t    module.exports = Pattern;\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var CMD = __webpack_require__(30).CMD;\n\t    var vec2 = __webpack_require__(15);\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t\n\t    var points = [[], [], []];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAtan2 = Math.atan2;\n\t    function transformPath(path, m) {\n\t        var data = path.data;\n\t        var cmd;\n\t        var nPoint;\n\t        var i;\n\t        var j;\n\t        var k;\n\t        var p;\n\t\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var R = CMD.R;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t\n\t        for (i = 0, j = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            j = i;\n\t            nPoint = 0;\n\t\n\t            switch (cmd) {\n\t                case M:\n\t                    nPoint = 1;\n\t                    break;\n\t                case L:\n\t                    nPoint = 1;\n\t                    break;\n\t                case C:\n\t                    nPoint = 3;\n\t                    break;\n\t                case Q:\n\t                    nPoint = 2;\n\t                    break;\n\t                case A:\n\t                    var x = m[4];\n\t                    var y = m[5];\n\t                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n\t                    // cx\n\t                    data[i] *= sx;\n\t                    data[i++] += x;\n\t                    // cy\n\t                    data[i] *= sy;\n\t                    data[i++] += y;\n\t                    // Scale rx and ry\n\t                    // FIXME Assume psi is 0 here\n\t                    data[i++] *= sx;\n\t                    data[i++] *= sy;\n\t\n\t                    // Start angle\n\t                    data[i++] += angle;\n\t                    // end angle\n\t                    data[i++] += angle;\n\t                    // FIXME psi\n\t                    i += 2;\n\t                    j = i;\n\t                    break;\n\t                case R:\n\t                    // x0, y0\n\t                    p[0] = data[i++];\n\t                    p[1] = data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t                    // x1, y1\n\t                    p[0] += data[i++];\n\t                    p[1] += data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t            }\n\t\n\t            for (k = 0; k < nPoint; k++) {\n\t                var p = points[k];\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t\n\t                v2ApplyTransform(p, p, m);\n\t                // Write back\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = transformPath;\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports) {\n\n\t\n\t\n\t    /**\n\t     * @param {Array.<Object>} colorStops\n\t     */\n\t    var Gradient = function (colorStops) {\n\t\n\t        this.colorStops = colorStops || [];\n\t\n\t    };\n\t\n\t    Gradient.prototype = {\n\t\n\t        constructor: Gradient,\n\t\n\t        addColorStop: function (offset, color) {\n\t            this.colorStops.push({\n\t\n\t                offset: offset,\n\t\n\t                color: color\n\t            });\n\t        }\n\t\n\t    };\n\t\n\t    module.exports = Gradient;\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports) {\n\n\t// TODO Draggable for group\n\t// FIXME Draggable on element which has parent rotation or scale\n\t\n\t    function Draggable() {\n\t\n\t        this.on('mousedown', this._dragStart, this);\n\t        this.on('mousemove', this._drag, this);\n\t        this.on('mouseup', this._dragEnd, this);\n\t        this.on('globalout', this._dragEnd, this);\n\t        // this._dropTarget = null;\n\t        // this._draggingTarget = null;\n\t\n\t        // this._x = 0;\n\t        // this._y = 0;\n\t    }\n\t\n\t    Draggable.prototype = {\n\t\n\t        constructor: Draggable,\n\t\n\t        _dragStart: function (e) {\n\t            var draggingTarget = e.target;\n\t            if (draggingTarget && draggingTarget.draggable) {\n\t                this._draggingTarget = draggingTarget;\n\t                draggingTarget.dragging = true;\n\t                this._x = e.offsetX;\n\t                this._y = e.offsetY;\n\t\n\t                this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n\t            }\n\t        },\n\t\n\t        _drag: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t\n\t                var x = e.offsetX;\n\t                var y = e.offsetY;\n\t\n\t                var dx = x - this._x;\n\t                var dy = y - this._y;\n\t                this._x = x;\n\t                this._y = y;\n\t\n\t                draggingTarget.drift(dx, dy, e);\n\t                this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n\t\n\t                var dropTarget = this.findHover(x, y, draggingTarget).target;\n\t                var lastDropTarget = this._dropTarget;\n\t                this._dropTarget = dropTarget;\n\t\n\t                if (draggingTarget !== dropTarget) {\n\t                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n\t                    }\n\t                    if (dropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _dragEnd: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t\n\t            if (draggingTarget) {\n\t                draggingTarget.dragging = false;\n\t            }\n\t\n\t            this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\t\n\t            if (this._dropTarget) {\n\t                this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n\t            }\n\t\n\t            this._draggingTarget = null;\n\t            this._dropTarget = null;\n\t        }\n\t\n\t    };\n\t\n\t    function param(target, e) {\n\t        return {target: target, topTarget: e && e.topTarget};\n\t    }\n\t\n\t    module.exports = Draggable;\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n\t * @module zrender/graphic/Group\n\t * @example\n\t *     var Group = require('zrender/lib/container/Group');\n\t *     var Circle = require('zrender/lib/graphic/shape/Circle');\n\t *     var g = new Group();\n\t *     g.position[0] = 100;\n\t *     g.position[1] = 100;\n\t *     g.add(new Circle({\n\t *         style: {\n\t *             x: 100,\n\t *             y: 100,\n\t *             r: 20,\n\t *         }\n\t *     }));\n\t *     zr.add(g);\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(5);\n\t    var Element = __webpack_require__(10);\n\t    var BoundingRect = __webpack_require__(27);\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Group\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @extends module:zrender/mixin/Eventful\n\t     */\n\t    var Group = function (opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        for (var key in opts) {\n\t            if (opts.hasOwnProperty(key)) {\n\t                this[key] = opts[key];\n\t            }\n\t        }\n\t\n\t        this._children = [];\n\t\n\t        this.__storage = null;\n\t\n\t        this.__dirty = true;\n\t    };\n\t\n\t    Group.prototype = {\n\t\n\t        constructor: Group,\n\t\n\t        isGroup: true,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        type: 'group',\n\t\n\t        /**\n\t         * 所有子孙元素是否响应鼠标事件\n\t         * @name module:/zrender/container/Group#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/Element>}\n\t         */\n\t        children: function () {\n\t            return this._children.slice();\n\t        },\n\t\n\t        /**\n\t         * 获取指定 index 的儿子节点\n\t         * @param  {number} idx\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childAt: function (idx) {\n\t            return this._children[idx];\n\t        },\n\t\n\t        /**\n\t         * 获取指定名字的儿子节点\n\t         * @param  {string} name\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childOfName: function (name) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (children[i].name === name) {\n\t                    return children[i];\n\t                }\n\t             }\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        childCount: function () {\n\t            return this._children.length;\n\t        },\n\t\n\t        /**\n\t         * 添加子节点到最后\n\t         * @param {module:zrender/Element} child\n\t         */\n\t        add: function (child) {\n\t            if (child && child !== this && child.parent !== this) {\n\t\n\t                this._children.push(child);\n\t\n\t                this._doAdd(child);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 添加子节点在 nextSibling 之前\n\t         * @param {module:zrender/Element} child\n\t         * @param {module:zrender/Element} nextSibling\n\t         */\n\t        addBefore: function (child, nextSibling) {\n\t            if (child && child !== this && child.parent !== this\n\t                && nextSibling && nextSibling.parent === this) {\n\t\n\t                var children = this._children;\n\t                var idx = children.indexOf(nextSibling);\n\t\n\t                if (idx >= 0) {\n\t                    children.splice(idx, 0, child);\n\t                    this._doAdd(child);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        _doAdd: function (child) {\n\t            if (child.parent) {\n\t                child.parent.remove(child);\n\t            }\n\t\n\t            child.parent = this;\n\t\n\t            var storage = this.__storage;\n\t            var zr = this.__zr;\n\t            if (storage && storage !== child.__storage) {\n\t\n\t                storage.addToStorage(child);\n\t\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * 移除子节点\n\t         * @param {module:zrender/Element} child\n\t         */\n\t        remove: function (child) {\n\t            var zr = this.__zr;\n\t            var storage = this.__storage;\n\t            var children = this._children;\n\t\n\t            var idx = zrUtil.indexOf(children, child);\n\t            if (idx < 0) {\n\t                return this;\n\t            }\n\t            children.splice(idx, 1);\n\t\n\t            child.parent = null;\n\t\n\t            if (storage) {\n\t\n\t                storage.delFromStorage(child);\n\t\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 移除所有子节点\n\t         */\n\t        removeAll: function () {\n\t            var children = this._children;\n\t            var storage = this.__storage;\n\t            var child;\n\t            var i;\n\t            for (i = 0; i < children.length; i++) {\n\t                child = children[i];\n\t                if (storage) {\n\t                    storage.delFromStorage(child);\n\t                    if (child instanceof Group) {\n\t                        child.delChildrenFromStorage(storage);\n\t                    }\n\t                }\n\t                child.parent = null;\n\t            }\n\t            children.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 遍历所有子节点\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        eachChild: function (cb, context) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                cb.call(context, child, i);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 深度优先遍历所有子孙节点\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                cb.call(context, child);\n\t\n\t                if (child.type === 'group') {\n\t                    child.traverse(cb, context);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        addChildrenToStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.addToStorage(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        delChildrenFromStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.delFromStorage(child);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function (includeChildren) {\n\t            // TODO Caching\n\t            var rect = null;\n\t            var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t            var children = includeChildren || this._children;\n\t            var tmpMat = [];\n\t\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                if (child.ignore || child.invisible) {\n\t                    continue;\n\t                }\n\t\n\t                var childRect = child.getBoundingRect();\n\t                var transform = child.getLocalTransform(tmpMat);\n\t                // TODO\n\t                // The boundingRect cacluated by transforming original\n\t                // rect may be bigger than the actual bundingRect when rotation\n\t                // is used. (Consider a circle rotated aginst its center, where\n\t                // the actual boundingRect should be the same as that not be\n\t                // rotated.) But we can not find better approach to calculate\n\t                // actual boundingRect yet, considering performance.\n\t                if (transform) {\n\t                    tmpRect.copy(childRect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = rect || tmpRect.clone();\n\t                    rect.union(tmpRect);\n\t                }\n\t                else {\n\t                    rect = rect || childRect.clone();\n\t                    rect.union(childRect);\n\t                }\n\t            }\n\t            return rect || tmpRect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Group, Element);\n\t\n\t    module.exports = Group;\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Image element\n\t * @module zrender/graphic/Image\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(8);\n\t    var BoundingRect = __webpack_require__(27);\n\t    var zrUtil = __webpack_require__(5);\n\t    var imageHelper = __webpack_require__(28);\n\t\n\t    /**\n\t     * @alias zrender/graphic/Image\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function ZImage(opts) {\n\t        Displayable.call(this, opts);\n\t    }\n\t\n\t    ZImage.prototype = {\n\t\n\t        constructor: ZImage,\n\t\n\t        type: 'image',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var src = style.image;\n\t\n\t            // Must bind each time\n\t            style.bind(ctx, this, prevEl);\n\t\n\t            var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this);\n\t\n\t            if (!image || !imageHelper.isImageReady(image)) {\n\t                return;\n\t            }\n\t\n\t            // 图片已经加载完成\n\t            // if (image.nodeName.toUpperCase() == 'IMG') {\n\t            //     if (!image.complete) {\n\t            //         return;\n\t            //     }\n\t            // }\n\t            // Else is canvas\n\t\n\t            var x = style.x || 0;\n\t            var y = style.y || 0;\n\t            var width = style.width;\n\t            var height = style.height;\n\t            var aspect = image.width / image.height;\n\t            if (width == null && height != null) {\n\t                // Keep image/height ratio\n\t                width = height * aspect;\n\t            }\n\t            else if (height == null && width != null) {\n\t                height = width / aspect;\n\t            }\n\t            else if (width == null && height == null) {\n\t                width = image.width;\n\t                height = image.height;\n\t            }\n\t\n\t            // 设置transform\n\t            this.setTransform(ctx);\n\t\n\t            if (style.sWidth && style.sHeight) {\n\t                var sx = style.sx || 0;\n\t                var sy = style.sy || 0;\n\t                ctx.drawImage(\n\t                    image,\n\t                    sx, sy, style.sWidth, style.sHeight,\n\t                    x, y, width, height\n\t                );\n\t            }\n\t            else if (style.sx && style.sy) {\n\t                var sx = style.sx;\n\t                var sy = style.sy;\n\t                var sWidth = width - sx;\n\t                var sHeight = height - sy;\n\t                ctx.drawImage(\n\t                    image,\n\t                    sx, sy, sWidth, sHeight,\n\t                    x, y, width, height\n\t                );\n\t            }\n\t            else {\n\t                ctx.drawImage(image, x, y, width, height);\n\t            }\n\t\n\t            this.restoreTransform(ctx);\n\t\n\t            // Draw rect text\n\t            if (style.text != null) {\n\t                this.drawRectText(ctx, this.getBoundingRect());\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t            if (! this._rect) {\n\t                this._rect = new BoundingRect(\n\t                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n\t                );\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(ZImage, Displayable);\n\t\n\t    module.exports = ZImage;\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Text element\n\t * @module zrender/graphic/Text\n\t *\n\t * TODO Wrapping\n\t *\n\t * Text not support gradient\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(8);\n\t    var zrUtil = __webpack_require__(5);\n\t    var textContain = __webpack_require__(26);\n\t    var textHelper = __webpack_require__(25);\n\t\n\t    /**\n\t     * @alias zrender/graphic/Text\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    var Text = function (opts) {\n\t        Displayable.call(this, opts);\n\t    };\n\t\n\t    Text.prototype = {\n\t\n\t        constructor: Text,\n\t\n\t        type: 'text',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t\n\t            // Optimize, avoid normalize every time.\n\t            this.__dirty && textHelper.normalizeTextStyle(style, true);\n\t\n\t            // Use props with prefix 'text'.\n\t            style.fill = style.stroke = style.shadowBlur = style.shadowColor =\n\t                style.shadowOffsetX = style.shadowOffsetY = null;\n\t\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t\n\t            // Always bind style\n\t            style.bind(ctx, this, prevEl);\n\t\n\t            if (!textHelper.needDrawText(text, style)) {\n\t                return;\n\t            }\n\t\n\t            this.setTransform(ctx);\n\t\n\t            textHelper.renderText(this, ctx, text, style);\n\t\n\t            this.restoreTransform(ctx);\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t\n\t            // Optimize, avoid normalize every time.\n\t            this.__dirty && textHelper.normalizeTextStyle(style, true);\n\t\n\t            if (!this._rect) {\n\t                var text = style.text;\n\t                text != null ? (text += '') : (text = '');\n\t\n\t                var rect = textContain.getBoundingRect(\n\t                    style.text + '',\n\t                    style.font,\n\t                    style.textAlign,\n\t                    style.textVerticalAlign,\n\t                    style.textPadding,\n\t                    style.rich\n\t                );\n\t\n\t                rect.x += style.x || 0;\n\t                rect.y += style.y || 0;\n\t\n\t                if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {\n\t                    var w = style.textStrokeWidth;\n\t                    rect.x -= w / 2;\n\t                    rect.y -= w / 2;\n\t                    rect.width += w;\n\t                    rect.height += w;\n\t                }\n\t\n\t                this._rect = rect;\n\t            }\n\t\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Text, Displayable);\n\t\n\t    module.exports = Text;\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 圆形\n\t * @module zrender/shape/Circle\n\t */\n\t\n\t\n\t\n\t    module.exports = __webpack_require__(7).extend({\n\t\n\t        type: 'circle',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0\n\t        },\n\t\n\t\n\t        buildPath : function (ctx, shape, inBundle) {\n\t            // Better stroking in ShapeBundle\n\t            // Always do it may have performence issue ( fill may be 2x more cost)\n\t            if (inBundle) {\n\t                ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            }\n\t            // else {\n\t            //     if (ctx.allocate && !ctx.data.length) {\n\t            //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n\t            //     }\n\t            // }\n\t            // Better stroking in ShapeBundle\n\t            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 扇形\n\t * @module zrender/graphic/shape/Sector\n\t */\n\t\n\t\n\t\n\t    var Path = __webpack_require__(7);\n\t    var fixClipWithShadow = __webpack_require__(49);\n\t\n\t    module.exports = Path.extend({\n\t\n\t        type: 'sector',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r0: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        brush: fixClipWithShadow(Path.prototype.brush),\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r0 = Math.max(shape.r0 || 0, 0);\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t\n\t            ctx.lineTo(unitX * r + x, unitY * r + y);\n\t\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t\n\t            ctx.lineTo(\n\t                Math.cos(endAngle) * r0 + x,\n\t                Math.sin(endAngle) * r0 + y\n\t            );\n\t\n\t            if (r0 !== 0) {\n\t                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t            }\n\t\n\t            ctx.closePath();\n\t        }\n\t    });\n\t\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var env = __webpack_require__(50);\n\t\n\t    // Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n\t    // where exception \"unexpected call to method or property access\"\n\t    // might be thrown when calling ctx.fill or ctx.stroke after a path\n\t    // whose area size is zero is drawn and ctx.clip() is called and\n\t    // shadowBlur is set. See #4572, #3112, #5777.\n\t    // (e.g.,\n\t    //  ctx.moveTo(10, 10);\n\t    //  ctx.lineTo(20, 10);\n\t    //  ctx.closePath();\n\t    //  ctx.clip();\n\t    //  ctx.shadowBlur = 10;\n\t    //  ...\n\t    //  ctx.fill();\n\t    // )\n\t\n\t    var shadowTemp = [\n\t        ['shadowBlur', 0],\n\t        ['shadowColor', '#000'],\n\t        ['shadowOffsetX', 0],\n\t        ['shadowOffsetY', 0]\n\t    ];\n\t\n\t    module.exports = function (orignalBrush) {\n\t\n\t        // version string can be: '11.0'\n\t        return (env.browser.ie && env.browser.version >= 11)\n\t\n\t            ? function () {\n\t                var clipPaths = this.__clipPaths;\n\t                var style = this.style;\n\t                var modified;\n\t\n\t                if (clipPaths) {\n\t                    for (var i = 0; i < clipPaths.length; i++) {\n\t                        var clipPath = clipPaths[i];\n\t                        var shape = clipPath && clipPath.shape;\n\t                        var type = clipPath && clipPath.type;\n\t\n\t                        if (shape && (\n\t                            (type === 'sector' && shape.startAngle === shape.endAngle)\n\t                            || (type === 'rect' && (!shape.width || !shape.height))\n\t                        )) {\n\t                            for (var j = 0; j < shadowTemp.length; j++) {\n\t                                // It is save to put shadowTemp static, because shadowTemp\n\t                                // will be all modified each item brush called.\n\t                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n\t                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n\t                            }\n\t                            modified = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t\n\t                orignalBrush.apply(this, arguments);\n\t\n\t                if (modified) {\n\t                    for (var j = 0; j < shadowTemp.length; j++) {\n\t                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n\t                    }\n\t                }\n\t            }\n\t\n\t            : orignalBrush;\n\t    };\n\t\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * echarts设备环境识别\n\t *\n\t * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n\t * @author firede[firede@firede.us]\n\t * @desc thanks zepto.\n\t */\n\t\n\t    var env = {};\n\t    if (typeof navigator === 'undefined') {\n\t        // In node\n\t        env = {\n\t            browser: {},\n\t            os: {},\n\t            node: true,\n\t            // Assume canvas is supported\n\t            canvasSupported: true\n\t        };\n\t    }\n\t    else {\n\t        env = detect(navigator.userAgent);\n\t    }\n\t\n\t    module.exports = env;\n\t\n\t    // Zepto.js\n\t    // (c) 2010-2013 Thomas Fuchs\n\t    // Zepto.js may be freely distributed under the MIT license.\n\t\n\t    function detect(ua) {\n\t        var os = {};\n\t        var browser = {};\n\t        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t        // var touchpad = webos && ua.match(/TouchPad/);\n\t        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t        // var playbook = ua.match(/PlayBook/);\n\t        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n\t        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n\t            // IE 11 Trident/7.0; rv:11.0\n\t            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\t\n\t        var weChat = (/micromessenger/i).test(ua);\n\t\n\t        // Todo: clean this up with a better OS/browser seperation:\n\t        // - discern (more) between multiple browsers on android\n\t        // - decide if kindle fire in silk mode is android or not\n\t        // - Firefox on Android doesn't specify the Android version\n\t        // - possibly devide in os, device and browser hashes\n\t\n\t        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t\n\t        // if (android) os.android = true, os.version = android[2];\n\t        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t        // if (webos) os.webos = true, os.version = webos[2];\n\t        // if (touchpad) os.touchpad = true;\n\t        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t        // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t        // if (playbook) browser.playbook = true;\n\t        // if (kindle) os.kindle = true, os.version = kindle[1];\n\t        // if (silk) browser.silk = true, browser.version = silk[1];\n\t        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t        if (firefox) {\n\t            browser.firefox = true;\n\t            browser.version = firefox[1];\n\t        }\n\t        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t        // if (webview) browser.webview = true;\n\t\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t\n\t        if (edge) {\n\t            browser.edge = true;\n\t            browser.version = edge[1];\n\t        }\n\t\n\t        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n\t        // not be set on win phone. So we do not consider Win Phone.\n\t        if (weChat) {\n\t            browser.weChat = true;\n\t        }\n\t\n\t        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t\n\t        return {\n\t            browser: browser,\n\t            os: os,\n\t            node: false,\n\t            // 原生canvas支持，改极端点了\n\t            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n\t            canvasSupported : document.createElement('canvas').getContext ? true : false,\n\t            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n\t            // works on most browsers\n\t            // IE10/11 does not support touch event, and MS Edge supports them but not by\n\t            // default, so we dont check navigator.maxTouchPoints for them here.\n\t            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t            // <http://caniuse.com/#search=pointer%20event>.\n\t            pointerEventsSupported: 'onpointerdown' in window\n\t                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n\t                // events currently. So we dont use that on other browsers unless tested sufficiently.\n\t                // Although IE 10 supports pointer event, it use old style and is different from the\n\t                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n\t                && (browser.edge || (browser.ie && browser.version >= 11))\n\t        };\n\t    }\n\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 圆环\n\t * @module zrender/graphic/shape/Ring\n\t */\n\t\n\t\n\t    module.exports = __webpack_require__(7).extend({\n\t\n\t        type: 'ring',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            r0: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var PI2 = Math.PI * 2;\n\t            ctx.moveTo(x + shape.r, y);\n\t            ctx.arc(x, y, shape.r, 0, PI2, false);\n\t            ctx.moveTo(x + shape.r0, y);\n\t            ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 多边形\n\t * @module zrender/shape/Polygon\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(53);\n\t\n\t    module.exports = __webpack_require__(7).extend({\n\t        \n\t        type: 'polygon',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, true);\n\t        }\n\t    });\n\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var smoothSpline = __webpack_require__(54);\n\t    var smoothBezier = __webpack_require__(55);\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape, closePath) {\n\t            var points = shape.points;\n\t            var smooth = shape.smooth;\n\t            if (points && points.length >= 2) {\n\t                if (smooth && smooth !== 'spline') {\n\t                    var controlPoints = smoothBezier(\n\t                        points, smooth, closePath, shape.smoothConstraint\n\t                    );\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    var len = points.length;\n\t                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t                        var cp1 = controlPoints[i * 2];\n\t                        var cp2 = controlPoints[i * 2 + 1];\n\t                        var p = points[(i + 1) % len];\n\t                        ctx.bezierCurveTo(\n\t                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n\t                        );\n\t                    }\n\t                }\n\t                else {\n\t                    if (smooth === 'spline') {\n\t                        points = smoothSpline(points, closePath);\n\t                    }\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    for (var i = 1, l = points.length; i < l; i++) {\n\t                        ctx.lineTo(points[i][0], points[i][1]);\n\t                    }\n\t                }\n\t\n\t                closePath && ctx.closePath();\n\t            }\n\t        }\n\t    };\n\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Catmull-Rom spline 插值折线\n\t * @module zrender/shape/util/smoothSpline\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t    var vec2 = __webpack_require__(15);\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/shape/util/smoothSpline\n\t     * @param {Array} points 线段顶点数组\n\t     * @param {boolean} isLoop\n\t     * @return {Array}\n\t     */\n\t    module.exports = function (points, isLoop) {\n\t        var len = points.length;\n\t        var ret = [];\n\t\n\t        var distance = 0;\n\t        for (var i = 1; i < len; i++) {\n\t            distance += vec2.distance(points[i - 1], points[i]);\n\t        }\n\t\n\t        var segs = distance / 2;\n\t        segs = segs < len ? len : segs;\n\t        for (var i = 0; i < segs; i++) {\n\t            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t            var idx = Math.floor(pos);\n\t\n\t            var w = pos - idx;\n\t\n\t            var p0;\n\t            var p1 = points[idx % len];\n\t            var p2;\n\t            var p3;\n\t            if (!isLoop) {\n\t                p0 = points[idx === 0 ? idx : idx - 1];\n\t                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t            }\n\t            else {\n\t                p0 = points[(idx - 1 + len) % len];\n\t                p2 = points[(idx + 1) % len];\n\t                p3 = points[(idx + 2) % len];\n\t            }\n\t\n\t            var w2 = w * w;\n\t            var w3 = w * w2;\n\t\n\t            ret.push([\n\t                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n\t                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n\t            ]);\n\t        }\n\t        return ret;\n\t    };\n\t\n\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 贝塞尔平滑曲线\n\t * @module zrender/shape/util/smoothBezier\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(15);\n\t    var v2Min = vec2.min;\n\t    var v2Max = vec2.max;\n\t    var v2Scale = vec2.scale;\n\t    var v2Distance = vec2.distance;\n\t    var v2Add = vec2.add;\n\t\n\t    /**\n\t     * 贝塞尔平滑曲线\n\t     * @alias module:zrender/shape/util/smoothBezier\n\t     * @param {Array} points 线段顶点数组\n\t     * @param {number} smooth 平滑等级, 0-1\n\t     * @param {boolean} isLoop\n\t     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n\t     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n\t     *                           整个折线的包围盒做一个并集用来约束控制点。\n\t     * @param {Array} 计算出来的控制点数组\n\t     */\n\t    module.exports = function (points, smooth, isLoop, constraint) {\n\t        var cps = [];\n\t\n\t        var v = [];\n\t        var v1 = [];\n\t        var v2 = [];\n\t        var prevPoint;\n\t        var nextPoint;\n\t\n\t        var min, max;\n\t        if (constraint) {\n\t            min = [Infinity, Infinity];\n\t            max = [-Infinity, -Infinity];\n\t            for (var i = 0, len = points.length; i < len; i++) {\n\t                v2Min(min, min, points[i]);\n\t                v2Max(max, max, points[i]);\n\t            }\n\t            // 与指定的包围盒做并集\n\t            v2Min(min, min, constraint[0]);\n\t            v2Max(max, max, constraint[1]);\n\t        }\n\t\n\t        for (var i = 0, len = points.length; i < len; i++) {\n\t            var point = points[i];\n\t\n\t            if (isLoop) {\n\t                prevPoint = points[i ? i - 1 : len - 1];\n\t                nextPoint = points[(i + 1) % len];\n\t            }\n\t            else {\n\t                if (i === 0 || i === len - 1) {\n\t                    cps.push(vec2.clone(points[i]));\n\t                    continue;\n\t                }\n\t                else {\n\t                    prevPoint = points[i - 1];\n\t                    nextPoint = points[i + 1];\n\t                }\n\t            }\n\t\n\t            vec2.sub(v, nextPoint, prevPoint);\n\t\n\t            // use degree to scale the handle length\n\t            v2Scale(v, v, smooth);\n\t\n\t            var d0 = v2Distance(point, prevPoint);\n\t            var d1 = v2Distance(point, nextPoint);\n\t            var sum = d0 + d1;\n\t            if (sum !== 0) {\n\t                d0 /= sum;\n\t                d1 /= sum;\n\t            }\n\t\n\t            v2Scale(v1, v, -d0);\n\t            v2Scale(v2, v, d1);\n\t            var cp0 = v2Add([], point, v1);\n\t            var cp1 = v2Add([], point, v2);\n\t            if (constraint) {\n\t                v2Max(cp0, cp0, min);\n\t                v2Min(cp0, cp0, max);\n\t                v2Max(cp1, cp1, min);\n\t                v2Min(cp1, cp1, max);\n\t            }\n\t            cps.push(cp0);\n\t            cps.push(cp1);\n\t        }\n\t\n\t        if (isLoop) {\n\t            cps.push(cps.shift());\n\t        }\n\t\n\t        return cps;\n\t    };\n\t\n\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/graphic/shape/Polyline\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(53);\n\t\n\t    module.exports = __webpack_require__(7).extend({\n\t        \n\t        type: 'polyline',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, false);\n\t        }\n\t    });\n\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 矩形\n\t * @module zrender/graphic/shape/Rect\n\t */\n\t\n\t\n\t    var roundRectHelper = __webpack_require__(29);\n\t\n\t    module.exports = __webpack_require__(7).extend({\n\t\n\t        type: 'rect',\n\t\n\t        shape: {\n\t            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n\t            // r缩写为1         相当于 [1, 1, 1, 1]\n\t            // r缩写为[1]       相当于 [1, 1, 1, 1]\n\t            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n\t            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n\t            r: 0,\n\t\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            if (!shape.r) {\n\t                ctx.rect(x, y, width, height);\n\t            }\n\t            else {\n\t                roundRectHelper.buildPath(ctx, shape);\n\t            }\n\t            ctx.closePath();\n\t            return;\n\t        }\n\t    });\n\t\n\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 直线\n\t * @module zrender/graphic/shape/Line\n\t */\n\t\n\t    module.exports = __webpack_require__(7).extend({\n\t\n\t        type: 'line',\n\t\n\t        shape: {\n\t            // Start point\n\t            x1: 0,\n\t            y1: 0,\n\t            // End point\n\t            x2: 0,\n\t            y2: 0,\n\t\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var percent = shape.percent;\n\t\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (percent < 1) {\n\t                x2 = x1 * (1 - percent) + x2 * percent;\n\t                y2 = y1 * (1 - percent) + y2 * percent;\n\t            }\n\t            ctx.lineTo(x2, y2);\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} percent\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (p) {\n\t            var shape = this.shape;\n\t            return [\n\t                shape.x1 * (1 - p) + shape.x2 * p,\n\t                shape.y1 * (1 - p) + shape.y2 * p\n\t            ];\n\t        }\n\t    });\n\t\n\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 贝塞尔曲线\n\t * @module zrender/shape/BezierCurve\n\t */\n\t\n\t\n\t    var curveTool = __webpack_require__(31);\n\t    var vec2 = __webpack_require__(15);\n\t    var quadraticSubdivide = curveTool.quadraticSubdivide;\n\t    var cubicSubdivide = curveTool.cubicSubdivide;\n\t    var quadraticAt = curveTool.quadraticAt;\n\t    var cubicAt = curveTool.cubicAt;\n\t    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n\t    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\t\n\t    var out = [];\n\t\n\t    function someVectorAt(shape, t, isTangent) {\n\t        var cpx2 = shape.cpx2;\n\t        var cpy2 = shape.cpy2;\n\t        if (cpx2 === null || cpy2 === null) {\n\t            return [\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n\t            ];\n\t        }\n\t        else {\n\t            return [\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n\t            ];\n\t        }\n\t    }\n\t    module.exports = __webpack_require__(7).extend({\n\t\n\t        type: 'bezier-curve',\n\t\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            cpx1: 0,\n\t            cpy1: 0,\n\t            // cpx2: 0,\n\t            // cpy2: 0\n\t\n\t            // Curve show percent, for animating\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var cpx1 = shape.cpx1;\n\t            var cpy1 = shape.cpy1;\n\t            var cpx2 = shape.cpx2;\n\t            var cpy2 = shape.cpy2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (cpx2 == null || cpy2 == null) {\n\t                if (percent < 1) {\n\t                    quadraticSubdivide(\n\t                        x1, cpx1, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    x2 = out[2];\n\t                    quadraticSubdivide(\n\t                        y1, cpy1, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    y2 = out[2];\n\t                }\n\t\n\t                ctx.quadraticCurveTo(\n\t                    cpx1, cpy1,\n\t                    x2, y2\n\t                );\n\t            }\n\t            else {\n\t                if (percent < 1) {\n\t                    cubicSubdivide(\n\t                        x1, cpx1, cpx2, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    cpx2 = out[2];\n\t                    x2 = out[3];\n\t                    cubicSubdivide(\n\t                        y1, cpy1, cpy2, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    cpy2 = out[2];\n\t                    y2 = out[3];\n\t                }\n\t                ctx.bezierCurveTo(\n\t                    cpx1, cpy1,\n\t                    cpx2, cpy2,\n\t                    x2, y2\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (t) {\n\t            return someVectorAt(this.shape, t, false);\n\t        },\n\t\n\t        /**\n\t         * Get tangent at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        tangentAt: function (t) {\n\t            var p = someVectorAt(this.shape, t, true);\n\t            return vec2.normalize(p, p);\n\t        }\n\t    });\n\t\n\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 圆弧\n\t * @module zrender/graphic/shape/Arc\n\t */\n\t \n\t\n\t    module.exports = __webpack_require__(7).extend({\n\t\n\t        type: 'arc',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        style: {\n\t\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t        }\n\t    });\n\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(5);\n\t\n\t    var Gradient = __webpack_require__(42);\n\t\n\t    /**\n\t     * x, y, x2, y2 are all percent from 0 to 1\n\t     * @param {number} [x=0]\n\t     * @param {number} [y=0]\n\t     * @param {number} [x2=1]\n\t     * @param {number} [y2=0]\n\t     * @param {Array.<Object>} colorStops\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t        // Should do nothing more in this constructor. Because gradient can be\n\t        // declard by `color: {type: 'linear', colorStops: ...}`, where\n\t        // this constructor will not be called.\n\t\n\t        this.x = x == null ? 0 : x;\n\t\n\t        this.y = y == null ? 0 : y;\n\t\n\t        this.x2 = x2 == null ? 1 : x2;\n\t\n\t        this.y2 = y2 == null ? 0 : y2;\n\t\n\t        // Can be cloned\n\t        this.type = 'linear';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    LinearGradient.prototype = {\n\t\n\t        constructor: LinearGradient\n\t    };\n\t\n\t    zrUtil.inherits(LinearGradient, Gradient);\n\t\n\t    module.exports = LinearGradient;\n\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(5);\n\t\n\t    var Gradient = __webpack_require__(42);\n\t\n\t    /**\n\t     * x, y, r are all percent from 0 to 1\n\t     * @param {number} [x=0.5]\n\t     * @param {number} [y=0.5]\n\t     * @param {number} [r=0.5]\n\t     * @param {Array.<Object>} [colorStops]\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t        // Should do nothing more in this constructor. Because gradient can be\n\t        // declard by `color: {type: 'radial', colorStops: ...}`, where\n\t        // this constructor will not be called.\n\t\n\t        this.x = x == null ? 0.5 : x;\n\t\n\t        this.y = y == null ? 0.5 : y;\n\t\n\t        this.r = r == null ? 0.5 : r;\n\t\n\t        // Can be cloned\n\t        this.type = 'radial';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    RadialGradient.prototype = {\n\t\n\t        constructor: RadialGradient\n\t    };\n\t\n\t    zrUtil.inherits(RadialGradient, Gradient);\n\t\n\t    module.exports = RadialGradient;\n\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * States machine for managing graphic states\n\t */\n\t\n\t\n\t\n\t    /**\n\t     * @typedef {Object} IGraphicState\n\t     * @property {number} [zlevel]\n\t     * @property {number} [z]\n\t     * @property {Array.<number>} {position}\n\t     * @property {Array.<number>|number} {rotation}\n\t     * @property {Array.<number>} {scale}\n\t     * @property {Object} style\n\t     *\n\t     * @property {Function} onenter\n\t     * @property {Function} onleave\n\t     * @property {Function} ontransition\n\t     * @property {Array.<IGraphicStateTransition|string>} transition\n\t     *           Transition object or a string descriptor like '* 30 0 Linear'\n\t     */\n\t\n\t    var zrUtil = __webpack_require__(5);\n\t    var Style = __webpack_require__(9);\n\t    var vec2Copy = __webpack_require__(15).copy;\n\t\n\t    var transitionProperties = ['position', 'rotation', 'scale', 'style', 'shape'];\n\t    /**\n\t     * @module zrender/graphic/States~TransitionObject\n\t     */\n\t    var TransitionObject = function (opts) {\n\t        if (typeof opts == 'string') {\n\t            this._fromStr(opts);\n\t        }\n\t        else if (opts) {\n\t            opts.property && (this.property = opts.property);\n\t            opts.duration != null && (this.duration = opts.duration);\n\t            opts.easing && (this.easing = opts.easing);\n\t            opts.delay && (this.delay = opts.delay);\n\t        }\n\t        if (this.property !== '*') {\n\t            this.property = this.property.split(',');\n\t        }\n\t        else {\n\t            this.property = transitionProperties;\n\t        }\n\t    };\n\t\n\t    TransitionObject.prototype = {\n\t\n\t        constructor: TransitionObject,\n\t\n\t        /**\n\t         * List of all transition properties. Splitted by comma. Must not have spaces in the string.\n\t         * e.g. 'position,style.color'. '*' will match all the valid properties.\n\t         * @type {string}\n\t         * @default *\n\t         */\n\t        property: '*',\n\t\n\t        /**\n\t         * @type {string}\n\t         * @default 'Linear'\n\t         */\n\t        easing: 'Linear',\n\t\n\t        /**\n\t         * @type {number}\n\t         * @default 'number'\n\t         */\n\t        duration: 500,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        delay: 0,\n\t\n\t        _fromStr: function (str) {\n\t            var arr = str.split(/\\s+/g);\n\t            this.property = arr[0];\n\t            this.duration = +arr[1];\n\t            this.delay = +arr[2];\n\t            this.easing = arr[3];\n\t        }\n\t    };\n\t\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/States\n\t     */\n\t    var GraphicStates = function (opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        this._states = {};\n\t\n\t        /**\n\t         * Target element\n\t         * @type {zrender/graphic/Displayable|zrender/container/Group}\n\t         */\n\t        this._el = opts.el;\n\t\n\t        this._subStates = [];\n\t\n\t        this._transitionAnimators = [];\n\t\n\t        if (opts.initialState) {\n\t            this._initialState = opts.initialState;\n\t        }\n\t\n\t        var optsStates = opts.states;\n\t        if (optsStates) {\n\t            for (var name in optsStates) {\n\t                if (optsStates.hasOwnProperty(name)) {\n\t                    var state = optsStates[name];\n\t                    this._addState(name, state);\n\t                }\n\t            }\n\t        }\n\t\n\t        this.setState(this._initialState);\n\t    };\n\t\n\t    GraphicStates.prototype = {\n\t\n\t        constructor: GraphicStates,\n\t\n\t        /**\n\t         * All other state will be extended from initial state\n\t         * @type {string}\n\t         * @private\n\t         */\n\t        _initialState: 'normal',\n\t\n\t        /**\n\t         * Current state\n\t         * @type {string}\n\t         * @private\n\t         */\n\t        _currentState: '',\n\t\n\t        el: function () {\n\t            return this._el;\n\t        },\n\t\n\t        _addState: function (name, state) {\n\t            this._states[name] = state;\n\t\n\t            if (state.transition) {\n\t                state.transition = new TransitionObject(state.transition);\n\t            }\n\t\n\t            // Extend from initial state\n\t            if (name !== this._initialState) {\n\t                this._extendFromInitial(state);\n\t            }\n\t            else {\n\t                var el = this._el;\n\t                // setState 的时候自带的 style 和 shape 都会被直接覆盖\n\t                // 所以这边先把自带的 style 和 shape 扩展到初始状态中\n\t                zrUtil.merge(state.style, el.style, false, false);\n\t                if (state.shape) {\n\t                    zrUtil.merge(state.shape, el.shape, false, true);\n\t                }\n\t                else {\n\t                    state.shape = zrUtil.clone(el.shape, true);\n\t                }\n\t\n\t                for (var name in this._states) {\n\t                    if (this._states.hasOwnProperty(name)) {\n\t                        this._extendFromInitial(this._states[name]);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _extendFromInitial: function (state) {\n\t            var initialState = this._states[this._initialState];\n\t            if (initialState && state !== initialState) {\n\t                zrUtil.merge(state, initialState, false, true);\n\t            }\n\t        },\n\t\n\t        setState: function (name, silent) {\n\t            if (name === this._currentState\n\t                && ! this.transiting()\n\t            ) {\n\t                return;\n\t            }\n\t\n\t            var state = this._states[name];\n\t\n\t            if (state) {\n\t                this._stopTransition();\n\t\n\t                if (! silent) {\n\t                    var prevState = this._states[this._currentState];\n\t                    if (prevState) {\n\t                        prevState.onleave && prevState.onleave.call(this);\n\t                    }\n\t\n\t                    state.onenter && state.onenter.call(this);\n\t                }\n\t\n\t                this._currentState = name;\n\t\n\t                if (this._el) {\n\t                    var el = this._el;\n\t\n\t                    // Setting attributes\n\t                    if (state.zlevel != null) {\n\t                        el.zlevel = state.zlevel;\n\t                    }\n\t                    if (state.z != null) {\n\t                        el.z = state.z;\n\t                    }\n\t\n\t                    // SRT\n\t                    state.position && vec2Copy(el.position, state.position);\n\t                    state.scale && vec2Copy(el.scale, state.scale);\n\t                    if (state.rotation != null) {\n\t                        el.rotation = state.rotation;\n\t                    }\n\t\n\t                    // Style\n\t                    if (state.style) {\n\t                        var initialState = this._states[this._initialState];\n\t                        el.style = new Style();\n\t                        if (initialState) {\n\t                            el.style.extendFrom(initialState.style, false);\n\t                        }\n\t                        if (\n\t                            // Not initial state\n\t                            name != this._initialState\n\t                            // Not copied from initial state in _extendFromInitial method\n\t                            && initialState.style !== state.style\n\t                        ) {\n\t                            el.style.extendFrom(state.style, true);\n\t                        }\n\t                    }\n\t                    if (state.shape) {\n\t                        el.shape = zrUtil.clone(state.shape, true);\n\t                    }\n\t\n\t                    el.dirty();\n\t                }\n\t            }\n\t\n\t            for (var i = 0; i < this._subStates.length; i++) {\n\t                this._subStates.setState(name);\n\t            }\n\t        },\n\t\n\t        getState: function () {\n\t            return this._currentState;\n\t        },\n\t\n\t        transitionState: function (target, done) {\n\t            if (\n\t                target === this._currentState\n\t                && ! this.transiting()\n\t            ) {\n\t                return;\n\t            }\n\t\n\t            var state = this._states[target];\n\t            var styleShapeReg = /$[style|shape]\\./;\n\t            var self = this;\n\t\n\t            // Animation 去重\n\t            var propPathMap = {};\n\t\n\t            if (state) {\n\t\n\t                self._stopTransition();\n\t\n\t                var el = self._el;\n\t\n\t                if (state.transition && el && el.__zr) {// El can be animated\n\t                    var transitionCfg = state.transition;\n\t                    var property = transitionCfg.property;\n\t\n\t                    var animatingCount = 0;\n\t                    var animationDone = function () {\n\t                        animatingCount--;\n\t                        if (animatingCount === 0) {\n\t                            self.setState(target);\n\t                            done && done();\n\t                        }\n\t                    };\n\t                    for (var i = 0; i < property.length; i++) {\n\t                        var propName = property[i];\n\t\n\t                        // Animating all the properties in style or shape\n\t                        if (propName === 'style' || propName === 'shape') {\n\t                            if (state[propName]) {\n\t                                for (var key in state[propName]) {\n\t                                    if (!state[propName].hasOwnProperty(key)) {\n\t                                        continue;\n\t                                    }\n\t                                    var path = propName + '.' + key;\n\t                                    if (propPathMap[path]) {\n\t                                        continue;\n\t                                    }\n\t                                    propPathMap[path] = 1;\n\t                                    animatingCount += self._animProp(\n\t                                        state, propName, key, transitionCfg, animationDone\n\t                                    );\n\t                                }\n\t                            }\n\t                        }\n\t                        else {\n\t                            if (propPathMap[propName]) {\n\t                                continue;\n\t                            }\n\t                            propPathMap[propName] = 1;\n\t                            // Animating particular property in style or style\n\t                            if (propName.match(styleShapeReg)) {\n\t                                // remove 'style.', 'shape.' prefix\n\t                                var subProp = propName.slice(0, 5);\n\t                                propName = propName.slice(6);\n\t                                animatingCount += self._animProp(\n\t                                    state, subProp, propName, transitionCfg, animationDone\n\t                                );\n\t                            }\n\t                            else {\n\t                                animatingCount += self._animProp(\n\t                                    state, '', propName, transitionCfg, animationDone\n\t                                );\n\t                            }\n\t\n\t                        }\n\t                    }\n\t                    // No transition properties\n\t                    if (animatingCount === 0) {\n\t                        self.setState(target);\n\t                        done && done();\n\t                    }\n\t                }\n\t                else {\n\t                    self.setState(target);\n\t                    done && done();\n\t                }\n\t            }\n\t\n\t            var subStates = self._subStates;\n\t            for (var i = 0; i < subStates.length; i++) {\n\t                subStates.transitionState(target);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Do transition animation of particular property\n\t         * @param {Object} state\n\t         * @param {string} subPropKey\n\t         * @param {string} key\n\t         * @param {Object} transitionCfg\n\t         * @param {Function} done\n\t         * @private\n\t         */\n\t        _animProp: function (state, subPropKey, key, transitionCfg, done) {\n\t            var el = this._el;\n\t            var stateObj = subPropKey ? state[subPropKey] : state;\n\t            var elObj = subPropKey ? el[subPropKey] : el;\n\t            var availableProp = stateObj && (key in stateObj)\n\t                && elObj && (key in elObj);\n\t\n\t            var transitionAnimators = this._transitionAnimators;\n\t            if (availableProp) {\n\t                var obj = {};\n\t                if (stateObj[key] === elObj[key]) {\n\t                    return 0;\n\t                }\n\t                obj[key] = stateObj[key];\n\t\n\t                var animator = el.animate(subPropKey)\n\t                    .when(transitionCfg.duration, obj)\n\t                    .delay(transitionCfg.dealy)\n\t                    .done(function () {\n\t                        var idx = zrUtil.indexOf(transitionAnimators, 1);\n\t                        if (idx > 0) {\n\t                            transitionAnimators.splice(idx, 1);\n\t                        }\n\t                        done();\n\t                    })\n\t                    .start(transitionCfg.easing);\n\t                transitionAnimators.push(animator);\n\t\n\t                return 1;\n\t            }\n\t            return 0;\n\t        },\n\t\n\t        _stopTransition: function () {\n\t            var transitionAnimators = this._transitionAnimators;\n\t            for (var i = 0; i < transitionAnimators.length; i++) {\n\t                transitionAnimators[i].stop();\n\t            }\n\t            transitionAnimators.length = 0;\n\t        },\n\t\n\t        transiting: function () {\n\t            return this._transitionAnimators.length > 0;\n\t        },\n\t\n\t        addSubStates: function (states) {\n\t            this._subStates.push(states);\n\t        },\n\t\n\t        removeSubStates: function (states) {\n\t            var idx = zrUtil.indexOf(this._subStates, states);\n\t            if (idx >= 0) {\n\t                this._subStates.splice(states, 1);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = GraphicStates;\n\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var BoundingRect = __webpack_require__(27);\r\n\t    function Minimap(bigCanvas,groupPosition, group,eagleEyeNode,distance,imgSrc) {\r\n\t\r\n\t        this.bigCanvas = bigCanvas;\r\n\t        this.eagleEyeNode = eagleEyeNode;\r\n\t        this.distance = distance;\r\n\t        this.imgSrc = imgSrc;\r\n\t        this.ratio;\r\n\t        this.groupRatio;\r\n\t        this.group = group;\r\n\t        this.img = document.createElement(\"img\");\r\n\t        this.selection = document.createElement('div');\r\n\t        this.groupPosition = zrUtil.clone(groupPosition);\r\n\t        this.selectPosition = [0,0];\r\n\t        this.render();\r\n\t    }\r\n\t\r\n\t    Minimap.prototype.render = function() {\r\n\t        var that = this;\r\n\t        that.ratio = 0.12;\r\n\t        var eagleEyeNodeWidth = that.group.width  * that.ratio;\r\n\t        var eagleEyeNodeHeight = that.group.height  * that.ratio;\r\n\t        that.eagleEyeNode.style.width = eagleEyeNodeWidth+\"px\";\r\n\t        that.eagleEyeNode.style.height = eagleEyeNodeHeight+\"px\";\r\n\t        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+\"px\";\r\n\t        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+\"px\";\r\n\t        that.eagleEyeNode.style.position=\"relative\";\r\n\t        that.eagleEyeNode.style.background = \"url(\"+that.imgSrc+\") no-repeat\";\r\n\t        that.eagleEyeNode.style.backgroundSize = eagleEyeNodeWidth/(that.group.width*that.distance[2]/that.bigCanvas.getWidth())+\"px\";\r\n\t        that.backgroundSize = zrUtil.clone(that.eagleEyeNode.style.backgroundSize);\r\n\t        that.eagleEyeNode.innerHTML = \"\";\r\n\t        that.selection.style.border = \"1px solid #ff0000\";\r\n\t        that.selection.style.cursor = \"pointer\";\r\n\t        that.selection.style.width = that.bigCanvas.getWidth()/that.group.width*eagleEyeNodeWidth+\"px\";\r\n\t        that.selection.style.height = that.bigCanvas.getHeight()/that.group.height*eagleEyeNodeHeight+\"px\";\r\n\t        that.selectWidth = that.selection.style.width;\r\n\t        that.selectHeight = that.selection.style.height;\r\n\t        that.selection.style.position=\"absolute\";\r\n\t        that.selection.style.top = 0+\"px\";\r\n\t        that.selection.style.left = 0+\"px\";\r\n\t        that.eagleEyeNode.appendChild(this.selection);\r\n\t    };\r\n\t    Minimap.prototype.updataSelection = function(offectLeft,offectTop,zoomScale,nowZoom){\r\n\t        var that = this;\r\n\t        that.zoomScale = zoomScale;\r\n\t        this.selection.style.width = this.selection.style.width.replace(\"px\",\"\")/zoomScale+\"px\";\r\n\t        this.selection.style.height = this.selection.style.height.replace(\"px\",\"\")/zoomScale+\"px\";\r\n\t        that.selectPosition[0] = zrUtil.clone(offectLeft)*that.ratio/nowZoom;\r\n\t        that.selectPosition[1] = zrUtil.clone(offectTop)*that.ratio/nowZoom;\r\n\t        this.selection.style.left = -that.selectPosition[0]+\"px\";\r\n\t        this.selection.style.top = -that.selectPosition[1]+\"px\";\r\n\t    };\r\n\t    Minimap.prototype.updataMap = function(imgSrc,newGroup){\r\n\t        var that = this;\r\n\t        that.eagleEyeNode.style.backgroundImage = \"url(\"+imgSrc+\")\";\r\n\t        var eagleEyeNodeWidth = newGroup.width  * that.ratio;\r\n\t        var eagleEyeNodeHeight = newGroup.height  * that.ratio;\r\n\t        that.eagleEyeNode.style.width = eagleEyeNodeWidth+\"px\";\r\n\t        that.eagleEyeNode.style.height = eagleEyeNodeHeight+\"px\";\r\n\t        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+\"px\";\r\n\t        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+\"px\";\r\n\t    };\r\n\t    Minimap.prototype.updataSelectionPosition = function(nowGroupPosition,nowZoom){\r\n\t        var that = this;\r\n\t        that.selectPosition[0] = zrUtil.clone(nowGroupPosition[0])*that.ratio/nowZoom;\r\n\t        that.selectPosition[1] = zrUtil.clone(nowGroupPosition[1])*that.ratio/nowZoom;\r\n\t        this.selection.style.left = -that.selectPosition[0]+\"px\";\r\n\t        this.selection.style.top = -that.selectPosition[1]+\"px\";\r\n\t    };\r\n\t    Minimap.prototype.updataGroupPosition = function(group,nowZoom){\r\n\t        var that = this;\r\n\t        var positionX = -Number(that.selection.style.left.substring(0,that.selection.style.left.length-2))/that.ratio*nowZoom;\r\n\t        var positionY = -Number(that.selection.style.top.substring(0,that.selection.style.top.length-2))/that.ratio*nowZoom;\r\n\t        group.attr(\"position\",[positionX,positionY]);\r\n\t    };\r\n\t\r\n\t    module.exports = Minimap;\r\n\t\r\n\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 工具方法类\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Point = __webpack_require__(66);\r\n\t    var Line = __webpack_require__(67);\r\n\t    var BoundingRect = __webpack_require__(27);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    /**\r\n\t     * 构造类继承关系\r\n\t     *\r\n\t     * @param {Function} clazz 源类\r\n\t     * @param {Function} baseClazz 基类\r\n\t     */\r\n\t    function inherits(clazz, baseClazz) {\r\n\t        var clazzPrototype = clazz.prototype;\r\n\t\r\n\t        function F() {}\r\n\t        F.prototype = baseClazz.prototype;\r\n\t        clazz.prototype = new F();\r\n\t\r\n\t        for (var prop in clazzPrototype) {\r\n\t            clazz.prototype[prop] = clazzPrototype[prop];\r\n\t        }\r\n\t        clazz.prototype.constructor = clazz;\r\n\t        clazz.superClass = baseClazz;\r\n\t    }\r\n\t\r\n\t    function getUUID() {\r\n\t        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),\r\n\t            uuid = new Array(36),\r\n\t            rnd = 0,\r\n\t            r;\r\n\t        for (var i = 0; i < 36; i++) {\r\n\t            if (i == 8 || i == 13 || i == 18 || i == 23) {\r\n\t                uuid[i] = '-';\r\n\t            } else if (i == 14) {\r\n\t                uuid[i] = '4';\r\n\t            } else {\r\n\t                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\r\n\t                r = rnd & 0xf;\r\n\t                rnd = rnd >> 4;\r\n\t                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\r\n\t            }\r\n\t        }\r\n\t        return \"sid-\" + uuid.join('');\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 计算两点之间的距离\r\n\t     *@param {Point} p1 - first {Point}\r\n\t     *@param {Point} p2 - second {Point}\r\n\t     *@return {Number} - the distance between those 2 points. It is always positive.\r\n\t     **/\r\n\t    function distance(p1, p2) {\r\n\t        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 返回一条折线 最长的两个点\r\n\t     * @param  {[type]} points [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    function getMaxLineLength(points) {\r\n\t        var m = distance(points[0], points[1]);\r\n\t        var result = [points[0], points[1]];\r\n\t        for (var i = 1; i < points.length - 1; i++) {\r\n\t\r\n\t            if (m < distance(points[i], points[i + 1])) {\r\n\t                m = distance(points[i], points[i + 1])\r\n\t                result = [points[i], points[i + 1]];\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return result;\r\n\t    }\r\n\t\r\n\t    /**Returns the length of a Polyline that would be created with a set of points\r\n\t     *@param {Array} v - an {Array} of {Points}\r\n\t     *@return {Number} - a positive number equal with total length*/\r\n\t    function getPolylineLength(v) {\r\n\t        var l = 0;\r\n\t        for (var i = 0; i < v.length - 1; i++) {\r\n\t            l += distance(v[i], v[i + 1]);\r\n\t        }\r\n\t\r\n\t        return l;\r\n\t    }\r\n\t\r\n\t\r\n\t    /**Returns the max of a vector\r\n\t     *@param {Array} v - vector of {Number}s\r\n\t     *@return {Number} - the maximum number from the vector or NaN if vector is empty\r\n\t     **/\r\n\t    function max(v) {\r\n\t        if (v.lenght == 0) {\r\n\t            return NaN;\r\n\t        } else {\r\n\t            var m = v[0];\r\n\t            for (var i = 0; i < v.length; i++) {\r\n\t                if (m < v[i]) {\r\n\t                    m = v[i];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return m;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    /**Returns the min of a vector\r\n\t     *@param {Array} v - vector of {Number}s\r\n\t     *@return {Number} - the minimum number from the vector or NaN if vector is empty\r\n\t     *@author alex@scriptoid.com\r\n\t     **/\r\n\t    function min(v) {\r\n\t        if (v.lenght == 0) {\r\n\t            return NaN;\r\n\t        } else {\r\n\t            var m = v[0];\r\n\t            for (var i = 0; i < v.length; i++) {\r\n\t                if (m > v[i]) {\r\n\t                    m = v[i];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return m;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 判断 点数组 是否正交直线路径\r\n\t     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)\r\n\t     *@param {Array} v - an {Array} of {Point}s\r\n\t     *@return {Boolean} - true if path is valid, false otherwise\r\n\t     **/\r\n\t    function orthogonalPath(v) {\r\n\t        if (v.length <= 1) {\r\n\t            return true;\r\n\t        }\r\n\t\r\n\t        for (var i = 0; i < v.length - 1; i++) {\r\n\t            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {\r\n\t                return false;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return true;\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     *Test to see if 2 {Line}s intersects. They are considered finite segments\r\n\t     *and not the infinite lines from geometry\r\n\t     *@param {Line} l1 - fist line/segment\r\n\t     *@param {Line} l2 - last line/segment\r\n\t     *@return {Boolean} true - if the lines intersect or false if not\r\n\t     **/\r\n\t    function lineIntersectsLine(l1, l2) {\r\n\t        // check for two vertical lines\r\n\t        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {\r\n\t            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,\r\n\t                // then check segment bounds for overlapping\r\n\t                l1.contains(l2.startPoint.x, l2.startPoint.y) ||\r\n\t                l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n\t                // lines are paralel\r\n\t                false;\r\n\t        }\r\n\t        // if one line is vertical, and another line is not vertical\r\n\t        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {\r\n\t            // let assume l2 is vertical, otherwise exchange them\r\n\t            if (l1.startPoint.x == l1.endPoint.x) {\r\n\t                var l = l1;\r\n\t                l1 = l2;\r\n\t                l2 = l;\r\n\t            }\r\n\t            // finding intersection of 'infinite' lines\r\n\t            // equation of the first line is y = ax + b, second: x = c\r\n\t            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n\t            var b = l1.startPoint.y - a * l1.startPoint.x;\r\n\t            var x0 = l2.startPoint.x;\r\n\t            var y0 = a * x0 + b;\r\n\t            return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n\t        }\r\n\t\r\n\t        // check normal case - both lines are not vertical\r\n\t        else {\r\n\t            //line equation is : y = a*x + b, b = y - a * x\r\n\t            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n\t            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;\r\n\t\r\n\t            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);\r\n\t            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;\r\n\t\r\n\t            if (a1 == a2) { //paralel lines\r\n\t                return b1 == b2 ?\r\n\t                    // for coincide lines, check for segment bounds overlapping\r\n\t                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n\t                    // not coincide paralel lines have no chance to intersect\r\n\t                    false;\r\n\t            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment\r\n\t\r\n\t                /*\r\n\t                 * if one of the lines are vertical, then x0 is equal to their x,\r\n\t                 * otherwise:\r\n\t                 * y1 = a1 * x + b1\r\n\t                 * y2 = a2 * x + b2\r\n\t                 * => x0 = (b2 - b1) / (a1 - a2)\r\n\t                 * => y0 = a1 * x0 + b1\r\n\t                 **/\r\n\t                x0 = (b2 - b1) / (a1 - a2);\r\n\t                y0 = a1 * x0 + b1;\r\n\t                return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     *Tests if a a polyline defined by a set of points intersects a rectangle\r\n\t     *@param {Array} points - and {Array} of {Point}s\r\n\t     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)\r\n\t     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false\r\n\t     *\r\n\t     *@return true - if line intersects the rectangle, false - if not\r\n\t     **/\r\n\t    function polylineIntersectsRectangle(points, bounds, closedPolyline) {\r\n\t\r\n\t\r\n\t        //get the 4 lines/segments represented by the bounds\r\n\t        var lines = [];\r\n\t        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));\r\n\t        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));\r\n\t        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));\r\n\t        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));\r\n\t\r\n\t        for (var k = 0; k < points.length - 1; k++) {\r\n\t            //create a line out of each 2 consecutive points\r\n\t            var tempLine = new Line(points[k], points[k + 1]);\r\n\t\r\n\t            //see if that line intersect any of the line on bounds border\r\n\t            for (var i = 0; i < lines.length; i++) {\r\n\t                if (lineIntersectsLine(tempLine, lines[i])) {\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        //check the closed figure - that is last point connected to the first\r\n\t        if (closedPolyline) {\r\n\t            //create a line out of each 2 consecutive points\r\n\t            var tempLine1 = new Line(points[points.length - 1], points[0]);\r\n\t\r\n\t            //see if that line intersect any of the line on bounds border\r\n\t            for (var j = 0; j < lines.length; j++) {\r\n\t                if (lineIntersectsLine(tempLine1, lines[j])) {\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return false;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 计算路径的分数\r\n\t     * Score a ortogonal path made out of Points\r\n\t     *Iterates over a set of points (minimum 3)\r\n\t     *For each 3 points (i, i+1, i+2) :\r\n\t     *  - if the 3rd one is after the 2nd on the same line we add +1\r\n\t     *  - if the 3rd is up or down related to the 2nd we do not do anything +0\r\n\t     *  - if the 3rd goes back we imediatelly return -1\r\n\t     *@param {Array} v - an array of {Point}s\r\n\t     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine\r\n\t     *  The bigger the number the smooth the path is\r\n\t     **/\r\n\t    function scorePath(v) {\r\n\t        if (v.length <= 2) {\r\n\t            return -1;\r\n\t        }\r\n\t\r\n\t        var score = 0;\r\n\t        for (var i = 1; i < v.length - 1; i++) {\r\n\t            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical\r\n\t                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction\r\n\t                    score++;\r\n\t                } else { //going back - no good\r\n\t                    return -1;\r\n\t                }\r\n\t            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal\r\n\t                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction\r\n\t                    score++;\r\n\t                } else { //going back - no good\r\n\t                    return -1;\r\n\t                }\r\n\t            } else { //not on same vertical nor horizontal\r\n\t                score--;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return score;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 返回数字符号（+ -)\r\n\t     * Returns the sign of a number\r\n\t     *@param {Number} x - the number\r\n\t     *@returns {Number}\r\n\t     *@see <a href=\"http://en.wikipedia.org/wiki/Sign_function\">http://en.wikipedia.org/wiki/Sign_function</a>\r\n\t     **/\r\n\t    function signum(x) {\r\n\t        if (x > 0)\r\n\t            return 1;\r\n\t        else if (x < 0)\r\n\t            return -1;\r\n\t        else\r\n\t            return 0;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 判断 点数组 是不是有效路径（没有回路）\r\n\t     *Tests if a vector of points is a valid path (not going back)\r\n\t     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that\r\n\t     *@param {Array} v - an {Array} of {Point}s\r\n\t     *@return {Boolean} - true if path is valid, false otherwise\r\n\t     **/\r\n\t    function forwardPath(v) {\r\n\t        if (v.length <= 2) {\r\n\t            return true;\r\n\t        }\r\n\t\r\n\t        for (var i = 0; i < v.length - 2; i++) {\r\n\t            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical\r\n\t                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path\r\n\t                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)\r\n\t                        return false;\r\n\t                    }\r\n\t                }\r\n\t            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal\r\n\t                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path\r\n\t                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)\r\n\t                        return false;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return true;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n\t     * @param  {[type]} points [description]\r\n\t     * @param  {[type]} isRevert [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    function traslatePoints(points, isRevert) {\r\n\t        var newPoints = [];\r\n\t        if (isRevert) {\r\n\t            for (var i = 0; i < points.length; i++) {\r\n\t                var point = points[i];\r\n\t                newPoints.push(new Point(point[0], point[1]));\r\n\t            }\r\n\t            return newPoints;\r\n\t        } else {\r\n\t            for (var j = 0; j < points.length; j++) {\r\n\t                var point1 = points[j];\r\n\t                newPoints.push([point1.x, point1.y]);\r\n\t            }\r\n\t            return newPoints;\r\n\t        }\r\n\t\r\n\t\r\n\t    }\r\n\t\r\n\t    function rotationMatrix(angle) {\r\n\t        var mReturn = [\r\n\t            [Math.cos(angle), -Math.sin(angle), 0],\r\n\t            [Math.sin(angle), Math.cos(angle), 0],\r\n\t            [0, 0, 1]\r\n\t        ];\r\n\t        return mReturn;\r\n\t    }\r\n\t\r\n\t    function translationMatrix(dx, dy) {\r\n\t        return [\r\n\t            [1, 0, dx],\r\n\t            [0, 1, dy],\r\n\t            [0, 0, 1]\r\n\t        ];\r\n\t    }\r\n\t\r\n\t    function scaleMatrix(sx, sy) {\r\n\t        if (sy == null) {\r\n\t            sy = sx;\r\n\t        }\r\n\t        return [\r\n\t            [sx, 0, 0],\r\n\t            [0, sy, 0],\r\n\t            [0, 0, 1]\r\n\t        ];\r\n\t    }\r\n\t\r\n\t    /** It will return the end point of a line on a given angle (clockwise).\r\n\t     * @param {Point} startPoint - the start of the line\r\n\t     * @param {Number} length - the length of the line\r\n\t     * @param {Number} angle - the angle of the line in radians\r\n\t     * @return {Point} - the endPoint of the line\r\n\t     */\r\n\t    function getEndPoint(startPoint, length, angle) {\r\n\t        var endPoint = startPoint.clone();\r\n\t        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));\r\n\t        endPoint.y -= length;\r\n\t        endPoint.transform(rotationMatrix(angle));\r\n\t        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));\r\n\t        return endPoint;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取获取两个图形的外面四个连接点\r\n\t     * @param  {[type]} node [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    function getConnectorPoints(node) {\r\n\t        return {\r\n\t            left: new Point(node.x, node.y + node.height / 2), //矩形 左中的位置\r\n\t            top: new Point(node.x + node.width / 2, node.y), //矩形 上中的位置\r\n\t            right: new Point(node.x + node.width, node.y + node.height / 2), //矩形 右中的位置\r\n\t            bottom: new Point(node.x + node.width / 2, node.y + node.height), //矩形 下中的位置\r\n\t            center: new Point(node.x + node.width / 2, node.y + node.height / 2) //中间位置\r\n\t\r\n\t        };\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取获取两个图形的外面四个连接点\r\n\t     * @param  {[type]} node [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    function getSoltPoints(node) {\r\n\t        return [\r\n\t            //top\r\n\t            [Math.round(node.getRect().width / 3 /10)*10, 0 ],\r\n\t            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],\r\n\t            //right\r\n\t            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],\r\n\t            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],\r\n\t            //bottom\r\n\t            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n\t            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n\t            //left\r\n\t            [0, Math.round(node.getRect().height / 3 /10)*10 ],\r\n\t            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]\r\n\t\r\n\t        ]\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 计算 p1 p2两点所连接的直线的角度\r\n\t     * @param  {[type]} p1 [description]\r\n\t     * @param  {[type]} p2 [description]\r\n\t     * @return {[type]}    [description]\r\n\t     */\r\n\t    function tangentRotation(p1, p2) {\r\n\t        return -Math.PI / 2 - Math.atan2(\r\n\t            p2.y - p1.y, p2.x - p1.x\r\n\t        );\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 判断3点是否在一条直线上\r\n\t     * Tests if 3 points are coliniar with matrix determinants.\r\n\t     * If the determinat of matrix\r\n\t     * /         \\\r\n\t     * | x1 y1 1 |\r\n\t     * | x2 y2 1 |\r\n\t     * | x3 y3 1 |\r\n\t     * \\         /\r\n\t     * is zero it means that the points are colinear\r\n\t     *@param {Point} p1 - first point\r\n\t     *@param {Point} p2 - second point\r\n\t     *@param {Point} p3 - third point\r\n\t     * @param {Number} precission\r\n\t     *@return {Boolean} - true if coliniar and false if not\r\n\t     *@author Alex\r\n\t     *@see http://en.wikipedia.org/wiki/Determinant\r\n\t     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html\r\n\t     **/\r\n\t    function collinearity(p1, p2, p3, precission) {\r\n\t        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);\r\n\t\r\n\t        if (precission) {\r\n\t            return Math.abs(determinant) <= precission;\r\n\t        } else {\r\n\t            return determinant === 0;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 四舍五入 保存decimals的小数\r\n\t     **/\r\n\t    function enhancedRound(number, decimals) {\r\n\t        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取两点之间的长度\r\n\t     **/\r\n\t    function getLength(startPoint, endPoint) {\r\n\t        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取角度\r\n\t     * @param  {[type]} centerPoint  [description]\r\n\t     * @param  {[type]} outsidePoint [description]\r\n\t     * @param  {[type]} round        [description]\r\n\t     * @return {[type]}              [description]\r\n\t     */\r\n\t    function getAngle(centerPoint, outsidePoint, round) {\r\n\t        centerPoint.x = enhancedRound(centerPoint.x, 5);\r\n\t        centerPoint.y = enhancedRound(centerPoint.y, 5);\r\n\t        outsidePoint.x = enhancedRound(outsidePoint.x, 5);\r\n\t        outsidePoint.y = enhancedRound(outsidePoint.y, 5);\r\n\t        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));\r\n\t        angle = -angle;\r\n\t\r\n\t        //endAngle+=90;\r\n\t        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n\t            angle += Math.PI;\r\n\t        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n\t            angle += Math.PI;\r\n\t        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {\r\n\t            angle += Math.PI * 2;\r\n\t        }\r\n\t        while (angle >= Math.PI * 2) {\r\n\t            angle -= Math.PI * 2;\r\n\t        }\r\n\t        if (isNaN(angle)) { //Nan\r\n\t            angle = 0; //we are at center point;\r\n\t        }\r\n\t        if (round) {\r\n\t            angle = Math.round(angle / round) * round\r\n\t        }\r\n\t        return angle;\r\n\t    }\r\n\t\r\n\t    function getRect(node, isCalcParent) {\r\n\t        var boundingRect = node.getBoundingRect();\r\n\t        //创建最小包围盒虚线\r\n\t        var points = [];\r\n\t        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\t        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];\r\n\t        points[2] = [boundingRect.width / 2, boundingRect.height / 2];\r\n\t        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];\r\n\t        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\t\r\n\t        var positionX = node.position[0];\r\n\t        var positionY = node.position[1];\r\n\t        //这里要循环判断一把 有没有父节点 并且父节点不是根节点 然后进行相加\r\n\t        if (node.parent.type === \"GroupNode\" && isCalcParent) {\r\n\t            positionX = positionX + node.parent.position[0];\r\n\t            positionY = positionY + node.parent.position[1];\r\n\t        }\r\n\t\r\n\t        var boundRect = new BoundingRect(\r\n\t                Number(positionX + boundingRect.x),   //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半\r\n\t                Number(positionY + boundingRect.y),\r\n\t                Number(boundingRect.width),\r\n\t                Number(boundingRect.height)\r\n\t            );\r\n\t        //中心点\r\n\t        var cx = Number(node.position[0]) + Number(boundingRect.width) / 2 + Number(boundingRect.x);\r\n\t        var cy = Number(node.position[1]) + Number(boundingRect.height) / 2 + Number(boundingRect.y);\r\n\t        return {\r\n\t            x: Number(cx),\r\n\t            y: Number(cy),\r\n\t            width: Number(boundingRect.width),\r\n\t            height: Number(boundingRect.height),\r\n\t            points: points,\r\n\t            boundingRect: boundRect\r\n\t        };\r\n\t    }\r\n\t\r\n\t    var StackedMap = {\r\n\t        createNew: function() {\r\n\t            var stack = [];\r\n\t\r\n\t            return {\r\n\t                add: function(key, value) {\r\n\t                    var arrKey = this.get(key);\r\n\t                    arrKey.push(value)\r\n\t\r\n\t                },\r\n\t                get: function(key) {\r\n\t                    for (var i = 0; i < stack.length; i++) {\r\n\t                        if (key == stack[i].key) {\r\n\t                            return stack[i].value;\r\n\t                        }\r\n\t                    }\r\n\t                    //如果没有找到的话，则创建一个新的数组\r\n\t                    var value = [];\r\n\t                    stack.push({ key: key, value: value });\r\n\t                    return value;\r\n\t                },\r\n\t                keys: function() {\r\n\t                    var keys = [];\r\n\t                    for (var i = 0; i < stack.length; i++) {\r\n\t                        keys.push(stack[i].key);\r\n\t                    }\r\n\t                    return keys;\r\n\t                },\r\n\t                top: function() {\r\n\t                    return stack[stack.length - 1];\r\n\t                },\r\n\t                remove: function(key) {\r\n\t                    var idx = -1;\r\n\t                    for (var i = 0; i < stack.length; i++) {\r\n\t                        if (key == stack[i].key) {\r\n\t                            idx = i;\r\n\t                            break;\r\n\t                        }\r\n\t                    }\r\n\t                    return stack.splice(idx, 1)[0];\r\n\t                },\r\n\t                removeItem: function(key, item) {\r\n\t                    var arrKey = this.get(key);\r\n\t                    var index = zrUtil.indexOf(arrKey, item);\r\n\t                    arrKey.splice(index, 1);\r\n\t\r\n\t                },\r\n\t                removeTop: function() {\r\n\t                    return stack.splice(stack.length - 1, 1)[0];\r\n\t                },\r\n\t                length: function() {\r\n\t                    return stack.length;\r\n\t                },\r\n\t                clear: function() {\r\n\t                    stack.splice(0, stack.length);\r\n\t                }\r\n\t            };\r\n\t        }\r\n\t    };\r\n\t\r\n\t    function randomColor() {\r\n\t        var arrHex = [\"0\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\"],\r\n\t            strHex = \"#\",\r\n\t            index;\r\n\t        for (var i = 0; i < 6; i++) {\r\n\t            index = Math.round(Math.random() * 15);\r\n\t            strHex += arrHex[index];\r\n\t        }\r\n\t        return strHex;\r\n\t    }\r\n\t\r\n\t    function isUndefined(obj) {\r\n\t        return obj === void 0;\r\n\t    }\r\n\t\r\n\t    function collinearReduction (v) {\r\n\t        var r = [];\r\n\t\r\n\t        if(v.length < 3){\r\n\t            return Point.cloneArray(v);\r\n\t        }\r\n\t\r\n\t        r.push( v[0].clone() );\r\n\t        for(var i=1; i < v.length-1; i++){\r\n\t            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )\r\n\t            {\r\n\t                continue;\r\n\t            }\r\n\t            else{\r\n\t                r.push( v[i].clone() );\r\n\t            }\r\n\t        }\r\n\t        r.push( v[v.length-1].clone() );\r\n\t\r\n\t        return r;\r\n\t    }\r\n\t\r\n\t    // By default, Underscore uses ERB-style template delimiters, change the\r\n\t    // following template settings to use alternative delimiters.\r\n\t    var templateSettings = {\r\n\t        evaluate: /<%([\\s\\S]+?)%>/g,\r\n\t        interpolate: /<%=([\\s\\S]+?)%>/g,\r\n\t        escape: /<%-([\\s\\S]+?)%>/g\r\n\t    };\r\n\t\r\n\t    // When customizing `templateSettings`, if you don't want to define an\r\n\t    // interpolation, evaluation or escaping regex, we need one that is\r\n\t    // guaranteed not to match.\r\n\t    var noMatch = /(.)^/;\r\n\t\r\n\t    // Certain characters need to be escaped so that they can be put into a\r\n\t    // string literal.\r\n\t    var escapes = {\r\n\t        \"'\": \"'\",\r\n\t        '\\\\': '\\\\',\r\n\t        '\\r': 'r',\r\n\t        '\\n': 'n',\r\n\t        '\\u2028': 'u2028',\r\n\t        '\\u2029': 'u2029'\r\n\t    };\r\n\t\r\n\t    var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\r\n\t\r\n\t    var escapeChar = function(match) {\r\n\t        return '\\\\' + escapes[match];\r\n\t    };\r\n\t\r\n\t    // JavaScript micro-templating, similar to John Resig's implementation.\r\n\t    // Underscore templating handles arbitrary delimiters, preserves whitespace,\r\n\t    // and correctly escapes quotes within interpolated code.\r\n\t    // NB: `oldSettings` only exists for backwards compatibility.\r\n\t    function template(text, settings, oldSettings) {\r\n\t        if (!settings && oldSettings) settings = oldSettings;\r\n\t        settings = settings || {};\r\n\t        settings = zrUtil.defaults(settings, templateSettings, true);\r\n\t\r\n\t        // Combine delimiters into one regular expression via alternation.\r\n\t        var matcher = RegExp([\r\n\t            (settings.escape || noMatch).source,\r\n\t            (settings.interpolate || noMatch).source,\r\n\t            (settings.evaluate || noMatch).source\r\n\t        ].join('|') + '|$', 'g');\r\n\t\r\n\t        // Compile the template source, escaping string literals appropriately.\r\n\t        var index = 0;\r\n\t        var source = \"__p+='\";\r\n\t        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\r\n\t            source += text.slice(index, offset).replace(escaper, escapeChar);\r\n\t            index = offset + match.length;\r\n\t\r\n\t            if (escape) {\r\n\t                source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\r\n\t            } else if (interpolate) {\r\n\t                source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\r\n\t            } else if (evaluate) {\r\n\t                source += \"';\\n\" + evaluate + \"\\n__p+='\";\r\n\t            }\r\n\t\r\n\t            // Adobe VMs need the match returned to produce the correct offest.\r\n\t            return match;\r\n\t        });\r\n\t        source += \"';\\n\";\r\n\t\r\n\t        // If a variable is not specified, place data values in local scope.\r\n\t        if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\r\n\t\r\n\t        source = \"var __t,__p='',__j=Array.prototype.join,\" +\r\n\t            \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\r\n\t            source + 'return __p;\\n';\r\n\t\r\n\t        try {\r\n\t            var render = new Function(settings.variable || 'obj', source);\r\n\t        } catch (e) {\r\n\t            e.source = source;\r\n\t            throw e;\r\n\t        }\r\n\t\r\n\t        var template = function(data) {\r\n\t            return render.call(this, data);\r\n\t        };\r\n\t\r\n\t        // Provide the compiled source as a convenience for precompilation.\r\n\t        var argument = settings.variable || 'obj';\r\n\t        template.source = 'function(' + argument + '){\\n' + source + '}';\r\n\t\r\n\t        return template;\r\n\t    }\r\n\t\r\n\t    function isEmpty(obj) {\r\n\t        if (obj == null) return true;\r\n\t        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;\r\n\t    }\r\n\t    function Class() {}\r\n\t    Class.extend = function(proto) {\r\n\t        var base = function() {},\r\n\t            member,\r\n\t            that = this,\r\n\t            subclass = proto && proto.init ? proto.init : function () {\r\n\t                that.apply(this, arguments);\r\n\t            },\r\n\t            fn;\r\n\t\r\n\t        base.prototype = that.prototype;\r\n\t        fn = subclass.fn = subclass.prototype = new base();\r\n\t\r\n\t        for (member in proto) {\r\n\t            if (proto[member] != null && proto[member].constructor === Object) {\r\n\t                // Merge object members\r\n\t                fn[member] = zrUtil.mergeAll([{}, base.prototype[member], proto[member]],true);\r\n\t            } else {\r\n\t                fn[member] = proto[member];\r\n\t            }\r\n\t        }\r\n\t\r\n\t        fn.constructor = subclass;\r\n\t        subclass.extend = that.extend;\r\n\t\r\n\t        return subclass;\r\n\t    };\r\n\t\r\n\t    module.exports = {\r\n\t        inherits: inherits,\r\n\t        getUUID: getUUID,\r\n\t        distance: distance,\r\n\t        getPolylineLength: getPolylineLength,\r\n\t        max: max,\r\n\t        min: min,\r\n\t        isEmpty: isEmpty,\r\n\t        orthogonalPath: orthogonalPath,\r\n\t        polylineIntersectsRectangle: polylineIntersectsRectangle,\r\n\t        scorePath: scorePath,\r\n\t        forwardPath: forwardPath,\r\n\t        traslatePoints: traslatePoints,\r\n\t        getEndPoint: getEndPoint,\r\n\t        getConnectorPoints: getConnectorPoints,\r\n\t        tangentRotation: tangentRotation,\r\n\t        collinearity: collinearity,\r\n\t        translationMatrix: translationMatrix,\r\n\t        scaleMatrix: scaleMatrix,\r\n\t        round: enhancedRound,\r\n\t        getLength: getLength,\r\n\t        getAngle: getAngle,\r\n\t        getRect: getRect,\r\n\t        StackedMap: StackedMap,\r\n\t        getMaxLineLength: getMaxLineLength,\r\n\t        randomColor: randomColor,\r\n\t        template: template,\r\n\t        isUndefined: isUndefined,\r\n\t        getSoltPoints:getSoltPoints,\r\n\t        collinearReduction: collinearReduction,\r\n\t        Class:Class\r\n\t    };\r\n\t\r\n\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports) {\n\n\t\r\n\t\r\n\t    /**\r\n\t      * Creates an instance of Point\r\n\t      *\r\n\t      *\r\n\t      * @constructor\r\n\t      * @this {Point}\r\n\t      * @param {Number} x The x coordinate of point.\r\n\t      * @param {Number} y The y coordinate of point.\r\n\t      * Note: Even if it is named Point this class should be named Dot as Dot is closer\r\n\t      * then Point from math perspective.\r\n\t      **/\r\n\t    function Point(x, y){\r\n\t        /**The x coordinate of point*/\r\n\t        this.x = x;\r\n\t\r\n\t        /**The y coordinate of point*/\r\n\t        this.y = y;\r\n\t\r\n\t\r\n\t    }\r\n\t\r\n\t    /**Creates a {Point} out of JSON parsed object\r\n\t     *@param {JSONObject} o - the JSON parsed object\r\n\t     *@return {Point} a newly constructed Point\r\n\t     **/\r\n\t    Point.load = function(o){\r\n\t        var newPoint = new Point(Number(o.x), Number(o.y));\r\n\t        return newPoint;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**Creates an array of points from an array of {JSONObject}s\r\n\t     *@param {Array} v - the array of JSONObjects\r\n\t     *@return an {Array} of {Point}s\r\n\t     **/\r\n\t    Point.loadArray = function(v){\r\n\t        var newPoints = [];\r\n\t        for(var i=0; i< v.length; i++){\r\n\t            newPoints.push(Point.load(v[i]));\r\n\t        }\r\n\t        return newPoints;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**Clones an array of points\r\n\t     *@param {Array} v - the array of {Point}s\r\n\t     *@return an {Array} of {Point}s\r\n\t     **/\r\n\t    Point.cloneArray = function(v){\r\n\t        var newPoints = [];\r\n\t        for(var i=0; i< v.length; i++){\r\n\t            newPoints.push(v[i].clone());\r\n\t        }\r\n\t        return newPoints;\r\n\t    };\r\n\t\r\n\t    Point.prototype = {\r\n\t        constructor : Point,\r\n\t\r\n\t        transform:function(matrix){\r\n\t            var oldX = this.x;\r\n\t            var oldY = this.y;\r\n\t            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];\r\n\t            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];\r\n\t        },\r\n\t\r\n\t        /**Tests if this point is similar to other point\r\n\t         *@param {Point} anotherPoint - the other point\r\n\t         **/\r\n\t        equals:function(anotherPoint){\r\n\t            if(! (anotherPoint instanceof Point) ){\r\n\t                return false;\r\n\t            }\r\n\t            return (this.x == anotherPoint.x)\r\n\t            && (this.y == anotherPoint.y)\r\n\t        },\r\n\t\r\n\t        /**Clone current Point\r\n\t         **/\r\n\t        clone: function(){\r\n\t            var newPoint = new Point(this.x, this.y);\r\n\t            return newPoint;\r\n\t        },\r\n\t\r\n\t        add: function(point) {\r\n\t            this.x = this.x + point.x;\r\n\t            this.y = this.y + point.y;\r\n\t            return this;\r\n\t        },\r\n\t\r\n\t        /**Tests to see if a point (x, y) is within a range of current Point\r\n\t         *@param {Numeric} x - the x coordinate of tested point\r\n\t         *@param {Numeric} y - the x coordinate of tested point\r\n\t         *@param {Numeric} radius - the radius of the vicinity\r\n\t         **/\r\n\t        near:function(x, y, radius){\r\n\t            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));\r\n\t\r\n\t            return (distance <= radius);\r\n\t        },\r\n\t\r\n\t        contains: function(x,y){\r\n\t            return this.x == x && this.y == y;\r\n\t        },\r\n\t\r\n\t        toString:function(){\r\n\t            return '[' + this.x + ',' + this.y + ']';\r\n\t        },\r\n\t\r\n\t        getPoints:function(){\r\n\t            return [this];\r\n\t        }\r\n\t    };\r\n\t    module.exports = Point;\r\n\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports) {\n\n\t\r\n\t\r\n\t    /**\r\n\t      * Creates an instance of a Line. A Line is actually a segment and not a pure\r\n\t      * geometrical Line\r\n\t      *\r\n\t      * @constructor\r\n\t      * @this {Line}\r\n\t      * @param {Point} startPoint - starting point of the line\r\n\t      * @param {Point} endPoint - the ending point of the line\r\n\t      **/\r\n\t    function Line(startPoint, endPoint){\r\n\t        /**Starting {@link Point} of the line*/\r\n\t        this.startPoint = startPoint;\r\n\t\r\n\t        /**Ending {@link Point} of the line*/\r\n\t        this.endPoint = endPoint;\r\n\t\r\n\t        /**Serialization type*/\r\n\t        this.oType = 'Line'; //object type used for JSON deserialization\r\n\t    }\r\n\t\r\n\t    /**Creates a {Line} out of JSON parsed object\r\n\t     *@param {JSONObject} o - the JSON parsed object\r\n\t     *@return {Line} a newly constructed Line\r\n\t     **/\r\n\t    Line.load = function(o){\r\n\t        var newLine = new Line(\r\n\t            Point.load(o.startPoint),\r\n\t            Point.load(o.endPoint)\r\n\t        );\r\n\t\r\n\t        return newLine;\r\n\t    };\r\n\t\r\n\t    Line.prototype = {\r\n\t        contructor: Line,\r\n\t\r\n\t\r\n\t\r\n\t        clone:function(){\r\n\t            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());\r\n\t            return ret;\r\n\t        },\r\n\t\r\n\t        equals:function(anotherLine){\r\n\t            if(!anotherLine instanceof Line){\r\n\t                return false;\r\n\t            }\r\n\t            return this.startPoint.equals(anotherLine.startPoint)\r\n\t            && this.endPoint.equals(anotherLine.endPoint)\r\n\t        },\r\n\t\r\n\t        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)\r\n\t         * Algorithm: Compute line's equation and see if (x, y) verifies it.\r\n\t         * @param {Number} x - the X coordinates\r\n\t         * @param {Number} y - the Y coordinates\r\n\t         **/\r\n\t        contains: function(x, y){\r\n\t            // if the point is inside rectangle bounds of the segment\r\n\t            if (Math.min(this.startPoint.x, this.endPoint.x) <= x\r\n\t                && x <= Math.max(this.startPoint.x, this.endPoint.x)\r\n\t                && Math.min(this.startPoint.y, this.endPoint.y) <= y\r\n\t                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {\r\n\t\r\n\t                // check for vertical line\r\n\t                if (this.startPoint.x == this.endPoint.x) {\r\n\t                    return x == this.startPoint.x;\r\n\t                } else { // usual (not vertical) line can be represented as y = a * x + b\r\n\t                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);\r\n\t                    var b = this.startPoint.y - a * this.startPoint.x;\r\n\t                    return y == a * x + b;\r\n\t                }\r\n\t            } else {\r\n\t                return false;\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /*\r\n\t         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)\r\n\t         *@param {Number} x - the x coordinates\r\n\t         *@param {Number} y - the y coordinates\r\n\t         *@param {Number} radius - the radius to search for\r\n\t         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n\t         *@see \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n\t         **/\r\n\t        near:function(x,y,radius){\r\n\t\r\n\t            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle\r\n\t                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)\r\n\t                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))\r\n\t                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;\r\n\t            }\r\n\t\r\n\t            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle\r\n\t                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)\r\n\t                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))\r\n\t                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;\r\n\t            }\r\n\t\r\n\t\r\n\t            var startX = Math.min(this.endPoint.x,this.startPoint.x);\r\n\t            var startY = Math.min(this.endPoint.y,this.startPoint.y);\r\n\t            var endX = Math.max(this.endPoint.x,this.startPoint.x);\r\n\t            var endY = Math.max(this.endPoint.y,this.startPoint.y);\r\n\t\r\n\t            /*We will compute the distance from point to the line\r\n\t             * by using the algorithm from\r\n\t             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n\t             * */\r\n\t\r\n\t            //First we need to find a,b,c of the line equation ax + by + c = 0\r\n\t            var a = this.endPoint.y - this.startPoint.y;\r\n\t            var b = this.startPoint.x - this.endPoint.x;\r\n\t            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);\r\n\t\r\n\t            //Secondly we get the distance \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n\t            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );\r\n\t\r\n\t            //Thirdly we get coordinates of closest line's point to target point\r\n\t            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates\r\n\t            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n\t            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n\t\r\n\t            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment\r\n\t                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment\r\n\t\r\n\t            return  r;\r\n\t\r\n\t        },\r\n\t\r\n\t        /**we need to create a new array each time, or we will affect the actual shape*/\r\n\t        getPoints:function(){\r\n\t            var points = [];\r\n\t            points.push(this.startPoint);\r\n\t            points.push(this.endPoint);\r\n\t            return points;\r\n\t        },\r\n\t\r\n\t        /**Return the {Point} corresponding the t certain t value\r\n\t         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/\r\n\t        getPoint: function(t){\r\n\t            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;\r\n\t            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;\r\n\t\r\n\t            return new Point(Xp, Yp);\r\n\t        },\r\n\t\r\n\t        // /**\r\n\t        //  * Returns the middle of the line\r\n\t        //  * @return {Point} the middle point\r\n\t        //  * */\r\n\t        // getMiddle : function(){\r\n\t        //     return Util.getMiddle(this.startPoint, this.endPoint);\r\n\t        // },\r\n\t\r\n\t\r\n\t        // getLength : function(){\r\n\t        //     return Util.getLength(this.startPoint, this.endPoint);\r\n\t        // },\r\n\t\r\n\t        // /**\r\n\t        //  *Get bounds for this line\r\n\t        //  *@author Alex Gheorghiu <alex@scriptoid.com>\r\n\t        //  **/\r\n\t        // getBounds:function(){\r\n\t        //     return Util.getBounds(this.getPoints());\r\n\t        // },\r\n\t\r\n\t        /**String representation*/\r\n\t        toString:function(){\r\n\t            return 'line(' + this.startPoint + ',' + this.endPoint + ')';\r\n\t        }\r\n\t    };\r\n\t    module.exports = Line;\r\n\t\r\n\t\r\n\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t\r\n\t    var apiList = [\r\n\t        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',\r\n\t        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',\r\n\t        \"remove\", \"_getParentZr\", \"changeSelectConnectorType\"\r\n\t    ];\r\n\t\r\n\t    function ExtensionAPI(instance) {\r\n\t        zrUtil.each(apiList, function (name) {\r\n\t            this[name] = zrUtil.bind(instance[name], instance);\r\n\t        }, this);\r\n\t    }\r\n\t\r\n\t    module.exports = ExtensionAPI;\r\n\t\r\n\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * ZRender, a high performance 2d drawing library.\n\t *\n\t * Copyright (c) 2013, Baidu Inc.\n\t * All rights reserved.\n\t *\n\t * LICENSE\n\t * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n\t */\n\t// Global defines\n\t\n\t    var guid = __webpack_require__(11);\n\t    var env = __webpack_require__(50);\n\t    var zrUtil = __webpack_require__(5);\n\t\n\t    var Handler = __webpack_require__(70);\n\t    var Storage = __webpack_require__(71);\n\t    var Animation = __webpack_require__(73);\n\t    var HandlerProxy = __webpack_require__(76);\n\t\n\t    var useVML = !env.canvasSupported;\n\t\n\t    var painterCtors = {\n\t        canvas: __webpack_require__(78)\n\t    };\n\t\n\t    var instances = {};    // ZRender实例map索引\n\t\n\t    var zrender = {};\n\t\n\t    /**\n\t     * @type {string}\n\t     */\n\t    zrender.version = '3.6.3';\n\t\n\t    /**\n\t     * Initializing a zrender instance\n\t     * @param {HTMLElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.init = function (dom, opts) {\n\t        var zr = new ZRender(guid(), dom, opts);\n\t        instances[zr.id] = zr;\n\t        return zr;\n\t    };\n\t\n\t    /**\n\t     * Dispose zrender instance\n\t     * @param {module:zrender/ZRender} zr\n\t     */\n\t    zrender.dispose = function (zr) {\n\t        if (zr) {\n\t            zr.dispose();\n\t        }\n\t        else {\n\t            for (var key in instances) {\n\t                if (instances.hasOwnProperty(key)) {\n\t                    instances[key].dispose();\n\t                }\n\t            }\n\t            instances = {};\n\t        }\n\t\n\t        return zrender;\n\t    };\n\t\n\t    /**\n\t     * Get zrender instance by id\n\t     * @param {string} id zrender instance id\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.getInstance = function (id) {\n\t        return instances[id];\n\t    };\n\t\n\t    zrender.registerPainter = function (name, Ctor) {\n\t        painterCtors[name] = Ctor;\n\t    };\n\t\n\t    function delInstance(id) {\n\t        delete instances[id];\n\t    }\n\t\n\t    /**\n\t     * @module zrender/ZRender\n\t     */\n\t    /**\n\t     * @constructor\n\t     * @alias module:zrender/ZRender\n\t     * @param {string} id\n\t     * @param {HTMLElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     */\n\t    var ZRender = function (id, dom, opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         */\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id = id;\n\t\n\t        var self = this;\n\t        var storage = new Storage();\n\t\n\t        var rendererType = opts.renderer;\n\t        // TODO WebGL\n\t        if (useVML) {\n\t            if (!painterCtors.vml) {\n\t                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t            }\n\t            rendererType = 'vml';\n\t        }\n\t        else if (!rendererType || !painterCtors[rendererType]) {\n\t            rendererType = 'canvas';\n\t        }\n\t        var painter = new painterCtors[rendererType](dom, storage, opts);\n\t\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t\n\t        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\t\n\t        /**\n\t         * @type {module:zrender/animation/Animation}\n\t         */\n\t        this.animation = new Animation({\n\t            stage: {\n\t                update: zrUtil.bind(this.flush, this)\n\t            }\n\t        });\n\t        this.animation.start();\n\t\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._needsRefresh;\n\t\n\t        // 修改 storage.delFromStorage, 每次删除元素之前删除动画\n\t        // FIXME 有点ugly\n\t        var oldDelFromStorage = storage.delFromStorage;\n\t        var oldAddToStorage = storage.addToStorage;\n\t\n\t        storage.delFromStorage = function (el) {\n\t            oldDelFromStorage.call(storage, el);\n\t\n\t            el && el.removeSelfFromZr(self);\n\t        };\n\t\n\t        storage.addToStorage = function (el) {\n\t            oldAddToStorage.call(storage, el);\n\t\n\t            el.addSelfToZr(self);\n\t        };\n\t    };\n\t\n\t    ZRender.prototype = {\n\t\n\t        constructor: ZRender,\n\t        /**\n\t         * 获取实例唯一标识\n\t         * @return {string}\n\t         */\n\t        getId: function () {\n\t            return this.id;\n\t        },\n\t\n\t        /**\n\t         * 添加元素\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        add: function (el) {\n\t            this.storage.addRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * 删除元素\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        remove: function (el) {\n\t            this.storage.delRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Change configuration of layer\n\t         * @param {string} zLevel\n\t         * @param {Object} config\n\t         * @param {string} [config.clearColor=0] Clear color\n\t         * @param {string} [config.motionBlur=false] If enable motion blur\n\t         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n\t        */\n\t        configLayer: function (zLevel, config) {\n\t            this.painter.configLayer(zLevel, config);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Repaint the canvas immediately\n\t         */\n\t        refreshImmediately: function () {\n\t            // var start = new Date();\n\t            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t            // Or it will cause zrender refreshes again and again.\n\t            this._needsRefresh = false;\n\t            this.painter.refresh();\n\t            /**\n\t             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t             */\n\t            this._needsRefresh = false;\n\t            // var end = new Date();\n\t\n\t            // var log = document.getElementById('log');\n\t            // if (log) {\n\t            //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n\t            // }\n\t        },\n\t\n\t        /**\n\t         * Mark and repaint the canvas in the next frame of browser\n\t         */\n\t        refresh: function() {\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Perform all refresh\n\t         */\n\t        flush: function () {\n\t            if (this._needsRefresh) {\n\t                this.refreshImmediately();\n\t            }\n\t            if (this._needsRefreshHover) {\n\t                this.refreshHoverImmediately();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add element to hover layer\n\t         * @param  {module:zrender/Element} el\n\t         * @param {Object} style\n\t         */\n\t        addHover: function (el, style) {\n\t            if (this.painter.addHover) {\n\t                this.painter.addHover(el, style);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add element from hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        removeHover: function (el) {\n\t            if (this.painter.removeHover) {\n\t                this.painter.removeHover(el);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clear all hover elements in hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        clearHover: function () {\n\t            if (this.painter.clearHover) {\n\t                this.painter.clearHover();\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Refresh hover in next frame\n\t         */\n\t        refreshHover: function () {\n\t            this._needsRefreshHover = true;\n\t        },\n\t\n\t        /**\n\t         * Refresh hover immediately\n\t         */\n\t        refreshHoverImmediately: function () {\n\t            this._needsRefreshHover = false;\n\t            this.painter.refreshHover && this.painter.refreshHover();\n\t        },\n\t\n\t        /**\n\t         * Resize the canvas.\n\t         * Should be invoked when container size is changed\n\t         * @param {Object} [opts]\n\t         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t         */\n\t        resize: function(opts) {\n\t            opts = opts || {};\n\t            this.painter.resize(opts.width, opts.height);\n\t            this.handler.resize();\n\t        },\n\t\n\t        /**\n\t         * Stop and clear all animation immediately\n\t         */\n\t        clearAnimation: function () {\n\t            this.animation.clear();\n\t        },\n\t\n\t        /**\n\t         * Get container width\n\t         */\n\t        getWidth: function() {\n\t            return this.painter.getWidth();\n\t        },\n\t\n\t        /**\n\t         * Get container height\n\t         */\n\t        getHeight: function() {\n\t            return this.painter.getHeight();\n\t        },\n\t\n\t        /**\n\t         * Export the canvas as Base64 URL\n\t         * @param {string} type\n\t         * @param {string} [backgroundColor='#fff']\n\t         * @return {string} Base64 URL\n\t         */\n\t        // toDataURL: function(type, backgroundColor) {\n\t        //     return this.painter.getRenderedCanvas({\n\t        //         backgroundColor: backgroundColor\n\t        //     }).toDataURL(type);\n\t        // },\n\t\n\t        /**\n\t         * Converting a path to image.\n\t         * It has much better performance of drawing image rather than drawing a vector path.\n\t         * @param {module:zrender/graphic/Path} e\n\t         * @param {number} width\n\t         * @param {number} height\n\t         */\n\t        pathToImage: function(e, dpr) {\n\t            return this.painter.pathToImage(e, dpr);\n\t        },\n\t\n\t        /**\n\t         * Set default cursor\n\t         * @param {string} [cursorStyle='default'] 例如 crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            this.handler.setCursorStyle(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * Find hovered element\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @return {Object} {target, topTarget}\n\t         */\n\t        findHover: function (x, y) {\n\t            return this.handler.findHover(x, y);\n\t        },\n\t\n\t        /**\n\t         * Bind event\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {Function} eventHandler Handler function\n\t         * @param {Object} [context] Context object\n\t         */\n\t        on: function(eventName, eventHandler, context) {\n\t            this.handler.on(eventName, eventHandler, context);\n\t        },\n\t\n\t        /**\n\t         * Unbind event\n\t         * @param {string} eventName Event name\n\t         * @param {Function} [eventHandler] Handler function\n\t         */\n\t        off: function(eventName, eventHandler) {\n\t            this.handler.off(eventName, eventHandler);\n\t        },\n\t\n\t        /**\n\t         * Trigger event manually\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {event=} event Event object\n\t         */\n\t        trigger: function (eventName, event) {\n\t            this.handler.trigger(eventName, event);\n\t        },\n\t\n\t\n\t        /**\n\t         * Clear all objects and the canvas.\n\t         */\n\t        clear: function () {\n\t            this.storage.delRoot();\n\t            this.painter.clear();\n\t        },\n\t\n\t        /**\n\t         * Dispose self.\n\t         */\n\t        dispose: function () {\n\t            this.animation.stop();\n\t\n\t            this.clear();\n\t            this.storage.dispose();\n\t            this.painter.dispose();\n\t            this.handler.dispose();\n\t\n\t            this.animation =\n\t            this.storage =\n\t            this.painter =\n\t            this.handler = null;\n\t\n\t            delInstance(this.id);\n\t        }\n\t    };\n\t\n\t    module.exports = zrender;\n\t\n\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Handler\n\t * @module zrender/Handler\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (shenyi.914@gmail.com)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(5);\n\t    var vec2 = __webpack_require__(15);\n\t    var Draggable = __webpack_require__(43);\n\t\n\t    var Eventful = __webpack_require__(12);\n\t\n\t    var SILENT = 'silent';\n\t\n\t    function makeEventPacket(eveType, targetInfo, event) {\n\t        return {\n\t            type: eveType,\n\t            event: event,\n\t            // target can only be an element that is not silent.\n\t            target: targetInfo.target,\n\t            // topTarget can be a silent element.\n\t            topTarget: targetInfo.topTarget,\n\t            cancelBubble: false,\n\t            offsetX: event.zrX,\n\t            offsetY: event.zrY,\n\t            gestureEvent: event.gestureEvent,\n\t            pinchX: event.pinchX,\n\t            pinchY: event.pinchY,\n\t            pinchScale: event.pinchScale,\n\t            wheelDelta: event.zrDelta,\n\t            zrByTouch: event.zrByTouch,\n\t            which: event.which\n\t        };\n\t    }\n\t\n\t    function EmptyProxy () {}\n\t    EmptyProxy.prototype.dispose = function () {};\n\t\n\t    var handlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n\t    ];\n\t    /**\n\t     * @alias module:zrender/Handler\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Eventful\n\t     * @param {module:zrender/Storage} storage Storage instance.\n\t     * @param {module:zrender/Painter} painter Painter instance.\n\t     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n\t     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n\t     */\n\t    var Handler = function(storage, painter, proxy, painterRoot) {\n\t        Eventful.call(this);\n\t\n\t        this.storage = storage;\n\t\n\t        this.painter = painter;\n\t\n\t        this.painterRoot = painterRoot;\n\t\n\t        proxy = proxy || new EmptyProxy();\n\t\n\t        /**\n\t         * Proxy of event. can be Dom, WebGLSurface, etc.\n\t         */\n\t        this.proxy = proxy;\n\t\n\t        // Attach handler\n\t        proxy.handler = this;\n\t\n\t        /**\n\t         * {target, topTarget, x, y}\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._hovered = {};\n\t\n\t        /**\n\t         * @private\n\t         * @type {Date}\n\t         */\n\t        this._lastTouchMoment;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastX;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastY;\n\t\n\t\n\t        Draggable.call(this);\n\t\n\t        util.each(handlerNames, function (name) {\n\t            proxy.on && proxy.on(name, this[name], this);\n\t        }, this);\n\t    };\n\t\n\t    Handler.prototype = {\n\t\n\t        constructor: Handler,\n\t\n\t        mousemove: function (event) {\n\t            var x = event.zrX;\n\t            var y = event.zrY;\n\t\n\t            var lastHovered = this._hovered;\n\t            var lastHoveredTarget = lastHovered.target;\n\t\n\t            // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n\t            // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n\t            // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n\t            // See #6198.\n\t            if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n\t                lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n\t                lastHoveredTarget = lastHovered.target;\n\t            }\n\t\n\t            var hovered = this._hovered = this.findHover(x, y);\n\t            var hoveredTarget = hovered.target;\n\t\n\t            var proxy = this.proxy;\n\t            proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');\n\t\n\t            // Mouse out on previous hovered element\n\t            if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n\t                this.dispatchToElement(lastHovered, 'mouseout', event);\n\t            }\n\t\n\t            // Mouse moving on one element\n\t            this.dispatchToElement(hovered, 'mousemove', event);\n\t\n\t            // Mouse over on a new element\n\t            if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n\t                this.dispatchToElement(hovered, 'mouseover', event);\n\t            }\n\t        },\n\t\n\t        mouseout: function (event) {\n\t            this.dispatchToElement(this._hovered, 'mouseout', event);\n\t\n\t            // There might be some doms created by upper layer application\n\t            // at the same level of painter.getViewportRoot() (e.g., tooltip\n\t            // dom created by echarts), where 'globalout' event should not\n\t            // be triggered when mouse enters these doms. (But 'mouseout'\n\t            // should be triggered at the original hovered element as usual).\n\t            var element = event.toElement || event.relatedTarget;\n\t            var innerDom;\n\t            do {\n\t                element = element && element.parentNode;\n\t            }\n\t            while (element && element.nodeType != 9 && !(\n\t                innerDom = element === this.painterRoot\n\t            ));\n\t\n\t            !innerDom && this.trigger('globalout', {event: event});\n\t        },\n\t\n\t        /**\n\t         * Resize\n\t         */\n\t        resize: function (event) {\n\t            this._hovered = {};\n\t        },\n\t\n\t        /**\n\t         * Dispatch event\n\t         * @param {string} eventName\n\t         * @param {event=} eventArgs\n\t         */\n\t        dispatch: function (eventName, eventArgs) {\n\t            var handler = this[eventName];\n\t            handler && handler.call(this, eventArgs);\n\t        },\n\t\n\t        /**\n\t         * Dispose\n\t         */\n\t        dispose: function () {\n\t\n\t            this.proxy.dispose();\n\t\n\t            this.storage =\n\t            this.proxy =\n\t            this.painter = null;\n\t        },\n\t\n\t        /**\n\t         * 设置默认的cursor style\n\t         * @param {string} [cursorStyle='default'] 例如 crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            var proxy = this.proxy;\n\t            proxy.setCursor && proxy.setCursor(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * 事件分发代理\n\t         *\n\t         * @private\n\t         * @param {Object} targetInfo {target, topTarget} 目标图形元素\n\t         * @param {string} eventName 事件名称\n\t         * @param {Object} event 事件对象\n\t         */\n\t        dispatchToElement: function (targetInfo, eventName, event) {\n\t            targetInfo = targetInfo || {};\n\t            var el = targetInfo.target;\n\t            if (el && el.silent) {\n\t                return;\n\t            }\n\t            var eventHandler = 'on' + eventName;\n\t            var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\t\n\t            while (el) {\n\t                el[eventHandler]\n\t                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t\n\t                el.trigger(eventName, eventPacket);\n\t\n\t                el = el.parent;\n\t\n\t                if (eventPacket.cancelBubble) {\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (!eventPacket.cancelBubble) {\n\t                // 冒泡到顶级 zrender 对象\n\t                this.trigger(eventName, eventPacket);\n\t                // 分发事件到用户自定义层\n\t                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\t                this.painter && this.painter.eachOtherLayer(function (layer) {\n\t                    if (typeof(layer[eventHandler]) == 'function') {\n\t                        layer[eventHandler].call(layer, eventPacket);\n\t                    }\n\t                    if (layer.trigger) {\n\t                        layer.trigger(eventName, eventPacket);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @param {module:zrender/graphic/Displayable} exclude\n\t         * @return {model:zrender/Element}\n\t         * @method\n\t         */\n\t        findHover: function(x, y, exclude) {\n\t            var list = this.storage.getDisplayList();\n\t            var out = {x: x, y: y};\n\t\n\t            for (var i = list.length - 1; i >= 0 ; i--) {\n\t                var hoverCheckResult;\n\t                if (list[i] !== exclude\n\t                    // getDisplayList may include ignored item in VML mode\n\t                    && !list[i].ignore\n\t                    && (hoverCheckResult = isHover(list[i], x, y))\n\t                ) {\n\t                    !out.topTarget && (out.topTarget = list[i]);\n\t                    if (hoverCheckResult !== SILENT) {\n\t                        out.target = list[i];\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return out;\n\t        }\n\t    };\n\t\n\t    // Common handlers\n\t    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t        Handler.prototype[name] = function (event) {\n\t            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t            var hovered = this.findHover(event.zrX, event.zrY);\n\t            var hoveredTarget = hovered.target;\n\t\n\t            if (name === 'mousedown') {\n\t                this._downEl = hoveredTarget;\n\t                this._downPoint = [event.zrX, event.zrY];\n\t                // In case click triggered before mouseup\n\t                this._upEl = hoveredTarget;\n\t            }\n\t            else if (name === 'mosueup') {\n\t                this._upEl = hoveredTarget;\n\t            }\n\t            else if (name === 'click') {\n\t                if (this._downEl !== this._upEl\n\t                    // Original click event is triggered on the whole canvas element,\n\t                    // including the case that `mousedown` - `mousemove` - `mouseup`,\n\t                    // which should be filtered, otherwise it will bring trouble to\n\t                    // pan and zoom.\n\t                    || !this._downPoint\n\t                    // Arbitrary value\n\t                    || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4\n\t                ) {\n\t                    return;\n\t                }\n\t                this._downPoint = null;\n\t            }\n\t\n\t            this.dispatchToElement(hovered, name, event);\n\t        };\n\t    });\n\t\n\t    function isHover(displayable, x, y) {\n\t        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t            var el = displayable;\n\t            var isSilent;\n\t            while (el) {\n\t                // If clipped by ancestor.\n\t                // FIXME: If clipPath has neither stroke nor fill,\n\t                // el.clipPath.contain(x, y) will always return false.\n\t                if (el.clipPath && !el.clipPath.contain(x, y))  {\n\t                    return false;\n\t                }\n\t                if (el.silent) {\n\t                    isSilent = true;\n\t                }\n\t                el = el.parent;\n\t            }\n\t            return isSilent ? SILENT : true;\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    util.mixin(Handler, Eventful);\n\t    util.mixin(Handler, Draggable);\n\t\n\t    module.exports = Handler;\n\t\n\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Storage内容仓库模块\n\t * @module zrender/Storage\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t * @author errorrik (errorrik@gmail.com)\n\t * @author pissang (https://github.com/pissang/)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(5);\n\t    var env = __webpack_require__(50);\n\t\n\t    var Group = __webpack_require__(44);\n\t\n\t    // Use timsort because in most case elements are partially sorted\n\t    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n\t    var timsort = __webpack_require__(72);\n\t\n\t    function shapeCompareFunc(a, b) {\n\t        if (a.zlevel === b.zlevel) {\n\t            if (a.z === b.z) {\n\t                // if (a.z2 === b.z2) {\n\t                //     // FIXME Slow has renderidx compare\n\t                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t                //     return a.__renderidx - b.__renderidx;\n\t                // }\n\t                return a.z2 - b.z2;\n\t            }\n\t            return a.z - b.z;\n\t        }\n\t        return a.zlevel - b.zlevel;\n\t    }\n\t    /**\n\t     * 内容仓库 (M)\n\t     * @alias module:zrender/Storage\n\t     * @constructor\n\t     */\n\t    var Storage = function () {\n\t        this._roots = [];\n\t\n\t        this._displayList = [];\n\t\n\t        this._displayListLen = 0;\n\t    };\n\t\n\t    Storage.prototype = {\n\t\n\t        constructor: Storage,\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         *\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._roots.length; i++) {\n\t                this._roots[i].traverse(cb, context);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 返回所有图形的绘制队列\n\t         * @param {boolean} [update=false] 是否在返回前更新该数组\n\t         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n\t         *\n\t         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n\t         * @return {Array.<module:zrender/graphic/Displayable>}\n\t         */\n\t        getDisplayList: function (update, includeIgnore) {\n\t            includeIgnore = includeIgnore || false;\n\t            if (update) {\n\t                this.updateDisplayList(includeIgnore);\n\t            }\n\t            return this._displayList;\n\t        },\n\t\n\t        /**\n\t         * 更新图形的绘制队列。\n\t         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n\t         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n\t         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n\t         */\n\t        updateDisplayList: function (includeIgnore) {\n\t            this._displayListLen = 0;\n\t            var roots = this._roots;\n\t            var displayList = this._displayList;\n\t            for (var i = 0, len = roots.length; i < len; i++) {\n\t                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t            }\n\t            displayList.length = this._displayListLen;\n\t\n\t            // for (var i = 0, len = displayList.length; i < len; i++) {\n\t            //     displayList[i].__renderidx = i;\n\t            // }\n\t\n\t            // displayList.sort(shapeCompareFunc);\n\t            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t        },\n\t\n\t        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t\n\t            if (el.ignore && !includeIgnore) {\n\t                return;\n\t            }\n\t\n\t            el.beforeUpdate();\n\t\n\t            if (el.__dirty) {\n\t\n\t                el.update();\n\t\n\t            }\n\t\n\t            el.afterUpdate();\n\t\n\t            var userSetClipPath = el.clipPath;\n\t            if (userSetClipPath) {\n\t\n\t                // FIXME 效率影响\n\t                if (clipPaths) {\n\t                    clipPaths = clipPaths.slice();\n\t                }\n\t                else {\n\t                    clipPaths = [];\n\t                }\n\t\n\t                var currentClipPath = userSetClipPath;\n\t                var parentClipPath = el;\n\t                // Recursively add clip path\n\t                while (currentClipPath) {\n\t                    // clipPath 的变换是基于使用这个 clipPath 的元素\n\t                    currentClipPath.parent = parentClipPath;\n\t                    currentClipPath.updateTransform();\n\t\n\t                    clipPaths.push(currentClipPath);\n\t\n\t                    parentClipPath = currentClipPath;\n\t                    currentClipPath = currentClipPath.clipPath;\n\t                }\n\t            }\n\t\n\t            if (el.isGroup) {\n\t                var children = el._children;\n\t\n\t                for (var i = 0; i < children.length; i++) {\n\t                    var child = children[i];\n\t\n\t                    // Force to mark as dirty if group is dirty\n\t                    // FIXME __dirtyPath ?\n\t                    if (el.__dirty) {\n\t                        child.__dirty = true;\n\t                    }\n\t\n\t                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t                }\n\t\n\t                // Mark group clean here\n\t                el.__dirty = false;\n\t\n\t            }\n\t            else {\n\t                el.__clipPaths = clipPaths;\n\t\n\t                this._displayList[this._displayListLen++] = el;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 添加图形(Shape)或者组(Group)到根节点\n\t         * @param {module:zrender/Element} el\n\t         */\n\t        addRoot: function (el) {\n\t            if (el.__storage === this) {\n\t                return;\n\t            }\n\t\n\t            if (el instanceof Group) {\n\t                el.addChildrenToStorage(this);\n\t            }\n\t\n\t            this.addToStorage(el);\n\t            this._roots.push(el);\n\t        },\n\t\n\t        /**\n\t         * 删除指定的图形(Shape)或者组(Group)\n\t         * @param {string|Array.<string>} [el] 如果为空清空整个Storage\n\t         */\n\t        delRoot: function (el) {\n\t            if (el == null) {\n\t                // 不指定el清空\n\t                for (var i = 0; i < this._roots.length; i++) {\n\t                    var root = this._roots[i];\n\t                    if (root instanceof Group) {\n\t                        root.delChildrenFromStorage(this);\n\t                    }\n\t                }\n\t\n\t                this._roots = [];\n\t                this._displayList = [];\n\t                this._displayListLen = 0;\n\t\n\t                return;\n\t            }\n\t\n\t            if (el instanceof Array) {\n\t                for (var i = 0, l = el.length; i < l; i++) {\n\t                    this.delRoot(el[i]);\n\t                }\n\t                return;\n\t            }\n\t\n\t\n\t            var idx = util.indexOf(this._roots, el);\n\t            if (idx >= 0) {\n\t                this.delFromStorage(el);\n\t                this._roots.splice(idx, 1);\n\t                if (el instanceof Group) {\n\t                    el.delChildrenFromStorage(this);\n\t                }\n\t            }\n\t        },\n\t\n\t        addToStorage: function (el) {\n\t            el.__storage = this;\n\t            el.dirty(false);\n\t\n\t            return this;\n\t        },\n\t\n\t        delFromStorage: function (el) {\n\t            if (el) {\n\t                el.__storage = null;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 清空并且释放Storage\n\t         */\n\t        dispose: function () {\n\t            this._renderList =\n\t            this._roots = null;\n\t        },\n\t\n\t        displayableSortFunc: shapeCompareFunc\n\t    };\n\t\n\t    module.exports = Storage;\n\t\n\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports) {\n\n\t// https://github.com/mziccard/node-timsort\n\t\n\t    var DEFAULT_MIN_MERGE = 32;\n\t\n\t    var DEFAULT_MIN_GALLOPING = 7;\n\t\n\t    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t\n\t    function minRunLength(n) {\n\t        var r = 0;\n\t\n\t        while (n >= DEFAULT_MIN_MERGE) {\n\t            r |= n & 1;\n\t            n >>= 1;\n\t        }\n\t\n\t        return n + r;\n\t    }\n\t\n\t    function makeAscendingRun(array, lo, hi, compare) {\n\t        var runHi = lo + 1;\n\t\n\t        if (runHi === hi) {\n\t            return 1;\n\t        }\n\t\n\t        if (compare(array[runHi++], array[lo]) < 0) {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t                runHi++;\n\t            }\n\t\n\t            reverseRun(array, lo, runHi);\n\t        }\n\t        else {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t                runHi++;\n\t            }\n\t        }\n\t\n\t        return runHi - lo;\n\t    }\n\t\n\t    function reverseRun(array, lo, hi) {\n\t        hi--;\n\t\n\t        while (lo < hi) {\n\t            var t = array[lo];\n\t            array[lo++] = array[hi];\n\t            array[hi--] = t;\n\t        }\n\t    }\n\t\n\t    function binaryInsertionSort(array, lo, hi, start, compare) {\n\t        if (start === lo) {\n\t            start++;\n\t        }\n\t\n\t        for (; start < hi; start++) {\n\t            var pivot = array[start];\n\t\n\t            var left = lo;\n\t            var right = start;\n\t            var mid;\n\t\n\t            while (left < right) {\n\t                mid = left + right >>> 1;\n\t\n\t                if (compare(pivot, array[mid]) < 0) {\n\t                    right = mid;\n\t                }\n\t                else {\n\t                    left = mid + 1;\n\t                }\n\t            }\n\t\n\t            var n = start - left;\n\t\n\t            switch (n) {\n\t                case 3:\n\t                    array[left + 3] = array[left + 2];\n\t\n\t                case 2:\n\t                    array[left + 2] = array[left + 1];\n\t\n\t                case 1:\n\t                    array[left + 1] = array[left];\n\t                    break;\n\t                default:\n\t                    while (n > 0) {\n\t                        array[left + n] = array[left + n - 1];\n\t                        n--;\n\t                    }\n\t            }\n\t\n\t            array[left] = pivot;\n\t        }\n\t    }\n\t\n\t    function gallopLeft(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) > 0) {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t        else {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) > 0) {\n\t                lastOffset = m + 1;\n\t            }\n\t            else {\n\t                offset = m;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t\n\t    function gallopRight(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) < 0) {\n\t            maxOffset = hint + 1;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t        else {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t\n\t        lastOffset++;\n\t\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) < 0) {\n\t                offset = m;\n\t            }\n\t            else {\n\t                lastOffset = m + 1;\n\t            }\n\t        }\n\t\n\t        return offset;\n\t    }\n\t\n\t    function TimSort(array, compare) {\n\t        var minGallop = DEFAULT_MIN_GALLOPING;\n\t        var length = 0;\n\t        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t        var stackLength = 0;\n\t        var runStart;\n\t        var runLength;\n\t        var stackSize = 0;\n\t\n\t        length = array.length;\n\t\n\t        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t            tmpStorageLength = length >>> 1;\n\t        }\n\t\n\t        var tmp = [];\n\t\n\t        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t\n\t        runStart = [];\n\t        runLength = [];\n\t\n\t        function pushRun(_runStart, _runLength) {\n\t            runStart[stackSize] = _runStart;\n\t            runLength[stackSize] = _runLength;\n\t            stackSize += 1;\n\t        }\n\t\n\t        function mergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t                    if (runLength[n - 1] < runLength[n + 1]) {\n\t                        n--;\n\t                    }\n\t                }\n\t                else if (runLength[n] > runLength[n + 1]) {\n\t                    break;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function forceMergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t                    n--;\n\t                }\n\t\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function mergeAt(i) {\n\t            var start1 = runStart[i];\n\t            var length1 = runLength[i];\n\t            var start2 = runStart[i + 1];\n\t            var length2 = runLength[i + 1];\n\t\n\t            runLength[i] = length1 + length2;\n\t\n\t            if (i === stackSize - 3) {\n\t                runStart[i + 1] = runStart[i + 2];\n\t                runLength[i + 1] = runLength[i + 2];\n\t            }\n\t\n\t            stackSize--;\n\t\n\t            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t            start1 += k;\n\t            length1 -= k;\n\t\n\t            if (length1 === 0) {\n\t                return;\n\t            }\n\t\n\t            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t\n\t            if (length2 === 0) {\n\t                return;\n\t            }\n\t\n\t            if (length1 <= length2) {\n\t                mergeLow(start1, length1, start2, length2);\n\t            }\n\t            else {\n\t                mergeHigh(start1, length1, start2, length2);\n\t            }\n\t        }\n\t\n\t        function mergeLow(start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length1; i++) {\n\t                tmp[i] = array[start1 + i];\n\t            }\n\t\n\t            var cursor1 = 0;\n\t            var cursor2 = start2;\n\t            var dest = start1;\n\t\n\t            array[dest++] = array[cursor2++];\n\t\n\t            if (--length2 === 0) {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t                return;\n\t            }\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t            var count1, count2, exit;\n\t\n\t            while (1) {\n\t                count1 = 0;\n\t                count2 = 0;\n\t                exit = false;\n\t\n\t                do {\n\t                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t                        array[dest++] = array[cursor2++];\n\t                        count2++;\n\t                        count1 = 0;\n\t\n\t                        if (--length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest++] = tmp[cursor1++];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        for (i = 0; i < count1; i++) {\n\t                            array[dest + i] = tmp[cursor1 + i];\n\t                        }\n\t\n\t                        dest += count1;\n\t                        cursor1 += count1;\n\t                        length1 -= count1;\n\t                        if (length1 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest++] = array[cursor2++];\n\t\n\t                    if (--length2 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[dest + i] = array[cursor2 + i];\n\t                        }\n\t\n\t                        dest += count2;\n\t                        cursor2 += count2;\n\t                        length2 -= count2;\n\t\n\t                        if (length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = tmp[cursor1++];\n\t\n\t                    if (--length1 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            minGallop < 1 && (minGallop = 1);\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t            }\n\t            else if (length1 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeLow preconditions were not respected');\n\t            }\n\t            else {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t            }\n\t        }\n\t\n\t        function mergeHigh (start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length2; i++) {\n\t                tmp[i] = array[start2 + i];\n\t            }\n\t\n\t            var cursor1 = start1 + length1 - 1;\n\t            var cursor2 = length2 - 1;\n\t            var dest = start2 + length2 - 1;\n\t            var customCursor = 0;\n\t            var customDest = 0;\n\t\n\t            array[dest--] = array[cursor1--];\n\t\n\t            if (--length1 === 0) {\n\t                customCursor = dest - (length2 - 1);\n\t\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t\n\t            while (true) {\n\t                var count1 = 0;\n\t                var count2 = 0;\n\t                var exit = false;\n\t\n\t                do {\n\t                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t                        array[dest--] = array[cursor1--];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest--] = tmp[cursor2--];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        dest -= count1;\n\t                        cursor1 -= count1;\n\t                        length1 -= count1;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor1 + 1;\n\t\n\t                        for (i = count1 - 1; i >= 0; i--) {\n\t                            array[customDest + i] = array[customCursor + i];\n\t                        }\n\t\n\t                        if (length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = tmp[cursor2--];\n\t\n\t                    if (--length2 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        dest -= count2;\n\t                        cursor2 -= count2;\n\t                        length2 -= count2;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor2 + 1;\n\t\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[customDest + i] = tmp[customCursor + i];\n\t                        }\n\t\n\t                        if (length2 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = array[cursor1--];\n\t\n\t                    if (--length1 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            if (minGallop < 1) {\n\t                minGallop = 1;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t            }\n\t            else if (length2 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeHigh preconditions were not respected');\n\t            }\n\t            else {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t            }\n\t        }\n\t\n\t        this.mergeRuns = mergeRuns;\n\t        this.forceMergeRuns = forceMergeRuns;\n\t        this.pushRun = pushRun;\n\t    }\n\t\n\t    function sort(array, compare, lo, hi) {\n\t        if (!lo) {\n\t            lo = 0;\n\t        }\n\t        if (!hi) {\n\t            hi = array.length;\n\t        }\n\t\n\t        var remaining = hi - lo;\n\t\n\t        if (remaining < 2) {\n\t            return;\n\t        }\n\t\n\t        var runLength = 0;\n\t\n\t        if (remaining < DEFAULT_MIN_MERGE) {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t            return;\n\t        }\n\t\n\t        var ts = new TimSort(array, compare);\n\t\n\t        var minRun = minRunLength(remaining);\n\t\n\t        do {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            if (runLength < minRun) {\n\t                var force = remaining;\n\t                if (force > minRun) {\n\t                    force = minRun;\n\t                }\n\t\n\t                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t                runLength = force;\n\t            }\n\t\n\t            ts.pushRun(lo, runLength);\n\t            ts.mergeRuns();\n\t\n\t            remaining -= runLength;\n\t            lo += runLength;\n\t        } while (remaining !== 0);\n\t\n\t        ts.forceMergeRuns();\n\t    }\n\t\n\t    module.exports = sort;\n\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 动画主类, 调度和管理所有动画控制器\n\t *\n\t * @module zrender/animation/Animation\n\t * @author pissang(https://github.com/pissang)\n\t */\n\t// TODO Additive animation\n\t// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n\t// https://developer.apple.com/videos/wwdc2014/#236\n\t\n\t\n\t    var util = __webpack_require__(5);\n\t    var Dispatcher = __webpack_require__(74).Dispatcher;\n\t\n\t    var requestAnimationFrame = __webpack_require__(75);\n\t\n\t    var Animator = __webpack_require__(17);\n\t    /**\n\t     * @typedef {Object} IZRenderStage\n\t     * @property {Function} update\n\t     */\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animation\n\t     * @constructor\n\t     * @param {Object} [options]\n\t     * @param {Function} [options.onframe]\n\t     * @param {IZRenderStage} [options.stage]\n\t     * @example\n\t     *     var animation = new Animation();\n\t     *     var obj = {\n\t     *         x: 100,\n\t     *         y: 100\n\t     *     };\n\t     *     animation.animate(node.position)\n\t     *         .when(1000, {\n\t     *             x: 500,\n\t     *             y: 500\n\t     *         })\n\t     *         .when(2000, {\n\t     *             x: 100,\n\t     *             y: 100\n\t     *         })\n\t     *         .start('spline');\n\t     */\n\t    var Animation = function (options) {\n\t\n\t        options = options || {};\n\t\n\t        this.stage = options.stage || {};\n\t\n\t        this.onframe = options.onframe || function() {};\n\t\n\t        // private properties\n\t        this._clips = [];\n\t\n\t        this._running = false;\n\t\n\t        this._time;\n\t\n\t        this._pausedTime;\n\t\n\t        this._pauseStart;\n\t\n\t        this._paused = false;\n\t\n\t        Dispatcher.call(this);\n\t    };\n\t\n\t    Animation.prototype = {\n\t\n\t        constructor: Animation,\n\t        /**\n\t         * 添加 clip\n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        addClip: function (clip) {\n\t            this._clips.push(clip);\n\t        },\n\t        /**\n\t         * 添加 animator\n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        addAnimator: function (animator) {\n\t            animator.animation = this;\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.addClip(clips[i]);\n\t            }\n\t        },\n\t        /**\n\t         * 删除动画片段\n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        removeClip: function(clip) {\n\t            var idx = util.indexOf(this._clips, clip);\n\t            if (idx >= 0) {\n\t                this._clips.splice(idx, 1);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 删除动画片段\n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        removeAnimator: function (animator) {\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.removeClip(clips[i]);\n\t            }\n\t            animator.animation = null;\n\t        },\n\t\n\t        _update: function() {\n\t\n\t            var time = new Date().getTime() - this._pausedTime;\n\t            var delta = time - this._time;\n\t            var clips = this._clips;\n\t            var len = clips.length;\n\t\n\t            var deferredEvents = [];\n\t            var deferredClips = [];\n\t            for (var i = 0; i < len; i++) {\n\t                var clip = clips[i];\n\t                var e = clip.step(time, delta);\n\t                // Throw out the events need to be called after\n\t                // stage.update, like destroy\n\t                if (e) {\n\t                    deferredEvents.push(e);\n\t                    deferredClips.push(clip);\n\t                }\n\t            }\n\t\n\t            // Remove the finished clip\n\t            for (var i = 0; i < len;) {\n\t                if (clips[i]._needsRemove) {\n\t                    clips[i] = clips[len - 1];\n\t                    clips.pop();\n\t                    len--;\n\t                }\n\t                else {\n\t                    i++;\n\t                }\n\t            }\n\t\n\t            len = deferredEvents.length;\n\t            for (var i = 0; i < len; i++) {\n\t                deferredClips[i].fire(deferredEvents[i]);\n\t            }\n\t\n\t            this._time = time;\n\t\n\t            this.onframe(delta);\n\t\n\t            this.trigger('frame', delta);\n\t\n\t            if (this.stage.update) {\n\t                this.stage.update();\n\t            }\n\t        },\n\t\n\t        _startLoop: function () {\n\t            var self = this;\n\t\n\t            this._running = true;\n\t\n\t            function step() {\n\t                if (self._running) {\n\t\n\t                    requestAnimationFrame(step);\n\t\n\t                    !self._paused && self._update();\n\t                }\n\t            }\n\t\n\t            requestAnimationFrame(step);\n\t        },\n\t\n\t        /**\n\t         * 开始运行动画\n\t         */\n\t        start: function () {\n\t\n\t            this._time = new Date().getTime();\n\t            this._pausedTime = 0;\n\t\n\t            this._startLoop();\n\t        },\n\t        /**\n\t         * 停止运行动画\n\t         */\n\t        stop: function () {\n\t            this._running = false;\n\t        },\n\t\n\t        /**\n\t         * Pause\n\t         */\n\t        pause: function () {\n\t            if (!this._paused) {\n\t                this._pauseStart = new Date().getTime();\n\t                this._paused = true;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Resume\n\t         */\n\t        resume: function () {\n\t            if (this._paused) {\n\t                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n\t                this._paused = false;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 清除所有动画片段\n\t         */\n\t        clear: function () {\n\t            this._clips = [];\n\t        },\n\t        /**\n\t         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n\t         * @param  {Object} target\n\t         * @param  {Object} options\n\t         * @param  {boolean} [options.loop=false] 是否循环播放动画\n\t         * @param  {Function} [options.getter=null]\n\t         *         如果指定getter函数，会通过getter函数取属性值\n\t         * @param  {Function} [options.setter=null]\n\t         *         如果指定setter函数，会通过setter函数设置属性值\n\t         * @return {module:zrender/animation/Animation~Animator}\n\t         */\n\t        // TODO Gap\n\t        animate: function (target, options) {\n\t            options = options || {};\n\t\n\t            var animator = new Animator(\n\t                target,\n\t                options.loop,\n\t                options.getter,\n\t                options.setter\n\t            );\n\t\n\t            this.addAnimator(animator);\n\t\n\t            return animator;\n\t        }\n\t    };\n\t\n\t    util.mixin(Animation, Dispatcher);\n\t\n\t    module.exports = Animation;\n\t\n\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 事件辅助类\n\t * @module zrender/core/event\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t */\n\t\n\t\n\t    var Eventful = __webpack_require__(12);\n\t    var env = __webpack_require__(50);\n\t\n\t    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\t\n\t    var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n\t\n\t    function getBoundingClientRect(el) {\n\t        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n\t    }\n\t\n\t    // `calculate` is optional, default false\n\t    function clientToLocal(el, e, out, calculate) {\n\t        out = out || {};\n\t\n\t        // According to the W3C Working Draft, offsetX and offsetY should be relative\n\t        // to the padding edge of the target element. The only browser using this convention\n\t        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n\t        // not support the properties.\n\t        // (see http://www.jacklmoore.com/notes/mouse-position/)\n\t        // In zr painter.dom, padding edge equals to border edge.\n\t\n\t        // FIXME\n\t        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n\t        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n\t        // is too complex. So css-transfrom dont support in this case temporarily.\n\t        if (calculate || !env.canvasSupported) {\n\t            defaultGetZrXY(el, e, out);\n\t        }\n\t        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n\t        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n\t        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n\t        // zoom-factor, overflow / opacity layers, transforms ...)\n\t        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n\t        // <https://bugs.jquery.com/ticket/8523#comment:14>\n\t        // BTW3, In ff, offsetX/offsetY is always 0.\n\t        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n\t            out.zrX = e.layerX;\n\t            out.zrY = e.layerY;\n\t        }\n\t        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n\t        else if (e.offsetX != null) {\n\t            out.zrX = e.offsetX;\n\t            out.zrY = e.offsetY;\n\t        }\n\t        // For some other device, e.g., IOS safari.\n\t        else {\n\t            defaultGetZrXY(el, e, out);\n\t        }\n\t\n\t        return out;\n\t    }\n\t\n\t    function defaultGetZrXY(el, e, out) {\n\t        // This well-known method below does not support css transform.\n\t        var box = getBoundingClientRect(el);\n\t        out.zrX = e.clientX - box.left;\n\t        out.zrY = e.clientY - box.top;\n\t    }\n\t\n\t    /**\n\t     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.\n\t     * `calculate` is optional, default false.\n\t     */\n\t    function normalizeEvent(el, e, calculate) {\n\t\n\t        e = e || window.event;\n\t\n\t        if (e.zrX != null) {\n\t            return e;\n\t        }\n\t\n\t        var eventType = e.type;\n\t        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t\n\t        if (!isTouch) {\n\t            clientToLocal(el, e, e, calculate);\n\t            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t        }\n\t        else {\n\t            var touch = eventType != 'touchend'\n\t                ? e.targetTouches[0]\n\t                : e.changedTouches[0];\n\t            touch && clientToLocal(el, touch, e, calculate);\n\t        }\n\t\n\t        // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n\t        // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n\t        // If e.which has been defined, if may be readonly,\n\t        // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\t        var button = e.button;\n\t        if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n\t            e.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));\n\t        }\n\t\n\t        return e;\n\t    }\n\t\n\t    function addEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.addEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.attachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    function removeEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.removeEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.detachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * preventDefault and stopPropagation.\n\t     * Notice: do not do that in zrender. Upper application\n\t     * do that if necessary.\n\t     *\n\t     * @memberOf module:zrender/core/event\n\t     * @method\n\t     * @param {Event} e : event对象\n\t     */\n\t    var stop = isDomLevel2\n\t        ? function (e) {\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\t            e.cancelBubble = true;\n\t        }\n\t        : function (e) {\n\t            e.returnValue = false;\n\t            e.cancelBubble = true;\n\t        };\n\t\n\t    function notLeftMouse(e) {\n\t        // If e.which is undefined, considered as left mouse event.\n\t        return e.which > 1;\n\t    }\n\t\n\t    module.exports = {\n\t        clientToLocal: clientToLocal,\n\t        normalizeEvent: normalizeEvent,\n\t        addEventListener: addEventListener,\n\t        removeEventListener: removeEventListener,\n\t        notLeftMouse: notLeftMouse,\n\t\n\t        stop: stop,\n\t        // 做向上兼容\n\t        Dispatcher: Eventful\n\t    };\n\t\n\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports) {\n\n\t\n\t\n\t    module.exports = (typeof window !== 'undefined' &&\n\t                ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window))\n\t                // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\n\t                || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))\n\t                || window.mozRequestAnimationFrame\n\t                || window.webkitRequestAnimationFrame)\n\t            )\n\t            || function (func) {\n\t                setTimeout(func, 16);\n\t            };\n\t\n\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var eventTool = __webpack_require__(74);\n\t    var zrUtil = __webpack_require__(5);\n\t    var Eventful = __webpack_require__(12);\n\t    var env = __webpack_require__(50);\n\t    var GestureMgr = __webpack_require__(77);\n\t\n\t    var addEventListener = eventTool.addEventListener;\n\t    var removeEventListener = eventTool.removeEventListener;\n\t    var normalizeEvent = eventTool.normalizeEvent;\n\t\n\t    var TOUCH_CLICK_DELAY = 300;\n\t\n\t    var mouseHandlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n\t    ];\n\t\n\t    var touchHandlerNames = [\n\t        'touchstart', 'touchend', 'touchmove'\n\t    ];\n\t\n\t    var pointerEventNames = {\n\t        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n\t    };\n\t\n\t    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n\t        var nm = name.replace('mouse', 'pointer');\n\t        return pointerEventNames[nm] ? nm : name;\n\t    });\n\t\n\t    function eventNameFix(name) {\n\t        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n\t    }\n\t\n\t    function processGesture(proxy, event, stage) {\n\t        var gestureMgr = proxy._gestureMgr;\n\t\n\t        stage === 'start' && gestureMgr.clear();\n\t\n\t        var gestureInfo = gestureMgr.recognize(\n\t            event,\n\t            proxy.handler.findHover(event.zrX, event.zrY, null).target,\n\t            proxy.dom\n\t        );\n\t\n\t        stage === 'end' && gestureMgr.clear();\n\t\n\t        // Do not do any preventDefault here. Upper application do that if necessary.\n\t        if (gestureInfo) {\n\t            var type = gestureInfo.type;\n\t            event.gestureEvent = type;\n\t\n\t            proxy.handler.dispatchToElement({target: gestureInfo.target}, type, gestureInfo.event);\n\t        }\n\t    }\n\t\n\t    // function onMSGestureChange(proxy, event) {\n\t    //     if (event.translationX || event.translationY) {\n\t    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n\t    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n\t    //     }\n\t    //     if (event.scale !== 1) {\n\t    //         event.pinchX = event.offsetX;\n\t    //         event.pinchY = event.offsetY;\n\t    //         event.pinchScale = event.scale;\n\t    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n\t    //     }\n\t    // }\n\t\n\t    /**\n\t     * Prevent mouse event from being dispatched after Touch Events action\n\t     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t     * Result: Blocking Mouse Events for 700ms.\n\t     */\n\t    function setTouchTimer(instance) {\n\t        instance._touching = true;\n\t        clearTimeout(instance._touchTimer);\n\t        instance._touchTimer = setTimeout(function () {\n\t            instance._touching = false;\n\t        }, 700);\n\t    }\n\t\n\t\n\t    var domHandlers = {\n\t        /**\n\t         * Mouse move handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mousemove: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            this.trigger('mousemove', event);\n\t        },\n\t\n\t        /**\n\t         * Mouse out handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mouseout: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            var element = event.toElement || event.relatedTarget;\n\t            if (element != this.dom) {\n\t                while (element && element.nodeType != 9) {\n\t                    // 忽略包含在root中的dom引起的mouseOut\n\t                    if (element === this.dom) {\n\t                        return;\n\t                    }\n\t\n\t                    element = element.parentNode;\n\t                }\n\t            }\n\t\n\t            this.trigger('mouseout', event);\n\t        },\n\t\n\t        /**\n\t         * Touch开始响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchstart: function (event) {\n\t            // Default mouse behaviour should not be disabled here.\n\t            // For example, page may needs to be slided.\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            this._lastTouchMoment = new Date();\n\t\n\t            processGesture(this, event, 'start');\n\t\n\t            // In touch device, trigger `mousemove`(`mouseover`) should\n\t            // be triggered, and must before `mousedown` triggered.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            domHandlers.mousedown.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch移动响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchmove: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            processGesture(this, event, 'change');\n\t\n\t            // Mouse move should always be triggered no matter whether\n\t            // there is gestrue event, because mouse move and pinch may\n\t            // be used at the same time.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch结束响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchend: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            processGesture(this, event, 'end');\n\t\n\t            domHandlers.mouseup.call(this, event);\n\t\n\t            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n\t            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n\t            // we can conveniently implement \"hover style\" in both PC and touch device just\n\t            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n\t            // to remove \"hover style\" on an element, without any additional code for\n\t            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n\t            // style\" will remain for user view)\n\t\n\t            // click event should always be triggered no matter whether\n\t            // there is gestrue event. System click can not be prevented.\n\t            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t                domHandlers.click.call(this, event);\n\t            }\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        pointerdown: function (event) {\n\t            domHandlers.mousedown.call(this, event);\n\t\n\t            // if (useMSGuesture(this, event)) {\n\t            //     this._msGesture.addPointer(event.pointerId);\n\t            // }\n\t        },\n\t\n\t        pointermove: function (event) {\n\t            // FIXME\n\t            // pointermove is so sensitive that it always triggered when\n\t            // tap(click) on touch screen, which affect some judgement in\n\t            // upper application. So, we dont support mousemove on MS touch\n\t            // device yet.\n\t            if (!isPointerFromTouch(event)) {\n\t                domHandlers.mousemove.call(this, event);\n\t            }\n\t        },\n\t\n\t        pointerup: function (event) {\n\t            domHandlers.mouseup.call(this, event);\n\t        },\n\t\n\t        pointerout: function (event) {\n\t            // pointerout will be triggered when tap on touch screen\n\t            // (IE11+/Edge on MS Surface) after click event triggered,\n\t            // which is inconsistent with the mousout behavior we defined\n\t            // in touchend. So we unify them.\n\t            // (check domHandlers.touchend for detailed explanation)\n\t            if (!isPointerFromTouch(event)) {\n\t                domHandlers.mouseout.call(this, event);\n\t            }\n\t        }\n\t    };\n\t\n\t    function isPointerFromTouch(event) {\n\t        var pointerType = event.pointerType;\n\t        return pointerType === 'pen' || pointerType === 'touch';\n\t    }\n\t\n\t    // function useMSGuesture(handlerProxy, event) {\n\t    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n\t    // }\n\t\n\t    // Common handlers\n\t    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t        domHandlers[name] = function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t            this.trigger(name, event);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * 为控制类实例初始化dom 事件处理函数\n\t     *\n\t     * @inner\n\t     * @param {module:zrender/Handler} instance 控制类实例\n\t     */\n\t    function initDomHandler(instance) {\n\t        zrUtil.each(touchHandlerNames, function (name) {\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        });\n\t\n\t        zrUtil.each(pointerHandlerNames, function (name) {\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        });\n\t\n\t        zrUtil.each(mouseHandlerNames, function (name) {\n\t            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t        });\n\t\n\t        function makeMouseHandler(fn, instance) {\n\t            return function () {\n\t                if (instance._touching) {\n\t                    return;\n\t                }\n\t                return fn.apply(instance, arguments);\n\t            };\n\t        }\n\t    }\n\t\n\t\n\t    function HandlerDomProxy(dom) {\n\t        Eventful.call(this);\n\t\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._touching = false;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._touchTimer;\n\t\n\t        /**\n\t         * @private\n\t         * @type {module:zrender/core/GestureMgr}\n\t         */\n\t        this._gestureMgr = new GestureMgr();\n\t\n\t        this._handlers = {};\n\t\n\t        initDomHandler(this);\n\t\n\t        if (env.pointerEventsSupported) { // Only IE11+/Edge\n\t            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n\t            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n\t            // at the same time.\n\t            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n\t            // screen, which do not occurs in pointer event.\n\t            // So we use pointer event to both detect touch gesture and mouse behavior.\n\t            mountHandlers(pointerHandlerNames, this);\n\t\n\t            // FIXME\n\t            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n\t            // which does not prevent defuault behavior occasionally (which may cause view port\n\t            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n\t            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n\t            // touch screen. And we only support click behavior on MS touch screen now.\n\t\n\t            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n\t            // We dont support touch on IE on win7.\n\t            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n\t            // if (typeof MSGesture === 'function') {\n\t            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n\t            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n\t            // }\n\t        }\n\t        else {\n\t            if (env.touchEventsSupported) {\n\t                mountHandlers(touchHandlerNames, this);\n\t                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t            }\n\t\n\t            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n\t            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t            // mouse event can not be handle in those devices.\n\t            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n\t            // mouseevent after touch event triggered, see `setTouchTimer`.\n\t            mountHandlers(mouseHandlerNames, this);\n\t        }\n\t\n\t        function mountHandlers(handlerNames, instance) {\n\t            zrUtil.each(handlerNames, function (name) {\n\t                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t            }, instance);\n\t        }\n\t    }\n\t\n\t    var handlerDomProxyProto = HandlerDomProxy.prototype;\n\t    handlerDomProxyProto.dispose = function () {\n\t        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t\n\t        for (var i = 0; i < handlerNames.length; i++) {\n\t            var name = handlerNames[i];\n\t            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t        }\n\t    };\n\t\n\t    handlerDomProxyProto.setCursor = function (cursorStyle) {\n\t        this.dom.style.cursor = cursorStyle || 'default';\n\t    };\n\t\n\t    zrUtil.mixin(HandlerDomProxy, Eventful);\n\t\n\t    module.exports = HandlerDomProxy;\n\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Only implements needed gestures for mobile.\n\t */\n\t\n\t\n\t    var eventUtil = __webpack_require__(74);\n\t\n\t    var GestureMgr = function () {\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._track = [];\n\t    };\n\t\n\t    GestureMgr.prototype = {\n\t\n\t        constructor: GestureMgr,\n\t\n\t        recognize: function (event, target, root) {\n\t            this._doTrack(event, target, root);\n\t            return this._recognize(event);\n\t        },\n\t\n\t        clear: function () {\n\t            this._track.length = 0;\n\t            return this;\n\t        },\n\t\n\t        _doTrack: function (event, target, root) {\n\t            var touches = event.touches;\n\t\n\t            if (!touches) {\n\t                return;\n\t            }\n\t\n\t            var trackItem = {\n\t                points: [],\n\t                touches: [],\n\t                target: target,\n\t                event: event\n\t            };\n\t\n\t            for (var i = 0, len = touches.length; i < len; i++) {\n\t                var touch = touches[i];\n\t                var pos = eventUtil.clientToLocal(root, touch, {});\n\t                trackItem.points.push([pos.zrX, pos.zrY]);\n\t                trackItem.touches.push(touch);\n\t            }\n\t\n\t            this._track.push(trackItem);\n\t        },\n\t\n\t        _recognize: function (event) {\n\t            for (var eventName in recognizers) {\n\t                if (recognizers.hasOwnProperty(eventName)) {\n\t                    var gestureInfo = recognizers[eventName](this._track, event);\n\t                    if (gestureInfo) {\n\t                        return gestureInfo;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    function dist(pointPair) {\n\t        var dx = pointPair[1][0] - pointPair[0][0];\n\t        var dy = pointPair[1][1] - pointPair[0][1];\n\t\n\t        return Math.sqrt(dx * dx + dy * dy);\n\t    }\n\t\n\t    function center(pointPair) {\n\t        return [\n\t            (pointPair[0][0] + pointPair[1][0]) / 2,\n\t            (pointPair[0][1] + pointPair[1][1]) / 2\n\t        ];\n\t    }\n\t\n\t    var recognizers = {\n\t\n\t        pinch: function (track, event) {\n\t            var trackLen = track.length;\n\t\n\t            if (!trackLen) {\n\t                return;\n\t            }\n\t\n\t            var pinchEnd = (track[trackLen - 1] || {}).points;\n\t            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t\n\t            if (pinchPre\n\t                && pinchPre.length > 1\n\t                && pinchEnd\n\t                && pinchEnd.length > 1\n\t            ) {\n\t                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t                !isFinite(pinchScale) && (pinchScale = 1);\n\t\n\t                event.pinchScale = pinchScale;\n\t\n\t                var pinchCenter = center(pinchEnd);\n\t                event.pinchX = pinchCenter[0];\n\t                event.pinchY = pinchCenter[1];\n\t\n\t                return {\n\t                    type: 'pinch',\n\t                    target: track[0].target,\n\t                    event: event\n\t                };\n\t            }\n\t        }\n\t\n\t        // Only pinch currently.\n\t    };\n\t\n\t    module.exports = GestureMgr;\n\t\n\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Default canvas painter\n\t * @module zrender/Painter\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t \n\t\n\t    var config = __webpack_require__(23);\n\t    var util = __webpack_require__(5);\n\t    var log = __webpack_require__(22);\n\t    var BoundingRect = __webpack_require__(27);\n\t    var timsort = __webpack_require__(72);\n\t\n\t    var Layer = __webpack_require__(79);\n\t\n\t    var requestAnimationFrame = __webpack_require__(75);\n\t\n\t    // PENDIGN\n\t    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t    //\n\t    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\t    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t\n\t    function isLayerValid(layer) {\n\t        if (!layer) {\n\t            return false;\n\t        }\n\t\n\t        if (layer.__builtin__) {\n\t            return true;\n\t        }\n\t\n\t        if (typeof(layer.resize) !== 'function'\n\t            || typeof(layer.refresh) !== 'function'\n\t        ) {\n\t            return false;\n\t        }\n\t\n\t        return true;\n\t    }\n\t\n\t    function preProcessLayer(layer) {\n\t        layer.__unusedCount++;\n\t    }\n\t\n\t    function postProcessLayer(layer) {\n\t        if (layer.__unusedCount == 1) {\n\t            layer.clear();\n\t        }\n\t    }\n\t\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var viewRect = new BoundingRect(0, 0, 0, 0);\n\t    function isDisplayableCulled(el, width, height) {\n\t        tmpRect.copy(el.getBoundingRect());\n\t        if (el.transform) {\n\t            tmpRect.applyTransform(el.transform);\n\t        }\n\t        viewRect.width = width;\n\t        viewRect.height = height;\n\t        return !tmpRect.intersect(viewRect);\n\t    }\n\t\n\t    function isClipPathChanged(clipPaths, prevClipPaths) {\n\t        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n\t            return false;\n\t        }\n\t\n\t        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n\t            return true;\n\t        }\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            if (clipPaths[i] !== prevClipPaths[i]) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t\n\t    function doClip(clipPaths, ctx) {\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            var clipPath = clipPaths[i];\n\t\n\t            clipPath.setTransform(ctx);\n\t            ctx.beginPath();\n\t            clipPath.buildPath(ctx, clipPath.shape);\n\t            ctx.clip();\n\t            // Transform back\n\t            clipPath.restoreTransform(ctx);\n\t        }\n\t    }\n\t\n\t    function createRoot(width, height) {\n\t        var domRoot = document.createElement('div');\n\t\n\t        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t        domRoot.style.cssText = [\n\t            'position:relative',\n\t            'overflow:hidden',\n\t            'width:' + width + 'px',\n\t            'height:' + height + 'px',\n\t            'padding:0',\n\t            'margin:0',\n\t            'border-width:0'\n\t        ].join(';') + ';';\n\t\n\t        return domRoot;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Painter\n\t     * @constructor\n\t     * @param {HTMLElement} root 绘图容器\n\t     * @param {module:zrender/Storage} storage\n\t     * @param {Object} opts\n\t     */\n\t    var Painter = function (root, storage, opts) {\n\t\n\t        this.type = 'canvas';\n\t\n\t        // In node environment using node-canvas\n\t        var singleCanvas = !root.nodeName // In node ?\n\t            || root.nodeName.toUpperCase() === 'CANVAS';\n\t\n\t        this._opts = opts = util.extend({}, opts || {});\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._singleCanvas = singleCanvas;\n\t        /**\n\t         * 绘图容器\n\t         * @type {HTMLElement}\n\t         */\n\t        this.root = root;\n\t\n\t        var rootStyle = root.style;\n\t\n\t        if (rootStyle) {\n\t            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t            rootStyle['-webkit-user-select'] =\n\t            rootStyle['user-select'] =\n\t            rootStyle['-webkit-touch-callout'] = 'none';\n\t\n\t            root.innerHTML = '';\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/Storage}\n\t         */\n\t        this.storage = storage;\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        var zlevelList = this._zlevelList = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:zrender/Layer>}\n\t         * @private\n\t         */\n\t        var layers = this._layers = {};\n\t\n\t        /**\n\t         * @type {Object.<string, Object>}\n\t         * @type {private}\n\t         */\n\t        this._layerConfig = {};\n\t\n\t        if (!singleCanvas) {\n\t            this._width = this._getSize(0);\n\t            this._height = this._getSize(1);\n\t\n\t            var domRoot = this._domRoot = createRoot(\n\t                this._width, this._height\n\t            );\n\t            root.appendChild(domRoot);\n\t        }\n\t        else {\n\t            if (opts.width != null) {\n\t                root.width = opts.width;\n\t            }\n\t            if (opts.height != null) {\n\t                root.height = opts.height;\n\t            }\n\t            // Use canvas width and height directly\n\t            var width = root.width;\n\t            var height = root.height;\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            // Create layer if only one given canvas\n\t            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t            var mainLayer = new Layer(root, this, 1);\n\t            mainLayer.initContext();\n\t            // FIXME Use canvas width and height\n\t            // mainLayer.resize(width, height);\n\t            layers[0] = mainLayer;\n\t            zlevelList.push(0);\n\t\n\t            this._domRoot = root;\n\t        }\n\t\n\t        // Layers for progressive rendering\n\t        this._progressiveLayers = [];\n\t\n\t        /**\n\t         * @type {module:zrender/Layer}\n\t         * @private\n\t         */\n\t        this._hoverlayer;\n\t\n\t        this._hoverElements = [];\n\t    };\n\t\n\t    Painter.prototype = {\n\t\n\t        constructor: Painter,\n\t\n\t        getType: function () {\n\t            return 'canvas';\n\t        },\n\t\n\t        /**\n\t         * If painter use a single canvas\n\t         * @return {boolean}\n\t         */\n\t        isSingleCanvas: function () {\n\t            return this._singleCanvas;\n\t        },\n\t        /**\n\t         * @return {HTMLDivElement}\n\t         */\n\t        getViewportRoot: function () {\n\t            return this._domRoot;\n\t        },\n\t\n\t        getViewportRootOffset: function () {\n\t            var viewportRoot = this.getViewportRoot();\n\t            if (viewportRoot) {\n\t                return {\n\t                    offsetLeft: viewportRoot.offsetLeft || 0,\n\t                    offsetTop: viewportRoot.offsetTop || 0\n\t                };\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 刷新\n\t         * @param {boolean} [paintAll=false] 强制绘制所有displayable\n\t         */\n\t        refresh: function (paintAll) {\n\t\n\t            var list = this.storage.getDisplayList(true);\n\t\n\t            var zlevelList = this._zlevelList;\n\t\n\t            this._paintList(list, paintAll);\n\t\n\t            // Paint custum layers\n\t            for (var i = 0; i < zlevelList.length; i++) {\n\t                var z = zlevelList[i];\n\t                var layer = this._layers[z];\n\t                if (!layer.__builtin__ && layer.refresh) {\n\t                    layer.refresh();\n\t                }\n\t            }\n\t\n\t            this.refreshHover();\n\t\n\t            if (this._progressiveLayers.length) {\n\t                this._startProgessive();\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        addHover: function (el, hoverStyle) {\n\t            if (el.__hoverMir) {\n\t                return;\n\t            }\n\t            var elMirror = new el.constructor({\n\t                style: el.style,\n\t                shape: el.shape\n\t            });\n\t            elMirror.__from = el;\n\t            el.__hoverMir = elMirror;\n\t            elMirror.setStyle(hoverStyle);\n\t            this._hoverElements.push(elMirror);\n\t        },\n\t\n\t        removeHover: function (el) {\n\t            var elMirror = el.__hoverMir;\n\t            var hoverElements = this._hoverElements;\n\t            var idx = util.indexOf(hoverElements, elMirror);\n\t            if (idx >= 0) {\n\t                hoverElements.splice(idx, 1);\n\t            }\n\t            el.__hoverMir = null;\n\t        },\n\t\n\t        clearHover: function (el) {\n\t            var hoverElements = this._hoverElements;\n\t            for (var i = 0; i < hoverElements.length; i++) {\n\t                var from = hoverElements[i].__from;\n\t                if (from) {\n\t                    from.__hoverMir = null;\n\t                }\n\t            }\n\t            hoverElements.length = 0;\n\t        },\n\t\n\t        refreshHover: function () {\n\t            var hoverElements = this._hoverElements;\n\t            var len = hoverElements.length;\n\t            var hoverLayer = this._hoverlayer;\n\t            hoverLayer && hoverLayer.clear();\n\t\n\t            if (!len) {\n\t                return;\n\t            }\n\t            timsort(hoverElements, this.storage.displayableSortFunc);\n\t\n\t            // Use a extream large zlevel\n\t            // FIXME?\n\t            if (!hoverLayer) {\n\t                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n\t            }\n\t\n\t            var scope = {};\n\t            hoverLayer.ctx.save();\n\t            for (var i = 0; i < len;) {\n\t                var el = hoverElements[i];\n\t                var originalEl = el.__from;\n\t                // Original el is removed\n\t                // PENDING\n\t                if (!(originalEl && originalEl.__zr)) {\n\t                    hoverElements.splice(i, 1);\n\t                    originalEl.__hoverMir = null;\n\t                    len--;\n\t                    continue;\n\t                }\n\t                i++;\n\t\n\t                // Use transform\n\t                // FIXME style and shape ?\n\t                if (!originalEl.invisible) {\n\t                    el.transform = originalEl.transform;\n\t                    el.invTransform = originalEl.invTransform;\n\t                    el.__clipPaths = originalEl.__clipPaths;\n\t                    // el.\n\t                    this._doPaintEl(el, hoverLayer, true, scope);\n\t                }\n\t            }\n\t            hoverLayer.ctx.restore();\n\t        },\n\t\n\t        _startProgessive: function () {\n\t            var self = this;\n\t\n\t            if (!self._furtherProgressive) {\n\t                return;\n\t            }\n\t\n\t            // Use a token to stop progress steps triggered by\n\t            // previous zr.refresh calling.\n\t            var token = self._progressiveToken = +new Date();\n\t\n\t            self._progress++;\n\t            requestAnimationFrame(step);\n\t\n\t            function step() {\n\t                // In case refreshed or disposed\n\t                if (token === self._progressiveToken && self.storage) {\n\t\n\t                    self._doPaintList(self.storage.getDisplayList());\n\t\n\t                    if (self._furtherProgressive) {\n\t                        self._progress++;\n\t                        requestAnimationFrame(step);\n\t                    }\n\t                    else {\n\t                        self._progressiveToken = -1;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _clearProgressive: function () {\n\t            this._progressiveToken = -1;\n\t            this._progress = 0;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                layer.__dirty && layer.clear();\n\t            });\n\t        },\n\t\n\t        _paintList: function (list, paintAll) {\n\t\n\t            if (paintAll == null) {\n\t                paintAll = false;\n\t            }\n\t\n\t            this._updateLayerStatus(list);\n\t\n\t            this._clearProgressive();\n\t\n\t            this.eachBuiltinLayer(preProcessLayer);\n\t\n\t            this._doPaintList(list, paintAll);\n\t\n\t            this.eachBuiltinLayer(postProcessLayer);\n\t        },\n\t\n\t        _doPaintList: function (list, paintAll) {\n\t            var currentLayer;\n\t            var currentZLevel;\n\t            var ctx;\n\t\n\t            // var invTransform = [];\n\t            var scope;\n\t\n\t            var progressiveLayerIdx = 0;\n\t            var currentProgressiveLayer;\n\t\n\t            var width = this._width;\n\t            var height = this._height;\n\t            var layerProgress;\n\t            var frame = this._progress;\n\t            function flushProgressiveLayer(layer) {\n\t                var dpr = ctx.dpr || 1;\n\t                ctx.save();\n\t                ctx.globalAlpha = 1;\n\t                ctx.shadowBlur = 0;\n\t                // Avoid layer don't clear in next progressive frame\n\t                currentLayer.__dirty = true;\n\t                ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t                ctx.restore();\n\t            }\n\t\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t\n\t                var elFrame = el.__frame;\n\t\n\t                // Flush at current context\n\t                // PENDING\n\t                if (elFrame < 0 && currentProgressiveLayer) {\n\t                    flushProgressiveLayer(currentProgressiveLayer);\n\t                    currentProgressiveLayer = null;\n\t                }\n\t\n\t                // Change draw layer\n\t                if (currentZLevel !== elZLevel) {\n\t                    if (ctx) {\n\t                        ctx.restore();\n\t                    }\n\t\n\t                    // Reset scope\n\t                    scope = {};\n\t\n\t                    // Only 0 zlevel if only has one canvas\n\t                    currentZLevel = elZLevel;\n\t                    currentLayer = this.getLayer(currentZLevel);\n\t\n\t                    if (!currentLayer.__builtin__) {\n\t                        log(\n\t                            'ZLevel ' + currentZLevel\n\t                            + ' has been used by unkown layer ' + currentLayer.id\n\t                        );\n\t                    }\n\t\n\t                    ctx = currentLayer.ctx;\n\t                    ctx.save();\n\t\n\t                    // Reset the count\n\t                    currentLayer.__unusedCount = 0;\n\t\n\t                    if (currentLayer.__dirty || paintAll) {\n\t                        currentLayer.clear();\n\t                    }\n\t                }\n\t\n\t                if (!(currentLayer.__dirty || paintAll)) {\n\t                    continue;\n\t                }\n\t\n\t                if (elFrame >= 0) {\n\t                    // Progressive layer changed\n\t                    if (!currentProgressiveLayer) {\n\t                        currentProgressiveLayer = this._progressiveLayers[\n\t                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n\t                        ];\n\t\n\t                        currentProgressiveLayer.ctx.save();\n\t                        currentProgressiveLayer.renderScope = {};\n\t\n\t                        if (currentProgressiveLayer\n\t                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n\t                        ) {\n\t                            // flushProgressiveLayer(currentProgressiveLayer);\n\t                            // Quick jump all progressive elements\n\t                            // All progressive element are not dirty, jump over and flush directly\n\t                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n\t                            // currentProgressiveLayer = null;\n\t                            continue;\n\t                        }\n\t\n\t                        layerProgress = currentProgressiveLayer.__progress;\n\t\n\t                        if (!currentProgressiveLayer.__dirty) {\n\t                            // Keep rendering\n\t                            frame = layerProgress;\n\t                        }\n\t\n\t                        currentProgressiveLayer.__progress = frame + 1;\n\t                    }\n\t\n\t                    if (elFrame === frame) {\n\t                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t                    }\n\t                }\n\t                else {\n\t                    this._doPaintEl(el, currentLayer, paintAll, scope);\n\t                }\n\t\n\t                el.__dirty = false;\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                flushProgressiveLayer(currentProgressiveLayer);\n\t            }\n\t\n\t            // Restore the lastLayer ctx\n\t            ctx && ctx.restore();\n\t            // If still has clipping state\n\t            // if (scope.prevElClipPaths) {\n\t            //     ctx.restore();\n\t            // }\n\t\n\t            this._furtherProgressive = false;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                if (layer.__maxProgress >= layer.__progress) {\n\t                    this._furtherProgressive = true;\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t            var ctx = currentLayer.ctx;\n\t            var m = el.transform;\n\t            if (\n\t                (currentLayer.__dirty || forcePaint)\n\t                // Ignore invisible element\n\t                && !el.invisible\n\t                // Ignore transparent element\n\t                && el.style.opacity !== 0\n\t                // Ignore scale 0 element, in some environment like node-canvas\n\t                // Draw a scale 0 element can cause all following draw wrong\n\t                // And setTransform with scale 0 will cause set back transform failed.\n\t                && !(m && !m[0] && !m[3])\n\t                // Ignore culled element\n\t                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n\t            ) {\n\t\n\t                var clipPaths = el.__clipPaths;\n\t\n\t                // Optimize when clipping on group with several elements\n\t                if (scope.prevClipLayer !== currentLayer\n\t                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n\t                ) {\n\t                    // If has previous clipping state, restore from it\n\t                    if (scope.prevElClipPaths) {\n\t                        scope.prevClipLayer.ctx.restore();\n\t                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\t\n\t                        // Reset prevEl since context has been restored\n\t                        scope.prevEl = null;\n\t                    }\n\t                    // New clipping state\n\t                    if (clipPaths) {\n\t                        ctx.save();\n\t                        doClip(clipPaths, ctx);\n\t                        scope.prevClipLayer = currentLayer;\n\t                        scope.prevElClipPaths = clipPaths;\n\t                    }\n\t                }\n\t                el.beforeBrush && el.beforeBrush(ctx);\n\t\n\t                el.brush(ctx, scope.prevEl || null);\n\t                scope.prevEl = el;\n\t\n\t                el.afterBrush && el.afterBrush(ctx);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n\t         * @param {number} zlevel\n\t         * @return {module:zrender/Layer}\n\t         */\n\t        getLayer: function (zlevel) {\n\t            if (this._singleCanvas) {\n\t                return this._layers[0];\n\t            }\n\t\n\t            var layer = this._layers[zlevel];\n\t            if (!layer) {\n\t                // Create a new layer\n\t                layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t                layer.__builtin__ = true;\n\t\n\t                if (this._layerConfig[zlevel]) {\n\t                    util.merge(layer, this._layerConfig[zlevel], true);\n\t                }\n\t\n\t                this.insertLayer(zlevel, layer);\n\t\n\t                // Context is created after dom inserted to document\n\t                // Or excanvas will get 0px clientWidth and clientHeight\n\t                layer.initContext();\n\t            }\n\t\n\t            return layer;\n\t        },\n\t\n\t        insertLayer: function (zlevel, layer) {\n\t\n\t            var layersMap = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var len = zlevelList.length;\n\t            var prevLayer = null;\n\t            var i = -1;\n\t            var domRoot = this._domRoot;\n\t\n\t            if (layersMap[zlevel]) {\n\t                log('ZLevel ' + zlevel + ' has been used already');\n\t                return;\n\t            }\n\t            // Check if is a valid layer\n\t            if (!isLayerValid(layer)) {\n\t                log('Layer of zlevel ' + zlevel + ' is not valid');\n\t                return;\n\t            }\n\t\n\t            if (len > 0 && zlevel > zlevelList[0]) {\n\t                for (i = 0; i < len - 1; i++) {\n\t                    if (\n\t                        zlevelList[i] < zlevel\n\t                        && zlevelList[i + 1] > zlevel\n\t                    ) {\n\t                        break;\n\t                    }\n\t                }\n\t                prevLayer = layersMap[zlevelList[i]];\n\t            }\n\t            zlevelList.splice(i + 1, 0, zlevel);\n\t\n\t            layersMap[zlevel] = layer;\n\t\n\t            // Vitual layer will not directly show on the screen.\n\t            // (It can be a WebGL layer and assigned to a ZImage element)\n\t            // But it still under management of zrender.\n\t            if (!layer.virtual) {\n\t                if (prevLayer) {\n\t                    var prevDom = prevLayer.dom;\n\t                    if (prevDom.nextSibling) {\n\t                        domRoot.insertBefore(\n\t                            layer.dom,\n\t                            prevDom.nextSibling\n\t                        );\n\t                    }\n\t                    else {\n\t                        domRoot.appendChild(layer.dom);\n\t                    }\n\t                }\n\t                else {\n\t                    if (domRoot.firstChild) {\n\t                        domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t                    }\n\t                    else {\n\t                        domRoot.appendChild(layer.dom);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        // Iterate each layer\n\t        eachLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                cb.call(context, this._layers[z], z);\n\t            }\n\t        },\n\t\n\t        // Iterate each buildin layer\n\t        eachBuiltinLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (layer.__builtin__) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        // Iterate each other layer except buildin layer\n\t        eachOtherLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (!layer.__builtin__) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 获取所有已创建的层\n\t         * @param {Array.<module:zrender/Layer>} [prevLayer]\n\t         */\n\t        getLayers: function () {\n\t            return this._layers;\n\t        },\n\t\n\t        _updateLayerStatus: function (list) {\n\t\n\t            var layers = this._layers;\n\t            var progressiveLayers = this._progressiveLayers;\n\t\n\t            var elCountsLastFrame = {};\n\t            var progressiveElCountsLastFrame = {};\n\t\n\t            this.eachBuiltinLayer(function (layer, z) {\n\t                elCountsLastFrame[z] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                progressiveElCountsLastFrame[idx] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            var progressiveLayerCount = 0;\n\t            var currentProgressiveLayer;\n\t            var lastProgressiveKey;\n\t            var frameCount = 0;\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var layer = layers[zlevel];\n\t                var elProgress = el.progressive;\n\t                if (layer) {\n\t                    layer.elCount++;\n\t                    layer.__dirty = layer.__dirty || el.__dirty;\n\t                }\n\t\n\t                /////// Update progressive\n\t                if (elProgress >= 0) {\n\t                    // Fix wrong progressive sequence problem.\n\t                    if (lastProgressiveKey !== elProgress) {\n\t                        lastProgressiveKey = elProgress;\n\t                        frameCount++;\n\t                    }\n\t                    var elFrame = el.__frame = frameCount - 1;\n\t                    if (!currentProgressiveLayer) {\n\t                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t                        currentProgressiveLayer = progressiveLayers[idx];\n\t                        if (!currentProgressiveLayer) {\n\t                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n\t                                'progressive', this, this.dpr\n\t                            );\n\t                            currentProgressiveLayer.initContext();\n\t                        }\n\t                        currentProgressiveLayer.__maxProgress = 0;\n\t                    }\n\t                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t                    currentProgressiveLayer.elCount++;\n\t\n\t                    currentProgressiveLayer.__maxProgress = Math.max(\n\t                        currentProgressiveLayer.__maxProgress, elFrame\n\t                    );\n\t\n\t                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t                        // Should keep rendering this  layer because progressive rendering is not finished yet\n\t                        layer.__dirty = true;\n\t                    }\n\t                }\n\t                else {\n\t                    el.__frame = -1;\n\t\n\t                    if (currentProgressiveLayer) {\n\t                        currentProgressiveLayer.__nextIdxNotProg = i;\n\t                        progressiveLayerCount++;\n\t                        currentProgressiveLayer = null;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                progressiveLayerCount++;\n\t                currentProgressiveLayer.__nextIdxNotProg = i;\n\t            }\n\t\n\t            // 层中的元素数量有发生变化\n\t            this.eachBuiltinLayer(function (layer, z) {\n\t                if (elCountsLastFrame[z] !== layer.elCount) {\n\t                    layer.__dirty = true;\n\t                }\n\t            });\n\t\n\t            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t                    el.__dirty = true;\n\t                }\n\t                if (layer.__dirty) {\n\t                    layer.__progress = 0;\n\t                }\n\t            });\n\t        },\n\t\n\t        /**\n\t         * 清除hover层外所有内容\n\t         */\n\t        clear: function () {\n\t            this.eachBuiltinLayer(this._clearLayer);\n\t            return this;\n\t        },\n\t\n\t        _clearLayer: function (layer) {\n\t            layer.clear();\n\t        },\n\t\n\t        /**\n\t         * 修改指定zlevel的绘制参数\n\t         *\n\t         * @param {string} zlevel\n\t         * @param {Object} config 配置对象\n\t         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n\t         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n\t         * @param {number} [config.lastFrameAlpha=0.7]\n\t         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t         */\n\t        configLayer: function (zlevel, config) {\n\t            if (config) {\n\t                var layerConfig = this._layerConfig;\n\t                if (!layerConfig[zlevel]) {\n\t                    layerConfig[zlevel] = config;\n\t                }\n\t                else {\n\t                    util.merge(layerConfig[zlevel], config, true);\n\t                }\n\t\n\t                var layer = this._layers[zlevel];\n\t\n\t                if (layer) {\n\t                    util.merge(layer, layerConfig[zlevel], true);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 删除指定层\n\t         * @param {number} zlevel 层所在的zlevel\n\t         */\n\t        delLayer: function (zlevel) {\n\t            var layers = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var layer = layers[zlevel];\n\t            if (!layer) {\n\t                return;\n\t            }\n\t            layer.dom.parentNode.removeChild(layer.dom);\n\t            delete layers[zlevel];\n\t\n\t            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t        },\n\t\n\t        /**\n\t         * 区域大小变化后重绘\n\t         */\n\t        resize: function (width, height) {\n\t            var domRoot = this._domRoot;\n\t            // FIXME Why ?\n\t            domRoot.style.display = 'none';\n\t\n\t            // Save input w/h\n\t            var opts = this._opts;\n\t            width != null && (opts.width = width);\n\t            height != null && (opts.height = height);\n\t\n\t            width = this._getSize(0);\n\t            height = this._getSize(1);\n\t\n\t            domRoot.style.display = '';\n\t\n\t            // 优化没有实际改变的resize\n\t            if (this._width != width || height != this._height) {\n\t                domRoot.style.width = width + 'px';\n\t                domRoot.style.height = height + 'px';\n\t\n\t                for (var id in this._layers) {\n\t                    if (this._layers.hasOwnProperty(id)) {\n\t                        this._layers[id].resize(width, height);\n\t                    }\n\t                }\n\t                util.each(this._progressiveLayers, function (layer) {\n\t                    layer.resize(width, height);\n\t                });\n\t\n\t                this.refresh(true);\n\t            }\n\t\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 清除单独的一个层\n\t         * @param {number} zlevel\n\t         */\n\t        clearLayer: function (zlevel) {\n\t            var layer = this._layers[zlevel];\n\t            if (layer) {\n\t                layer.clear();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 释放\n\t         */\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t\n\t            this.root =\n\t            this.storage =\n\t\n\t            this._domRoot =\n\t            this._layers = null;\n\t        },\n\t\n\t        /**\n\t         * Get canvas which has all thing rendered\n\t         * @param {Object} opts\n\t         * @param {string} [opts.backgroundColor]\n\t         */\n\t        getRenderedCanvas: function (opts) {\n\t            opts = opts || {};\n\t            if (this._singleCanvas) {\n\t                return this._layers[0].dom;\n\t            }\n\t\n\t            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t            imageLayer.initContext();\n\t\n\t            imageLayer.clearColor = opts.backgroundColor;\n\t            imageLayer.clear();\n\t\n\t            var displayList = this.storage.getDisplayList(true);\n\t\n\t            var scope = {};\n\t            var zlevel;\n\t\n\t            var self = this;\n\t            function findAndDrawOtherLayer(smaller, larger) {\n\t                var zlevelList = self._zlevelList;\n\t                if (smaller == null) {\n\t                    smaller = -Infinity;\n\t                }\n\t                var intermediateLayer;\n\t                for (var i = 0; i < zlevelList.length; i++) {\n\t                    var z = zlevelList[i];\n\t                    var layer = self._layers[z];\n\t                    if (!layer.__builtin__ && z > smaller && z < larger) {\n\t                        intermediateLayer = layer;\n\t                        break;\n\t                    }\n\t                }\n\t                if (intermediateLayer && intermediateLayer.renderToCanvas) {\n\t                    imageLayer.ctx.save();\n\t                    intermediateLayer.renderToCanvas(imageLayer.ctx);\n\t                    imageLayer.ctx.restore();\n\t                }\n\t            }\n\t            for (var i = 0; i < displayList.length; i++) {\n\t                var el = displayList[i];\n\t\n\t                if (el.zlevel !== zlevel) {\n\t                    findAndDrawOtherLayer(zlevel, el.zlevel);\n\t                    zlevel = el.zlevel;\n\t                }\n\t                this._doPaintEl(el, imageLayer, true, scope);\n\t            }\n\t\n\t            findAndDrawOtherLayer(zlevel, Infinity);\n\t\n\t            return imageLayer.dom;\n\t        },\n\t        /**\n\t         * 获取绘图区域宽度\n\t         */\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t\n\t        /**\n\t         * 获取绘图区域高度\n\t         */\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t\n\t        _getSize: function (whIdx) {\n\t            var opts = this._opts;\n\t            var wh = ['width', 'height'][whIdx];\n\t            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n\t            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n\t            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\t\n\t            if (opts[wh] != null && opts[wh] !== 'auto') {\n\t                return parseFloat(opts[wh]);\n\t            }\n\t\n\t            var root = this.root;\n\t            // IE8 does not support getComputedStyle, but it use VML.\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t\n\t            return (\n\t                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n\t                - (parseInt10(stl[plt]) || 0)\n\t                - (parseInt10(stl[prb]) || 0)\n\t            ) | 0;\n\t        },\n\t\n\t        pathToImage: function (path, dpr) {\n\t            dpr = dpr || this.dpr;\n\t\n\t            var canvas = document.createElement('canvas');\n\t            var ctx = canvas.getContext('2d');\n\t            var rect = path.getBoundingRect();\n\t            var style = path.style;\n\t            var shadowBlurSize = style.shadowBlur;\n\t            var shadowOffsetX = style.shadowOffsetX;\n\t            var shadowOffsetY = style.shadowOffsetY;\n\t            var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\t\n\t            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n\t            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n\t            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n\t            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n\t            var width = rect.width + leftMargin + rightMargin;\n\t            var height = rect.height + topMargin + bottomMargin;\n\t\n\t            canvas.width = width * dpr;\n\t            canvas.height = height * dpr;\n\t\n\t            ctx.scale(dpr, dpr);\n\t            ctx.clearRect(0, 0, width, height);\n\t            ctx.dpr = dpr;\n\t\n\t            var pathTransform = {\n\t                position: path.position,\n\t                rotation: path.rotation,\n\t                scale: path.scale\n\t            };\n\t            path.position = [leftMargin - rect.x, topMargin - rect.y];\n\t            path.rotation = 0;\n\t            path.scale = [1, 1];\n\t            path.updateTransform();\n\t            if (path) {\n\t                path.brush(ctx);\n\t            }\n\t\n\t            var ImageShape = __webpack_require__(45);\n\t            var imgShape = new ImageShape({\n\t                style: {\n\t                    x: 0,\n\t                    y: 0,\n\t                    image: canvas\n\t                }\n\t            });\n\t\n\t            if (pathTransform.position != null) {\n\t                imgShape.position = path.position = pathTransform.position;\n\t            }\n\t\n\t            if (pathTransform.rotation != null) {\n\t                imgShape.rotation = path.rotation = pathTransform.rotation;\n\t            }\n\t\n\t            if (pathTransform.scale != null) {\n\t                imgShape.scale = path.scale = pathTransform.scale;\n\t            }\n\t\n\t            return imgShape;\n\t        }\n\t    };\n\t\n\t    module.exports = Painter;\n\t\n\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/Layer\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(5);\n\t    var config = __webpack_require__(23);\n\t    var Style = __webpack_require__(9);\n\t    var Pattern = __webpack_require__(40);\n\t\n\t    function returnFalse() {\n\t        return false;\n\t    }\n\t\n\t    /**\n\t     * 创建dom\n\t     *\n\t     * @inner\n\t     * @param {string} id dom id 待用\n\t     * @param {string} type dom type，such as canvas, div etc.\n\t     * @param {Painter} painter painter instance\n\t     * @param {number} number\n\t     */\n\t    function createDom(id, type, painter, dpr) {\n\t        var newDom = document.createElement(type);\n\t        var width = painter.getWidth();\n\t        var height = painter.getHeight();\n\t\n\t        var newDomStyle = newDom.style;\n\t        // 没append呢，请原谅我这样写，清晰~\n\t        newDomStyle.position = 'absolute';\n\t        newDomStyle.left = 0;\n\t        newDomStyle.top = 0;\n\t        newDomStyle.width = width + 'px';\n\t        newDomStyle.height = height + 'px';\n\t        newDom.width = width * dpr;\n\t        newDom.height = height * dpr;\n\t\n\t        // id不作为索引用，避免可能造成的重名，定义为私有属性\n\t        newDom.setAttribute('data-zr-dom-id', id);\n\t        return newDom;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Layer\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @param {string} id\n\t     * @param {module:zrender/Painter} painter\n\t     * @param {number} [dpr]\n\t     */\n\t    var Layer = function(id, painter, dpr) {\n\t        var dom;\n\t        dpr = dpr || config.devicePixelRatio;\n\t        if (typeof id === 'string') {\n\t            dom = createDom(id, 'canvas', painter, dpr);\n\t        }\n\t        // Not using isDom because in node it will return false\n\t        else if (util.isObject(id)) {\n\t            dom = id;\n\t            id = dom.id;\n\t        }\n\t        this.id = id;\n\t        this.dom = dom;\n\t\n\t        var domStyle = dom.style;\n\t        if (domStyle) { // Not in node\n\t            dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t            domStyle['-webkit-user-select'] = 'none';\n\t            domStyle['user-select'] = 'none';\n\t            domStyle['-webkit-touch-callout'] = 'none';\n\t            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t            domStyle['padding'] = 0;\n\t            domStyle['margin'] = 0;\n\t            domStyle['border-width'] = 0;\n\t        }\n\t\n\t        this.domBack = null;\n\t        this.ctxBack = null;\n\t\n\t        this.painter = painter;\n\t\n\t        this.config = null;\n\t\n\t        // Configs\n\t        /**\n\t         * 每次清空画布的颜色\n\t         * @type {string}\n\t         * @default 0\n\t         */\n\t        this.clearColor = 0;\n\t        /**\n\t         * 是否开启动态模糊\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        this.motionBlur = false;\n\t        /**\n\t         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t         * @type {number}\n\t         * @default 0.7\n\t         */\n\t        this.lastFrameAlpha = 0.7;\n\t\n\t        /**\n\t         * Layer dpr\n\t         * @type {number}\n\t         */\n\t        this.dpr = dpr;\n\t    };\n\t\n\t    Layer.prototype = {\n\t\n\t        constructor: Layer,\n\t\n\t        elCount: 0,\n\t\n\t        __dirty: true,\n\t\n\t        initContext: function () {\n\t            this.ctx = this.dom.getContext('2d');\n\t            this.ctx.__currentValues = {};\n\t            this.ctx.dpr = this.dpr;\n\t        },\n\t\n\t        createBackBuffer: function () {\n\t            var dpr = this.dpr;\n\t\n\t            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n\t            this.ctxBack = this.domBack.getContext('2d');\n\t            this.ctxBack.__currentValues = {};\n\t\n\t            if (dpr != 1) {\n\t                this.ctxBack.scale(dpr, dpr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param  {number} width\n\t         * @param  {number} height\n\t         */\n\t        resize: function (width, height) {\n\t            var dpr = this.dpr;\n\t\n\t            var dom = this.dom;\n\t            var domStyle = dom.style;\n\t            var domBack = this.domBack;\n\t\n\t            domStyle.width = width + 'px';\n\t            domStyle.height = height + 'px';\n\t\n\t            dom.width = width * dpr;\n\t            dom.height = height * dpr;\n\t\n\t            if (domBack) {\n\t                domBack.width = width * dpr;\n\t                domBack.height = height * dpr;\n\t\n\t                if (dpr != 1) {\n\t                    this.ctxBack.scale(dpr, dpr);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 清空该层画布\n\t         * @param {boolean} clearAll Clear all with out motion blur\n\t         */\n\t        clear: function (clearAll) {\n\t            var dom = this.dom;\n\t            var ctx = this.ctx;\n\t            var width = dom.width;\n\t            var height = dom.height;\n\t\n\t            var clearColor = this.clearColor;\n\t            var haveMotionBLur = this.motionBlur && !clearAll;\n\t            var lastFrameAlpha = this.lastFrameAlpha;\n\t\n\t            var dpr = this.dpr;\n\t\n\t            if (haveMotionBLur) {\n\t                if (!this.domBack) {\n\t                    this.createBackBuffer();\n\t                }\n\t\n\t                this.ctxBack.globalCompositeOperation = 'copy';\n\t                this.ctxBack.drawImage(\n\t                    dom, 0, 0,\n\t                    width / dpr,\n\t                    height / dpr\n\t                );\n\t            }\n\t\n\t            ctx.clearRect(0, 0, width, height);\n\t            if (clearColor) {\n\t                var clearColorGradientOrPattern;\n\t                // Gradient\n\t                if (clearColor.colorStops) {\n\t                    // Cache canvas gradient\n\t                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t                        x: 0,\n\t                        y: 0,\n\t                        width: width,\n\t                        height: height\n\t                    });\n\t\n\t                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t                }\n\t                // Pattern\n\t                else if (clearColor.image) {\n\t                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t                }\n\t                ctx.save();\n\t                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t                ctx.fillRect(0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t\n\t            if (haveMotionBLur) {\n\t                var domBack = this.domBack;\n\t                ctx.save();\n\t                ctx.globalAlpha = lastFrameAlpha;\n\t                ctx.drawImage(domBack, 0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Layer;\n\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 选中节点后，出现的操作框及按钮\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Node = __webpack_require__(81);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var graphic = __webpack_require__(4);\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var env = __webpack_require__(50);\r\n\t    var icon = __webpack_require__(89);\r\n\t    var symbolUtil = __webpack_require__(83);\r\n\t    function OperationNode(node, zr, api,forbidEdit) {\r\n\t        Node.call(this);\r\n\t        this.node = node;\r\n\t        this.zr = zr;\r\n\t        this.forbidEdit = forbidEdit;\r\n\t        this._api = api;\r\n\t        this.render();\r\n\t    }\r\n\t\r\n\t    //事件\r\n\t    OperationNode.ARROW_DRAGEND = \"OperationNode:dragendArrow\";\r\n\t    OperationNode.ARROW_DRAG = \"OperationNode:dragArrow\";\r\n\t    OperationNode.ARROW_DRAGSTART = \"OperationNode:dragstartArrow\";\r\n\t    OperationNode.DELETE_CLICK = \"OperationNode:deleteClick\";\r\n\t    OperationNode.DEL = \"DEL\";\r\n\t    if(!env.canvasSupported) {//IE8不支持canvas 以及base64  此处是为了兼容IE8. 实际都可以用SVG图标,但没有找到好的SVG图标, 如果有的话那就没有必要用这些base64了\r\n\t        //内置操作图标的图像\r\n\t        OperationNode.opicons = {\r\n\t            STRAIGHT: icon.STRAIGHT_SVG,\r\n\t            JAGGED: icon.JAGGED_SVG,\r\n\t            CURVE: icon.CURVE_SVG,\r\n\t            DEL: icon.DEL_SVG\r\n\t        };\r\n\t    }else{\r\n\t        OperationNode.opicons = {\r\n\t            STRAIGHT: icon.STRAIGHT_IMG,\r\n\t            JAGGED: icon.JAGGED_IMG,\r\n\t            CURVE: icon.CURVE_IMG,\r\n\t            DEL: icon.DEL_SVG\r\n\t        };\r\n\t    }\r\n\t\r\n\t    OperationNode.prototype.render = function() {\r\n\t        this.renderBase();\r\n\t        if (!this.forbidEdit) {\r\n\t            this.renderOther();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.renderBase = function() {\r\n\t        this.createOperation();\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.createOperation = function() {\r\n\t        var me = this;\r\n\t        if (!this.node.selectStyle) {\r\n\t            this.virtualRect = new graphic.Polyline({ style: { lineDash: [2] } });\r\n\t            this.virtualRect.isSelfComputePos = true;  // 自己计算位置\r\n\t            this.add(this.virtualRect);\r\n\t        } else {\r\n\t            this._api.getZr().addHover(this.node, this.node.selectStyle);\r\n\t        }\r\n\t\r\n\t        if (this.node.operationIcons) {\r\n\t            zrUtil.each(this.node.operationIcons, function(item) {\r\n\t                //检查是否是内置图标\r\n\t                var opIconInstance = null;\r\n\t                var operationIcon = OperationNode.opicons[item.name.toUpperCase() + \"\"]\r\n\t                if (operationIcon) {\r\n\t\r\n\t                    if (this.forbidEdit) {\r\n\t                        return;\r\n\t                    }\r\n\t                    if (item.name == OperationNode.DEL) {\r\n\t                        //垃圾桶\r\n\t                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#000000' },z:me.node.z+1,rectHover: true }, { x: 0, y: 0, width: 10, height: 15 });\r\n\t                        if(item.iconPath) {\r\n\t                            opIconInstance = new graphic.Image({\r\n\t                                style: {\r\n\t                                    image:item.iconPath,\r\n\t                                    width:15,\r\n\t                                    height:15\r\n\t                                },\r\n\t                                z: me.node.z + 2 //zIndex 置为 节点+2 节点+1为组\r\n\t                            });\r\n\t                        }\r\n\t\r\n\t                        if(item.callback){\r\n\t                            opIconInstance.on(\"click\", function(e) {\r\n\t                                e.data = item;\r\n\t                                e.node = me.node;  // 将所附的节点也传递出去\r\n\t                                if (item.callback) {\r\n\t                                    item.callback(e);\r\n\t                                }\r\n\t                            });\r\n\t                        }else{\r\n\t                            opIconInstance.on(\"click\", function(e) {\r\n\t                                var params = {};\r\n\t                                params.event = e;\r\n\t                                params.target = this;\r\n\t                                params.type = OperationNode.DELETE_CLICK;\r\n\t                                me.trigger(params.type, params);\r\n\t                            });\r\n\t                        }\r\n\t\r\n\t\r\n\t                    } else {\r\n\t                        if(!env.canvasSupported){\r\n\t                            var rect = { x: 0, y: 0, width: 15, height: 15 };\r\n\t                            opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#000000' },draggable:true,z:me.node.z+2,lineType: Connector[\"TYPE_\" + item.name.toUpperCase()],rectHover: true }, rect);\r\n\t                        }else{\r\n\t                            var imageUrl = document.createElement('img');\r\n\t                            imageUrl.src = item.iconPath || operationIcon;\r\n\t                            opIconInstance = new graphic.Image({\r\n\t                                style: {\r\n\t                                    image:imageUrl,\r\n\t                                    width:15,\r\n\t                                    height:15\r\n\t                                },\r\n\t                                draggable: true,\r\n\t                                z: me.node.z + 2, //zIndex 置为 节点+2 节点+1为组\r\n\t                                lineType: Connector[\"TYPE_\" + item.name.toUpperCase()] //区分不同的线段\r\n\t                            });\r\n\t                        }\r\n\t\r\n\t                        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];\r\n\t                        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n\t                            opIconInstance.on(eveName, function(e) {\r\n\t                                var params = {};\r\n\t                                params.event = e;\r\n\t                                params.data = item.options\r\n\t                                params.type = \"OperationNode:\" + eveName + \"Arrow\";\r\n\t                                me.trigger(params.type, params);\r\n\t                            });\r\n\t                        });\r\n\t                    }\r\n\t\r\n\t                } else {\r\n\t                    opIconInstance = symbolUtil.createSymbol(item.iconPath, 0, 0, item.width || 15, item.height || 15, me.node.z+1, item.color||'#000');\r\n\t                    opIconInstance.on(\"click\", function(e) {\r\n\t                        e.data = item;\r\n\t                        e.node = me.node;  // 将所附的节点也传递出去\r\n\t                        if (item.callback) {\r\n\t                            item.callback(e);\r\n\t                        }\r\n\t                        var param = {event:e, type:\"OperationNode:\" + item.name + \"Click\"};\r\n\t                        me._api.trigger(param.type, param);\r\n\t                    });\r\n\t                }\r\n\t                opIconInstance.name = item.name;\r\n\t                me.add(opIconInstance);\r\n\t            });\r\n\t        }\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.refreshPostion = function(node,nodeRect) {\r\n\t        var i = 0;\r\n\t        var rbPoint = nodeRect.points[2]; //取右下角坐标\r\n\t        //1.定位虚框\r\n\t        this.virtualRect && this.virtualRect.setShape({ points: nodeRect.points });\r\n\t        //2.定位每个小图标\r\n\t        this.eachChild(function(nodeItem) {\r\n\t            if (!nodeItem.isSelfComputePos) {\r\n\t                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离\r\n\t                nodeItem.attr(\"position\", [rbPoint[0] + 8 + (i++ * 20), rbPoint[1] - 10]);\r\n\t            }\r\n\t        });\r\n\t\r\n\t        this.refreshPositionOther(node,nodeRect);\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.renderOther = function() {\r\n\t        //留给扩展使用\r\n\t    };\r\n\t    OperationNode.prototype.refreshPositionOther = function(node,nodeRect) {\r\n\t        //留给扩展使用\r\n\t        //3.定位整个operationNode\r\n\t        if (node.parent && node.parent.isBg && node.parent.isBg == true) {\r\n\t            this.attr(\"position\", [nodeRect.x, nodeRect.y])\r\n\t        } else {\r\n\t            var nodeShapeX = node.shape? node.shape.x:0;\r\n\t            var nodeSahpeY = node.shape? node.shape.y:0;\r\n\t            this.attr(\"position\", [nodeRect.x + node.parent.position[0]+nodeShapeX, nodeRect.y + node.parent.position[1]+nodeSahpeY])\r\n\t        }\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.cleanup = function() {\r\n\t        if(this.node.selectStyle) {\r\n\t            this._api.getZr().removeHover(this.node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(OperationNode, Node);\r\n\t    module.exports = OperationNode;\r\n\t\r\n\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var graphic = __webpack_require__(4);\r\n\t    var util = __webpack_require__(65)\r\n\t    //创建Node类 所有形状都继承Node  包括fromJSON toJSON\r\n\t    function Node() {\r\n\t        this.resourceId = util.getUUID(); // 生成节点ID\r\n\t        graphic.Group.call(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 由父类实现\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Node.prototype.render = function() {};\r\n\t\r\n\t    /**\r\n\t     * 由父类实现\r\n\t     * @param  {[type]} json [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    Node.prototype.getRect = function(json) {};\r\n\t\r\n\t    /**\r\n\t     * drawText\r\n\t     * @description 画一个文本\r\n\t     * @param {string} name\r\n\t     * @param {string} color\r\n\t     */\r\n\t    Node.prototype.drawText = function(name,color) {\r\n\t        var textName = this.bpmnInfo.name;\r\n\t        if(name != null){\r\n\t            textName = name;\r\n\t        }\r\n\t        var text = new graphic.Text({\r\n\t            style: {\r\n\t                text: textName,\r\n\t                color: color ? color : this.options.text.color,\r\n\t                textFont: '12px Microsoft YaHei'\r\n\t            },\r\n\t            zlevel: 20\r\n\t        });\r\n\t        //文字绘制的位置  \r\n\t        //x = 中心点.x - 起始位置.x - 文字宽度的一半\r\n\t        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n\t        //y = 中心点.y - 起始位置.y + 节点高度的一半 + 偏移值（6）\r\n\t        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;\r\n\t        text.attr(\"style\", { x: x, y: y });\r\n\t        return {\r\n\t            text: text,\r\n\t            rect: text.getBoundingRect()\r\n\t        };\r\n\t    };\r\n\t    /**\r\n\t     * refreshText\r\n\t     * @description 刷新文本\r\n\t     */\r\n\t    Node.prototype.refreshText = function() {\r\n\t        var text = this.childOfName(\"Title\");\r\n\t        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n\t        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;\r\n\t        text.attr(\"style\", { x: x, y: y });\r\n\t    };\r\n\t    /**\r\n\t     * 由父类实现\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Node.prototype.toJSON = function() {};\r\n\t\r\n\t    graphic.Util.inherits(Node, graphic.Group);\r\n\t    module.exports = Node;\r\n\t\r\n\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连接线\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Util = __webpack_require__(65);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var graphic = __webpack_require__(4);\r\n\t    var Node = __webpack_require__(81);\r\n\t    var symbolUtil = __webpack_require__(83);\r\n\t    var Handle = __webpack_require__(84);\r\n\t    var EffectLine = __webpack_require__(85);\r\n\t    var ConnectionPoint = __webpack_require__(86);\r\n\t    var Point = __webpack_require__(66);\r\n\t    var Model = __webpack_require__(87);\r\n\t\r\n\t    Connector.TYPE_STRAIGHT = 'straight';\r\n\t    Connector.TYPE_JAGGED = 'jagged';\r\n\t    Connector.TYPE_CURVE = 'curve';\r\n\t    Connector.RADIUS = 3;\r\n\t    Connector.START_NODE = \"startNode\";\r\n\t    Connector.END_NODE = \"endNode\";\r\n\t    Connector.LEFT = \"left\";\r\n\t    Connector.RIGHT = \"right\";\r\n\t    Connector.TOP = \"top\";\r\n\t    Connector.BOTTOM = \"bottom\";\r\n\t    Connector.BOTTOM = \"bottom\";\r\n\t    Connector.SEPERATOR = \"-\";\r\n\t    Connector.NORMAL_COLOR = \"#BBBBBB\";\r\n\t    Connector.SELECTED_COLOR = '#74B7E0';\r\n\t    /**\r\n\t     * 构造函数\r\n\t     * @param {[type]} options [description]\r\n\t     */\r\n\t    function Connector(options) {\r\n\t        Node.call(this);\r\n\t        var opt = options || {};\r\n\t        if (opt.model) {\r\n\t            this.resourceId = opt.model.get(\"resourceId\");\r\n\t            this.model = opt.model;\r\n\t        } else {\r\n\t            this.resourceId = Util.getUUID(); // 生成节点ID\r\n\t            this.model = new Model({});\r\n\t        }\r\n\t        var defaultOptions = {\r\n\t            symbol: { type: \"arrow\", size: 10, color: Connector.NORMAL_COLOR, both:false }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t            style: { lineWidth: 1, stroke: Connector.NORMAL_COLOR, lineType: Connector.TYPE_STRAIGHT }, //样式\r\n\t            hoverStyle: { lineWidth: 2, stroke: Connector.SELECTED_COLOR }, //移上去的样式\r\n\t            arrowHoverStyle: { fill: Connector.SELECTED_COLOR},\r\n\t            shape: { points: null, smooth: false, smoothConstraint: null }, //形状\r\n\t            position: { startPos:null, endPos:null,  //指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t                        startOffset:[0,0],  // 起始线段离节点的偏移\r\n\t                        endOffset:[0,0],    // 终止线段离节点的偏移\r\n\t                        escapeDistance:[30,30], // 第一条折线的长度，最后一条折线的长度\r\n\t                        points:null    //不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n\t                    },\r\n\t            autoChangePosition: false,\r\n\t            isEdit: true, //是否可编辑\r\n\t            text: {\r\n\t                text: \"\",\r\n\t                color: '#000000', // 文本颜色\r\n\t                textFont: '12px Microsoft YaHei',\r\n\t                textPos: 'center'\r\n\t            },\r\n\t            z: 0\r\n\t        }\r\n\t\r\n\t        this.options = zrUtil.merge(defaultOptions, opt, true);\r\n\t        this.handles = [];\r\n\t        this.conPointsGroup = new graphic.Group();\r\n\t        this.startNode = null;\r\n\t        this.endNode = null;\r\n\t        this.line = null;\r\n\t        this.groupCurve = new graphic.Group();\r\n\t        this.icons = []; // 用于存储线段上面的操作图标\r\n\t        this.render();\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 重新画线，如果传空则根据turningPoints 重新画线\r\n\t     * @param  {[type]} points [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    Connector.prototype.refresh = function(arrPoints) {\r\n\t        if (arrPoints) {\r\n\t            this.turningPoints = arrPoints;\r\n\t        }\r\n\t        //将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n\t        var points = Util.traslatePoints(this.turningPoints);\r\n\t\r\n\t        if ((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {\r\n\t            this.modifyCurve(this.turningPoints);\r\n\t        } else {\r\n\t            this.line.attr('shape', { points: points });\r\n\t        }\r\n\t\r\n\t        var lineText = this.childOfName('lineText');\r\n\t        //开始没有创建文本，后来传进来text了，需要先创建文本\r\n\t        if (!lineText && this.options.text.text) {\r\n\t            var text = this.drawText(\"lineText\", this.options.text.text, 0, 0);\r\n\t            this.add(text.text);\r\n\t            lineText = this.childOfName('lineText');\r\n\t        }\r\n\t        if (lineText) {\r\n\t            lineText.setStyle(\"text\", this.options.text.text);\r\n\t\r\n\t            var textPoint = this.getTextPostion(this.options.text);\r\n\t\r\n\t            // if (this.options.style.lineType == Connector.TYPE_STRAIGHT ) {\r\n\t            //     lineText.attr('rotation', this.getTextRotation(textPoint));\r\n\t            // }\r\n\t\r\n\t            lineText.attr(\"position\", textPoint);\r\n\t        }\r\n\t\r\n\t        this.refreshFromToSymbol(points);\r\n\t    };\r\n\t    /**\r\n\t     * 渲染\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.render = function() {\r\n\t        var that = this;\r\n\t        //1.创建箭头\r\n\t        this.renderFromToSymbol();\r\n\t\r\n\t        //2.创建线\r\n\t        this.curveLine = new graphic.BezierCurve({\r\n\t            //position: this.options.position,\r\n\t            style: this.options.style,\r\n\t            z: this.options.z\r\n\t        });\r\n\t        this.groupCurve.add(this.curveLine);\r\n\t        this.add(this.groupCurve);\r\n\t        this.add(this.conPointsGroup);\r\n\t\r\n\t        this.polyLine = new graphic.Polyline({\r\n\t            //position: this.options.position,\r\n\t            shape: this.options.shape,\r\n\t            style: this.options.style,\r\n\t            z: this.options.z\r\n\t        });\r\n\t        this.add(this.polyLine);\r\n\t\r\n\t        if ((this.options.style.lineType == Connector.TYPE_CURVE)) {\r\n\t            this.line = this.groupCurve;\r\n\t            this.createHoverStyle(this.curveLine);\r\n\t            this.polyLine.hide();\r\n\t        } else {\r\n\t            this.line = this.polyLine;\r\n\t            this.createHoverStyle(this.polyLine);\r\n\t            this.curveLine.hide();\r\n\t        }\r\n\t\r\n\t        //3.侦听线事件\r\n\t        var MOUSE_EVENT_NAMES = ['dblclick', 'click']; //'click', 'dblclick', 'mouseover', 'mouseout'\r\n\t        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n\t            this.line.on(eveName, zrUtil.bind(function(e) {\r\n\t                e.cancelBubble = true;\r\n\t                var params = {};\r\n\t                params.event = e;\r\n\t                params.type = \"Connector:\" + eveName;\r\n\t                params.target = that;\r\n\t                this.trigger(params.type, params);\r\n\t                this.setStyle({color:Connector.SELECTED_COLOR});\r\n\t                if (this.options.isEdit == false) {\r\n\t                    return; }\r\n\t\r\n\t                if (this.options.isEdit && this.turningPoints.length >= 2) {\r\n\t                    this.createAllconnectionPoint()\r\n\t                }\r\n\t                if (this.handles.length < 1) {\r\n\t                    this.shapeSetHandle();\r\n\t                }\r\n\t\r\n\t            }, this));\r\n\t        }, this);\r\n\t\r\n\t        //4.创建线上文本\r\n\t        if (this.options.text.text) {\r\n\t            var text = this.drawText(\"lineText\", this.options.text.text, 0, 0);\r\n\t            this.add(text.text);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    Connector.prototype.renderFromToSymbol = function(options) {\r\n\t        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle\r\n\t        if (symbolTo) {\r\n\t            this.add(symbolTo);\r\n\t        }\r\n\t        //如果双向箭头 则再创建首箭头\r\n\t        if (this.options.symbol.both) {\r\n\t            var symbolFrom = this.createSymbol('fromSymbol', this.options); //arrow,triangle\r\n\t            if (symbolFrom) {\r\n\t                this.add(symbolFrom);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    Connector.prototype.refreshFromToSymbol = function(points) {\r\n\t        var symbolTo = this.childOfName('toSymbol');\r\n\t        var symbolFrom = this.childOfName('fromSymbol');\r\n\t        if (symbolTo) {\r\n\t            if (this.options.effect && this.options.effect.show) {\r\n\t                new EffectLine(symbolTo, this.options, this.groupCurve, this.polyLine);\r\n\t            } else {\r\n\t                symbolTo.attr('position', points[points.length - 1]);\r\n\t                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]));\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if (symbolFrom) {\r\n\t            symbolFrom.attr('position', points[0]);\r\n\t            symbolFrom.attr('rotation', Util.tangentRotation(this.turningPoints[1], this.turningPoints[0]));\r\n\t        }\r\n\t    }\r\n\t    //设置style\r\n\t    Connector.prototype.setStyle = function(options) {\r\n\t        var symbolTo = null;\r\n\t        if (options.color) {\r\n\t            if (this.options.style.lineType == Connector.TYPE_CURVE) {\r\n\t                this.groupCurve.eachChild(function(curve) {\r\n\t                    curve.attr(\"style\", { stroke: options.color });\r\n\t                    graphic.setNormalStyle(curve, { stroke: options.color });\r\n\t                });\r\n\t            } else {\r\n\t                this.polyLine.attr(\"style\", { stroke: options.color });\r\n\t                graphic.setNormalStyle(this.polyLine, { stroke: options.color });\r\n\t            }\r\n\t            symbolTo = this.childOfName('toSymbol');\r\n\t            if (symbolTo) {\r\n\t                symbolTo.attr(\"style\", { fill: options.color });\r\n\t                graphic.setNormalStyle(symbolTo, { fill: options.color });\r\n\t            }\r\n\t            this.options.style.stroke = options.color;\r\n\t            this.model.set(\"options.style.stroke\", options.color);\r\n\t            this.model.set(\"options.symbol.color\", options.color);\r\n\t            this.options.symbol.color = options.color;\r\n\t        }\r\n\t\r\n\t        if (options.text) {\r\n\t            var lineText = this.childOfName('lineText');\r\n\t            //开始没有创建文本，后来传进来text了，需要先创建文本\r\n\t            if (!lineText && options.text.text) {\r\n\t                var text = this.drawText(\"lineText\", options.text.text, 0, 0);\r\n\t                this.add(text.text);\r\n\t                lineText = this.childOfName('lineText');\r\n\t            }\r\n\t\r\n\t            if (options.text.text || options.text.text == \"\") {\r\n\t                lineText.setStyle(\"text\", options.text.text);\r\n\t                this.options.text.text = options.text.text;\r\n\t            }\r\n\t            var textPoint = this.getTextPostion(options.text);\r\n\t            lineText.attr(\"position\", textPoint);\r\n\t            if (options.text.textPos) {\r\n\t                this.options.text.textPos = options.text.textPos;\r\n\t            }\r\n\t\r\n\t            if (options.text.color) {\r\n\t                lineText.attr(\"style\", {\r\n\t                    fill: options.text.color\r\n\t                });\r\n\t                this.options.text.color = options.text.color;\r\n\t            }\r\n\t            this.model.set(\"options.text\", options.text);\r\n\t        }\r\n\t\r\n\t        if (options.symbol) {\r\n\t            if (options.symbol.type) {\r\n\t                this.options.symbol.type = options.symbol.type;\r\n\t                this.model.set(\"options.symbol.type\", options.symbol.type);\r\n\t            }\r\n\t            if (options.symbol.size) {\r\n\t                this.options.symbol.size = options.symbol.size;\r\n\t                this.model.set(\"options.symbol.size\", options.symbol.size);\r\n\t            }\r\n\t            if (options.symbol.color) {\r\n\t                this.options.symbol.color = options.symbol.color;\r\n\t                this.model.set(\"options.symbol.color\", options.symbol.color);\r\n\t            }\r\n\t            if (options.symbol.z) {\r\n\t                this.options.symbol.z = options.symbol.z;\r\n\t                this.model.set(\"options.symbol.z\", options.symbol.z);\r\n\t            }\r\n\t\r\n\t            symbolTo = this.childOfName('toSymbol');\r\n\t            if (symbolTo) {\r\n\t                this.remove(symbolTo);\r\n\t            }\r\n\t            var symbol = this.createSymbol(\"toSymbol\", this.model.get(\"options\"))\r\n\t            if (symbol) {\r\n\t                this.add(symbol);\r\n\t            }\r\n\t            this.refresh();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取线段的位置\r\n\t     * @param  {Object} text {text:'', color:'', textPos:''}\r\n\t     * @return {Object}      {x,y}\r\n\t     */\r\n\t    Connector.prototype.getTextPostion = function(text) {\r\n\t        var textPostion = [];\r\n\t        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n\t        if (text && text.textPos) {\r\n\t            var offset = text.offset || 0;\r\n\t            var arrOffset = offset;\r\n\t            if (!zrUtil.isArray(offset)) {\r\n\t                arrOffset = [offset, 0];\r\n\t            }\r\n\t            if (text.textPos == 'start') {\r\n\t                textPostion = [this.turningPoints[0].x + arrOffset[0], this.turningPoints[0].y + arrOffset[1]];\r\n\t            } else if (text.textPos == 'end') {\r\n\t                var points = Util.getMaxLineLength([this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]]);\r\n\t                var angle = Util.getAngle(points[0], points[1]);\r\n\t                var length = Util.distance(points[0], points[1]) - textWidth;\r\n\t                var newPoint = Util.getEndPoint(points[0], length, angle);\r\n\t                textPostion = [newPoint.x + arrOffset[0], newPoint.y + arrOffset[1]];\r\n\t            } else {\r\n\t                var midPoint = this.middle(text);\r\n\t                textPostion = [midPoint[0] + arrOffset[0], midPoint[1] + arrOffset[1]];\r\n\t            }\r\n\t        } else {\r\n\t            var position = this.middle(text);\r\n\t            textPostion = [position[0] - textWidth / 2, position[1]];\r\n\t        }\r\n\t\r\n\t        return textPostion;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取线段的旋转角度\r\n\t     * @param  {Object} textPostion {x,y}\r\n\t     * @return {Number}             角度值\r\n\t     */\r\n\t    Connector.prototype.getTextRotation = function(textPostion) {\r\n\t        //计算出极坐标的角度\r\n\t        var points = Util.getMaxLineLength(this.turningPoints);\r\n\t        var angle = -Math.atan2(points[1].y - textPostion[1], points[1].x - textPostion[0]); //,Math.PI/2\r\n\t        return angle;\r\n\t    };\r\n\t\r\n\t    Connector.prototype.createHoverStyle = function(el) {\r\n\t        if (this.options.hoverStyle) {\r\n\t            graphic.setElementHoverStl(el, this.options.hoverStyle);\r\n\t\r\n\t            var symbolTo = this.childOfName('toSymbol');\r\n\t            if (symbolTo) { graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle); }\r\n\t\r\n\t            el.on('mouseover', zrUtil.bind(function() {\r\n\t                    graphic.doEnterHover(el);\r\n\t                    if (symbolTo) { graphic.doEnterHover(symbolTo); }\r\n\t\r\n\t                    this.groupCurve.eachChild(function(line) {\r\n\t                        graphic.doEnterHover(line);\r\n\t                    });\r\n\t                }, this))\r\n\t                .on('mouseout', zrUtil.bind(function() {\r\n\t                    graphic.doLeaveHover(el);\r\n\t                    if (symbolTo) { graphic.doLeaveHover(symbolTo); }\r\n\t                    this.groupCurve.eachChild(function(line) {\r\n\t                        graphic.doLeaveHover(line);\r\n\t                    });\r\n\t                }, this));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 创建Node的连接点\r\n\t     * @private\r\n\t     *\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.createAllconnectionPoint = function() {\r\n\t        var sRect = this.startNode.getRect ? this.startNode.getRect().boundingRect : Util.getRect(this.startNode).boundingRect;\r\n\t\r\n\t        var eRect = this.endNode.getRect ? this.endNode.getRect().boundingRect : Util.getRect(this.endNode).boundingRect;\r\n\t\r\n\t        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n\t        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\t\r\n\t        this.connectionPointCreate(this.startNode, sConnectorPoint.left, Connector.START_NODE + Connector.SEPERATOR + Connector.LEFT);\r\n\t        this.connectionPointCreate(this.startNode, sConnectorPoint.right, Connector.START_NODE + Connector.SEPERATOR + Connector.RIGHT);\r\n\t        this.connectionPointCreate(this.startNode, sConnectorPoint.top, Connector.START_NODE + Connector.SEPERATOR + Connector.TOP);\r\n\t        this.connectionPointCreate(this.startNode, sConnectorPoint.bottom, Connector.START_NODE + Connector.SEPERATOR + Connector.BOTTOM);\r\n\t\r\n\t        this.connectionPointCreate(this.endNode, eConnectorPoint.left, Connector.END_NODE + Connector.SEPERATOR + Connector.LEFT);\r\n\t        this.connectionPointCreate(this.endNode, eConnectorPoint.right, Connector.END_NODE + Connector.SEPERATOR + Connector.RIGHT);\r\n\t        this.connectionPointCreate(this.endNode, eConnectorPoint.top, Connector.END_NODE + Connector.SEPERATOR + Connector.TOP);\r\n\t        this.connectionPointCreate(this.endNode, eConnectorPoint.bottom, Connector.END_NODE + Connector.SEPERATOR + Connector.BOTTOM);\r\n\t\r\n\t\r\n\t        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n\t\r\n\t        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length - 1].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建连接点\r\n\t     * @private\r\n\t     * @param  {[type]} shape [description]\r\n\t     * @param  {[type]} point [description]\r\n\t     * @param  {[type]} type  [description]\r\n\t     * @return {[type]}       [description]\r\n\t     */\r\n\t    Connector.prototype.connectionPointCreate = function(shape, point, type) {\r\n\t        var conPoint = new ConnectionPoint(this, point, type, this.options);\r\n\t        this.conPointsGroup.add(conPoint.shape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 清空控制点\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.clearHandles = function() {\r\n\t        for (var i = 0; i < this.handles.length; i++) {\r\n\t            this.remove(this.handles[i].handleShape);\r\n\t        }\r\n\t        this.handles = [];\r\n\t        if (this.conPointsGroup) {\r\n\t            this.conPointsGroup.removeAll();\r\n\t        }\r\n\t        //恢复原来的颜色\r\n\t        this.setStyle({color:this.options.style.stroke});\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建拆线 线断的控制点\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.shapeSetHandle = function() {\r\n\t        for (var i = 1; i < this.turningPoints.length - 2; i++) {\r\n\t            var h;\r\n\t            var x, y;\r\n\t            //是否在一条线上\r\n\t            var isCollineaityFirst = Util.collinearity(this.turningPoints[i - 1], this.turningPoints[i], this.turningPoints[i + 1]);\r\n\t            var isCollineaitySecond = Util.collinearity(this.turningPoints[i], this.turningPoints[i + 1], this.turningPoints[i + 2]);\r\n\t            if ((!isCollineaityFirst && (!isCollineaitySecond || this.turningPoints[i + 1].equals(this.turningPoints[i + 2]))) || ((!isCollineaityFirst || this.turningPoints[i - 1].equals(this.turningPoints[i])) && !isCollineaitySecond)) {\r\n\t\r\n\t                if (this.turningPoints[i].x === this.turningPoints[i + 1].x) { //same vertical\r\n\t                    x = this.turningPoints[i].x;\r\n\t                    y = (this.turningPoints[i].y + this.turningPoints[i + 1].y) / 2;\r\n\t\r\n\t                    h = new Handle('h', x, y, this);\r\n\t\r\n\t\r\n\t                } else if (this.turningPoints[i].y === this.turningPoints[i + 1].y) { // same horizontal\r\n\t                    x = (this.turningPoints[i].x + this.turningPoints[i + 1].x) / 2;\r\n\t                    y = this.turningPoints[i].y;\r\n\t                    h = new Handle('v', x, y, this);\r\n\t                }\r\n\t                if (h) {\r\n\t                    this.add(h.handleShape);\r\n\t                    this.handles.push(h);\r\n\t                }\r\n\t\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 创建箭头\r\n\t     * @param  {[type]} name       [description]\r\n\t     * @param  {[type]} options [description]\r\n\t     * @return {[type]}            [description]\r\n\t     */\r\n\t    Connector.prototype.createSymbol = function(name, options) {\r\n\t        var symbolType = options.symbol.type;\r\n\t        var symbolSize = options.symbol.size;\r\n\t        if (symbolType === 'none') {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        if (!zrUtil.isArray(symbolSize)) {\r\n\t            symbolSize = [symbolSize, symbolSize];\r\n\t        }\r\n\t\r\n\t        var symbolZIndex = options.z;\r\n\t\r\n\t        if (options.symbol.z) { symbolZIndex = options.symbol.z }\r\n\t\r\n\t        var symbolPath = symbolUtil.createSymbol(\r\n\t            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,\r\n\t            symbolSize[0], symbolSize[1], symbolZIndex, options.symbol.color\r\n\t        );\r\n\t        symbolPath.name = name;\r\n\t\r\n\t        return symbolPath;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 绘制线段上的文本\r\n\t     * @param  {[type]} content [description]\r\n\t     * @param  {[type]} name [description]\r\n\t     * @param  {[type]} x       [description]\r\n\t     * @param  {[type]} y       [description]\r\n\t     * @param  {[type]} color   [description]\r\n\t     * @return {[type]}         [description]\r\n\t     */\r\n\t    Connector.prototype.drawText = function(name, content, x, y, color) {\r\n\t        var textStyle = zrUtil.defaults(this.options.text, {text:content, x:x, y:y, fill:color}, true);\r\n\t        var text = new graphic.Text({\r\n\t            style: textStyle,\r\n\t            zlevel: 20,\r\n\t            name : name\r\n\t        });\r\n\t        return {\r\n\t            text: text,\r\n\t            rect: text.getBoundingRect()\r\n\t        };\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取线段的中间值\r\n\t     * @return {[type]} text\r\n\t     */\r\n\t    Connector.prototype.middle = function() {\r\n\t\r\n\t        if (this.options.style.lineType == Connector.TYPE_STRAIGHT) {\r\n\t            var points = Util.getMaxLineLength(this.turningPoints);\r\n\t            //如果是求线段上的文字的中间值\r\n\t            // if(text) {\r\n\t            //     //取出字的长度，计算角度，\r\n\t            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n\t            //     var angle = Util.getAngle(points[0],points[1]);\r\n\t            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;\r\n\t            //     var newPoint = Util.getEndPoint(points[0], length, angle);\r\n\t            //     return [newPoint.x, newPoint.y];\r\n\t            // } else {\r\n\t            //     var middleX = (points[0].x + points[1].x)/2;\r\n\t            //     var middleY = (points[0].y + points[1].y) /2;\r\n\t            //     return [middleX, middleY];\r\n\t            // }\r\n\t            var middleX = (points[0].x + points[1].x) / 2;\r\n\t            var middleY = (points[0].y + points[1].y) / 2;\r\n\t            return [middleX, middleY];\r\n\t        } else if (this.options.style.lineType == Connector.TYPE_JAGGED) {\r\n\t\r\n\t            //find total distance\r\n\t            var distance = this.getLength();\r\n\t\r\n\t            //find between what turning points the half distance is\r\n\t            var index = -1;\r\n\t            var ellapsedDistance = 0;\r\n\t            for (var i = 0; i < this.turningPoints.length - 1; i++) {\r\n\t                index = i;\r\n\t                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);\r\n\t                if (ellapsedDistance + segment < distance / 2) {\r\n\t                    ellapsedDistance += segment;\r\n\t                } else {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t\r\n\t            //we have the middle distance somewhere between i(ndex) and i(ndex)+1\r\n\t            if (index != -1) {\r\n\t                var missingDistance = distance / 2 - ellapsedDistance;\r\n\t                if (Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3)) { //vertical segment (same x)\r\n\t                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];\r\n\t                } else if (Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3)) { //horizontal segment (same y)\r\n\t                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];\r\n\t                } else {\r\n\t                    console.error(\"Connector:middle() - this should never happen \" + this.turningPoints[index] + \" \" + this.turningPoints[index + 1] + \" nr of points \" + this.turningPoints.length);\r\n\t                }\r\n\t\r\n\t            }\r\n\t        } else if (this.options.style.lineType == Connector.TYPE_CURVE) {\r\n\t            var t = 0.5;\r\n\t            var l = this.getLength();\r\n\t\r\n\t            var walked = 0;\r\n\t            for (var j = 0; j < this.turningPoints.length - 1; j++) {\r\n\t                if (walked + Util.distance(this.turningPoints[j], this.turningPoints[j + 1]) > l * t) {\r\n\t                    break;\r\n\t                }\r\n\t\r\n\t                walked += Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);\r\n\t            }\r\n\t\r\n\t            var rest = l * t - walked;\r\n\t            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);\r\n\t\r\n\t            //find the position/ration of the middle of Polyline on current segment\r\n\t            var segmentPercent = rest / currentSegmentLength;\r\n\t\r\n\t            var Xp = segmentPercent * (this.turningPoints[j + 1].x - this.turningPoints[j].x) + this.turningPoints[j].x;\r\n\t            var Yp = segmentPercent * (this.turningPoints[j + 1].y - this.turningPoints[j].y) + this.turningPoints[j].y;\r\n\t\r\n\t            return [Xp, Yp];\r\n\t\r\n\t        }\r\n\t\r\n\t        return null;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * find total distance\r\n\t     * @return {Number} [description]\r\n\t     */\r\n\t    Connector.prototype.getLength = function() {\r\n\t        //find total distance\r\n\t        var distance = 0;\r\n\t        for (var i = 0; i < this.turningPoints.length - 1; i++) {\r\n\t            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);\r\n\t        }\r\n\t        return distance;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 转JSON对象 bpmn使用\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.toJSON = function() {\r\n\t\r\n\t        this.model.set(\"resourceId\", this.resourceId);\r\n\t        this.model.set(\"properties.type\", 14);\r\n\t\r\n\t        this.model.set(\"bounds.upperLeft.x\", this.position[0]);\r\n\t        this.model.set(\"bounds.upperLeft.y\", this.position[1]);\r\n\t        this.model.set(\"bounds.lowerRight.x\", parseInt(this.position[0] + this.getBoundingRect().width));\r\n\t        this.model.set(\"bounds.lowerRight.y\", parseInt(this.position[1] + this.getBoundingRect().height));\r\n\t        this.model.set(\"style.sPos\", this.options.position.startPos);\r\n\t        this.model.set(\"style.ePos\", this.options.position.endPos);\r\n\t        this.model.set(\"dockers\", this.turningPoints);\r\n\t        return this.model.option;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * refreshModel  flow当序列化的时候调用 更新线段的位置 及线上的icons\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.refreshModel = function() {\r\n\t        this.model.set(\"options\", zrUtil.clone(this.options));\r\n\t        this.model.set(\"options.dockers\", this.turningPoints);\r\n\t        var icons = [];\r\n\t        for (var i = 0; i < this.icons.length; i++) {\r\n\t            var iconNode = this.icons[i];\r\n\t            var option = [iconNode.key, {\r\n\t                icon: iconNode.style.image,\r\n\t                width: iconNode.style.width,\r\n\t                height: iconNode.style.height\r\n\t            }];\r\n\t            icons.push(option);\r\n\t        }\r\n\t        this.model.set(\"icons\", icons);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 调整曲线的形状\r\n\t     * @param  {array} points 点数组\r\n\t     * @return {void}\r\n\t     */\r\n\t    Connector.prototype.modifyCurve = function(points) {\r\n\t        var sol = this.getCurvePoint(points);\r\n\t\r\n\t        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段\r\n\t        var willDelCurves = [];\r\n\t        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve; j++) {\r\n\t            willDelCurves.push(this.groupCurve.childAt(j));\r\n\t        }\r\n\t        zrUtil.each(willDelCurves, function(curve) {\r\n\t            this.groupCurve.remove(curve);\r\n\t        }, this);\r\n\t        // 2. 遍历曲线   如果存在则直接设置形状，否则创建\r\n\t        for (var i = 0; i < sol.length; i++) {\r\n\t            var line = this.groupCurve.childAt(i);\r\n\t            if (line) {\r\n\t                line.attr('shape', sol[i]);\r\n\t            } else {\r\n\t                var cure = new graphic.BezierCurve({\r\n\t                   // position: this.options.position,\r\n\t                    style: this.options.style,\r\n\t                    shape: sol[i],\r\n\t                    z: this.options.z\r\n\t                });\r\n\t                this.groupCurve.add(cure);\r\n\t                this.createHoverStyle(cure);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 根据传入的点数组计算曲线的点\r\n\t     * @param  {array} P 点数组\r\n\t     * @return {object}        曲线的点数组\r\n\t     */\r\n\t    Connector.prototype.getCurvePoint = function(P) {\r\n\t        var n = P.length;\r\n\t        var sol = [];\r\n\t        if (n === 3) {\r\n\t            sol.push({\r\n\t                x1: P[0].x,\r\n\t                y1: P[0].y,\r\n\t                cpx1: P[1].x,\r\n\t                cpy1: P[1].y,\r\n\t                x2: P[2].x,\r\n\t                y2: P[2].y\r\n\t            });\r\n\t            return sol;\r\n\t        } else if (n === 4) {\r\n\t            sol.push({\r\n\t                x1: P[0].x,\r\n\t                y1: P[0].y,\r\n\t                cpx1: P[1].x,\r\n\t                cpy1: P[1].y,\r\n\t                cpx2: P[2].x,\r\n\t                cpy2: P[2].y,\r\n\t                x2: P[3].x,\r\n\t                y2: P[3].y\r\n\t            });\r\n\t            return sol;\r\n\t        }\r\n\t\r\n\t\r\n\t        /**Computes the sum between two point\r\n\t         *@param p1 - {Point}\r\n\t         *@param p2 - {Point}\r\n\t         *@return {Point} the sum of initial points\r\n\t         **/\r\n\t        function sum(p1, p2) {\r\n\t            return new Point(p1.x + p2.x, p1.y + p2.y);\r\n\t        }\r\n\t\r\n\t\r\n\t        /**Computes the division of a {Point} by a number\r\n\t         *@param p - {Point}\r\n\t         *@param nr - {Number}\r\n\t         *@return {Point}\r\n\t         **/\r\n\t        function divide(p, nr) {\r\n\t            if (nr == 0) {\r\n\t                throw \"Division by zero not allowed (yet :) \" + this.callee;\r\n\t            }\r\n\t            return new Point(p.x / nr, p.y / nr);\r\n\t        }\r\n\t\r\n\t        /**Computes the multiplication of a {Point} by a number\r\n\t         *@param p - {Point}\r\n\t         *@param nr - {Number}\r\n\t         *@return {Point}\r\n\t         **/\r\n\t        function multiply(p, nr) {\r\n\t            return new Point(p.x * nr, p.y * nr);\r\n\t        }\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t        /*\r\n\t         *I do not get why first 4 must be 0 and last 3 of same value.....\r\n\t         *but otherwise we will get division by zero\r\n\t         */\r\n\t        var k = [0, 0, 0];\r\n\t\r\n\t        var j;\r\n\t        for (j = 0; j <= n - 3; j++) {\r\n\t            k.push(j);\r\n\t        }\r\n\t\r\n\t        k.push(n - 3, n - 3);\r\n\t\r\n\t\r\n\t\r\n\t        for (var i = 1; i <= n - 3; i++) {\r\n\t            //q1 - compute start point\r\n\t            var q1 = divide(sum(multiply(P[i], k[i + 4] - k[i + 2]), multiply(P[i + 1], k[i + 2] - k[i + 1])), k[i + 4] - k[i + 1]);\r\n\t\r\n\t            //q0 - compute 1st controll point\r\n\t            var q_01 = (k[i + 3] - k[i + 2]) / (k[i + 3] - k[i + 1]);\r\n\t            var q_02 = divide(sum(multiply(P[i - 1], k[i + 3] - k[i + 2]), multiply(P[i], k[i + 2] - k[i])), k[i + 3] - k[i]);\r\n\t            var q_03 = multiply(q1, (k[i + 2] - k[i + 1]) / (k[i + 3] - k[i + 1]));\r\n\t            var q0 = sum(multiply(q_02, q_01), q_03);\r\n\t\r\n\t            //q2 - compute 2nd controll point\r\n\t            var q2 = divide(sum(multiply(P[i], k[i + 4] - k[i + 3]), multiply(P[i + 1], k[i + 3] - k[i + 1])), k[i + 4] - k[i + 1]);\r\n\t\r\n\t            //q3 - compute end point\r\n\t            var q_31 = (k[i + 3] - k[i + 2]) / (k[i + 4] - k[i + 2]);\r\n\t            var q_32 = divide(sum(multiply(P[i + 1], k[i + 5] - k[i + 3]), multiply(P[i + 2], k[i + 3] - k[i + 2])), k[i + 5] - k[i + 2]);\r\n\t            var q_33 = multiply(q2, (k[i + 4] - k[i + 3]) / (k[i + 4] - k[i + 2]));\r\n\t            var q3 = sum(multiply(q_32, q_31), q_33);\r\n\t\r\n\t            //store solution\r\n\t            //\r\n\t            sol.push({\r\n\t                x1: q0.x,\r\n\t                y1: q0.y,\r\n\t                cpx1: q1.x,\r\n\t                cpy1: q1.y,\r\n\t                cpx2: q2.x,\r\n\t                cpy2: q2.y,\r\n\t                x2: q3.x,\r\n\t                y2: q3.y\r\n\t            });\r\n\t        }\r\n\t\r\n\t        return sol;\r\n\t    };\r\n\t\r\n\t\r\n\t    Util.inherits(Connector, Node);\r\n\t\r\n\t    module.exports = Connector;\r\n\t\r\n\t\r\n\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Symbol factory\r\n\t\r\n\t\r\n\t    var graphic = __webpack_require__(4);\r\n\t    var BoundingRect = __webpack_require__(27);\r\n\t    /**\r\n\t     * Triangle shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Triangle = graphic.extendShape({\r\n\t        type: 'triangle',\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t        buildPath: function (path, shape) {\r\n\t            var cx = shape.cx;\r\n\t            var cy = shape.cy;\r\n\t            var width = shape.width / 2;\r\n\t            var height = shape.height / 2;\r\n\t            path.moveTo(cx, cy - height);\r\n\t            path.lineTo(cx + width, cy + height);\r\n\t            path.lineTo(cx - width, cy + height);\r\n\t            path.closePath();\r\n\t        }\r\n\t    });\r\n\t    /**\r\n\t     * Diamond shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Diamond = graphic.extendShape({\r\n\t        type: 'diamond',\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t        buildPath: function (path, shape) {\r\n\t            var cx = shape.cx;\r\n\t            var cy = shape.cy;\r\n\t            var width = shape.width / 2;\r\n\t            var height = shape.height / 2;\r\n\t            path.moveTo(cx, cy - height);\r\n\t            path.lineTo(cx + width, cy);\r\n\t            path.lineTo(cx, cy + height);\r\n\t            path.lineTo(cx - width, cy);\r\n\t            path.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t    /**\r\n\t     * Pin shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Pin = graphic.extendShape({\r\n\t        type: 'pin',\r\n\t        shape: {\r\n\t            // x, y on the cusp\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (path, shape) {\r\n\t            var x = shape.x;\r\n\t            var y = shape.y;\r\n\t            var w = shape.width / 5 * 3;\r\n\t            // Height must be larger than width\r\n\t            var h = Math.max(w, shape.height);\r\n\t            var r = w / 2;\r\n\t\r\n\t            // Dist on y with tangent point and circle center\r\n\t            var dy = r * r / (h - r);\r\n\t            var cy = y - h + r + dy;\r\n\t            var angle = Math.asin(dy / r);\r\n\t            // Dist on x with tangent point and circle center\r\n\t            var dx = Math.cos(angle) * r;\r\n\t\r\n\t            var tanX = Math.sin(angle);\r\n\t            var tanY = Math.cos(angle);\r\n\t\r\n\t            path.arc(\r\n\t                x, cy, r,\r\n\t                Math.PI - angle,\r\n\t                Math.PI * 2 + angle\r\n\t            );\r\n\t\r\n\t            var cpLen = r * 0.6;\r\n\t            var cpLen2 = r * 0.7;\r\n\t            path.bezierCurveTo(\r\n\t                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\r\n\t                x, y - cpLen2,\r\n\t                x, y\r\n\t            );\r\n\t            path.bezierCurveTo(\r\n\t                x, y - cpLen2,\r\n\t                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\r\n\t                x - dx, cy + dy\r\n\t            );\r\n\t            path.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t    /**\r\n\t     * Arrow shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Arrow = graphic.extendShape({\r\n\t\r\n\t        type: 'arrow',\r\n\t\r\n\t        shape: {\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var height = shape.height;\r\n\t            var width = shape.width;\r\n\t            var x = shape.x;\r\n\t            var y = shape.y;\r\n\t            var dx = width / 3 * 2;\r\n\t            ctx.moveTo(x, y);\r\n\t            ctx.lineTo(x + dx, y + height);\r\n\t            ctx.lineTo(x, y + height / 4 * 3);\r\n\t            ctx.lineTo(x - dx, y + height);\r\n\t            ctx.lineTo(x, y);\r\n\t            ctx.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t    /**\r\n\t     * Map of path contructors\r\n\t     * @type {Object.<string, module:zrender/graphic/Path>}\r\n\t     */\r\n\t    var symbolCtors = {\r\n\t        line: graphic.Line,\r\n\t\r\n\t        rect: graphic.Rect,\r\n\t\r\n\t        roundRect: graphic.Rect,\r\n\t\r\n\t        square: graphic.Rect,\r\n\t\r\n\t        circle: graphic.Circle,\r\n\t\r\n\t        diamond: Diamond,\r\n\t\r\n\t        pin: Pin,\r\n\t\r\n\t        arrow: Arrow,\r\n\t\r\n\t        triangle: Triangle\r\n\t    };\r\n\t\r\n\t    var symbolShapeMakers = {\r\n\t\r\n\t        line: function (x, y, w, h, shape) {\r\n\t            // FIXME\r\n\t            shape.x1 = x;\r\n\t            shape.y1 = y + h / 2;\r\n\t            shape.x2 = x + w;\r\n\t            shape.y2 = y + h / 2;\r\n\t        },\r\n\t\r\n\t        rect: function (x, y, w, h, shape) {\r\n\t            shape.x = x;\r\n\t            shape.y = y;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        roundRect: function (x, y, w, h, shape) {\r\n\t            shape.x = x;\r\n\t            shape.y = y;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t            shape.r = Math.min(w, h) / 4;\r\n\t        },\r\n\t\r\n\t        square: function (x, y, w, h, shape) {\r\n\t            var size = Math.min(w, h);\r\n\t            shape.x = x;\r\n\t            shape.y = y;\r\n\t            shape.width = size;\r\n\t            shape.height = size;\r\n\t        },\r\n\t\r\n\t        circle: function (x, y, w, h, shape) {\r\n\t            // Put circle in the center of square\r\n\t            shape.cx = x + w / 2;\r\n\t            shape.cy = y + h / 2;\r\n\t            shape.r = Math.min(w, h) / 2;\r\n\t        },\r\n\t\r\n\t        diamond: function (x, y, w, h, shape) {\r\n\t            shape.cx = x + w / 2;\r\n\t            shape.cy = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        pin: function (x, y, w, h, shape) {\r\n\t            shape.x = x + w / 2;\r\n\t            shape.y = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        arrow: function (x, y, w, h, shape) {\r\n\t            shape.x = x + w / 2;\r\n\t            shape.y = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        triangle: function (x, y, w, h, shape) {\r\n\t            shape.cx = x + w / 2;\r\n\t            shape.cy = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    var symbolBuildProxies = {};\r\n\t    for (var name in symbolCtors) {\r\n\t        symbolBuildProxies[name] = new symbolCtors[name]();\r\n\t    }\r\n\t\r\n\t    var Symbol = graphic.extendShape({\r\n\t\r\n\t        type: 'symbol',\r\n\t\r\n\t        shape: {\r\n\t            symbolType: '',\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        beforeBrush: function () {\r\n\t            var style = this.style;\r\n\t            var shape = this.shape;\r\n\t            // FIXME\r\n\t            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\r\n\t                style.textPosition = ['50%', '40%'];\r\n\t                style.textAlign = 'center';\r\n\t                style.textVerticalAlign = 'middle';\r\n\t            }\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var symbolType = shape.symbolType;\r\n\t            var proxySymbol = symbolBuildProxies[symbolType];\r\n\t            if (shape.symbolType !== 'none') {\r\n\t                if (!proxySymbol) {\r\n\t                    // Default rect\r\n\t                    symbolType = 'rect';\r\n\t                    proxySymbol = symbolBuildProxies[symbolType];\r\n\t                }\r\n\t                symbolShapeMakers[symbolType](\r\n\t                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\r\n\t                );\r\n\t                proxySymbol.buildPath(ctx, proxySymbol.shape);\r\n\t            }\r\n\t        }\r\n\t    });\r\n\t\r\n\t    // Provide setColor helper method to avoid determine if set the fill or stroke outside\r\n\t    var symbolPathSetColor = function (color) {\r\n\t        if (this.type !== 'image') {\r\n\t            var symbolStyle = this.style;\r\n\t            var symbolShape = this.shape;\r\n\t            if (symbolShape && symbolShape.symbolType === 'line') {\r\n\t                symbolStyle.stroke = color;\r\n\t            }\r\n\t            else if (this.__isEmptyBrush) {\r\n\t                symbolStyle.stroke = color;\r\n\t                symbolStyle.fill = '#fff';\r\n\t            }\r\n\t            else {\r\n\t                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\r\n\t                symbolStyle.fill && (symbolStyle.fill = color);\r\n\t                symbolStyle.stroke && (symbolStyle.stroke = color);\r\n\t            }\r\n\t            this.dirty();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    var symbolUtil = {\r\n\t        /**\r\n\t         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\r\n\t         * @param {string} symbolType\r\n\t         * @param {number} x\r\n\t         * @param {number} y\r\n\t         * @param {number} w\r\n\t         * @param {number} h\r\n\t         * @param {number} z\r\n\t         * @param {string} color\r\n\t         */\r\n\t        createSymbol: function (symbolType, x, y, w, h, z, color) {\r\n\t            var isEmpty = symbolType.indexOf('empty') === 0;\r\n\t            if (isEmpty) {\r\n\t                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\r\n\t            }\r\n\t            var symbolPath;\r\n\t\r\n\t            if (symbolType.indexOf('image://') === 0) {\r\n\t                symbolPath = new graphic.Image({\r\n\t                    style: {\r\n\t                        image: symbolType.slice(8),\r\n\t                        x: x,\r\n\t                        y: y,\r\n\t                        width: w,\r\n\t                        height: h\r\n\t                    },\r\n\t                    z: z\r\n\t                });\r\n\t            }\r\n\t            else if (symbolType.indexOf('path://') === 0) {\r\n\t                symbolPath = graphic.makePath(symbolType.slice(7), {z: z, rectHover: true}, new BoundingRect(x, y, w, h));\r\n\t            }\r\n\t            else {\r\n\t                symbolPath = new Symbol({\r\n\t                    shape: {\r\n\t                        symbolType: symbolType,\r\n\t                        x: x,\r\n\t                        y: y,\r\n\t                        width: w,\r\n\t                        height: h\r\n\t                    },\r\n\t                    z: z\r\n\t                });\r\n\t            }\r\n\t\r\n\t            symbolPath.__isEmptyBrush = isEmpty;\r\n\t\r\n\t            symbolPath.setColor = symbolPathSetColor;\r\n\t\r\n\t            symbolPath.setColor(color);\r\n\t\r\n\t            return symbolPath;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = symbolUtil;\r\n\t\r\n\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 画句柄\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var graphic = __webpack_require__(4);\r\n\t    var Util = __webpack_require__(65);\r\n\t    function Handle(type, x, y, connector){\r\n\t        this.type = type;\r\n\t\r\n\t        this.x = x;\r\n\t\r\n\t        this.y = y;\r\n\t\r\n\t        this.visible = true;\r\n\t\r\n\t        this.connector = connector;\r\n\t\r\n\t        this.handleShape = new graphic.Circle({\r\n\t            shape: {\r\n\t                cx: x,\r\n\t                cy: y,\r\n\t                r: Handle.RADIUS\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                fill: \"rgb(0,255,0)\",\r\n\t                stroke:\"rgb(0,0,0)\"\r\n\t            },\r\n\t            z : connector.options.z + 2,  //节点Z为1 线段为0;\r\n\t            draggable:true\r\n\t        });\r\n\t\r\n\t        var that = this;\r\n\t        this.handleShape.on(\"drag\", function(e) {\r\n\t            that.actionConnector(e.offsetX,e.offsetY);\r\n\t        });\r\n\t       // return this.circle;\r\n\t    }\r\n\t\r\n\t    Handle.RADIUS = 4;\r\n\t\r\n\t    Handle.prototype = {\r\n\t\r\n\t        constructor : Handle,\r\n\t\r\n\t        equals : function(anotherHandle){\r\n\t            if(!anotherHandle instanceof Handle){\r\n\t                return false;\r\n\t            }\r\n\t\r\n\t            return this.type == anotherHandle.type\r\n\t            && this.x == anotherHandle.x\r\n\t            && this.y == anotherHandle.y\r\n\t            && this.visible == anotherHandle.visible;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 移动句柄\r\n\t         * @param  {[type]} newX [description]\r\n\t         * @param  {[type]} newY [description]\r\n\t         * @return {[type]}      [description]\r\n\t         */\r\n\t        actionConnector: function(newX, newY){\r\n\t            switch(this.type){\r\n\t                case 'v':\r\n\t                    var index;\r\n\t                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n\t                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n\t                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y\r\n\t                            && this.connector.turningPoints[i].y == this.y\r\n\t                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x\r\n\t                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)\r\n\t                        {\r\n\t                            index = i;\r\n\t                        }\r\n\t                    }\r\n\t                    var deltaY = newY - this.y;\r\n\t                    var translationMatrix = Util.translationMatrix(0, deltaY);\r\n\t\r\n\t                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n\t                    this.connector.turningPoints[index].transform(translationMatrix);\r\n\t                    this.connector.refresh();\r\n\t                    this.y = newY;  //将句柄新的位置赋值给y\r\n\t\r\n\t                    break;\r\n\t\r\n\t                case 'h':\r\n\t                    var index;\r\n\t                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n\t                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n\t                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x\r\n\t                            && this.connector.turningPoints[i].x == this.x\r\n\t                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y\r\n\t                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)\r\n\t                            {\r\n\t                            index = i;\r\n\t                        }\r\n\t                    }\r\n\t                    var deltaX = newX-this.x;\r\n\t                    var translationMatrix = Util.translationMatrix(deltaX, 0);\r\n\t                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n\t                    this.connector.turningPoints[index].transform(translationMatrix);\r\n\t                    this.connector.refresh();\r\n\t                    this.x = newX; //将句柄新的位置赋值给x\r\n\t\r\n\t                    break;\r\n\t            }\r\n\t           //. this.shape.updateMiddleText();\r\n\t        }\r\n\t    };\r\n\t    module.exports = Handle;\r\n\t\r\n\t\r\n\t\r\n\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连线动态效果\r\n\t * @author miao.cunzhi\r\n\t */\r\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var vec2 = __webpack_require__(15);\r\n\t    var curveUtil = __webpack_require__(31);\r\n\t    var symbolUtil = __webpack_require__(83);\r\n\t\r\n\t    function EffectLine(symbol, options, groupCurve, polyLine) {\r\n\t        this._lastFrame = 0;\r\n\t        this._lastFramePercent = 0;\r\n\t        this.symbol = symbol;\r\n\t        this.groupCurve = groupCurve;\r\n\t        this.initSymbol(options, polyLine);\r\n\t    }\r\n\t    var EffectLineProto = EffectLine.prototype;\r\n\t\r\n\t    EffectLineProto.initSymbol = function(options, polyLine) {\r\n\t        var that = this;\r\n\t        this.symbol.z2 = 100;\r\n\t        this.symbol.culling = true;\r\n\t        var period = options.effect.period * 1000;\r\n\t        this.symbol.__t = 0;\r\n\t        this.symbol.stopAnimation();\r\n\t        if ((options.style.lineType == \"curve\")) {\r\n\t            if (this.groupCurve) {\r\n\t                var i = 0;\r\n\t                period = period / this.groupCurve._children.length;\r\n\t                this.groupCurveAnimate(this.groupCurve._children[0], i, period);\r\n\t            }\r\n\t\r\n\t        } else {\r\n\t            this.symbol.animate('', true)\r\n\t                .when(period, {\r\n\t                    __t: 1\r\n\t                })\r\n\t                .delay(0)\r\n\t                .during(function() {\r\n\t                    that.updateSymbolPositionPolyline();\r\n\t                })\r\n\t                .start();\r\n\t            this.setAnimationPointsPolyline(polyLine.shape.points);\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {\r\n\t        var that = this;\r\n\t        if (curveLine == undefined) {\r\n\t            curveLine = this.groupCurve._children[0];\r\n\t            i = 0;\r\n\t        }\r\n\t        var points;\r\n\t        var pos = curveLine.shape;\r\n\t        points = [\r\n\t            [pos.x1, pos.y1],\r\n\t            [pos.x2, pos.y2],\r\n\t            [pos.cpx1, pos.cpy1],\r\n\t            [pos.cpx2, pos.cpy2]\r\n\t        ];\r\n\t        this.setAnimationPointsBezierCurve(points);\r\n\t        this.symbol.animate('')\r\n\t            .when(period, {\r\n\t                __t: 1\r\n\t            })\r\n\t            .delay(0)\r\n\t            .during(function() {\r\n\t                that.updateSymbolPositionBezierCurve();\r\n\t            })\r\n\t            .done(function() {\r\n\t                that.symbol.__t = 0;\r\n\t                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);\r\n\t            })\r\n\t            .start();\r\n\t\r\n\t    };\r\n\t\r\n\t\r\n\t    EffectLineProto.setAnimationPointsBezierCurve = function(points) {\r\n\t        this.symbol.__p1 = points[0];\r\n\t        this.symbol.__p2 = points[1];\r\n\t        this.symbol.__cp1 = points[2] || [\r\n\t            (points[0][0] + points[1][0]) / 2,\r\n\t            (points[0][1] + points[1][1]) / 2\r\n\t        ];\r\n\t        this.symbol.__cp2 = points[3];\r\n\t    };\r\n\t\r\n\t    EffectLineProto.updateSymbolPositionBezierCurve = function() {\r\n\t        var p1 = this.symbol.__p1;\r\n\t        var p2 = this.symbol.__p2;\r\n\t        var cp1 = this.symbol.__cp1;\r\n\t        var cp2 = this.symbol.__cp2;\r\n\t        var t = this.symbol.__t;\r\n\t        var pos = this.symbol.position;\r\n\t        var tx, ty;\r\n\t        if (cp2[0] != undefined) {\r\n\t            var cubicAt = curveUtil.cubicAt;\r\n\t            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;\r\n\t            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n\t            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n\t            // Tangent\r\n\t            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n\t            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n\t        } else {\r\n\t            var quadraticAt = curveUtil.quadraticAt;\r\n\t            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;\r\n\t            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);\r\n\t            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);\r\n\t            // Tangent\r\n\t            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);\r\n\t            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);\r\n\t        }\r\n\t        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;\r\n\t\r\n\t        this.symbol.ignore = false;\r\n\t    };\r\n\t\r\n\t    EffectLineProto.setAnimationPointsPolyline = function(points) {\r\n\t        this._points = points;\r\n\t        var accLenArr = [0];\r\n\t        var len = 0;\r\n\t        for (var i = 1; i < points.length; i++) {\r\n\t            var p1 = points[i - 1];\r\n\t            var p2 = points[i];\r\n\t            len += vec2.dist(p1, p2);\r\n\t            accLenArr.push(len);\r\n\t        }\r\n\t        if (len === 0) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        for (var j = 0; j < accLenArr.length; j++) {\r\n\t            accLenArr[j] /= len;\r\n\t        }\r\n\t        this._offsets = accLenArr;\r\n\t        this._length = len;\r\n\t        this.symbol._lastFrame = 0;\r\n\t        this.symbol.__lastFramePercent = 0;\r\n\t    };\r\n\t\r\n\t    EffectLineProto.updateSymbolPositionPolyline = function() {\r\n\t        var t = this.symbol.__t;\r\n\t        var points = this._points;\r\n\t        var offsets = this._offsets;\r\n\t        var len = points.length;\r\n\t\r\n\t        if (!offsets) {\r\n\t            // Has length 0\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var lastFrame = this._lastFrame;\r\n\t        var frame;\r\n\t\r\n\t        if (t < this._lastFramePercent) {\r\n\t            // Start from the next frame\r\n\t            // PENDING start from lastFrame ?\r\n\t            var start = Math.min(lastFrame + 1, len - 1);\r\n\t            for (frame = start; frame >= 0; frame--) {\r\n\t                if (offsets[frame] <= t) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            // PENDING really need to do this ?\r\n\t            frame = Math.min(frame, len - 2);\r\n\t        } else {\r\n\t            for (var frame = lastFrame; frame < len; frame++) {\r\n\t                if (offsets[frame] > t) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            frame = Math.min(frame - 1, len - 2);\r\n\t        }\r\n\t        vec2.lerp(\r\n\t            this.symbol.position, points[frame], points[frame + 1],\r\n\t            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])\r\n\t        );\r\n\t\r\n\t        this._lastFrame = frame;\r\n\t        this._lastFramePercent = t;\r\n\t        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);\r\n\t        this.symbol.rotation = angle - Math.PI / 2;\r\n\t        this.symbol.ignore = false;\r\n\t    };\r\n\t    module.exports = EffectLine;\r\n\t\r\n\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 控制点\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var graphic = __webpack_require__(4);\r\n\t    function ConnectionPoint(connector, point, type, options){\r\n\t        this.connector = connector;\r\n\t\r\n\t        this.point = point.clone();\r\n\t\r\n\t        this.type = type;\r\n\t\r\n\t        this.color = ConnectionPoint.NORMAL_COLOR;\r\n\t\r\n\t        this.oType = 'ConnectionPoint';\r\n\t\r\n\t        this.shape = new graphic.Circle({\r\n\t            shape: {\r\n\t                cx: this.point.x,\r\n\t                cy: this.point.y,\r\n\t                r: ConnectionPoint.RADIUS\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                fill: this.color,\r\n\t                stroke:'#000000'\r\n\t            },\r\n\t            z : options.z + 2  //节点Z为1 线段为0;\r\n\t        });\r\n\t        this.shape.type =  this.type;\r\n\t\r\n\t        this.shape.connector = connector;\r\n\t        //return this.circle;\r\n\t    }\r\n\t\r\n\t    ConnectionPoint.NORMAL_COLOR = \"#FFFF33\"; //yellow.\r\n\t\r\n\t    ConnectionPoint.OVER_COLOR = \"#FF9900\"; //orange\r\n\t\r\n\t    ConnectionPoint.CONNECTED_COLOR = \"#ff0000\"; //red\r\n\t\r\n\t    ConnectionPoint.RADIUS = 4;\r\n\t\r\n\t    ConnectionPoint.TYPE_FIGURE = 'figure';\r\n\t\r\n\t    ConnectionPoint.TYPE_CONNECTOR = 'connector';\r\n\t\r\n\t    ConnectionPoint.prototype = {\r\n\t\r\n\t        constructor : ConnectionPoint,\r\n\t\r\n\t        equals : function(anotherConnectionPoint){\r\n\t            return this.point.equals(anotherConnectionPoint.point)\r\n\t            && this.connector == anotherConnectionPoint.connector\r\n\t            && this.type == anotherConnectionPoint.type\r\n\t            && this.color == anotherConnectionPoint.color\r\n\t            && this.radius == anotherConnectionPoint.radius;\r\n\t        }\r\n\t\r\n\t\r\n\t    };\r\n\t    module.exports = ConnectionPoint;\r\n\t\r\n\t\r\n\t\r\n\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 节点等的模型\r\n\t * 里面存的数据用来处理序列化和反序列化\r\n\t * @class fish.topo.model\r\n\t */\r\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var clazzUtil = __webpack_require__(88);\r\n\t\r\n\t    function Model(option, parentModel,  extraOpt) {\r\n\t        this.parentModel = parentModel;\r\n\t        this.option = option;\r\n\t\r\n\t        // Simple optimization\r\n\t        if (this.init) {\r\n\t            if (arguments.length <= 3) {\r\n\t                this.init(option, parentModel,  extraOpt);\r\n\t            }\r\n\t            else {\r\n\t                this.init.apply(this, arguments);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    Model.prototype = {\r\n\t\r\n\t        constructor: Model,\r\n\t\r\n\t        /**\r\n\t         * Model 的初始化函数\r\n\t         * @private\r\n\t         * @param {Object} option\r\n\t         */\r\n\t        init: function (option) {\r\n\t            zrUtil.merge(option, this.getDefaultOption());\r\n\t        },\r\n\t\r\n\t        getDefaultOption: function () {\r\n\t            if (!this.hasOwnProperty('__defaultOption')) {\r\n\t                var optList = [];\r\n\t                var Class = this.constructor;\r\n\t                while (Class) {\r\n\t                    var opt = Class.prototype.defaultOption;\r\n\t                    opt && optList.push(opt);\r\n\t                    Class = Class.superClass;\r\n\t                }\r\n\t\r\n\t                var defaultOption = {};\r\n\t                for (var i = optList.length - 1; i >= 0; i--) {\r\n\t                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\r\n\t                }\r\n\t                this.__defaultOption = defaultOption;\r\n\t            }\r\n\t            return this.__defaultOption;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        mergeOption: function (option) {\r\n\t            zrUtil.merge(this.option, option, true);\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 获取model的某个属性的值\r\n\t         * @param {string} path model中的属性\r\n\t         * @return {String}\r\n\t         *\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *          node.model.get(\"options.text\");\r\n\t         */\r\n\t        get: function (path, ignoreParent) {\r\n\t            if (!path) {\r\n\t                return this.option;\r\n\t            }\r\n\t\r\n\t            if (typeof path === 'string') {\r\n\t                path = path.split('.');\r\n\t            }\r\n\t\r\n\t            var obj = this.option;\r\n\t            var parentModel = this.parentModel;\r\n\t            for (var i = 0; i < path.length; i++) {\r\n\t                // obj could be number/string/... (like 0)\r\n\t                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;\r\n\t                if (obj == null) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            if (obj == null && parentModel && !ignoreParent) {\r\n\t                obj = parentModel.get(path);\r\n\t            }\r\n\t            return obj;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 设置model的某个属性的值\r\n\t         * @param {string} path model中的属性\r\n\t         * @param {String} value 所需要设置的值\r\n\t         * @return {String}\r\n\t         *\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *          node.model.set(\"options.text\",\"例子\");\r\n\t         */\r\n\t        set: function (path, value) {\r\n\t            var obj = this.option;\r\n\t\r\n\t            if (path.indexOf(\".\") == -1) {\r\n\t                obj[path] = value;\r\n\t            } else {\r\n\t                var fieldArray  = path.split('.');\r\n\t                var n = fieldArray.length;\r\n\t                var currentRef = obj;\r\n\t                var fieldName;\r\n\t\r\n\t                for (var i = 0; i < n - 1; i++) {\r\n\t                    fieldName = fieldArray[i];\r\n\t                    if(currentRef[fieldName] == null) {\r\n\t                        currentRef[fieldName] = {};\r\n\t                    }\r\n\t                    currentRef = currentRef[fieldName];\r\n\t                }\r\n\t                fieldName = fieldArray[n-1];\r\n\t                currentRef[fieldName] = value;\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        getShallow: function (key, ignoreParent) {\r\n\t            var option = this.option;\r\n\t            var val = option && option[key];\r\n\t            var parentModel = this.parentModel;\r\n\t            if (val == null && parentModel && !ignoreParent) {\r\n\t                val = parentModel.getShallow(key);\r\n\t            }\r\n\t            return val;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        getModel: function (path, parentModel) {\r\n\t            var obj = this.get(path, true);\r\n\t            var thisParentModel = this.parentModel;\r\n\t            var model = new Model(\r\n\t                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))\r\n\t            );\r\n\t            return model;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         *清空model的option\r\n\t         * @private\r\n\t         */\r\n\t        isEmpty: function () {\r\n\t            return this.option == null;\r\n\t        },\r\n\t\r\n\t        restoreData: function () {},\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        clone: function () {\r\n\t            var Ctor = this.constructor;\r\n\t            return new Ctor(zrUtil.clone(this.option));\r\n\t        }\r\n\t    };\r\n\t\r\n\t    // Enable Model.extend.\r\n\t    clazzUtil.enableClassExtend(Model);\r\n\t\r\n\t    module.exports = Model;\r\n\t\r\n\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t\r\n\t    var clazz = {};\r\n\t\r\n\t    var TYPE_DELIMITER = '.';\r\n\t    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';\r\n\t    /**\r\n\t     * @public\r\n\t     */\r\n\t    var parseClassType = clazz.parseClassType = function (componentType) {\r\n\t        var ret = {main: '', sub: ''};\r\n\t        if (componentType) {\r\n\t            componentType = componentType.split(TYPE_DELIMITER);\r\n\t            ret.main = componentType[0] || '';\r\n\t            ret.sub = componentType[1] || '';\r\n\t        }\r\n\t        return ret;\r\n\t    };\r\n\t    /**\r\n\t     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数\r\n\t     */\r\n\t    clazz.enableClassExtend = function (RootClass, preConstruct) {\r\n\t        RootClass.extend = function (proto) {\r\n\t            var ExtendedClass = function () {\r\n\t                preConstruct && preConstruct.apply(this, arguments);\r\n\t                RootClass.apply(this, arguments);\r\n\t            };\r\n\t\r\n\t            zrUtil.extend(ExtendedClass.prototype, proto);\r\n\t\r\n\t            ExtendedClass.extend = this.extend;\r\n\t            ExtendedClass.superCall = superCall;\r\n\t            ExtendedClass.superApply = superApply;\r\n\t            zrUtil.inherits(ExtendedClass, this);\r\n\t            ExtendedClass.superClass = this;\r\n\t\r\n\t            return ExtendedClass;\r\n\t        };\r\n\t    };\r\n\t\r\n\t    // superCall should have class info, which can not be fetch from 'this'.\r\n\t    // Consider this case:\r\n\t    // class A has method f,\r\n\t    // class B inherits class A, overrides method f, f call superApply('f'),\r\n\t    // class C inherits class B, do not overrides method f,\r\n\t    // then when method of class C is called, dead loop occured.\r\n\t    function superCall(context, methodName) {\r\n\t        var args = zrUtil.slice(arguments, 2);\r\n\t        return this.superClass.prototype[methodName].apply(context, args);\r\n\t    }\r\n\t\r\n\t    function superApply(context, methodName, args) {\r\n\t        return this.superClass.prototype[methodName].apply(context, args);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @param {Object} entity\r\n\t     * @param {Object} options\r\n\t     * @param {boolean} [options.registerWhenExtend]\r\n\t     * @public\r\n\t     */\r\n\t    clazz.enableClassManagement = function (entity, options) {\r\n\t        options = options || {};\r\n\t\r\n\t        /**\r\n\t         * Component model classes\r\n\t         * key: componentType,\r\n\t         * value:\r\n\t         *     componentClass, when componentType is 'xxx'\r\n\t         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\r\n\t         * @type {Object}\r\n\t         */\r\n\t        var storage = {};\r\n\t\r\n\t        entity.registerClass = function (Clazz, componentType) {\r\n\t            if (componentType) {\r\n\t                componentType = parseClassType(componentType);\r\n\t\r\n\t                if (!componentType.sub) {\r\n\t                    if (storage[componentType.main]) {\r\n\t                        //已经注册过了，直接返回\r\n\t                        return;\r\n\t                    }\r\n\t                    storage[componentType.main] = Clazz;\r\n\t                }\r\n\t                else if (componentType.sub !== IS_CONTAINER) {\r\n\t                    var container = makeContainer(componentType);\r\n\t                    container[componentType.sub] = Clazz;\r\n\t                }\r\n\t            }\r\n\t            return Clazz;\r\n\t        };\r\n\t\r\n\t        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\r\n\t            var Clazz = storage[componentTypeMain];\r\n\t\r\n\t            if (Clazz && Clazz[IS_CONTAINER]) {\r\n\t                Clazz = subType ? Clazz[subType] : null;\r\n\t            }\r\n\t\r\n\t            if (throwWhenNotFound && !Clazz) {\r\n\t                throw new Error(\r\n\t                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'\r\n\t                );\r\n\t            }\r\n\t\r\n\t            return Clazz;\r\n\t        };\r\n\t\r\n\t        entity.getClassesByMainType = function (componentType) {\r\n\t            componentType = parseClassType(componentType);\r\n\t\r\n\t            var result = [];\r\n\t            var obj = storage[componentType.main];\r\n\t\r\n\t            if (obj && obj[IS_CONTAINER]) {\r\n\t                zrUtil.each(obj, function (o, type) {\r\n\t                    type !== IS_CONTAINER && result.push(o);\r\n\t                });\r\n\t            }\r\n\t            else {\r\n\t                result.push(obj);\r\n\t            }\r\n\t\r\n\t            return result;\r\n\t        };\r\n\t\r\n\t        entity.hasClass = function (componentType) {\r\n\t            // Just consider componentType.main.\r\n\t            componentType = parseClassType(componentType);\r\n\t            return !!storage[componentType.main];\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\r\n\t         */\r\n\t        entity.getAllClassMainTypes = function () {\r\n\t            var types = [];\r\n\t            zrUtil.each(storage, function (obj, type) {\r\n\t                types.push(type);\r\n\t            });\r\n\t            return types;\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * If a main type is container and has sub types\r\n\t         * @param  {string}  componentType\r\n\t         * @return {boolean}\r\n\t         */\r\n\t        entity.hasSubTypes = function (componentType) {\r\n\t            componentType = parseClassType(componentType);\r\n\t            var obj = storage[componentType.main];\r\n\t            return obj && obj[IS_CONTAINER];\r\n\t        };\r\n\t\r\n\t        entity.parseClassType = parseClassType;\r\n\t\r\n\t        function makeContainer(componentType) {\r\n\t            var container = storage[componentType.main];\r\n\t            if (!container || !container[IS_CONTAINER]) {\r\n\t                container = storage[componentType.main] = {};\r\n\t                container[IS_CONTAINER] = true;\r\n\t            }\r\n\t            return container;\r\n\t        }\r\n\t\r\n\t        if (options.registerWhenExtend) {\r\n\t            var originalExtend = entity.extend;\r\n\t            if (originalExtend) {\r\n\t                entity.extend = function (proto) {\r\n\t                    var ExtendedClass = originalExtend.call(this, proto);\r\n\t                    return entity.registerClass(ExtendedClass, proto.type);\r\n\t                };\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return entity;\r\n\t    };\r\n\t\r\n\t    module.exports = clazz;\r\n\t\r\n\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports) {\n\n\t/**\r\n\t * 操作图标类\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t\r\n\t    var IconOperation = {\r\n\t        STRAIGHT_SVG: 'M13.961,2.309c-0.051-0.122-0.148-0.22-0.27-0.27L13.5,2h-5C8.224,2,8,2.224,8,2.5S8.224,3,8.5,3h3.793L2.146,13.146c-0.195,0.195-0.195,0.512,0,0.707s0.512,0.195,0.707,0L13,3.707V7.5C13,7.776,13.225,8,13.5,8S14,7.776,14,7.5v-5L13.961,2.309z',\r\n\t        JAGGED_SVG: 'M653.604571 440.905143l289.499429 339.529143 414.134857-538.404572v195.803429h104.155429V0l-381.805715 144.969143 37.083429 97.426286 153.526857-58.294858-331.190857 430.738286-279.698286-327.753143-657.846857 663.552L75.483429 1024z',\r\n\t        CURVE_SVG: 'M956.9 67.6h-240v240h92.5c1.6 22.6 3.6 68.3-0.8 116.7C803.3 483 787.5 558 742.4 582c-45.5 24.2-121.1-6.6-218.7-89-57.5-48.5-109.5-80.6-154.3-95.3-43.7-14.3-82.3-13-114.6 4-53.6 28.2-86.2 96.8-96.7 204-4.3 43.5-4 84.2-2.9 111.5H68.3v240h240v-240H205.2c-1.1-25.6-1.5-65 2.6-106.6 6.1-61.5 23.1-140 70.2-164.7 45.3-23.8 119.1 5.7 213.5 85.3 59.4 50.1 112.7 83.3 158.5 98.5 44.5 14.9 83.5 13.6 116-3.6 52.2-27.7 83.3-94.4 92.6-198.1 4.4-49.5 2.7-95.2 1.1-120.4h97.4v-240zM258.3 907.2h-140v-140h140v140z m648.6-649.6h-140v-140h140v140z',\r\n\t        DEL_SVG: 'M73.641,45.957l-0.021,0.252c0,0.032,0.021,0.06,0.021,0.088c0,0.065-0.022,0.126-0.026,0.191l-2.685,54.878H70.91c-0.231,4.304-5.166,10.81-31.748,10.81c-26.58,0-31.509-6.506-31.746-10.81H7.41L4.731,46.488c-0.009-0.06-0.028-0.126-0.028-0.191c0-0.032,0.01-0.06,0.01-0.088l-0.01-0.252h0.028c0.099-0.466,0.364-0.919,0.784-1.353c3.439,3.477,17.191,4.051,33.646,4.051s30.221-0.574,33.642-4.051c0.426,0.434,0.711,0.887,0.784,1.353H73.641z M78.335,25.102v6.407c0,1.316-1.34,2.567-3.715,3.696c-6.266,2.936-19.777,4.975-35.459,4.975c-15.666,0-29.189-2.039-35.442-4.975C1.33,34.075,0,32.825,0,31.509v-6.407c0-3.374,8.681-6.286,21.359-7.724V3.929c0-2.16,1.768-3.929,3.93-3.929h26.314c2.164,0,3.938,1.773,3.938,3.938v13.296C68.98,18.606,78.333,21.611,78.335,25.102z M48.416,11.395c0-2.348-0.321-4.27-0.715-4.27c-0.393,0-2.641,0-4.979,0h-8.545c-2.352,0-4.592,0-4.989,0c-0.388,0-0.714,1.922-0.714,4.27v5.367l1.083-0.065c3.067-0.173,6.286-0.27,9.595-0.271c3.202,0,6.292,0.098,9.264,0.252V11.395z',\r\n\t        STRAIGHT_IMG: 'data:image/png;base64,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',\r\n\t        JAGGED_IMG: 'data:image/png;base64,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',\r\n\t        CURVE_IMG: 'data:image/png;base64,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',\r\n\t        DEL_IMG: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAOBAMAAADpk+DfAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAtUExURQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGgKD4AAAAPdFJOUwDH/g+agESj4Y6zUiRnh7lnwbkAAABLSURBVAjXY2BgYDZgAIEnnkCa7a5cYGwCwwklIOhhMBEEgmIGnlAgOMDAprhQUGgDA5vWdJciXJRGR0dTAgPzQ0FBSaBpzMbGBgwAIoUW3sQ2EdkAAAAASUVORK5CYII=',\r\n\t        CHANGE_LINE_TYPE_IMG: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAPBAMAAAD9gUllAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAqUExURQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoTzogAAAAOdFJOUwD+CC3uuR7gVXeeFEnMRIEDJwAAAGRJREFUCNdjYOCZwIAA7YuUQADM1nQsDQWBBBBnoSAYiBiAOGeROWwLIzpAYANEE7JpDBtQKAiYqQCmlI1BYOFqMMfcBQQERcEGmkBMFwwAcWzLQcBRCuwItTQQWD4JybQ5DAwAO74b0S83OyMAAAAASUVORK5CYII='\r\n\t    }\r\n\t    module.exports = IconOperation;\r\n\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * flow连线管理类\r\n\t * @author miao.cunzhi\r\n\t */\r\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var ConnectionManager = __webpack_require__(91);\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var Util = __webpack_require__(65);\r\n\t    var Point = __webpack_require__(66);\r\n\t    var Constants = __webpack_require__(93);\r\n\t\r\n\t    function FlowConnectionManager(api) {\r\n\t        ConnectionManager.call(this);\r\n\t        this.bundleOffset = 30; //多线段的偏移\r\n\t        this.bundleGap = 20; // 多线段的间隔\r\n\t        this.connectorMap = Util.StackedMap.createNew(); //存放多线段\r\n\t        this._api = api;\r\n\t    }\r\n\t\r\n\t    FlowConnectionManager.prototype.add = function(connector) {\r\n\t        this.connectors.push(connector);\r\n\t        //1.处理事件\r\n\t        this.handleConnectorEvent(connector);\r\n\t        //2.判断是否两节点相联\r\n\t        if(connector.startNode && connector.endNode) {\r\n\t            var key = this.getTwoNodeId(connector.startNode, connector.endNode);\r\n\t            this.connectorMap.add(key, connector);\r\n\t\r\n\t            this.handleConnectorShrink(connector);\r\n\t\r\n\t            this.bundleOffset = connector.options.bundleOffset || this.bundleOffset;\r\n\t            this.bundleGap = connector.options.bundleGap || this.bundleGap;\r\n\t            //2. 获取这个key对应的线段数组\r\n\t            var arrCons = this.connectorMap.get(key);\r\n\t            if (arrCons.length == 1) {\r\n\t                //两个节点只有一个连线的情况\r\n\t                //判断一下 model里有没有dockers，如果有则调用构造point数组  或者调用refreshConnector计算如何画线\r\n\t                var dockers = connector.options.dockers;\r\n\t                var points = [];\r\n\t                if (dockers && dockers.length >= 2) {\r\n\t                    points = Point.loadArray(dockers);\r\n\t                    connector.refresh(points);\r\n\t                } else {\r\n\t                    if (connector.options.position.points) {\r\n\t                        var arrStartEndPoint = this.getStartEndPoint(connector);\r\n\t                        points = connector.options.position.points;\r\n\t                        points.unshift(arrStartEndPoint[0]);\r\n\t                        points.push(arrStartEndPoint[1]);\r\n\t                        connector.refresh(points);\r\n\t                    } else {\r\n\t                        this.refreshConnector(arrCons[0], true);\r\n\t                    }\r\n\t                }\r\n\t            } else if (arrCons.length > 1) {\r\n\t                //两个节点有多个连线的情况\r\n\t                this.refreshCons(arrCons);\r\n\t            }\r\n\t        } else {\r\n\t            //处理没有 起始节点与终止节点时的连线\r\n\t            this.handleConnectorPoints(connector)\r\n\t        }\r\n\t\r\n\t        //3.设置模型\r\n\t        this.handleConnectorModel(connector);\r\n\t        return connector;\r\n\t    }\r\n\t\r\n\t    FlowConnectionManager.prototype.handleConnectorEvent = function(connector) {\r\n\t        if (connector.conPointsGroup) {\r\n\t            connector.conPointsGroup.on(\"click\", function(e) {\r\n\t                var arrSplit = e.target.type.split(Connector.SEPERATOR);\r\n\t                var connector = e.target.connector;\r\n\t                if (arrSplit[0] === Connector.START_NODE) {\r\n\t                    connector.options.position.startPos = arrSplit[1];\r\n\t                } else if (arrSplit[0] === Connector.END_NODE) {\r\n\t                    connector.options.position.endPos = arrSplit[1];\r\n\t                }\r\n\t                this.refreshConnector(connector, true);\r\n\t                e.cancelBubble = true;\r\n\t                var params = {};\r\n\t                params.event = e;\r\n\t                params.type = \"conPointsGroup:click\";\r\n\t                params.lineNode = this.selConnector;\r\n\t                this._api.trigger(params.type, params);\r\n\t            }.bind(this));\r\n\t        }\r\n\t\r\n\t\r\n\t        var MOUSE_EVENT_NAMES = ['click', 'dblclick'];\r\n\t        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n\t            connector.on(\"Connector:\" + eveName, function(e) {\r\n\t                var selected = e.target;\r\n\t                if (this.selConnector !== selected) {\r\n\t                    this.selConnector && this.refreshConnector(this.selConnector);\r\n\t                    this.selConnector = selected;\r\n\t                }\r\n\t                e.cancelBubble = true;\r\n\t                var params = {};\r\n\t                params.event = e;\r\n\t                params.type = eveName;\r\n\t                params.target = this.selConnector;\r\n\t                this._api.trigger(params.type, params);\r\n\t            }.bind(this));\r\n\t        }.bind(this));\r\n\t    }\r\n\t\r\n\t    FlowConnectionManager.prototype.handleConnectorModel = function(connector) {\r\n\t        connector.model.set(Constants.ELEMENT_TYPE, Constants.CONNECTION);\r\n\t        if(connector.startNode && connector.endNode) {\r\n\t            connector.model.set(Constants.START_ID, connector.startNode.id);\r\n\t            connector.model.set(Constants.END_ID, connector.endNode.id);\r\n\t        }\r\n\t        connector.model.set(Constants.OPTIONS, zrUtil.clone(connector.options));\r\n\t    }\r\n\t\r\n\t    FlowConnectionManager.prototype.handleConnectorShrink = function(connector) {\r\n\t        var that = this;\r\n\t        //双击收紧为一条线\r\n\t        connector.line.on(\"dblclick\", function() {\r\n\t            if (connector.options.isShrink == false) {\r\n\t                return;\r\n\t            }\r\n\t            var con = this.parent;\r\n\t            var startNode = con.startNode;\r\n\t            var endNode = con.endNode;\r\n\t            //1.获取所有的线段\r\n\t            var key = that.getTwoNodeId(startNode, endNode);\r\n\t            var cons = that.connectorMap.get(key);\r\n\t            if (cons.length == 1) {\r\n\t                return\r\n\t            }\r\n\t            //2.判断线是否处于隐藏状态\r\n\t            //2.将除中间的一条线进行隐藏\r\n\t            var half = parseInt(cons.length / 2);\r\n\t            for (var i = 0; i < cons.length; i++) {\r\n\t                if (i != (half)) {\r\n\t                    if (cons[i].ignore) {\r\n\t                        cons[i].show();\r\n\t                    } else {\r\n\t                        cons[i].hide();\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        })\r\n\t    }\r\n\t\r\n\t    //处理没有 起始节点与终止节点时的连线\r\n\t    FlowConnectionManager.prototype.handleConnectorPoints = function(connector) {\r\n\t        var options = connector.options;\r\n\t        var dockers = connector.options.dockers;\r\n\t        if (dockers && dockers.length >= 2) {\r\n\t            var points = Point.loadArray(dockers);\r\n\t            connector.refresh(points);\r\n\t        } else {\r\n\t            if (options.position && options.position.points) {\r\n\t                var oPoints = options.position.points;\r\n\t                connector.refresh(oPoints);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    FlowConnectionManager.prototype.getTwoNodeId = function(startNode, endNode) {\r\n\t            return startNode.id + \",\" + endNode.id;\r\n\t    }\r\n\t        //处理多条线段\r\n\t    FlowConnectionManager.prototype.refreshCons = function(arrCons) {\r\n\t        //如果是折线的话\r\n\t        if (arrCons[0].options.style.lineType == Connector.TYPE_JAGGED) {\r\n\t            for (var i = 0; i < arrCons.length; i++) {\r\n\t                this.refreshConnector(arrCons[i], true);\r\n\t            }\r\n\t        } else {\r\n\t            this.refreshConsStraight(arrCons);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    //处理多条线段(直线)\r\n\t    FlowConnectionManager.prototype.refreshConsStraight = function(arrCons) {\r\n\t        var half = parseInt(arrCons.length / 2);\r\n\t        var arrConnectResult = []\r\n\t\r\n\t        var startNode = arrCons[0].startNode;\r\n\t        var endNode = arrCons[0].endNode;\r\n\t        var sRect = Util.getRect(startNode).boundingRect;\r\n\t        var eRect = Util.getRect(endNode).boundingRect;\r\n\t        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n\t        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\t        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n\t        var position = arrCons[0].options.position;\r\n\t        if (!position.startPos || !position.endPos) {\r\n\t            if (sRect.x < eRect.x) {\r\n\t                position.startPos = \"right\";\r\n\t                position.endPos = \"left\";\r\n\t            } else {\r\n\t                position.startPos = \"left\";\r\n\t                position.endPos = \"right\";\r\n\t            }\r\n\t        }\r\n\t\r\n\t        var startPoint = sConnectorPoint[position.startPos];\r\n\t        var endPoint = eConnectorPoint[position.endPos];\r\n\t        var angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);\r\n\t        var points = [];\r\n\t        for (var i = half; i >= 1; i--) {\r\n\t            points = []; //var points = [];\r\n\t            points.push(startPoint); //\r\n\t            // points.push(new Point(startPoint.x + bundleOffset , startPoint.y + i * bundleGap));\r\n\t            // points.push(new Point(endPoint.x - bundleOffset , startPoint.y + i * bundleGap)); //startPoint.x + bundleOffset\r\n\t            var secondPoint = startPoint.clone();\r\n\t\r\n\t            //secondPoint.x =  secondPoint.x + this.bundleOffset;\r\n\t            secondPoint.transform(Util.translationMatrix(0, this.bundleGap * i));\r\n\t            //secondPoint = this.boundOffsetXY(secondPoint, true);\r\n\t            //\r\n\t            //直角坐标 x, 和 y, 计算出极坐标\r\n\t\r\n\t\r\n\t            //从极坐标计算出直角坐标\r\n\t            secondPoint.x = secondPoint.x + this.bundleOffset * Math.cos(angle);\r\n\t            secondPoint.y = secondPoint.y + this.bundleOffset * Math.sin(angle);\r\n\t\r\n\t\r\n\t\r\n\t            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n\t            points.push(secondPoint);\r\n\t\r\n\t            var thirdPoint = endPoint.clone();\r\n\t            //thirdPoint.x =  thirdPoint.x - this.bundleOffset;\r\n\t\r\n\t\r\n\t\r\n\t            thirdPoint.transform(Util.translationMatrix(0, this.bundleGap * i));\r\n\t            //thirdPoint = this.boundOffsetXY(thirdPoint, false);\r\n\t            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n\t            //\r\n\t            //直角坐标 x, 和 y, 计算出极坐标\r\n\t\r\n\t            //从极坐标计算出直角坐标\r\n\t            thirdPoint.x = thirdPoint.x - this.bundleOffset * Math.cos(angle);\r\n\t            thirdPoint.y = thirdPoint.y - this.bundleOffset * Math.sin(angle);\r\n\t\r\n\t            points.push(thirdPoint);\r\n\t\r\n\t            points.push(endPoint);\r\n\t            arrConnectResult.push(points);\r\n\t        }\r\n\t\r\n\t        arrConnectResult.push([startPoint, endPoint]);\r\n\t\r\n\t        var upHalf = Math.ceil(arrCons.length / 2);\r\n\t        for (i = 1; i < upHalf; i++) {\r\n\t            points = []; //var points = [];\r\n\t            points.push(startPoint);\r\n\t            var secPoint = startPoint.clone();\r\n\t            //secPoint.x =  secPoint.x + this.bundleOffset;\r\n\t            secPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));\r\n\t            secPoint.x = secPoint.x + this.bundleOffset * Math.cos(angle);\r\n\t            secPoint.y = secPoint.y + this.bundleOffset * Math.sin(angle);\r\n\t            points.push(secPoint);\r\n\t\r\n\t            var thdPoint = endPoint.clone();\r\n\t            //thdPoint.x =  thdPoint.x - this.bundleOffset;\r\n\t            thdPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));\r\n\t            //从极坐标计算出直角坐标\r\n\t            thdPoint.x = thdPoint.x - this.bundleOffset * Math.cos(angle);\r\n\t            thdPoint.y = thdPoint.y - this.bundleOffset * Math.sin(angle);\r\n\t            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n\t            points.push(thdPoint);\r\n\t\r\n\t            points.push(endPoint);\r\n\t            arrConnectResult.push(points);\r\n\t        }\r\n\t\r\n\t\r\n\t        for (i = 0; i < arrConnectResult.length; i++) {\r\n\t            arrCons[i].refresh(arrConnectResult[i]);\r\n\t        }\r\n\t\r\n\t    }\r\n\t\r\n\t    FlowConnectionManager.prototype.boundOffsetXY = function(point, isPositive) {\r\n\t        var resultPoint = point.clone();\r\n\t        //直角坐标 x, 和 y, 计算出极坐标\r\n\t        var angle = Math.atan2(resultPoint.y, resultPoint.x);\r\n\t        var r = Math.sqrt(Math.pow(resultPoint.x, 2) + Math.pow(resultPoint.y, 2));\r\n\t        if (isPositive) {\r\n\t            r = r + this.bundleOffset;\r\n\t        } else {\r\n\t            r = r - this.bundleOffset;\r\n\t        }\r\n\t\r\n\t\r\n\t        //从极坐标计算出直角坐标\r\n\t        resultPoint.x = r * Math.cos(angle);\r\n\t        resultPoint.y = r * Math.sin(angle);\r\n\t        return resultPoint;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 设置线段的模型数据  (类型 文字)\r\n\t     * @param {[type]} connector [description]\r\n\t     * @param {[type]} option    [description]\r\n\t     */\r\n\t    FlowConnectionManager.prototype.setModel = function(connector, option) {\r\n\t        var originLineType = connector.model.get(\"style.lineType\");\r\n\t        connector.model.mergeOption(option);\r\n\t        zrUtil.merge(connector.model.get(\"options\"), option, true);\r\n\t        if (originLineType !== option.style.lineType) {\r\n\t            this.refreshConnector(connector, true);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 删除指定的线\r\n\t     * @param connector 欲删除的连线\r\n\t     * @param _zr zr\r\n\t     */\r\n\t    ConnectionManager.prototype.deleteByLine = function (connector,_zr) {\r\n\t        //1.将线 所联的startNode的outgoing数据删除\r\n\t        if(connector.startNode){\r\n\t            var startNodeOutgoing = connector.startNode.model.get(\"outgoing\");\r\n\t            index = zrUtil.indexOf(startNodeOutgoing, connector.resourceId);\r\n\t            if (index != -1) {\r\n\t                startNodeOutgoing.splice(index, 1);\r\n\t            }\r\n\t\r\n\t            if (this.connectorMap) {\r\n\t                var key = this.getTwoNodeId(connector.startNode, connector.endNode);\r\n\t                this.connectorMap.removeItem(key, connector);\r\n\t            }\r\n\t        }\r\n\t\r\n\t\r\n\t        //2.从_zr上删除\r\n\t        _zr.remove(connector);\r\n\t\r\n\t\r\n\t        //3.从线数据中删除\r\n\t        var index = zrUtil.indexOf(this.connectors, connector);\r\n\t        if (index != -1) {\r\n\t            this.connectors.splice(index, 1);\r\n\t        }\r\n\t        if (this.selConnector === connector) {\r\n\t            this.selConnector = null;\r\n\t        }\r\n\t    }\r\n\t    /**\r\n\t     * 刷新连接线\r\n\t     * @param  {[type]} node [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    FlowConnectionManager.prototype.refreshLineByNode = function(node) {\r\n\t        // 判断这个节点是否有多条线段\r\n\t        var keys = this.connectorMap.keys();\r\n\t        for (var i = 0; i < keys.length; i++) {\r\n\t            var key = keys[i];\r\n\t            if (key.indexOf(node.id) != -1) {\r\n\t                var arrCons = this.connectorMap.get(key);\r\n\t                this.countLinePos(arrCons)\r\n\t                if (arrCons.length == 1) {\r\n\t                    //两个节点只有一个连线的情况\r\n\t                    this.refreshConnector(arrCons[0], true);\r\n\t                } else if (arrCons.length > 1) {\r\n\t                    //两个节点有多个连线的情况\r\n\t                    this.refreshCons(arrCons);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 刷新连接线\r\n\t     * @param  {[type]} node [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    FlowConnectionManager.prototype.toggleLineByNode = function(node, isShow) {\r\n\t        // 判断这个节点是否有多条线段\r\n\t        var keys = this.connectorMap.keys();\r\n\t        for (var i = 0; i < keys.length; i++) {\r\n\t            var key = keys[i];\r\n\t            if (key.indexOf(node.id) != -1) {\r\n\t                var arrCons = this.connectorMap.get(key);\r\n\t\r\n\t                zrUtil.each(arrCons, function(connection) {\r\n\t                    if(isShow) {\r\n\t                        connection.show();\r\n\t                    } else {\r\n\t                        connection.hide();\r\n\t                    }\r\n\t                })\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    /**\r\n\t     * 重新调整线的位置\r\n\t     */\r\n\t    FlowConnectionManager.prototype.countLinePos = function(arrCons) {\r\n\t        zrUtil.each(arrCons, function(connector) {\r\n\t            var options = connector.options;\r\n\t            if (options.autoChangePosition == true) {\r\n\t                var sRect = Util.getRect(connector.startNode).boundingRect;\r\n\t                var eRect = Util.getRect(connector.endNode).boundingRect;\r\n\t                var startPos = options.position.startPos;\r\n\t                var endPos = options.position.endPos;\r\n\t                var startPosNow = this.posIsChange(startPos, sRect, eRect, \"startNode\");\r\n\t                var endPosNow = this.posIsChange(endPos, sRect, eRect, \"endNode\");\r\n\t                if (startPos != startPosNow || endPos != endPosNow) {\r\n\t                    options.position.startPos = startPosNow;\r\n\t                    options.position.endPos = endPosNow;\r\n\t                }\r\n\t            }\r\n\t        },this);\r\n\t    }\r\n\t\r\n\t    FlowConnectionManager.prototype.posIsChange = function(pos, sRect, eRect, nodeType) {\r\n\t        var newPos\r\n\t        if (pos.indexOf(\"top\") != -1 || pos.indexOf(\"bottom\") != -1) {\r\n\t            if (sRect.y + sRect.height < eRect.y) {\r\n\t                if (nodeType == \"startNode\") {\r\n\t                    newPos = pos.replace(/(top|bottom)/g, \"bottom\");\r\n\t                } else {\r\n\t                    newPos = pos.replace(/(top|bottom)/g, \"top\");\r\n\t                }\r\n\t            } else if (eRect.y + eRect.height < sRect.y) {\r\n\t                if (nodeType == \"endNode\") {\r\n\t                    newPos = pos.replace(/(top|bottom)/g, \"bottom\");\r\n\t                } else {\r\n\t                    newPos = pos.replace(/(top|bottom)/g, \"top\");\r\n\t                }\r\n\t            } else {\r\n\t                newPos = pos;\r\n\t            }\r\n\t        } else if (pos.indexOf(\"left\") != -1 || pos.indexOf(\"right\") != -1) {\r\n\t            if (sRect.x + sRect.width < eRect.x) {\r\n\t                if (nodeType == \"startNode\") {\r\n\t                    newPos = pos.replace(/(right|left)/g, \"right\");\r\n\t                } else {\r\n\t                    newPos = pos.replace(/(right|left)/g, \"left\");\r\n\t                }\r\n\t            } else if (eRect.x + eRect.width < sRect.x) {\r\n\t                if (nodeType == \"endNode\") {\r\n\t                    newPos = pos.replace(/(right|left)/g, \"right\");\r\n\t                } else {\r\n\t                    newPos = pos.replace(/(right|left)/g, \"left\");\r\n\t                }\r\n\t            } else {\r\n\t                newPos = pos;\r\n\t            }\r\n\t        } else {\r\n\t            newPos = pos;\r\n\t        }\r\n\t        return newPos;\r\n\t    }\r\n\t\r\n\t\r\n\t    zrUtil.inherits(FlowConnectionManager, ConnectionManager);\r\n\t    module.exports = FlowConnectionManager;\r\n\t\r\n\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连线管理类\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Util = __webpack_require__(65);\r\n\t    var Point = __webpack_require__(66);\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var Log = __webpack_require__(92);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t\r\n\t    function ConnectionManager() {\r\n\t        this.connectors = []; //当前画布所有的线段\r\n\t        this.selConnector = null; //当前选中的线段\r\n\t        this.tempConnector = null; //临时线段\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 设置线的不可编辑\r\n\t     * @param  {[type]} forbidEdit [description]\r\n\t     * @return {[type]}            [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.connectorForbidEdit = function (forbidEdit) {\r\n\t        for (var i = 0; i < this.connectors.length; i++) {\r\n\t            this.connectors[i].options.isEdit = !forbidEdit;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 清空连接线上的调整位置按钮\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.clearSelectCon = function () {\r\n\t        if (this.selConnector != null) {\r\n\t            this.refreshConnector(this.selConnector);\r\n\t        }\r\n\t    }\r\n\t    /**\r\n\t     * 删除和节点相关联的连接线\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.deleteSelectCon = function (node, _zr) {\r\n\t        for (var i = 0; i < this.connectors.length; i++) {\r\n\t            if (this.connectors[i].startNode == node || this.connectors[i].endNode == node) {\r\n\t                //1.将线 所联的startNode的outgoing数据删除\r\n\t                var startNodeOutgoing = this.connectors[i].startNode.model.get(\"outgoing\");\r\n\t                var index = zrUtil.indexOf(startNodeOutgoing, this.connectors[i].resourceId);\r\n\t                if (index != -1) {\r\n\t                    startNodeOutgoing.splice(index, 1);\r\n\t                }\r\n\t                //2.从_zr上删除\r\n\t                _zr.remove(this.connectors[i]);\r\n\t                this.connectors.splice(i, 1);\r\n\t                i--;\r\n\t                this.selConnector = null;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    /**\r\n\t     * 删除选定的线\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.deleteLine = function (_zr) {\r\n\t        //1.将线 所联的startNode的outgoing数据删除\r\n\t        if(this.selConnector.startNode){\r\n\t            var startNodeOutgoing = this.selConnector.startNode.model.get(\"outgoing\");\r\n\t            index = zrUtil.indexOf(startNodeOutgoing, this.selConnector.resourceId);\r\n\t            if (index != -1) {\r\n\t                startNodeOutgoing.splice(index, 1);\r\n\t            }\r\n\t\r\n\t            if (this.connectorMap) {\r\n\t                var key = this.getTwoNodeId(this.selConnector.startNode, this.selConnector.endNode);\r\n\t                this.connectorMap.removeItem(key, this.selConnector);\r\n\t            }\r\n\t        }\r\n\t\r\n\t\r\n\t        //2.从_zr上删除\r\n\t        _zr.remove(this.selConnector);\r\n\t\r\n\t\r\n\t        //3.从线数据中删除\r\n\t        var index = zrUtil.indexOf(this.connectors, this.selConnector);\r\n\t        if (index != -1) {\r\n\t            this.connectors.splice(index, 1);\r\n\t        }\r\n\t        this.selConnector = null;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 重新画线\r\n\t     * @param  {[type]} connector          [description]\r\n\t     * @param  {[type]} force\r\n\t     * @return {[type]}                    [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.refreshConnector = function (connector, force) {\r\n\t        // 只有需要强制刷新  或者 连线为空（<2)时 才进行重新计算重绘\r\n\t        if (force || (!connector.turningPoints) || (connector.turningPoints.length < 2)) {\r\n\t            if (connector.model && connector.model.get(\"style.lineType\")) {\r\n\t                connector.options.style.lineType = connector.model.get(\"style.lineType\");\r\n\t            }\r\n\t            var arrStartEndPoint = this.getStartEndPoint(connector);\r\n\t            var escapeDistance = null;\r\n\t            if (connector.options.position && connector.options.position.escapeDistance) {\r\n\t                escapeDistance = connector.options.position.escapeDistance;\r\n\t            }\r\n\t            var solutions = this.connector2Points(connector.options.style.lineType, arrStartEndPoint[0],\r\n\t                arrStartEndPoint[1],\r\n\t                arrStartEndPoint[2], arrStartEndPoint[3], escapeDistance); // TYPE_STRAIGHT TYPE_JAGGED\r\n\t\r\n\t            connector.refresh(solutions[0][2]);\r\n\t        }\r\n\t\r\n\t        connector.clearHandles(); //清空handle\r\n\t    }\r\n\t\r\n\t\r\n\t    ConnectionManager.prototype.getStartEndPoint = function (connector) {\r\n\t        var startNode = connector.startNode;\r\n\t        var endNode = connector.endNode;\r\n\t\r\n\t        var isNotInSameGroup = startNode.parent !== endNode.parent;\r\n\t\r\n\t        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode, isNotInSameGroup).boundingRect;\r\n\t        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(\r\n\t            sRect.y) + Number(sRect.height)];\r\n\t\r\n\t        var eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode, isNotInSameGroup).boundingRect;\r\n\t        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(\r\n\t            eRect.y) + Number(eRect.height)];\r\n\t\r\n\t\r\n\t        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n\t        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\t\r\n\t        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n\t        var position = connector.options.position;\r\n\t        if (!position.startPos || !position.endPos) {\r\n\t            if (sRect.x < eRect.x) {\r\n\t                position.startPos = \"right\";\r\n\t                position.endPos = \"left\";\r\n\t            } else {\r\n\t                position.startPos = \"left\";\r\n\t                position.endPos = \"right\";\r\n\t            }\r\n\t        }\r\n\t        var startPoint = this.calcPointExpression(position.startPos, sConnectorPoint);\r\n\t        var endPoint = this.calcPointExpression(position.endPos, eConnectorPoint);\r\n\t        startPoint.add(new Point(position.startOffset[0], position.startOffset[1]));\r\n\t        endPoint.add(new Point(position.endOffset[0], position.endOffset[1]));\r\n\t        return [startPoint, endPoint, sBounds, eBounds];\r\n\t    }\r\n\t\r\n\t    ConnectionManager.prototype.calcPointExpression = function (pos, point) {\r\n\t        var variable = {\r\n\t            top: point.top.x,\r\n\t            left: point.left.y,\r\n\t            right: point.right.y,\r\n\t            bottom: point.bottom.x,\r\n\t            center: point.center.x\r\n\t        };\r\n\t\r\n\t        var expression = \"<% print(\" + pos + \") %>\";\r\n\t        var val = parseInt(Util.template(expression)(variable));\r\n\t        if (pos.indexOf(\"top\") != -1) {\r\n\t            return new Point(val, point.top.y);\r\n\t        } else if (pos.indexOf(\"left\") != -1) {\r\n\t            return new Point(point.left.x, val);\r\n\t        } else if (pos.indexOf(\"right\") != -1) {\r\n\t            return new Point(point.right.x, val);\r\n\t        } else if (pos.indexOf(\"bottom\") != -1) {\r\n\t            return new Point(val, point.bottom.y);\r\n\t        } else if (pos.indexOf(\"center\") != -1) {\r\n\t            return new Point(val, point.bottom.y);\r\n\t        } else {\r\n\t            throw new Error(\"pos参数错误\");\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 创建或修改临时线\r\n\t     * @param  {[type]} startNode             [description]\r\n\t     * @param  {[type]} rEndPoint             [description]\r\n\t     * @param  {[type]} lineType [description]\r\n\t     * @return {[type]}                       [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.manageTempConnector = function (startNode, rEndPoint, lineType) {\r\n\t\r\n\t        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode).boundingRect;\r\n\t\r\n\t        var sBounds = [sRect.x, sRect.y, sRect.x + sRect.width, sRect.y + sRect.height];\r\n\t        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n\t\r\n\t        if (!this.tempConnector) {\r\n\t            this.tempConnector = new Connector({\r\n\t                isEdit: false,\r\n\t                style: {\r\n\t                    lineType: lineType\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t\r\n\t        var connector = this.tempConnector;\r\n\t        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n\t        var position = connector.options.position;\r\n\t        if (sRect.x < rEndPoint.x) {\r\n\t            position.startPos = \"right\";\r\n\t            position.endPos = \"left\";\r\n\t        } else {\r\n\t            position.startPos = \"left\";\r\n\t            position.endPos = \"right\";\r\n\t        }\r\n\t\r\n\t        connector.options.style.lineType = lineType;\r\n\t        var solutions = this.connector2Points(lineType, sConnectorPoint[position.startPos], rEndPoint,\r\n\t            sBounds, null); // TYPE_STRAIGHT TYPE_JAGGED\r\n\t\r\n\t        connector.refresh(solutions[0][2]);\r\n\t        return connector;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 删除临时线\r\n\t     * @param  {[type]} zr             [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.removeTempConnector = function (zr) {\r\n\t        if (this.tempConnector) {\r\n\t            zr.remove(this.tempConnector);\r\n\t            this.tempConnector = null;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 算出 两个节点 指定两个点如何联线\r\n\t     * @param  {[type]} type       [description]\r\n\t     * @param  {[type]} startPoint [description]\r\n\t     * @param  {[type]} endPoint   [description]\r\n\t     * @param  {[type]} sBounds    [description]\r\n\t     * @param  {[type]} eBounds    [description]\r\n\t     * @return {[type]}            [description]\r\n\t     */\r\n\t    ConnectionManager.prototype.connector2Points = function (type, startPoint, endPoint, sBounds, eBounds,\r\n\t        escapeDistance) {\r\n\t        var figureEscapeDistance = [30, 30];\r\n\t        if (escapeDistance) {\r\n\t            if (!zrUtil.isArray(escapeDistance)) {\r\n\t                figureEscapeDistance = [escapeDistance, escapeDistance];\r\n\t            } else {\r\n\t                figureEscapeDistance = escapeDistance;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        Log.group(\"connectionManager: connector2Points\");\r\n\t\r\n\t\r\n\t        Log.info(\"ConnectionManager: connector2Points (\" + type + \", \" + startPoint + \", \" + endPoint +\r\n\t            \", \" + sBounds + \", \" + eBounds + ')');\r\n\t        var solutions = [];\r\n\t\r\n\t\r\n\t\r\n\t        switch (type) {\r\n\t            case Connector.TYPE_STRAIGHT: //直线\r\n\t                var points = [startPoint.clone(), endPoint.clone()];\r\n\t                solutions.push(['straight', 'straight', points]);\r\n\t                break;\r\n\t\r\n\t            case Connector.TYPE_CURVE: //曲线\r\n\t\r\n\t            case Connector.TYPE_JAGGED: //折线\r\n\t                var startExitPoint = null;\r\n\t                var endExitPoint = null;\r\n\t\r\n\t                //find start exit point  寻找开始出口\r\n\t                if (sBounds != null) {\r\n\t                    var potentialExits = [];\r\n\t\r\n\t                    potentialExits.push(new Point(startPoint.x, sBounds[1] - figureEscapeDistance[0])); //north 北\r\n\t                    potentialExits.push(new Point(sBounds[2] + figureEscapeDistance[0], startPoint.y)); //east  东\r\n\t                    potentialExits.push(new Point(startPoint.x, sBounds[3] + figureEscapeDistance[0])); //south  南\r\n\t                    potentialExits.push(new Point(sBounds[0] - figureEscapeDistance[0], startPoint.y)); //west  西\r\n\t\r\n\t                    //pick closest exit point  寻找与 startPoint 最靠近的出口点\r\n\t                    startExitPoint = potentialExits[0];\r\n\t                    for (var i = 1; i < potentialExits.length; i++) {\r\n\t                        if (Util.distance(startPoint, potentialExits[i]) < Util.distance(startPoint,\r\n\t                                startExitPoint)) {\r\n\t                            startExitPoint = potentialExits[i];\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t\r\n\t\r\n\t                //find end exit point  寻找结束出口\r\n\t                if (eBounds != null) {\r\n\t                    var potentialExits = [];\r\n\t\r\n\t                    potentialExits.push(new Point(endPoint.x, eBounds[1] - figureEscapeDistance[1])); //north\r\n\t                    potentialExits.push(new Point(eBounds[2] + figureEscapeDistance[1], endPoint.y)); //east\r\n\t                    potentialExits.push(new Point(endPoint.x, eBounds[3] + figureEscapeDistance[1])); //south\r\n\t                    potentialExits.push(new Point(eBounds[0] - figureEscapeDistance[1], endPoint.y)); //west\r\n\t\r\n\t                    //pick closest exit point  寻找与 endPoint 最靠近的出口点\r\n\t                    endExitPoint = potentialExits[0];\r\n\t                    for (var i = 1; i < potentialExits.length; i++) {\r\n\t                        if (Util.distance(endPoint, potentialExits[i]) < Util.distance(endPoint,\r\n\t                                endExitPoint)) {\r\n\t                            endExitPoint = potentialExits[i];\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                //Basic solution 最基本的解决方案   为其他解决方案做准备\r\n\t                var s = [startPoint];\r\n\t                var gapIndex = 0; //the index of the gap (where do we need to insert new points) DO NOT CHANGE IT\r\n\t                if (startExitPoint) {\r\n\t                    s.push(startExitPoint);\r\n\t                    gapIndex = 1;\r\n\t                }\r\n\t                if (endExitPoint) {\r\n\t                    s.push(endExitPoint);\r\n\t                }\r\n\t                s.push(endPoint);\r\n\t\r\n\t\r\n\t\r\n\t                //SO - no additional points     S0 解决方案 不添加任何点  基本不会被采用\r\n\t                var s0 = Point.cloneArray(s);\r\n\t                solutions.push(['s0', 's0', s0]);\r\n\t\r\n\t\r\n\t\r\n\t                //S1   S1 解决方案  只有一个折点\r\n\t                var s1 = Point.cloneArray(s);\r\n\t\r\n\t                //first variant   第一个变体 s1 s1_1方案  折线点在 startExitPoint的X 与 endExitPoint的 Y位置\r\n\t                var s1_1 = Point.cloneArray(s1);\r\n\t                s1_1.splice(gapIndex + 1, 0, new Point(s1_1[gapIndex].x, s1_1[gapIndex + 1].y));\r\n\t                solutions.push(['s1', 's1_1', s1_1]);\r\n\t\r\n\t                //second variant  第二变体 s1 s1-2方案  折线点在 endExitPoint的X 与  startExitPoint的Y位置\r\n\t                var s1_2 = Point.cloneArray(s1);\r\n\t                s1_2.splice(gapIndex + 1, 0, new Point(s1_2[gapIndex + 1].x, s1_2[gapIndex].y));\r\n\t                solutions.push(['s1', 's1_2', s1_2]);\r\n\t\r\n\t\r\n\t                //S2  S2 解决方案  添加两个折点\r\n\t\r\n\t                //Variant I   s2_1方案\r\n\t                var s2_1 = Point.cloneArray(s);\r\n\t                var s2_1_1 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex].y);\r\n\t                var s2_1_2 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex + 1].y);\r\n\t                s2_1.splice(gapIndex + 1, 0, s2_1_1, s2_1_2);\r\n\t                solutions.push(['s2', 's2_1', s2_1]);\r\n\t\r\n\t\r\n\t                //Variant II  s2_1方案  1折线点 x: startExitPoint的X 位置 y: startExitPoint的y+endExitPoint的y/2\r\n\t                //1折线点 x:endExitPoint的x  y:startExitPoint的y+endExitPoint的y/2\r\n\t                var s2_2 = Point.cloneArray(s);\r\n\t                var s2_2_1 = new Point(s2_2[gapIndex].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);\r\n\t                var s2_2_2 = new Point(s2_2[gapIndex + 1].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);\r\n\t                s2_2.splice(gapIndex + 1, 0, s2_2_1, s2_2_2);\r\n\t                solutions.push(['s2', 's2_2', s2_2]);\r\n\t\r\n\t\r\n\t                //Variant III\r\n\t                var s2_3 = Point.cloneArray(s);\r\n\t                //find the amount (stored in delta) of pixels we need to move right so no intersection with a figure will be present\r\n\t                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\t\r\n\t                var eastExits = [s2_3[gapIndex].x + 20, s2_3[gapIndex + 1].x + 20]; //add points X coordinates to be able to generate Variant III even in the absence of figures :p\r\n\t\r\n\t                if (sBounds) {\r\n\t                    eastExits.push(sBounds[2] + 20);\r\n\t                }\r\n\t\r\n\t                if (eBounds) {\r\n\t                    eastExits.push(eBounds[2] + 20);\r\n\t                }\r\n\t\r\n\t                var eastExit = Util.max(eastExits);\r\n\t                var s2_3_1 = new Point(eastExit, s2_3[gapIndex].y);\r\n\t                var s2_3_2 = new Point(eastExit, s2_3[gapIndex + 1].y);\r\n\t                s2_3.splice(gapIndex + 1, 0, s2_3_1, s2_3_2);\r\n\t                solutions.push(['s2', 's2_3', s2_3]);\r\n\t\r\n\t\r\n\t                //Variant IV  s2_4方案\r\n\t                var s2_4 = Point.cloneArray(s);\r\n\t                //find the amount (stored in delta) of pixels we need to move up so no intersection with a figure will be present\r\n\t                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\t\r\n\t                var northExits = [s2_4[gapIndex].y - 20, s2_4[gapIndex + 1].y - 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p\r\n\t\r\n\t                if (sBounds) {\r\n\t                    northExits.push(sBounds[1] - 20);\r\n\t                }\r\n\t\r\n\t                if (eBounds) {\r\n\t                    northExits.push(eBounds[1] - 20);\r\n\t                }\r\n\t\r\n\t                var northExit = Util.min(northExits);\r\n\t                var s2_4_1 = new Point(s2_4[gapIndex].x, northExit);\r\n\t                var s2_4_2 = new Point(s2_4[gapIndex + 1].x, northExit);\r\n\t                s2_4.splice(gapIndex + 1, 0, s2_4_1, s2_4_2);\r\n\t                solutions.push(['s2', 's2_4', s2_4]);\r\n\t\r\n\t\r\n\t                //Variant V\r\n\t                var s2_5 = Point.cloneArray(s);\r\n\t                //find the amount (stored in delta) of pixels we need to move left so no intersection with a figure will be present\r\n\t                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\t\r\n\t                var westExits = [s2_5[gapIndex].x - 20, s2_5[gapIndex + 1].x - 20]; //add points x coordinates to be able to generate Variant III even in the absence of figures :p\r\n\t\r\n\t                if (sBounds) {\r\n\t                    westExits.push(sBounds[0] - 20);\r\n\t                }\r\n\t\r\n\t                if (eBounds) {\r\n\t                    westExits.push(eBounds[0] - 20);\r\n\t                }\r\n\t\r\n\t                var westExit = Util.min(westExits);\r\n\t                var s2_5_1 = new Point(westExit, s2_5[gapIndex].y);\r\n\t                var s2_5_2 = new Point(westExit, s2_5[gapIndex + 1].y);\r\n\t                s2_5.splice(gapIndex + 1, 0, s2_5_1, s2_5_2);\r\n\t                solutions.push(['s2', 's2_5', s2_5]);\r\n\t\r\n\t\r\n\t                //Variant VI\r\n\t                var s2_6 = Point.cloneArray(s);\r\n\t                //find the amount (stored in delta) of pixels we need to move down so no intersection with a figure will be present\r\n\t                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\t\r\n\t                var southExits = [s2_6[gapIndex].y + 20, s2_6[gapIndex + 1].y + 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p\r\n\t\r\n\t                if (sBounds) {\r\n\t                    southExits.push(sBounds[3] + 20);\r\n\t                }\r\n\t\r\n\t                if (eBounds) {\r\n\t                    southExits.push(eBounds[3] + 20);\r\n\t                }\r\n\t\r\n\t                var southExit = Util.max(southExits);\r\n\t                var s2_6_1 = new Point(s2_6[gapIndex].x, southExit);\r\n\t                var s2_6_2 = new Point(s2_6[gapIndex + 1].x, southExit);\r\n\t                s2_6.splice(gapIndex + 1, 0, s2_6_1, s2_6_2);\r\n\t                solutions.push(['s2', 's2_6', s2_6]);\r\n\t\r\n\t\r\n\t\r\n\t                //FILTER solutions\r\n\t\r\n\t                /*Algorithm\r\n\t                 * 0. solutions are ordered from minimmun nr of points to maximum >:)\r\n\t                 * 1. remove all solutions that are not orthogonal (mainly s0 solution)\r\n\t                 * 2. remove all solutions that go backward (we will not need them ever)\r\n\t                 * 3. remove all solutions with intersections\r\n\t                 * 4. pick first class of solutions with same nr of points (ex: 2)\r\n\t                 * 5. pick the first solution with 90 degree angles (less turnarounds)\r\n\t                 * (not interesteted) sort by length :p\r\n\t                 */\r\n\t\r\n\t                //1. filter non ortogonal solutions 删除不是正交直线的方案\r\n\t                Log.info(\"Filter orthogonal solutions. Initial number of solutions = \" + solutions.length);\r\n\t                var orthogonalSolution = [];\r\n\t                for (var l = 0; l < solutions.length; l++) {\r\n\t                    var solution = solutions[l][2];\r\n\t                    if (Util.orthogonalPath(solution)) {\r\n\t                        orthogonalSolution.push(solutions[l]);\r\n\t                    }\r\n\t                }\r\n\t                solutions = orthogonalSolution;\r\n\t                Log.info(\"\\n\\tOrthogonalSolutions = \" + solutions.length);\r\n\t\r\n\t                //2. filter backward solutions  过滤 倒退的方案\r\n\t                //do not allow start and end points to coincide - ignore them\r\n\t                if (startPoint.equals(endPoint)) {\r\n\t                    Log.info(\r\n\t                        \"Start and end point coincide...skip backward solution. I think we will just fall on s0 :)\"\r\n\t                    );\r\n\t                } else {\r\n\t                    Log.info(\"Filter backward solutions. Initial number of solutions = \" + solutions.length);\r\n\t                    var forwardSolutions = [];\r\n\t                    var temp = '';\r\n\t                    for (var l = 0; l < solutions.length; l++) {\r\n\t                        var solution = solutions[l][2];\r\n\t                        if (Util.forwardPath(solution)) {\r\n\t                            forwardSolutions.push(solutions[l]);\r\n\t                        } else {\r\n\t                            temp = temp + \"\\n\\t\" + solution;\r\n\t                        }\r\n\t                    }\r\n\t                    solutions = forwardSolutions;\r\n\t                    Log.info(\"\\n\\t ForwardSolutions = \" + solutions.length);\r\n\t                    if (solutions.length == 0) {\r\n\t                        Log.info(\"Discarded solutions: \" + temp);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t\r\n\t                //3. Filter non intersecting solutions  去除没有交集()的方案\r\n\t                Log.info(\"Filter non intersecting solutions. Initial number of solutions = \" + solutions.length);\r\n\t                var nonIntersectionSolutions = []\r\n\t                for (var l = 0; l < solutions.length; l++) {\r\n\t                    var solution = solutions[l][2];\r\n\t                    //Log.info(\"Solution id= \" + solutions[l][1] + ' nr points = ' + solution.length + \", points = \" + solution);\r\n\t                    var intersect = false;\r\n\t\r\n\t                    var innerLines = solution.slice(); //just a shallow copy\r\n\t\r\n\t                    /*If any bounds just trim the solution. So we avoid the strange case when a connection\r\n\t                     *startes from a point on a figure and ends inside of the same figure, but not on a connection point*/\r\n\t                    if (eBounds || sBounds) {\r\n\t                        //i0nnerLines = innerLines.slice(0, innerLines.length - 1);\r\n\t                        innerLines = innerLines.slice(1, innerLines.length - 1);\r\n\t                        //Log.info(\"\\t eBounds present,innerLines nr. points = \" + innerLines.length + \", points = \" + innerLines);\r\n\t                    }\r\n\t\r\n\t\r\n\t\r\n\t                    //now test for intersection\r\n\t                    if (sBounds) {\r\n\t                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, sBounds);\r\n\t                    }\r\n\t                    if (eBounds) {\r\n\t                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, eBounds);\r\n\t                    }\r\n\t\r\n\t                    if (!intersect) {\r\n\t                        nonIntersectionSolutions.push(solutions[l]);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                //If all solutions intersect than this is destiny  :) and just ignore the intersection filter\r\n\t                if (nonIntersectionSolutions.length != 0) {\r\n\t                    //reasign to solutions\r\n\t                    solutions = nonIntersectionSolutions;\r\n\t                }\r\n\t\r\n\t                Log.info(\"\\n\\t nonIntersectionSolutions = \" + solutions.length);\r\n\t\r\n\t\r\n\t                //4. get first class of solutions with same nr of points 选择与第一个方案点数一样多的方案（因为第一个方案点数最少）\r\n\t                Log.info(\"Get first class of solutions with same nr of points\");\r\n\t                if (solutions.length == 0) {\r\n\t                    Log.info(\"This is not possible\");\r\n\t                }\r\n\t\r\n\t                var firstSolution = solutions[0][2]; //pick first solution\r\n\t                var nrOfPoints = firstSolution.length;\r\n\t                var sameNrPointsSolution = [];\r\n\t\r\n\t                for (var l = 0; l < solutions.length; l++) {\r\n\t                    var solution = solutions[l][2];\r\n\t                    if (solution.length == nrOfPoints) {\r\n\t                        sameNrPointsSolution.push(solutions[l]);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                solutions = sameNrPointsSolution;\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t                /*5.  计算路径分数 ，取最分数高的\r\n\t                 Pick the first solution with 90 degree angles (less turnarounds)\r\n\t                 *in case we have more than one solution in our class\r\n\t                 */\r\n\t                Log.info(\"pick the first solution with 90 degree angles (less turnarounds)\");\r\n\t                var solIndex = 0;\r\n\t                for (var l = 0; l < solutions.length; l++) {\r\n\t                    var solution = solutions[l][2];\r\n\t                    if (Util.scorePath(solutions[solIndex][2]) < Util.scorePath(solutions[l][2])) {\r\n\t                        solIndex = l;\r\n\t                    }\r\n\t                }\r\n\t                solutions = [solutions[solIndex]];\r\n\t\r\n\t\r\n\t                break;\r\n\t        }\r\n\t\r\n\t        //SMOOTHING curve\r\n\t        if (type === Connector.TYPE_CURVE) {\r\n\t            this.smoothCurve(solutions);\r\n\t        }\r\n\t        //END SMOOTHING curve\r\n\t\r\n\t        Log.groupEnd();\r\n\t\r\n\t        return solutions;\r\n\t    }\r\n\t\r\n\t    ConnectionManager.prototype.smoothCurve = function (solutions) {\r\n\t        var option = 3;\r\n\t\r\n\t        switch (option) {\r\n\t            case 0:\r\n\t                //do nothing\r\n\t                break;\r\n\t\r\n\t            case 1: //add intermediate points\r\n\t                //Add the middle point for start and end segment so that we \"force\" the\r\n\t                //curve to both come \"perpendicular\" on bounds and also make the curve\r\n\t                //\"flee\" more from bounds (on exit)\r\n\t                for (var s = 0; s < solutions.length; s++) {\r\n\t                    var solTurningPoints = solutions[s][2];\r\n\t\r\n\t                    //first segment\r\n\t                    var a1 = solTurningPoints[0];\r\n\t                    var a2 = solTurningPoints[1];\r\n\t                    var startMiddlePoint = Util.getMiddle(a1, a2);\r\n\t                    solTurningPoints.splice(1, 0, startMiddlePoint);\r\n\t\r\n\t                    //last segment\r\n\t                    var a3 = solTurningPoints[solTurningPoints.length - 2];\r\n\t                    var a4 = solTurningPoints[solTurningPoints.length - 1];\r\n\t                    var endMiddlePoint = Util.getMiddle(a3, a4);\r\n\t                    solTurningPoints.splice(solTurningPoints.length - 1, 0, endMiddlePoint);\r\n\t                }\r\n\t                break;\r\n\t\r\n\t            case 2: //remove points\r\n\t\r\n\t                zrUtil.each(solutions, function(solution) {\r\n\t                    var solType = solution[0];\r\n\t                    if (solType == 's1' || solType == 's2') {\r\n\t                        var solTurningPoints = solution[2];\r\n\t                        solTurningPoints.splice(1, 1);\r\n\t                        solTurningPoints.splice(solTurningPoints.length - 2, 1);\r\n\t                    }\r\n\t                });\r\n\t                break;\r\n\t\r\n\t            case 3:\r\n\t                /*remove colinear point for s1 as it seems that more colinear points do not look good\r\n\t                 * on organic solutions >:D*/\r\n\t                zrUtil.each(solutions, function(solution) {\r\n\t                    var solType = solution[0];\r\n\t                    if (solType == 's1') {\r\n\t                        var solTurningPoints = solution[2];\r\n\t                        var reducedSolution = Util.collinearReduction(solTurningPoints);\r\n\t                        solution[2] = reducedSolution;\r\n\t                    }\r\n\t                });\r\n\t                break;\r\n\t        } //end switch\r\n\t\r\n\t    }\r\n\t\r\n\t    module.exports = ConnectionManager;\r\n\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports) {\n\n\t/**\r\n\t * 日志类\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t\r\n\t    var Log  = {\r\n\t        LOG_LEVEL_NONE  : 0,\r\n\t\r\n\t        LOG_LEVEL_DEBUG : 1,\r\n\t\r\n\t        LOG_LEVEL_INFO : 2,\r\n\t\r\n\t        LOG_LEVEL_ERROR : 3,\r\n\t\r\n\t        level : this.LOG_LEVEL_ERROR,\r\n\t        \r\n\t        /**\r\n\t        * The less important of all messages\r\n\t        * @param {String} message - the message to be logged\r\n\t        **/\r\n\t        debug: function (message){\r\n\t            if(typeof console !== 'undefined'){\r\n\t                if(this.level <= this.LOG_LEVEL_DEBUG){\r\n\t                    \r\n\t                    //in FF is debug\r\n\t                    if(typeof console.debug == 'function'){\r\n\t                        console.debug(message);\r\n\t                    }\r\n\t                    else{//TODO: in IE is log\r\n\t    //                    console.info(message);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t\r\n\t        /**\r\n\t        * The commonly used log message\r\n\t        * @param {String} message - the message to be logged\r\n\t        **/\r\n\t        info : function (message){\r\n\t            if(typeof console !== 'undefined'){\r\n\t                if(this.level <= this.LOG_LEVEL_INFO){\r\n\t                    console.info(message);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**\r\n\t        * The worse kind of message. Usually a crash\r\n\t        * @param {String} message - the message to be logged\r\n\t        **/\r\n\t        error : function (message){\r\n\t            if(typeof console !== 'undefined'){\r\n\t                if(this.level <= this.LOG_LEVEL_ERROR){\r\n\t                    console.error(message);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         *Start grouping the log messages\r\n\t         *@param {String} title - the title of the group\r\n\t         *@see <a href=\"http://getfirebug.com/logging\">http://getfirebug.com/logging</a>\r\n\t         **/\r\n\t        group : function(title){\r\n\t            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info\r\n\t                if(typeof console !== 'undefined'){           \r\n\t                    /**If we do not test for group() function you will get an error in Opera\r\n\t                     *as Opera has it's own console...which does not have a group() function*/\r\n\t                    if(typeof console.group === 'function'){\r\n\t                        console.group(title);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**Ends current message grouping*/\r\n\t        groupEnd : function(){\r\n\t            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info\r\n\t                if(typeof console !== 'undefined'){\r\n\t                    /**If we do not test for groupEnd() function you will get an error in Opera\r\n\t                     *as Opera has it's own console...which does not have a group() function*/\r\n\t                    if(typeof console.groupEnd === 'function'){\r\n\t                        console.groupEnd();\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    //Log.level = Log.LOG_LEVEL_DEBUG; \r\n\t    Log.level = Log.LOG_LEVEL_ERROR; \r\n\t    //Log.level = Log.LOG_LEVEL_ERROR;\r\n\t    //Log.level = Log.LOG_LEVEL_NONE;\r\n\t    module.exports = Log;\r\n\t    \r\n\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports) {\n\n\t/**\r\n\t * 常量定义\r\n\t */\r\n\t\r\n\t\tmodule.exports = \t{\r\n\t\t\tELEMENT_TYPE: \"elementType\",\r\n\t\t\tMODE: \"mode\",\r\n\t\t\tBACKGROUND: \"backgroud\",\r\n\t\t\tOPTIONS: \"options\",\r\n\t\t\tUSERDATA: \"userData\",\r\n\t\t\tID: \"id\",\r\n\t\t\tSTART_ID: \"startNodeId\",\r\n\t\t\tEND_ID: \"endNodeId\",\r\n\t\t\tALARM: \"Alarm\",\r\n\t\t\tRELATIONID:\"relationId\",\r\n\t\t\tRELATION_IMAGE:\"relationImage\",\r\n\t\t\tGROUP: \"Group\",\r\n\t\t\tCONNECTION: \"connection\",\r\n\t\t\tCHILDS: \"childs\",\r\n\t\t\tTREE_ROOT: \"treeRoot\",\r\n\t\t\tDOCKERS:\"options.dockers\",\r\n\t\t\tSTYLE_LINETYPE:\"style.lineType\",\r\n\t\t\tLINEOPERATIONICON:\"LineOperationIcon\",\r\n\t\t\tDEL:\"DEL\",\r\n\t\t\tLINK:\"straight\",\r\n\t\t\tFOLD:\"jagged\",\r\n\t\t\tCURVE:\"curve\"\r\n\t\t};\r\n\t\r\n\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Flow工具类\r\n\t * @author wang.xiaohu9\r\n\t */\r\n\t\r\n\t    var Constants = __webpack_require__(93);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var GroupNode = __webpack_require__(95);\r\n\t    var Rect = __webpack_require__(97);\r\n\t    var Circle = __webpack_require__(98);\r\n\t    var Image = __webpack_require__(99);\r\n\t    var Text = __webpack_require__(100);\r\n\t    var Sector = __webpack_require__(101);\r\n\t    var Ring = __webpack_require__(102);\r\n\t    var Ellipse = __webpack_require__(103);\r\n\t    var Heart = __webpack_require__(104);\r\n\t    var Droplet = __webpack_require__(105);\r\n\t    var Rose = __webpack_require__(106);\r\n\t    var Isogon = __webpack_require__(107);\r\n\t    var Polygon = __webpack_require__(108);\r\n\t    var Line = __webpack_require__(109);\r\n\t    var Polyline = __webpack_require__(110);\r\n\t    var BezierCurve = __webpack_require__(111);\r\n\t    var Arc = __webpack_require__(112);\r\n\t    var Star = __webpack_require__(113);\r\n\t    var Trochoid = __webpack_require__(114);\r\n\t    var Path = __webpack_require__(115);\r\n\t    var IconButton = __webpack_require__(116);\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var flowLink = __webpack_require__(117);\r\n\t    /**\r\n\t     * 根据结点数组 导出JSON格式的数据\r\n\t     *\r\n\t     * @param {Array} model 总的模型\r\n\t     * @return {JSON} JSON格式的数据\r\n\t     */\r\n\t    function toJson(model, group) {\r\n\t        var jsonArr = [];\r\n\t        group.eachChild(function (node) {\r\n\t            if (node.model) {\r\n\t                //如果是组的话\r\n\t                if (node instanceof GroupNode) {\r\n\t                    var childArr = [];\r\n\t                    node.eachChild(function (childNode) {\r\n\t                        if (childNode.model) {\r\n\t                            childArr.push(childNode.model.option);\r\n\t                        }\r\n\t                    });\r\n\t                    node.model.set(Constants.CHILDS, childArr);\r\n\t                }\r\n\t                if (node instanceof Connector) {\r\n\t                    node.refreshModel();\r\n\t                }\r\n\t                jsonArr.push(node.model.option);\r\n\t\r\n\t            }\r\n\t\r\n\t\r\n\t        })\r\n\t        model.set(Constants.CHILDS, jsonArr);\r\n\t        return model.option;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 根据 JSON 生成节点\r\n\t     * @param  {[type]} fishTopoflow [description]\r\n\t     * @param  {[type]} json         [description]\r\n\t     * @return {[type]}              [description]\r\n\t     */\r\n\t    function fromJson(fishTopoflow, group, childShapes, isChild, layoutRootNode) {\r\n\t        var connectors = [];\r\n\t        // 1.先创建节点  遍历形状 获取模型\r\n\t        for (var i = 0; i < childShapes.length; i++) {\r\n\t            var shape = childShapes[i];\r\n\t            if (shape.elementType === Constants.CONNECTION) {\r\n\t                connectors.push(shape);\r\n\t            } else if (shape.elementType === Constants.ALARM) {\r\n\t                var relationNode = findNodeById(fishTopoflow.group, shape.relationId);\r\n\t                fishTopoflow.createAlarm(relationNode, shape.options);\r\n\t            } else if (shape.elementType === Constants.GROUP) {\r\n\t                shape.options.id = shape.id;\r\n\t                var createdGroup = fishTopoflow.createNode(shape.elementType, shape.options, shape.userData);\r\n\t                fromJson(fishTopoflow, createdGroup, shape.childs, true, layoutRootNode);\r\n\t\r\n\t                fishTopoflow.addNode(createdGroup);\r\n\t\r\n\t\r\n\t            } else {\r\n\t                // 根据options创建节点\r\n\t                var node = fishTopoflow.createNode(shape.elementType, shape.options, shape.userData);\r\n\t                if (isChild) {\r\n\t                    group.add(node);\r\n\t                } else {\r\n\t                    fishTopoflow.addNode(node);\r\n\t                }\r\n\t\r\n\t                if (shape.options.layout) {\r\n\t                    if (shape.options.layout.layout === Constants.TREE_ROOT) {\r\n\t                        var nodeForLayout = findNodeById(group, shape.id)\r\n\t                        layoutRootNode.push(nodeForLayout);\r\n\t                        //  fishTopo.layoutNode(\"tree\",{\"node\":node});\r\n\t                    }\r\n\t                }\r\n\t\r\n\t            }\r\n\t        }\r\n\t\r\n\t        // 2. 再创建线\r\n\t        zrUtil.each(connectors, function (line) {\r\n\t            var startNode = findNodeById(group, line.startNodeId);\r\n\t            var endNode = findNodeById(group, line.endNodeId);\r\n\t            if (startNode && endNode) {\r\n\t                var link = fishTopoflow.createLink(startNode, endNode, line.options, line.userData);\r\n\t                if (isChild) {\r\n\t                    group.add(link);\r\n\t                } else {\r\n\t                    fishTopoflow.addNode(link);\r\n\t                }\r\n\t            }else{\r\n\t                var thisLink = flowLink.Link.createByPoint(line.options,line.userData);\r\n\t                if (isChild) {\r\n\t                    group.add(thisLink);\r\n\t                } else {\r\n\t                    fishTopoflow.addNode(thisLink);\r\n\t                }\r\n\t            }\r\n\t        })\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 根据id在group中查找\r\n\t     * @param  {[type]} group  [description]\r\n\t     * @param  {[type]} nodeId [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    function findNodeById(group, nodeId) {\r\n\t        var retNode = null;\r\n\t        group.eachChild(function (node) {\r\n\t            if (node.id === nodeId) {\r\n\t                retNode = node;\r\n\t            }\r\n\t        })\r\n\t        return retNode;\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * Get canvas which has all thing rendered\r\n\t     * @param {Object} opts\r\n\t     * @param {string} [opts.backgroundColor]\r\n\t     */\r\n\t    function getRenderedCanvas(zr, opts) {\r\n\t        opts = opts || {};\r\n\t        opts.pixelRatio = opts.pixelRatio || 1;\r\n\t        opts.backgroundColor = opts.backgroundColor ||\r\n\t            \"#FFFFFF\";\r\n\t        var list = zr.storage.getDisplayList();\r\n\t        // Stop animations\r\n\t        zrUtil.each(list, function (el) {\r\n\t            el.stopAnimation(true);\r\n\t        });\r\n\t        return zr.painter.getRenderedCanvas(opts);\r\n\t    }\r\n\t\r\n\t    function toDataURL(zr, opts) {\r\n\t        opts = opts || {};\r\n\t        var url = getRenderedCanvas(zr, opts).toDataURL(\r\n\t            'image/' + (opts && opts.type || 'png')\r\n\t        );\r\n\t        return url;\r\n\t    }\r\n\t\r\n\t    function truncPosition(position) {\r\n\t        var x = parseInt(position[0], 10);\r\n\t        var y = parseInt(position[1], 10);\r\n\t        if (x < 0) {\r\n\t            x = 0\r\n\t        }\r\n\t        if (y < 0) {\r\n\t            y = 0\r\n\t        }\r\n\t        return [x, y];\r\n\t    }\r\n\t\r\n\t    function registerFlowNode(flowNode) {\r\n\t        var nodeCtors = {\r\n\t            Rect: Rect,\r\n\t            Circle: Circle,\r\n\t            Image: Image,\r\n\t            Text: Text,\r\n\t            Sector: Sector,\r\n\t            Ring: Ring,\r\n\t            Ellipse: Ellipse,\r\n\t            Heart: Heart,\r\n\t            Droplet: Droplet,\r\n\t            Rose: Rose,\r\n\t            Isogon: Isogon,\r\n\t            Polygon: Polygon,\r\n\t            Line: Line,\r\n\t            Polyline: Polyline,\r\n\t            BezierCurve: BezierCurve,\r\n\t            Arc: Arc,\r\n\t            Star: Star,\r\n\t            Trochoid: Trochoid,\r\n\t            Path: Path,\r\n\t            Group: GroupNode,\r\n\t            IconButton: IconButton\r\n\t        }\r\n\t        for (var name in nodeCtors) {\r\n\t            flowNode[name] = nodeCtors[name]\r\n\t        }\r\n\t        return flowNode;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Normalize css liked array configuration\r\n\t     * e.g.\r\n\t     *  3 => [3, 3, 3, 3]\r\n\t     *  [4, 2] => [4, 2, 4, 2]\r\n\t     *  [4, 3, 2] => [4, 3, 2, 3]\r\n\t     * @param {number|Array.<number>} val\r\n\t     */\r\n\t    function normalizeCssArray(val) {\r\n\t        var len = val.length;\r\n\t        if (typeof (val) === 'number') {\r\n\t            return [val, val, val, val];\r\n\t        } else if (len === 2) {\r\n\t            // vertical | horizontal\r\n\t            return [val[0], val[1], val[0], val[1]];\r\n\t        } else if (len === 3) {\r\n\t            // top | horizontal | bottom\r\n\t            return [val[0], val[1], val[2], val[1]];\r\n\t        }\r\n\t        return val;\r\n\t    }\r\n\t\r\n\t    function _trim(str) {\r\n\t        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\r\n\t    }\r\n\t\r\n\t    function parsePercent(percent, all) {\r\n\t        switch (percent) {\r\n\t            case 'center':\r\n\t            case 'middle':\r\n\t                percent = '50%';\r\n\t                break;\r\n\t            case 'left':\r\n\t            case 'top':\r\n\t                percent = '0%';\r\n\t                break;\r\n\t            case 'right':\r\n\t            case 'bottom':\r\n\t                percent = '100%';\r\n\t                break;\r\n\t        }\r\n\t        if (typeof percent === 'string') {\r\n\t            if (_trim(percent).match(/%$/)) {\r\n\t                return parseFloat(percent) / 100 * all;\r\n\t            }\r\n\t\r\n\t            return parseFloat(percent);\r\n\t        }\r\n\t\r\n\t        return percent == null ? NaN : +percent;\r\n\t    }\r\n\t\r\n\t\r\n\t\r\n\t    /**\r\n\t     * @param {string} str\r\n\t     * @param {boolean} [upperCaseFirst=false]\r\n\t     * @return {string} str\r\n\t     */\r\n\t    function toCamelCase(str, upperCaseFirst) {\r\n\t        str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {\r\n\t            return group1.toUpperCase();\r\n\t        });\r\n\t\r\n\t        if (upperCaseFirst && str) {\r\n\t            str = str.charAt(0).toUpperCase() + str.slice(1);\r\n\t        }\r\n\t\r\n\t        return str;\r\n\t    }\r\n\t    /**\r\n\t     * Enable property storage to any host object.\r\n\t     * Notice: Serialization is not supported.\r\n\t     *\r\n\t     * For example:\r\n\t     * var get = modelUitl.makeGetter();\r\n\t     *\r\n\t     * function some(hostObj) {\r\n\t     *      get(hostObj)._someProperty = 1212;\r\n\t     *      ...\r\n\t     * }\r\n\t     *\r\n\t     * @return {Function}\r\n\t     */\r\n\t    var makeGetter = (function () {\r\n\t        var index = 0;\r\n\t        return function () {\r\n\t            var key = '\\0__topo_prop_getter_' + index++;\r\n\t            return function (hostObj) {\r\n\t                return hostObj[key] || (hostObj[key] = {});\r\n\t            };\r\n\t        };\r\n\t    })();\r\n\t    var encodeHTML = function (source) {\r\n\t        return String(source)\r\n\t            .replace(/&/g, '&amp;')\r\n\t            .replace(/</g, '&lt;')\r\n\t            .replace(/>/g, '&gt;')\r\n\t            .replace(/\"/g, '&quot;')\r\n\t            .replace(/'/g, '&#39;');\r\n\t    };\r\n\t\r\n\t    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\r\n\t\r\n\t    var wrapVar = function (varName, seriesIdx) {\r\n\t        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\r\n\t    };\r\n\t    /**\r\n\t     * Template formatter\r\n\t     * @param {string} tpl\r\n\t     * @param {Array.<Object>|Object} paramsList\r\n\t     * @param {boolean} [encode=false]\r\n\t     * @return {string}\r\n\t     */\r\n\t    function formatTpl(tpl, paramsList, encode) {\r\n\t        if (!zrUtil.isArray(paramsList)) {\r\n\t            paramsList = [paramsList];\r\n\t        }\r\n\t        var seriesLen = paramsList.length;\r\n\t        if (!seriesLen) {\r\n\t            return '';\r\n\t        }\r\n\t\r\n\t        var $vars = paramsList[0].$vars || [];\r\n\t        for (var i = 0; i < $vars.length; i++) {\r\n\t            var alias = TPL_VAR_ALIAS[i];\r\n\t            var val = wrapVar(alias, 0);\r\n\t            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\r\n\t        }\r\n\t        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\r\n\t            for (var k = 0; k < $vars.length; k++) {\r\n\t                var ret = paramsList[seriesIdx][$vars[k]];\r\n\t                tpl = tpl.replace(\r\n\t                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\r\n\t                    encode ? encodeHTML(ret) : ret\r\n\t                );\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return tpl;\r\n\t    }\r\n\t\r\n\t\r\n\t    module.exports = {\r\n\t        toJson: toJson,\r\n\t        fromJson: fromJson,\r\n\t        toDataURL: toDataURL,\r\n\t        truncPosition: truncPosition,\r\n\t        registerFlowNode: registerFlowNode,\r\n\t        normalizeCssArray: normalizeCssArray,\r\n\t        parsePercent: parsePercent,\r\n\t        toCamelCase: toCamelCase,\r\n\t        makeGetter: makeGetter,\r\n\t        formatTpl: formatTpl,\r\n\t        findNodeById: findNodeById\r\n\t    };\r\n\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 组， 组中元素的坐标都是相对于这个组的<br>\r\n\t * @class fishTopoFlow.node.GroupNode\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var group1 = new node.Group({\r\n\t *           position:[60,50]\r\n\t *       });\r\n\t *\r\n\t *       var rect1 = new node.Rect({\r\n\t *           shape:{width:120,height:30},\r\n\t *           style:{text:\"标题\", fill:\"#FFB90F\",stroke:\"#bbbbbb\"},\r\n\t *           position:[0,0],\r\n\t *           selectable:false\r\n\t *       });\r\n\t *\r\n\t *       var rect2 = new node.Rect({\r\n\t *           shape:{width:120,height:60},\r\n\t *           style:{text:\"内容\", fill:\"#FFFFFF\",stroke:\"#bbbbbb\"},\r\n\t *           position:[0,30],\r\n\t *           selectable:false\r\n\t *       });\r\n\t *\r\n\t *       group1.add(rect1);\r\n\t *       group1.add(rect2);\r\n\t *       fishTopo.add(group1);\r\n\t */\r\n\t\r\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var BoundingRect = __webpack_require__(27);\r\n\t    var graphic = __webpack_require__(4);\r\n\t    var util = __webpack_require__(65);\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var flowNode =__webpack_require__(96);\r\n\t\r\n\t    function GroupNode(opts) {\r\n\t        this.model = flowNode.genModel(\"GroupNode\", opts);\r\n\t        graphic.Group.call(this, opts);\r\n\t\r\n\t        var defaultOptions = {\r\n\t            shape: {\r\n\t                width: 5,\r\n\t                height: 5,\r\n\t                r: 5\r\n\t            },\r\n\t            style: {\r\n\t                fill: 'rgba(0,0,0,0)',//'#f9f9f9',\r\n\t                stroke: 'rgba(0,0,0,0)'//'#bbbbbb'\r\n\t            },\r\n\t            position: [0, 0]\r\n\t        };\r\n\t        this.options = zrUtil.merge(defaultOptions, opts, true);\r\n\t        //函数无法clone 原型clone不上\r\n\t        this.options.layout = opts.layout;\r\n\t        this.max = [1024, 960];\r\n\t        this.render(this.options);\r\n\t    }\r\n\t    GroupNode.RECT_NAME = \"GROUP_RECT_NAME\";\r\n\t    GroupNode.prototype = {\r\n\t        constructor: GroupNode,\r\n\t        type: \"GroupNode\",\r\n\t        render: function (model) {\r\n\t            var rect = new graphic.Rect({\r\n\t                shape: model.shape,\r\n\t                style: model.style,\r\n\t                //silent:true, //加上后 拖动 组中没有子元素的地方 无法手动了\r\n\t                z2:-1\r\n\t            });\r\n\t            rect.name = GroupNode.RECT_NAME;\r\n\t            this.add(rect);\r\n\t            this.position = model.position;\r\n\t            this.mergedImage = model.mergedImage;\r\n\t        },\r\n\t        rectContain: function (x, y) {\r\n\t            var rect = util.getRect(this);\r\n\t            return rect.boundingRect.contain(x, y);\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 遍历组中每一个子节点\r\n\t         * @param  {Function} cb 回调函数cb\r\n\t         * @param  {Object} context   上下文context\r\n\t         */\r\n\t        each: function (cb, context) {\r\n\t            var children = this._children;\r\n\t            for (var i = 0; i < children.length; i++) {\r\n\t                var child = children[i];\r\n\t                if (child.name != GroupNode.RECT_NAME) {\r\n\t                    cb.call(context, child, i);\r\n\t                }\r\n\t            }\r\n\t            return this;\r\n\t        },\r\n\t        // 设置 group中框形大小为 group的包围和\r\n\t        willRender:function () {\r\n\t            if (this.options.layout) {\r\n\t                this.setLayout(this.options.layout);\r\n\t            }\r\n\t            this.setProperties({\r\n\t                shape: {\r\n\t                    width: this.getBoundingRect().width,\r\n\t                    height: this.getBoundingRect().height\r\n\t                }\r\n\t            });\r\n\t        },\r\n\t\r\n\t        setLayout: function(Layout) {\r\n\t            Layout.run(this);\r\n\t        },\r\n\t\r\n\t        getRect: function () {\r\n\t            var boundingRect = this.getBoundingRect();\r\n\t            //创建最小包围盒虚线\r\n\t            var points = [];\r\n\t            points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\t            points[1] = [boundingRect.width / 2, -boundingRect.height / 2];\r\n\t            points[2] = [boundingRect.width / 2, boundingRect.height / 2];\r\n\t            points[3] = [-boundingRect.width / 2, boundingRect.height / 2];\r\n\t            points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\t\r\n\t            var boundRect = new BoundingRect(this.position[0],\r\n\t                this.position[1],\r\n\t                boundingRect.width, boundingRect.height);\r\n\t            return {\r\n\t                x: this.position[0] + boundingRect.width / 2,\r\n\t                y: this.position[1] + boundingRect.height / 2,\r\n\t                width: boundingRect.width,\r\n\t                height: boundingRect.height,\r\n\t                points: points,\r\n\t                boundingRect: boundRect\r\n\t            };\r\n\t        },\r\n\t        /**\r\n\t         * 拖拽组内节点的时候，动态更改背景rect的大小\r\n\t         * @param nodeMessage 拖拽的组内节点的信息\r\n\t         */\r\n\t        modifyGroupRect: function (nodeMessage) {\r\n\t            //1.重置背景rect 的长宽\r\n\t            var minLength = this.options.shape.r;\r\n\t            this.setProperties({\r\n\t                shape: {\r\n\t                    width: minLength,\r\n\t                    height: minLength,\r\n\t                    r: minLength\r\n\t                }\r\n\t            });\r\n\t\r\n\t            var rect = this.childOfName(GroupNode.RECT_NAME);\r\n\t            var boundingRect = this.getBoundingRect();\r\n\t            var width = boundingRect.width;\r\n\t            var height = boundingRect.height;\r\n\t            var rx = rect.position[0],//rect.shape.x,\r\n\t                ry = rect.position[1];//rect.shape.y;\r\n\t            //2.取group中所有节点最靠上边和最高左边的值，不包括背景rect的值\r\n\t            var minX = this._children[1].position[0],\r\n\t                minY = this._children[1].position[1];\r\n\t            var maxX = this._children[1].position[0],\r\n\t                maxY = this._children[1].position[1];\r\n\t            var nowNodePosition = zrUtil.clone(nodeMessage.position);\r\n\t            for (var i = 1; i < this._children.length; i++) {\r\n\t                if (this._children[i] instanceof Connector || this._children[i].isIcon == true) {\r\n\t                    continue;\r\n\t                } else {\r\n\t                    if (minX > this._children[i].position[0]) {\r\n\t                        minX = this._children[i].position[0];\r\n\t                    }\r\n\t                    if (maxX < this._children[i].position[0]) {\r\n\t                        maxX = this._children[i].position[0];\r\n\t                    }\r\n\t                    if (minY > this._children[i].position[1]) {\r\n\t                        minY = this._children[i].position[1];\r\n\t                    }\r\n\t                    if (maxY < this._children[i].position[1]) {\r\n\t                        maxY = this._children[i].position[1];\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t\r\n\t            // 3. 宽度大于最大宽度\r\n\t            if (width > this.max[0]) {\r\n\t                width = this.max[0] - 2;\r\n\t                if (nodeMessage.position[0] > minX) {\r\n\t                    nowNodePosition[0] = minX + this.max[0] - nodeMessage.width;\r\n\t                } else {\r\n\t                    nowNodePosition[0] = maxX - this.max[0] + nodeMessage.width;\r\n\t                }\r\n\t            } else {\r\n\t                //移动节点改变group中背景rect的x位置，不超过最小的值\r\n\t                rx = rect.position[0] + nodeMessage.position[0];\r\n\t                if (rx > minX) {\r\n\t                    rx = minX;\r\n\t                }\r\n\t                nowNodePosition[0] = nodeMessage.movePosition[0] + nodeMessage.moveX;\r\n\t                if (nodeMessage.position[0] > minX) {\r\n\t                    if (nowNodePosition[0] > minX + this.max[0] - nodeMessage.width) {\r\n\t                        nowNodePosition[0] = minX + this.max[0] - nodeMessage.width;\r\n\t                    }\r\n\t                } else {\r\n\t                    if (nowNodePosition[0] < maxX - this.max[0] + nodeMessage.width) {\r\n\t                        nowNodePosition[0] = maxX - this.max[0] + nodeMessage.width\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            if (height > this.max[1]) {\r\n\t                height = this.max[1] - 2;\r\n\t                if (nodeMessage.position[1] > minY) {\r\n\t                    nowNodePosition[1] = minY + this.max[1] - nodeMessage.height;\r\n\t                } else {\r\n\t                    nowNodePosition[1] = maxY - this.max[1] + nodeMessage.height;\r\n\t                }\r\n\t            } else {\r\n\t                //移动节点改变group中背景rect的y位置，不超过最小的值\r\n\t                ry = rect.position[1] + (nodeMessage.position[1]);\r\n\t                if (ry > minY) {\r\n\t                    ry = minY;\r\n\t                }\r\n\t                nowNodePosition[1] = nodeMessage.movePosition[1] + nodeMessage.moveY;\r\n\t                if (nodeMessage.position[1] > minY) {\r\n\t                    if (nowNodePosition[1] > minY + this.max[1] - nodeMessage.height) {\r\n\t                        nowNodePosition[1] = minY + this.max[1] - nodeMessage.height;\r\n\t                    }\r\n\t                } else {\r\n\t                    if (nowNodePosition[1] < maxY - this.max[1] + nodeMessage.height) {\r\n\t                        nowNodePosition[1] = maxY - this.max[1] + nodeMessage.height\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            if (nodeMessage.node.alarm) {\r\n\t                var newAlarmPosition = [nowNodePosition[0] + nodeMessage.node.getBoundingRect().width - (nodeMessage.node.alarm\r\n\t                        .getBoundingRect().width - 6), nowNodePosition[1] - nodeMessage.node.alarm.getBoundingRect()\r\n\t                    .height - 3\r\n\t                ];\r\n\t                nodeMessage.node.alarm.attr(\"position\", newAlarmPosition);\r\n\t            }\r\n\t            //改变背景rect的长宽和位置\r\n\t            this.setProperties({\r\n\t                shape: {\r\n\t                    width: width,\r\n\t                    height: height,\r\n\t                    x: rx,\r\n\t                    y: ry\r\n\t                }\r\n\t            });\r\n\t\r\n\t        },\r\n\t\r\n\t        setProperties: function (opt) {\r\n\t            var rect = this.childOfName(GroupNode.RECT_NAME);\r\n\t            rect.setShape(opt.shape);\r\n\t           // rect.attr(\"style\", opt.style);\r\n\t            rect.attr('position', opt.position);\r\n\t           // this.attr(\"shape\", opt.shape);\r\n\t        },\r\n\t\r\n\t        merged: function () {\r\n\t            var that = this;\r\n\t            //保留group的初始位置\r\n\t            var groupPosition = zrUtil.clone(this.position);\r\n\t            //给小图片设置属性，隐藏group\r\n\t            var width = this._relationImage.getBoundingRect().width;\r\n\t            var height = this._relationImage.getBoundingRect().height;\r\n\t            //计算合并后的小图片的position\r\n\t            var relationImagePosition = [this.position[0] + this.childOfName(GroupNode.RECT_NAME).shape.x + (this.getBoundingRect()\r\n\t                    .width / 2 - width / 2), this.position[1] + this.childOfName(GroupNode.RECT_NAME).shape.y +\r\n\t                (this.getBoundingRect().height / 2 - height / 2)\r\n\t            ];\r\n\t            //将小图片的位置保留下来\r\n\t            var cloneImagePosition = zrUtil.clone(relationImagePosition);\r\n\t            this._relationImage.attr(\"style\", {\r\n\t                image: this.mergedImage,\r\n\t                width: width,\r\n\t                height: height\r\n\t            });\r\n\t            this._relationImage.attr(\"position\", relationImagePosition);\r\n\t            if (width > 0 && height > 0) {\r\n\t                this.hide();\r\n\t                this._relationImage.show();\r\n\t            }\r\n\t\r\n\t            //双击图片放出组\r\n\t            this._relationImage.on(\"dblclick\", function () {\r\n\t                //设置组的位置根据小图片的偏移量来计算\r\n\t                that.attr('position',[groupPosition[0] + (this.position[0] -cloneImagePosition[0]),\r\n\t                    groupPosition[1] + (this.position[1] - cloneImagePosition[1])]);\r\n\t                this.hide();\r\n\t                that.show();\r\n\t            });\r\n\t            return this._relationImage;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    zrUtil.inherits(GroupNode, graphic.Group);\r\n\t    module.exports = GroupNode;\r\n\t\r\n\t/**\r\n\t * @method add\r\n\t * 将节点加入到这个组中最后\r\n\t * @param {Object} node 欲添加到组的节点\r\n\t */\r\n\t/**\r\n\t * @method removeAll\r\n\t * 移除所有子节点\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method remove\r\n\t * 移除所有子节点\r\n\t * @param {Object} child 子节点\r\n\t */\r\n\t/**\r\n\t * @method childOfName\r\n\t * 获取指定名字的儿子节点\r\n\t * @param {String} name\r\n\t * @return {Object} 节点\r\n\t */\r\n\t/**\r\n\t * @method traverse\r\n\t * 深度优先遍历所有子孙节点（each只遍历子节点）\r\n\t * @param {String} name\r\n\t * @return {Object} 节点\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {String} mergedImage=''  控制当双击时 组可以缩小为指定的图形。\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Boolean} childDraggable=false  控制组内成员是否可以拖动\r\n\t */\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * fishTopoFlow的node对象，框架提供的节点都放在这个对象下。通过extend方法创建自定义节点<br>\r\n\t * @class fishTopoFlow.node\r\n\t * @abstract\r\n\t *\r\n\t    * **使用范例**：\r\n\t    *\r\n\t    *      @example\r\n\t    *       var node = fishTopoFlow.node;\r\n\t    *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t    *      var Diamond = node.extend({\r\n\t    *          type: 'Diamond',\r\n\t    *          shape: {\r\n\t    *              width: 0,\r\n\t    *              height: 0\r\n\t    *          },\r\n\t    *          buildPath: function (path, shape) {\r\n\t    *              var cx = 0;\r\n\t    *              var cy = 0;\r\n\t    *              var width = shape.width / 2;\r\n\t    *              var height = shape.height / 2;\r\n\t    *              path.moveTo(cx, cy - height);\r\n\t    *              path.lineTo(cx + width, cy);\r\n\t    *              path.lineTo(cx, cy + height);\r\n\t    *              path.lineTo(cx - width, cy);\r\n\t    *              path.closePath();\r\n\t    *          }\r\n\t    *      });\r\n\t    *        var diamod = new Diamond({\r\n\t    *            shape: {\r\n\t    *                width:50,\r\n\t    *                height:50\r\n\t    *            },\r\n\t    *            position:[60,60]\r\n\t    *        })\r\n\t    *        fishTopo.add(diamod);\r\n\t */\r\n\t\r\n\t    var Path = __webpack_require__(7);\r\n\t    var Constants = __webpack_require__(93);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var util = __webpack_require__(65);\r\n\t    var Model = __webpack_require__(87);\r\n\t    var flowNode = {};\r\n\t    /**\r\n\t     * 构造模型\r\n\t     * @private\r\n\t     */\r\n\t    flowNode.genModel = function (type, opts) {\r\n\t        var model = new Model({});\r\n\t        // 没有id的时候，缺少给一个UUID。创建节点或者反序列化的时候 节点的ID取的是opts.id\r\n\t\t\tif (!opts.id) {\r\n\t\t\t\topts.id = util.getUUID();\r\n\t\t\t}\r\n\t        model.set(Constants.ELEMENT_TYPE, type);\r\n\t        // 防止 new el.constructor({ style: el.style,shape: el.shape }); zrUtil.clone报错\r\n\t        if (opts.style && opts.style.host) {\r\n\t            delete opts.style.host;\r\n\t        }\r\n\t        model.set(Constants.OPTIONS, zrUtil.clone(opts));\r\n\t        if (\"draggable\" in opts) {\r\n\t            opts.isdraggable = opts.draggable;\r\n\t            delete opts.draggable;\r\n\t        }\r\n\t        if (!opts.z) {\r\n\t            opts.z = 1; //节点默认为1，线段0;\r\n\t        }\r\n\t\r\n\t        if (util.isUndefined(opts.hoverAnimation)) {\r\n\t            opts.hoverAnimation = false;\r\n\t        }\r\n\t\r\n\t        if (util.isUndefined(opts.selectable)) {\r\n\t            opts.selectable = true;  //默认可以选中\r\n\t        }\r\n\t        return model;\r\n\t    }\r\n\t\r\n\t    flowNode.addHoverAnimation = function(node) {\r\n\t        var scale = zrUtil.clone(node.scale) || [1,1];\r\n\t        var onEmphasis = function() {\r\n\t            this.animateTo({\r\n\t                scale: [scale[0] * 1.1, scale[1] * 1.1]\r\n\t            }, 400, 'elasticOut');\r\n\t        };\r\n\t        var onNormal = function() {\r\n\t            this.animateTo({\r\n\t                scale: scale\r\n\t            }, 400, 'elasticOut');\r\n\t        };\r\n\t        node.on('mouseover', onEmphasis)\r\n\t            .on('mouseout', onNormal)\r\n\t            .on('emphasis', onEmphasis)\r\n\t            .on('normal', onNormal);\r\n\t    }\r\n\t    /**\r\n\t     * @method extend\r\n\t     * 扩展一个 自定义节点, 比如钻石形等。\r\n\t     * @param {Object} props\r\n\t     * @param {string} props.type 自定义结节的名称 Path type\r\n\t     * @param {Function} [props.init] 初始化 Initialize\r\n\t     * @param {Function} props.buildPath 进行构建节点 Overwrite buildPath method\r\n\t     * @param {Object} [props.style] 缺省样式 Extended default style config\r\n\t     * @param {Object} [props.shape] 缺省节点参数 Extended default shape config\r\n\t     *\r\n\t     */\r\n\t    flowNode.extend = function (defaults) {\r\n\t        var Sub = function (opts) {\r\n\t            this.model = flowNode.genModel(defaults.type, opts);\r\n\t            Path.call(this, opts);\r\n\t\r\n\t            if (defaults.style) {\r\n\t                // Extend default style\r\n\t                this.style.extendFrom(defaults.style, false);\r\n\t            }\r\n\t\r\n\t            // Extend default shape\r\n\t            var defaultShape = defaults.shape;\r\n\t            if (defaultShape) {\r\n\t                this.shape = this.shape || {};\r\n\t                var thisShape = this.shape;\r\n\t                for (var name in defaultShape) {\r\n\t                    if (\r\n\t                        !thisShape.hasOwnProperty(name)\r\n\t                        && defaultShape.hasOwnProperty(name)\r\n\t                    ) {\r\n\t                        thisShape[name] = defaultShape[name];\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t\r\n\t            defaults.init && defaults.init.call(this, opts);\r\n\t\r\n\t        };\r\n\t\r\n\t        zrUtil.inherits(Sub, Path);\r\n\t\r\n\t        // FIXME 不能 extend position, rotation 等引用对象\r\n\t        for (var name in defaults) {\r\n\t            // Extending prototype values and methods\r\n\t            if (name !== 'style' && name !== 'shape') {\r\n\t                Sub.prototype[name] = defaults[name];\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return Sub;\r\n\t    };\r\n\t\r\n\t    module.exports = flowNode;\r\n\t\r\n\t\r\n\t/**\r\n\t * @cfg {Array} position 节点的位置,统一使用position进行定位[x,y] eg. [100,100]\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Object} style 样式参数\r\n\t * @cfg {string} style.fill=#000 填充色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red | gradient\r\n\t * @cfg {string} style.stroke=null 笔画颜色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red | gradient\r\n\t * @cfg {number} style.lineWidth=1 笔画宽度\r\n\t * @cfg {Array} style.lineDash=null 笔画的虚线间隔，参数为交替绘制线段和间距长度的数字 参见[lineDashOffset](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/setLineDash) eg. lineDash:[6,10]\r\n\t * @cfg {number} style.lineDashOffset=0  笔画的虚线偏移量 参见[lineDashOffset](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset)\r\n\t * @cfg {string} style.text=\"\" 节点上显示的文本,可以使用 \\n 来换行\r\n\t * @cfg {string} style.textFont='12px sans-serif' 字体大小、字体类型、粗细、字体样式。格式参见[css font](https://developer.mozilla.org/en-US/docs/Web/CSS/font) eg.textFont: 'italic bolder 14px Microsoft YaHei'\r\n\t * @cfg {string} style.fontStyle=null 字体样式\r\n\t * @cfg {string} style.fontWeight=#000 字体粗细\r\n\t * @cfg {number} style.fontSize=null 字体大小\r\n\t * @cfg {string} style.fontFamily=null 字体类型\r\n\t * @cfg {string} style.textFill=#000 节点上文本的填充色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red\r\n\t * @cfg {string} style.textStoke=null 节点上文本的描边色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red\r\n\t * @cfg {string|Array} style.textPosition=\"\" 文本在节点中的位置left|right|top|bottom|inside|insideLeft|insideRight|insideTop|insideBottom|insideTopLeft|insideTopRight|insideBottomLeft|insideBottomRight|[x,y]|[%,%]\r\n\t * @cfg {string} style.textBaseline=\"alphabetic\" 当前文本基线的属性 \"top\" || \"hanging\" || \"middle\" || \"alphabetic\" || \"ideographic\" || \"bottom\" 参见[css font](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/textBaseline)\r\n\t * @cfg {Array} style.textOffset=null 文本在节点的偏移值[x,y] eg. [10,10]\r\n\t * @cfg {string} style.textAlign=\"\" 文本在节点中的对齐方式 left | center | right\r\n\t * @cfg {string} style.textVerticalAlign=null 文本在节点中的垂直对齐方式 top | middle | bottom\r\n\t * @cfg {number} style.textDistance=5 文字的相对textPos的偏移量 eg. textPosition='left' textDistance=5 则文字的x坐标的值为 (left的坐标x值) -5\r\n\t * @cfg {string} style.textShadowColor='transparent' 文字阴影颜色\r\n\t * @cfg {number} style.textShadowBlur=0 文本阴影宽度 参见[shadowBlur](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowBlur)\r\n\t * @cfg {number} style.textShadowOffsetX=0 文本阴影 X 方向偏移 参见shadowOffsetX[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX]\r\n\t * @cfg {number} style.textShadowOffsetY=0 文本阴影 Y 方向偏移 参见shadowOffsetY[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY]\r\n\t * @cfg {number} style.textRotation=0 文本旋转的角度\r\n\t * @cfg {number} style.textBorderWidth=0 文字描边宽度\r\n\t * @cfg {string} style.textBorderColor=null 文字描边颜色\r\n\t * @cfg {number} style.textBorderRadius=0 文字描边半径\r\n\t * @cfg {string|Object} style.textBackgroundColor=null 文字背景(颜色或图片) eg. '#333' | {image:'./asset/img/clund.png'}\r\n\t * @cfg {number|Array} style.textPadding=null 文字padding  eg. `2` or `[2, 4]` or `[2, 3, 4, 5]`\r\n\t * @cfg {Object} style.rich=null 富文本样式属性\r\n\t * @cfg {number} style.textLineHeight=0 文字的行高\r\n\t * @cfg {number} style.opacity=1 图形透明度。支持从 0 到 1 的数字，为 0 时不绘制该图形。\r\n\t * @cfg {number} style.shadowBlur=0 阴影宽度 参见[shadowBlur](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowBlur)\r\n\t * @cfg {number} style.shadowOffsetX=0 阴影 X 方向偏移 参见shadowOffsetX[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX]\r\n\t * @cfg {number} style.shadowOffsetY=0 阴影 Y 方向偏移 参见shadowOffsetY[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY]\r\n\t * @cfg {string} style.shadowColor='#000' 阴影颜色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red 参见[shadowColor](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowColor)\r\n\t * @cfg {string} style.image=\"\" 图片的路径 用于Image\r\n\t * @cfg {number} style.width 图片的宽度 用于Image\r\n\t * @cfg {number} style.height 图片的高度 用于Image\r\n\t */\r\n\t\r\n\t /**\r\n\t * @cfg {Object} hoverStyle hover样式, 参数见style\r\n\t  */\r\n\t /**\r\n\t * @cfg {Object} selectStyle 选中节点的样式, 参数见style;  默认是一个虚的边框;  设为空对象则不显示选中边框;\r\n\t*/\r\n\t/**\r\n\t * @cfg {Boolean} draggable=true 是否可以被拖拽。\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Boolean} selectable=true 节点是否可选中，默认是true\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {String} id 为了避免重复，目前由系统自动生成，如果不需要用可以忽略。建议使用nmae\r\n\t */\r\n\t\r\n\t/**\r\n\t *  @cfg {Boolean} hoverAnimation=false 是否开启 hover 在节点上的提示动画效果。，默认是false\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {String} name 指定节点的name, 可以使用childOfName等函数根据name查找节点\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {String} tooltip 节点的tooltip 内容可以包括HTML标签\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Object} relative relative描述怎么根据父元素进行定位，设置了relative属性 就不需要设置position。支持：left、right、top、bottom\r\n\t * @cfg {Number|String} relative.left  距离父元素左边的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.left 和 right 只有一个可以生效。\r\n\t * @cfg {Number|String} relative.right  距离父元素右边的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.left 和 right 只有一个可以生效。\r\n\t * @cfg {Number|String} relative.top  距离父元素顶部的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.top 和 bottom 只有一个可以生效。\r\n\t * @cfg {Number|String} relative.bottom  距离父元素底部的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.top 和 bottom 只有一个可以生效。\r\n\t * @cfg {String} [bounding='all'] 决定此图形元素在定位时，对自身的包围盒计算方式。 1.'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。2.'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Array} scale 节点的缩放因子, [x,y] 水平与垂直方向的 eg. [1,1]\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {number} rotation 节点的旋转因子, 单位是角度 eg. 0.5* Math.PI\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Array} origin 旋转和缩放的原点, [x,y] eg. [75,75]\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {number} z=0  z方向的高度，决定层叠关系。类似css zIndex\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {number} zlevel=0  决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Boolean} silent=false  是否不响应鼠标以及触摸事件。\r\n\t */\r\n\t/**\r\n\t * @cfg {Boolean} invisible=false  节点是否可见。\r\n\t */\r\n\t\r\n\t/**\r\n\t * @cfg {Object} parent  节点的父元素\r\n\t */\r\n\t/**\r\n\t * @cfg {Object} operationIcons  节点操作为选中的节点，提供默认操作或用户自定操作。 默认提供的操作：{ name: constants.DEL } 删除节点, { constants.LINK} 直线, { constants.FOLD} 折线, { constants.CURVE } 曲线。也可以自定义操作\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var image1 = new node.Image({\r\n\t *           style: {\r\n\t *               image: \"img/img-cic/icon-send-sms.svg\",\r\n\t *               width:120,\r\n\t *               height:70,\r\n\t *               text:\"操作:线段\",\r\n\t *               textPosition:\"insideBottom\"\r\n\t *           },\r\n\t *           position:[60,60],\r\n\t *           operationIcons: [\r\n\t *               { name: constants.LINK} ,\r\n\t *               { name: constants.FOLD },\r\n\t *               { name: constants.CURVE }\r\n\t *           ]\r\n\t *       });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @property {Object} states\r\n\t * 用于设置节点的状态\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * @property {Object} model\r\n\t * 节点的模型，用于存储序列化数据 以及用户自定义数据\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method setStyle\r\n\t * 创建节点后，设置节点的样式（style属性）\r\n\t * @param {String} key 键名\r\n\t * @param {*} value 键值\r\n\t * @return {Object} 返回节点对象自身\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method setShape\r\n\t * 创建节点后，设置节点的形状（shape属性）\r\n\t * @param {String} key 键名\r\n\t * @param {*} value 键值\r\n\t * @return {Object} 返回节点对象自身\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method hide\r\n\t * 隐藏节点\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method show\r\n\t * 显示节点\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * @method on\r\n\t * 绑定事件\r\n\t * @param {String} event 事件名\r\n\t * @param {Function} handler 事件处理函数\r\n\t * @param {Object} [context] 上下文\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method off\r\n\t * 解绑事件\r\n\t * @param {String} event 事件名\r\n\t * @param {Function} handler 事件处理函数\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method one\r\n\t * 单次触发绑定,trigger后销毁\r\n\t * @param {String} event 事件名\r\n\t * @param {Function} handler 事件处理函数\r\n\t * @param {Object} [context] 上下文\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method trigger\r\n\t * 事件分发\r\n\t * @param {String} type 事件类型\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method isSilent\r\n\t * 是否绑定了事件\r\n\t * @param {String} event 事件名\r\n\t * @return {boolean}\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method animate\r\n\t * 动画\r\n\t * @param {String} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\r\n\t * @param {Boolean} [loop] 动画是否循环\r\n\t * @return {Object} 返回Animator对象\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *      el.animate('style', false)\r\n\t *         .when(1000, {x: 10} )\r\n\t *         .done(function(){ // Animation done })\r\n\t *         .start()\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method stopAnimation\r\n\t * 停止动画\r\n\t * @param {boolean} forwardToLast 是否在停止前移动到最后一帧\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method animateTo\r\n\t * 从一动属性过渡到另一种属性的动画\r\n\t * @param {Object} target 目前属性\r\n\t * @param {number} [time=500] 动画时间 单位ms\r\n\t * @param {string} [easing='linear'] 动画函数 参见[缓动示例](http://echarts.baidu.com/gallery/editor.html?c=line-easing)\r\n\t * @param {number} [delay=0] 延时时间\r\n\t * @param {Function} [callback] 动画结束回调\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          // Animate position\r\n\t *          el.animateTo({\r\n\t *              position: [10, 10]\r\n\t *          }, function () { // done })\r\n\t *\r\n\t *          // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\r\n\t *          el.animateTo({\r\n\t *              shape: {\r\n\t *                  width: 500\r\n\t *              },\r\n\t *              style: {\r\n\t *                  fill: 'red'\r\n\t *              }\r\n\t *              position: [10, 10]\r\n\t *          }, 100, 100, 'cubicOut', function () { // done })\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event click\r\n\t * 单击事件\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象\r\n\t * <pre>\r\n\t * node.on('click', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event dblclick\r\n\t * 当双击元素时，会发生 dblclick 事件。\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象\r\n\t * <pre>\r\n\t * node.on('dblclick', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event mouseover\r\n\t * 当鼠标指针位于元素上方时，会发生 mouseover 事件\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象\r\n\t * <pre>\r\n\t * node.on('mouseover', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event mouseout\r\n\t * 当鼠标指针从元素上移开时，发生 mouseout 事件。\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象\r\n\t * <pre>\r\n\t * node.on('mouseout', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * @event mousemove\r\n\t * 当鼠标指针在指定的元素中移动时，就会发生 mousemove 事件\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象\r\n\t * <pre>\r\n\t * node.on('mousemove', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * @event mousewheel\r\n\t * 当用户在指定的元素时滚动鼠标滑轮时,就会发生 mousewheel事件\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象\r\n\t * <pre>\r\n\t * node.on('mousewheel', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * @event mousedown\r\n\t * 当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象\r\n\t * <pre>\r\n\t * node.on('mousedown', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * @event mouseup\r\n\t * 当在元素上放松鼠标按钮时，会发生 mouseup 事件。\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象\r\n\t * <pre>\r\n\t * node.on('mouseup', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event contextmenu\r\n\t * 当在元素上点击鼠标右键时，会发生 contextmenu 事件。\r\n\t * @param {Object} event 事件\r\n\t * @param {Object} event.target 目标对象\r\n\t * @param {Object} event.event 实际的浏览器事件对象，如果想阻止默认的浏览器右键菜单请使用 event.event.preventDefault(); event.event.stopPropagation();\r\n\t\r\n\t * <pre>\r\n\t * node.on('contextmenu', function(event) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event dragstart\r\n\t * 当开始拖动节点的时候，会发生 dragstart 事件。\r\n\t *\r\n\t * <pre>\r\n\t * node.on('dragstart', function(e) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * @event drag\r\n\t * 当拖动节点的时候，会发生 drag 事件。\r\n\t *\r\n\t * <pre>\r\n\t * node.on('drag', function(e) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event dragend\r\n\t * 当拖动节点结束的时候，会发生 dragend 事件。\r\n\t *\r\n\t * <pre>\r\n\t * node.on('dragend', function(e) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 矩形<br>\r\n\t * @class fishTopoFlow.node.Rect\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var rect = new node.Rect({\r\n\t *           shape:{width:100,height:60},\r\n\t *           position:[20,20]\r\n\t *       });\r\n\t *       fishTopo.add(rect);\r\n\t */\r\n\t\r\n\t    var roundRectHelper = __webpack_require__(29);\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Rect',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Array} shape.points=null 拆线点的坐标 可以从AI中获取。\r\n\t         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑\r\n\t         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效\r\n\t         */\r\n\t        shape: {\r\n\t            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\r\n\t            // r缩写为1         相当于 [1, 1, 1, 1]\r\n\t            // r缩写为[1]       相当于 [1, 1, 1, 1]\r\n\t            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\r\n\t            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            r: 0,\r\n\t            width: 50,\r\n\t            height: 50\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var x = 0;\r\n\t            var y = 0;\r\n\t            var width = shape.width;\r\n\t            var height = shape.height;\r\n\t            if (!shape.r) {\r\n\t                ctx.rect(x, y, width, height);\r\n\t            }\r\n\t            else {\r\n\t                roundRectHelper.buildPath(ctx, shape);\r\n\t            }\r\n\t            ctx.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * 圆形<br>\r\n\t * @class fishTopoFlow.node.Circle\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var circle = new node.Circle({\r\n\t *           shape:{r:24},\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(circle);\r\n\t */\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Circle',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.r=20 半径。\r\n\t         */\r\n\t        shape: {\r\n\t            r: 20\r\n\t        },\r\n\t\r\n\t        buildPath : function (ctx, shape, inBundle) {\r\n\t            // Better stroking in ShapeBundle\r\n\t            // Always do it may have performence issue ( fill may be 2x more cost)\r\n\t            if (inBundle) {\r\n\t                ctx.moveTo(shape.r, 0);\r\n\t            }\r\n\t            // Better stroking in ShapeBundle\r\n\t            // ctx.moveTo(shape.cx + shape.r, shape.cy);\r\n\t            ctx.arc(0, 0, shape.r, 0, Math.PI * 2, true);\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 图片节点<br>\r\n\t * @class fishTopoFlow.node.Image\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var image = new node.Image({\r\n\t *           style: {\r\n\t *               image: \"../../examples/flow/img/img-cic/start.svg\",\r\n\t *               width:120,\r\n\t *               height:70,\r\n\t *               text:\"Event Name\"\r\n\t *           },\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(image);\r\n\t */\r\n\t\r\n\t\r\n\t    var Displayable = __webpack_require__(8);\r\n\t    var BoundingRect = __webpack_require__(27);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var flowNode = __webpack_require__(96);\r\n\t    var LRU = __webpack_require__(21);\r\n\t    var globalImageCache = new LRU(50);\r\n\t\r\n\t\r\n\t    function ZImage(opts) {\r\n\t        this.model = flowNode.genModel(\"Image\", opts);\r\n\t        Displayable.call(this, opts);\r\n\t\r\n\t        if (window.jQuery) {   //判断jQuery是否存在\r\n\t            this.resultDeferrd = jQuery.Deferred();\r\n\t            this.result = this.resultDeferrd.promise();\r\n\t        }\r\n\t    }\r\n\t\r\n\t    ZImage.prototype = {\r\n\t\r\n\t        constructor: ZImage,\r\n\t\r\n\t        type: 'Image',\r\n\t\r\n\t        brush: function (ctx, prevEl) {\r\n\t            var style = this.style;\r\n\t            var src = style.image;\r\n\t            var image;\r\n\t\r\n\t            // Must bind each time\r\n\t            style.bind(ctx, this, prevEl);\r\n\t            // style.image is a url string\r\n\t            if (typeof src === 'string') {\r\n\t                image = this._image;\r\n\t            }\r\n\t            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\r\n\t            else {\r\n\t                image = src;\r\n\t                image.isLoaded = true;\r\n\t            }\r\n\t            // FIXME Case create many images with src\r\n\t            if (!image && src) {\r\n\t                // Try get from global image cache\r\n\t                var cachedImgObj = globalImageCache.get(src);\r\n\t                if (!cachedImgObj) {\r\n\t                    // Create a new image\r\n\t                    image = new Image();\r\n\t                    image.isLoaded = false;\r\n\t                    image.onload = function () {\r\n\t                        image.isLoaded = true;\r\n\t                        image.onload = null;\r\n\t                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\r\n\t                            cachedImgObj.pending[i].dirty();\r\n\t                        }\r\n\t                    };\r\n\t                    cachedImgObj = {\r\n\t                        image: image,\r\n\t                        pending: [this]\r\n\t                    };\r\n\t                    image.src = src;\r\n\t                    globalImageCache.put(src, cachedImgObj);\r\n\t                    this._image = image;\r\n\t                    return;\r\n\t                }\r\n\t                else {\r\n\t                    image = cachedImgObj.image;\r\n\t                    this._image = image;\r\n\t                    // Image is not complete finish, add to pending list  如果使用的svg图片, IE11下就算加载成功image.width, image.height也都是为0\r\n\t                    if ((!image.width || !image.height) && (!image.src.endsWith(\"svg\"))) {\r\n\t                        cachedImgObj.pending.push(this);\r\n\t                        return;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t\r\n\t            if (image) {\r\n\t                // 图片已经加载完成\r\n\t                // if (image.nodeName.toUpperCase() == 'IMG') {\r\n\t                //     if (!image.complete) {\r\n\t                //         return;\r\n\t                //     }\r\n\t                // }\r\n\t                // Else is canvas\r\n\t\r\n\t                var x = style.x || 0;\r\n\t                var y = style.y || 0;\r\n\t                // 如果使用的svg图片, IE11下就算加载成功image.width, image.height也都是为0\r\n\t                //此处如不注释, 会导致IE11下svg图片无法使用\r\n\t                // 图片加载失败\r\n\t                // if (!image.width || !image.height) {\r\n\t                //     return;\r\n\t                // }\r\n\t                if (!image.isLoaded) {\r\n\t                    if (window.jQuery) {\r\n\t                        this.resultDeferrd.reject(image);\r\n\t                    }\r\n\t                    return;\r\n\t                }\r\n\t\r\n\t                var width = style.width;\r\n\t                var height = style.height;\r\n\t                var aspect = image.width / image.height;\r\n\t                if (width == null && height != null) {\r\n\t                    // Keep image/height ratio\r\n\t                    width = height * aspect;\r\n\t                }\r\n\t                else if (height == null && width != null) {\r\n\t                    height = width / aspect;\r\n\t                }\r\n\t                else if (width == null && height == null) {\r\n\t                    width = image.width;\r\n\t                    height = image.height;\r\n\t                }\r\n\t\r\n\t                // 设置transform\r\n\t                this.setTransform(ctx);\r\n\t\r\n\t                if (style.sWidth && style.sHeight) {\r\n\t                    var sx = style.sx || 0;\r\n\t                    var sy = style.sy || 0;\r\n\t                    ctx.drawImage(\r\n\t                        image,\r\n\t                        sx, sy, style.sWidth, style.sHeight,\r\n\t                        x, y, width, height\r\n\t                    );\r\n\t                }\r\n\t                else if (style.sx && style.sy) {\r\n\t                    var sx2 = style.sx;\r\n\t                    var sy2 = style.sy;\r\n\t                    var sWidth = width - sx2;\r\n\t                    var sHeight = height - sy2;\r\n\t                    ctx.drawImage(\r\n\t                        image,\r\n\t                        sx2, sy2, sWidth, sHeight,\r\n\t                        x, y, width, height\r\n\t                    );\r\n\t                }\r\n\t                else {\r\n\t                    ctx.drawImage(image, x, y, width, height);\r\n\t                }\r\n\t                // 如果没设置宽和高的话自动根据图片宽高设置\r\n\t                if (style.width == null) {\r\n\t                    style.width = width;\r\n\t                }\r\n\t                if (style.height == null) {\r\n\t                    style.height = height;\r\n\t                }\r\n\t\r\n\t                this.restoreTransform(ctx);\r\n\t\r\n\t                // Draw rect text\r\n\t                if (style.text != null) {\r\n\t                    this.drawRectText(ctx, this.getBoundingRect());\r\n\t                }\r\n\t                if (window.jQuery) {\r\n\t                    this.resultDeferrd.resolve(image);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t        getBoundingRect: function () {\r\n\t            var style = this.style;\r\n\t            if (! this._rect) {\r\n\t                this._rect = new BoundingRect(\r\n\t                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\r\n\t                );\r\n\t            }\r\n\t            return this._rect;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(ZImage, Displayable);\r\n\t\r\n\t    module.exports = ZImage;\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 文本<br>\r\n\t * @class fishTopoFlow.node.Text\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n\t *       var text = new node.Text({\r\n\t *           style:{text:\"文本也可以作为独立的节点进行拖拽\",fill:\"#ff0000\", textFont:\"16px Microsoft YaHei\"},\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(text);\r\n\t */\r\n\t\r\n\t    var Text = __webpack_require__(46);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var flowNode = __webpack_require__(96);\r\n\t    function ZText(opts) {\r\n\t        var defaultOptions = {\r\n\t            style:{textBaseline:\"top\"}   // 默认值  这样选中时的框才正确\r\n\t        };\r\n\t        var options = zrUtil.merge(defaultOptions, opts, true);\r\n\t        this.model = flowNode.genModel(\"Text\", opts);\r\n\t        Text.call(this, options);\r\n\t    }\r\n\t    zrUtil.inherits(ZText, Text);\r\n\t    module.exports = ZText;\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 扇形<br>\r\n\t * @class fishTopoFlow.node.Sector\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n\t *       var sector = new node.Sector({\r\n\t *           shape: {r:30, startAngle:0, endAngle:Math.PI * 0.5}, // startAngle\\endAngle是弧度单位\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(sector);\r\n\t */\r\n\t\r\n\t    var env = __webpack_require__(50);\r\n\t    var Path = __webpack_require__(7);\r\n\t\r\n\t    var shadowTemp = [\r\n\t        ['shadowBlur', 0],\r\n\t        ['shadowColor', '#000'],\r\n\t        ['shadowOffsetX', 0],\r\n\t        ['shadowOffsetY', 0]\r\n\t    ];\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Sector',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.r=0 外半径。\r\n\t         * @cfg {Number} shape.r0=0 内半径。\r\n\t         * @cfg {Number} shape.startAngle=0 开始弧度。\r\n\t         * @cfg {Number} shape.endAngle=Math.PI * 2  结束弧度。\r\n\t         * @cfg {Boolean} shape.clockwise=true 是否顺时针。\r\n\t         */\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t\r\n\t            cy: 0,\r\n\t\r\n\t            r0: 0,\r\n\t\r\n\t            r: 0,\r\n\t\r\n\t            startAngle: 0,\r\n\t\r\n\t            endAngle: Math.PI * 2,\r\n\t\r\n\t            clockwise: true\r\n\t        },\r\n\t\r\n\t        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\r\n\t            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\r\n\t            // where exception \"unexpected call to method or property access\"\r\n\t            // might be thrown when calling ctx.fill after a path whose area size\r\n\t            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\r\n\t            // (e.g.,\r\n\t            //  ctx.moveTo(10, 10);\r\n\t            //  ctx.lineTo(20, 10);\r\n\t            //  ctx.closePath();\r\n\t            //  ctx.clip();\r\n\t            //  ctx.shadowBlur = 10;\r\n\t            //  ...\r\n\t            //  ctx.fill();\r\n\t            // )\r\n\t            ? function () {\r\n\t                var clipPaths = this.__clipPaths;\r\n\t                var style = this.style;\r\n\t                var modified;\r\n\t\r\n\t                if (clipPaths) {\r\n\t                    for (var i = 0; i < clipPaths.length; i++) {\r\n\t                        var shape = clipPaths[i] && clipPaths[i].shape;\r\n\t                        if (shape && shape.startAngle === shape.endAngle) {\r\n\t                            for (var j = 0; j < shadowTemp.length; j++) {\r\n\t                                shadowTemp[j][2] = style[shadowTemp[j][0]];\r\n\t                                style[shadowTemp[j][0]] = shadowTemp[j][1];\r\n\t                            }\r\n\t                            modified = true;\r\n\t                            break;\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                Path.prototype.brush.apply(this, arguments);\r\n\t\r\n\t                if (modified) {\r\n\t                    for (var k = 0; k < shadowTemp.length; k++) {\r\n\t                        style[shadowTemp[k][0]] = shadowTemp[k][2];\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            : Path.prototype.brush,\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t\r\n\t            var x = shape.cx;\r\n\t            var y = shape.cy;\r\n\t            var r0 = Math.max(shape.r0 || 0, 0);\r\n\t            var r = Math.max(shape.r, 0);\r\n\t            var startAngle = shape.startAngle;\r\n\t            var endAngle = shape.endAngle;\r\n\t            var clockwise = shape.clockwise;\r\n\t\r\n\t            var unitX = Math.cos(startAngle);\r\n\t            var unitY = Math.sin(startAngle);\r\n\t\r\n\t            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\r\n\t\r\n\t            ctx.lineTo(unitX * r + x, unitY * r + y);\r\n\t\r\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\r\n\t\r\n\t            ctx.lineTo(\r\n\t                Math.cos(endAngle) * r0 + x,\r\n\t                Math.sin(endAngle) * r0 + y\r\n\t            );\r\n\t\r\n\t            if (r0 !== 0) {\r\n\t                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\r\n\t            }\r\n\t\r\n\t            ctx.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 环形<br>\r\n\t * @class fishTopoFlow.node.Ring\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n\t *       var ring = new node.Ring({\r\n\t *           shape: {r:30,  r0:10},  // r0 内半径\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(ring);\r\n\t */\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t         type: 'Ring',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.r=0 外半径。\r\n\t         * @cfg {Number} shape.r0=0 内半径。\r\n\t         */\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            r: 0,\r\n\t            r0: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var x = shape.cx;\r\n\t            var y = shape.cy;\r\n\t            var PI2 = Math.PI * 2;\r\n\t            ctx.moveTo(x + shape.r, y);\r\n\t            ctx.arc(x, y, shape.r, 0, PI2, false);\r\n\t            ctx.moveTo(x + shape.r0, y);\r\n\t            ctx.arc(x, y, shape.r0, 0, PI2, true);\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * 椭圆<br>\r\n\t * @class fishTopoFlow.node.Droplet\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var ellipse = new node.Ellipse({\r\n\t *           shape: {rx:70,  ry:30},  // rx:椭圆横半轴长 ry:椭圆纵半轴长\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(ellipse);\r\n\t */\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Ellipse',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.rx=0 椭圆横半轴长\r\n\t         * @cfg {Number} shape.ry=0 椭圆纵半轴长\r\n\t         */\r\n\t        shape: {\r\n\t            rx: 0, ry: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var k = 0.5522848;\r\n\t            var x = 0;\r\n\t            var y = 0;\r\n\t            var a = shape.rx;\r\n\t            var b = shape.ry;\r\n\t            var ox = a * k; // 水平控制点偏移量\r\n\t            var oy = b * k; // 垂直控制点偏移量\r\n\t            // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线\r\n\t            ctx.moveTo(x - a, y);\r\n\t            ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);\r\n\t            ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);\r\n\t            ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);\r\n\t            ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);\r\n\t            ctx.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 104 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 心形<br>\r\n\t * @class fishTopoFlow.node.Heart\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var heart  = new node.Heart({\r\n\t *           shape: {width:40,  height:50},\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(heart );\r\n\t */\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Heart',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.cx=0 中心在父节点坐标系（以父节点左上角为原点）中的横坐标值。\r\n\t         * @cfg {Number} shape.cy=0 中心在父节点坐标系（以父节点左上角为原点）中的纵坐标值。\r\n\t         * @cfg {Number} shape.width=0 宽度。\r\n\t         * @cfg {Number} shape.height=0 高度。\r\n\t         */\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var x = shape.cx;\r\n\t            var y = shape.cy;\r\n\t            var a = shape.width;\r\n\t            var b = shape.height;\r\n\t            ctx.moveTo(x, y);\r\n\t            ctx.bezierCurveTo(\r\n\t                x + a / 2, y - b * 2 / 3,\r\n\t                x + a * 2, y + b / 3,\r\n\t                x, y + b\r\n\t            );\r\n\t            ctx.bezierCurveTo(\r\n\t                x - a *  2, y + b / 3,\r\n\t                x - a / 2, y - b * 2 / 3,\r\n\t                x, y\r\n\t            );\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 105 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * 水滴形<br>\r\n\t * @class fishTopoFlow.node.Droplet\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var droplet = new node.Droplet({\r\n\t *           shape: {width:10,  height:30},\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(droplet);\r\n\t */\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Droplet',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.width=0 宽度。\r\n\t         * @cfg {Number} shape.height=0 高度。\r\n\t         */\r\n\t        shape: {\r\n\t            cx: 0, cy: 0,\r\n\t            width: 0, height: 0\r\n\t        },\r\n\t\r\n\t        buildPath : function (ctx, shape) {\r\n\t            var x = shape.cx;\r\n\t            var y = shape.cy;\r\n\t            var a = shape.width;\r\n\t            var b = shape.height;\r\n\t\r\n\t            ctx.moveTo(x, y + a);\r\n\t            ctx.bezierCurveTo(\r\n\t                x + a,\r\n\t                y + a,\r\n\t                x + a * 3 / 2,\r\n\t                y - a / 3,\r\n\t                x,\r\n\t                y - b\r\n\t            );\r\n\t            ctx.bezierCurveTo(\r\n\t                x - a * 3 / 2,\r\n\t                y - a / 3,\r\n\t                x - a,\r\n\t                y + a,\r\n\t                x,\r\n\t                y + a\r\n\t            );\r\n\t            ctx.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 106 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 玫瑰形<br>\r\n\t * @class fishTopoFlow.node.Rose\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n\t *       var rose = new node.Rose({\r\n\t *           shape: {r:[35], k:7, n:4},\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(rose);\r\n\t */\r\n\t\r\n\t    var sin = Math.sin;\r\n\t    var cos = Math.cos;\r\n\t    var radian = Math.PI / 180;\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Rose',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Array} shape.r=[]\r\n\t         * @cfg {Number} shape.k=0\r\n\t         * @cfg {Number} shape.n=1\r\n\t         */\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            r: [],\r\n\t            k: 0,\r\n\t            n: 1\r\n\t        },\r\n\t\r\n\t        style: {\r\n\t            stroke: '#000',\r\n\t            fill: null,\r\n\t            lineWidth: 2\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var x;\r\n\t            var y;\r\n\t            var R = shape.r;\r\n\t            var r;\r\n\t            var k = shape.k;\r\n\t            var n = shape.n;\r\n\t\r\n\t            var x0 = shape.cx;\r\n\t            var y0 = shape.cy;\r\n\t\r\n\t            ctx.moveTo(x0, y0);\r\n\t\r\n\t            for (var i = 0, len = R.length; i < len ; i++) {\r\n\t                r = R[i];\r\n\t\r\n\t                for (var j = 0; j <= 360 * n; j++) {\r\n\t                    x = r\r\n\t                         * sin(k / n * j % 360 * radian)\r\n\t                         * cos(j * radian)\r\n\t                         + x0;\r\n\t                    y = r\r\n\t                         * sin(k / n * j % 360 * radian)\r\n\t                         * sin(j * radian)\r\n\t                         + y0;\r\n\t                    ctx.lineTo(x, y);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 107 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 正多边形<br>\r\n\t * @class fishTopoFlow.node.Isogon\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var isogon = new node.Isogon({\r\n\t *           shape: {r:40,  n:9},  // r半径 n几个边\r\n\t *           position:[60,50]\r\n\t *       });\r\n\t *       fishTopo.add(isogon);\r\n\t */\r\n\t\r\n\t    var PI = Math.PI;\r\n\t    var sin = Math.sin;\r\n\t    var cos = Math.cos;\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Isogon',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.r=0 半径\r\n\t         * @cfg {Number} shape.n=0 几个边\r\n\t         */\r\n\t       shape: {\r\n\t            x: 0, y: 0,\r\n\t            r: 0, n: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var n = shape.n;\r\n\t            if (!n || n < 2) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            var x = shape.x;\r\n\t            var y = shape.y;\r\n\t            var r = shape.r;\r\n\t\r\n\t            var dStep = 2 * PI / n;\r\n\t            var deg = -PI / 2;\r\n\t\r\n\t            ctx.moveTo(x + r * cos(deg), y + r * sin(deg));\r\n\t            for (var i = 0, end = n - 1; i < end; i++) {\r\n\t                deg += dStep;\r\n\t                ctx.lineTo(x + r * cos(deg), y + r * sin(deg));\r\n\t            }\r\n\t\r\n\t            ctx.closePath();\r\n\t\r\n\t            return;\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 108 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 多边形<br>\r\n\t * @class fishTopoFlow.node.Polygon\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var polygon = new node.Polygon({\r\n\t *           shape: {points:[[85.275,0], [100,25.41], [85.275,50.821], [14.138,50.821], [0,25.41], [14.138,0]]},  // r半径 n几个边\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(polygon);\r\n\t */\r\n\t\r\n\t    var polyHelper = __webpack_require__(53);\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t       type: 'Polygon',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Array} shape.points=null 多边形点的坐标 可以从AI中获取。\r\n\t         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑\r\n\t         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效\r\n\t         */\r\n\t        shape: {\r\n\t            points: null,\r\n\t\r\n\t            smooth: false,\r\n\t\r\n\t            smoothConstraint: null\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            polyHelper.buildPath(ctx, shape, true);\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 直线<br>\r\n\t * @class fishTopoFlow.node.Line\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var line = new node.Line({\r\n\t *           shape: {x1:60,  y1:60, x2:100, y2:100},  // x 起点 y终点\r\n\t *           style: {lineWidth:3}\r\n\t *       });\r\n\t *       fishTopo.add(line);\r\n\t */\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Line',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.x1=0 起始点的横坐标值。\r\n\t         * @cfg {Number} shape.y1=0 起始点的纵坐标值。\r\n\t         * @cfg {Number} shape.x2=0 终止点的横坐标值。\r\n\t         * @cfg {Number} shape.y2=0 终止点的纵坐标值。\r\n\t         */\r\n\t        shape: {\r\n\t            // Start point\r\n\t            x1: 0,\r\n\t            y1: 0,\r\n\t            // End point\r\n\t            x2: 0,\r\n\t            y2: 0,\r\n\t\r\n\t            percent: 1\r\n\t        },\r\n\t\r\n\t        style: {\r\n\t            stroke: '#000',\r\n\t            fill: null\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var x1 = shape.x1;\r\n\t            var y1 = shape.y1;\r\n\t            var x2 = shape.x2;\r\n\t            var y2 = shape.y2;\r\n\t            var percent = shape.percent;\r\n\t\r\n\t            if (percent === 0) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            ctx.moveTo(x1, y1);\r\n\t\r\n\t            if (percent < 1) {\r\n\t                x2 = x1 * (1 - percent) + x2 * percent;\r\n\t                y2 = y1 * (1 - percent) + y2 * percent;\r\n\t            }\r\n\t            ctx.lineTo(x2, y2);\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * Get point at percent\r\n\t         * @param  {number} percent\r\n\t         * @return {Array.<number>}\r\n\t         */\r\n\t        pointAt: function (p) {\r\n\t            var shape = this.shape;\r\n\t            return [\r\n\t                shape.x1 * (1 - p) + shape.x2 * p,\r\n\t                shape.y1 * (1 - p) + shape.y2 * p\r\n\t            ];\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 110 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * 拆线<br>\r\n\t * @class fishTopoFlow.node.Polyline\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var polyline = new node.Polyline({\r\n\t *           shape: {points:[[57,138],[95,184],[115,166],[151,184] ]}\r\n\t *       });\r\n\t *       fishTopo.add(polyline);\r\n\t */\r\n\t\r\n\t    var polyHelper = __webpack_require__(53);\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Polyline',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Array} shape.points=null 拆线点的坐标 可以从AI中获取。\r\n\t         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑\r\n\t         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效\r\n\t         */\r\n\t        shape: {\r\n\t            points: null,\r\n\t\r\n\t            smooth: false,\r\n\t\r\n\t            smoothConstraint: null\r\n\t        },\r\n\t\r\n\t        style: {\r\n\t            stroke: '#000',\r\n\t\r\n\t            fill: null\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            polyHelper.buildPath(ctx, shape, false);\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 111 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * 贝塞尔曲线<br>\r\n\t * @class fishTopoFlow.node.BezierCurve\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var bezierCurve = new node.BezierCurve({\r\n\t *           shape: {x1:0, y1:100, cpx1:0, cpy1:0, cpx2:0, cpy2:0, x2:100, y2:0},\r\n\t *           position: [60, 60]\r\n\t *       });\r\n\t *       fishTopo.add(bezierCurve);\r\n\t */\r\n\t\r\n\t\r\n\t    var curveTool = __webpack_require__(31);\r\n\t    var vec2 = __webpack_require__(15);\r\n\t    var quadraticSubdivide = curveTool.quadraticSubdivide;\r\n\t    var cubicSubdivide = curveTool.cubicSubdivide;\r\n\t    var quadraticAt = curveTool.quadraticAt;\r\n\t    var cubicAt = curveTool.cubicAt;\r\n\t    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\r\n\t    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\r\n\t\r\n\t    var out = [];\r\n\t\r\n\t    function someVectorAt(shape, t, isTangent) {\r\n\t        var cpx2 = shape.cpx2;\r\n\t        var cpy2 = shape.cpy2;\r\n\t        if (cpx2 === null || cpy2 === null) {\r\n\t            return [\r\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\r\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\r\n\t            ];\r\n\t        }\r\n\t        else {\r\n\t            return [\r\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\r\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\r\n\t            ];\r\n\t        }\r\n\t    }\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'BezierCurve',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.x1=0 起始点的横坐标值。\r\n\t         * @cfg {Number} shape.y1=0 起始点的纵坐标值。\r\n\t         * @cfg {Number} shape.x2=0 终止点的横坐标值。\r\n\t         * @cfg {Number} shape.y2=0 终止点的纵坐标值。\r\n\t         * @cfg {Number} shape.cpx1=0 控制点的横坐标值。\r\n\t         * @cfg {Boolean} shape.cpx2=0 控制点的纵坐标值。\r\n\t         */\r\n\t        shape: {\r\n\t            x1: 0,\r\n\t            y1: 0,\r\n\t            x2: 0,\r\n\t            y2: 0,\r\n\t            cpx1: 0,\r\n\t            cpy1: 0,\r\n\t\r\n\t            // Curve show percent, for animating\r\n\t            percent: 1\r\n\t        },\r\n\t\r\n\t        style: {\r\n\t            stroke: '#000',\r\n\t            fill: null\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var x1 = shape.x1;\r\n\t            var y1 = shape.y1;\r\n\t            var x2 = shape.x2;\r\n\t            var y2 = shape.y2;\r\n\t            var cpx1 = shape.cpx1;\r\n\t            var cpy1 = shape.cpy1;\r\n\t            var cpx2 = shape.cpx2;\r\n\t            var cpy2 = shape.cpy2;\r\n\t            var percent = shape.percent;\r\n\t            if (percent === 0) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            ctx.moveTo(x1, y1);\r\n\t\r\n\t            if (cpx2 == null || cpy2 == null) {\r\n\t                if (percent < 1) {\r\n\t                    quadraticSubdivide(\r\n\t                        x1, cpx1, x2, percent, out\r\n\t                    );\r\n\t                    cpx1 = out[1];\r\n\t                    x2 = out[2];\r\n\t                    quadraticSubdivide(\r\n\t                        y1, cpy1, y2, percent, out\r\n\t                    );\r\n\t                    cpy1 = out[1];\r\n\t                    y2 = out[2];\r\n\t                }\r\n\t\r\n\t                ctx.quadraticCurveTo(\r\n\t                    cpx1, cpy1,\r\n\t                    x2, y2\r\n\t                );\r\n\t            }\r\n\t            else {\r\n\t                if (percent < 1) {\r\n\t                    cubicSubdivide(\r\n\t                        x1, cpx1, cpx2, x2, percent, out\r\n\t                    );\r\n\t                    cpx1 = out[1];\r\n\t                    cpx2 = out[2];\r\n\t                    x2 = out[3];\r\n\t                    cubicSubdivide(\r\n\t                        y1, cpy1, cpy2, y2, percent, out\r\n\t                    );\r\n\t                    cpy1 = out[1];\r\n\t                    cpy2 = out[2];\r\n\t                    y2 = out[3];\r\n\t                }\r\n\t                ctx.bezierCurveTo(\r\n\t                    cpx1, cpy1,\r\n\t                    cpx2, cpy2,\r\n\t                    x2, y2\r\n\t                );\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * Get point at percent\r\n\t         * @param  {number} t\r\n\t         * @return {Array.<number>}\r\n\t         */\r\n\t        pointAt: function (t) {\r\n\t            return someVectorAt(this.shape, t, false);\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * Get tangent at percent\r\n\t         * @param  {number} t\r\n\t         * @return {Array.<number>}\r\n\t         */\r\n\t        tangentAt: function (t) {\r\n\t            var p = someVectorAt(this.shape, t, true);\r\n\t            return vec2.normalize(p, p);\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 112 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * 圆弧<br>\r\n\t * @class fishTopoFlow.node.Arc\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var arc = new node.Arc({\r\n\t *           shape: {r:50, startAngle:0, endAngle:1.2*Math.PI},\r\n\t *           position: [60, 60]\r\n\t *       });\r\n\t *       fishTopo.add(arc);\r\n\t */\r\n\t\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Arc',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.r=0 半径。\r\n\t         * @cfg {Number} shape.startAngle=0 开始弧度。\r\n\t         * @cfg {Number} shape.endAngle=Math.PI * 2  结束弧度。\r\n\t         * @cfg {Boolean} shape.clockwise=true 是否顺时针。\r\n\t         */\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            r: 0,\r\n\t            startAngle: 0,\r\n\t            endAngle: Math.PI * 2,\r\n\t            clockwise: true\r\n\t        },\r\n\t\r\n\t        style: {\r\n\t\r\n\t            stroke: '#000',\r\n\t\r\n\t            fill: null\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t\r\n\t            var x = shape.cx;\r\n\t            var y = shape.cy;\r\n\t            var r = Math.max(shape.r, 0);\r\n\t            var startAngle = shape.startAngle;\r\n\t            var endAngle = shape.endAngle;\r\n\t            var clockwise = shape.clockwise;\r\n\t\r\n\t            var unitX = Math.cos(startAngle);\r\n\t            var unitY = Math.sin(startAngle);\r\n\t\r\n\t            ctx.moveTo(unitX * r + x, unitY * r + y);\r\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 113 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * 星形<br>\r\n\t * @class fishTopoFlow.node.Star\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n\t *       var star = new node.Star({\r\n\t *           shape: {n:7, r:30},  //r半径 n几个角\r\n\t *           position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(star);\r\n\t */\r\n\t\r\n\t    var PI = Math.PI;\r\n\t\r\n\t    var cos = Math.cos;\r\n\t    var sin = Math.sin;\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Star',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.n=3 几个角。\r\n\t         * @cfg {Number} shape.r=0 外半径。\r\n\t         * @cfg {Number} shape.r0=0 内半径。\r\n\t         */\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            n: 3,\r\n\t            r0: null,\r\n\t            r: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t\r\n\t            var n = shape.n;\r\n\t            if (!n || n < 2) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            var x = shape.cx;\r\n\t            var y = shape.cy;\r\n\t            var r = shape.r;\r\n\t            var r0 = shape.r0;\r\n\t\r\n\t            // 如果未指定内部顶点外接圆半径，则自动计算\r\n\t            if (r0 == null) {\r\n\t                r0 = n > 4\r\n\t                    // 相隔的外部顶点的连线的交点，\r\n\t                    // 被取为内部交点，以此计算r0\r\n\t                    ? r * cos(2 * PI / n) / cos(PI / n)\r\n\t                    // 二三四角星的特殊处理\r\n\t                    : r / 3;\r\n\t            }\r\n\t\r\n\t            var dStep = PI / n;\r\n\t            var deg = -PI / 2;\r\n\t            var xStart = x + r * cos(deg);\r\n\t            var yStart = y + r * sin(deg);\r\n\t            deg += dStep;\r\n\t\r\n\t            // 记录边界点，用于判断inside\r\n\t            ctx.moveTo(xStart, yStart);\r\n\t            for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {\r\n\t                ri = i % 2 === 0 ? r0 : r;\r\n\t                ctx.lineTo(x + ri * cos(deg), y + ri * sin(deg));\r\n\t                deg += dStep;\r\n\t            }\r\n\t\r\n\t            ctx.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 114 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * 旋轮曲线<br>\r\n\t * @class fishTopoFlow.node.Trochoid\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n\t *       var trochoid = new node.Trochoid({\r\n\t *           shape: {r:50, r0:35, d:30, location:null},  //r半径 n几个角\r\n\t *           position:[60,60],\r\n\t *           tooltip: \"旋轮曲线\"\r\n\t *       });\r\n\t *       fishTopo.add(trochoid);\r\n\t */\r\n\t\r\n\t\r\n\t    var cos = Math.cos;\r\n\t    var sin = Math.sin;\r\n\t    module.exports = __webpack_require__(96).extend({\r\n\t\r\n\t        type: 'Trochoid',\r\n\t        /**\r\n\t         * @cfg {Object} shape 形状参数\r\n\t         * @cfg {Number} shape.r=0 外半径。\r\n\t         * @cfg {Number} shape.r0=0 内半径。\r\n\t         * @cfg {Number} shape.d=0\r\n\t         * @cfg {Number} shape.location='out'\r\n\t         */\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            r: 0,\r\n\t            r0: 0,\r\n\t            d: 0,\r\n\t            location: 'out'\r\n\t        },\r\n\t\r\n\t        style: {\r\n\t            stroke: '#000',\r\n\t\r\n\t            fill: null\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var x1;\r\n\t            var y1;\r\n\t            var x2;\r\n\t            var y2;\r\n\t            var R = shape.r;\r\n\t            var r = shape.r0;\r\n\t            var d = shape.d;\r\n\t            var offsetX = shape.cx;\r\n\t            var offsetY = shape.cy;\r\n\t            var delta = shape.location == 'out' ? 1 : -1;\r\n\t\r\n\t            if (shape.location && R <= r) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            var num = 0;\r\n\t            var i = 1;\r\n\t            var theta;\r\n\t\r\n\t            x1 = (R + delta * r) * cos(0)\r\n\t                - delta * d * cos(0) + offsetX;\r\n\t            y1 = (R + delta * r) * sin(0)\r\n\t                - d * sin(0) + offsetY;\r\n\t\r\n\t            ctx.moveTo(x1, y1);\r\n\t\r\n\t            // 计算结束时的i\r\n\t            do {\r\n\t                num++;\r\n\t            }\r\n\t            while ((r * num) % (R + delta * r) !== 0);\r\n\t\r\n\t            do {\r\n\t                theta = Math.PI / 180 * i;\r\n\t                x2 = (R + delta * r) * cos(theta)\r\n\t                     - delta * d * cos((R / r +  delta) * theta)\r\n\t                     + offsetX;\r\n\t                y2 = (R + delta * r) * sin(theta)\r\n\t                     - d * sin((R / r + delta) * theta)\r\n\t                     + offsetY;\r\n\t                ctx.lineTo(x2, y2);\r\n\t                i++;\r\n\t            }\r\n\t            while (i <= (r * num) / (R + delta * r) * 360);\r\n\t\r\n\t        }\r\n\t    });\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 路径<br>\r\n\t * @class fishTopoFlow.node.Path\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var path = new node.Path({\r\n\t *           pathData: 'M9 0l8 8-17 17 7 7 17-17 8 8v-23h-23z',\r\n\t *           rect: {x:0,y:0,width:30,height:30},\r\n\t *           position: [60,60]\r\n\t *       });\r\n\t *       fishTopo.add(path);\r\n\t */\r\n\t\r\n\t    var pathTool = __webpack_require__(6);\r\n\t    var Draggable = __webpack_require__(43);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var flowNode = __webpack_require__(96);\r\n\t\r\n\t    function ZPath(opts) {\r\n\t        /**\r\n\t         * @cfg {Object} options 参数\r\n\t         * @cfg {String} options.pathData path数据。\r\n\t         * @cfg {Object} options.rect 图形的大小。\r\n\t         * @cfg {Object} options.rect.width 图形的宽度。\r\n\t         * @cfg {Object} options.rect.height 图形的高度。\r\n\t         * @cfg {Number} [options.layout=null] 默认为null  仅支持\"center\"\r\n\t         *\r\n\t         */\r\n\t        var defaultOptions = {\r\n\t            style:{ fill: 'none',stroke: '#2c2c2c'},\r\n\t            rect:{x:0,y:0,width:0,height:0},\r\n\t            rectHover: true\r\n\t        }\r\n\t\r\n\t        var pathData = opts.pathData;\r\n\t        var model = flowNode.genModel(\"Path\", opts);\r\n\t        delete opts.pathData;\r\n\t        this.options = zrUtil.merge(defaultOptions, opts, true);\r\n\t        var path = pathTool.createFromString(pathData, this.options);\r\n\t        path.model = model;\r\n\t        Draggable.call(path);\r\n\t        var boundingRect = path.getBoundingRect();\r\n\t        var rect = this.options.rect;\r\n\t        var layout = opts.layout;\r\n\t        if (rect) {\r\n\t            var aspect = boundingRect.width / boundingRect.height;\r\n\t\r\n\t            if (layout === 'center') {\r\n\t                // Set rect to center, keep width / height ratio.\r\n\t                var width = rect.height * aspect;\r\n\t                var height;\r\n\t                if (width <= rect.width) {\r\n\t                    height = rect.height;\r\n\t                }\r\n\t                else {\r\n\t                    width = rect.width;\r\n\t                    height = width / aspect;\r\n\t                }\r\n\t                var cx = rect.x + rect.width / 2;\r\n\t                var cy = rect.y + rect.height / 2;\r\n\t\r\n\t                rect.x = cx - width / 2;\r\n\t                rect.y = cy - height / 2;\r\n\t                rect.width = width;\r\n\t                rect.height = height;\r\n\t            }\r\n\t\r\n\t            this.resizePath(path, rect);\r\n\t        }\r\n\t\r\n\t        return path;\r\n\t    }\r\n\t\r\n\t    ZPath.prototype = {\r\n\t\r\n\t        constructor: ZPath,\r\n\t\r\n\t        type: 'Path',\r\n\t        /**\r\n\t         * Resize a path to fit the rect\r\n\t         */\r\n\t        resizePath: function (path, rect) {\r\n\t                if (!path.applyTransform) {\r\n\t                    return;\r\n\t                }\r\n\t\r\n\t                var pathRect = path.getBoundingRect();\r\n\t\r\n\t                var m = pathRect.calculateTransform(rect);\r\n\t\r\n\t                path.applyTransform(m);\r\n\t        }\r\n\t    }\r\n\t    zrUtil.inherits(ZPath, Draggable);\r\n\t    module.exports = ZPath;\r\n\t\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 图形按钮<br>\r\n\t * @class fishTopoFlow.node.IconButton\r\n\t * @extends fishTopoFlow.node\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       var iconButton   = new node.IconButton({\r\n\t *          title:'IconButton',\r\n\t *          icon:'path://M432.45,595.444c0,2.177-4.661,6.82-11.305,6.82c-6.475,0-11.306-4.567-11.306-6.82s4.852-6.812,11.306-6.812C427.841,588.632,432.452,593.191,432.45,595.444L432.45,595.444z M421.155,589.876c-3.009,0-5.448,2.495-5.448,5.572s2.439,5.572,5.448,5.572c3.01,0,5.449-2.495,5.449-5.572C426.604,592.371,424.165,589.876,421.155,589.876L421.155,589.876z M421.146,591.891c-1.916,0-3.47,1.589-3.47,3.549c0,1.959,1.554,3.548,3.47,3.548s3.469-1.589,3.469-3.548C424.614,593.479,423.062,591.891,421.146,591.891L421.146,591.891zM421.146,591.891',\r\n\t *          itemSize:50,\r\n\t *          position:[60,60]\r\n\t *       });\r\n\t *       fishTopo.add(iconButton);\r\n\t */\r\n\t\r\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var graphic = __webpack_require__(4);\r\n\t    var flowNode = __webpack_require__(96);\r\n\t\r\n\t    function IconButton(opts) {\r\n\t\r\n\t        /**\r\n\t         * @cfg {Object} options 构造参数\r\n\t         * @cfg {String} options.title=\"\" 鼠标移上去显示的文字\r\n\t         * @cfg {String} options.icon=\"\" Icon 的 path 字符串，支持使用自定义的 svg path 作为 icon，格式参见 [SVG PathData](https://www.w3.org/TR/SVG/paths.html#PathData)。可以从 Adobe Illustrator 等工具编辑导出。\r\n\t         * @cfg {Number} options.itemSize=15  icon 的大小\r\n\t         * @cfg {Object} options.iconStyle  图标样式\r\n\t         * @cfg {Object} options.iconStyle.normal 正常的样式\r\n\t         * @cfg {Number} options.iconStyle.normal.stroke='#666' 正常的样式（描边色）\r\n\t         * @cfg {Number} options.iconStyle.normal.fill='none' 正常的样式（填充色）\r\n\t         * @cfg {Object} options.iconStyle.emphasis 高亮状态下的样式\r\n\t         * @cfg {Number} options.iconStyle.emphasis.stroke='#666' 高亮状态下的样式（描边色）\r\n\t         * @cfg {Number} options.iconStyle.emphasis.fill='none' 高亮状态下的样式（填充色）\r\n\t         */\r\n\t        var defaultOptions = {\r\n\t            backgroundColor: 'transparent',\r\n\t            borderColor: '#ccc',\r\n\t            draggable:false,\r\n\t            selectable:false,\r\n\t            borderWidth: 0,\r\n\t            itemSize: 15,\r\n\t            showTitle: true,\r\n\t            icon:\"\",  //Icon 的 path 字符串，支持使用自定义的 svg path 作为 icon，格式参见 SVG PathData。可以从 Adobe Illustrator 等工具编辑导出。\r\n\t            iconStyle: {\r\n\t                normal: {\r\n\t                    stroke: '#666',\r\n\t                    fill: 'none'\r\n\t                },\r\n\t                emphasis: {\r\n\t                    stroke: '#3E98c5'\r\n\t                }\r\n\t            }\r\n\t        };\r\n\t        this.options = zrUtil.merge(defaultOptions, opts, true);\r\n\t\r\n\t        this.model = flowNode.genModel(\"IconButton\", this.options);\r\n\t        graphic.Group.call(this, this.options);\r\n\t        this.render();\r\n\t    }\r\n\t    IconButton.prototype = {\r\n\t        constructor: IconButton,\r\n\t        type: \"IconButton\",\r\n\t        render: function () {\r\n\t            var normalStyle = this.options.iconStyle.normal;\r\n\t            var hoverStyle = this.options.iconStyle.emphasis;\r\n\t            var itemSize = this.options.itemSize;\r\n\t            var icon = this.options.icon;\r\n\t            var style = {\r\n\t                x: -itemSize / 2,\r\n\t                y: -itemSize / 2,\r\n\t                width: itemSize,\r\n\t                height: itemSize\r\n\t            };\r\n\t            var path = icon.indexOf('image://') === 0 ?\r\n\t                (\r\n\t                    style.image = icon.slice(8),\r\n\t                    new graphic.Image({\r\n\t                        style: style\r\n\t                    })\r\n\t                ) :\r\n\t                graphic.makePath(\r\n\t                    icon.replace('path://', ''), {\r\n\t                        style: normalStyle,\r\n\t                        hoverStyle: hoverStyle,\r\n\t                        rectHover: true\r\n\t                    },\r\n\t                    style,\r\n\t                    'center'\r\n\t                );\r\n\t\r\n\t            graphic.setHoverStyle(path);\r\n\t\r\n\t            if (this.options.showTitle) {\r\n\t                path.__title = this.options.title;\r\n\t                path.on('mouseover', function () {\r\n\t                        // Should not reuse above hoverStyle, which might be modified.\r\n\t                        path.setStyle({\r\n\t                            text: this.options.title,\r\n\t                            textPosition: hoverStyle.textPosition || 'bottom',\r\n\t                            textFill: hoverStyle.fill || hoverStyle.stroke || '#000',\r\n\t                            textAlign: hoverStyle.textAlign || 'center'\r\n\t                        });\r\n\t                    }.bind(this))\r\n\t                    .on('mouseout', function () {\r\n\t                        path.setStyle({\r\n\t                            textFill: null\r\n\t                        });\r\n\t                    });\r\n\t            }\r\n\t\r\n\t            path.trigger('normal');\r\n\t            this.add(path);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    zrUtil.inherits(IconButton, graphic.Group);\r\n\t    module.exports = IconButton;\r\n\t\r\n\t/**\r\n\t * @method extend\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 117 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * fishTopoFlow的link对象，框架提供的连线都放在这个对象下。\r\n\t * @class fishTopoFlow.link\r\n\t * @abstract\r\n\t */\r\n\t\r\n\t    var Link = __webpack_require__(118);\r\n\t    var Fold = __webpack_require__(120);\r\n\t    var Curve = __webpack_require__(121);\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var flowLink = {};\r\n\t    flowLink.Link = flowLink[Connector.TYPE_STRAIGHT] = Link;\r\n\t    flowLink.Fold = flowLink[Connector.TYPE_JAGGED] = Fold;\r\n\t    flowLink.Curve = flowLink[Connector.TYPE_CURVE] = Curve;\r\n\t    module.exports = flowLink;\r\n\t\r\n\t\r\n\t/**\r\n\t * @method constructor\r\n\t * 连线的构造函数\r\n\t * @param  {Object} startNode 开始节点\r\n\t * @param  {Object} endNode   结束节点\r\n\t * @param  {Object} options 线段选项\r\n\t * @param {Object} [options.style] 节点的样式\r\n\t * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n\t * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n\t * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n\t * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n\t * @param {Object} [options.symbol] 线段的箭头\r\n\t * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n\t * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n\t * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n\t * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n\t * @param {Object} [options.text] 线段上的文字\r\n\t * @param {String} [options.text.text] 线段上的文字内容\r\n\t * @param {String} [options.text.color] 线段上的文字颜色\r\n\t * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n\t * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n\t * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t * @param {String} [options.position] 指定线段位置\r\n\t * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n\t * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n\t * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n\t * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n\t * @param {Object} [options.effect] 线上动态效果\r\n\t * @param {String} [options.effect.show] 是否显示箭头动效\r\n\t * @param {Number} [options.effect.period] 动效移动速度\r\n\t * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n\t * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n\t * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n\t * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n\t * @return {Object} 返回创建成功的连线对象\r\n\t */\r\n\t\r\n\t\r\n\t/**\r\n\t * @method setStyle\r\n\t * 创建连线后，设置连线的样式\r\n\t * @param {Object} options 对应创建节点，传递的options参数\r\n\t */\r\n\t/**\r\n\t * @method on\r\n\t * 绑定事件\r\n\t * @param {String} event 事件名\r\n\t * @param {Function} handler 事件处理函数\r\n\t * @param {Object} [context] 上下文\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method off\r\n\t * 解绑事件\r\n\t * @param {String} event 事件名\r\n\t * @param {Function} handler 事件处理函数\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method one\r\n\t * 单次触发绑定,trigger后销毁\r\n\t * @param {String} event 事件名\r\n\t * @param {Function} handler 事件处理函数\r\n\t * @param {Object} [context] 上下文\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method trigger\r\n\t * 事件分发\r\n\t * @param {String} type 事件类型\r\n\t */\r\n\t/**\r\n\t * @event click\r\n\t * 单击事件\r\n\t *\r\n\t * <pre>\r\n\t * flink.on('Connector:click', function(e) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event dblclick\r\n\t * 当双击元素时，会发生 dblclick 事件。\r\n\t *\r\n\t * <pre>\r\n\t * flink.on('Connector:dblclick', function(e) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\n\n/***/ }),\n/* 118 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 直线<br>\r\n\t * @class fishTopoFlow.link.Link\r\n\t * @extends fishTopoFlow.link\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var link = fishTopoFlow.link;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       //节点\r\n\t *       function newNode(x, y, w, h) {\r\n\t *           var rect = new node.Rect({\r\n\t *               shape: {width: w,height: h},\r\n\t *               position: [x, y],\r\n\t *               style: {fill: \"#167CFF\"}\r\n\t *           });\r\n\t *           fishTopo.add(rect);\r\n\t *           return rect;\r\n\t *       }\r\n\t *       //简单连线\r\n\t *       function newLink(startNode, endNode, text, dashedPattern) {\r\n\t *           var slink = new link.Link(startNode, endNode, {\r\n\t *               style: {lineDash: [dashedPattern]},\r\n\t *               text: {text: text}\r\n\t *           })\r\n\t *           fishTopo.add(slink);\r\n\t *           return slink;\r\n\t *       }\r\n\t *       var from = newNode(100, 60, 30, 30);\r\n\t *       var to = newNode(300, 60, 30, 30);\r\n\t *       newLink(from, to, '虚线带箭头', 5);\r\n\t */\r\n\t\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var Flow = __webpack_require__(119);\r\n\t\r\n\t    function Link(startNode,endNode,options) {\r\n\t        var opt = Flow.translateLinkOptions(options);\r\n\t        //默认就是直线\r\n\t        var connector = new Connector(opt);\r\n\t        connector.startNode = startNode;\r\n\t        connector.endNode = endNode;\r\n\t\r\n\t        return connector;\r\n\t    }\r\n\t    /**\r\n\t     * @method createByPoint\r\n\t     * 用户指定连线的点，来进行画线\r\n\t     * @param  {Object} options 线段选项\r\n\t     * @param {Object} [options.style] 节点的样式\r\n\t     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n\t     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n\t     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n\t     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n\t     * @param {Object} [options.symbol] 线段的箭头\r\n\t     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n\t     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n\t     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n\t     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n\t     * @param {Object} [options.text] 线段上的文字\r\n\t     * @param {String} [options.text.text] 线段上的文字内容\r\n\t     * @param {String} [options.text.color] 线段上的文字颜色\r\n\t     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n\t     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n\t     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {String} [options.position] 指定线段位置\r\n\t     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n\t     * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n\t     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n\t     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n\t     * @param {Object} [options.effect] 线上动态效果\r\n\t     * @param {String} [options.effect.show] 是否显示箭头动效\r\n\t     * @param {Number} [options.effect.period] 动效移动速度\r\n\t     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n\t     * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n\t     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n\t     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n\t     */\r\n\t    Link.createByPoint = function(options) {\r\n\t        var opt = Flow.translateLinkOptions(options);\r\n\t        //默认就是直线\r\n\t        var connector = new Connector(opt);\r\n\t        return connector;\r\n\t    }\r\n\t\r\n\t    module.exports = Link;\r\n\t\r\n\t\r\n\n\n/***/ }),\n/* 119 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Flow静态方法类\r\n\t * @class fish.topo.FishTopoFlow.Flow\r\n\t */\r\n\t\r\n\t\r\n\t    var Constants = __webpack_require__(93);\r\n\t    var GroupNode = __webpack_require__(95);\r\n\t    var Flow = {\r\n\t        FLOW_TYPE: \"elementType\",\r\n\t        LINK: \"connection\",\r\n\t        RECT: \"Rect\",\r\n\t        Group: 'Group',\r\n\t        IMAGE: 'Image',\r\n\t        TEXT: 'Text',\r\n\t        CIRCLE: 'Circle',\r\n\t        SECTOR: 'Sector',\r\n\t        RING: 'Ring',\r\n\t        POLYGON: 'Polygon',\r\n\t        POLYLINE: 'Polyline',\r\n\t        LINE: 'Line',\r\n\t        BEZIERCURVE: 'Beziercurve',\r\n\t        ARC: 'Arc',\r\n\t        SCENE:'scene',\r\n\t\r\n\t        /**\r\n\t         * @method setUserData\r\n\t         * 设置用户数据\r\n\t         * @param {Object} node 需要设置数据的节点\r\n\t         * @param {Object} obj 数据\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //设置自定义数据\r\n\t         *      this.fishTopo.Flow.setUserData(rect, { customObj: \"rect\" });\r\n\t         */\r\n\t        setUserData: function(node, obj) {\r\n\t            node.model.set(Constants.USERDATA, obj);\r\n\t        },\r\n\t        /**\r\n\t         * 获取设置的用户数据\r\n\t         * @param {Object} node 需要获取数据的节点\r\n\t         * @return {String}      数据\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //获取自定义数据\r\n\t         *      this.fishTopo.Flow.getUserData(rect);\r\n\t         */\r\n\t        getUserData: function(node) {\r\n\t            return node.model.get(Constants.USERDATA);\r\n\t        },\r\n\t        /**\r\n\t         * 判断是否是连线\r\n\t         * @param {Object} model 对象的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是连线\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isLink(nodeModel)) { return true;}\r\n\t         */\r\n\t        isLink: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType == Flow.LINK;\r\n\t        },\r\n\t        /**\r\n\t         * 判断是否是节点\r\n\t         * @param {Object} model 对象的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是节点\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isNode(nodeModel)) { return true;}\r\n\t         */\r\n\t\r\n\t        isNode: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            var isNode;\r\n\t            if(elementType !=  Flow.LINK && elementType !=  Flow.SCENE){\r\n\t                isNode = true;\r\n\t            }else{\r\n\t                isNode = false;\r\n\t            }\r\n\t            return isNode;\r\n\t        },\r\n\t\r\n\t        isInGroup: function(node) {\r\n\t            return node.parent && node.parent instanceof GroupNode;\r\n\t        },\r\n\t\r\n\t        isGroupNode: function(node) {\r\n\t            return node instanceof GroupNode;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 判断节点是否是矩形节点\r\n\t         * @param {Object} model 节点的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是矩形节点\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isRect(nodeModel)) { return true;}\r\n\t         */\r\n\t        isRect: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return  elementType == Flow.RECT;\r\n\t        },\r\n\t        /**\r\n\t         * 判断节点是否是图片节点\r\n\t         * @param {Object} model 节点的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是图片节点\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isImage(nodeModel)) { return true;}\r\n\t         */\r\n\t        isImage: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType == Flow.IMAGE;\r\n\t        },\r\n\t        /**\r\n\t         * 判断节点是否是文字节点\r\n\t         * @param {Object} model 节点的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是文字节点\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isText(nodeModel)) { return true;}\r\n\t         */\r\n\t        isText: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType == Flow.TEXT;\r\n\t        },\r\n\t        /**\r\n\t         * 判断节点是否是圆形节点\r\n\t         * @param {Object} model 节点的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是圆形节点\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isCircle(nodeModel)) { return true;}\r\n\t         */\r\n\t        isCircle: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType == Flow.CIRCLE;\r\n\t        },\r\n\t        /**\r\n\t         * 获取节点的类型\r\n\t         * @param {Object} model 节点的model\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //获取节点类型\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      return this.fishTopo.Flow.getType(nodeModel);\r\n\t         */\r\n\t        getType: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType;\r\n\t        },\r\n\t        translateLinkOptions: function(options) {\r\n\t            if (options && options.pos) {\r\n\t                var arrPos = options.pos.split(\",\");\r\n\t                if (arrPos.length >= 2) {\r\n\t                    if (!options.position) {\r\n\t                        options.position = {};\r\n\t                    }\r\n\t                    options.position.startPos = arrPos[0];\r\n\t                    options.position.endPos = arrPos[1];\r\n\t                }\r\n\t            }\r\n\t            return options;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = Flow;\r\n\t\r\n\n\n/***/ }),\n/* 120 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 折线<br>\r\n\t * @class fishTopoFlow.link.Fold\r\n\t * @extends fishTopoFlow.link\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var link = fishTopoFlow.link;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       //节点\r\n\t *       function newNode(x, y, w, h) {\r\n\t *           var rect = new node.Rect({\r\n\t *               shape: {width: w,height: h},\r\n\t *               position: [x, y],\r\n\t *               style: {fill: \"#167CFF\"}\r\n\t *           });\r\n\t *           fishTopo.add(rect);\r\n\t *           return rect;\r\n\t *       }\r\n\t *       //折线\r\n\t *       function newFoldLink(startNode, endNode, text, direction, dashedPattern) {\r\n\t *           var flink = new link.Fold(startNode, endNode, {\r\n\t *               style: {lineDash: [dashedPattern]},\r\n\t *               text: {text: text},\r\n\t *               pos: direction\r\n\t *           })\r\n\t *           fishTopo.add(flink);\r\n\t *           return flink;\r\n\t *       }\r\n\t *       var from = newNode(100, 40, 30, 30);\r\n\t *       var to = newNode(300, 80, 30, 30);\r\n\t *       newFoldLink(from, to, '折线');\r\n\t */\r\n\t\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var Flow = __webpack_require__(119);\r\n\t\r\n\t    function Fold(startNode,endNode,options) {\r\n\t        //折线\r\n\t        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_JAGGED}}, options, true);\r\n\t        opt = Flow.translateLinkOptions(opt);\r\n\t        var connector = new Connector(opt);\r\n\t        connector.startNode = startNode;\r\n\t        connector.endNode = endNode;\r\n\t\r\n\t        return connector;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method createByPoint\r\n\t     * 用户指定连线的点，来进行画线\r\n\t     * @param  {Object} options 线段选项\r\n\t     * @param {Object} [options.style] 节点的样式\r\n\t     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n\t     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n\t     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n\t     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n\t     * @param {Object} [options.symbol] 线段的箭头\r\n\t     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n\t     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n\t     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n\t     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n\t     * @param {Object} [options.text] 线段上的文字\r\n\t     * @param {String} [options.text.text] 线段上的文字内容\r\n\t     * @param {String} [options.text.color] 线段上的文字颜色\r\n\t     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n\t     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n\t     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {String} [options.position] 指定线段位置\r\n\t     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n\t     * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n\t     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n\t     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n\t     * @param {Object} [options.effect] 线上动态效果\r\n\t     * @param {String} [options.effect.show] 是否显示箭头动效\r\n\t     * @param {Number} [options.effect.period] 动效移动速度\r\n\t     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n\t     * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n\t     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n\t     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n\t     */\r\n\t    Fold.createByPoint = function(options) {\r\n\t        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_JAGGED}}, options, true);\r\n\t        opt = Flow.translateLinkOptions(opt);\r\n\t        var connector = new Connector(opt);\r\n\t        return connector;\r\n\t    }\r\n\t    module.exports = Fold;\r\n\n\n/***/ }),\n/* 121 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 曲线<br>\r\n\t * @class fishTopoFlow.link.Curve\r\n\t * @extends fishTopoFlow.link\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var link = fishTopoFlow.link;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       //节点\r\n\t *       function newNode(x, y, w, h) {\r\n\t *           var rect = new node.Rect({\r\n\t *               shape: {width: w,height: h},\r\n\t *               position: [x, y],\r\n\t *               style: {fill: \"#167CFF\"}\r\n\t *           });\r\n\t *           fishTopo.add(rect);\r\n\t *           return rect;\r\n\t *       }\r\n\t *       //曲线\r\n\t *       function newCurveLink(startNode, endNode, text, direction, dashedPattern) {\r\n\t *           var clink = new link.Curve(startNode, endNode, {\r\n\t *               style: {lineDash: [dashedPattern]},\r\n\t *               text: {text: text},\r\n\t *               pos: direction\r\n\t *           })\r\n\t *           fishTopo.add(clink);\r\n\t *           return clink;\r\n\t *       }\r\n\t *       var from = newNode(100, 40, 30, 30);\r\n\t *       var to = newNode(300, 80, 30, 30);\r\n\t *       newCurveLink(from, to, '曲线');\r\n\t */\r\n\t\r\n\t    var Connector = __webpack_require__(82);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var Flow = __webpack_require__(119);\r\n\t    function Curve(startNode,endNode,options) {\r\n\t        //曲线\r\n\t        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_CURVE}}, options, true);\r\n\t        opt = Flow.translateLinkOptions(opt);\r\n\t\r\n\t        var connector = new Connector(opt);\r\n\t        connector.startNode = startNode;\r\n\t        connector.endNode = endNode;\r\n\t\r\n\t        return connector;\r\n\t    }\r\n\t    /**\r\n\t     * @method createByPoint\r\n\t     * 用户指定连线的点，来进行画线\r\n\t     * @param  {Object} options 线段选项\r\n\t     * @param {Object} [options.style] 节点的样式\r\n\t     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n\t     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n\t     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n\t     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n\t     * @param {Object} [options.symbol] 线段的箭头\r\n\t     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n\t     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n\t     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n\t     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n\t     * @param {Object} [options.text] 线段上的文字\r\n\t     * @param {String} [options.text.text] 线段上的文字内容\r\n\t     * @param {String} [options.text.color] 线段上的文字颜色\r\n\t     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n\t     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n\t     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {String} [options.position] 指定线段位置\r\n\t     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n\t     * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n\t     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n\t     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n\t     * @param {Object} [options.effect] 线上动态效果\r\n\t     * @param {String} [options.effect.show] 是否显示箭头动效\r\n\t     * @param {Number} [options.effect.period] 动效移动速度\r\n\t     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n\t     * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n\t     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n\t     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n\t     */\r\n\t    Curve.createByPoint = function(options) {\r\n\t        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_CURVE}}, options, true);\r\n\t        opt = Flow.translateLinkOptions(opt);\r\n\t        var connector = new Connector(opt);\r\n\t        return connector;\r\n\t    }\r\n\t    module.exports = Curve;\r\n\n\n/***/ }),\n/* 122 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连线操作类\r\n\t * @author miao.cunzhi\r\n\t */\r\n\t\r\n\t    var symbolUtil = __webpack_require__(83);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var icon = __webpack_require__(89);\r\n\t    function LineOperationManager(connectionManager, api) {\r\n\t        this.lineOperations = [],\r\n\t        this.isEdit = true;\r\n\t        this.connectionManager = connectionManager;\r\n\t        this._api = api;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     *  this.lineOperationManager.addIcon(key, options);\r\n\t     */\r\n\t    LineOperationManager.prototype.addIcon = function(key, options) {\r\n\t        //判断是小图标否存在 ，存在则直接返回\r\n\t        var lineOperationIcon = zrUtil.find(options.lineNode.icons, function(icon) {\r\n\t            return icon.key === key;\r\n\t        });\r\n\t\r\n\t        if (lineOperationIcon) {\r\n\t            this.bindOperation(options.lineNode);\r\n\t            return;\r\n\t        }else {\r\n\t            var lineOperation = this.creatOperation(key, options);\r\n\t            this._api._getParentZr().add(lineOperation);\r\n\t            this.bindOperation(options.lineNode);\r\n\t            return lineOperation;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    LineOperationManager.prototype.creatOperation = function(key, options) {\r\n\t        var lineOperation = symbolUtil.createSymbol(options.iconPath, 0, 0, options.width || 15, options.height || 15, 0, options.color||'#000');\r\n\t        lineOperation.key = key;\r\n\t        lineOperation._width =  options.width || 15;  // path情况下无法计算\r\n\t        lineOperation._isLineOperationIcon = true;\r\n\t        lineOperation.hide();\r\n\t        options.lineNode.icons.push(lineOperation);\r\n\t        this.lineOperations.push(lineOperation);\r\n\t\r\n\t        //小图标 点击事件  如果有回调则调用回调，否则派发事件\r\n\t        lineOperation.on(\"click\", function(event) {\r\n\t            if (options.callback) {\r\n\t                event.data = options;\r\n\t                event.lineNode = options.lineNode;\r\n\t                options.callback(event);\r\n\t            } else {\r\n\t                var params = {};\r\n\t                params.event = event;\r\n\t                params.type = \"click\";\r\n\t                params.elementType = \"LineOperationIcon\";\r\n\t                this._api.trigger(params.type, params);\r\n\t            }\r\n\t        }.bind(this));\r\n\t        return lineOperation;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 计算小图标的位置，并显示\r\n\t     * @param  {[type]} connector [description]\r\n\t     * @return {[type]}           [description]\r\n\t     */\r\n\t    LineOperationManager.prototype.bindOperation = function(connector) {\r\n\t        if (this.isEdit == false) {\r\n\t            return;\r\n\t        }\r\n\t        var pointPosition = connector.middle();\r\n\t\r\n\t        var arrLength = zrUtil.map(connector.icons, function(icon) {\r\n\t            return icon._width;\r\n\t        });\r\n\t\r\n\t        var totalLength = zrUtil.reduce(arrLength, function(previousValue,currentValue) {\r\n\t            return previousValue + currentValue + 10;\r\n\t        }, 0 );\r\n\t\r\n\t        zrUtil.each(connector.icons, function(icon, index) {\r\n\t            var connectorPosition = 0;\r\n\t            for (var k = 0; k < index; k++) {\r\n\t                connectorPosition += arrLength[k] + 10;\r\n\t            }\r\n\t            icon.attr(\"position\", [pointPosition[0] + connectorPosition - totalLength / 2, pointPosition[1] + 5]);\r\n\t            icon.show();\r\n\t            icon.attachLine = connector;\r\n\t        })\r\n\t    }\r\n\t\r\n\t    LineOperationManager.prototype.hideAllLineOperation = function() {\r\n\t        zrUtil.each(this.lineOperations, function(lineOperation) {\r\n\t            lineOperation.hide();\r\n\t        });\r\n\t    }\r\n\t\r\n\t    LineOperationManager.prototype.addDeleteIcon = function(lineNode,options) {\r\n\t        var opts = zrUtil.defaults({\r\n\t            iconPath: 'image://' + icon.DEL_IMG,\r\n\t            width: 12,\r\n\t            height: 14,\r\n\t            lineNode: lineNode,\r\n\t            callback: function(e) {\r\n\t                this._api.remove(e.target.attachLine);//this.connectionManager.selConnector);\r\n\t            }.bind(this)\r\n\t        }, options,true);\r\n\t\r\n\t        this.addIcon(\"delete\", opts);\r\n\t    }\r\n\t\r\n\t    LineOperationManager.prototype.addChangeLineTypeIcon = function(lineNode,options) {\r\n\t        var opts = zrUtil.defaults({\r\n\t            iconPath: 'image://' + icon.CHANGE_LINE_TYPE_IMG,\r\n\t            width: 15,\r\n\t            height: 15,\r\n\t            lineNode: lineNode,\r\n\t            callback: function () {\r\n\t                this._api.changeSelectConnectorType();\r\n\t            }.bind(this)\r\n\t        }, options,true);\r\n\t\r\n\t        this.addIcon(\"change\", opts)\r\n\t    }\r\n\t\r\n\t    module.exports = LineOperationManager;\r\n\t\r\n\n\n/***/ }),\n/* 123 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\r\n\t * fishTopoFlow的layout对象，框架提供的布局都放在这个对象下。通过addCustomLayout方法添加自定义布局\r\n\t * @class fishTopoFlow.layout\r\n\t * @abstract\r\n\t */\r\n\t\r\n\t    var BoundingRect = __webpack_require__(27);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var flowUtil = __webpack_require__(94);\r\n\t    var HLayout = __webpack_require__(124);\r\n\t    var VLayout = __webpack_require__(125);\r\n\t    var TreeLayout = __webpack_require__(126);\r\n\t    var ForceLayout = __webpack_require__(129);\r\n\t    var parsePercent = flowUtil.parsePercent;\r\n\t    var Tree = __webpack_require__(127);\r\n\t    var layout = {};\r\n\t    layout.HLayout = HLayout;\r\n\t    layout.VLayout = VLayout;\r\n\t    layout.TreeLayout = TreeLayout;\r\n\t    layout.ForceLayout = ForceLayout;\r\n\t    layout.Tree = Tree\r\n\t\r\n\t    /**\r\n\t     * @method addCustomLayout\r\n\t     * 添加自定义布局类\r\n\t     * @param {Object} customLayout 自定义布局的类\r\n\t     */\r\n\t    layout.addCustomLayout = function(customLayout) {\r\n\t        layout.customLayout = customLayout;\r\n\t    }\r\n\t\r\n\t\r\n\t    layout.getLayoutRect = function (positionInfo, containerRect, margin) {\r\n\t        margin = flowUtil.normalizeCssArray(margin || 0);\r\n\t\r\n\t        var containerWidth = containerRect.width;\r\n\t        var containerHeight = containerRect.height;\r\n\t\r\n\t        var left = parsePercent(positionInfo.left, containerWidth);\r\n\t        var top = parsePercent(positionInfo.top, containerHeight);\r\n\t        var right = parsePercent(positionInfo.right, containerWidth);\r\n\t        var bottom = parsePercent(positionInfo.bottom, containerHeight);\r\n\t        var width = parsePercent(positionInfo.width, containerWidth);\r\n\t        var height = parsePercent(positionInfo.height, containerHeight);\r\n\t\r\n\t        var verticalMargin = margin[2] + margin[0];\r\n\t        var horizontalMargin = margin[1] + margin[3];\r\n\t        var aspect = positionInfo.aspect;\r\n\t\r\n\t        // If width is not specified, calculate width from left and right\r\n\t        if (isNaN(width)) {\r\n\t            width = containerWidth - right - horizontalMargin - left;\r\n\t        }\r\n\t        if (isNaN(height)) {\r\n\t            height = containerHeight - bottom - verticalMargin - top;\r\n\t        }\r\n\t\r\n\t        // If width and height are not given\r\n\t        // 1. Graph should not exceeds the container\r\n\t        // 2. Aspect must be keeped\r\n\t        // 3. Graph should take the space as more as possible\r\n\t        if (isNaN(width) && isNaN(height)) {\r\n\t            if (aspect > containerWidth / containerHeight) {\r\n\t                width = containerWidth * 0.8;\r\n\t            }\r\n\t            else {\r\n\t                height = containerHeight * 0.8;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if (aspect != null) {\r\n\t            // Calculate width or height with given aspect\r\n\t            if (isNaN(width)) {\r\n\t                width = aspect * height;\r\n\t            }\r\n\t            if (isNaN(height)) {\r\n\t                height = width / aspect;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        // If left is not specified, calculate left from right and width\r\n\t        if (isNaN(left)) {\r\n\t            left = containerWidth - right - width - horizontalMargin;\r\n\t        }\r\n\t        if (isNaN(top)) {\r\n\t            top = containerHeight - bottom - height - verticalMargin;\r\n\t        }\r\n\t\r\n\t        // Align left and top\r\n\t        switch (positionInfo.left || positionInfo.right) {\r\n\t            case 'center':\r\n\t                left = containerWidth / 2 - width / 2 - margin[3];\r\n\t                break;\r\n\t            case 'right':\r\n\t                left = containerWidth - width - horizontalMargin;\r\n\t                break;\r\n\t        }\r\n\t        switch (positionInfo.top || positionInfo.bottom) {\r\n\t            case 'middle':\r\n\t            case 'center':\r\n\t                top = containerHeight / 2 - height / 2 - margin[0];\r\n\t                break;\r\n\t            case 'bottom':\r\n\t                top = containerHeight - height - verticalMargin;\r\n\t                break;\r\n\t        }\r\n\t        // If something is wrong and left, top, width, height are calculated as NaN\r\n\t        left = left || 0;\r\n\t        top = top || 0;\r\n\t        if (isNaN(width)) {\r\n\t            // Width may be NaN if only one value is given except width\r\n\t            width = containerWidth - left - (right || 0);\r\n\t        }\r\n\t        if (isNaN(height)) {\r\n\t            // Height may be NaN if only one value is given except height\r\n\t            height = containerHeight - top - (bottom || 0);\r\n\t        }\r\n\t\r\n\t        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\r\n\t        rect.margin = margin;\r\n\t        return rect;\r\n\t    };\r\n\t\r\n\t\r\n\t    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\r\n\t        var h = !opt || !opt.hv || opt.hv[0];\r\n\t        var v = !opt || !opt.hv || opt.hv[1];\r\n\t        var boundingMode = opt && opt.boundingMode || 'all';\r\n\t\r\n\t        if (!h && !v) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var rect;\r\n\t        if (boundingMode === 'raw') {\r\n\t            rect = (el.type === 'group' || el.type === 'GroupNode')\r\n\t                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\r\n\t                : el.getBoundingRect();\r\n\t        }\r\n\t        else {\r\n\t            rect = el.getBoundingRect();\r\n\t            if (el.needLocalTransform()) {\r\n\t                var transform = el.getLocalTransform();\r\n\t                // Notice: raw rect may be inner object of el,\r\n\t                // which should not be modified.\r\n\t                rect = rect.clone();\r\n\t                rect.applyTransform(transform);\r\n\t            }\r\n\t        }\r\n\t\r\n\t        positionInfo = layout.getLayoutRect(\r\n\t            zrUtil.defaults(\r\n\t                {width: rect.width, height: rect.height},\r\n\t                positionInfo\r\n\t            ),\r\n\t            containerRect,\r\n\t            margin\r\n\t        );\r\n\t\r\n\t        // Because 'tranlate' is the last step in transform\r\n\t        // (see zrender/core/Transformable#getLocalTransfrom),\r\n\t        // we can just only modify el.position to get final result.\r\n\t        var elPos = el.position;\r\n\t        var dx = h ? positionInfo.x - rect.x : 0;\r\n\t        var dy = v ? positionInfo.y - rect.y : 0;\r\n\t\r\n\t        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\r\n\t    };\r\n\t\r\n\t\r\n\t    module.exports = layout;\r\n\n\n/***/ }),\n/* 124 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 水平布局<br>\r\n\t * @class fishTopoFlow.layout.HLayout\r\n\t * @extends fishTopoFlow.layout\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var layout = fishTopoFlow.layout;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       function newNode(group,text) {\r\n\t *           var rect = new node.Rect({\r\n\t *                   shape:{width:25,height:25},\r\n\t *                   style: {text:text,fill: \"#167CFF\"}\r\n\t *               });\r\n\t *           group.add(rect);\r\n\t *           return rect;\r\n\t *       }\r\n\t *       var hGroup =  new node.Group({\r\n\t *           style: {\r\n\t *               text: \"水平布局\",\r\n\t *               textPosition:\"bottom\"\r\n\t *           },\r\n\t *           position:[50,50],\r\n\t *           layout : new layout.HLayout({gap:10})\r\n\t *       });\r\n\t *       newNode(hGroup, \"A_1\")\r\n\t *       newNode(hGroup, \"A_2\");\r\n\t *       newNode(hGroup, \"A_3\");\r\n\t *       newNode(hGroup, \"A_4\");\r\n\t *       newNode(hGroup, \"A_5\");\r\n\t *       fishTopo.add(hGroup);\r\n\t */\r\n\t\r\n\t            var zrUtil = __webpack_require__(5);\r\n\t             var Connector = __webpack_require__(82);\r\n\t            function HLayout(opts) {\r\n\t                /**\r\n\t                 * @cfg {Number} gap 节点之间的间隔\r\n\t                 */\r\n\t                /**\r\n\t                 * @cfg {Number} maxHeight=Infinity 组最大的宽度，如果超过会换行\r\n\t                 */\r\n\t                var defaultOptions = {\r\n\t                    gap: 5,\r\n\t                    maxWidth: Infinity\r\n\t                };\r\n\t                this.options = zrUtil.merge(defaultOptions, opts, true);\r\n\t            }\r\n\t            /**\r\n\t             * @method run\r\n\t             * 进行垂直布局，一般不需要调用，直接将布局类 赋值给组layout 属性即可\r\n\t             * @param {Object} group 需要进行垂直布局的组\r\n\t             */\r\n\t            HLayout.prototype.run = function(group)  {\r\n\t                var x = 0;\r\n\t                var y = 0;\r\n\t                var currentLineMaxSize = 0;\r\n\t                group.each(function (child, idx) {\r\n\t                    if (child instanceof Connector) {\r\n\t                        return;\r\n\t                    }\r\n\t\r\n\t                    var position = child.position;\r\n\t                    var rect = child.getBoundingRect();\r\n\t                    var nextChild = group.childAt(idx + 1);\r\n\t                    var nextChildRect = nextChild && nextChild.getBoundingRect();\r\n\t                    var nextX;\r\n\t\r\n\t                    var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\r\n\t                    nextX = x + moveX;\r\n\t                    // Wrap when width exceeds maxWidth or meet a `newline` group\r\n\t                    if (nextX > this.options.maxWidth || child.newline) {\r\n\t                        x = 0;\r\n\t                        nextX = moveX;\r\n\t                        y += currentLineMaxSize + parseInt(this.options.gap,10);\r\n\t                        currentLineMaxSize = rect.height;\r\n\t                    } else {\r\n\t                        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\r\n\t                    }\r\n\t\r\n\t                    if (child.newline) {\r\n\t                        return;\r\n\t                    }\r\n\t\r\n\t                    position[0] = x;\r\n\t                    position[1] = y;\r\n\t                    x = nextX + this.options.gap;\r\n\t                },this);\r\n\t\r\n\t                return HLayout;\r\n\t            }\r\n\t        module.exports = HLayout;\r\n\t\r\n\t/**\r\n\t * @method addCustomLayout\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 125 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 垂直布局<br>\r\n\t * @class fishTopoFlow.layout.VLayout\r\n\t * @extends fishTopoFlow.layout\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var layout = fishTopoFlow.layout;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       function newNode(group,text) {\r\n\t *           var rect = new node.Rect({\r\n\t *                   shape:{width:25,height:25},\r\n\t *                   style: {text:text,fill: \"#167CFF\"}\r\n\t *               });\r\n\t *           group.add(rect);\r\n\t *           return rect;\r\n\t *       }\r\n\t *       var vGroup =  new node.Group({\r\n\t *           style: {\r\n\t *               text: \"垂直布局\",\r\n\t *               textPosition:\"bottom\"\r\n\t *           },\r\n\t *           position:[60,60],\r\n\t *           layout : new layout.VLayout({gap:10})\r\n\t *       });\r\n\t*\r\n\t *       newNode(vGroup, \"A_1\")\r\n\t *       newNode(vGroup, \"A_2\");\r\n\t *       newNode(vGroup, \"A_3\");\r\n\t *       newNode(vGroup, \"A_4\");\r\n\t *       newNode(vGroup, \"A_5\");\r\n\t *       fishTopo.add(vGroup);\r\n\t */\r\n\t\r\n\t            var zrUtil = __webpack_require__(5);\r\n\t            var Connector = __webpack_require__(82);\r\n\t            function VLayout(opts) {\r\n\t                /**\r\n\t                 * @cfg {Number} gap 节点之间的间隔\r\n\t                 */\r\n\t                /**\r\n\t                 * @cfg {Number} maxHeight=Infinity 组最大的高度，如果超过会换行\r\n\t                 */\r\n\t                var defaultOptions = {\r\n\t                    gap: 5,\r\n\t                    maxHeight: Infinity\r\n\t                };\r\n\t                this.options = zrUtil.merge(defaultOptions, opts, true);\r\n\t            }\r\n\t\r\n\t            /**\r\n\t             * @method run\r\n\t             * 进行垂直布局，一般不需要调用，直接将布局类 赋值给组layout 属性即可\r\n\t             * @param {Object} group 需要进行垂直布局的组\r\n\t             */\r\n\t            VLayout.prototype.run = function(group)  {\r\n\t                var x = 0;\r\n\t                var y = 0;\r\n\t                var currentLineMaxSize = 0;\r\n\t                group.each(function (child, idx) {\r\n\t                    if (child instanceof Connector) {\r\n\t                        return;\r\n\t                    }\r\n\t\r\n\t                    var position = child.position;\r\n\t                    var rect = child.getBoundingRect();\r\n\t                    var nextChild = group.childAt(idx + 1);\r\n\t                    var nextChildRect = nextChild && nextChild.getBoundingRect();\r\n\t                    var nextY;\r\n\t\r\n\t                    var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\r\n\t                    nextY = y + moveY;\r\n\t                    // Wrap when width exceeds maxHeight or meet a `newline` group\r\n\t                    if (nextY > this.options.maxHeight || child.newline) {\r\n\t                        x += currentLineMaxSize + parseInt(this.options.gap,10);\r\n\t                        y = 0;\r\n\t                        nextY = moveY;\r\n\t                        currentLineMaxSize = rect.width;\r\n\t                    }\r\n\t                    else {\r\n\t                        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\r\n\t                    }\r\n\t\r\n\t                    if (child.newline) {\r\n\t                        return;\r\n\t                    }\r\n\t\r\n\t                    position[0] = x;\r\n\t                    position[1] = y;\r\n\t                    y = nextY + this.options.gap;\r\n\t                },this);\r\n\t\r\n\t                return VLayout;\r\n\t            }\r\n\t        module.exports = VLayout;\r\n\t\r\n\t\r\n\t/**\r\n\t * @method addCustomLayout\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 126 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 树布局<br>\r\n\t * @class fishTopoFlow.layout.TreeLayout\r\n\t * @extends fishTopoFlow.layout\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var layout = fishTopoFlow.layout;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n\t *       function newNode(data) {\r\n\t *           var circle = new node.Circle({\r\n\t *               shape: { r: 15 },\r\n\t *               style: { fill: \"#4883b4\" },\r\n\t *               name: data.name\r\n\t *           });\r\n\t *           return circle;\r\n\t *       }\r\n\t *       var options = {\r\n\t *           createNodeFunction: newNode,\r\n\t *           data:[{\r\n\t *               name: '根节点',\r\n\t *               children: [\r\n\t *                   {   name: '节点1',\r\n\t *                       children: [\r\n\t *                           {name: '叶子节点1'},\r\n\t *                           {name: '叶子节点2'},\r\n\t *                           {name: '叶子节点3'},\r\n\t *                           {name: '叶子节点4'},\r\n\t *                           {name: '叶子节点5'},\r\n\t *                           {name: '叶子节点6'}\r\n\t *                       ]\r\n\t *                   },\r\n\t *                   {   name: '节点2',\r\n\t *                       children: [\r\n\t *                           {name: '叶子节点7'},\r\n\t *                           {name: '叶子节点8'}]\r\n\t *                   },\r\n\t *                   {   name: '节点3',\r\n\t *                       children: [\r\n\t *                           {name: '叶子节点9'},\r\n\t *                           {name: '叶子节点10'},\r\n\t *                           {name: '叶子节点11'},\r\n\t *                           {name: '叶子节点12'}\r\n\t *                       ]\r\n\t *                   }\r\n\t *               ]\r\n\t *           }]\r\n\t *       }\r\n\t*\r\n\t *       var treeLayout = new layout.TreeLayout({\r\n\t *           fishTopo:fishTopo,\r\n\t *           rootLocation:{x:'center', y:50},\r\n\t *           nodePadding:1\r\n\t *       });\r\n\t *       treeLayout.doLayout(options);\r\n\t */\r\n\t\r\n\t            var zrUtil = __webpack_require__(5);\r\n\t            var BoundingRect = __webpack_require__(27);\r\n\t            var flowUtil = __webpack_require__(94);\r\n\t            var parsePercent = flowUtil.parsePercent;\r\n\t            var TreeData = __webpack_require__(127);  // 数据依赖\r\n\t            var TreeHelper = __webpack_require__(128); // 布局依赖\r\n\t            function TreeLayout(opts) {\r\n\t                /**\r\n\t                 * @cfg {Object} fishTopo fishTopo实例\r\n\t                 */\r\n\t                /**\r\n\t                 * @cfg {Object} rootLocation 根节点坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number\r\n\t                 * @cfg {Number|String} rootLocation.x  根节点横坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number\r\n\t                 * @cfg {Number|String} rootLocation.y  根节点纵坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number\r\n\t                 */\r\n\t                /**\r\n\t                 * @cfg {Number} layerPadding=100 层间距,默认:100\r\n\t                 */\r\n\t                /**\r\n\t                 * @cfg {Number} nodePadding=30 节点间距,默认:30\r\n\t                 */\r\n\t                /**\r\n\t                 *@cfg {String} direction 树的方向可选：'vertical' | 'horizontal' ,默认:vertical\r\n\t                 */\r\n\t                /**\r\n\t                 * @cfg {Object} lineStyle 连线的样式  参见{@link fishTopoFlow.link#constructor 构造函数options参数}\r\n\t                 */\r\n\t                var defaultOptions = {\r\n\t                    orient:'vertical',  // vertical,horizontal\r\n\t                    nodePadding:30, //节点间距\r\n\t                    layerPadding:100,  //层间距\r\n\t                    rootLocation: {x:100, y:230}, // 根节点坐标，支持绝对值（px）、字符和百分比\r\n\t                    animateTime : 500,\r\n\t                    lineStyle: {pos:'bottom,top', symbol:{type:'none'}}\r\n\t                };\r\n\t                if (opts.orient === 'horizontal') {\r\n\t                    defaultOptions.lineStyle.pos = 'right,left';\r\n\t                }\r\n\t\r\n\t                this.options = zrUtil.defaults(defaultOptions, opts, true);\r\n\t                this.nodePadding = this.options.nodePadding;\r\n\t                this.layerPadding = this.options.layerPadding;\r\n\t                this.fishTopo = this.options.fishTopo;\r\n\t                this._layerOffsets = [];\r\n\t                this._layers = [];\r\n\t                this._hideNodes = [];\r\n\t            }\r\n\t\r\n\t            /**\r\n\t             * @method layoutByRootNode\r\n\t             * 根据根节点及连线的关系 ，生成树\r\n\t             * @param {Object} rootNode 树的根节点\r\n\t             * @return {Object} boundingbox 包围和\r\n\t             */\r\n\t            TreeLayout.prototype.layoutByRootNode = function(rootNode) {\r\n\t                var connectors = this.fishTopo.connectionManager.connectors;  //所有线段的数组\r\n\t                //递归生成树型数据结构\r\n\t                function traverseNode(parentNode, treeData) {\r\n\t                    var childrenData = [];\r\n\t                    var childrenNode = [];\r\n\t                    //1.根据连线，找出起始节点的所有子节点\r\n\t                    zrUtil.each(connectors, function(connector) {\r\n\t                        if(connector.startNode === parentNode) {\r\n\t                            if(!connector.endNode.exclude) {   //如果是排斥的节点则不加入\r\n\t                                childrenNode.push(connector.endNode);\r\n\t                            }\r\n\t                        }\r\n\t                    })\r\n\t\r\n\t                    if (childrenNode.length > 0) {\r\n\t                        //2.遍历子节点\r\n\t                        zrUtil.each(childrenNode, function(node) {\r\n\t                             var nodeData = {name: node.id, node:node};\r\n\t                             childrenData.push(nodeData);\r\n\t                             traverseNode(node, nodeData);\r\n\t                        })\r\n\t                    }\r\n\t                    //3.将子节点放入children中\r\n\t                    if (childrenData.length > 0) {\r\n\t                        treeData.children = childrenData;\r\n\t                    }\r\n\t                }\r\n\t                var rootTreeData = {name: rootNode.id, node:rootNode};\r\n\t                traverseNode(rootNode,rootTreeData);\r\n\t                return this.doLayout({data:[rootTreeData]}, true);\r\n\t            }\r\n\t\r\n\t            /**\r\n\t             * @method doLayout\r\n\t             * 根据传过来树型结构数据进行树布局\r\n\t             * @param {Object} treeData 树形数据\r\n\t             * @param {Function} treeData.createNodeFunction=null 创建节点的函数 会把data中的数据 传递过去  如果没有默认就是创建圆形\r\n\t             * @param {Object} treeData.data 创建树布局数据（必须包括name属性）\r\n\t             * @param {boolean} isNotBuildLink=true 默认是自动创建连线，传true则不会自动创建连线\r\n\t             * @return {Object} boundingbox 包围和\r\n\t             */\r\n\t            TreeLayout.prototype.doLayout = function(treeData, isNotBuildLink)  {\r\n\t                var rootData = treeData.data[0];\r\n\t                this.treeData = treeData;\r\n\t\r\n\t                this.tree = TreeData.fromOptionData(rootData.name, rootData.children);\r\n\t                this.tree.root.data = rootData;\r\n\t\r\n\t\r\n\t                this._buildNode(treeData);\r\n\t\r\n\t                //根据root坐标 方向 对每个节点的坐标进行映射\r\n\t                this._setTreeShape(function() {\r\n\t                    this._buildAllLink(isNotBuildLink);\r\n\t                }.bind(this));\r\n\t\r\n\t                return this.getBoundingRect();\r\n\t            }\r\n\t\r\n\t            /**\r\n\t             * @private\r\n\t             * @method _buildAllLink\r\n\t             * 递归画出连接线 与设置节点坐标\r\n\t             */\r\n\t             TreeLayout.prototype._buildAllLink = function (isNotBuildLink) {\r\n\t                this.tree.traverse(function(treeNode) {\r\n\t                    //画连接线\r\n\t                    if (treeNode.children.length > 0 && !isNotBuildLink) {\r\n\t                        this._buildLinkByParent(treeNode, this.treeData.createLinkFunction)\r\n\t                    } else {\r\n\t                        this.fishTopo.connectionManager.refreshLineByNode(treeNode.data.node);\r\n\t                    }\r\n\t                },this)\r\n\t             }\r\n\t\r\n\t\r\n\t            /**\r\n\t             * @method getBoundingRect\r\n\t             * 计算出树的包围和\r\n\t             * @return {Object} boundingbox 包围和\r\n\t             */\r\n\t            TreeLayout.prototype.getBoundingRect = function() {\r\n\t                var rect = null;\r\n\t                this.tree.traverse(function(treeNode) {\r\n\t                    var childRect = BoundingRect.create({x:treeNode.layout.position[0], y:treeNode.layout.position[1], width:treeNode.layout.width, height: treeNode.layout.height});\r\n\t                    if (!rect) rect = childRect.clone();\r\n\t                    rect.union(childRect);\r\n\t                },this)\r\n\t                return rect;\r\n\t            }\r\n\t\r\n\t\r\n\t\r\n\t            TreeLayout.prototype._setTreeShape = function(doneCallback) {\r\n\t                var animateCount = 0;\r\n\t                var treeHelper = new TreeHelper(\r\n\t                    {\r\n\t                        nodePadding: this.nodePadding,\r\n\t                        layerPadding: this.layerPadding\r\n\t                    }\r\n\t                );\r\n\t\r\n\t\r\n\t                this.tree.traverse(function(treeNode) {\r\n\t                    if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){\r\n\t                        var boundingRect = treeNode.data.node.getBoundingRect();\r\n\t                        treeNode.layout = {\r\n\t                            width: treeNode.data.node._width || boundingRect.width,\r\n\t                            height: treeNode.data.node._height || boundingRect.height\r\n\t                        }\r\n\t                    }\r\n\t\r\n\t                },this);\r\n\t                treeHelper._hideNodes = this._hideNodes;\r\n\t                treeHelper.run(this.tree);\r\n\t                // 树的方向\r\n\t                var orient = this.options.orient;\r\n\t                var rootX = this.options.rootLocation.x;\r\n\t                var rootY = this.options.rootLocation.y;\r\n\t                var zrWidth = this.fishTopo.getWidth();\r\n\t                var zrHeight = this.fishTopo.getHeight();\r\n\t                if (rootX === 'center') {\r\n\t                    rootX = zrWidth * 0.5;\r\n\t                }\r\n\t                else {\r\n\t                    rootX = parsePercent(rootX, zrWidth);\r\n\t                }\r\n\t                if (rootY === 'center') {\r\n\t                    rootY = zrHeight * 0.5;\r\n\t                }\r\n\t                else {\r\n\t                    rootY = parsePercent(rootY, zrHeight);\r\n\t                }\r\n\t                rootY = parsePercent(rootY, zrHeight);\r\n\t                // 水平树\r\n\t                if (orient === 'horizontal') {\r\n\t                    rootX = isNaN(rootX) ? 10 : rootX;\r\n\t                    rootY = isNaN(rootY) ? zrHeight * 0.5 : rootY;\r\n\t                }\r\n\t                // 纵向树\r\n\t                else {\r\n\t                    rootX = isNaN(rootX) ? zrWidth * 0.5 : rootX;\r\n\t                    rootY = isNaN(rootY) ? 10 : rootY;\r\n\t                }\r\n\t                // tree layout自动算出来的root的坐标\r\n\t                var originRootX = this.tree.root.layout.position[0];\r\n\t\r\n\t                var treeNodeCount = treeHelper.count(this.tree) - this._hideNodes.length;\r\n\t                var minY = Infinity;\r\n\t\r\n\t                this.tree.traverse(\r\n\t                    function (treeNode) {\r\n\t                        var x;\r\n\t                        var y;\r\n\t                        if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){\r\n\t                            if (orient === 'vertical' && this.options.direction === 'inverse') {\r\n\t                                x = treeNode.layout.position[0] - originRootX + rootX;\r\n\t                                y = rootY - treeNode.layout.position[1];\r\n\t                            }\r\n\t                            else if (orient === 'vertical') {\r\n\t                                x = treeNode.layout.position[0] - originRootX + rootX;\r\n\t                                y = treeNode.layout.position[1] + rootY;\r\n\t                            }\r\n\t                            else if (orient === 'horizontal' && this.options.direction === 'inverse') {\r\n\t                                y = treeNode.layout.position[0] - originRootX + rootY;\r\n\t                                x = rootX - treeNode.layout.position[1];\r\n\t                            }\r\n\t                            else if (orient === 'horizontal') {\r\n\t                                y = treeNode.layout.position[0] - originRootX + rootY;\r\n\t                                x = treeNode.layout.position[1] + rootX;\r\n\t                            }\r\n\t                            treeNode.layout.__x = x;\r\n\t                            treeNode.layout.__y = y;\r\n\t                            if (y < minY) {\r\n\t                                minY = y;\r\n\t                            }\r\n\t                        }\r\n\t                    },\r\n\t                    this\r\n\t                );\r\n\t\r\n\t                this.tree.traverse(function (treeNode) {\r\n\t                    if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){\r\n\t                        if (minY > 0) {\r\n\t                            treeNode.layout.position[0] = treeNode.layout.__x;\r\n\t                            treeNode.layout.position[1] = treeNode.layout.__y;\r\n\t                        } else  {\r\n\t                            treeNode.layout.position[0] = treeNode.layout.__x;\r\n\t                            treeNode.layout.position[1] = treeNode.layout.__y - minY;\r\n\t                        }\r\n\t\r\n\t                        treeNode.data.node.animateTo({\r\n\t                            position: [treeNode.layout.position[0], treeNode.layout.position[1]]\r\n\t                        }, this.options.animateTime, function() {\r\n\t                            if (++animateCount === treeNodeCount) {\r\n\t                                doneCallback();\r\n\t                            }\r\n\t                        }.bind(this));\r\n\t                        //节点有孩子才显示 收缩按钮\r\n\t                        if(this._hideNodes.length == 0){\r\n\t                            if (treeNode.children.length > 0 && treeNode.data.node._toggleShrink) {\r\n\t                                treeNode.data.node._toggleShrink(true);\r\n\t                            }\r\n\t                        }\r\n\t                    }\r\n\t\r\n\t                },this)\r\n\t            }\r\n\t\r\n\t            TreeLayout.prototype._buildNode = function(treeData) {\r\n\t                if(!treeData.createNodeFunction) {\r\n\t                    treeData.createNodeFunction = this._defaultCreateNodeFunction;\r\n\t                }\r\n\t                //判断一下是否有node 如果没有则自己创建\r\n\t                this.tree.traverse(function(treeNode) {\r\n\t                    if(!treeNode.data.node) {\r\n\t                        var createNodeFunction = treeNode.data.createNodeFunction || treeData.createNodeFunction;\r\n\t                        var node = createNodeFunction(treeNode.data, this);\r\n\t                        node._childShow = true;\r\n\t                        this.fishTopo.add(node);\r\n\t                        treeNode.data.node = node;\r\n\t                    }\r\n\t                },this);\r\n\t            }\r\n\t\r\n\t            TreeLayout.prototype._defaultCreateNodeFunction = function(item) {\r\n\t                var circle = this.fishTopo.createNode(\"Circle\",{\r\n\t                    shape: { r: 15 },\r\n\t                    style: { fill: \"#4883b4\" },\r\n\t                    name: item.lable || item.name\r\n\t                });\r\n\t                return circle;\r\n\t            }\r\n\t\r\n\t            TreeLayout.prototype._buildLinkByParent = function (parentTreeNode, createLinkFunction) {\r\n\t                for (var i = 0, childLength = parentTreeNode.children.length; i < childLength; i++) {\r\n\t                    this._buildLink(parentTreeNode, parentTreeNode.children[i], createLinkFunction);\r\n\t                }\r\n\t            };\r\n\t\r\n\t\r\n\t            TreeLayout.prototype._buildLink = function (startTreeNode, endTreeNode, createLinkFunction) {\r\n\t                    var connector = null;\r\n\t                    var startNode = startTreeNode.data.node;\r\n\t                    var endNode = endTreeNode.data.node;\r\n\t                    if(createLinkFunction) {\r\n\t                        var paramObj =  endTreeNode.data;\r\n\t                        paramObj.startNode = startNode;\r\n\t                        paramObj.endNode = endNode;\r\n\t                        connector = createLinkFunction(paramObj);\r\n\t                    } else {\r\n\t                        var linkStyle = this.options.lineStyle;\r\n\t                        if (endTreeNode.data.lineStyle) {\r\n\t                            linkStyle = zrUtil.merge(zrUtil.clone(linkStyle), endTreeNode.data.lineStyle, true);\r\n\t                        }\r\n\t                        connector = this.fishTopo.createLink(startNode,endNode,linkStyle)\r\n\t                    }\r\n\t                    this.fishTopo.add(connector);\r\n\t            };\r\n\t\r\n\t\r\n\t            TreeLayout.prototype.addChild = function (treeNode, data, callback) {\r\n\t                var newTreeNode = (new TreeData(data.name)).root;\r\n\t                newTreeNode.data = data;\r\n\t\r\n\t                var node = this.treeData.createNodeFunction(newTreeNode.data, this);\r\n\t                node._childShow = true;\r\n\t                if (treeNode.children.length >= 1) {\r\n\t                    node.attr('position', zrUtil.clone(treeNode.children[treeNode.children.length - 1].layout.position));\r\n\t                } else {\r\n\t                    node.attr('position', zrUtil.clone(treeNode.layout.position));\r\n\t                }\r\n\t\r\n\t                this.fishTopo.add(node);\r\n\t                newTreeNode.data.node = node;\r\n\t                setTimeout(function () {\r\n\t                    this._buildLink(treeNode, newTreeNode, this.treeData.createLinkFunction);\r\n\t                }.bind(this), this.options.animateTime);\r\n\t\r\n\t                treeNode.add(newTreeNode);\r\n\t                this.refreshPositionAndLine(callback);\r\n\t                return node;\r\n\t            };\r\n\t\r\n\t            TreeLayout.prototype.toggleChild = function (node) {\r\n\t                var toggleTreeNode = this.findTreeNodeByNode(node);\r\n\t                if (node._childShow) {\r\n\t                    toggleTreeNode.traverse(function (treeNode) {\r\n\t                        if (treeNode.data.node !== node) {\r\n\t                            treeNode.data.node.hide();\r\n\t                            if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){\r\n\t                                this._hideNodes.push(treeNode);\r\n\t                            }\r\n\t                            this.fishTopo.connectionManager.toggleLineByNode(treeNode.data.node, false);\r\n\t                            if (treeNode.children.length > 0) {\r\n\t                                treeNode.data.node._childShow = false;\r\n\t                                treeNode.data.node._toggleShrink && treeNode.data.node._toggleShrink(false);\r\n\t                            }\r\n\t                        }\r\n\t                    },this);\r\n\t                    node._childShow = false;\r\n\t                    node._toggleShrink && node._toggleShrink(false);\r\n\t                    this.refreshPositionAndLine();\r\n\t                } else {\r\n\t                    toggleTreeNode.traverse(function (treeNode) {\r\n\t                        if (treeNode.data.node !== node) {\r\n\t                            treeNode.data.node.show();\r\n\t                            this._hideNodes.splice(zrUtil.indexOf(this._hideNodes, treeNode),1);\r\n\t                            this.fishTopo.connectionManager.toggleLineByNode(treeNode.data.node, true);\r\n\t                            if (treeNode.children.length > 0) {\r\n\t                                treeNode.data.node._childShow = true;\r\n\t                                treeNode.data.node._toggleShrink && treeNode.data.node._toggleShrink(true);\r\n\t                            }\r\n\t                        }\r\n\t                    },this);\r\n\t                    node._childShow = true;\r\n\t                    node._toggleShrink && node._toggleShrink(true);\r\n\t                    this.refreshPositionAndLine();\r\n\t                }\r\n\t            };\r\n\t\r\n\t\r\n\t            TreeLayout.prototype.findTreeNodeByNode = function (node) {\r\n\t                var returnTreeNode = null;\r\n\t                this.tree.traverse(function (treeNode) {\r\n\t                    if (treeNode.data.node === node) {\r\n\t                        returnTreeNode = treeNode;\r\n\t                    }\r\n\t                });\r\n\t                return returnTreeNode;\r\n\t            };\r\n\t\r\n\t            TreeLayout.prototype.removeNode = function (node) {\r\n\t                var treeNode = this.findTreeNodeByNode(node);\r\n\t                var parentTreeNode = treeNode.parent;\r\n\t                if (!parentTreeNode) return false;\r\n\t                //遍历 topo中删除自己及孩子节点\r\n\t                treeNode.traverse(function (eachTreeNode) {\r\n\t                    this.fishTopo.remove(eachTreeNode.data.node); //删除节点\r\n\t                },this)\r\n\t\r\n\t                parentTreeNode.remove(treeNode);\r\n\t\r\n\t                //判断一下父节点是不是没有了,如果没有的话,要把线与+-号给隐藏掉\r\n\t                if (parentTreeNode.children.length === 0) {\r\n\t                    parentTreeNode.data.node._hideToggle && parentTreeNode.data.node._hideToggle();\r\n\t                }\r\n\t\r\n\t                //重新生成数据\r\n\t                this.refreshPositionAndLine();\r\n\t                return true;\r\n\t            };\r\n\t\r\n\t\r\n\t            TreeLayout.prototype.removeChildren = function (node) {\r\n\t                var treeNode = this.findTreeNodeByNode(node);\r\n\t                //遍历 topo中删除孩子节点\r\n\t                treeNode.traverse(function (eachTreeNode) {\r\n\t                    if (eachTreeNode !== treeNode) {\r\n\t                        this.fishTopo.remove(eachTreeNode.data.node); //删除节点\r\n\t                    }\r\n\t                },this)\r\n\t\r\n\t                treeNode.removeAllChildren();\r\n\t                node._hideToggle && node._hideToggle(); //this._hidePath(node);\r\n\t\r\n\t                //重新生成数据\r\n\t                this.refreshPositionAndLine();\r\n\t                return true;\r\n\t            };\r\n\t\r\n\t            TreeLayout.prototype.refreshPositionAndLine = function (callback) {\r\n\t                this.tree.root.updateDepthAndHeight(0);\r\n\t                this._setTreeShape(function () {\r\n\t                    this.tree.traverse(function (eachTreeNode) {\r\n\t                        this.fishTopo.connectionManager.refreshLineByNode(eachTreeNode.data.node);\r\n\t                    }, this);\r\n\t                    callback && callback();\r\n\t                }.bind(this));\r\n\t            }\r\n\t\r\n\t            TreeLayout.prototype.changePosition = function (node, direction) {\r\n\t                var parentNode = node.parent;\r\n\t                var nowIndex = zrUtil.indexOf(parentNode.children, node);\r\n\t                var targetIndex;\r\n\t                if(direction == \"next\"){\r\n\t                    targetIndex = nowIndex + 1;\r\n\t                }else if(direction == \"prev\"){\r\n\t                    targetIndex = nowIndex - 1;\r\n\t                }\r\n\t                var targetNode = parentNode.children[targetIndex];\r\n\t                if(targetNode){\r\n\t                    var storage = targetNode;\r\n\t                    parentNode.children[targetIndex] = node;\r\n\t                    parentNode.children[nowIndex] = storage;\r\n\t                }\r\n\t                this.refreshPositionAndLine();\r\n\t                this.fishTopo.trigger('treeLayout:changePosition',{\r\n\t                    node:node,\r\n\t                    parentNode:parentNode,\r\n\t                    targetNode:targetNode\r\n\t                })\r\n\t            }\r\n\t\r\n\t        module.exports = TreeLayout;\r\n\t\r\n\t\r\n\t/**\r\n\t * @method addCustomLayout\r\n\t * @hide\r\n\t */\n\n/***/ }),\n/* 127 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t\r\n\t    /**\r\n\t     * @constructor TreeNode\r\n\t     * @param {string} id Node ID\r\n\t     * @param {Object} [data]\r\n\t     */\r\n\t    function TreeNode(id, data) {\r\n\t        /**\r\n\t         * @type {string}\r\n\t         */\r\n\t        this.id = id;\r\n\t        /**\r\n\t         * 节点的深度\r\n\t         * @type {number}\r\n\t         */\r\n\t        this.depth = 0;\r\n\t        /**\r\n\t         * 以当前节点为根节点的子树的高度\r\n\t         * @type {number}\r\n\t         */\r\n\t        this.height = 0;\r\n\t        /**\r\n\t         * 子节点列表\r\n\t         * @type {Array.<TreeNode>}\r\n\t         */\r\n\t        this.children = [];\r\n\t\r\n\t        /**\r\n\t         * @type {TreeNode}\r\n\t         */\r\n\t        this.parent = null;\r\n\t\r\n\t        /**\r\n\t         * 存储的用户数据\r\n\t         * @type {Object}\r\n\t         */\r\n\t        this.data = data || null;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 添加子节点\r\n\t     * @param {TreeNode} child\r\n\t     */\r\n\t    TreeNode.prototype.add = function (child) {\r\n\t        var children = this.children;\r\n\t        if (child.parent === this) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        children.push(child);\r\n\t        child.parent = this;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 移除子节点\r\n\t     * @param {TreeNode} child\r\n\t     */\r\n\t    TreeNode.prototype.remove = function (child) {\r\n\t        var children = this.children;\r\n\t        var idx = zrUtil.indexOf(children, child);\r\n\t        if (idx >= 0) {\r\n\t            children.splice(idx, 1);\r\n\t            child.parent = null;\r\n\t        }\r\n\t    };\r\n\t\r\n\t     TreeNode.prototype.removeAllChildren = function () {\r\n\t         var children = this.children;\r\n\t         for (var i = 0; i < children.length; i++) {\r\n\t             var child = children[i];\r\n\t            child.parent = null;\r\n\t         }\r\n\t        this.children = [];\r\n\t     }\r\n\t\r\n\t    /**\r\n\t     * 遍历当前节点及其所有子节点\r\n\t     * @param  {Function} cb\r\n\t     * @param  {Object}   [context]\r\n\t     */\r\n\t    TreeNode.prototype.traverse = function (cb, context) {\r\n\t        cb.call(context, this);\r\n\t\r\n\t        for (var i = 0; i < this.children.length; i++) {\r\n\t            this.children[i].traverse(cb, context);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 遍历节前节点及所有子节点的数量\r\n\t     */\r\n\t    TreeNode.prototype.count = function () {\r\n\t        var count = 0;\r\n\t        this.traverse(function() {\r\n\t            count++;\r\n\t         });\r\n\t        return count;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 更新当前树及所有子树的高度和深度\r\n\t     * @param  {number} depth\r\n\t     */\r\n\t    TreeNode.prototype.updateDepthAndHeight = function (depth) {\r\n\t        var height = 0;\r\n\t        this.depth = depth;\r\n\t        for (var i = 0; i < this.children.length; i++) {\r\n\t            var child = this.children[i];\r\n\t            child.updateDepthAndHeight(depth + 1);\r\n\t            if (child.height > height) {\r\n\t                height = child.height;\r\n\t            }\r\n\t        }\r\n\t        this.height = height + 1;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param  {string} id\r\n\t     * @return TreeNode\r\n\t     */\r\n\t    TreeNode.prototype.getNodeById = function (id) {\r\n\t        if (this.id === id) {\r\n\t            return this;\r\n\t        }\r\n\t        for (var i = 0; i < this.children.length; i++) {\r\n\t            var res = this.children[i].getNodeById(id);\r\n\t            if (res) {\r\n\t                return res;\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @constructor\r\n\t     * @alias module:echarts/data/Tree\r\n\t     * @param {string} id\r\n\t     */\r\n\t    function Tree(id) {\r\n\t        /**\r\n\t         * @type {TreeNode}\r\n\t         */\r\n\t        this.root = new TreeNode(id);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 遍历树的所有子节点(深度优先遍历)\r\n\t     * @param  {Function} cb\r\n\t     * @param  {Object}   [context]\r\n\t     */\r\n\t    Tree.prototype.traverse = function(cb, context) {\r\n\t        this.root.traverse(cb, context);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成子树\r\n\t     * @param  {string} id 子树根节点 id\r\n\t     * @return {module:echarts/data/Tree}\r\n\t     */\r\n\t    Tree.prototype.getSubTree = function(id) {\r\n\t        var root = this.getNodeById(id);\r\n\t        if (root) {\r\n\t            var tree = new Tree(root.id);\r\n\t            tree.root = root;\r\n\t            return tree;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param  {string} id\r\n\t     * @return TreeNode\r\n\t     */\r\n\t    Tree.prototype.getNodeById = function (id) {\r\n\t        return this.root.getNodeById(id);\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 从 option 里的 data 数据构建树\r\n\t     * @param {string} id\r\n\t     * @param {Array.<Object>} data\r\n\t     * @return Tree\r\n\t     */\r\n\t    Tree.fromOptionData = function (id, data) {\r\n\t        var tree = new Tree(id);\r\n\t        var rootNode = tree.root;\r\n\t        // Root node\r\n\t        rootNode.data = {\r\n\t            name: id,\r\n\t            children: data\r\n\t        };\r\n\t\r\n\t        function buildHierarchy(dataNode, parentNode) {\r\n\t            var node = new TreeNode(dataNode.name, dataNode);\r\n\t            parentNode.add(node);\r\n\t            // 遍历添加子节点\r\n\t            var children = dataNode.children;\r\n\t            if (children) {\r\n\t                for (var i = 0; i < children.length; i++) {\r\n\t                    buildHierarchy(children[i], node);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        for (var i = 0; i < data.length; i++) {\r\n\t            buildHierarchy(data[i], rootNode);\r\n\t        }\r\n\t\r\n\t        tree.root.updateDepthAndHeight(0);\r\n\t\r\n\t        return tree;\r\n\t    };\r\n\t\r\n\t\r\n\t    Tree.fromDataSource = function (dataSource, rootItem) {\r\n\t\r\n\t        function _findChildItem(nodeName) {\r\n\t            return zrUtil.filter(dataSource.link,function(item){\r\n\t                if(item.from === nodeName && !item.pos) {  // 数据中有pos属性的不是子节点\r\n\t                    return item;\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t\r\n\t\r\n\t        function buildHierarchy(root) {\r\n\t            var childItem = _findChildItem(root.id);\r\n\t            for (var i = 0; i < childItem.length; i++) {\r\n\t                var item = childItem[i];\r\n\t                var childTreeNode = treeNodesMap[item.to];\r\n\t                root.children.push(childTreeNode);\r\n\t                buildHierarchy(childTreeNode);\r\n\t            }\r\n\t        }\r\n\t\r\n\t        var treeNodesMap = {};\r\n\t        for (var i = 0; i < dataSource.node.length; i++) {\r\n\t            var node = dataSource.node[i];\r\n\t            var treeNode = new TreeNode(node.name,node);\r\n\t            treeNodesMap[node.name] = treeNode;\r\n\t        }\r\n\t\r\n\t        var tree = new Tree(rootItem.name);\r\n\t        var rootNode = tree.root;\r\n\t        // Root node\r\n\t        rootNode.data = rootItem;\r\n\t\r\n\t\r\n\t        buildHierarchy(tree.root);\r\n\t        tree.root.updateDepthAndHeight(0);\r\n\t\r\n\t        return tree;\r\n\t    };\r\n\t\r\n\t    module.exports = Tree;\r\n\n\n/***/ }),\n/* 128 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var vec2 = __webpack_require__(15);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t\r\n\t    function TreeHelper(opts) {\r\n\t        opts = opts || {};\r\n\t\r\n\t        this.nodePadding = opts.nodePadding || 30;\r\n\t\r\n\t        this.layerPadding = opts.layerPadding || 100;\r\n\t\r\n\t        this._layerOffsets = [];\r\n\t\r\n\t        this._layers = [];\r\n\t\r\n\t        this._hideNodes = [];\r\n\t    }\r\n\t\r\n\t    TreeHelper.prototype.count = function (tree) {\r\n\t        var count = 0;\r\n\t        tree.traverse(function() {\r\n\t            count++;\r\n\t         });\r\n\t        return count;\r\n\t    }\r\n\t\r\n\t    TreeHelper.prototype.run = function (tree) {\r\n\t        this._layerOffsets.length = 0;\r\n\t        for (var i = 0; i < tree.root.height + 1; i++) {\r\n\t            this._layerOffsets[i] = 0;\r\n\t            this._layers[i] = [];\r\n\t        }\r\n\t        this._updateNodeXPosition(tree.root);\r\n\t        var root = tree.root;\r\n\t        this._updateNodeYPosition(root, 0, root.layout.height);\r\n\t    };\r\n\t\r\n\t    TreeHelper.prototype._updateNodeXPosition = function (node) {\r\n\t        var minX = Infinity;\r\n\t        var maxX = -Infinity;\r\n\t        node.layout.position = node.layout.position || vec2.create();\r\n\t        for (var i = 0; i < node.children.length; i++) {\r\n\t            var child = node.children[i];\r\n\t            if(zrUtil.indexOf(this._hideNodes, child) == -1){\r\n\t                this._updateNodeXPosition(child);\r\n\t                var x = child.layout.position[0];\r\n\t                if (x < minX) {\r\n\t                    minX = x;\r\n\t                }\r\n\t                if (x > maxX) {\r\n\t                    maxX = x;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        if (node.children.length > 0 && (zrUtil.indexOf(this._hideNodes, node.children[0]) == -1)) {\r\n\t            node.layout.position[0] = (minX + maxX) / 2;\r\n\t        } else {\r\n\t            node.layout.position[0] = 0;\r\n\t            node.height = 0;   // 隐藏节点的 深度设为0\r\n\t        }\r\n\t        var off = this._layerOffsets[node.depth] || 0;\r\n\t        if (off > node.layout.position[0]) {\r\n\t            var shift = off - node.layout.position[0];\r\n\t            this._shiftSubtree(node, shift);\r\n\t            for (var j = node.depth + 1; j < node.height + node.depth; j++) {\r\n\t                this._layerOffsets[j] += shift;\r\n\t            }\r\n\t        }\r\n\t        this._layerOffsets[node.depth] = node.layout.position[0] + node.layout.width + this.nodePadding;\r\n\t\r\n\t        if(zrUtil.indexOf(this._layers[node.depth], node) == -1){\r\n\t            this._layers[node.depth].push(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    TreeHelper.prototype._shiftSubtree = function (root, offset) {\r\n\t        root.layout.position[0] += offset;\r\n\t        for (var i = 0; i < root.children.length; i++) {\r\n\t            if(zrUtil.indexOf(this._hideNodes,root.children[i]) == -1){\r\n\t                this._shiftSubtree(root.children[i], offset);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    TreeHelper.prototype._updateNodeYPosition = function (node, y, prevLayerHeight) {\r\n\t        if(zrUtil.indexOf(this._hideNodes,node) == -1){\r\n\t            node.layout.position[1] = y;\r\n\t            var layerHeight = 0;\r\n\t            for (var i = 0; i < node.children.length; i++) {\r\n\t                layerHeight = Math.max(node.children[i].layout.height, layerHeight);\r\n\t            }\r\n\t            var layerPadding = this.layerPadding;\r\n\t            if (typeof (layerPadding) === 'function') {\r\n\t                layerPadding = layerPadding(node.depth);\r\n\t            }\r\n\t            for (var j = 0; j < node.children.length; j++) {\r\n\t                this._updateNodeYPosition(node.children[j], y + layerPadding + prevLayerHeight, layerHeight);\r\n\t            }\r\n\t        }\r\n\t\r\n\t    };\r\n\t    module.exports = TreeHelper;\r\n\n\n/***/ }),\n/* 129 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 力导向布局<br>\r\n\t * @class fishTopoFlow.layout.ForceLayout\r\n\t * @extends fishTopoFlow.layout\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *       var node = fishTopoFlow.node;\r\n\t *       var layout = fishTopoFlow.layout;\r\n\t *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n\t *       function newNode(data) {\r\n\t *           var circle = new node.Circle({\r\n\t *               shape: { r: 15 },\r\n\t *               style: { fill: \"#4883b4\" },\r\n\t *               name: data.name\r\n\t *           });\r\n\t *           return circle;\r\n\t *       }\r\n\t *       var options = {\r\n\t *           createNodeFunction: newNode,\r\n\t *           data:[{nodes:[\r\n\t *                           {name: '节点1'},\r\n\t *                           {name: '节点2'},\r\n\t *                           {name: '节点3'},\r\n\t *                           {name: '节点4'},\r\n\t *                           {name: '节点5'},\r\n\t *                           {name: '节点6'},\r\n\t *                           {name: '节点7'},\r\n\t *                           {name: '节点8'}\r\n\t *                       ],\r\n\t *                   links:[\r\n\t *                           {source:'节点1', target:'节点2'},\r\n\t *                           {source:'节点2', target:'节点3'},\r\n\t *                           {source:'节点3', target:'节点4'},\r\n\t *                           {source:'节点4', target:'节点5'},\r\n\t *                           {source:'节点5', target:'节点6'},\r\n\t *                           {source:'节点6', target:'节点7'},\r\n\t *                           {source:'节点7', target:'节点8'}\r\n\t *                       ]\r\n\t *           }]\r\n\t *       }\r\n\t *       var forceLayout = new layout.ForceLayout({\r\n\t *          fishTopo:fishTopo,\r\n\t *           repulsion: 200\r\n\t *       });\r\n\t *       forceLayout.doLayout(options);\r\n\t */\r\n\t\r\n\t\r\n\t\r\n\t    var forceHelper = __webpack_require__(130);\r\n\t    var vec2 = __webpack_require__(15);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    function ForceLayout(opts) {\r\n\t         /**\r\n\t         * @cfg {Object} fishTopo fishTopo实例\r\n\t         */\r\n\t         /**\r\n\t         * @cfg {Number} [repulsion=100] 节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100\r\n\t         */\r\n\t         /**\r\n\t         * @cfg {Number} [gravity=0.1] 节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1\r\n\t         */\r\n\t        /**\r\n\t         * @cfg {Number} [edgeLength=30] 边的两个节点之间的距离，这个距离也会受 repulsion影响。 默认为30\r\n\t         */\r\n\t        /**\r\n\t         * @cfg {Boolean} [once=true] 是否只进行布局一次\r\n\t         */\r\n\t        /**\r\n\t         * @cfg {Object} [rect] 布局显示范围\r\n\t         *\r\n\t         * @cfg {Object} [rect.x] 布局显示范围x坐标\r\n\t         * @cfg {Object} [rect.y] 布局显示范围y坐标\r\n\t         * @cfg {Object} [rect.width] 布局显示宽度\r\n\t         * @cfg {Object} [rect.height] 布局显示高度\r\n\t         */\r\n\t        /**\r\n\t         * @cfg {Boolean} [layoutAnimation=true] 是否显示布局动画\r\n\t         */\r\n\t        /**\r\n\t         * @cfg {Object} [lineStyle] 连线的样式  参见{@link fishTopoFlow.link#constructor 构造函数options参数}\r\n\t         */\r\n\t        this.fishTopo = opts.fishTopo;\r\n\t        var defaultOptions = {\r\n\t            repulsion: 100,  //节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100\r\n\t            gravity: 0.1, //节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1\r\n\t            edgeLength: 30, // 边的两个节点之间的距离，这个距离也会受 repulsion。 默认为30\r\n\t            once:true,\r\n\t            layoutAnimation:true,\r\n\t            rect: {x:0, y:0, width:this.fishTopo.getWidth() ,height:this.fishTopo.getHeight()},\r\n\t            lineStyle: {symbol:{type:'none'}},\r\n\t            preservedPoints: {}\r\n\t        };\r\n\t\r\n\t        this.options = zrUtil.defaults(defaultOptions, opts, true);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method doLayout\r\n\t     * 根据forceData进行力导向布局\r\n\t     * @param {Object} forceData 力导向数据\r\n\t     * @param {Function} forceData.createNodeFunction=null 创建节点的函数 会把data中nodes的数据 传递过去  如果没有默认就是创建圆形\r\n\t     * @param {Object} forceData.data 创建力导向布局数据\r\n\t     * @param {Object} forceData.data.nodes 创建力导向布局节点的对象数据（必须包括name属性）\r\n\t     * @param {Object} forceData.data.links 创建力导向布局连线的对象数据（必须包括name属性）\r\n\t     *\r\n\t     */\r\n\t    ForceLayout.prototype.doLayout = function(forceData) {\r\n\t         var rootData = forceData.data[0];\r\n\t        this.allNodes = this._buildNode(rootData.nodes);\r\n\t        this.allLinks = this._buildLinks(rootData.links);\r\n\t        this._forceIns();\r\n\t\r\n\t        this._startForceLayoutIteration();\r\n\t    }\r\n\t\r\n\t    ForceLayout.prototype._buildNode = function(datas) {\r\n\t        if(!datas.createNodeFunction) {\r\n\t            datas.createNodeFunction = this._defaultCreateNodeFunction.bind(this);\r\n\t        }\r\n\t        var allNodes = [];\r\n\t        //判断一下是否有node 如果没有则自己创建\r\n\t        zrUtil.each(datas,  function(item,idx) {\r\n\t            if(!item.node) {\r\n\t                var createNodeFunction = item.createNodeFunction || datas.createNodeFunction;\r\n\t                var node = createNodeFunction(item);\r\n\t                this.fishTopo.add(node);\r\n\t                this._addNodeEvent(node,idx);\r\n\t                allNodes.push(node);\r\n\t            }\r\n\t        },this);\r\n\t        return allNodes;\r\n\t    }\r\n\t\r\n\t    ForceLayout.prototype._addNodeEvent = function(node,idx) {\r\n\t        if(!this.options.once) {\r\n\t            node.on('drag', function() {\r\n\t                if(this.options.forceLayout) {\r\n\t                    this.options.forceLayout.warmUp();\r\n\t                    !this._layouting && this._startForceLayoutIteration();\r\n\t                    this.options.forceLayout.setFixed(idx);\r\n\t                }\r\n\t            },this).on('dragend', function() {\r\n\t                if(this.options.forceLayout) {\r\n\t                    this.options.forceLayout.setUnfixed(idx);\r\n\t                }\r\n\t            },this)\r\n\t        }\r\n\t    }\r\n\t\r\n\t    ForceLayout.prototype._defaultCreateNodeFunction = function(item) {\r\n\t        var circle = this.fishTopo.createNode(\"Circle\",{\r\n\t            shape: { r: 15 },\r\n\t            style: { fill: \"#4883b4\" },\r\n\t            name: item.lable || item.name\r\n\t        });\r\n\t        return circle;\r\n\t    }\r\n\t\r\n\t    ForceLayout.prototype._buildLinks = function(links,createLinkFunction) {\r\n\t        var allLinks = [];\r\n\t\r\n\t        zrUtil.each(links, function(link) {\r\n\t            var startNode = this.fishTopo.childOfName(link.source);\r\n\t            var endNode = this.fishTopo.childOfName(link.target);\r\n\t            if(startNode && endNode) {\r\n\t                 var connector = null;\r\n\t                if(createLinkFunction) {\r\n\t                    var paramObj = link;\r\n\t                    paramObj.startNode = startNode;\r\n\t                    paramObj.endNode = endNode;\r\n\t                    connector = createLinkFunction(paramObj);\r\n\t                } else {\r\n\t                    var linkStyle = this.options.lineStyle;\r\n\t                    if (link.style) {\r\n\t                        linkStyle = zrUtil.merge(zrUtil.clone(linkStyle), link.style, true);\r\n\t                    }\r\n\t                    connector = this.fishTopo.createLink(startNode,endNode,linkStyle);\r\n\t                }\r\n\t                this.fishTopo.add(connector);\r\n\t                allLinks.push(connector);\r\n\t            }\r\n\t        },this);\r\n\t        return allLinks;\r\n\t    }\r\n\t\r\n\t\r\n\t    ForceLayout.prototype._forceIns = function() {\r\n\t        var rect = this.options.rect;\r\n\t        var self = this;\r\n\t        var preservedPoints = this.options.preservedPoints;\r\n\t        var nodes = zrUtil.map(this.allNodes, function(node) {\r\n\t            var rep = this.options.repulsion; node.w = rep; node.rep = rep; node.p = null;\r\n\t            return {\r\n\t                w: rep,\r\n\t                rep: rep,\r\n\t                p: null\r\n\t            };\r\n\t        },this);\r\n\t        if (preservedPoints) {\r\n\t            zrUtil.each(this.allNodes, function(node,idx) {\r\n\t                node.attr(\"position\", preservedPoints[idx]);\r\n\t            })\r\n\t        }\r\n\t        zrUtil.each(this.allLinks, function(link) {\r\n\t            link.n1 = link.startNode,\r\n\t            link.n2 = link.endNode,\r\n\t            link.d = this.options.edgeLength;\r\n\t            link.curveness = 0;\r\n\t        },this)\r\n\t\r\n\t        var forceInstance = forceHelper(this.allNodes, this.allLinks, {\r\n\t            rect: rect,\r\n\t            gravity: this.options.gravity\r\n\t        });\r\n\t        var oldStep = forceInstance.step;\r\n\t        forceInstance.step = function(cb) {\r\n\t            zrUtil.each(this.allNodes, function(node) {\r\n\t                if (nodes.fixed) {\r\n\t                    vec2.copy(nodes.p, nodes.position);\r\n\t                }\r\n\t            })\r\n\t\r\n\t            oldStep(function(allNodes, allLinks, stopped) {\r\n\t                for (var i = 0, l = allNodes.length; i < l; i++) {\r\n\t                    if (!allNodes[i].fixed) {\r\n\t                        allNodes[i].attr(\"position\", allNodes[i].p);\r\n\t                    }\r\n\t                    preservedPoints[i] = allNodes[i].p;\r\n\t                }\r\n\t\r\n\t                zrUtil.each(allLinks, function(connector) {\r\n\t                    self.fishTopo.connectionManager.refreshConnector(connector, true);\r\n\t                })\r\n\t\r\n\t                cb && cb(stopped);\r\n\t            });\r\n\t        };\r\n\t        this.options.forceLayout = forceInstance;\r\n\t        this.options.preservedPoints = preservedPoints;\r\n\t        // Step to get the layout\r\n\t        forceInstance.step();\r\n\t    }\r\n\t\r\n\t\r\n\t    ForceLayout.prototype._startForceLayoutIteration = function () {\r\n\t        var self = this;\r\n\t        var layoutAnimation = this.options.layoutAnimation;\r\n\t        (function step() {\r\n\t            self.options.forceLayout.step(function (stopped) {\r\n\t                self._layouting = !stopped;\r\n\t                if (self._layouting) {\r\n\t                    if (layoutAnimation) {\r\n\t                        self._layoutTimeout = setTimeout(step, 16)\r\n\t                    } else {\r\n\t                        step();\r\n\t                    }\r\n\t                } else {\r\n\t                     self.fishTopo.trigger(\"forceLayoutEnd\");  //派发布局结束事件\r\n\t                }\r\n\t            })\r\n\t        })();\r\n\t    };\r\n\t    module.exports = ForceLayout;\r\n\t\r\n\t/**\r\n\t * @method addCustomLayout\r\n\t * @hide\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event forceLayoutEnd\r\n\t * 布局结束事件\r\n\t *\r\n\t * <pre>\r\n\t * fishtopo.on('forceLayoutEnd', function(e) {\r\n\t *   //do something\r\n\t * })\r\n\t * </pre>\r\n\t */\r\n\n\n/***/ }),\n/* 130 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t\r\n\t    var vec2 = __webpack_require__(15);\r\n\t    var scaleAndAdd = vec2.scaleAndAdd;\r\n\t\r\n\t    // function adjacentNode(n, e) {\r\n\t    //     return e.n1 === n ? e.n2 : e.n1;\r\n\t    // }\r\n\t\r\n\t    module.exports = function (nodes, edges, opts) {\r\n\t        var rect = opts.rect;\r\n\t        var width = rect.width;\r\n\t        var height = rect.height;\r\n\t        var center = [rect.x + width / 2, rect.y + height / 2];\r\n\t        // var scale = opts.scale || 1;\r\n\t        var gravity = opts.gravity == null ? 0.1 : opts.gravity;\r\n\t\r\n\t        // for (var i = 0; i < edges.length; i++) {\r\n\t        //     var e = edges[i];\r\n\t        //     var n1 = e.n1;\r\n\t        //     var n2 = e.n2;\r\n\t        //     n1.edges = n1.edges || [];\r\n\t        //     n2.edges = n2.edges || [];\r\n\t        //     n1.edges.push(e);\r\n\t        //     n2.edges.push(e);\r\n\t        // }\r\n\t        // Init position\r\n\t        for (var i = 0; i < nodes.length; i++) {\r\n\t            var n = nodes[i];\r\n\t            if (!n.p) {\r\n\t                // Use the position from first adjecent node with defined position\r\n\t                // Or use a random position\r\n\t                // From d3\r\n\t                // if (n.edges) {\r\n\t                //     var j = -1;\r\n\t                //     while (++j < n.edges.length) {\r\n\t                //         var e = n.edges[j];\r\n\t                //         var other = adjacentNode(n, e);\r\n\t                //         if (other.p) {\r\n\t                //             n.p = vec2.clone(other.p);\r\n\t                //             break;\r\n\t                //         }\r\n\t                //     }\r\n\t                // }\r\n\t                // if (!n.p) {\r\n\t                    n.p = vec2.create(\r\n\t                        width * (Math.random() - 0.5) + center[0],\r\n\t                        height * (Math.random() - 0.5) + center[1]\r\n\t                    );\r\n\t                // }\r\n\t            }\r\n\t            n.pp = vec2.clone(n.p);\r\n\t            n.edges = null;\r\n\t        }\r\n\t\r\n\t        // Formula in 'Graph Drawing by Force-directed Placement'\r\n\t        // var k = scale * Math.sqrt(width * height / nodes.length);\r\n\t        // var k2 = k * k;\r\n\t\r\n\t        var friction = 0.6;\r\n\t\r\n\t        return {\r\n\t            warmUp: function () {\r\n\t                friction = 0.5;\r\n\t            },\r\n\t\r\n\t            setFixed: function (idx) {\r\n\t                nodes[idx].fixed = true;\r\n\t            },\r\n\t\r\n\t            setUnfixed: function (idx) {\r\n\t                nodes[idx].fixed = false;\r\n\t            },\r\n\t\r\n\t            step: function (cb) {\r\n\t                var v12 = [];\r\n\t                var nLen = nodes.length;\r\n\t                for (var i = 0; i < edges.length; i++) {\r\n\t                    var e = edges[i];\r\n\t                    var n1 = e.n1;\r\n\t                    var n2 = e.n2;\r\n\t\r\n\t                    vec2.sub(v12, n2.p, n1.p);\r\n\t                    var d = vec2.len(v12) - e.d;\r\n\t                    var w = n2.w / (n1.w + n2.w);\r\n\t                    vec2.normalize(v12, v12);\r\n\t\r\n\t                    !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);\r\n\t                    !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);\r\n\t                }\r\n\t                // Gravity\r\n\t                for (var i = 0; i < nLen; i++) {\r\n\t                    var n = nodes[i];\r\n\t                    if (!n.fixed) {\r\n\t                        vec2.sub(v12, center, n.p);\r\n\t                        // var d = vec2.len(v12);\r\n\t                        // vec2.scale(v12, v12, 1 / d);\r\n\t                        // var gravityFactor = gravity;\r\n\t                        vec2.scaleAndAdd(n.p, n.p, v12, gravity * friction);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                // Repulsive\r\n\t                // PENDING\r\n\t                for (var i = 0; i < nLen; i++) {\r\n\t                    var n1 = nodes[i];\r\n\t                    for (var j = i + 1; j < nLen; j++) {\r\n\t                        var n2 = nodes[j];\r\n\t                        vec2.sub(v12, n2.p, n1.p);\r\n\t                        var d = vec2.len(v12);\r\n\t                        if (d === 0) {\r\n\t                            // Random repulse\r\n\t                            vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);\r\n\t                            d = 1;\r\n\t                        }\r\n\t                        var repFact = (n1.rep + n2.rep) / d / d;\r\n\t                        !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);\r\n\t                        !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);\r\n\t                    }\r\n\t                }\r\n\t                var v = [];\r\n\t                for (var i = 0; i < nLen; i++) {\r\n\t                    var n = nodes[i];\r\n\t                    if (!n.fixed) {\r\n\t                        vec2.sub(v, n.p, n.pp);\r\n\t                        vec2.scaleAndAdd(n.p, n.p, v, friction);\r\n\t                        vec2.copy(n.pp, n.p);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                friction = friction * 0.992;\r\n\t\r\n\t                cb && cb(nodes, edges, friction < 0.01);\r\n\t            }\r\n\t        };\r\n\t    }\r\n\t\r\n\n\n/***/ }),\n/* 131 */\n/***/ (function(module, exports) {\n\n\t/**\r\n\t * 工具类\r\n\t * @class fishTopoFlow.util\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method initImagePool\r\n\t * 初始化图片池  用于对图片加载进行管理\r\n\t * @param {number} max 最大连接数。数值。\r\n\t * @returns {{load: Function, info: Function}}\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t        var imagepool = fishTopoFlow.util.initImagePool(100);\r\n\t        imagepool.load(grayArray, {\r\n\t            success: function(imgs) {\r\n\t            },\r\n\t            once: true\r\n\t        });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @method inherits\r\n\t * 构造类继承关系\r\n\t *\r\n\t * @param {Function} clazz 源类\r\n\t * @param {Function} baseClazz 基类\r\n\t */\r\n\t\r\n\t\r\n\t    var emptyFn = function() {};\r\n\t    //初始默认配置\r\n\t    var config_default = {\r\n\t        //线程池\"线程\"数量\r\n\t        thread: 5,\r\n\t        //图片加载失败重试次数\r\n\t        //重试2次，加上原有的一次，总共是3次\r\n\t        \"tries\": 2\r\n\t    };\r\n\t    //工具\r\n\t    var _helpers = {\r\n\t        //设置dom属性\r\n\t        setAttr: (function() {\r\n\t            var img = new Image();\r\n\t            //判断浏览器是否支持HTML5 dataset\r\n\t            if (img.dataset) {\r\n\t                return function(dom, name, value) {\r\n\t                    dom.dataset[name] = value;\r\n\t                    return value;\r\n\t                };\r\n\t            } else {\r\n\t                return function(dom, name, value) {\r\n\t                    dom.setAttribute(\"data-\" + name, value);\r\n\t                    return value;\r\n\t                };\r\n\t            }\r\n\t        }()),\r\n\t        //获取dom属性\r\n\t        getAttr: (function() {\r\n\t            var img = new Image();\r\n\t            //判断浏览器是否支持HTML5 dataset\r\n\t            if (img.dataset) {\r\n\t                return function(dom, name) {\r\n\t                    if(!dom.dataset[name]){\r\n\t                        return dom.getAttribute(\"data-\" + name);\r\n\t                    }else{\r\n\t                        return dom.dataset[name];\r\n\t                    }\r\n\t                };\r\n\t            } else {\r\n\t                return function(dom, name) {\r\n\t                    return dom.getAttribute(\"data-\" + name);\r\n\t                };\r\n\t            }\r\n\t        }())\r\n\t    };\r\n\t    /**\r\n\t     * 构造方法\r\n\t     * @private\r\n\t     * @param max 最大连接数。数值。\r\n\t     */\r\n\t    function ImagePool(max) {\r\n\t        //最大并发数量\r\n\t        this.max = max || config_default.thread;\r\n\t        this.linkHead = null;\r\n\t        this.linkNode = null;\r\n\t        //加载池\r\n\t        //[{img: dom,free: true, node: node}]\r\n\t        //node\r\n\t        //{src: \"\", options: {success: \"fn\",error: \"fn\", once: true}, tries: 0}\r\n\t        this.pool = [];\r\n\t    }\r\n\t    /**\r\n\t     * 初始化\r\n\t     * @private\r\n\t     */\r\n\t    ImagePool.prototype.initPool = function() {\r\n\t        var i, img, obj, _s;\r\n\t        _s = this;\r\n\t        for (i = 0; i < this.max; i++) {\r\n\t            obj = {};\r\n\t            img = new Image();\r\n\t            _helpers.setAttr(img, \"id\", i);\r\n\t            img.onload = function() {\r\n\t                //回调\r\n\t                _s.notice(_s.getNode(this), \"success\", this);\r\n\t                //处理任务\r\n\t                _s.executeLink(this);\r\n\t            };\r\n\t            img.onerror = function() {\r\n\t                var node = _s.getNode(this);\r\n\t                //判断尝试次数\r\n\t                if (node.tries < config_default.tries) {\r\n\t                    node.tries = node.tries+1;\r\n\t                    //再次追加到任务链表末尾\r\n\t                    _s.appendNode(_s.createNode(node.src, node.options, node.notice, node.group, node.tries));\r\n\t                } else {\r\n\t                    //error回调\r\n\t                    //node.options.error.call(null, this.src);\r\n\t                    _s.notice(node, \"error\", this);\r\n\t                }\r\n\t                //处理任务\r\n\t                _s.executeLink(this);\r\n\t            };\r\n\t            obj.img = img;\r\n\t            obj.free = true;\r\n\t            this.pool.push(obj);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 回调封装\r\n\t     * @private\r\n\t     * @param node 节点。对象。\r\n\t     * @param status 状态。字符串。可选值：success(成功)|error(失败)\r\n\t     * @param img 图片。\r\n\t     */\r\n\t    ImagePool.prototype.notice = function(node, status, img) {\r\n\t        node.notice(status, img);\r\n\t    };\r\n\t    /**\r\n\t     * 处理链表任务\r\n\t     * @private\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     */\r\n\t    ImagePool.prototype.executeLink = function(dom) {\r\n\t        //判断链表是否存在节点\r\n\t        if (this.linkHead) {\r\n\t            //加载下一个图片\r\n\t            this.setSrc(dom, this.linkHead);\r\n\t            //去除链表头\r\n\t            this.shiftNode();\r\n\t        } else {\r\n\t            //设置自身状态为空闲\r\n\t            this.status(dom, true);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 获取空闲\"线程\"\r\n\t     * @private\r\n\t     */\r\n\t    ImagePool.prototype.getFree = function() {\r\n\t        var length, i;\r\n\t        for (i = 0, length = this.pool.length; i < length; i++) {\r\n\t            if (this.pool[i].free) {\r\n\t                return this.pool[i];\r\n\t            }\r\n\t        }\r\n\t        return null;\r\n\t    };\r\n\t    /**\r\n\t     * 封装src属性设置\r\n\t     * 因为改变src属性相当于加载图片，所以把操作封装起来\r\n\t     * @private\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     * @param node 节点。对象。\r\n\t     */\r\n\t    ImagePool.prototype.setSrc = function(dom, node) {\r\n\t        //设置池中的\"线程\"为非空闲状态\r\n\t        this.status(dom, false);\r\n\t        //关联节点\r\n\t        this.setNode(dom, node);\r\n\t        //加载图片\r\n\t        dom.src = node.src;\r\n\t    };\r\n\t    /**\r\n\t     * 更新池中的\"线程\"状态\r\n\t     * @private\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     * @param status 状态。布尔。可选值：true(空闲)|false(非空闲)\r\n\t     */\r\n\t    ImagePool.prototype.status = function(dom, status) {\r\n\t        var id = _helpers.getAttr(dom, \"id\");\r\n\t        if(id){\r\n\t            this.pool[id].free = status;\r\n\t        }\r\n\t\r\n\t        //空闲状态，清除关联的节点\r\n\t        if (status) {\r\n\t            this.pool[id].node = null;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 更新池中的\"线程\"的关联节点\r\n\t     * @private\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     * @param node 节点。对象。\r\n\t     */\r\n\t    ImagePool.prototype.setNode = function(dom, node) {\r\n\t        var id = _helpers.getAttr(dom, \"id\");\r\n\t        if(id){\r\n\t            this.pool[id].node = node;\r\n\t            return this.pool[id].node === node;\r\n\t        }\r\n\t\r\n\t    };\r\n\t    /**\r\n\t     * 获取池中的\"线程\"的关联节点\r\n\t     * @private\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     */\r\n\t    ImagePool.prototype.getNode = function(dom) {\r\n\t        var id = _helpers.getAttr(dom, \"id\");\r\n\t        if(id){\r\n\t            return this.pool[id].node;\r\n\t        }\r\n\t\r\n\t    };\r\n\t    /**\r\n\t     * 对外接口，加载图片\r\n\t     * @private\r\n\t     * @param src 可以是src字符串，也可以是src字符串数组。\r\n\t     * @param options 用户自定义参数。包含：success回调、error回调、once标识。\r\n\t     */\r\n\t    ImagePool.prototype._load = function(src, options) {\r\n\t        var srcs = [],\r\n\t            free = null,\r\n\t            length = 0,\r\n\t            i = 0,\r\n\t            //只初始化一次回调策略\r\n\t            notice = (function() {\r\n\t                if (options.once) {\r\n\t                    return function(status, img) {\r\n\t                        var g = this.group,\r\n\t                            o = this.options;\r\n\t                        //记录\r\n\t                        g[status].push(img);\r\n\t                        //判断改组是否全部处理完成\r\n\t                        if (g.success.length + g.error.length === g.count) {\r\n\t                            //异步\r\n\t                            //实际上是作为另一个任务单独执行，防止回调函数执行时间过长影响图片加载速度\r\n\t                            setTimeout(function() {\r\n\t                                o.success.call(null, g.success, g.error, g.count);\r\n\t                            }, 1);\r\n\t                        }\r\n\t                    };\r\n\t                } else {\r\n\t                    return function(status, img) {\r\n\t                        var o = this.options;\r\n\t                        //直接回调\r\n\t                        setTimeout(function() {\r\n\t                            o[status].call(null, img);\r\n\t                        }, 1);\r\n\t                    };\r\n\t                }\r\n\t            }()),\r\n\t            group = {\r\n\t                count: 0,\r\n\t                success: [],\r\n\t                error: []\r\n\t            },\r\n\t            node = null;\r\n\t        options = options || {};\r\n\t        options.success = options.success || emptyFn;\r\n\t        options.error = options.error || emptyFn;\r\n\t        srcs = srcs.concat(src);\r\n\t        //设置组元素个数\r\n\t        group.count = srcs.length;\r\n\t        //遍历需要加载的图片\r\n\t        for (i = 0, length = srcs.length; i < length; i++) {\r\n\t            //创建节点\r\n\t            node = this.createNode(srcs[i], options, notice, group);\r\n\t            //判断线程池是否有空闲\r\n\t            free = this.getFree();\r\n\t            if (free) {\r\n\t                //有空闲，则立即加载图片\r\n\t                this.setSrc(free.img, node);\r\n\t            } else {\r\n\t                //没有空闲，将任务添加到链表\r\n\t                this.appendNode(node);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 获取内部状态信息\r\n\t     * @private\r\n\t     * @returns {Object}\r\n\t     */\r\n\t    ImagePool.prototype._info = function() {\r\n\t        var info = {},\r\n\t            length = 0,\r\n\t            i = 0,\r\n\t            node = null;\r\n\t        //线程\r\n\t        info.thread = {};\r\n\t        //线程总数量\r\n\t        info.thread.count = this.pool.length;\r\n\t        //空闲线程数量\r\n\t        info.thread.free = 0;\r\n\t        //任务\r\n\t        info.task = {};\r\n\t        //待处理任务数量\r\n\t        info.task.count = 0;\r\n\t        //获取空闲\"线程\"数量\r\n\t        for (i = 0, length = this.pool.length; i < length; i++) {\r\n\t            if (this.pool[i].free) {\r\n\t                info.thread.free = info.thread.free + 1;\r\n\t            }\r\n\t        }\r\n\t        //获取任务数量(任务链长度)\r\n\t        node = this.linkHead;\r\n\t        if (node) {\r\n\t            info.task.count = info.task.count + 1;\r\n\t            while (node.next) {\r\n\t                info.task.count = info.task.count + 1;\r\n\t                node = node.next;\r\n\t            }\r\n\t        }\r\n\t        return info;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建节点\r\n\t     * @private\r\n\t     * @param src 图片路径。字符串。\r\n\t     * @param options 用户自定义参数。包含：success回调、error回调、once标识。\r\n\t     * @param notice 回调策略。 函数。\r\n\t     * @param group 组信息。对象。{count: 0, success: [], error: []}\r\n\t     * @param tr 出错重试次数。数值。默认为0。\r\n\t     * @returns {Object}\r\n\t     */\r\n\t    ImagePool.prototype.createNode = function(src, options, notice, group, tr) {\r\n\t        var node = {};\r\n\t        node.src = src;\r\n\t        node.options = options;\r\n\t        node.notice = notice;\r\n\t        node.group = group;\r\n\t        node.tries = tr || 0;\r\n\t        return node;\r\n\t    };\r\n\t    /**\r\n\t     * 向任务链表末尾追加节点\r\n\t     * @private\r\n\t     * @param node 节点。对象。\r\n\t     */\r\n\t    ImagePool.prototype.appendNode = function(node) {\r\n\t        //判断链表是否为空\r\n\t        if (!this.linkHead) {\r\n\t            this.linkHead = node;\r\n\t            this.linkNode = node;\r\n\t        } else {\r\n\t            this.linkNode.next = node;\r\n\t            this.linkNode = node;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 删除链表头\r\n\t     * @private\r\n\t     */\r\n\t    ImagePool.prototype.shiftNode = function() {\r\n\t        //判断链表是否存在节点\r\n\t        if (this.linkHead) {\r\n\t            //修改链表头\r\n\t            this.linkHead = this.linkHead.next || null;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 初始化图片池\r\n\t     * @param {number} max 最大连接数。数值。\r\n\t     * @returns {{load: Function, info: Function}}\r\n\t     */\r\n\t    var initImagePool = function(max) {\r\n\t        var instance = new ImagePool(max);\r\n\t        instance.initPool();\r\n\t        return {\r\n\t            /**\r\n\t             * 加载图片\r\n\t             * @param {string|Array} src 可以是src字符串，也可以是src字符串数组。\r\n\t             * @param {Object} options 用户自定义参数。包含：success回调、error回调、once标识。\r\n\t             * @param {Function} [options.success] success回调\r\n\t             * @param {Function} [options.error] error回调\r\n\t             * @param {boolean} [options.once] 是否全部加载完毕后，一次回调\r\n\t             */\r\n\t            load: function() {\r\n\t                instance._load.apply(instance, arguments);\r\n\t            },\r\n\t            /**\r\n\t             * 获取内部状态信息\r\n\t             * @returns {Object}\r\n\t             */\r\n\t            info: function() {\r\n\t                return instance._info.call(instance);\r\n\t            }\r\n\t        };\r\n\t    };\r\n\t\r\n\t    module.exports = { initImagePool: initImagePool }\r\n\t\r\n\n\n/***/ }),\n/* 132 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var TooltipContent = __webpack_require__(133);\r\n\t    var globalListener = __webpack_require__(134);\r\n\t    var Model = __webpack_require__(87);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var env = __webpack_require__(50);\r\n\t    var flowUtil = __webpack_require__(94);\r\n\t    var layout = __webpack_require__(123);\r\n\t    function TooltipView(tooltipModel, api) {\r\n\t        this._tooltipContent = new TooltipContent(api.getDom(),api);\r\n\t        this._api = api;\r\n\t        this._tooltipModel = tooltipModel;\r\n\t        this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\r\n\t        this._initGloablListener();\r\n\t    }\r\n\t\r\n\t    TooltipView.prototype._initGloablListener = function() {\r\n\t        var triggerOn = this._tooltipModel.get('triggerOn');\r\n\t        // 当有 'click' | 'mousemove' | 'none' 事件时触发回调\r\n\t        globalListener.register(\r\n\t            'itemTooltip',\r\n\t            this._api,\r\n\t            function(currTrigger, e, dispatchAction){\r\n\t                if (triggerOn !== 'none') {\r\n\t                    if (triggerOn.indexOf(currTrigger) >= 0 ) {\r\n\t                        this._tryShow(e, dispatchAction);\r\n\t                    }\r\n\t                    else if (currTrigger === 'leave') {\r\n\t                        this._hide(dispatchAction)\r\n\t                    }\r\n\t                }\r\n\t            }.bind(this)\r\n\t        )\r\n\t    };\r\n\t\r\n\t    TooltipView.prototype._tryShow = function(e, dispatchAction) {\r\n\t            var el = e.target;\r\n\t            var tooltipModel = this._tooltipModel;\r\n\t\r\n\t            if (!tooltipModel) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\r\n\t            this._lastX = e.offsetX;\r\n\t            this._lastY = e.offsetY;\r\n\t\r\n\t            if (el && el.tooltip) {\r\n\t                this._showComponentItemTooltip(e, el);\r\n\t            }\r\n\t            else {\r\n\t                this._hide(dispatchAction);\r\n\t            }\r\n\t    };\r\n\t\r\n\t     TooltipView.prototype._hide = function(dispatchAction) {\r\n\t            // Do not directly hideLater here, because this behavior may be prevented\r\n\t            // in dispatchAction when showTip is dispatched.\r\n\t\r\n\t            // FIXME\r\n\t            // duplicated hideTip if manuallyHideTip is called from dispatchAction.\r\n\t            this._lastDataByCoordSys = null;\r\n\t            dispatchAction({\r\n\t                type: 'hideTip',\r\n\t                from: this.uid\r\n\t            });\r\n\t            this.manuallyHideTip();\r\n\t        };\r\n\t\r\n\t       TooltipView.prototype.dispose = function () {\r\n\t            if (env.node) {\r\n\t                return;\r\n\t            }\r\n\t            this._tooltipContent.hide();\r\n\t            globalListener.unregister('itemTooltip', this._api);\r\n\t        };\r\n\t\r\n\t        TooltipView.prototype.manuallyHideTip = function () {\r\n\t            var tooltipContent = this._tooltipContent;\r\n\t\r\n\t            if (!this._alwaysShowContent) {\r\n\t                tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\r\n\t            }\r\n\t\r\n\t            this._lastX = this._lastY = null;\r\n\t\r\n\t\r\n\t        },\r\n\t\r\n\t    TooltipView.prototype._showComponentItemTooltip = function (e, el) {\r\n\t            var tooltipOpt = el.tooltip;\r\n\t            if (typeof tooltipOpt === 'string') {\r\n\t                var content = tooltipOpt;\r\n\t                tooltipOpt = {\r\n\t                    content: content,\r\n\t                    // Fixed formatter\r\n\t                    formatter: content\r\n\t                };\r\n\t            }\r\n\t            var subTooltipModel = new Model(tooltipOpt, this._tooltipModel);\r\n\t            var defaultHtml = subTooltipModel.get('content');\r\n\t            var asyncTicket = Math.random();\r\n\t\r\n\t            // Do not check whether `trigger` is 'none' here, because `trigger`\r\n\t            // only works on cooridinate system. In fact, we have not found case\r\n\t            // that requires setting `trigger` nothing on component yet.\r\n\t\r\n\t            this._showOrMove(subTooltipModel, function () {\r\n\t                this._showTooltipContent(\r\n\t                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\r\n\t                    asyncTicket, e.offsetX, e.offsetY, e.position, el\r\n\t                );\r\n\t            });\r\n\t\r\n\t\r\n\t        };\r\n\t\r\n\t      TooltipView.prototype._showOrMove = function (tooltipModel, cb) {\r\n\t            // showDelay is used in this case: tooltip.enterable is set\r\n\t            // as true. User intent to move mouse into tooltip and click\r\n\t            // something. `showDelay` makes it easyer to enter the content\r\n\t            // but tooltip do not move immediately.\r\n\t            var delay = tooltipModel.get('showDelay');\r\n\t            cb = zrUtil.bind(cb, this);\r\n\t            clearTimeout(this._showTimout);\r\n\t            delay > 0\r\n\t                ? (this._showTimout = setTimeout(cb, delay))\r\n\t                : cb();\r\n\t        };\r\n\t\r\n\t        TooltipView.prototype._showTooltipContent = function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {\r\n\t            // Reset ticket\r\n\t            this._ticket = '';\r\n\t\r\n\t            if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            var tooltipContent = this._tooltipContent;\r\n\t\r\n\t            var formatter = tooltipModel.get('formatter');\r\n\t            positionExpr = positionExpr || tooltipModel.get('position');\r\n\t            var html = defaultHtml;\r\n\t\r\n\t            if (formatter && typeof formatter === 'string') {\r\n\t                html = flowUtil.formatTpl(formatter, params, true);\r\n\t            }\r\n\t            else if (typeof formatter === 'function') {\r\n\t                var callback = function (cbTicket, html) {\r\n\t                    if (cbTicket === this._ticket) {\r\n\t                        tooltipContent.setContent(html);\r\n\t                        this._updatePosition(\r\n\t                            tooltipModel, positionExpr, x, y, tooltipContent, params, el\r\n\t                        );\r\n\t                    }\r\n\t                }.bind(this);\r\n\t                this._ticket = asyncTicket;\r\n\t                html = formatter(params, asyncTicket, callback);\r\n\t            }\r\n\t\r\n\t            tooltipContent.setContent(html);\r\n\t            tooltipContent.show(tooltipModel);\r\n\t\r\n\t            this._updatePosition(\r\n\t                tooltipModel, positionExpr, x, y, tooltipContent, params, el\r\n\t            );\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * @param  {string|Function|Array.<number>} positionExpr\r\n\t         * @param  {number} x Mouse x\r\n\t         * @param  {number} y Mouse y\r\n\t         * @param  {boolean} confine Whether confine tooltip content in view rect.\r\n\t         * @param  {Object|<Array.<Object>} params\r\n\t         * @param  {module:zrender/Element} el target element\r\n\t         * @param  {module:echarts/ExtensionAPI} api\r\n\t         * @return {Array.<number>}\r\n\t         */\r\n\t        TooltipView.prototype._updatePosition = function (tooltipModel, positionExpr, x, y, content, params, el) {\r\n\t            var viewWidth = this._api.getWidth();\r\n\t            var viewHeight = this._api.getHeight();\r\n\t            positionExpr = positionExpr || tooltipModel.get('position');\r\n\t\r\n\t            var contentSize = content.getSize();\r\n\t            var align = tooltipModel.get('align');\r\n\t            var vAlign = tooltipModel.get('verticalAlign');\r\n\t            var rect = el && el.getBoundingRect().clone();\r\n\t            el && rect.applyTransform(el.transform);\r\n\t\r\n\t            if (typeof positionExpr === 'function') {\r\n\t                // Callback of position can be an array or a string specify the position\r\n\t                positionExpr = positionExpr([x, y], params, content.el, rect, {\r\n\t                    viewSize: [viewWidth, viewHeight],\r\n\t                    contentSize: contentSize.slice()\r\n\t                });\r\n\t            }\r\n\t\r\n\t            if (zrUtil.isArray(positionExpr)) {\r\n\t                x = flowUtil.parsePercent(positionExpr[0], viewWidth);\r\n\t                y = flowUtil.parsePercent(positionExpr[1], viewHeight);\r\n\t            }\r\n\t            else if (zrUtil.isObject(positionExpr)) {\r\n\t                positionExpr.width = contentSize[0];\r\n\t                positionExpr.height = contentSize[1];\r\n\t                var layoutRect = layout.getLayoutRect(\r\n\t                    positionExpr, {width: viewWidth, height: viewHeight}\r\n\t                );\r\n\t                x = layoutRect.x;\r\n\t                y = layoutRect.y;\r\n\t                align = null;\r\n\t                // When positionExpr is left/top/right/bottom,\r\n\t                // align and verticalAlign will not work.\r\n\t                vAlign = null;\r\n\t            }\r\n\t            // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\r\n\t            else if (typeof positionExpr === 'string' && el) {\r\n\t                var pos = calcTooltipPosition(\r\n\t                    positionExpr, rect, contentSize\r\n\t                );\r\n\t                x = pos[0];\r\n\t                y = pos[1];\r\n\t            }\r\n\t            else {\r\n\t                var pos1 = refixTooltipPosition(\r\n\t                    x, y, content.el, viewWidth, viewHeight, align ? 0 : 20, vAlign ? 0 : 20\r\n\t                );\r\n\t                x = pos1[0];\r\n\t                y = pos1[1];\r\n\t            }\r\n\t\r\n\t            align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\r\n\t            vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\r\n\t\r\n\t            if (tooltipModel.get('confine')) {\r\n\t                var pos2 = confineTooltipPosition(\r\n\t                    x, y, content.el, viewWidth, viewHeight\r\n\t                );\r\n\t                x = pos2[0];\r\n\t                y = pos2[1];\r\n\t            }\r\n\t\r\n\t            content.moveTo(x, y);\r\n\t        }\r\n\t\r\n\t    function calcTooltipPosition(position, rect, contentSize) {\r\n\t        var domWidth = contentSize[0];\r\n\t        var domHeight = contentSize[1];\r\n\t        var gap = 5;\r\n\t        var x = 0;\r\n\t        var y = 0;\r\n\t        var rectWidth = rect.width;\r\n\t        var rectHeight = rect.height;\r\n\t        switch (position) {\r\n\t            case 'inside':\r\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\r\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\r\n\t                break;\r\n\t            case 'top':\r\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\r\n\t                y = rect.y - domHeight - gap;\r\n\t                break;\r\n\t            case 'bottom':\r\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\r\n\t                y = rect.y + rectHeight + gap;\r\n\t                break;\r\n\t            case 'left':\r\n\t                x = rect.x - domWidth - gap;\r\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\r\n\t                break;\r\n\t            case 'right':\r\n\t                x = rect.x + rectWidth + gap;\r\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\r\n\t        }\r\n\t        return [x, y];\r\n\t    }\r\n\t    function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\r\n\t        var width = el.clientWidth;\r\n\t        var height = el.clientHeight;\r\n\t\r\n\t        if (x + width + gapH > viewWidth) {\r\n\t            x -= width + gapH;\r\n\t        }\r\n\t        else {\r\n\t            x += gapH;\r\n\t        }\r\n\t        if (y + height + gapV > viewHeight) {\r\n\t            y -= height + gapV;\r\n\t        }\r\n\t        else {\r\n\t            y += gapV;\r\n\t        }\r\n\t        return [x, y];\r\n\t    }\r\n\t\r\n\t    function isCenterAlign(align) {\r\n\t        return align === 'center' || align === 'middle';\r\n\t    }\r\n\t\r\n\t    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\r\n\t        var width = el.clientWidth;\r\n\t        var height = el.clientHeight;\r\n\t\r\n\t        x = Math.min(x + width, viewWidth) - width;\r\n\t        y = Math.min(y + height, viewHeight) - height;\r\n\t        x = Math.max(x, 0);\r\n\t        y = Math.max(y, 0);\r\n\t\r\n\t        return [x, y];\r\n\t    }\r\n\t    module.exports = TooltipView;\r\n\n\n/***/ }),\n/* 133 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var zrColor = __webpack_require__(20);\r\n\t    var env = __webpack_require__(50);\r\n\t    var eventUtil = __webpack_require__(74);\r\n\t    var flowUtil = __webpack_require__(94);\r\n\t    var toCamelCase = flowUtil.toCamelCase;\r\n\t    var normalizeCssArray = flowUtil.normalizeCssArray;\r\n\t    var each = zrUtil.each;\r\n\t\r\n\t\r\n\t    var vendors = ['', '-webkit-', '-moz-', '-o-'];\r\n\t\r\n\t    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:999;';//fish popup zindex:1050\r\n\t    /**\r\n\t     * @param {number} duration\r\n\t     * @return {string}\r\n\t     * @inner\r\n\t     */\r\n\t    function assembleTransition(duration) {\r\n\t        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\r\n\t        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\r\n\t                            + 'top ' + duration + 's ' + transitionCurve;\r\n\t        return zrUtil.map(vendors, function (vendorPrefix) {\r\n\t            return vendorPrefix + 'transition:' + transitionText;\r\n\t        }).join(';');\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @param {Object} textStyle\r\n\t     * @return {string}\r\n\t     * @inner\r\n\t     */\r\n\t    function assembleFont(textStyleModel) {\r\n\t        var cssText = [];\r\n\t\r\n\t        var fontSize = textStyleModel.get('fontSize');\r\n\t        var color = textStyleModel.get(\"color\");\r\n\t\r\n\t        color && cssText.push('color:' + color);\r\n\t\r\n\t        var font = textStyleModel.get(\"font\");\r\n\t        font && cssText.push('font:' + font);\r\n\t\r\n\t        fontSize &&\r\n\t            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\r\n\t\r\n\t        each(['decoration', 'align'], function (name) {\r\n\t            var val = textStyleModel.get(name);\r\n\t            val && cssText.push('text-' + name + ':' + val);\r\n\t        });\r\n\t\r\n\t        return cssText.join(';');\r\n\t    }\r\n\t    /**\r\n\t     * @param {Object} tooltipModel\r\n\t     * @return {string}\r\n\t     * @inner\r\n\t     */\r\n\t    function assembleCssText(tooltipModel) {\r\n\t\r\n\t        var cssText = [];\r\n\t\r\n\t        var transitionDuration = tooltipModel.get('transitionDuration');\r\n\t        var backgroundColor = tooltipModel.get('backgroundColor');\r\n\t        var textStyleModel = tooltipModel.getModel('textStyle');\r\n\t        var padding = tooltipModel.get('padding');\r\n\t\r\n\t        // Animation transition. Do not animate when transitionDuration is 0.\r\n\t        transitionDuration &&\r\n\t            cssText.push(assembleTransition(transitionDuration));\r\n\t\r\n\t        if (backgroundColor) {\r\n\t            if (env.canvasSupported) {\r\n\t                cssText.push('background-Color:' + backgroundColor);\r\n\t            }\r\n\t            else {\r\n\t                // for ie\r\n\t                cssText.push(\r\n\t                    'background-Color:#' + zrColor.toHex(backgroundColor)\r\n\t                );\r\n\t                cssText.push('filter:alpha(opacity=70)');\r\n\t            }\r\n\t        }\r\n\t\r\n\t        // Border style\r\n\t        each(['width', 'color', 'radius'], function (name) {\r\n\t            var borderName = 'border-' + name;\r\n\t            var camelCase = toCamelCase(borderName);\r\n\t            var val = tooltipModel.get(camelCase);\r\n\t            val != null &&\r\n\t                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\r\n\t        });\r\n\t\r\n\t        // Text style\r\n\t        cssText.push(assembleFont(textStyleModel));\r\n\t\r\n\t        // Padding\r\n\t        if (padding != null) {\r\n\t            cssText.push('padding:' + normalizeCssArray(padding).join('px ') + 'px');\r\n\t        }\r\n\t\r\n\t        return cssText.join(';') + ';';\r\n\t    }\r\n\t    /**\r\n\t     *\r\n\t     *\r\n\t     * @param {any} container\r\n\t     * @param {any} api\r\n\t     */\r\n\t    function TooltipContent(container, api) {\r\n\t        var el = document.createElement('div');\r\n\t        var zr = this._zr = api.getZr();\r\n\t\r\n\t        this.el = el;\r\n\t\r\n\t        this._x = api.getWidth() / 2;\r\n\t        this._y = api.getHeight() / 2;\r\n\t\r\n\t        container.appendChild(el);\r\n\t\r\n\t        this._container = container;\r\n\t\r\n\t        this._show = false;\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        this._hideTimeout;\r\n\t\r\n\t        var self = this;\r\n\t        el.onmouseenter = function () {\r\n\t            // clear the timeout in hideLater and keep showing tooltip\r\n\t            if (self._enterable) {\r\n\t                clearTimeout(self._hideTimeout);\r\n\t                self._show = true;\r\n\t            }\r\n\t            self._inContent = true;\r\n\t        };\r\n\t        el.onmousemove = function (e) {\r\n\t            e = e || window.event;\r\n\t            if (!self._enterable) {\r\n\t                // Try trigger zrender event to avoid mouse\r\n\t                // in and out shape too frequently\r\n\t                var handler = zr.handler;\r\n\t                eventUtil.normalizeEvent(container, e, true);\r\n\t                handler.dispatch('mousemove', e);\r\n\t            }\r\n\t        };\r\n\t        el.onmouseleave = function () {\r\n\t            if (self._enterable) {\r\n\t                if (self._show) {\r\n\t                    self.hideLater(self._hideDelay);\r\n\t                }\r\n\t            }\r\n\t            self._inContent = false;\r\n\t        };\r\n\t    }\r\n\t    TooltipContent.prototype = {\r\n\t\r\n\t        constructor: TooltipContent,\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         * @type {boolean}\r\n\t         */\r\n\t        _enterable: true,\r\n\t\r\n\t        /**\r\n\t         * Update when tooltip is rendered\r\n\t         */\r\n\t        update: function () {\r\n\t            // FIXME\r\n\t            // Move this logic to ec main?\r\n\t            var container = this._container;\r\n\t            var stl = container.currentStyle\r\n\t                || document.defaultView.getComputedStyle(container);\r\n\t            var domStyle = container.style;\r\n\t            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\r\n\t                domStyle.position = 'relative';\r\n\t            }\r\n\t            // Hide the tooltip\r\n\t            // PENDING\r\n\t            // this.hide();\r\n\t        },\r\n\t\r\n\t        show: function (tooltipModel) {\r\n\t            clearTimeout(this._hideTimeout);\r\n\t            var el = this.el;\r\n\t\r\n\t            el.style.cssText = gCssText + assembleCssText(tooltipModel)\r\n\t                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\r\n\t                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\r\n\t                + (tooltipModel.get('extraCssText') || '');\r\n\t\r\n\t            el.style.display = el.innerHTML ?  'block' : 'none';\r\n\t\r\n\t            this._show = true;\r\n\t        },\r\n\t\r\n\t        setContent: function (content) {\r\n\t            this.el.innerHTML = content;\r\n\t        },\r\n\t\r\n\t        setEnterable: function (enterable) {\r\n\t            this._enterable = enterable;\r\n\t        },\r\n\t\r\n\t        getSize: function () {\r\n\t            var el = this.el;\r\n\t            return [el.clientWidth, el.clientHeight];\r\n\t        },\r\n\t\r\n\t        moveTo: function (x, y) {\r\n\t            // xy should be based on canvas root. But tooltipContent is\r\n\t            // the sibling of canvas root. So padding of ec container\r\n\t            // should be considered here.\r\n\t            var zr = this._zr;\r\n\t            var viewportRoot;\r\n\t            if (zr && zr.painter && (viewportRoot = zr.painter.getViewportRoot())) {\r\n\t                x += viewportRoot.offsetLeft || 0;\r\n\t                y += viewportRoot.offsetTop || 0;\r\n\t            }\r\n\t\r\n\t            var style = this.el.style;\r\n\t            style.left = x + 'px';\r\n\t            style.top = y + 'px';\r\n\t\r\n\t            this._x = x;\r\n\t            this._y = y;\r\n\t        },\r\n\t\r\n\t        hide: function () {\r\n\t            this.el.style.display = 'none';\r\n\t            this._show = false;\r\n\t        },\r\n\t\r\n\t        hideLater: function (time) {\r\n\t            if (this._show && !(this._inContent && this._enterable)) {\r\n\t                if (time) {\r\n\t                    this._hideDelay = time;\r\n\t                    // Set show false to avoid invoke hideLater mutiple times\r\n\t                    this._show = false;\r\n\t                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\r\n\t                }\r\n\t                else {\r\n\t                    this.hide();\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t        isShow: function () {\r\n\t            return this._show;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = TooltipContent;\r\n\n\n/***/ }),\n/* 134 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t\r\n\t    var env = __webpack_require__(50);\r\n\t    var zrUtil = __webpack_require__(5);\r\n\t    var get = __webpack_require__(94).makeGetter();\r\n\t\r\n\t    var each = zrUtil.each;\r\n\t\r\n\t    var globalListener = {};\r\n\t\r\n\t    /**\r\n\t     * @param key 注册的字符串\r\n\t     * @param api ExtensionAPI\r\n\t     * @param handler 处理回调\r\n\t     */\r\n\t    globalListener.register = function (key, api, handler) {\r\n\t        if (env.node) {   //node环境下不执行\r\n\t            return;\r\n\t        }\r\n\t        //判断zrender的 records  并初始化\r\n\t        var zr = api.getZr();\r\n\t        get(zr).records || (get(zr).records = {});\r\n\t\r\n\t        initGlobalListeners(zr, api);\r\n\t\r\n\t        //将回调加入record\r\n\t        var record = get(zr).records[key] || (get(zr).records[key] = {});\r\n\t        record.handler = handler;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 初始化全局侦听\r\n\t     *\r\n\t     * @param {object} zr   zrender\r\n\t     * @param {object} api  ExtensionAPI\r\n\t     * @returns\r\n\t     */\r\n\t    function initGlobalListeners(zr, api) {\r\n\t        if (get(zr).initialized) {   //避免重复初始化\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        get(zr).initialized = true;\r\n\t\r\n\t        //侦听事件\r\n\t        useHandler('click', zrUtil.curry(doEnter, 'click'));\r\n\t        useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove'));\r\n\t        // useHandler('mouseout', onLeave);\r\n\t        useHandler('globalout', onLeave);\r\n\t\r\n\t        function useHandler(eventType, cb) {\r\n\t            zr.on(eventType, function (e) {\r\n\t                var dis = makeDispatchAction(api);\r\n\t                //遍历注册的 所有records， 并进行调用\r\n\t                each(get(zr).records, function (record) {\r\n\t                    record && cb(record, e, dis.dispatchAction);\r\n\t                });\r\n\t\r\n\t                dispatchTooltipFinally(dis.pendings, api);\r\n\t            });\r\n\t        }\r\n\t    }\r\n\t\r\n\t    function dispatchTooltipFinally(pendings, api) {\r\n\t        var showLen = pendings.showTip.length;\r\n\t        var hideLen = pendings.hideTip.length;\r\n\t\r\n\t        var actuallyPayload;\r\n\t        if (showLen) {\r\n\t            actuallyPayload = pendings.showTip[showLen - 1];\r\n\t        }\r\n\t        else if (hideLen) {\r\n\t            actuallyPayload = pendings.hideTip[hideLen - 1];\r\n\t        }\r\n\t        if (actuallyPayload) {\r\n\t            actuallyPayload.dispatchAction = null;\r\n\t            api.dispatchAction(actuallyPayload);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    function onLeave(record, e, dispatchAction) {\r\n\t        record.handler('leave', null, dispatchAction);\r\n\t    }\r\n\t\r\n\t    function doEnter(currTrigger, record, e, dispatchAction) {\r\n\t        record.handler(currTrigger, e, dispatchAction);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 派发action   行将发生的\r\n\t     *\r\n\t     * @param {any} api\r\n\t     * @returns\r\n\t     */\r\n\t    function makeDispatchAction(api) {\r\n\t        var pendings = {\r\n\t            showTip: [],\r\n\t            hideTip: []\r\n\t        };\r\n\t        // FIXME\r\n\t        // better approach?\r\n\t        // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\r\n\t        // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\r\n\t        // So we have to add \"final stage\" to merge those dispatched actions.\r\n\t        var dispatchAction = function (payload) {\r\n\t            var pendingList = pendings[payload.type];\r\n\t            if (pendingList) {\r\n\t                pendingList.push(payload);\r\n\t            }\r\n\t            else {\r\n\t                payload.dispatchAction = dispatchAction;\r\n\t                api.dispatchAction(payload);\r\n\t            }\r\n\t        };\r\n\t\r\n\t        return {\r\n\t            dispatchAction: dispatchAction,\r\n\t            pendings: pendings\r\n\t        };\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @param {string} key\r\n\t     * @param {module:echarts/ExtensionAPI} api\r\n\t     */\r\n\t    globalListener.unregister = function (key, api) {\r\n\t        if (env.node) {\r\n\t            return;\r\n\t        }\r\n\t        var zr = api.getZr();\r\n\t        var record = (get(zr).records || {})[key];\r\n\t        if (record) {\r\n\t            get(zr).records[key] = null;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = globalListener;\r\n\n\n/***/ }),\n/* 135 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t\r\n\t    var Model = __webpack_require__(87);\r\n\t    module.exports = Model.extend({\r\n\t\r\n\t        type: 'tooltip',\r\n\t\r\n\t        defaultOption: {\r\n\t            zlevel: 0,\r\n\t\r\n\t            z: 8,\r\n\t\r\n\t            show: true,\r\n\t\r\n\t            // tooltip主体内容\r\n\t            showContent: true,\r\n\t\r\n\t\r\n\t\r\n\t            // 'click' | 'mousemove' | 'none'\r\n\t            triggerOn: 'mousemove',\r\n\t\r\n\t            alwaysShowContent: false,\r\n\t\r\n\t            displayMode: 'single', // 'single' | 'multipleByCoordSys'\r\n\t\r\n\t            // 位置 {Array} | {Function}\r\n\t            // position: null\r\n\t            // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\r\n\t            // align: null,\r\n\t            // verticalAlign: null,\r\n\t\r\n\t            // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。\r\n\t            confine: false,\r\n\t\r\n\t            // 内容格式器：{string}（Template） ¦ {Function}\r\n\t            // formatter: null\r\n\t\r\n\t            showDelay: 0,\r\n\t\r\n\t            // 隐藏延迟，单位ms\r\n\t            hideDelay: 100,\r\n\t\r\n\t            // 动画变换时间，单位s\r\n\t            transitionDuration: 0.4,\r\n\t\r\n\t            enterable: false,\r\n\t\r\n\t            // 提示背景颜色，默认为透明度为0.7的黑色\r\n\t            backgroundColor: 'rgba(50,50,50,0.7)',\r\n\t\r\n\t            // 提示边框颜色\r\n\t            borderColor: '#333',\r\n\t\r\n\t            // 提示边框圆角，单位px，默认为4\r\n\t            borderRadius: 4,\r\n\t\r\n\t            // 提示边框线宽，单位px，默认为0（无边框）\r\n\t            borderWidth: 0,\r\n\t\r\n\t            // 提示内边距，单位px，默认各方向内边距为5，\r\n\t            // 接受数组分别设定上右下左边距，同css\r\n\t            padding: 5,\r\n\t\r\n\t            // Extra css text\r\n\t            extraCssText: '',\r\n\t\r\n\t            textStyle: {\r\n\t                color: '#fff',\r\n\t                fontSize: 14\r\n\t            }\r\n\t        }\r\n\t    });\r\n\n\n/***/ }),\n/* 136 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t    __webpack_require__(137);\n\t    __webpack_require__(69).registerPainter('vml', __webpack_require__(139));\n\n\n/***/ }),\n/* 137 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// http://www.w3.org/TR/NOTE-VML\n\t// TODO Use proxy like svg instead of overwrite brush methods\n\t\n\t\n\tif (!__webpack_require__(50).canvasSupported) {\n\t    var vec2 = __webpack_require__(15);\n\t    var BoundingRect = __webpack_require__(27);\n\t    var CMD = __webpack_require__(30).CMD;\n\t    var colorTool = __webpack_require__(20);\n\t    var textContain = __webpack_require__(26);\n\t    var textHelper = __webpack_require__(25);\n\t    var RectText = __webpack_require__(24);\n\t    var Displayable = __webpack_require__(8);\n\t    var ZImage = __webpack_require__(45);\n\t    var Text = __webpack_require__(46);\n\t    var Path = __webpack_require__(7);\n\t    var PathProxy = __webpack_require__(30);\n\t\n\t    var Gradient = __webpack_require__(42);\n\t\n\t    var vmlCore = __webpack_require__(138);\n\t\n\t    var round = Math.round;\n\t    var sqrt = Math.sqrt;\n\t    var abs = Math.abs;\n\t    var cos = Math.cos;\n\t    var sin = Math.sin;\n\t    var mathMax = Math.max;\n\t\n\t    var applyTransform = vec2.applyTransform;\n\t\n\t    var comma = ',';\n\t    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\t\n\t    var Z = 21600;\n\t    var Z2 = Z / 2;\n\t\n\t    var ZLEVEL_BASE = 100000;\n\t    var Z_BASE = 1000;\n\t\n\t    var initRootElStyle = function (el) {\n\t        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n\t        el.coordsize = Z + ','  + Z;\n\t        el.coordorigin = '0,0';\n\t    };\n\t\n\t    var encodeHtmlAttribute = function (s) {\n\t        return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n\t    };\n\t\n\t    var rgb2Str = function (r, g, b) {\n\t        return 'rgb(' + [r, g, b].join(',') + ')';\n\t    };\n\t\n\t    var append = function (parent, child) {\n\t        if (child && parent && child.parentNode !== parent) {\n\t            parent.appendChild(child);\n\t        }\n\t    };\n\t\n\t    var remove = function (parent, child) {\n\t        if (child && parent && child.parentNode === parent) {\n\t            parent.removeChild(child);\n\t        }\n\t    };\n\t\n\t    var getZIndex = function (zlevel, z, z2) {\n\t        // z 的取值范围为 [0, 1000]\n\t        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n\t    };\n\t\n\t    var parsePercent = function (value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    };\n\t\n\t    /***************************************************\n\t     * PATH\n\t     **************************************************/\n\t\n\t    var setColorAndOpacity = function (el, color, opacity) {\n\t        var colorArr = colorTool.parse(color);\n\t        opacity = +opacity;\n\t        if (isNaN(opacity)) {\n\t            opacity = 1;\n\t        }\n\t        if (colorArr) {\n\t            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n\t            el.opacity = opacity * colorArr[3];\n\t        }\n\t    };\n\t\n\t    var getColorAndAlpha = function (color) {\n\t        var colorArr = colorTool.parse(color);\n\t        return [\n\t            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),\n\t            colorArr[3]\n\t        ];\n\t    };\n\t\n\t    var updateFillNode = function (el, style, zrEl) {\n\t        // TODO pattern\n\t        var fill = style.fill;\n\t        if (fill != null) {\n\t            // Modified from excanvas\n\t            if (fill instanceof Gradient) {\n\t                var gradientType;\n\t                var angle = 0;\n\t                var focus = [0, 0];\n\t                // additional offset\n\t                var shift = 0;\n\t                // scale factor for offset\n\t                var expansion = 1;\n\t                var rect = zrEl.getBoundingRect();\n\t                var rectWidth = rect.width;\n\t                var rectHeight = rect.height;\n\t                if (fill.type === 'linear') {\n\t                    gradientType = 'gradient';\n\t                    var transform = zrEl.transform;\n\t                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\t                    if (transform) {\n\t                        applyTransform(p0, p0, transform);\n\t                        applyTransform(p1, p1, transform);\n\t                    }\n\t                    var dx = p1[0] - p0[0];\n\t                    var dy = p1[1] - p0[1];\n\t                    angle = Math.atan2(dx, dy) * 180 / Math.PI;\n\t                    // The angle should be a non-negative number.\n\t                    if (angle < 0) {\n\t                        angle += 360;\n\t                    }\n\t\n\t                    // Very small angles produce an unexpected result because they are\n\t                    // converted to a scientific notation string.\n\t                    if (angle < 1e-6) {\n\t                        angle = 0;\n\t                    }\n\t                }\n\t                else {\n\t                    gradientType = 'gradientradial';\n\t                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t                    var transform = zrEl.transform;\n\t                    var scale = zrEl.scale;\n\t                    var width = rectWidth;\n\t                    var height = rectHeight;\n\t                    focus = [\n\t                        // Percent in bounding rect\n\t                        (p0[0] - rect.x) / width,\n\t                        (p0[1] - rect.y) / height\n\t                    ];\n\t                    if (transform) {\n\t                        applyTransform(p0, p0, transform);\n\t                    }\n\t\n\t                    width /= scale[0] * Z;\n\t                    height /= scale[1] * Z;\n\t                    var dimension = mathMax(width, height);\n\t                    shift = 2 * 0 / dimension;\n\t                    expansion = 2 * fill.r / dimension - shift;\n\t                }\n\t\n\t                // We need to sort the color stops in ascending order by offset,\n\t                // otherwise IE won't interpret it correctly.\n\t                var stops = fill.colorStops.slice();\n\t                stops.sort(function(cs1, cs2) {\n\t                    return cs1.offset - cs2.offset;\n\t                });\n\t\n\t                var length = stops.length;\n\t                // Color and alpha list of first and last stop\n\t                var colorAndAlphaList = [];\n\t                var colors = [];\n\t                for (var i = 0; i < length; i++) {\n\t                    var stop = stops[i];\n\t                    var colorAndAlpha = getColorAndAlpha(stop.color);\n\t                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\t                    if (i === 0 || i === length - 1) {\n\t                        colorAndAlphaList.push(colorAndAlpha);\n\t                    }\n\t                }\n\t\n\t                if (length >= 2) {\n\t                    var color1 = colorAndAlphaList[0][0];\n\t                    var color2 = colorAndAlphaList[1][0];\n\t                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n\t                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\t\n\t                    el.type = gradientType;\n\t                    el.method = 'none';\n\t                    el.focus = '100%';\n\t                    el.angle = angle;\n\t                    el.color = color1;\n\t                    el.color2 = color2;\n\t                    el.colors = colors.join(',');\n\t                    // When colors attribute is used, the meanings of opacity and o:opacity2\n\t                    // are reversed.\n\t                    el.opacity = opacity2;\n\t                    // FIXME g_o_:opacity ?\n\t                    el.opacity2 = opacity1;\n\t                }\n\t                if (gradientType === 'radial') {\n\t                    el.focusposition = focus.join(',');\n\t                }\n\t            }\n\t            else {\n\t                // FIXME Change from Gradient fill to color fill\n\t                setColorAndOpacity(el, fill, style.opacity);\n\t            }\n\t        }\n\t    };\n\t\n\t    var updateStrokeNode = function (el, style) {\n\t        // if (style.lineJoin != null) {\n\t        //     el.joinstyle = style.lineJoin;\n\t        // }\n\t        // if (style.miterLimit != null) {\n\t        //     el.miterlimit = style.miterLimit * Z;\n\t        // }\n\t        // if (style.lineCap != null) {\n\t        //     el.endcap = style.lineCap;\n\t        // }\n\t        if (style.lineDash != null) {\n\t            el.dashstyle = style.lineDash.join(' ');\n\t        }\n\t        if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n\t            setColorAndOpacity(el, style.stroke, style.opacity);\n\t        }\n\t    };\n\t\n\t    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n\t        var isFill = type == 'fill';\n\t        var el = vmlEl.getElementsByTagName(type)[0];\n\t        // Stroke must have lineWidth\n\t        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {\n\t            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';\n\t            // FIXME Remove before updating, or set `colors` will throw error\n\t            if (style[type] instanceof Gradient) {\n\t                remove(vmlEl, el);\n\t            }\n\t            if (!el) {\n\t                el = vmlCore.createNode(type);\n\t            }\n\t\n\t            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n\t            append(vmlEl, el);\n\t        }\n\t        else {\n\t            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n\t            remove(vmlEl, el);\n\t        }\n\t    };\n\t\n\t    var points = [[], [], []];\n\t    var pathDataToString = function (data, m) {\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t\n\t        var str = [];\n\t        var nPoint;\n\t        var cmdStr;\n\t        var cmd;\n\t        var i;\n\t        var xi;\n\t        var yi;\n\t        for (i = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            cmdStr = '';\n\t            nPoint = 0;\n\t            switch (cmd) {\n\t                case M:\n\t                    cmdStr = ' m ';\n\t                    nPoint = 1;\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    points[0][0] = xi;\n\t                    points[0][1] = yi;\n\t                    break;\n\t                case L:\n\t                    cmdStr = ' l ';\n\t                    nPoint = 1;\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    points[0][0] = xi;\n\t                    points[0][1] = yi;\n\t                    break;\n\t                case Q:\n\t                case C:\n\t                    cmdStr = ' c ';\n\t                    nPoint = 3;\n\t                    var x1 = data[i++];\n\t                    var y1 = data[i++];\n\t                    var x2 = data[i++];\n\t                    var y2 = data[i++];\n\t                    var x3;\n\t                    var y3;\n\t                    if (cmd === Q) {\n\t                        // Convert quadratic to cubic using degree elevation\n\t                        x3 = x2;\n\t                        y3 = y2;\n\t                        x2 = (x2 + 2 * x1) / 3;\n\t                        y2 = (y2 + 2 * y1) / 3;\n\t                        x1 = (xi + 2 * x1) / 3;\n\t                        y1 = (yi + 2 * y1) / 3;\n\t                    }\n\t                    else {\n\t                        x3 = data[i++];\n\t                        y3 = data[i++];\n\t                    }\n\t                    points[0][0] = x1;\n\t                    points[0][1] = y1;\n\t                    points[1][0] = x2;\n\t                    points[1][1] = y2;\n\t                    points[2][0] = x3;\n\t                    points[2][1] = y3;\n\t\n\t                    xi = x3;\n\t                    yi = y3;\n\t                    break;\n\t                case A:\n\t                    var x = 0;\n\t                    var y = 0;\n\t                    var sx = 1;\n\t                    var sy = 1;\n\t                    var angle = 0;\n\t                    if (m) {\n\t                        // Extract SRT from matrix\n\t                        x = m[4];\n\t                        y = m[5];\n\t                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t                        angle = Math.atan2(-m[1] / sy, m[0] / sx);\n\t                    }\n\t\n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var startAngle = data[i++] + angle;\n\t                    var endAngle = data[i++] + startAngle + angle;\n\t                    // FIXME\n\t                    // var psi = data[i++];\n\t                    i++;\n\t                    var clockwise = data[i++];\n\t\n\t                    var x0 = cx + cos(startAngle) * rx;\n\t                    var y0 = cy + sin(startAngle) * ry;\n\t\n\t                    var x1 = cx + cos(endAngle) * rx;\n\t                    var y1 = cy + sin(endAngle) * ry;\n\t\n\t                    var type = clockwise ? ' wa ' : ' at ';\n\t                    if (Math.abs(x0 - x1) < 1e-4) {\n\t                        // IE won't render arches drawn counter clockwise if x0 == x1.\n\t                        if (Math.abs(endAngle - startAngle) > 1e-2) {\n\t                            // Offset x0 by 1/80 of a pixel. Use something\n\t                            // that can be represented in binary\n\t                            if (clockwise) {\n\t                                x0 += 270 / Z;\n\t                            }\n\t                        }\n\t                        else {\n\t                            // Avoid case draw full circle\n\t                            if (Math.abs(y0 - cy) < 1e-4) {\n\t                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {\n\t                                    y1 -= 270 / Z;\n\t                                }\n\t                                else {\n\t                                    y1 += 270 / Z;\n\t                                }\n\t                            }\n\t                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {\n\t                                x1 += 270 / Z;\n\t                            }\n\t                            else {\n\t                                x1 -= 270 / Z;\n\t                            }\n\t                        }\n\t                    }\n\t                    str.push(\n\t                        type,\n\t                        round(((cx - rx) * sx + x) * Z - Z2), comma,\n\t                        round(((cy - ry) * sy + y) * Z - Z2), comma,\n\t                        round(((cx + rx) * sx + x) * Z - Z2), comma,\n\t                        round(((cy + ry) * sy + y) * Z - Z2), comma,\n\t                        round((x0 * sx + x) * Z - Z2), comma,\n\t                        round((y0 * sy + y) * Z - Z2), comma,\n\t                        round((x1 * sx + x) * Z - Z2), comma,\n\t                        round((y1 * sy + y) * Z - Z2)\n\t                    );\n\t\n\t                    xi = x1;\n\t                    yi = y1;\n\t                    break;\n\t                case CMD.R:\n\t                    var p0 = points[0];\n\t                    var p1 = points[1];\n\t                    // x0, y0\n\t                    p0[0] = data[i++];\n\t                    p0[1] = data[i++];\n\t                    // x1, y1\n\t                    p1[0] = p0[0] + data[i++];\n\t                    p1[1] = p0[1] + data[i++];\n\t\n\t                    if (m) {\n\t                        applyTransform(p0, p0, m);\n\t                        applyTransform(p1, p1, m);\n\t                    }\n\t\n\t                    p0[0] = round(p0[0] * Z - Z2);\n\t                    p1[0] = round(p1[0] * Z - Z2);\n\t                    p0[1] = round(p0[1] * Z - Z2);\n\t                    p1[1] = round(p1[1] * Z - Z2);\n\t                    str.push(\n\t                        // x0, y0\n\t                        ' m ', p0[0], comma, p0[1],\n\t                        // x1, y0\n\t                        ' l ', p1[0], comma, p0[1],\n\t                        // x1, y1\n\t                        ' l ', p1[0], comma, p1[1],\n\t                        // x0, y1\n\t                        ' l ', p0[0], comma, p1[1]\n\t                    );\n\t                    break;\n\t                case CMD.Z:\n\t                    // FIXME Update xi, yi\n\t                    str.push(' x ');\n\t            }\n\t\n\t            if (nPoint > 0) {\n\t                str.push(cmdStr);\n\t                for (var k = 0; k < nPoint; k++) {\n\t                    var p = points[k];\n\t\n\t                    m && applyTransform(p, p, m);\n\t                    // 不 round 会非常慢\n\t                    str.push(\n\t                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),\n\t                        k < nPoint - 1 ? comma : ''\n\t                    );\n\t                }\n\t            }\n\t        }\n\t\n\t        return str.join('');\n\t    };\n\t\n\t    // Rewrite the original path method\n\t    Path.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t\n\t        var vmlEl = this._vmlEl;\n\t        if (!vmlEl) {\n\t            vmlEl = vmlCore.createNode('shape');\n\t            initRootElStyle(vmlEl);\n\t\n\t            this._vmlEl = vmlEl;\n\t        }\n\t\n\t        updateFillAndStroke(vmlEl, 'fill', style, this);\n\t        updateFillAndStroke(vmlEl, 'stroke', style, this);\n\t\n\t        var m = this.transform;\n\t        var needTransform = m != null;\n\t        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\t        if (strokeEl) {\n\t            var lineWidth = style.lineWidth;\n\t            // Get the line scale.\n\t            // Determinant of this.m_ means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            if (needTransform && !style.strokeNoScale) {\n\t                var det = m[0] * m[3] - m[1] * m[2];\n\t                lineWidth *= sqrt(abs(det));\n\t            }\n\t            strokeEl.weight = lineWidth + 'px';\n\t        }\n\t\n\t        var path = this.path || (this.path = new PathProxy());\n\t        if (this.__dirtyPath) {\n\t            path.beginPath();\n\t            this.buildPath(path, this.shape);\n\t            path.toStatic();\n\t            this.__dirtyPath = false;\n\t        }\n\t\n\t        vmlEl.path = pathDataToString(path.data, this.transform);\n\t\n\t        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Append to root\n\t        append(vmlRoot, vmlEl);\n\t\n\t        // Text\n\t        if (style.text != null) {\n\t            this.drawRectText(vmlRoot, this.getBoundingRect());\n\t        }\n\t        else {\n\t            this.removeRectText(vmlRoot);\n\t        }\n\t    };\n\t\n\t    Path.prototype.onRemove = function (vmlRoot) {\n\t        remove(vmlRoot, this._vmlEl);\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    Path.prototype.onAdd = function (vmlRoot) {\n\t        append(vmlRoot, this._vmlEl);\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t\n\t    /***************************************************\n\t     * IMAGE\n\t     **************************************************/\n\t    var isImage = function (img) {\n\t        // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n\t        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';\n\t        // return img instanceof Image;\n\t    };\n\t\n\t    // Rewrite the original path method\n\t    ZImage.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t        var image = style.image;\n\t\n\t        // Image original width, height\n\t        var ow;\n\t        var oh;\n\t\n\t        if (isImage(image)) {\n\t            var src = image.src;\n\t            if (src === this._imageSrc) {\n\t                ow = this._imageWidth;\n\t                oh = this._imageHeight;\n\t            }\n\t            else {\n\t                var imageRuntimeStyle = image.runtimeStyle;\n\t                var oldRuntimeWidth = imageRuntimeStyle.width;\n\t                var oldRuntimeHeight = imageRuntimeStyle.height;\n\t                imageRuntimeStyle.width = 'auto';\n\t                imageRuntimeStyle.height = 'auto';\n\t\n\t                // get the original size\n\t                ow = image.width;\n\t                oh = image.height;\n\t\n\t                // and remove overides\n\t                imageRuntimeStyle.width = oldRuntimeWidth;\n\t                imageRuntimeStyle.height = oldRuntimeHeight;\n\t\n\t                // Caching image original width, height and src\n\t                this._imageSrc = src;\n\t                this._imageWidth = ow;\n\t                this._imageHeight = oh;\n\t            }\n\t            image = src;\n\t        }\n\t        else {\n\t            if (image === this._imageSrc) {\n\t                ow = this._imageWidth;\n\t                oh = this._imageHeight;\n\t            }\n\t        }\n\t        if (!image) {\n\t            return;\n\t        }\n\t\n\t        var x = style.x || 0;\n\t        var y = style.y || 0;\n\t\n\t        var dw = style.width;\n\t        var dh = style.height;\n\t\n\t        var sw = style.sWidth;\n\t        var sh = style.sHeight;\n\t        var sx = style.sx || 0;\n\t        var sy = style.sy || 0;\n\t\n\t        var hasCrop = sw && sh;\n\t\n\t        var vmlEl = this._vmlEl;\n\t        if (!vmlEl) {\n\t            // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n\t            // vmlEl = vmlCore.createNode('group');\n\t            vmlEl = vmlCore.doc.createElement('div');\n\t            initRootElStyle(vmlEl);\n\t\n\t            this._vmlEl = vmlEl;\n\t        }\n\t\n\t        var vmlElStyle = vmlEl.style;\n\t        var hasRotation = false;\n\t        var m;\n\t        var scaleX = 1;\n\t        var scaleY = 1;\n\t        if (this.transform) {\n\t            m = this.transform;\n\t            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t\n\t            hasRotation = m[1] || m[2];\n\t        }\n\t        if (hasRotation) {\n\t            // If filters are necessary (rotation exists), create them\n\t            // filters are bog-slow, so only create them if abbsolutely necessary\n\t            // The following check doesn't account for skews (which don't exist\n\t            // in the canvas spec (yet) anyway.\n\t            // From excanvas\n\t            var p0 = [x, y];\n\t            var p1 = [x + dw, y];\n\t            var p2 = [x, y + dh];\n\t            var p3 = [x + dw, y + dh];\n\t            applyTransform(p0, p0, m);\n\t            applyTransform(p1, p1, m);\n\t            applyTransform(p2, p2, m);\n\t            applyTransform(p3, p3, m);\n\t\n\t            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n\t            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\t\n\t            var transformFilter = [];\n\t            transformFilter.push('M11=', m[0] / scaleX, comma,\n\t                        'M12=', m[2] / scaleY, comma,\n\t                        'M21=', m[1] / scaleX, comma,\n\t                        'M22=', m[3] / scaleY, comma,\n\t                        'Dx=', round(x * scaleX + m[4]), comma,\n\t                        'Dy=', round(y * scaleY + m[5]));\n\t\n\t            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';\n\t            // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n\t            vmlElStyle.filter = imageTransformPrefix + '.Matrix('\n\t                + transformFilter.join('') + ', SizingMethod=clip)';\n\t\n\t        }\n\t        else {\n\t            if (m) {\n\t                x = x * scaleX + m[4];\n\t                y = y * scaleY + m[5];\n\t            }\n\t            vmlElStyle.filter = '';\n\t            vmlElStyle.left = round(x) + 'px';\n\t            vmlElStyle.top = round(y) + 'px';\n\t        }\n\t\n\t        var imageEl = this._imageEl;\n\t        var cropEl = this._cropEl;\n\t\n\t        if (!imageEl) {\n\t            imageEl = vmlCore.doc.createElement('div');\n\t            this._imageEl = imageEl;\n\t        }\n\t        var imageELStyle = imageEl.style;\n\t        if (hasCrop) {\n\t            // Needs know image original width and height\n\t            if (! (ow && oh)) {\n\t                var tmpImage = new Image();\n\t                var self = this;\n\t                tmpImage.onload = function () {\n\t                    tmpImage.onload = null;\n\t                    ow = tmpImage.width;\n\t                    oh = tmpImage.height;\n\t                    // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\t                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\t\n\t                    // Caching image original width, height and src\n\t                    self._imageWidth = ow;\n\t                    self._imageHeight = oh;\n\t                    self._imageSrc = image;\n\t                };\n\t                tmpImage.src = image;\n\t            }\n\t            else {\n\t                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\t            }\n\t\n\t            if (! cropEl) {\n\t                cropEl = vmlCore.doc.createElement('div');\n\t                cropEl.style.overflow = 'hidden';\n\t                this._cropEl = cropEl;\n\t            }\n\t            var cropElStyle = cropEl.style;\n\t            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n\t            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n\t            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='\n\t                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';\n\t\n\t            if (! cropEl.parentNode) {\n\t                vmlEl.appendChild(cropEl);\n\t            }\n\t            if (imageEl.parentNode != cropEl) {\n\t                cropEl.appendChild(imageEl);\n\t            }\n\t        }\n\t        else {\n\t            imageELStyle.width = round(scaleX * dw) + 'px';\n\t            imageELStyle.height = round(scaleY * dh) + 'px';\n\t\n\t            vmlEl.appendChild(imageEl);\n\t\n\t            if (cropEl && cropEl.parentNode) {\n\t                vmlEl.removeChild(cropEl);\n\t                this._cropEl = null;\n\t            }\n\t        }\n\t\n\t        var filterStr = '';\n\t        var alpha = style.opacity;\n\t        if (alpha < 1) {\n\t            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n\t        }\n\t        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\t\n\t        imageELStyle.filter = filterStr;\n\t\n\t        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Append to root\n\t        append(vmlRoot, vmlEl);\n\t\n\t        // Text\n\t        if (style.text != null) {\n\t            this.drawRectText(vmlRoot, this.getBoundingRect());\n\t        }\n\t    };\n\t\n\t    ZImage.prototype.onRemove = function (vmlRoot) {\n\t        remove(vmlRoot, this._vmlEl);\n\t\n\t        this._vmlEl = null;\n\t        this._cropEl = null;\n\t        this._imageEl = null;\n\t\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    ZImage.prototype.onAdd = function (vmlRoot) {\n\t        append(vmlRoot, this._vmlEl);\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t\n\t\n\t    /***************************************************\n\t     * TEXT\n\t     **************************************************/\n\t\n\t    var DEFAULT_STYLE_NORMAL = 'normal';\n\t\n\t    var fontStyleCache = {};\n\t    var fontStyleCacheCount = 0;\n\t    var MAX_FONT_CACHE_SIZE = 100;\n\t    var fontEl = document.createElement('div');\n\t\n\t    var getFontStyle = function (fontString) {\n\t        var fontStyle = fontStyleCache[fontString];\n\t        if (!fontStyle) {\n\t            // Clear cache\n\t            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n\t                fontStyleCacheCount = 0;\n\t                fontStyleCache = {};\n\t            }\n\t\n\t            var style = fontEl.style;\n\t            var fontFamily;\n\t            try {\n\t                style.font = fontString;\n\t                fontFamily = style.fontFamily.split(',')[0];\n\t            }\n\t            catch (e) {\n\t            }\n\t\n\t            fontStyle = {\n\t                style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n\t                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n\t                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n\t                size: parseFloat(style.fontSize || 12) | 0,\n\t                family: fontFamily || 'Microsoft YaHei'\n\t            };\n\t\n\t            fontStyleCache[fontString] = fontStyle;\n\t            fontStyleCacheCount++;\n\t        }\n\t        return fontStyle;\n\t    };\n\t\n\t    var textMeasureEl;\n\t    // Overwrite measure text method\n\t    textContain.measureText = function (text, textFont) {\n\t        var doc = vmlCore.doc;\n\t        if (!textMeasureEl) {\n\t            textMeasureEl = doc.createElement('div');\n\t            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'\n\t                + 'padding:0;margin:0;border:none;white-space:pre;';\n\t            vmlCore.doc.body.appendChild(textMeasureEl);\n\t        }\n\t\n\t        try {\n\t            textMeasureEl.style.font = textFont;\n\t        } catch (ex) {\n\t            // Ignore failures to set to invalid font.\n\t        }\n\t        textMeasureEl.innerHTML = '';\n\t        // Don't use innerHTML or innerText because they allow markup/whitespace.\n\t        textMeasureEl.appendChild(doc.createTextNode(text));\n\t        return {\n\t            width: textMeasureEl.offsetWidth\n\t        };\n\t    };\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\t\n\t        var style = this.style;\n\t\n\t        // Optimize, avoid normalize every time.\n\t        this.__dirty && textHelper.normalizeTextStyle(style, true);\n\t\n\t        var text = style.text;\n\t        // Convert to string\n\t        text != null && (text += '');\n\t        if (!text) {\n\t            return;\n\t        }\n\t\n\t        // Convert rich text to plain text. Rich text is not supported in\n\t        // IE8-, but tags in rich text template will be removed.\n\t        if (style.rich) {\n\t            var contentBlock = textContain.parseRichText(text, style);\n\t            text = [];\n\t            for (var i = 0; i < contentBlock.lines.length; i++) {\n\t                var tokens = contentBlock.lines[i].tokens;\n\t                var textLine = [];\n\t                for (var j = 0; j < tokens.length; j++) {\n\t                    textLine.push(tokens[j].text);\n\t                }\n\t                text.push(textLine.join(''));\n\t            }\n\t            text = text.join('\\n');\n\t        }\n\t\n\t        var x;\n\t        var y;\n\t        var align = style.textAlign;\n\t        var verticalAlign = style.textVerticalAlign;\n\t\n\t        var fontStyle = getFontStyle(style.font);\n\t        // FIXME encodeHtmlAttribute ?\n\t        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '\n\t            + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\t\n\t        textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign);\n\t\n\t        // Transform rect to view space\n\t        var m = this.transform;\n\t        // Ignore transform for text in other element\n\t        if (m && !fromTextEl) {\n\t            tmpRect.copy(rect);\n\t            tmpRect.applyTransform(m);\n\t            rect = tmpRect;\n\t        }\n\t\n\t        if (!fromTextEl) {\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t\n\t                align = align || 'left';\n\t            }\n\t            else {\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, distance\n\t                );\n\t                x = res.x;\n\t                y = res.y;\n\t\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                verticalAlign = verticalAlign || res.textVerticalAlign;\n\t            }\n\t        }\n\t        else {\n\t            x = rect.x;\n\t            y = rect.y;\n\t        }\n\t\n\t        x = textContain.adjustTextX(x, textRect.width, align);\n\t        y = textContain.adjustTextY(y, textRect.height, verticalAlign);\n\t\n\t        // Force baseline 'middle'\n\t        y += textRect.height / 2;\n\t\n\t        // var fontSize = fontStyle.size;\n\t        // 1.75 is an arbitrary number, as there is no info about the text baseline\n\t        // switch (baseline) {\n\t            // case 'hanging':\n\t            // case 'top':\n\t            //     y += fontSize / 1.75;\n\t            //     break;\n\t        //     case 'middle':\n\t        //         break;\n\t        //     default:\n\t        //     // case null:\n\t        //     // case 'alphabetic':\n\t        //     // case 'ideographic':\n\t        //     // case 'bottom':\n\t        //         y -= fontSize / 2.25;\n\t        //         break;\n\t        // }\n\t\n\t        // switch (align) {\n\t        //     case 'left':\n\t        //         break;\n\t        //     case 'center':\n\t        //         x -= textRect.width / 2;\n\t        //         break;\n\t        //     case 'right':\n\t        //         x -= textRect.width;\n\t        //         break;\n\t            // case 'end':\n\t                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n\t                // break;\n\t            // case 'start':\n\t                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n\t                // break;\n\t            // default:\n\t            //     align = 'left';\n\t        // }\n\t\n\t        var createNode = vmlCore.createNode;\n\t\n\t        var textVmlEl = this._textVmlEl;\n\t        var pathEl;\n\t        var textPathEl;\n\t        var skewEl;\n\t        if (!textVmlEl) {\n\t            textVmlEl = createNode('line');\n\t            pathEl = createNode('path');\n\t            textPathEl = createNode('textpath');\n\t            skewEl = createNode('skew');\n\t\n\t            // FIXME Why here is not cammel case\n\t            // Align 'center' seems wrong\n\t            textPathEl.style['v-text-align'] = 'left';\n\t\n\t            initRootElStyle(textVmlEl);\n\t\n\t            pathEl.textpathok = true;\n\t            textPathEl.on = true;\n\t\n\t            textVmlEl.from = '0 0';\n\t            textVmlEl.to = '1000 0.05';\n\t\n\t            append(textVmlEl, skewEl);\n\t            append(textVmlEl, pathEl);\n\t            append(textVmlEl, textPathEl);\n\t\n\t            this._textVmlEl = textVmlEl;\n\t        }\n\t        else {\n\t            // 这里是在前面 appendChild 保证顺序的前提下\n\t            skewEl = textVmlEl.firstChild;\n\t            pathEl = skewEl.nextSibling;\n\t            textPathEl = pathEl.nextSibling;\n\t        }\n\t\n\t        var coords = [x, y];\n\t        var textVmlElStyle = textVmlEl.style;\n\t        // Ignore transform for text in other element\n\t        if (m && fromTextEl) {\n\t            applyTransform(coords, coords, m);\n\t\n\t            skewEl.on = true;\n\t\n\t            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +\n\t            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';\n\t\n\t            // Text position\n\t            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);\n\t            // Left top point as origin\n\t            skewEl.origin = '0 0';\n\t\n\t            textVmlElStyle.left = '0px';\n\t            textVmlElStyle.top = '0px';\n\t        }\n\t        else {\n\t            skewEl.on = false;\n\t            textVmlElStyle.left = round(x) + 'px';\n\t            textVmlElStyle.top = round(y) + 'px';\n\t        }\n\t\n\t        textPathEl.string = encodeHtmlAttribute(text);\n\t        // TODO\n\t        try {\n\t            textPathEl.style.font = font;\n\t        }\n\t        // Error font format\n\t        catch (e) {}\n\t\n\t        updateFillAndStroke(textVmlEl, 'fill', {\n\t            fill: style.textFill,\n\t            opacity: style.opacity\n\t        }, this);\n\t        updateFillAndStroke(textVmlEl, 'stroke', {\n\t            stroke: style.textStroke,\n\t            opacity: style.opacity,\n\t            lineDash: style.lineDash\n\t        }, this);\n\t\n\t        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Attached to root\n\t        append(vmlRoot, textVmlEl);\n\t    };\n\t\n\t    var removeRectText = function (vmlRoot) {\n\t        remove(vmlRoot, this._textVmlEl);\n\t        this._textVmlEl = null;\n\t    };\n\t\n\t    var appendRectText = function (vmlRoot) {\n\t        append(vmlRoot, this._textVmlEl);\n\t    };\n\t\n\t    var list = [RectText, Displayable, ZImage, Path, Text];\n\t\n\t    // In case Displayable has been mixed in RectText\n\t    for (var i = 0; i < list.length; i++) {\n\t        var proto = list[i].prototype;\n\t        proto.drawRectText = drawRectText;\n\t        proto.removeRectText = removeRectText;\n\t        proto.appendRectText = appendRectText;\n\t    }\n\t\n\t    Text.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t        if (style.text != null) {\n\t            this.drawRectText(vmlRoot, {\n\t                x: style.x || 0, y: style.y || 0,\n\t                width: 0, height: 0\n\t            }, this.getBoundingRect(), true);\n\t        }\n\t        else {\n\t            this.removeRectText(vmlRoot);\n\t        }\n\t    };\n\t\n\t    Text.prototype.onRemove = function (vmlRoot) {\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    Text.prototype.onAdd = function (vmlRoot) {\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t}\n\n\n/***/ }),\n/* 138 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t\n\tif (!__webpack_require__(50).canvasSupported) {\n\t    var urn = 'urn:schemas-microsoft-com:vml';\n\t\n\t    var createNode;\n\t    var win = window;\n\t    var doc = win.document;\n\t\n\t    var vmlInited = false;\n\t\n\t    try {\n\t        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n\t        createNode = function (tagName) {\n\t            return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n\t        };\n\t    }\n\t    catch (e) {\n\t        createNode = function (tagName) {\n\t            return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n\t        };\n\t    }\n\t\n\t    // From raphael\n\t    var initVML = function () {\n\t        if (vmlInited) {\n\t            return;\n\t        }\n\t        vmlInited = true;\n\t\n\t        var styleSheets = doc.styleSheets;\n\t        if (styleSheets.length < 31) {\n\t            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n\t        }\n\t        else {\n\t            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n\t            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n\t        }\n\t    };\n\t\n\t    // Not useing return to avoid error when converting to CommonJS module\n\t    module.exports = {\n\t        doc: doc,\n\t        initVML: initVML,\n\t        createNode: createNode\n\t    };\n\t}\n\n\n/***/ }),\n/* 139 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * VML Painter.\n\t *\n\t * @module zrender/vml/Painter\n\t */\n\t\n\t\n\t\n\t    var zrLog = __webpack_require__(22);\n\t    var vmlCore = __webpack_require__(138);\n\t\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/vml/Painter\n\t     */\n\t    function VMLPainter(root, storage) {\n\t\n\t        vmlCore.initVML();\n\t\n\t        this.root = root;\n\t\n\t        this.storage = storage;\n\t\n\t        var vmlViewport = document.createElement('div');\n\t\n\t        var vmlRoot = document.createElement('div');\n\t\n\t        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\t\n\t        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\t\n\t        root.appendChild(vmlViewport);\n\t\n\t        this._vmlRoot = vmlRoot;\n\t        this._vmlViewport = vmlViewport;\n\t\n\t        this.resize();\n\t\n\t        // Modify storage\n\t        var oldDelFromStorage = storage.delFromStorage;\n\t        var oldAddToStorage = storage.addToStorage;\n\t        storage.delFromStorage = function (el) {\n\t            oldDelFromStorage.call(storage, el);\n\t\n\t            if (el) {\n\t                el.onRemove && el.onRemove(vmlRoot);\n\t            }\n\t        };\n\t\n\t        storage.addToStorage = function (el) {\n\t            // Displayable already has a vml node\n\t            el.onAdd && el.onAdd(vmlRoot);\n\t\n\t            oldAddToStorage.call(storage, el);\n\t        };\n\t\n\t        this._firstPaint = true;\n\t    }\n\t\n\t    VMLPainter.prototype = {\n\t\n\t        constructor: VMLPainter,\n\t\n\t        getType: function () {\n\t            return 'vml';\n\t        },\n\t\n\t        /**\n\t         * @return {HTMLDivElement}\n\t         */\n\t        getViewportRoot: function () {\n\t            return this._vmlViewport;\n\t        },\n\t\n\t        getViewportRootOffset: function () {\n\t            var viewportRoot = this.getViewportRoot();\n\t            if (viewportRoot) {\n\t                return {\n\t                    offsetLeft: viewportRoot.offsetLeft || 0,\n\t                    offsetTop: viewportRoot.offsetTop || 0\n\t                };\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 刷新\n\t         */\n\t        refresh: function () {\n\t\n\t            var list = this.storage.getDisplayList(true, true);\n\t\n\t            this._paintList(list);\n\t        },\n\t\n\t        _paintList: function (list) {\n\t            var vmlRoot = this._vmlRoot;\n\t            for (var i = 0; i < list.length; i++) {\n\t                var el = list[i];\n\t                if (el.invisible || el.ignore) {\n\t                    if (!el.__alreadyNotVisible) {\n\t                        el.onRemove(vmlRoot);\n\t                    }\n\t                    // Set as already invisible\n\t                    el.__alreadyNotVisible = true;\n\t                }\n\t                else {\n\t                    if (el.__alreadyNotVisible) {\n\t                        el.onAdd(vmlRoot);\n\t                    }\n\t                    el.__alreadyNotVisible = false;\n\t                    if (el.__dirty) {\n\t                        el.beforeBrush && el.beforeBrush();\n\t                        (el.brushVML || el.brush).call(el, vmlRoot);\n\t                        el.afterBrush && el.afterBrush();\n\t                    }\n\t                }\n\t                el.__dirty = false;\n\t            }\n\t\n\t            if (this._firstPaint) {\n\t                // Detached from document at first time\n\t                // to avoid page refreshing too many times\n\t\n\t                // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n\t                this._vmlViewport.appendChild(vmlRoot);\n\t                this._firstPaint = false;\n\t            }\n\t        },\n\t\n\t        resize: function (width, height) {\n\t            var width = width == null ? this._getWidth() : width;\n\t            var height = height == null ? this._getHeight() : height;\n\t\n\t            if (this._width != width || this._height != height) {\n\t                this._width = width;\n\t                this._height = height;\n\t\n\t                var vmlViewportStyle = this._vmlViewport.style;\n\t                vmlViewportStyle.width = width + 'px';\n\t                vmlViewportStyle.height = height + 'px';\n\t            }\n\t        },\n\t\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t\n\t            this._vmlRoot =\n\t            this._vmlViewport =\n\t            this.storage = null;\n\t        },\n\t\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t\n\t        clear: function () {\n\t            if (this._vmlViewport) {\n\t                this.root.removeChild(this._vmlViewport);\n\t            }\n\t        },\n\t\n\t        _getWidth: function () {\n\t            var root = this.root;\n\t            var stl = root.currentStyle;\n\t\n\t            return ((root.clientWidth || parseInt10(stl.width))\n\t                    - parseInt10(stl.paddingLeft)\n\t                    - parseInt10(stl.paddingRight)) | 0;\n\t        },\n\t\n\t        _getHeight: function () {\n\t            var root = this.root;\n\t            var stl = root.currentStyle;\n\t\n\t            return ((root.clientHeight || parseInt10(stl.height))\n\t                    - parseInt10(stl.paddingTop)\n\t                    - parseInt10(stl.paddingBottom)) | 0;\n\t        }\n\t    };\n\t\n\t    // Not supported methods\n\t    function createMethodNotSupport(method) {\n\t        return function () {\n\t            zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n\t        };\n\t    }\n\t\n\t    var notSupportedMethods = [\n\t        'getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers',\n\t        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'\n\t    ];\n\t\n\t    for (var i = 0; i < notSupportedMethods.length; i++) {\n\t        var name = notSupportedMethods[i];\n\t        VMLPainter.prototype[name] = createMethodNotSupport(name);\n\t    }\n\t\n\t    module.exports = VMLPainter;\n\n\n/***/ })\n/******/ ])\n});\n;\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e3773754ce41a5176349","/**\r\n * Export fishTopo as CommonJS module\r\n */\r\nmodule.exports = require('./lib/fish-topo-flow/lib/FishTopoFlow.js');\r\n//兼容IE8 引入VML 如果不需要兼容IE8请删除\r\nrequire('zrender/lib/vml/vml');\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.flow.js\n// module id = 1\n// module chunks = 0","/**\r\n * fishtopo流程实例\r\n * @class fish.topo.FishTopoFlow\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *      var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n */\r\n\r\n/**\r\n * @event click\r\n * 节点或者线段的click事件\r\n * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          this.fishTopo.on(\"click\", function(event) {\r\n *              console.log(\"点击的是：\" + event.target.model.get('elementType'));\r\n *          });\r\n */\r\n\r\n/**\r\n * @event dblclick\r\n * 节点或者线段的双击事件\r\n * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          this.fishTopo.on(\"dblclick\", function(event) {\r\n *              console.log(\"双击的是：\" + event.target.model.get('elementType'));\r\n *          });\r\n */\r\n\r\n/**\r\n * @event create\r\n * 节点与线段创建完毕的事件\r\n * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          this.fishTopo.on(\"create\", function(e) {\r\n *               if (me.fishTopo.Flow.isLink(e.target.model)) {\r\n *                  console.log(\"线段创建完毕：\" + e.target.model);\r\n *               }\r\n *          });\r\n */\r\n\r\n/**\r\n * @event delete\r\n * 节点与线段创建完毕的事件\r\n * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          //节点删除完毕事件\r\n *          this.fishTopo.on(\"delete\", function(event) {\r\n *              console.log(\"删除的是：\" + event.target.model.get('elementType'));\r\n *          });\r\n */\r\n\r\n/**\r\n * @event dropDrag\r\n * 节点移动完成的事件\r\n * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          //节点移动结束事件\r\n            this.fishTopo.on(\"dropDrag\", function(event) {\r\n                console.log(\"移动的节点是：\"+event.target.model.get('elementType'));\r\n            });\r\n */\r\n\r\n\r\n\r\n\r\n    require(\"../../fish-topo-core/lib/polyfill.js\");\r\n    var graphic = require(\"../../fish-topo-core/lib/graphic.js\");\r\n    var Minimap = require(\"../../fish-topo-core/lib/minimap.js\");\r\n    var util = require(\"../../fish-topo-core/lib/util.js\");\r\n    var Point = require(\"../../fish-topo-core/lib/Point.js\");\r\n    var ExtensionAPI = require('./ExtensionApi');\r\n    var Eventful = require('zrender/lib/mixin/Eventful');\r\n    var zrender = require('zrender/lib/zrender');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var OperationNode = require(\"../../fish-topo-core/lib/manager/OperationNode.js\");\r\n    var FlowConnectionManager = require(\"./manager/FlowConnectionManager.js\");\r\n    var FlowUtil = require(\"./util/FlowUtil.js\");\r\n    var Constants = require(\"./util/FlowConstants.js\");\r\n    var Model = require(\"../../fish-topo-core/lib/model.js\");\r\n    var eventTool = require('zrender/lib/core/event');\r\n    var Connector = require(\"../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var LineOperationManager = require(\"../../fish-topo-core/lib/manager/LineOperationManager.js\");\r\n    var Flow = require(\"./Flow.js\");\r\n    var flowNode = require(\"./node/flowNode\");\r\n    var flowLink = require(\"./link/flowLink\");\r\n    var layout = require(\"./layout/layout\");\r\n    var textContain = require('zrender/lib/contain/text');\r\n    var ImagePool = require(\"../../fish-topo-core/lib/ImagePool.js\");\r\n    var ToolTipView = require(\"./tooltip/TooltipView\");\r\n    var TooltipModel = require(\"./tooltip/TooltipModel\");\r\n    var actions = {};\r\n    var keyCode = {ENTER:13, ESCAPE:27}\r\n    function FishTopoFlow(dom, opts) {\r\n        this.id;\r\n        this.group = null;\r\n        this._dom = dom;\r\n        this.nowZoom = 1;\r\n        this.canScale = true;\r\n        this.eagleEye = false;\r\n        this.eagleEyeNode = null;\r\n        this.initScaleRatio = 1;\r\n        this.operationNode = null;\r\n        this.selectedNode = null;\r\n        this.allNodes = [];\r\n        this.minimap = null;\r\n        this._api = new ExtensionAPI(this);\r\n        this.connectionManager = new FlowConnectionManager(this._api);\r\n        this.lineOperationManager = new LineOperationManager(this.connectionManager,this._api);\r\n        this._zr = zrender.init(dom, {\r\n            renderer: opts.renderer || 'canvas',\r\n            devicePixelRatio: opts.devicePixelRatio\r\n        });\r\n        this._tooltipView = new ToolTipView(new TooltipModel(opts.tooltip),this._api);\r\n        this.Shape = graphic;\r\n        this.model = new Model({});\r\n        this.model.set(Constants.ELEMENT_TYPE, \"scene\");\r\n        this.model.set(Constants.MODE, \"normal\");\r\n        this.options = opts;\r\n        Eventful.call(this);\r\n    }\r\n\r\n    var fishTopoProto = FishTopoFlow.prototype;\r\n\r\n    /**\r\n     * 获取 fishTopo 实例容器的 dom 节点\r\n     * @return {HTMLElement}\r\n     */\r\n    fishTopoProto.getDom = function () {\r\n        return this._dom;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    fishTopoProto.getZr = function () {\r\n        return this._zr;\r\n    };\r\n    /**\r\n     * 获取 fishTopo 实例容器的宽度。\r\n     * @return {number}\r\n     */\r\n    fishTopoProto.getWidth = function () {\r\n        return this._zr.getWidth();\r\n    };\r\n\r\n    /**\r\n     * 获取 fishTopo 实例容器的高度。\r\n     * @return {number}\r\n     */\r\n    fishTopoProto.getHeight = function () {\r\n        return this._zr.getHeight();\r\n    };\r\n\r\n\r\n    /**\r\n     * 当前实例是否已经被释放。\r\n     * @return {boolean}\r\n     */\r\n    fishTopoProto.isDisposed = function () {\r\n        return this._disposed;\r\n    };\r\n\r\n    /**\r\n     * 释放 当前实例\r\n     */\r\n    fishTopoProto.dispose = function () {\r\n        this._disposed = true;\r\n\r\n        this._zr.dispose();\r\n\r\n        instances[this.id] = null;\r\n    };\r\n\r\n\r\n    /**\r\n     * 调整尺寸  在窗口大小发生改变时需要手工调用\r\n     * @param {number} width 宽度\r\n     * @param {number} height 高度\r\n     */\r\n    fishTopoProto.resize = function () {\r\n        this._zr.resize();\r\n\r\n    };\r\n\r\n    fishTopoProto.dispatchAction = function (payload) {\r\n        if(!actions[payload.type]) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method option\r\n     * 修改画布的选项\r\n     * @param {String} key 键  如：roam linkModify  textEditable等\r\n     * @param {Boolean|String|Function} value 选项值\r\n     */\r\n    fishTopoProto.option = function(key,value) {\r\n        var model = new Model(this.options);\r\n        if (arguments.length === 0) {\r\n            return zrUtil.clone(this.options);\r\n        } else if (arguments.length === 1) {\r\n            return model.get(key);\r\n        } else if (arguments.length === 2) {\r\n            if (key === \"roam\") {\r\n                this.setRoam(value);\r\n            }\r\n            return model.set(key,value);\r\n        }\r\n    }\r\n\r\n\r\n    fishTopoProto.init = function () {\r\n        this.group = new graphic.Group();\r\n        this.group.isBg = true;\r\n\r\n        // 鼠标平移操作\r\n        if ((this.options.roam === true) || (this.options.roam === 'move')) {\r\n            this.zrMove();\r\n        }\r\n\r\n        this._zr.add(this.group);\r\n\r\n        //是否允许鼠标滚轮放大缩小\r\n        if ((this.options.roam === true) || (this.options.roam === 'scale')) {\r\n            this.zrScale();\r\n        }\r\n\r\n        this.connectionManager.connectors = [];\r\n        //mouseup 会在各个node或线的click事件之点执行  在选中节点或线前 先清空选中效果\r\n        this._zr.on(\"mouseup\", function (e) { // clearSelect\r\n            // 1. 清空节点的选中效果\r\n            this._removeOperationNode();\r\n            // 2. 点击的线 ，则直接返回\r\n            var shape = e.target;\r\n            if (shape && shape.model && Flow.isLink(shape.model)) {\r\n                return;\r\n            }\r\n            if (shape && shape.connector instanceof Connector) {\r\n                return;\r\n            }\r\n            // 3. 清空连接线\r\n            this.connectionManager.clearSelectCon();\r\n            // 4. 点击的是线上操作按钮，则直接返回\r\n            if (shape && shape._isLineOperationIcon && shape._isLineOperationIcon == true) {\r\n                return;\r\n            }\r\n            // 5.隐藏线上操作图标\r\n            this.lineOperationManager.hideAllLineOperation();\r\n        }.bind(this));\r\n\r\n        this._zr.on(\"click\", function (e) {\r\n            var nodeTarget = e.target;\r\n            var shape;\r\n            if (nodeTarget) {\r\n                shape = nodeTarget.model;\r\n            }\r\n            if ((nodeTarget && shape && Flow.isLink(shape)) || (nodeTarget && shape && Flow.isNode(\r\n                    shape))) {\r\n                return;\r\n            }\r\n            var params = {};\r\n            params.event = e;\r\n            params.type = \"click\";\r\n            params.target = this;\r\n            this._api.trigger(params.type, params);\r\n        }.bind(this));\r\n        this.on('conPointsGroup:click', function (argument) {\r\n            this.lineOperationManager.bindOperation(argument.lineNode);\r\n        }.bind(this));\r\n    };\r\n\r\n    fishTopoProto.setRoam = function (value) {\r\n        //是否允许鼠标滚轮放大缩小\r\n        if ((value === true) || (value === 'move')) {\r\n            this.zrMove();\r\n        }\r\n        if ((value === true) || (value === 'scale')) {\r\n            this.zrScale();\r\n        }\r\n        if (value === false ) {\r\n            this._zr.off(\"mousedown\");  //禁止 拖拽画布\r\n            this._zr.off(\"mousewheel\");//禁止用户缩放画布\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method toJson\r\n     * 导出json\r\n     * @return {Object} json对象\r\n     */\r\n    fishTopoProto.toJson = function () {\r\n        return FlowUtil.toJson(this.model, this.group);\r\n    }\r\n\r\n    /**\r\n     * @method fromJson\r\n     * 导入json\r\n     * @param  {Object} json对象\r\n     */\r\n    fishTopoProto.fromJson = function (json) {\r\n        this.clear();\r\n        var model = new Model(json);\r\n        this.setBackground(model.get(Constants.BACKGROUND));\r\n        var layoutRootNode = [];\r\n        FlowUtil.fromJson(this, this.group, model.get(Constants.CHILDS), false, layoutRootNode);\r\n        // for (var i = 0; i < layoutRootNode.length; i++) {\r\n        //     this.layoutNode(\"tree\", {\r\n        //         \"node\": layoutRootNode[i],\r\n        //         \"type\": layoutRootNode[i].treeType\r\n        //     });\r\n        // }\r\n    };\r\n    /**\r\n     * 添加节点或线段到画布 同add方法\r\n     * @method addNode\r\n     * @param {Object} node createNode或createLink返回的对象\r\n     * @param {Object} [option] 参数对象\r\n     * @param {Boolean} [option.trigger] 是否触发 beforeCreate事件\r\n     * @returns {Object} 返回添加成功的节点 ，如被用户取消之类则 返回null\r\n     */\r\n    /**\r\n     * 添加节点或线段到画布 同addNode方法\r\n     * @method add\r\n     * @param {Object} node createNode或createLink返回的对象\r\n     * @param {Object} [option] 参数对象\r\n     * @param {Boolean} [option.trigger] 是否触发 beforeCreate事件\r\n     * @returns {Object} 返回添加成功的节点 ，如被用户取消之类则 返回null\r\n     */\r\n    fishTopoProto.add = fishTopoProto.addNode = function (node,options) {\r\n        if (!node) return null;\r\n\r\n        var opt = options || {};\r\n        if(opt.trigger !==false && (!this._trigger('beforeCreate', {target:node}))) {\r\n            return null;\r\n        }\r\n        if (node instanceof Connector) {\r\n            this.addConnectorAttrEvent(node);\r\n        } else {\r\n            if (Flow.isGroupNode(node)) {\r\n                node.willRender();\r\n                var groupOptions = node.model.get(Constants.OPTIONS);\r\n                if (groupOptions.mergedImage) {\r\n                    var groupReplaceImage = new flowNode.Image({\r\n                        style: {\r\n                            image: groupOptions.mergedImage,\r\n                            text: groupOptions.style.text,\r\n                            textPosition: 'bottom'\r\n                        },\r\n                        position: [-5000, -5000]\r\n                    });\r\n                    this.drag(groupReplaceImage);\r\n                    node._relationImage = groupReplaceImage;\r\n                    this.group.add(groupReplaceImage);\r\n                    setTimeout(function () {\r\n                        groupReplaceImage.hide();\r\n                    }, 300);\r\n                    node.on('dblclick', function () {\r\n                        node.merged();\r\n                    })\r\n                }\r\n                //遍历组中所有节点\r\n                node.each(function (child) {\r\n                        if (child instanceof Connector) {\r\n                            this.addConnectorAttrEvent(child);\r\n                        } else {\r\n                            this.addNodeAttrEvent(child, groupOptions.childDraggable);\r\n                            if (util.isUndefined(child.selectable)) {\r\n                                child.selectable = false;  //组内默认不可选中\r\n                            }\r\n                            if (child.relative) {\r\n                                this._handleRelativePostion(child)\r\n                            }\r\n                            if (child.hoverStyle) {\r\n                                graphic.setHoverStyle(child);\r\n                            }\r\n                        }\r\n                        this._trigger(\"create\", {target:child});\r\n                }, this);\r\n            }\r\n            this.addNodeAttrEvent(node, true);\r\n        }\r\n        this._trigger(\"create\", {target:node});\r\n\r\n        if (node.hoverStyle) {\r\n            graphic.setHoverStyle(node);\r\n        }\r\n\r\n        this.group.add(node);\r\n        if (node.relative) {  //必须在加入画布后执行\r\n            this._handleRelativePostion(node)\r\n        }\r\n        if (node.hoverAnimation && this.options.isAnimationEnabled) {\r\n            flowNode.addHoverAnimation(node);\r\n        }\r\n        return node;\r\n    };\r\n\r\n    fishTopoProto.addConnectorAttrEvent = function (connector) {\r\n        var that = this;\r\n        connector.options.isEdit = !!this.options.linkModify;\r\n        connector.on(\"mousedown\", function () {\r\n            this.connectionManager.connectorForbidEdit(!this.options.linkModify);\r\n            this.isNode = false;\r\n        }.bind(this));\r\n        this.connectionManager.add(connector);\r\n        //支持双击编辑\r\n        connector.on(\"dblclick\", function () {\r\n            if (typeof this.options.text.textEditable == \"undefined\") {\r\n                if (that.options.textEditable) {\r\n                    that.connectorEdit(this);\r\n                }\r\n            } else {\r\n                if (this.options.text.textEditable) {\r\n                    that.connectorEdit(this);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    fishTopoProto.addNodeAttrEvent = function (node, childDraggable) {\r\n        var that = this;\r\n        if (childDraggable) {\r\n            this.drag(node);\r\n        }\r\n\r\n        node.attr(\"operationIcons\", node.model.get('options.operationIcons'));\r\n\r\n        //侦听节点的click dblclick事件，选中，并派发出去\r\n        node.on('click', function (event) {\r\n            var targeNode = this;\r\n            that.nodeClickHandler(targeNode);\r\n\r\n            var params = {};\r\n            params.event = event;\r\n            params.type = 'click';\r\n            params.target = targeNode;\r\n            that._api.trigger(params.type, params);\r\n            event.cancelBubble = true;\r\n\r\n            //判断一下是否是组内成组的点击事件，如果是的话，那组也也派发一下\r\n            if (Flow.isInGroup(targeNode)) {\r\n                var parentNode = targeNode.parent;\r\n                parentNode.trigger('click', {event:event, type:'click',target:parentNode});\r\n            }\r\n        });\r\n        node.on('dblclick', function (e) {\r\n            var targeNode = this;\r\n            if (!targeNode.style || (typeof targeNode.style.textEditable == \"undefined\")) {\r\n                if (that.options.textEditable) {\r\n                    that.nodeEdit(targeNode);\r\n                }\r\n            } else {\r\n                if (targeNode.style.textEditable) {\r\n                    that.nodeEdit(targeNode);\r\n                }\r\n            }\r\n            var params = {};\r\n            params.event = e;\r\n            params.type = 'dblclick';\r\n            params.target = targeNode;\r\n            that._api.trigger(params.type, params);\r\n\r\n            e.cancelBubble = true;\r\n        });\r\n\r\n        this.allNodes.push(node);\r\n    }\r\n\r\n    fishTopoProto._handleRelativePostion = function(node) {\r\n        var parentEl = node.parent;\r\n        var containerInfo = parentEl === this.group\r\n            ? {\r\n                width:this._api.getWidth(),\r\n                height:this._api.getHeight()\r\n            }\r\n            : {\r\n                width:parentEl.getBoundingRect().width,\r\n                height:parentEl.getBoundingRect().height\r\n            }\r\n        layout.positionElement(node, node.relative, containerInfo, node.relative.padding, {boundingMode:node.relative.bounding||'all'});\r\n    }\r\n\r\n    fishTopoProto._getParentZr = function(node) {\r\n        var parentZr = null;\r\n        if (node && node.parent) {\r\n            parentZr = node.parent;\r\n        } else {\r\n            parentZr = this.group;\r\n        }\r\n        return parentZr;\r\n    }\r\n\r\n    fishTopoProto._removeOperationNode = function() {\r\n        if (this.operationNode) {\r\n            this.group.remove(this.operationNode);\r\n            this.operationNode.cleanup();\r\n            this.operationNode = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 清空当前实例，会移除实例中所有的节点与线\r\n     * @method clear\r\n     */\r\n    fishTopoProto.clear = function () {\r\n        for (var i = 0; i < this.allNodes.length; i++) {\r\n            var parentZr = this._getParentZr(this.allNodes[i]);\r\n            this.connectionManager.deleteSelectCon(this.allNodes[i], parentZr)\r\n        }\r\n        this.connectionManager.connectorMap.clear();\r\n        this.allNodes = [];\r\n        this.operationNode = null;\r\n        this.selectedNode = null;\r\n        this.connectionManager.connectors = [];\r\n        this._zr.clear();\r\n        this.group = new graphic.Group();\r\n        this.group.isBg = true;\r\n        this._zr.add(this.group);\r\n    };\r\n\r\n    /**\r\n     * 创建连线的小图标操作\r\n     * @param {string} key 小图标的名称\r\n     * @param {Object} options 小图标的相关参数\r\n     * @param {String} [options.icon] 小图标路径\r\n     * @param {Object} [options.lineNode] 线段实例\r\n     * @param {Function} [options.callback] 点击后的回调\r\n     *\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *                  this.fishTopo.addIcon(\"icon1\", {\r\n     *                      icon: \"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_ca79a146.png\",\r\n     *                      lineNode: lineNode,\r\n     *                      callback: function(event) {\r\n     *                          alert(JSON.stringify(event.data))\r\n     *                      },\r\n     *                  });\r\n     */\r\n    fishTopoProto.addLineIcon = fishTopoProto.addIcon = function (key, options) {\r\n        this.lineOperationManager.addIcon(key, options);\r\n    };\r\n\r\n    /**\r\n     * 创建连线的默认删除操作\r\n     * @param  {Object} lineNode 线\r\n     *\r\n     *  **使用范例**：\r\n     *\r\n     *      @example\r\n     *      fishTopo.lineDefaultIcon(lineNode);\r\n     */\r\n    fishTopoProto.lineDefaultIcon = function (lineNode) {\r\n        this.addLineDeleteIcon(lineNode);\r\n        this.addLineChangeIcon(lineNode);\r\n    };\r\n\r\n    /**\r\n     * 创建连线的默认删除操作\r\n     * @param  {Object} lineNode 线\r\n     * @param {Object} [options] 连线操作的选项\r\n     *\r\n     *  **使用范例**：\r\n     *\r\n     *      @example\r\n     *      fishTopo.addLineChangeIcon(lineNode);\r\n     */\r\n    fishTopoProto.addLineDeleteIcon = function (lineNode,options) {\r\n        //创建删除\r\n        this.lineOperationManager.addDeleteIcon(lineNode,options);\r\n    };\r\n\r\n    /**\r\n     * 创建连线的默认切换类型操作\r\n     * @param  {Object} lineNode 线\r\n     * @param {Object} [options] 连线操作的选项\r\n     *\r\n     *  **使用范例**：\r\n     *\r\n     *      @example\r\n     *      fishTopo.addLineChangeIcon(lineNode);\r\n     */\r\n    fishTopoProto.addLineChangeIcon = function (lineNode,options) {\r\n        this.lineOperationManager.addChangeLineTypeIcon(lineNode,options);\r\n    };\r\n\r\n    /**\r\n     * 变更当前线的类型，如果不传则按顺序取下一个类型。先删除原来的线段 再增加一种类型的线段\r\n     * @param {String} lineType 欲变更线的类型\r\n     */\r\n    fishTopoProto.changeSelectConnectorType = function(lineType) {\r\n        var nextLineType = lineType;\r\n        var line = this.connectionManager.selConnector;\r\n        var originLineType = line.options.style.lineType;\r\n        if (nextLineType) {\r\n            if (nextLineType == originLineType) {\r\n                return;\r\n            }\r\n        } else {\r\n            var arrLineType = [Connector.TYPE_STRAIGHT, Connector.TYPE_JAGGED, Connector.TYPE_CURVE];\r\n            var index = zrUtil.indexOf(arrLineType, originLineType);\r\n            nextLineType = arrLineType[(index + 1) % arrLineType.length];\r\n        }\r\n\r\n        //this.remove(line, {trigger:false}); 这样会删除icons\r\n        this.connectionManager.deleteLine(this._getParentZr(line));\r\n        this.lineOperationManager.hideAllLineOperation();\r\n\r\n        zrUtil.merge(line.options.style, {lineType: nextLineType}, true);\r\n        var nextLine = this.createConnectorByNodes(line.startNode, line.endNode, line.options);\r\n        if (nextLine) {\r\n            nextLine.icons = line.icons;\r\n            nextLine.on('Connector:click', function () {\r\n                this.lineOperationManager.bindOperation(nextLine);\r\n            }.bind(this));\r\n        }\r\n    }\r\n\r\n    fishTopoProto.initOperationNode = function (node) {\r\n        this.operationNode = new OperationNode(node, this.group, this._api);\r\n\r\n        this.operationNode.on(OperationNode.ARROW_DRAGSTART, function (e) {\r\n            var x = (e.event.offsetX - this.group.position[0]) / this.nowZoom;\r\n            var y = (e.event.offsetY - this.group.position[1]) / this.nowZoom;\r\n            //拖拽开始先把 箭头图标 给隐藏\r\n            var arrow = e.event.target;\r\n            arrow.hide();\r\n            var rEndPoint = new Point(x, y);\r\n            var connector = this.connectionManager.manageTempConnector(this.selectedNode, rEndPoint,\r\n                arrow.lineType);\r\n            this.group.add(connector);\r\n            e.cancelBubble = true;\r\n        }.bind(this));\r\n\r\n        // 侦听 箭头 拖拽事件\r\n        this.operationNode.on(OperationNode.ARROW_DRAG, function (e) {\r\n            var x = (e.event.offsetX - this.group.position[0]) / this.nowZoom;\r\n            var y = (e.event.offsetY - this.group.position[1]) / this.nowZoom;\r\n            var arrow = e.event.target;\r\n            var rEndPoint = new Point(x, y);\r\n            this.connectionManager.manageTempConnector(this.selectedNode, rEndPoint, arrow.lineType);\r\n            e.cancelBubble = true;\r\n        }.bind(this));\r\n\r\n        //侦听 箭头 拖拽结束事件 画线\r\n        this.operationNode.on(OperationNode.ARROW_DRAGEND, function (e) {\r\n            e.cancelBubble = true;\r\n            var x = e.event.offsetX;\r\n            var y = e.event.offsetY;\r\n            var targetNode = null;\r\n            //拖拽结束先把 箭头图标 给显示\r\n            var arrow = e.event.target;\r\n            arrow.show();\r\n            //删除临时线\r\n            this.connectionManager.removeTempConnector(this.group);\r\n\r\n            //1.如果是子节点 内 节点拖拽 则 增加排除子节点的参数\r\n            targetNode = findHover(this.allNodes, x, y);\r\n\r\n            function isHover(node, x, y) {\r\n                return node.rectContain(x, y);\r\n            }\r\n\r\n            function findHover(list, x, y, excludes) {\r\n                for (var i = list.length - 1; i >= 0; i--) {\r\n                    if (isExclude(excludes, list[i]) //list[i] !== exclude\r\n                        // getDisplayList may include ignored item in VML mode\r\n                        &&\r\n                        !list[i].ignore && isHover(list[i], x, y)) {\r\n                        return list[i];\r\n                    }\r\n                }\r\n            }\r\n\r\n            function isExclude(excludes, node) {\r\n                return zrUtil.indexOf(excludes, node) == -1;\r\n            }\r\n\r\n            //2.如果找到目标结点 则画线\r\n            if (targetNode && (this.selectedNode != targetNode)) {\r\n                var connectOptions;\r\n                if (e.data) {\r\n                    connectOptions = e.data;\r\n                } else {\r\n                    connectOptions = {\r\n                        style: {\r\n                            lineType: arrow.lineType\r\n                        }\r\n                    }\r\n                }\r\n                if(!this._trigger('beforeCreate', {target:this.selectedNode,endNode:targetNode,connectOptions:connectOptions})) {\r\n                    return null;\r\n                }\r\n                this.createConnectorByNodes(this.selectedNode, targetNode, connectOptions);\r\n            }\r\n        }.bind(this));\r\n\r\n        //删除按钮点击事件\r\n        this.operationNode.on(OperationNode.DELETE_CLICK, function () {\r\n            this.removeNode(this.selectedNode);\r\n        }.bind(this));\r\n        this.group.add(this.operationNode);\r\n    };\r\n\r\n    /**\r\n     * 移除场景中的某个节点或者线段,同removeNode\r\n     * @method remove\r\n     * @param  {Object} node or link 待删除的节点或者线段\r\n     * @param {Object} [options] 参数\r\n     * @param {Boolean} [options.trigger=true] 是否触发删除事件\r\n     *\r\n     *  **使用范例**：\r\n     *\r\n     *      @example\r\n     *      fishTopo.remove(peopleNode);\r\n     */\r\n\r\n    /**\r\n     * 移除场景中的某个节点或者线段,同remove\r\n     * @method removeNode\r\n     * @param  {Object} node or link 待删除的节点或者线段\r\n     * @param {Object} [options] 参数\r\n     * @param {Boolean} [options.trigger=true] 是否触发删除事件\r\n     *\r\n     *  **使用范例**：\r\n     *\r\n     *      @example\r\n     *      fishTopo.removeNode(peopleNode);\r\n     */\r\n    fishTopoProto.remove = fishTopoProto.removeNode = function (delNode, options) {\r\n        var opt = options || {};\r\n        if(opt.trigger !==false && (!this._trigger('beforeDelete', {target:delNode}))) {\r\n            return;\r\n        }\r\n        var parentZr = this._getParentZr(delNode);\r\n        if (delNode instanceof Connector) {\r\n            // 1.1 删除线段上的操作图标\r\n            zrUtil.each(delNode.icons, function(lineOperationIcon) {\r\n                parentZr.remove(lineOperationIcon);\r\n            })\r\n            // 1.2 删除当前选中线段\r\n            this.connectionManager.deleteByLine(delNode,parentZr);\r\n        } else {\r\n            //2.1 删除节点\r\n            parentZr.remove(delNode);\r\n            //2.2 从allNodes数组中删除\r\n            for (var i = 0; i < this.allNodes.length; i++) {\r\n                if (delNode.id == this.allNodes[i].id) {\r\n                    this.allNodes.splice(i, 1);\r\n                }\r\n            }\r\n            //2.3 删除和节点相关联的线段\r\n            this.connectionManager.deleteSelectCon(delNode, this.group);\r\n            //2.4 删除节点操作\r\n            this._removeOperationNode();\r\n        }\r\n\r\n        //3. 清空连接线上的调整位置按钮\r\n        this.connectionManager.clearSelectCon();\r\n        //4. 清空连接线上的操作按钮\r\n        this.lineOperationManager.hideAllLineOperation();\r\n        //4. 派发删除事件\r\n         this._trigger(\"delete\", {target:delNode});\r\n    };\r\n\r\n\r\n    /**\r\n     * 根据节点创建连线\r\n     * @method createConnectorByNodes\r\n     * @param  {Object} startNode 开始节点\r\n     * @param  {Object} endNode   结束节点\r\n     * @param  {Object} options 线段选项 参见{@link fishTopoFlow.link#constructor 构造函数options参数}\r\n     */\r\n    fishTopoProto.createConnectorByNodes = function (startNode, endNode, options) {\r\n\r\n        var linkType = options.style.lineType || Connector.TYPE_STRAIGHT;\r\n        if (!flowLink[linkType]) {\r\n            return null;\r\n        }\r\n        var Link = flowLink[linkType];\r\n        var connector = new Link(startNode, endNode, options);\r\n        this.connectionManager.add(connector);\r\n\r\n        if (startNode.parent && endNode.parent) {\r\n            endNode.parent.add(connector);\r\n        } else {\r\n            this.group.add(connector);\r\n        }\r\n\r\n        connector.on(\"mousedown\", function () {\r\n            this.connectionManager.connectorForbidEdit(!this.options.linkModify);\r\n            this.isNode = false;\r\n        }.bind(this));\r\n        connector.on(\"dblclick\", function () {\r\n            if (this.options.textEditable) {\r\n                this.connectorEdit(this);\r\n            }\r\n        }.bind(this));\r\n\r\n        this._trigger(\"create\", {target:connector});\r\n        return connector;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 派发创建完成事件  返回fales则取消\r\n     */\r\n    fishTopoProto._trigger = function(type, event, data) {\r\n        var callback = this.options[type];\r\n\r\n        if (data === void 0) data = {};\r\n        if (event === null) {\r\n            event = {type:type, target:this}\r\n        } else {\r\n            event.type = type;\r\n        }\r\n        event.data = data;\r\n        this._api.trigger(event.type, event);\r\n        return !(zrUtil.isFunction(callback) && callback.apply(this, [event].concat(data)) === false);\r\n    }\r\n\r\n\r\n    fishTopoProto.nodeClickHandler = function (node) {\r\n        // 鼠标点下 将操作框 移到对应的节点上\r\n        if (node.selectable === false) {\r\n            if (Flow.isInGroup(node)) {\r\n                var group = node.parent;\r\n                if (group.selectable === false) {\r\n                    return;\r\n                } else {\r\n                    node = group;   // 如果有组的话，就针对组进行处理\r\n                }\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.selectedNode = node;\r\n        var shapeRect = util.getRect(node);\r\n        if (!this.operationNode) {\r\n            this.initOperationNode(node);\r\n        }\r\n        // 在存在子流程的情况下 需要把node也传递一下\r\n        this.operationNode.refreshPostion(node, shapeRect);\r\n    };\r\n\r\n    fishTopoProto._groupDragHandler = function (x, y) {\r\n        // flow中最外层的group移动操作\r\n        var nowGroupPosition = this.group.position;\r\n        var groupPositionX = this.group.position[0];\r\n        var groupPositionY = this.group.position[1];\r\n\r\n        var moveHandler = function (event) {\r\n            var width = this.group.getBoundingRect().width * this.nowZoom;\r\n            var height = this.group.getBoundingRect().height * this.nowZoom;\r\n            var gx = this.group.getBoundingRect().x * this.nowZoom;\r\n            var gy = this.group.getBoundingRect().y * this.nowZoom;\r\n            var min = [10 - (width + gx), 10 - (height + gy)];\r\n            var max = [(this._zr.getWidth() - gx) - 10, (this._zr.getHeight() - gy) - 10];\r\n            var sX = event.offsetX - x;\r\n            var sY = event.offsetY - y;\r\n            nowGroupPosition[0] = groupPositionX + sX;\r\n            nowGroupPosition[1] = groupPositionY + sY;\r\n            if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] <\r\n                min[0] || nowGroupPosition[1] < min[1]) {\r\n                return;\r\n            } else {\r\n                this.group.attr(\"position\", nowGroupPosition);\r\n                if (this.eagleEye == true) {\r\n                    this.minimap.updataSelectionPosition(nowGroupPosition, this.nowZoom);\r\n                }\r\n            }\r\n        }.bind(this);\r\n        this._zr.on('mousemove', moveHandler);\r\n\r\n        var endDragHandler = function () {\r\n            this._zr.off('mousemove', moveHandler);\r\n            this._zr.off('mouseup', endDragHandler);\r\n            this._zr.off(\"globalout\", endDragHandler);\r\n        }.bind(this);\r\n        this._zr.on('mouseup', endDragHandler);\r\n        this._zr.on(\"globalout\", endDragHandler);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 节点的移动操作, 为何要自己实现拖动？zredner Group不支持拖动，只能自己实现\r\n     */\r\n    fishTopoProto.drag = function (node) {\r\n        var that = this; // zrender中的一个bug event.target不会带group 只能用that 不能用bind(this)\r\n        node.on(\"mousedown\", function (event) {\r\n            var draggingTarget = this;\r\n            //如果加了属性 draggable:false 则不可以拖动\r\n            if (draggingTarget.isdraggable == false) {\r\n                return;\r\n            }\r\n            that._nodeDragHandler(draggingTarget, event.offsetX, event.offsetY);\r\n            event.cancelBubble = true;\r\n        });\r\n    };\r\n\r\n    fishTopoProto._nodeDragHandler = function (node, x, y) {\r\n        var isMove = 0;\r\n        var nowGroupPosition = node.position;\r\n        var groupPositionX = node.position[0];\r\n        var groupPositionY = node.position[1];\r\n        node._startX = x;\r\n        node._startY = y;\r\n\r\n        node.trigger(\"dragstart\");\r\n        // 1、侦听移动事件\r\n\r\n        var moveHandler = function (event) {\r\n            event.cancelBubble = true;\r\n            var sX = (event.offsetX - node._startX) / (this.nowZoom);\r\n            var sY = (event.offsetY - node._startY) / (this.nowZoom);\r\n\r\n            if ((sX != 0) || (sY != 0)) {\r\n                isMove = 1;\r\n            }\r\n            node.trigger(\"drag\");\r\n            // 1.1处理组内的情况（如果节点拖动，组也跟着变）\r\n            if (Flow.isInGroup(node)) {\r\n                //放入node现有数值，用于重绘group\r\n                var nodeMessage = {\r\n                    width: node.shape.width,\r\n                    height: node.shape.height,\r\n                    position: node.position,\r\n                    movePosition: [groupPositionX, groupPositionY],\r\n                    moveX: sX,\r\n                    moveY: sY,\r\n                    node: node\r\n                };\r\n                node.parent.modifyGroupRect(nodeMessage);\r\n            }\r\n            nowGroupPosition[0] = groupPositionX + sX;\r\n            nowGroupPosition[1] = groupPositionY + sY;\r\n            node.attr(\"position\", nowGroupPosition);\r\n            // 1.2 处理告警的情况 （告警随着节点移动）\r\n            if (node.alarm) {\r\n                var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm\r\n                        .getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect()\r\n                    .height - 3\r\n                ];\r\n                node.alarm.attr(\"position\", newAlarmPosition);\r\n            }\r\n            // 1.4 触发点击\r\n            this.nodeClickHandler(node);\r\n            // 1.5 刷新连线\r\n            this.connectionManager.refreshLineByNode(node);\r\n        }.bind(this);\r\n        this._zr.on('mousemove', moveHandler);\r\n\r\n\r\n\r\n        //2. 拖拽结束\r\n        var endDragHandler = function () {\r\n            if (node.model) {\r\n                node.model.set(\"options.position\", FlowUtil.truncPosition(node.position));\r\n            }\r\n\r\n            this._zr.off('mousemove', moveHandler);\r\n            this._zr.off('mouseup', endDragHandler);\r\n            this._zr.off(\"globalout\", endDragHandler);\r\n\r\n            //2.1 缩微图\r\n            if (isMove == 1) {\r\n                this._trigger(\"dropDrag\", {target:node});\r\n                node.trigger(\"dragend\");\r\n                if (this.eagleEye == true) {\r\n                    this.openEagleEye(this.eagleEyeNode);\r\n                }\r\n            }\r\n        }.bind(this);\r\n        this._zr.on('mouseup', endDragHandler);\r\n        this._zr.on('globalout', endDragHandler);\r\n    }\r\n\r\n\r\n    /**\r\n     * 创建节点\r\n     * @method createNode\r\n     * @param  {String} type 类型 eg. 'Rect'、'Circle'、'Image'、'Group'、'Text'等\r\n     * @param  {Object} opt 节点选项 详见{@link fishTopoFlow.node Config options}\r\n     * @param {Object} userData 用户传递的业务数据\r\n     * @return {Object} 创建的节点对象\r\n     *\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *      var rect = this.fishTopo.createNode(\"Rect\", { //矩形\r\n     *          shape: {\r\n     *              width: 100,\r\n     *              height: 60,\r\n     *          },\r\n     *          style: {\r\n     *              text: \"基本矩形\",\r\n     *              fill: \"#167CFF\",\r\n     *              stroke: \"rgb(255,255,255)\",\r\n     *              textFont: '14px Microsoft YaHei'\r\n     *          },\r\n     *          position: [180, 100],\r\n     *          operationIcons: [{ name: 'DEL' },\r\n     *              { name: 'STRAIGHT' },\r\n     *              { name: 'JAGGED' },\r\n     *              { name: 'CURVE' },\r\n     *              {\r\n     *                  name: \"custom1\",\r\n     *                  iconPath: \"img/host.png\",\r\n     *                  callback: function(e) { alert(e.data.name + \" clicked\") }  //e.node是当前的节点\r\n     *              }\r\n     *          ]\r\n     *      });\r\n     */\r\n    fishTopoProto.createNode = fishTopoProto.creatNode = function (type, opt, userData) {\r\n        if (!flowNode[type]) {\r\n            return null;\r\n        }\r\n        var Shape = flowNode[type];\r\n        var node = new Shape(opt);\r\n\r\n        Flow.setUserData(node, userData);\r\n        return node;\r\n    };\r\n\r\n    /**\r\n     * 根据name获取节点\r\n     * @param  {String} name 在创建节点中  name属性设置的值\r\n     * @return {Object}      name对应的节点\r\n     */\r\n    fishTopoProto.childOfName = function (name) {\r\n        var arrResult = [];\r\n        var childrenNode = this.allNodes;\r\n        var childrenLine = this.connectionManager.connectors;\r\n        for (var i = 0; i < childrenNode.length; i++) {\r\n            if (childrenNode[i].model.get(\"options.name\") && childrenNode[i].model.get(\"options.name\") ==\r\n                name) {\r\n                arrResult.push(childrenNode[i]);\r\n            } else if (childrenNode[i].model.get(\"userData.name\") == name) {\r\n                arrResult.push(childrenNode[i]);\r\n            }\r\n        }\r\n        for (var j = 0; j < childrenLine.length; j++) {\r\n            if (childrenLine[j].model.get(\"options.name\") && childrenLine[j].model.get(\"options.name\") ==\r\n                name) {\r\n                arrResult.push(childrenLine[j]);\r\n            } else if (childrenLine[j].model.get(\"userData.name\") == name) {\r\n                arrResult.push(childrenLine[j]);\r\n            }\r\n        }\r\n        if (arrResult.length > 1) {\r\n            return arrResult;\r\n        } else {\r\n            return arrResult[0];\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 查找场景中的对象   例如: x坐标大于100的节点 findElements(function(node){ return node.position[0] > 100; });\r\n     * @param  {Function} cb      回调函数 参数为遍历的节点\r\n     * @param  {Object}   context 回调函数执行的上下文\r\n     * @return {Array}           返回查找到的对象\r\n     */\r\n    fishTopoProto.findElements = function (cb, context) {\r\n        var childrenNode = this.allNodes;\r\n        var childrenLine = this.connectionManager.connectors;\r\n        var arr = [];\r\n        for (var i = 0; i < childrenNode.length; i++) {\r\n            var child = childrenNode[i];\r\n            if (cb.call(context, child, i)) {\r\n                arr.push(child);\r\n            }\r\n        }\r\n        for (var j = 0; j < childrenLine.length; j++) {\r\n            var childL = childrenLine[j];\r\n            if (cb.call(context, childL, j)) {\r\n                arr.push(childL);\r\n            }\r\n        }\r\n        return arr;\r\n    };\r\n\r\n    /**\r\n     * 设置背景色  或 背景图片\r\n     * @param {string} imageUrl 背景色  或 背景图片 eg. 'img/bg.jpg'，为‘gridLine’时网格背景\r\n     * @param {string} isRepeat 是否重复背景  如果重复的话，将使用css的repeat 因为canvas不支持repeat\r\n     */\r\n    fishTopoProto.setBackground = function (imageUrl, isRepeat) {\r\n        if (imageUrl && imageUrl.length > 0) {\r\n            this.model.set(Constants.BACKGROUND, imageUrl);\r\n            if (imageUrl.substr(0, 1) == \"#\" || imageUrl.substr(0, 4) == \"rgba\") { //如果是颜色创建rect为背景\r\n                if (!document.createElement('canvas').getContext) {\r\n                    this._dom.style.backgroundColor = imageUrl;\r\n                } else {\r\n                    var imageShape = new this.Shape.Rect({\r\n                        shape: {\r\n                            width: this._zr.getWidth(),\r\n                            height: this._zr.getHeight()\r\n                        },\r\n                        style: {\r\n                            fill: imageUrl\r\n                        },\r\n                        cursor: 'default',\r\n                        z: -1\r\n                    });\r\n                    this._zr.add(imageShape);\r\n                }\r\n\r\n            } else if (imageUrl == \"gridLine\") {\r\n                this.gridLineGroup = new graphic.Group();\r\n                this.gridLine(0.2);\r\n                this._zr.add(this.gridLineGroup);\r\n            } else {\r\n                if (!document.createElement('canvas').getContext || isRepeat) {\r\n                    this._dom.style.backgroundImage = \"url(\" + imageUrl + \")\";\r\n                    this._dom.style.backgroundRepeat = \"repeat\";\r\n                } else {\r\n                    var imageShape1 = new this.Shape.Image({ //如果是图片创建image为背景\r\n                        position: [0, 0],\r\n                        scale: [1, 1],\r\n                        style: {\r\n                            x: 0,\r\n                            y: 0,\r\n                            image: imageUrl,\r\n                            width: this._zr.getWidth(),\r\n                            height: this._zr.getHeight()\r\n                        },\r\n                        cursor: 'default',\r\n                        z: -1\r\n                    });\r\n                    this._zr.add(imageShape1);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    //背景网格线\r\n    fishTopoProto.gridLine = function (opacity) {\r\n        var pixel = 10;\r\n        var widthLen = parseInt(this.getWidth() / pixel);\r\n        for (var x = 0; x <= widthLen; x++) {\r\n            var lineX = new graphic.Line({\r\n                shape: {\r\n                    x1: x * pixel,\r\n                    y1: 0,\r\n                    x2: x * pixel,\r\n                    y2: this.getHeight()\r\n                },\r\n                style: {\r\n                    lineDash: [1],\r\n                    opacity: opacity\r\n                },\r\n                z: 0,\r\n                draggable: false,\r\n                cursor: 'default'\r\n            });\r\n            this.gridLineGroup.add(lineX);\r\n        }\r\n\r\n        var heightLen = parseInt(this.getHeight() / pixel, pixel);\r\n        for (var y = 0; y <= heightLen; y++) {\r\n            var lineY = new graphic.Line({\r\n                shape: {\r\n                    x1: 0,\r\n                    y1: y * pixel,\r\n                    x2: this.getWidth(),\r\n                    y2: y * pixel\r\n                },\r\n                style: {\r\n                    lineDash: [1],\r\n                    opacity: opacity\r\n                },\r\n                z: 0,\r\n                draggable: false,\r\n                cursor: 'default'\r\n            });\r\n            this.gridLineGroup.add(lineY);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 创建线段\r\n     * @method createLink\r\n     * @param  {Object} startNode 开始节点\r\n     * @param  {Object} endNode   结束节点\r\n     * @param  {Object} options 线段选项\r\n     * @param {Object} [options.style] 节点的样式\r\n     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n     * @param {Object} [options.symbol] 线段的箭头\r\n     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n     * @param {Object} [options.text] 线段上的文字\r\n     * @param {String} [options.text.text] 线段上的文字内容\r\n     * @param {String} [options.text.color] 线段上的文字颜色\r\n     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {String} [options.position] 指定线段位置\r\n     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n     * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n     * @param {Object} [options.effect] 线上动态效果\r\n     * @param {String} [options.effect.show] 是否显示箭头动效\r\n     * @param {Number} [options.effect.period] 动效移动速度\r\n     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n     * @param {Number} [options.z] [连线的层级，越大越在前面显示]\r\n     * @param {Object} userData 用户传递的业务数据\r\n     * @return {Object} 创建的线段对象\r\n     *\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *      var link = me.fishTopo.createLink(startNode, endNode, {\r\n     *              symbol: { type: 'arrow', size: 10, color: \"rgb(0,200,255)\" }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n     *              style: { lineWidth: 3, stroke: \"rgb(0,200,255)\", lineDash: [3,3], lineType: \"jagged\"  }, //样式\r\n     *              text: {\r\n     *                  text: text,\r\n     *                  color: '#ffffff',\r\n     *                  textPos:textPos,//文字位置可选值 'start','center','end',默认值为center\r\n     *                  xOffset:10, //文字位置x偏移量\r\n     *              },\r\n     *              pos:'right,left',\r\n     *              effect: {\r\n     *                  show: true,//是否显示箭头动效\r\n     *                  period: 6,//箭头速度\r\n     *              },\r\n     *              position:{\r\n     *                    escapeDistance:[50,30],  //第一条折线的长度，最后一条折线的长度\r\n     *                    points:[\"x1,y1\",\"x2,y2\"]  不使用自动计算 指定连线的位置数组\r\n     *              },\r\n     *              z: 0\r\n     *          });\r\n     */\r\n    fishTopoProto.createLink = fishTopoProto.creatLink = function (startNode, endNode, options, userData) {\r\n        var linkType = Connector.TYPE_STRAIGHT;\r\n        if (options && options.style && options.style.lineType) {\r\n            linkType = options.style.lineType\r\n        }\r\n\r\n        if (!flowLink[linkType]) {\r\n            return null;\r\n        }\r\n        var Link = flowLink[linkType];\r\n        var connector = new Link(startNode, endNode, options);\r\n        if (userData) {\r\n            connector.model.set(Constants.USERDATA, zrUtil.clone(userData));\r\n        }\r\n\r\n        return connector;\r\n    };\r\n\r\n    /**\r\n     * 根据节点刷新节点所连的线（重新计算线的位置）\r\n     * @param  {Object} node [节点]\r\n     */\r\n    fishTopoProto.refreshLineByNode = function (node) {\r\n        this.connectionManager.refreshLineByNode(node);\r\n    };\r\n\r\n\r\n    /**\r\n     * @private\r\n     * 线上文字编辑\r\n     */\r\n    fishTopoProto.connectorEdit = function (thisConnector) {\r\n        var lineText = thisConnector.childOfName('lineText');\r\n        if (!lineText) {\r\n            return;\r\n        }\r\n        var textarea = this.createTextArea();\r\n        textarea.style.width = 1.1 * util.getRect(lineText).width * this.nowZoom + \"px\";\r\n        textarea.style.height = (util.getRect(lineText).height || 12) * this.nowZoom + \"px\";\r\n        textarea.style.border = \"1px solid #000000\";\r\n        textarea.innerHTML = lineText.style.text;\r\n        thisConnector.setStyle({\r\n            text: {\r\n                text: \"\"\r\n            }\r\n        })\r\n        this._dom.appendChild(textarea);\r\n        this._dom.style.position = \"relative\";\r\n        var textRect = textContain.getBoundingRect(lineText.style.text, lineText.style.textFont);\r\n        textarea.style.lineHeight = (textRect.lineHeight || 14) + \"px\";\r\n        textarea.style.top = (lineText.position[1] - util.getRect(lineText).height) * this.nowZoom + this.group\r\n            .position[1] + \"px\";\r\n        textarea.style.left = (lineText.position[0] - 0.05 * util.getRect(lineText).width) * this.nowZoom +\r\n            this.group.position[0] + \"px\";\r\n        textarea.focus();\r\n        textarea.select();\r\n        $(textarea).on(\"keyup\", zrUtil.bind(function (e) {\r\n            var textRect = textContain.getBoundingRect(lineText.style.text, lineText.style.textFont);\r\n            this._textareaResize(textRect, textarea, e);\r\n        }, this));\r\n        $(textarea).on(\"focusout\", function () {\r\n            thisConnector.setStyle({\r\n                text: {\r\n                    text: textarea.value || \"\"\r\n                }\r\n            })\r\n            textarea.remove();\r\n        })\r\n    };\r\n    /**\r\n     * @private\r\n     * 节点上文字编辑\r\n     */\r\n    fishTopoProto.nodeEdit = function (thisNode) {\r\n        var isNotSetText = false;\r\n        var textarea = this.createTextArea();\r\n        var nodeText = zrUtil.clone(thisNode.style.text);\r\n        var textRect = textContain.getBoundingRect(nodeText, thisNode.style.textFont);\r\n        textarea.style.width = 2 * textRect.width * this.nowZoom + \"px\";\r\n        textarea.style.height = (2 * textRect.height || 12) * this.nowZoom + \"px\";\r\n        var nodeRect = util.getRect(thisNode);\r\n        textarea.style.maxWidth = 1.2 * nodeRect.width * this.nowZoom + \"px\";\r\n        textarea.style.lineHeight = (1.2 * textRect.lineHeight || 12) + \"px\";\r\n        textarea.style.border = \"1px solid #000000\";\r\n        textarea.innerHTML = thisNode.style.text;\r\n        this.setStyle(thisNode, {text: \"\"});  //先把节点文本给清空，否则删除文本框中文字的时候，会显示出来\r\n        this._dom.appendChild(textarea);\r\n        this._dom.style.position = \"relative\";\r\n        var offestI = 1;\r\n        if (thisNode.style.textAlign == \"left\") {\r\n            offestI = 0;\r\n        }\r\n        if (thisNode.style.textAlign == \"right\") {\r\n            offestI = 2;\r\n        }\r\n        var offestP = 0;\r\n        if (thisNode.style.textPosition && thisNode.style.textPosition == \"bottom\") {\r\n            offestP = 1;\r\n            textarea.style.maxWidth = 3 * 1.1 * nodeRect.width * this.nowZoom + \"px\";\r\n        }\r\n        if (thisNode.style.textPosition && thisNode.style.textPosition == \"top\") {\r\n            offestP = -1;\r\n            textarea.style.maxWidth = 3 * 1.1 * nodeRect.width * this.nowZoom + \"px\";\r\n        }\r\n        textarea.style.top = (nodeRect.y - textRect.height / 2 + offestP * (nodeRect.height - textRect.height /\r\n            2)) * this.nowZoom + this.group.position[1] + \"px\";\r\n        textarea.style.left = (nodeRect.x - offestI * textRect.width / 2 - 0.05 * textRect.width) * this.nowZoom +\r\n            this.group.position[0] + \"px\";\r\n        textarea.focus();\r\n        textarea.select();\r\n        textarea.onkeyup = function() {\r\n            if (event.keyCode == keyCode.ESCAPE) {\r\n                isNotSetText = true;\r\n                textarea.blur();\r\n            } else {\r\n                var textRect = textContain.getBoundingRect(textarea.value, thisNode.style.textFont);\r\n                this._textareaResize(textRect, textarea, textarea.style.maxWidth);\r\n            }\r\n        }.bind(this);\r\n\r\n        textarea.onblur = function() {\r\n            if (!isNotSetText) {\r\n                var text = this.handleWrap(textarea.value, textarea.style.maxWidth);\r\n                this.setStyle(thisNode, {text: text});\r\n            } else {\r\n                this.setStyle(thisNode, {text: nodeText});\r\n            }\r\n            textarea.remove();\r\n        }.bind(this);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 创建文本域\r\n     */\r\n    fishTopoProto.createTextArea = function () {\r\n        var textarea = document.createElement(\"textarea\");\r\n        textarea.style.position = \"absolute\";\r\n        textarea.style.padding = \"6px\";\r\n        textarea.style.resize = \"none\";\r\n        textarea.style.whiteSpace = \"pre\";\r\n        textarea.style.lineHeight = \"125%\";\r\n        textarea.style.overflow = \"hidden\";\r\n        textarea.style.border = \"0\";\r\n        textarea.spellcheck = false;\r\n        return textarea;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 处理textarea自动换行\r\n     */\r\n    fishTopoProto.handleWrap = function (value, width) {\r\n        var spanNode = document.createElement(\"span\");\r\n        spanNode.style.position = \"absolute\";\r\n        spanNode.style.overflow = \"hidden\";\r\n        spanNode.style.border = \"0\";\r\n        spanNode.style.padding = \"0\";\r\n        spanNode.style.left = \"0\";\r\n        spanNode.style.top = \"0\";\r\n        this._dom.appendChild(spanNode);\r\n        var content = value.split(\"\\n\");\r\n        var result = \"\";\r\n        $.each(content, function (i, val) {\r\n            var valLength = val.length;\r\n            if (valLength == 0) {\r\n                //result += \"\\n\";\r\n            } else {\r\n                var pre = \"\",\r\n                    innerVal, tempWidth, conWidth;\r\n                for (var innerI = 0; innerI < valLength; innerI++) {\r\n                    innerVal = val.charAt(innerI);\r\n                    $(spanNode).text($(spanNode).text() + innerVal);\r\n                    tempWidth = $(spanNode).width(); //获取添加字符后隐藏域的宽度\r\n                    conWidth = Number(width.substring(0, width.length - 2));\r\n                    if (tempWidth > conWidth) {\r\n                        result += pre; //如果追加字符后隐藏域宽度大于TextArea宽度，则表明该字符为下一行字符，\r\n                        result += \"\\n\";\r\n                        $(spanNode).text(innerVal);\r\n                        pre = innerVal;\r\n                    } else if (innerI == valLength - 1) {\r\n                        result += pre + innerVal; //最后一个字符\r\n                        if (i < content.length - 1) {\r\n                            result += \"\\n\";\r\n                        }\r\n                        $(spanNode).text(\"\");\r\n                        pre = \"\";\r\n                    } else {\r\n                        pre += innerVal; //依次追加到pre变量中\r\n                    }\r\n\r\n                }\r\n            }\r\n        });\r\n        this._dom.removeChild(spanNode);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 文本域自适应高宽\r\n     */\r\n    fishTopoProto._textareaResize = function (textRect, textarea, width) {\r\n        var minWidth = 0;\r\n        textarea.style.width = 0;\r\n        textarea.style.width = (1.1 * textRect.width) * this.nowZoom + \"px\";\r\n        if (width < 60) {\r\n            minWidth = width;\r\n        } else {\r\n            minWidth = 60\r\n        }\r\n        if (textRect.width <= minWidth) {\r\n            textarea.style.width = minWidth + \"px\";\r\n        }\r\n        textarea.style.height = \"0px\";\r\n        textarea.style.height = textarea.scrollHeight + 'px';\r\n        if (textarea.scrollHeight <= 0) {\r\n            textarea.style.height = \"12px\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method setStyle\r\n     * 节点更改style里的属性\r\n     * @param {String} name 节点style里的某个属性名称\r\n     * @param {String} string 节点style里的某个属性名称对应的值\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *          //节点设置文字\r\n     *         fishtopo.setStyle(node,{text:\"例子\"});\r\n     */\r\n    fishTopoProto.setStyle = function (node, options) {\r\n        node.setStyle(options);\r\n        zrUtil.merge(node.model.get(\"options.style\"), options, true);\r\n    }\r\n\r\n    /**\r\n     * @method setShape\r\n     * 节点更改shape里的属性\r\n     * @param {String} name 节点shape里的某个属性名称\r\n     * @param {String} string 节点shape里的某个属性名称对应的值\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *          //矩形节点设置宽\r\n     *         fishtopo.setShape(node,{width:100});\r\n     */\r\n    fishTopoProto.setShape = function (node, options) {\r\n        node.setShape(options);\r\n        zrUtil.merge(node.model.get(\"options.shape\"), options, true);\r\n    }\r\n\r\n    /**\r\n     * 创建节点上面的警告\r\n     * @method createAlarm\r\n     * @param  {Object} node 节点\r\n     * @param  {Object} opt  选项值\r\n     * @param  {Object} [opt.text] 警告的文字\r\n     * @param  {Object} [opt.textFont] 警告的文字的字体\r\n     * @param  {Object} [opt.textFill] 警告的文字的颜色\r\n     * @param  {Object} [opt.textBackground] 警告的背景的颜色\r\n     * @return {Object} 返回节点上的警告\r\n     *\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *          this.fishTopo.createAlarm(s1,{\r\n     *          text:\"2 W\",\r\n     *          textFont:\"4px Microsoft YaHei\",\r\n     *          textFill:\"#FFFFFF\",\r\n     *          textBackground:\"rgba(255,0,0,0.6)\"\r\n     *      });//创建小图片和节点绑定\r\n     */\r\n    fishTopoProto.createAlarm = fishTopoProto.creatAlarm = function (node, opt) {\r\n        var group = this.createNode(\"Group\", {\r\n            style: {\r\n                fill: 'rgba(0,0,0,0)',\r\n                stroke: 'rgba(0,0,0,0)'\r\n            }\r\n        });\r\n        group.isdraggable = false;\r\n        var text = this.createNode(\"Text\", { //文字\r\n            style: {\r\n                text: opt.text,\r\n                textFont: opt.textFont,\r\n                fill: opt.textFill,\r\n                textBaseline: \"top\" //垂直对齐,\r\n            },\r\n            selectable: false,\r\n            position: [2, 0],\r\n            z: 2\r\n        });\r\n        text.isdraggable = false;\r\n        group.add(text);\r\n        if (Flow.isInGroup(node)) {\r\n            node.parent.add(group);\r\n        } else {\r\n            this.group.add(group);\r\n        }\r\n        var groupWidth = group.getBoundingRect().width + 2;\r\n        var groupHeight = group.getBoundingRect().height + 6;\r\n        var points = [\r\n            [0, 0],\r\n            [groupWidth, 0],\r\n            [groupWidth, groupHeight],\r\n            [groupWidth - 3, groupHeight],\r\n            [groupWidth - 6, groupHeight + 3],\r\n            [groupWidth - 9, groupHeight],\r\n            [0, groupHeight],\r\n            [0, 0]\r\n        ];\r\n        var Polyline = this.createNode(\"Polyline\", {\r\n            shape: {\r\n                points: points\r\n            },\r\n            style: {\r\n                fill: opt.textBackground,\r\n                stroke: opt.textBackground\r\n            },\r\n            selectable: false,\r\n            z: 1\r\n        });\r\n        Polyline.isdraggable = false;\r\n        group.add(Polyline);\r\n        var groupPosition = [node.position[0] + node.getBoundingRect().width - (group.getBoundingRect().width -\r\n            6), node.position[1] - group.getBoundingRect().height - 3];\r\n        group.attr(\"position\", groupPosition);\r\n        node.alarm = group;\r\n        //设置模型 给json序列化用\r\n        var model = new Model({});\r\n        model.set(Constants.ELEMENT_TYPE, Constants.ALARM);\r\n        model.set(Constants.OPTIONS, zrUtil.clone(opt));\r\n        model.set(Constants.RELATIONID, node.model.get(Constants.ID));\r\n        group.model = model;\r\n        return group;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 返回当前画布的数据\r\n     */\r\n    fishTopoProto.toDataURL = function (opts) {\r\n        return FlowUtil.toDataURL(this._zr, opts);\r\n    };\r\n\r\n    fishTopoProto.zrMove = function () {\r\n        this._zr.on(\"mousedown\", function (e) { //点击在节点上或者线上不进行平移操作\r\n            if ((e.target && e.target.model) || (e.target && e.target.lineType && e.target.parent) ||\r\n                (e.target && e.target.connector instanceof Connector) || (e.target && e.target instanceof graphic\r\n                    .Circle)) {\r\n                return;\r\n            } else {\r\n                this._groupDragHandler(e.offsetX, e.offsetY);\r\n            }\r\n        }.bind(this));\r\n    }\r\n\r\n    fishTopoProto.initScale = function () {\r\n        var groupMaxWidth = this.group.getBoundingRect().width;\r\n        var groupMaxHeight = this.group.getBoundingRect().height;\r\n        var rangeWidth = this.getWidth();\r\n        var rangeHeight = this.getHeight();\r\n        var initRatio = 1,\r\n            pos = [];\r\n        if (groupMaxWidth / groupMaxHeight > rangeWidth / rangeHeight) {\r\n            if (groupMaxWidth > rangeWidth) {\r\n                initRatio = rangeWidth / groupMaxWidth;\r\n            }\r\n        } else {\r\n            if (groupMaxHeight > rangeHeight) {\r\n                initRatio = rangeHeight / groupMaxHeight;\r\n            }\r\n        }\r\n        pos[0] = Math.abs(this.group.getBoundingRect().x) * initRatio;\r\n        pos[1] = Math.abs(this.group.getBoundingRect().y) * initRatio;\r\n        this.group.attr(\"position\", [pos[0], pos[1]]);\r\n        this.group.attr(\"scale\", [initRatio, initRatio]);\r\n        this.initScaleRatio = initRatio;\r\n        var distance = [pos[0], pos[1], this.initScaleRatio, groupMaxWidth, groupMaxHeight];\r\n        return distance;\r\n    };\r\n\r\n    /**\r\n     * 放大或者缩小\r\n     * @param  {String|Number} type 当为字符串时 \"enlarge\"放大  \"narrowing\"缩小  当为数值时 缩放的比例  建议0.3-1.7\r\n     */\r\n    fishTopoProto.zrScale = function (type) {\r\n        if (type) {\r\n            if (type == \"narrowing\") {\r\n                var zoomDelta1 = -0.07;\r\n                this.zoom(zoomDelta1, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }\r\n            if (type == \"enlarge\") {\r\n                var zoomDelta = 0.07;\r\n                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }\r\n            if (!isNaN(type)) {\r\n                var target = this.group;\r\n                if (target) {\r\n                    var zoomScale = type;\r\n                    this._zoom = type;\r\n                    this.nowZoom = type;\r\n                    this.setScale(this._zr.getWidth() / 2, this._zr.getHeight() / 2, zoomScale);\r\n                }\r\n            }\r\n        } else {\r\n            this._zr.on('mousewheel', zrUtil.bind(function (e) {\r\n                eventTool.stop(e.event);\r\n                var zoomDelta = e.wheelDelta > 0 ? 0.07 : -0.07;\r\n                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }, this));\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    fishTopoProto.zoom = function (zoomDelta, zoomX, zoomY) {\r\n        if (this.canScale == false) {\r\n            return;\r\n        }\r\n        var target = this.group;\r\n        if (target) {\r\n\r\n            var newZoom = this._zoom = this._zoom || 1;\r\n            newZoom += zoomDelta;\r\n\r\n            newZoom = Number(newZoom.toFixed(2));\r\n            var zoomScale = newZoom / this._zoom;\r\n            if (newZoom > 1.7 || newZoom < 0.3) {\r\n                return;\r\n            }\r\n            this._zoom = newZoom;\r\n\r\n            this.nowZoom = newZoom;\r\n            this.setScale(zoomX, zoomY, zoomScale);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    fishTopoProto.setScale = function (zoomX, zoomY, zoomScale) {\r\n        var target = this.group;\r\n        var pos = target.position;\r\n        var scale = target.scale;\r\n        // Keep the mouse center when scaling\r\n        pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\r\n        pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\r\n        scale[0] *= zoomScale;\r\n        scale[1] *= zoomScale;\r\n        target.attr(\"position\", [pos[0], pos[1]]);\r\n        target.attr(\"scale\", [scale[0], scale[1]]);\r\n        if (this.eagleEye == true) {\r\n            this.minimap.updataSelection(pos[0], pos[1], zoomScale, this.nowZoom);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 鹰眼图\r\n     * @param  {HTMLElement} eagleEyeNode 显示鹰眼图的div元素\r\n     */\r\n    fishTopoProto.openEagleEye = function (eagleEyeNode) {\r\n        this.eagleEye = true;\r\n        this.eagleEyeNode = eagleEyeNode;\r\n        var groupPosition = zrUtil.clone(this.group.position);\r\n        var groupScale = zrUtil.clone(this.group.scale);\r\n        this.group.attr(\"position\", [0, 0]);\r\n        this.group.attr(\"scale\", [1, 1]);\r\n        var distance = this.initScale();\r\n        var imgSrc = this.toDataURL();\r\n        this.group.attr(\"position\", groupPosition);\r\n        this.group.attr(\"scale\", groupScale);\r\n        if (this.minimap) {\r\n            this.minimap.updataMap(imgSrc, this.group.getBoundingRect());\r\n        } else {\r\n            this.minimap = new Minimap(this, this.group.position, this.group.getBoundingRect(),\r\n                eagleEyeNode, distance, imgSrc);\r\n            setTimeout(zrUtil.bind(function () {\r\n                this.openEagleEye(this.eagleEyeNode)\r\n            }, this), 10);\r\n        }\r\n        this.minimap.selection.addEventListener(\"mousedown\", function (e) {\r\n            var startX = e.clientX;\r\n            var startY = e.clientY;\r\n            var minimapLeft = Number(this.minimap.selection.style.left.substring(0, this.minimap.selection\r\n                .style.left.length - 2));\r\n            var minimapTop = Number(this.minimap.selection.style.top.substring(0, this.minimap.selection\r\n                .style.top.length - 2));\r\n            var eagleEyeMove = function (e) {\r\n                var offsetX = e.clientX - startX;\r\n                var offsetY = e.clientY - startY;\r\n                this.minimap.selection.style.left = minimapLeft + offsetX + \"px\";\r\n                this.minimap.selection.style.top = minimapTop + offsetY + \"px\";\r\n                this.minimap.updataGroupPosition(this.group, this.nowZoom);\r\n            }.bind(this);\r\n\r\n            this.minimap.selection.addEventListener(\"mousemove\", eagleEyeMove);\r\n\r\n            var eagleEyeUp = function () {\r\n                this.minimap.selection.removeEventListener(\"mousemove\", eagleEyeMove);\r\n                this.minimap.selection.removeEventListener(\"mouseup\", eagleEyeUp);\r\n            }.bind(this);\r\n            this.minimap.selection.addEventListener(\"mouseup\", eagleEyeUp);\r\n        }.bind(this))\r\n    };\r\n\r\n\r\n\r\n    zrUtil.mixin(FishTopoFlow, Eventful);\r\n\r\n    // ---------对外暴露fishTopoFlow------------------\r\n    var idBase = new Date() - 0;\r\n    var instances = {};\r\n    var DOM_ATTRIBUTE_KEY = '_fishTopoFlow_instance_';\r\n\r\n    /**\r\n     * fishTopoFlow全局对象，如果是amd方式加载，则直接返回\r\n     * @class fishTopoFlow\r\n     * @singleton\r\n     *\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *      var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n     */\r\n    var fishTopoFlow = {\r\n        /**\r\n         * 版本号\r\n         * @type {String}\r\n         */\r\n        version: '2.2.1',\r\n        dependencies: {\r\n            zrender: '3.6.3'\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 初始化dom元素为 flow对象\r\n     * @member fishTopoFlow\r\n     * @param {HTMLElement} dom  一个div元素\r\n     * @param {Object} opts  传递的选项参数\r\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg' or 'vml'\r\n     * @param {number} [opts.devicePixelRatio=1] retina 屏幕优化\r\n     * @param {boolean} [opts.linkModify=false] 是否允许调整线段\r\n     * @param {boolean} [opts.textEditable=false] 是否允许双击节点编辑文字\r\n     * @param {boolean} [opts.roam=true] 是否开启鼠标缩放和平移漫游。默认开启。如果只想要开启缩放或者平移，可以设置成 'scale' 或者 'move'。设置成 true 为都开启\r\n     * @param {Object} [opts.tooltip] tooltip配置项\r\n     * @param {boolean} [opts.tooltip.show] tooltip配置项:控制tooltip是否显示\r\n     * @param {boolean} [opts.isAnimationEnabled=true] 是否开启动画,默认为true\r\n     * @param {Function} [opts.beforeDelete] 删除节点或边线 之前的回调，如果返回false则不进行后续的删除操作\r\n     * @param {Object} [opts.beforeCreate] 创建节点或边线 之前的回调，如果返回false则不进行后续的删除操作\r\n     * @return {fish.topo.FishTopoFlow}\r\n     */\r\n    fishTopoFlow.init = function (dom, opts) {\r\n        if (!dom) {\r\n            throw new Error('Initialize failed: invalid dom.');\r\n        }\r\n\r\n        opts = opts || {};\r\n        // Default value\r\n        zrUtil.defaults(opts, {\r\n            type: \"flow\",\r\n            devicePixelRatio: 1,\r\n            linkModify: false,\r\n            textEditable: false,\r\n            roam: true,\r\n            tooltip: {\r\n                show:true\r\n            },  //覆盖tooltipModel\r\n            isAnimationEnabled: true,\r\n            beforeDelete: null,  // 删除之前的事件\r\n            beforeCreate:null   //创建节点或连线之前的事件\r\n        });\r\n\r\n        var fishTopoFlow = new FishTopoFlow(dom, opts);\r\n        fishTopoFlow.init();\r\n        fishTopoFlow.Flow = Flow;\r\n        fishTopoFlow.id = 'ft_' + idBase++;\r\n        instances[fishTopoFlow.id] = fishTopoFlow;\r\n\r\n        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoFlow.id);\r\n\r\n        return fishTopoFlow;\r\n    };\r\n\r\n\r\n    /**\r\n     * 获取 dom 容器上的实例。\r\n     * @member fishTopoFlow\r\n     * @param  {HTMLElement} dom 一个div元素\r\n     * @return {fish.topo.FishTopoFlow}\r\n     */\r\n    fishTopoFlow.getInstanceByDom = function (dom) {\r\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n        return instances[key];\r\n    };\r\n\r\n    /**\r\n     * 销毁实例，实例销毁后无法再被使用。\r\n     *\r\n     * @member fishTopoFlow\r\n     * @param  {Object|string} chart fishTopoBpmn实例 或 fishTopoBpmn的id\r\n     */\r\n    fishTopoFlow.dispose = function (chart) {\r\n        var topo;\r\n        if (zrUtil.isDom(chart)) {\r\n            topo = fishTopoFlow.getInstanceByDom(chart);\r\n        } else if (typeof chart === 'string') {\r\n            topo = instances[chart];\r\n        }\r\n        if ((topo instanceof fishTopoFlow) && !topo.isDisposed()) {\r\n            topo.dispose();\r\n        }\r\n    };\r\n\r\n    //暴露出去的类\r\n    fishTopoFlow.graphic = graphic;\r\n    fishTopoFlow.node = FlowUtil.registerFlowNode(flowNode);\r\n    fishTopoFlow.link = flowLink;\r\n\r\n    fishTopoFlow.layout = layout;\r\n    fishTopoFlow.Flow = Flow;\r\n    fishTopoFlow.constants = Constants;\r\n    fishTopoFlow.util = util;\r\n    fishTopoFlow.util['initImagePool'] = ImagePool.initImagePool;\r\n    zrUtil.each([\r\n            'map', 'each', 'filter', 'indexOf', 'inherits',\r\n            'reduce', 'filter', 'bind', 'curry', 'isArray',\r\n            'isString', 'isObject', 'isFunction', 'extend',\r\n            'merge', \"mergeAll\"\r\n        ],\r\n        function (name) {\r\n            fishTopoFlow.util[name] = zrUtil[name];\r\n        }\r\n    );\r\n\r\n    module.exports = fishTopoFlow;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/FishTopoFlow.js\n// module id = 2\n// module chunks = 0","\r\n    //polyfill bind\r\n    if (!Function.prototype.bind) {\r\n        Function.prototype.bind = function(oThis) {\r\n            if (typeof this !== \"function\") {\r\n                // closest thing possible to the ECMAScript 5 internal IsCallable function\r\n                throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\r\n            }\r\n\r\n            var aArgs = Array.prototype.slice.call(arguments, 1),\r\n                fToBind = this,\r\n                fNOP = function() {},\r\n                fBound = function() {\r\n                    return fToBind.apply(this instanceof fNOP && oThis ? this : oThis || window,\r\n                        aArgs.concat(Array.prototype.slice.call(arguments)));\r\n                };\r\n\r\n            fNOP.prototype = this.prototype;\r\n            fBound.prototype = new fNOP();\r\n\r\n            return fBound;\r\n        };\r\n    }\r\n\r\n    //polyfill remove\r\n    if (!('remove' in Element.prototype)) {\r\n        Element.prototype.remove = function() {\r\n            if (this.parentNode) {\r\n                this.parentNode.removeChild(this);\r\n            }\r\n        };\r\n    }\r\n\r\n    if (!String.prototype.endsWith) {\r\n    String.prototype.endsWith = function(searchString, position) {\r\n        var subjectString = this.toString();\r\n        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\r\n            position = subjectString.length;\r\n        }\r\n        position -= searchString.length;\r\n        var lastIndex = subjectString.indexOf(searchString, position);\r\n        return lastIndex !== -1 && lastIndex === position;\r\n    };\r\n    }\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/polyfill.js\n// module id = 3\n// module chunks = 0","'use strict';\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var pathTool = require('zrender/lib/tool/path');\r\n    var round = Math.round;\r\n    var Path = require('zrender/lib/graphic/Path');\r\n    var colorTool = require('zrender/lib/tool/color');\r\n    var matrix = require('zrender/lib/core/matrix');\r\n    var vector = require('zrender/lib/core/vector');\r\n    var Gradient = require('zrender/lib/graphic/Gradient');\r\n    var Draggable = require('zrender/lib/mixin/Draggable');\r\n\r\n    var graphic = {};\r\n    graphic.Util = zrUtil;\r\n    graphic.Group = require('zrender/lib/container/Group');\r\n\r\n    graphic.Image = require('zrender/lib/graphic/Image');\r\n\r\n    graphic.Text = require('zrender/lib/graphic/Text');\r\n\r\n    graphic.textContain = require('zrender/lib/contain/text');\r\n\r\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\r\n\r\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\r\n\r\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\r\n\r\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\r\n\r\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\r\n\r\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\r\n\r\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\r\n\r\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\r\n\r\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\r\n\r\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\r\n\r\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\r\n\r\n    graphic.BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    graphic.States = require(\"zrender/lib/graphic/States.js\");\r\n    /**\r\n     * Extend shape with parameters\r\n     */\r\n    graphic.extendShape = function (opts) {\r\n        return Path.extend(opts);\r\n    };\r\n\r\n    /**\r\n     * Extend path\r\n     */\r\n    graphic.extendPath = function (pathData, opts) {\r\n        return pathTool.extendFromString(pathData, opts);\r\n    };\r\n\r\n    /**\r\n     * Create a path element from path data string\r\n     * @param {string} pathData\r\n     * @param {Object} opts\r\n     * @param {module:zrender/core/BoundingRect} rect\r\n     * @param {string} [layout=cover] 'center' or 'cover'\r\n     */\r\n    graphic.makePath = function (pathData, opts, rect, layout) {\r\n        var path = pathTool.createFromString(pathData, opts);\r\n        Draggable.call(path);\r\n        var boundingRect = path.getBoundingRect();\r\n        if (rect) {\r\n            var aspect = boundingRect.width / boundingRect.height;\r\n\r\n            if (layout === 'center') {\r\n                // Set rect to center, keep width / height ratio.\r\n                var width = rect.height * aspect;\r\n                var height;\r\n                if (width <= rect.width) {\r\n                    height = rect.height;\r\n                }\r\n                else {\r\n                    width = rect.width;\r\n                    height = width / aspect;\r\n                }\r\n                var cx = rect.x + rect.width / 2;\r\n                var cy = rect.y + rect.height / 2;\r\n\r\n                rect.x = cx - width / 2;\r\n                rect.y = cy - height / 2;\r\n                rect.width = width;\r\n                rect.height = height;\r\n            }\r\n\r\n            this.resizePath(path, rect);\r\n        }\r\n\r\n        zrUtil.inherits(path, Draggable);\r\n        return path;\r\n    };\r\n\r\n    graphic.mergePath = pathTool.mergePath;\r\n\r\n    /**\r\n     * Resize a path to fit the rect\r\n     * @param {module:zrender/graphic/Path} path\r\n     * @param {Object} rect\r\n     */\r\n    graphic.resizePath = function (path, rect) {\r\n        if (!path.applyTransform) {\r\n            return;\r\n        }\r\n\r\n        var pathRect = path.getBoundingRect();\r\n\r\n        var m = pathRect.calculateTransform(rect);\r\n\r\n        path.applyTransform(m);\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize line for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x1]\r\n     * @param {number} [param.shape.y1]\r\n     * @param {number} [param.shape.x2]\r\n     * @param {number} [param.shape.y2]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeLine = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n\r\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n        }\r\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n        }\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize rect for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x]\r\n     * @param {number} [param.shape.y]\r\n     * @param {number} [param.shape.width]\r\n     * @param {number} [param.shape.height]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeRect = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n        var originX = shape.x;\r\n        var originY = shape.y;\r\n        var originWidth = shape.width;\r\n        var originHeight = shape.height;\r\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n        shape.width = Math.max(\r\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n            originWidth === 0 ? 0 : 1\r\n        );\r\n        shape.height = Math.max(\r\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n            originHeight === 0 ? 0 : 1\r\n        );\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize for canvas\r\n     *\r\n     * @param {number} position Coordinate, such as x, y\r\n     * @param {number} lineWidth Should be nonnegative integer.\r\n     * @param {boolean=} positiveOrNegative Default false (negative).\r\n     * @return {number} Optimized position.\r\n     */\r\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n        // Assure that (position + lineWidth / 2) is near integer edge,\r\n        // otherwise line will be fuzzy in canvas.\r\n        var doubledPosition = round(position * 2);\r\n        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n            ? doubledPosition / 2\r\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    function doSingleEnterHover(el) {\r\n        if (el.__isHover) {\r\n            return;\r\n        }\r\n        if (el.__hoverStlDirty) {\r\n            var stroke = el.style.stroke;\r\n            var fill = el.style.fill;\r\n\r\n            // Create hoverStyle on mouseover\r\n            var hoverStyle = el.__hoverStl;\r\n            var lift = colorTool.lift;\r\n            hoverStyle.fill = hoverStyle.fill\r\n                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n            hoverStyle.stroke = hoverStyle.stroke\r\n                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\r\n            var normalStyle = {};\r\n            for (var name in hoverStyle) {\r\n                if (hoverStyle.hasOwnProperty(name)) {\r\n                    normalStyle[name] = el.style[name];\r\n                }\r\n            }\r\n\r\n            el.__normalStl = normalStyle;\r\n\r\n            el.__hoverStlDirty = false;\r\n        }\r\n        el.setStyle(el.__hoverStl);\r\n        el.z2 += 1;\r\n\r\n        el.__isHover = true;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doSingleLeaveHover(el) {\r\n        if (!el.__isHover) {\r\n            return;\r\n        }\r\n\r\n        var normalStl = el.__normalStl;\r\n        normalStl && el.setStyle(normalStl);\r\n        el.z2 -= 1;\r\n\r\n        el.__isHover = false;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doEnterHover(el) {\r\n        (el.type === 'group' || el.type === 'GroupNode')\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleEnterHover(child);\r\n                }\r\n            })\r\n            : doSingleEnterHover(el);\r\n    }\r\n    graphic.doEnterHover = doEnterHover;\r\n    function doLeaveHover(el) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleLeaveHover(child);\r\n                }\r\n            })\r\n            : doSingleLeaveHover(el);\r\n    }\r\n    graphic.doLeaveHover = doLeaveHover;\r\n    /**\r\n     * @inner\r\n     */\r\n    function setElementHoverStl(el, hoverStl) {\r\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n        // Often used when item group has a label element and it's hoverStyle is different\r\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n        el.__hoverStlDirty = true;\r\n    }\r\n    graphic.setElementHoverStl = setElementHoverStl;\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOver() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOut() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function enterEmphasis() {\r\n        this.__isEmphasis = true;\r\n        doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function leaveEmphasis() {\r\n        this.__isEmphasis = false;\r\n        doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * Set hover style of element\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} [hoverStyle]\r\n     */\r\n    graphic.setHoverStyle = function (el, hoverStyle) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    setElementHoverStl(child, hoverStyle);\r\n                }\r\n            })\r\n            : setElementHoverStl(el, hoverStyle);\r\n        // Remove previous bound handlers\r\n        el.on('mouseover', onElementMouseOver)\r\n          .on('mouseout', onElementMouseOut);\r\n\r\n        // Emphasis, normal can be triggered manually\r\n        el.on('emphasis', enterEmphasis)\r\n          .on('normal', leaveEmphasis);\r\n    };\r\n\r\n    graphic.setNormalStyle = function(el, options) {\r\n        if (el.__normalStl) {\r\n            for (var name in options) {\r\n                if (el.__normalStl.hasOwnProperty(name)) {\r\n                    el.__normalStl[name] = options[name];\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Set text option in the style\r\n     * @param {Object} textStyle\r\n     * @param {module:echarts/model/Model} labelModel\r\n     * @param {string} color\r\n     */\r\n    graphic.setText = function (textStyle, labelModel, color) {\r\n        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n        var textStyleModel = labelModel.getModel('textStyle');\r\n        zrUtil.extend(textStyle, {\r\n            textDistance: labelModel.getShallow('distance') || 5,\r\n            textFont: textStyleModel.getFont(),\r\n            textPosition: labelPosition,\r\n            textFill: textStyleModel.getTextColor() || labelColor\r\n        });\r\n    };\r\n\r\n    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n        var postfix = isUpdate ? 'Update' : '';\r\n        var duration = animatableModel\r\n            && animatableModel.getShallow('animationDuration' + postfix);\r\n        var animationEasing = animatableModel\r\n            && animatableModel.getShallow('animationEasing' + postfix);\r\n\r\n        animatableModel && animatableModel.getShallow('animation')\r\n            ? el.animateTo(props, duration, animationEasing, cb)\r\n            : (el.attr(props), cb && cb());\r\n    }\r\n    /**\r\n     * Update graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\r\n    /**\r\n     * Init graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\r\n    /**\r\n     * Get transform matrix of target (param target),\r\n     * in coordinate of its ancestor (param ancestor)\r\n     *\r\n     * @param {module:zrender/mixin/Transformable} target\r\n     * @param {module:zrender/mixin/Transformable} ancestor\r\n     */\r\n    graphic.getTransform = function (target, ancestor) {\r\n        var mat = matrix.identity([]);\r\n\r\n        while (target && target !== ancestor) {\r\n            matrix.mul(mat, target.getLocalTransform(), mat);\r\n            target = target.parent;\r\n        }\r\n\r\n        return mat;\r\n    };\r\n\r\n    /**\r\n     * Apply transform to an vertex.\r\n     * @param {Array.<number>} vertex [x, y]\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {Array.<number>} [x, y]\r\n     */\r\n    graphic.applyTransform = function (vertex, transform, invert) {\r\n        if (invert) {\r\n            transform = matrix.invert([], transform);\r\n        }\r\n        return vector.applyTransform([], vertex, transform);\r\n    };\r\n\r\n    /**\r\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n     */\r\n    graphic.transformDirection = function (direction, transform, invert) {\r\n\r\n        // Pick a base, ensure that transform result will not be (0, 0).\r\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\r\n        var vertex = [\r\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n        ];\r\n\r\n        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\r\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n            ? (vertex[0] > 0 ? 'right' : 'left')\r\n            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n    };\r\n\r\n    module.exports = graphic;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/graphic.js\n// module id = 4\n// module chunks = 0","/**\n * @module zrender/core/util\n */\n\n\n    // 用于处理merge时无法遍历Date等对象的问题\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            var Ctor = source.constructor;\n            if (source.constructor.from) {\n                result = Ctor.from(source);\n            }\n            else {\n                result = new Ctor(source.length);\n                for (var i = 0, len = source.length; i < len; i++) {\n                    result[i] = clone(source[i]);\n                }\n            }\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuiltInObject(sourceProp)\n                    && !isBuiltInObject(targetProp)\n                    && !isPrimitive(sourceProp)\n                    && !isPrimitive(targetProp)\n                ) {\n                    // 如果需要递归覆盖，就递归调用merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * 查询数组中元素的index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * 构造类继承关系\n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz 源类\n     * @param {Function} baseClazz 基类\n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * Consider typed array.\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * 数组或对象遍历\n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * 数组映射\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * 数组过滤\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * 数组项查找\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuiltInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * Whether is exactly NaN. Notice isNaN('a') returns true.\n     * @param {*} value\n     * @return {boolean}\n     */\n    function eqNaN(value) {\n        return value !== value;\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * Low performance.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    function retrieve2(value0, value1) {\n        return value0 != null\n            ? value0\n            : value1;\n    }\n\n    function retrieve3(value0, value1, value2) {\n        return value0 != null\n            ? value0\n            : value1 != null\n            ? value1\n            : value2;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     * @return {Array.<number>}\n     */\n    function normalizeCssArray(val) {\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        var len = val.length;\n        if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var primitiveKey = '__ec_primitive__';\n    /**\n     * Set an object as primitive to be ignored traversing children in clone or merge\n     */\n    function setAsPrimitive(obj) {\n        obj[primitiveKey] = true;\n    }\n\n    function isPrimitive(obj) {\n        return obj[primitiveKey];\n    }\n\n    /**\n     * @constructor\n     * @param {Object} obj Only apply `ownProperty`.\n     */\n    function HashMap(obj) {\n        obj && each(obj, function (value, key) {\n            this.set(key, value);\n        }, this);\n    }\n\n    // Add prefix to avoid conflict with Object.prototype.\n    var HASH_MAP_PREFIX = '_ec_';\n    var HASH_MAP_PREFIX_LENGTH = 4;\n\n    HashMap.prototype = {\n        constructor: HashMap,\n        // Do not provide `has` method to avoid defining what is `has`.\n        // (We usually treat `null` and `undefined` as the same, different\n        // from ES6 Map).\n        get: function (key) {\n            return this[HASH_MAP_PREFIX + key];\n        },\n        set: function (key, value) {\n            this[HASH_MAP_PREFIX + key] = value;\n            // Comparing with invocation chaining, `return value` is more commonly\n            // used in this case: `var someVal = map.set('a', genVal());`\n            return value;\n        },\n        // Although util.each can be performed on this hashMap directly, user\n        // should not use the exposed keys, who are prefixed.\n        each: function (cb, context) {\n            context !== void 0 && (cb = bind(cb, context));\n            for (var prefixedKey in this) {\n                this.hasOwnProperty(prefixedKey)\n                    && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n            }\n        },\n        // Do not use this method if performance sensitive.\n        removeKey: function (key) {\n            delete this[HASH_MAP_PREFIX + key];\n        }\n    };\n\n    function createHashMap(obj) {\n        return new HashMap(obj);\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuiltInObject: isBuiltInObject,\n        isDom: isDom,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        retrieve2: retrieve2,\n        retrieve3: retrieve3,\n        assert: assert,\n        setAsPrimitive: setAsPrimitive,\n        createHashMap: createHashMap,\n        normalizeCssArray: normalizeCssArray,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/core/util.js\n// module id = 5\n// module chunks = 0","\n\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            if (path.setData) {\n                path.setData(pathProxy.data);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            }\n            else {\n                var ctx = path;\n                pathProxy.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            transformPath(pathProxy, m);\n\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (!pathEl.path) {\n                    pathEl.createPathProxy();\n                }\n                if (pathEl.__dirtyPath) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            // Need path proxy.\n            pathBundle.createPathProxy();\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/tool/path.js\n// module id = 6\n// module chunks = 0","/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    var pathProxyForDraw = new PathProxy(true);\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = null;\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path || pathProxyForDraw;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect;\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath\n                || (lineDash && !ctxLineDash && hasStroke)\n            ) {\n                path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                if (this.path) {\n                    this.__dirtyPath = false;\n                }\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        createPathProxy: function () {\n            this.path = new PathProxy();\n        },\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (!path) {\n                    // Create path on demand.\n                    path = this.path = new PathProxy();\n                }\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     * 扩展一个 Path element, 比如星形，圆等。\n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME 不能 extend position, rotation 等引用对象\n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/Path.js\n// module id = 7\n// module chunks = 0","/**\n * 可绘制的图形基类\n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = require('../core/util');\n\n    var Style = require('./Style');\n\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style, this);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * z层level，决定绘画在哪层canvas中\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * 是否可拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * 是否正在拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * 是否相应鼠标事件\n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * 图形绘制方法\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * 获取最小包围盒\n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         * 判断坐标 x, y 是否在图形上\n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         * 判断坐标 x, y 是否在图形的包围盒上\n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * 标记图形元素为脏，并且在下一帧重绘\n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * 图形是否会触发事件\n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO, 通过 bind 绑定的事件\n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj, this);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/Displayable.js\n// module id = 8\n// module chunks = 0","/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts, host) {\n        this.extendFrom(opts, false);\n        this.host = host;\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        var x = obj.x == null ? 0 : obj.x;\n        var x2 = obj.x2 == null ? 1 : obj.x2;\n        var y = obj.y == null ? 0 : obj.y;\n        var y2 = obj.y2 == null ? 0 : obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x == null ? 0.5 : obj.x;\n        var y = obj.y == null ? 0.5 : obj.y;\n        var r = obj.r == null ? 0.5 : obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {module:zrender/graphic/Displayable}\n         */\n        host: null,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * If `fontSize` or `fontFamily` exists, `font` will be reset by\n         * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n         * So do not visit it directly in upper application (like echarts),\n         * but use `contain/text#makeFont` instead.\n         * @type {string}\n         */\n        font: null,\n\n        /**\n         * The same as font. Use font please.\n         * @deprecated\n         * @type {string}\n         */\n        textFont: null,\n\n        /**\n         * It helps merging respectively, rather than parsing an entire font string.\n         * @type {string}\n         */\n        fontStyle: null,\n\n        /**\n         * It helps merging respectively, rather than parsing an entire font string.\n         * @type {string}\n         */\n        fontWeight: null,\n\n        /**\n         * It helps merging respectively, rather than parsing an entire font string.\n         * Should be 12 but not '12px'.\n         * @type {number}\n         */\n        fontSize: null,\n\n        /**\n         * It helps merging respectively, rather than parsing an entire font string.\n         * @type {string}\n         */\n        fontFamily: null,\n\n        /**\n         * Reserved for special functinality, like 'hr'.\n         * @type {string}\n         */\n        textTag: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * @type {number}\n         */\n        textWidth: null,\n\n        /**\n         * Only for textBackground.\n         * @type {number}\n         */\n        textHeight: null,\n\n        /**\n         * textStroke may be set as some color as a default\n         * value in upper applicaion, where the default value\n         * of textStrokeWidth should be 0 to make sure that\n         * user can choose to do not use text stroke.\n         * @type {number}\n         */\n        textStrokeWidth: 0,\n\n        /**\n         * @type {number}\n         */\n        textLineHeight: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * Based on x, y of rect.\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * If not specified, use the boundingRect of a `displayable`.\n         * @type {Object}\n         */\n        textRect: null,\n\n        /**\n         * [x, y]\n         * @type {Array.<number>}\n         */\n        textOffset: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * @type {string}\n         */\n        textShadowColor: 'transparent',\n\n        /**\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * @type {string}\n         */\n        textBoxShadowColor: 'transparent',\n\n        /**\n         * @type {number}\n         */\n        textBoxShadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        textBoxShadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        textBoxShadowOffsetY: 0,\n\n        /**\n         * Whether transform text.\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        transformText: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and transformText is false.\n         */\n        textRotation: 0,\n\n        /**\n         * Text origin of text rotation, like [10, 40].\n         * Based on x, y of rect.\n         * Useful in label rotation of circular symbol.\n         * By default, this origin is textPosition.\n         * Can be 'center'.\n         * @type {string|Array.<number>}\n         */\n        textOrigin: null,\n\n        /**\n         * @type {string}\n         */\n        textBackgroundColor: null,\n\n        /**\n         * @type {string}\n         */\n        textBorderColor: null,\n\n        /**\n         * @type {number}\n         */\n        textBorderWidth: 0,\n\n        /**\n         * @type {number}\n         */\n        textBorderRadius: 0,\n\n        /**\n         * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n         * @type {number|Array.<number>}\n         */\n        textPadding: null,\n\n        /**\n         * Text styles for rich text.\n         * @type {Object}\n         */\n        rich: null,\n\n        /**\n         * {outerWidth, outerHeight, ellipsis, placeholder}\n         * @type {Object}\n         */\n        truncate: null,\n\n        /**\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         * @type {string}\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite true: overwrirte any way.\n         *                            false: overwrite only when !target.hasOwnProperty\n         *                            others: overwrite when property is not null/undefined.\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite === true\n                            || (\n                                overwrite === false\n                                    ? !this.hasOwnProperty(name)\n                                    : otherStyle[name] != null\n                            )\n                        )\n                    ) {\n                        this[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/Style.js\n// module id = 9\n// module chunks = 0","'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * 画布元素ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * 元素类型\n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * 元素名字\n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n         * 该路径会继承被裁减对象的变换\n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // 添加动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // 移除动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/Element.js\n// module id = 10\n// module chunks = 0","/**\n * zrender: 生成唯一id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/core/guid.js\n// module id = 11\n// module chunks = 0","/**\n * 事件扩展\n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * 事件分发器\n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * 单次触发绑定，trigger后销毁\n         *\n         * @param {string} event 事件名\n         * @param {Function} handler 响应函数\n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 绑定事件\n         * @param {string} event 事件名\n         * @param {Function} handler 事件处理函数\n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 是否绑定了事件\n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * 解绑事件\n         * @param {string} event 事件名\n         * @param {Function} [handler] 事件处理函数\n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * 事件分发\n         *\n         * @param {string} type 事件类型\n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * 带有context的事件分发, 最后一个参数是事件回调的context\n         * @param {string} type 事件类型\n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    // 对象可以通过 onxxxx 绑定事件\n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/mixin/Eventful.js\n// module id = 12\n// module chunks = 0","'use strict';\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * 平移\n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * 旋转\n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * 缩放\n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * 旋转和缩放的原点\n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * 判断是否需要有坐标变换\n     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // 应用父节点变换\n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // 保存这个变换矩阵\n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        return Transformable.getLocalTransform(this, m);\n    };\n\n    /**\n     * 将自己的transform应用到context上\n     * @param {CanvasRenderingContext2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {        \n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    };\n\n    var tmpTransform = [];\n\n    /**\n     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     * 变换坐标位置到 shape 的局部坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * 变换局部坐标位置到全局坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    /**\n     * @static\n     * @param {Object} target\n     * @param {Array.<number>} target.origin\n     * @param {number} target.rotation\n     * @param {Array.<number>} target.position\n     * @param {Array.<number>} [m]\n     */\n    Transformable.getLocalTransform = function (target, m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = target.origin;\n        var scale = target.scale || [1, 1];\n        var rotation = target.rotation || 0;\n        var position = target.position || [0, 0];\n\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n\n    module.exports = Transformable;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/mixin/Transformable.js\n// module id = 13\n// module chunks = 0","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2矩阵操作类\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * 创建一个单位矩阵\n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * 设置矩阵为单位矩阵\n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * 复制矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * 矩阵相乘\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * 平移变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * 旋转变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * 缩放变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * 求逆矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/core/matrix.js\n// module id = 14\n// module chunks = 0","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * 二维向量类\n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * 创建一个向量\n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * 复制向量数据\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 克隆一个向量\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 设置向量的两个项\n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} 结果\n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * 向量相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * 向量缩放后相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * 向量相减\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * 向量长度\n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * 向量长度平方\n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * 向量乘法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * 向量除法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * 向量点乘\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * 向量缩放\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * 向量归一化\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * 计算向量间距离\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * 向量距离平方\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * 求负向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * 插值两个点\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * 矩阵左乘向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * 求两个向量最小值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * 求两个向量最大值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/core/vector.js\n// module id = 15\n// module chunks = 0","'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * 动画\n         *\n         * @param {string} path The path to fetch value from object, like 'a.b.c'.\n         * @param {boolean} [loop] Whether to loop animation.\n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * Caution: this method will stop previous animation.\n         * So do not use this method to one element twice before\n         * animation starts, unless you know what you are doing.\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         * @param {Function} [forceAnimate] Prevent stop animation and callback\n         *        immediently when target values are the same as current values.\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing, forceAnimate);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/mixin/Animatable.js\n// module id = 16\n// module chunks = 0","/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = len && p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function getArrayDim(keyframes) {\n        var lastValue = keyframes[keyframes.length - 1].value;\n        return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n    }\n\n    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (!forceAnimate && isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * 设置动画关键帧\n         * @param  {number} time 关键帧时间，单位是ms\n         * @param  {Object} props 关键帧的属性值，key-value表示\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * 添加动画每一帧的回调函数\n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        pause: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].pause();\n            }\n            this._paused = true;\n        },\n\n        resume: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].resume();\n            }\n            this._paused = false;\n        },\n\n        isPaused: function () {\n            return !!this._paused;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * 开始执行动画\n         * @param  {string|Function} [easing]\n         *         动画缓动函数，详见{@link module:zrender/animation/easing}\n         * @param  {boolean} forceAnimate\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing, forceAnimate) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName, forceAnimate\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            // This optimization will help the case that in the upper application\n            // the view may be refreshed frequently, where animation will be\n            // called repeatly but nothing changed.\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * 设置动画延迟开始的时间\n         * @param  {number} time 单位ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * 添加动画结束的回调\n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/animation/Animator.js\n// module id = 17\n// module chunks = 0","/**\n * 动画主控制器\n * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n * @config life(1000) 动画时长\n * @config delay(0) 动画延迟时间\n * @config loop(true)\n * @config gap(0) 循环的间隔时间\n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = require('./easing');\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // 生命周期\n        this._life = options.life || 1000;\n        // 延时\n        this._delay = options.delay || 0;\n        // 开始时间\n        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n        this._initialized = false;\n\n        // 是否循环\n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n\n        this._pausedTime = 0;\n        this._paused = false;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime, deltaTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            if (this._paused) {\n                this._pausedTime += deltaTime;\n                return;\n            }\n\n            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n\n            // 还没开始\n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // 结束\n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // 重新开始周期\n                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n                    return 'restart';\n                }\n\n                // 动画完成将这个控制器标识为待删除\n                // 在Animation.update中进行批量删除\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._pausedTime = 0;\n\n            this._needsRemove = false;\n        },\n\n        fire: function (eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        },\n\n        pause: function () {\n            this._paused = true;\n        },\n\n        resume: function () {\n            this._paused = false;\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/animation/Clip.js\n// module id = 18\n// module chunks = 0","/**\n * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // 三次方的缓动（t^3）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // 四次方的缓动（t^4）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // 五次方的缓动（t^5）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // 正弦曲线的缓动（sin(t)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 指数曲线的缓动（2^t）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // 圆形曲线的缓动（sqrt(1-t^2)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // 创建类似于弹簧在停止前来回振荡的动画\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // 创建弹跳效果\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/animation/easing.js\n// module id = 19\n// module chunks = 0","/**\n * @module zrender/tool/color\n */\n\n\n    var LRU = require('../core/LRU');\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerpNumber(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    function setRgba(out, r, g, b, a) {\n        out[0] = r; out[1] = g; out[2] = b; out[3] = a;\n        return out;\n    }\n    function copyRgba(out, a) {\n        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n        return out;\n    }\n    var colorCache = new LRU(20);\n    var lastRemovedArr = null;\n    function putToCache(colorStr, rgbaArr) {\n        // Reuse removed array\n        if (lastRemovedArr) {\n            copyRgba(lastRemovedArr, rgbaArr);\n        }\n        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n    }\n    /**\n     * @param {string} colorStr\n     * @param {Array.<number>} out\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr, rgbaArr) {\n        if (!colorStr) {\n            return;\n        }\n        rgbaArr = rgbaArr || [];\n\n        var cached = colorCache.get(colorStr);\n        if (cached) {\n            return copyRgba(rgbaArr, cached);\n        }\n\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            copyRgba(rgbaArr, kCSSColorTable[str]);\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    setRgba(rgbaArr,\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    );\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsla':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsl':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                default:\n                    return;\n            }\n        }\n\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla, rgba) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        rgba = rgba || [];\n        setRgba(rgba,\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),\n            1\n        );\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than lerp methods because color is represented by rgba array.\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>} will be null/undefined if input illegal.\n     */\n    function fastLerp(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        out = out || [];\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n\n        return out;\n    }\n\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function lerp(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<number>} arrColor like [12,33,44,0.4]\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color. (If input illegal, return undefined).\n     */\n    function stringify(arrColor, type) {\n        if (!arrColor || !arrColor.length) {\n            return;\n        }\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastLerp: fastLerp,\n        fastMapToColor: fastLerp, // Deprecated\n        lerp: lerp,\n        mapToColor: lerp, // Deprecated\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/tool/color.js\n// module id = 20\n// module chunks = 0","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function () {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function (val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function (entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            entry.next = null;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function (entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function () {\n        return this._len;\n    };\n\n    /**\n     * Clear list\n     */\n    linkedListProto.clear = function () {\n        this.head = this.tail = null;\n        this._len = 0;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function (val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function (maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n\n        this._lastRemovedEntry = null;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     * @return {} Removed value\n     */\n    LRUProto.put = function (key, value) {\n        var list = this._list;\n        var map = this._map;\n        var removed = null;\n        if (map[key] == null) {\n            var len = list.len();\n            // Reuse last removed entry\n            var entry = this._lastRemovedEntry;\n\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n\n                removed = leastUsedEntry.value;\n                this._lastRemovedEntry = leastUsedEntry;\n            }\n\n            if (entry) {\n                entry.value = value;\n            }\n            else {\n                entry = new Entry(value);\n            }\n            entry.key = key;\n            list.insertEntry(entry);\n            map[key] = entry;\n        }\n\n        return removed;\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function (key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function () {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/core/LRU.js\n// module id = 21\n// module chunks = 0","\n        var config = require('../config');\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/core/log.js\n// module id = 22\n// module chunks = 0","\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config默认配置项\n     * @exports zrender/config\n     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debug日志选项：catchBrushException为true下有效\n         * 0 : 不生成debug数据，发布用\n         * 1 : 异常抛出，调试用\n         * 2 : 控制台输出，调试用\n         */\n        debugMode: 0,\n\n        // retina 屏幕优化\n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/config.js\n// module id = 23\n// module chunks = 0","/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textHelper = require('../helper/text');\n    var BoundingRect = require('../../core/BoundingRect');\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext2D} ctx\n         * @param  {Object} rect Displayable rect\n         */\n        drawRectText: function (ctx, rect) {\n            var style = this.style;\n\n            rect = style.textRect || rect;\n\n            // Optimize, avoid normalize every time.\n            this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            if (!textHelper.needDrawText(text, style)) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.transformText) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // transformText and textRotation can not be used at the same time.\n            textHelper.renderText(this, ctx, text, style, rect);\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/mixin/RectText.js\n// module id = 24\n// module chunks = 0","\n\n    var textContain = require('../../contain/text');\n    var util = require('../../core/util');\n    var roundRectHelper = require('./roundRect');\n    var imageHelper = require('./image');\n\n    var retrieve3 = util.retrieve3;\n    var retrieve2 = util.retrieve2;\n\n    // TODO: Have not support 'start', 'end' yet.\n    var VALID_TEXT_ALIGN = {left: 1, right: 1, center: 1};\n    var VALID_TEXT_VERTICAL_ALIGN = {top: 1, bottom: 1, middle: 1};\n\n    var helper = {};\n\n    /**\n     * @param {module:zrender/graphic/Style} style\n     * @return {module:zrender/graphic/Style} The input style.\n     */\n    helper.normalizeTextStyle = function (style) {\n        normalizeStyle(style);\n        util.each(style.rich, normalizeStyle);\n        return style;\n    };\n\n    function normalizeStyle(style) {\n        if (style) {\n\n            style.font = textContain.makeFont(style);\n\n            var textAlign = style.textAlign;\n            textAlign === 'middle' && (textAlign = 'center');\n            style.textAlign = (\n                textAlign == null || VALID_TEXT_ALIGN[textAlign]\n            ) ? textAlign : 'left';\n\n            // Compatible with textBaseline.\n            var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n            textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n            style.textVerticalAlign = (\n                textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign]\n            ) ? textVerticalAlign : 'top';\n\n            var textPadding = style.textPadding;\n            if (textPadding) {\n                style.textPadding = util.normalizeCssArray(style.textPadding);\n            }\n        }\n    }\n\n    /**\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {string} text\n     * @param {module:zrender/graphic/Style} style\n     * @param {Object|boolean} [rect] {x, y, width, height}\n     *                  If set false, rect text is not used.\n     */\n    helper.renderText = function (hostEl, ctx, text, style, rect) {\n        style.rich\n            ? renderRichText(hostEl, ctx, text, style, rect)\n            : renderPlainText(hostEl, ctx, text, style, rect);\n    };\n\n    function renderPlainText(hostEl, ctx, text, style, rect) {\n        var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n\n        var textPadding = style.textPadding;\n\n        var contentBlock = hostEl.__textCotentBlock;\n        if (!contentBlock || hostEl.__dirty) {\n            contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(\n                text, font, textPadding, style.truncate\n            );\n        }\n\n        var outerHeight = contentBlock.outerHeight;\n\n        var textLines = contentBlock.lines;\n        var lineHeight = contentBlock.lineHeight;\n\n        var boxPos = getBoxPosition(outerHeight, style, rect);\n        var baseX = boxPos.baseX;\n        var baseY = boxPos.baseY;\n        var textAlign = boxPos.textAlign;\n        var textVerticalAlign = boxPos.textVerticalAlign;\n\n        // Origin of textRotation should be the base point of text drawing.\n        applyTextRotation(ctx, style, rect, baseX, baseY);\n\n        var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n        var textX = baseX;\n        var textY = boxY;\n\n        var needDrawBg = needDrawBackground(style);\n        if (needDrawBg || textPadding) {\n            // Consider performance, do not call getTextWidth util necessary.\n            var textWidth = textContain.getWidth(text, font);\n            var outerWidth = textWidth;\n            textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n            var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n\n            needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n            if (textPadding) {\n                textX = getTextXForPadding(baseX, textAlign, textPadding);\n                textY += textPadding[0];\n            }\n        }\n\n        setCtx(ctx, 'textAlign', textAlign || 'left');\n        // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n        // text will offset downward a little bit in font \"Microsoft YaHei\".\n        setCtx(ctx, 'textBaseline', 'middle');\n\n        // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n        setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n        setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n        setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n        setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0);\n\n        // `textBaseline` is set as 'middle'.\n        textY += lineHeight / 2;\n\n        var textStrokeWidth = style.textStrokeWidth;\n        var textStroke = getStroke(style.textStroke, textStrokeWidth);\n        var textFill = getFill(style.textFill);\n\n        if (textStroke) {\n            setCtx(ctx, 'lineWidth', textStrokeWidth);\n            setCtx(ctx, 'strokeStyle', textStroke);\n        }\n        if (textFill) {\n            setCtx(ctx, 'fillStyle', textFill);\n        }\n\n        for (var i = 0; i < textLines.length; i++) {\n            // Fill after stroke so the outline will not cover the main part.\n            textStroke && ctx.strokeText(textLines[i], textX, textY);\n            textFill && ctx.fillText(textLines[i], textX, textY);\n            textY += lineHeight;\n        }\n    }\n\n    function renderRichText(hostEl, ctx, text, style, rect) {\n        var contentBlock = hostEl.__textCotentBlock;\n\n        if (!contentBlock || hostEl.__dirty) {\n            contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n        }\n\n        drawRichText(hostEl, ctx, contentBlock, style, rect);\n    }\n\n    function drawRichText(hostEl, ctx, contentBlock, style, rect) {\n        var contentWidth = contentBlock.width;\n        var outerWidth = contentBlock.outerWidth;\n        var outerHeight = contentBlock.outerHeight;\n        var textPadding = style.textPadding;\n\n        var boxPos = getBoxPosition(outerHeight, style, rect);\n        var baseX = boxPos.baseX;\n        var baseY = boxPos.baseY;\n        var textAlign = boxPos.textAlign;\n        var textVerticalAlign = boxPos.textVerticalAlign;\n\n        // Origin of textRotation should be the base point of text drawing.\n        applyTextRotation(ctx, style, rect, baseX, baseY);\n\n        var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n        var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n        var xLeft = boxX;\n        var lineTop = boxY;\n        if (textPadding) {\n            xLeft += textPadding[3];\n            lineTop += textPadding[0];\n        }\n        var xRight = xLeft + contentWidth;\n\n        needDrawBackground(style) && drawBackground(\n            hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight\n        );\n\n        for (var i = 0; i < contentBlock.lines.length; i++) {\n            var line = contentBlock.lines[i];\n            var tokens = line.tokens;\n            var tokenCount = tokens.length;\n            var lineHeight = line.lineHeight;\n            var usedWidth = line.width;\n\n            var leftIndex = 0;\n            var lineXLeft = xLeft;\n            var lineXRight = xRight;\n            var rightIndex = tokenCount - 1;\n            var token;\n\n            while (\n                leftIndex < tokenCount\n                && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')\n            ) {\n                placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n                usedWidth -= token.width;\n                lineXLeft += token.width;\n                leftIndex++;\n            }\n\n            while (\n                rightIndex >= 0\n                && (token = tokens[rightIndex], token.textAlign === 'right')\n            ) {\n                placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n                usedWidth -= token.width;\n                lineXRight -= token.width;\n                rightIndex--;\n            }\n\n            // The other tokens are placed as textAlign 'center' if there is enough space.\n            lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n            while (leftIndex <= rightIndex) {\n                token = tokens[leftIndex];\n                // Consider width specified by user, use 'center' rather than 'left'.\n                placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n                lineXLeft += token.width;\n                leftIndex++;\n            }\n\n            lineTop += lineHeight;\n        }\n    }\n\n    function applyTextRotation(ctx, style, rect, x, y) {\n        // textRotation only apply in RectText.\n        if (rect && style.textRotation) {\n            var origin = style.textOrigin;\n            if (origin === 'center') {\n                x = rect.width / 2 + rect.x;\n                y = rect.height / 2 + rect.y;\n            }\n            else if (origin) {\n                x = origin[0] + rect.x;\n                y = origin[1] + rect.y;\n            }\n\n            ctx.translate(x, y);\n            // Positive: anticlockwise\n            ctx.rotate(-style.textRotation);\n            ctx.translate(-x, -y);\n        }\n    }\n\n    function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n        var tokenStyle = style.rich[token.styleName] || {};\n\n        // 'ctx.textBaseline' is always set as 'middle', for sake of\n        // the bias of \"Microsoft YaHei\".\n        var textVerticalAlign = token.textVerticalAlign;\n        var y = lineTop + lineHeight / 2;\n        if (textVerticalAlign === 'top') {\n            y = lineTop + token.height / 2;\n        }\n        else if (textVerticalAlign === 'bottom') {\n            y = lineTop + lineHeight - token.height / 2;\n        }\n\n        !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(\n            hostEl,\n            ctx,\n            tokenStyle,\n            textAlign === 'right'\n                ? x - token.width\n                : textAlign === 'center'\n                ? x - token.width / 2\n                : x,\n            y - token.height / 2,\n            token.width,\n            token.height\n        );\n\n        var textPadding = token.textPadding;\n        if (textPadding) {\n            x = getTextXForPadding(x, textAlign, textPadding);\n            y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n        }\n\n        setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n        setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n        setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n        setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n\n        setCtx(ctx, 'textAlign', textAlign);\n        // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n        // text will offset downward a little bit in font \"Microsoft YaHei\".\n        setCtx(ctx, 'textBaseline', 'middle');\n\n        setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n\n        var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n        var textFill = getFill(tokenStyle.textFill || style.textFill);\n        var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth);\n\n        // Fill after stroke so the outline will not cover the main part.\n        if (textStroke) {\n            setCtx(ctx, 'lineWidth', textStrokeWidth);\n            setCtx(ctx, 'strokeStyle', textStroke);\n            ctx.strokeText(token.text, x, y);\n        }\n        if (textFill) {\n            setCtx(ctx, 'fillStyle', textFill);\n            ctx.fillText(token.text, x, y);\n        }\n    }\n\n    function needDrawBackground(style) {\n        return style.textBackgroundColor\n            || (style.textBorderWidth && style.textBorderColor);\n    }\n\n    // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n    // shape: {x, y, width, height}\n    function drawBackground(hostEl, ctx, style, x, y, width, height) {\n        var textBackgroundColor = style.textBackgroundColor;\n        var textBorderWidth = style.textBorderWidth;\n        var textBorderColor = style.textBorderColor;\n        var isPlainBg = util.isString(textBackgroundColor);\n\n        setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n        setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n        setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n        setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n        if (isPlainBg || (textBorderWidth && textBorderColor)) {\n            ctx.beginPath();\n            var textBorderRadius = style.textBorderRadius;\n            if (!textBorderRadius) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, {\n                    x: x, y: y, width: width, height: height, r: textBorderRadius\n                });\n            }\n            ctx.closePath();\n        }\n\n        if (isPlainBg) {\n            setCtx(ctx, 'fillStyle', textBackgroundColor);\n            ctx.fill();\n        }\n        else if (util.isObject(textBackgroundColor)) {\n            var image = textBackgroundColor.image;\n\n            image = imageHelper.createOrUpdateImage(\n                image, null, hostEl, onBgImageLoaded, textBackgroundColor\n            );\n            if (image && imageHelper.isImageReady(image)) {\n                ctx.drawImage(image, x, y, width, height);\n            }\n        }\n\n        if (textBorderWidth && textBorderColor) {\n            setCtx(ctx, 'lineWidth', textBorderWidth);\n            setCtx(ctx, 'strokeStyle', textBorderColor);\n            ctx.stroke();\n        }\n    }\n\n    function onBgImageLoaded(image, textBackgroundColor) {\n        // Replace image, so that `contain/text.js#parseRichText`\n        // will get correct result in next tick.\n        textBackgroundColor.image = image;\n    }\n\n    function getBoxPosition(blockHeiht, style, rect) {\n        var baseX = style.x || 0;\n        var baseY = style.y || 0;\n        var textAlign = style.textAlign;\n        var textVerticalAlign = style.textVerticalAlign;\n\n        // Text position represented by coord\n        if (rect) {\n            var textPosition = style.textPosition;\n            if (textPosition instanceof Array) {\n                // Percent\n                baseX = rect.x + parsePercent(textPosition[0], rect.width);\n                baseY = rect.y + parsePercent(textPosition[1], rect.height);\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, style.textDistance\n                );\n                baseX = res.x;\n                baseY = res.y;\n                // Default align and baseline when has textPosition\n                textAlign = textAlign || res.textAlign;\n                textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n            }\n\n            // textOffset is only support in RectText, otherwise\n            // we have to adjust boundingRect for textOffset.\n            var textOffset = style.textOffset;\n            if (textOffset) {\n                baseX += textOffset[0];\n                baseY += textOffset[1];\n            }\n        }\n\n        return {\n            baseX: baseX,\n            baseY: baseY,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    }\n\n    function setCtx(ctx, prop, value) {\n        // FIXME ??? performance try\n        // if (ctx.__currentValues[prop] !== value) {\n            // ctx[prop] = ctx.__currentValues[prop] = value;\n        ctx[prop] = value;\n        // }\n        return ctx[prop];\n    }\n\n    /**\n     * @param {string} [stroke] If specified, do not check style.textStroke.\n     * @param {string} [lineWidth] If specified, do not check style.textStroke.\n     * @param {number} style\n     */\n    var getStroke = helper.getStroke = function (stroke, lineWidth) {\n        return (stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none')\n            ? null\n            // TODO pattern and gradient?\n            : (stroke.image || stroke.colorStops)\n            ? '#000'\n            : stroke;\n    };\n\n    var getFill = helper.getFill = function (fill) {\n        return (fill == null || fill === 'none')\n            ? null\n            // TODO pattern and gradient?\n            : (fill.image || fill.colorStops)\n            ? '#000'\n            : fill;\n    };\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    function getTextXForPadding(x, textAlign, textPadding) {\n        return textAlign === 'right'\n            ? (x - textPadding[1])\n            : textAlign === 'center'\n            ? (x + textPadding[3] / 2 - textPadding[1] / 2)\n            : (x + textPadding[3]);\n    }\n\n    /**\n     * @param {string} text\n     * @param {module:zrender/Style} style\n     * @return {boolean}\n     */\n    helper.needDrawText = function (text, style) {\n        return text != null\n            && (text\n                || style.textBackgroundColor\n                || (style.textBorderWidth && style.textBorderColor)\n                || style.textPadding\n            );\n    };\n\n    module.exports = helper;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/helper/text.js\n// module id = 25\n// module chunks = 0","\n\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var imageHelper = require('../graphic/helper/image');\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n\n    var TEXT_CACHE_MAX = 5000;\n    var STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\n    var DEFAULT_FONT = '12px sans-serif';\n\n    var retrieve2 = util.retrieve2;\n    var retrieve3 = util.retrieve3;\n\n    /**\n     * @public\n     * @param {string} text\n     * @param {string} font\n     * @return {number} width\n     */\n    function getTextWidth(text, font) {\n        font = font || DEFAULT_FONT;\n        var key = text + ':' + font;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // textContain.measureText may be overrided in SVG or VML\n            width = Math.max(textContain.measureText(textLines[i], font).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    /**\n     * @public\n     * @param {string} text\n     * @param {string} font\n     * @param {string} [textAlign='left']\n     * @param {string} [textVerticalAlign='top']\n     * @param {Array.<number>} [textPadding]\n     * @param {Object} [rich]\n     * @param {Object} [truncate]\n     * @return {Object} {x, y, width, height, lineHeight}\n     */\n    function getTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n        return rich\n            ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate)\n            : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n    }\n\n    function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n        var contentBlock = parsePlainText(text, font, textPadding, truncate);\n        var outerWidth = getTextWidth(text, font);\n        if (textPadding) {\n            outerWidth += textPadding[1] + textPadding[3];\n        }\n        var outerHeight = contentBlock.outerHeight;\n\n        var x = adjustTextX(0, outerWidth, textAlign);\n        var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\n        var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n        rect.lineHeight = contentBlock.lineHeight;\n\n        return rect;\n    }\n\n    function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n        var contentBlock = parseRichText(text, {\n            rich: rich,\n            truncate: truncate,\n            font: font,\n            textAlign: textAlign,\n            textPadding: textPadding\n        });\n        var outerWidth = contentBlock.outerWidth;\n        var outerHeight = contentBlock.outerHeight;\n\n        var x = adjustTextX(0, outerWidth, textAlign);\n        var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\n        return new BoundingRect(x, y, outerWidth, outerHeight);\n    }\n\n    /**\n     * @public\n     * @param {number} x\n     * @param {number} width\n     * @param {string} [textAlign='left']\n     * @return {number} Adjusted x.\n     */\n    function adjustTextX(x, width, textAlign) {\n        // FIXME Right to left language\n        if (textAlign === 'right') {\n            x -= width;\n        }\n        else if (textAlign === 'center') {\n            x -= width / 2;\n        }\n        return x;\n    }\n\n    /**\n     * @public\n     * @param {number} y\n     * @param {number} height\n     * @param {string} [textVerticalAlign='top']\n     * @return {number} Adjusted y.\n     */\n    function adjustTextY(y, height, textVerticalAlign) {\n        if (textVerticalAlign === 'middle') {\n            y -= height / 2;\n        }\n        else if (textVerticalAlign === 'bottom') {\n            y -= height;\n        }\n        return y;\n    }\n\n    /**\n     * @public\n     * @param {stirng} textPosition\n     * @param {Object} rect {x, y, width, height}\n     * @param {number} distance\n     * @return {Object} {x, y, textAlign, textVerticalAlign}\n     */\n    function adjustTextPositionOnRect(textPosition, rect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n        var halfHeight = height / 2;\n\n        var textAlign = 'left';\n        var textVerticalAlign = 'top';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                textVerticalAlign = 'middle';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textVerticalAlign = 'middle';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance;\n                textAlign = 'center';\n                textVerticalAlign = 'bottom';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                textVerticalAlign = 'middle';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textVerticalAlign = 'middle';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                textVerticalAlign = 'middle';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - distance;\n                textAlign = 'center';\n                textVerticalAlign = 'bottom';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance;\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - distance;\n                textVerticalAlign = 'bottom';\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - distance;\n                textAlign = 'right';\n                textVerticalAlign = 'bottom';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @public\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} font\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, font, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        var textLines = (text + '').split('\\n');\n        options = prepareTruncateOptions(containerWidth, font, ellipsis, options);\n\n        // FIXME\n        // It is not appropriate that every line has '...' when truncate multiple lines.\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            textLines[i] = truncateSingleLine(textLines[i], options);\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n        options = util.extend({}, options);\n\n        options.font = font;\n        var ellipsis = retrieve2(ellipsis, '...');\n        options.maxIterations = retrieve2(options.maxIterations, 2);\n        var minChar = options.minChar = retrieve2(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        options.cnCharWidth = getTextWidth('国', font);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = options.ascCharWidth = getTextWidth('a', font);\n        options.placeholder = retrieve2(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        options.ellipsis = ellipsis;\n        options.ellipsisWidth = ellipsisWidth;\n        options.contentWidth = contentWidth;\n        options.containerWidth = containerWidth;\n\n        return options;\n    }\n\n    function truncateSingleLine(textLine, options) {\n        var containerWidth = options.containerWidth;\n        var font = options.font;\n        var contentWidth = options.contentWidth;\n\n        if (!containerWidth) {\n            return '';\n        }\n\n        var lineWidth = getTextWidth(textLine, font);\n\n        if (lineWidth <= containerWidth) {\n            return textLine;\n        }\n\n        for (var j = 0;; j++) {\n            if (lineWidth <= contentWidth || j >= options.maxIterations) {\n                textLine += options.ellipsis;\n                break;\n            }\n\n            var subLength = j === 0\n                ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth)\n                : lineWidth > 0\n                ? Math.floor(textLine.length * contentWidth / lineWidth)\n                : 0;\n\n            textLine = textLine.substr(0, subLength);\n            lineWidth = getTextWidth(textLine, font);\n        }\n\n        if (textLine === '') {\n            textLine = options.placeholder;\n        }\n\n        return textLine;\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    /**\n     * @public\n     * @param {string} font\n     * @return {number} line height\n     */\n    function getLineHeight(font) {\n        // FIXME A rough approach.\n        return getTextWidth('国', font);\n    }\n\n    /**\n     * @public\n     * @param {string} text\n     * @param {string} font\n     * @return {Object} width\n     */\n    function measureText(text, font) {\n        var ctx = util.getContext();\n        ctx.font = font || DEFAULT_FONT;\n        return ctx.measureText(text);\n    }\n\n    /**\n     * @public\n     * @param {string} text\n     * @param {string} font\n     * @param {Object} [truncate]\n     * @return {Object} block: {lineHeight, lines, height, outerHeight}\n     *  Notice: for performance, do not calculate outerWidth util needed.\n     */\n    function parsePlainText(text, font, padding, truncate) {\n        text != null && (text += '');\n\n        var lineHeight = getLineHeight(font);\n        var lines = text ? text.split('\\n') : [];\n        var height = lines.length * lineHeight;\n        var outerHeight = height;\n\n        if (padding) {\n            outerHeight += padding[0] + padding[2];\n        }\n\n        if (text && truncate) {\n            var truncOuterHeight = truncate.outerHeight;\n            var truncOuterWidth = truncate.outerWidth;\n            if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n                text = '';\n                lines = [];\n            }\n            else if (truncOuterWidth != null) {\n                var options = prepareTruncateOptions(\n                    truncOuterWidth - (padding ? padding[1] + padding[3] : 0),\n                    font,\n                    truncate.ellipsis,\n                    {minChar: truncate.minChar, placeholder: truncate.placeholder}\n                );\n\n                // FIXME\n                // It is not appropriate that every line has '...' when truncate multiple lines.\n                for (var i = 0, len = lines.length; i < len; i++) {\n                    lines[i] = truncateSingleLine(lines[i], options);\n                }\n            }\n        }\n\n        return {\n            lines: lines,\n            height: height,\n            outerHeight: outerHeight,\n            lineHeight: lineHeight\n        };\n    }\n\n    /**\n     * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n     * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n     *\n     * @public\n     * @param {string} text\n     * @param {Object} style\n     * @return {Object} block\n     * {\n     *      width,\n     *      height,\n     *      lines: [{\n     *          lineHeight,\n     *          width,\n     *          tokens: [[{\n     *              styleName,\n     *              text,\n     *              width,      // include textPadding\n     *              height,     // include textPadding\n     *              textWidth, // pure text width\n     *              textHeight, // pure text height\n     *              lineHeihgt,\n     *              font,\n     *              textAlign,\n     *              textVerticalAlign\n     *          }], [...], ...]\n     *      }, ...]\n     * }\n     * If styleName is undefined, it is plain text.\n     */\n    function parseRichText(text, style) {\n        var contentBlock = {lines: [], width: 0, height: 0};\n\n        text != null && (text += '');\n        if (!text) {\n            return contentBlock;\n        }\n\n        var lastIndex = STYLE_REG.lastIndex = 0;\n        var result;\n        while ((result = STYLE_REG.exec(text)) != null)  {\n            var matchedIndex = result.index;\n            if (matchedIndex > lastIndex) {\n                pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n            }\n            pushTokens(contentBlock, result[2], result[1]);\n            lastIndex = STYLE_REG.lastIndex;\n        }\n\n        if (lastIndex < text.length) {\n            pushTokens(contentBlock, text.substring(lastIndex, text.length));\n        }\n\n        var lines = contentBlock.lines;\n        var contentHeight = 0;\n        var contentWidth = 0;\n        // For `textWidth: 100%`\n        var pendingList = [];\n\n        var stlPadding = style.textPadding;\n\n        var truncate = style.truncate;\n        var truncateWidth = truncate && truncate.outerWidth;\n        var truncateHeight = truncate && truncate.outerHeight;\n        if (stlPadding) {\n            truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n            truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n        }\n\n        // Calculate layout info of tokens.\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i];\n            var lineHeight = 0;\n            var lineWidth = 0;\n\n            for (var j = 0; j < line.tokens.length; j++) {\n                var token = line.tokens[j];\n                var tokenStyle = token.styleName && style.rich[token.styleName] || {};\n                // textPadding should not inherit from style.\n                var textPadding = token.textPadding = tokenStyle.textPadding;\n\n                // textFont has been asigned to font by `normalizeStyle`.\n                var font = token.font = tokenStyle.font || style.font;\n\n                // textHeight can be used when textVerticalAlign is specified in token.\n                var tokenHeight = token.textHeight = retrieve2(\n                    // textHeight should not be inherited, consider it can be specified\n                    // as box height of the block.\n                    tokenStyle.textHeight, textContain.getLineHeight(font)\n                );\n                textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n                token.height = tokenHeight;\n                token.lineHeight = retrieve3(\n                    tokenStyle.textLineHeight, style.textLineHeight, tokenHeight\n                );\n\n                token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n                token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n                if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n                    return {lines: [], width: 0, height: 0};\n                }\n\n                token.textWidth = textContain.getWidth(token.text, font);\n                var tokenWidth = tokenStyle.textWidth;\n                var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto';\n\n                // Percent width, can be `100%`, can be used in drawing separate\n                // line when box width is needed to be auto.\n                if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n                    token.percentWidth = tokenWidth;\n                    pendingList.push(token);\n                    tokenWidth = 0;\n                    // Do not truncate in this case, because there is no user case\n                    // and it is too complicated.\n                }\n                else {\n                    if (tokenWidthNotSpecified) {\n                        tokenWidth = token.textWidth;\n\n                        // FIXME: If image is not loaded and textWidth is not specified, calling\n                        // `getBoundingRect()` will not get correct result.\n                        var textBackgroundColor = tokenStyle.textBackgroundColor;\n                        var bgImg = textBackgroundColor && textBackgroundColor.image;\n\n                        // Use cases:\n                        // (1) If image is not loaded, it will be loaded at render phase and call\n                        // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n                        // image, and then the right size will be calculated here at the next tick.\n                        // See `graphic/helper/text.js`.\n                        // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n                        // use `imageHelper.findExistImage` to find cached image.\n                        // `imageHelper.findExistImage` will always be called here before\n                        // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n                        // which ensures that image will not be rendered before correct size calcualted.\n                        if (bgImg) {\n                            bgImg = imageHelper.findExistImage(bgImg);\n                            if (imageHelper.isImageReady(bgImg)) {\n                                tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n                            }\n                        }\n                    }\n\n                    var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n                    tokenWidth += paddingW;\n\n                    var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n                    if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n                        if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n                            token.text = '';\n                            token.textWidth = tokenWidth = 0;\n                        }\n                        else {\n                            token.text = truncateText(\n                                token.text, remianTruncWidth - paddingW, font, truncate.ellipsis,\n                                {minChar: truncate.minChar}\n                            );\n                            token.textWidth = textContain.getWidth(token.text, font);\n                            tokenWidth = token.textWidth + paddingW;\n                        }\n                    }\n                }\n\n                lineWidth += (token.width = tokenWidth);\n                tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n            }\n\n            line.width = lineWidth;\n            line.lineHeight = lineHeight;\n            contentHeight += lineHeight;\n            contentWidth = Math.max(contentWidth, lineWidth);\n        }\n\n        contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n        contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n        if (stlPadding) {\n            contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n            contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n        }\n\n        for (var i = 0; i < pendingList.length; i++) {\n            var token = pendingList[i];\n            var percentWidth = token.percentWidth;\n            // Should not base on outerWidth, because token can not be placed out of padding.\n            token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n        }\n\n        return contentBlock;\n    }\n\n    function pushTokens(block, str, styleName) {\n        var isEmptyStr = str === '';\n        var strs = str.split('\\n');\n        var lines = block.lines;\n\n        for (var i = 0; i < strs.length; i++) {\n            var text = strs[i];\n            var token = {\n                styleName: styleName,\n                text: text,\n                isLineHolder: !text && !isEmptyStr\n            };\n\n            // The first token should be appended to the last line.\n            if (!i) {\n                var tokens = (lines[lines.length - 1] || (lines[0] = {tokens: []})).tokens;\n\n                // Consider cases:\n                // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n                // (which is a placeholder) should be replaced by new token.\n                // (2) A image backage, where token likes {a|}.\n                // (3) A redundant '' will affect textAlign in line.\n                // (4) tokens with the same tplName should not be merged, because\n                // they should be displayed in different box (with border and padding).\n                var tokensLen = tokens.length;\n                (tokensLen === 1 && tokens[0].isLineHolder)\n                    ? (tokens[0] = token)\n                    // Consider text is '', only insert when it is the \"lineHolder\" or\n                    // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n                    : ((text || !tokensLen || isEmptyStr) && tokens.push(token));\n            }\n            // Other tokens always start a new line.\n            else {\n                // If there is '', insert it as a placeholder.\n                lines.push({tokens: [token]});\n            }\n        }\n    }\n\n    function makeFont(style) {\n        // FIXME in node-canvas fontWeight is before fontStyle\n        // Use `fontSize` `fontFamily` to check whether font properties are defined.\n        return (style.fontSize || style.fontFamily) && [\n            style.fontStyle,\n            style.fontWeight,\n            (style.fontSize || 12) + 'px',\n            // If font properties are defined, `fontFamily` should not be ignored.\n            style.fontFamily || 'sans-serif'\n        ].join(' ') || style.textFont || style.font;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: measureText,\n\n        getLineHeight: getLineHeight,\n\n        parsePlainText: parsePlainText,\n\n        parseRichText: parseRichText,\n\n        adjustTextX: adjustTextX,\n\n        adjustTextY: adjustTextY,\n\n        makeFont: makeFont,\n\n        DEFAULT_FONT: DEFAULT_FONT\n    };\n\n    module.exports = textContain;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/contain/text.js\n// module id = 26\n// module chunks = 0","'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // 矩阵右乘\n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/core/BoundingRect.js\n// module id = 27\n// module chunks = 0","\n\n    var LRU = require('../../core/LRU');\n    var globalImageCache = new LRU(50);\n\n    var helper = {};\n\n    /**\n     * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n     * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n     */\n    helper.findExistImage = function (newImageOrSrc) {\n        if (typeof newImageOrSrc === 'string') {\n            var cachedImgObj = globalImageCache.get(newImageOrSrc);\n            return cachedImgObj && cachedImgObj.image;\n        }\n        else {\n            return newImageOrSrc;\n        }\n    };\n\n    /**\n     * Caution: User should cache loaded images, but not just count on LRU.\n     * Consider if required images more than LRU size, will dead loop occur?\n     *\n     * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n     * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n     * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n     * @param {Function} [cb] params: (image, cbPayload)\n     * @param {Object} [cbPayload] Payload on cb calling.\n     * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n     */\n    helper.createOrUpdateImage = function (newImageOrSrc, image, hostEl, cb, cbPayload) {\n        if (!newImageOrSrc) {\n            return image;\n        }\n        else if (typeof newImageOrSrc === 'string') {\n\n            // Image should not be loaded repeatly.\n            if ((image && image.__zrImageSrc === newImageOrSrc) || !hostEl) {\n                return image;\n            }\n\n            // Only when there is no existent image or existent image src\n            // is different, this method is responsible for load.\n            var cachedImgObj = globalImageCache.get(newImageOrSrc);\n\n            var pendingWrap = {hostEl: hostEl, cb: cb, cbPayload: cbPayload};\n\n            if (cachedImgObj) {\n                image = cachedImgObj.image;\n                !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n            }\n            else {\n                !image && (image = new Image());\n                image.onload = imageOnLoad;\n\n                globalImageCache.put(\n                    newImageOrSrc,\n                    image.__cachedImgObj = {\n                        image: image,\n                        pending: [pendingWrap]\n                    }\n                );\n\n                image.src = image.__zrImageSrc = newImageOrSrc;\n            }\n\n            return image;\n        }\n        // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n        else {\n            return newImageOrSrc;\n        }\n    };\n\n    function imageOnLoad() {\n        var cachedImgObj = this.__cachedImgObj;\n        this.onload = this.__cachedImgObj = null;\n\n        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n            var pendingWrap = cachedImgObj.pending[i];\n            var cb = pendingWrap.cb;\n            cb && cb(this, pendingWrap.cbPayload);\n            pendingWrap.hostEl.dirty();\n        }\n        cachedImgObj.pending.length = 0;\n    }\n\n    var isImageReady = helper.isImageReady = function (image) {\n        return image && image.width && image.height;\n    };\n\n    module.exports = helper;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/helper/image.js\n// module id = 28\n// module chunks = 0","\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/helper/roundRect.js\n// module id = 29\n// module chunks = 0","'use strict';\n/**\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n * 可以用于 isInsidePath 判断以及获取boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    // var CMD_MEM_SIZE = {\n    //     M: 3,\n    //     L: 3,\n    //     C: 7,\n    //     Q: 5,\n    //     A: 9,\n    //     R: 5,\n    //     Z: 1\n    // };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function (notSaveData) {\n\n        this._saveData = !(notSaveData || false);\n\n        if (this._saveData) {\n            /**\n             * Path data. Stored as flat array\n             * @type {Array.<Object>}\n             */\n            this.data = [];\n        }\n\n        this._ctx = null;\n    };\n\n    /**\n     * 快速计算Path包围盒（并不是最小包围盒）\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _xi: 0,\n        _yi: 0,\n\n        _x0: 0,\n        _y0: 0,\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        _ux: 0,\n        _uy: 0,\n\n        _len: 0,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            if (this._saveData) {\n                this._len = 0;\n            }\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._yi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n         * stroke 同样\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         * 直接设置 Path 数据\n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * 添加子路径\n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         * 填充 Path 数据。\n         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n         */\n        addData: function (cmd) {\n            if (!this._saveData) {\n                return;\n            }\n\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                // 因为之前的数组已经转换成静态的 Float32Array\n                // 所以不够用时需要扩展一个新的动态数组\n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         * 转成静态的 Float32Array 减少堆内存占用\n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                        // 在 closePath 的时候使用\n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc 判断的开销比较大\n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc 旋转\n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/core/PathProxy.js\n// module id = 30\n// module chunks = 0","'use strict';\n/**\n * 曲线辅助模块\n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // 临时变量\n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * 计算三次贝塞尔值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * 计算三次贝塞尔导数值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * 计算三次贝塞尔方程根，使用盛金公式\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算三次贝塞尔方程极限值的位置\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} 有效数目\n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 细分三次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * 投射点到三次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] 投射点\n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * 计算二次方贝塞尔值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * 计算二次方贝塞尔导数值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * 计算二次方贝塞尔方程根\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算二次贝塞尔方程极限值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * 细分二次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * 投射点到二次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out 投射点\n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/core/curve.js\n// module id = 31\n// module chunks = 0","/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points 顶点数组\n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/core/bbox.js\n// module id = 32\n// module chunks = 0","'use strict';\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n\n    var windingLine = require('./windingLine');\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // 临时数组\n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // 分成三段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // 分成两段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc 旋转\n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                // 如果被任何一个 subpath 包含\n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                // 如果第一个命令是 L, C, Q\n                // 则 previous point 同绘制命令的第一个 point\n                //\n                // 第一个命令为 Arc 的情况下会在后面特殊处理\n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                    // 在 closePath 的时候使用\n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc 判断的开销比较大\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc 旋转\n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    // 不是直接使用 arc 命令\n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // 第一个命令起点还未定义\n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        // 如果被任何一个 subpath 包含\n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/contain/path.js\n// module id = 33\n// module chunks = 0","\n    module.exports = {\n        /**\n         * 线段包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/contain/line.js\n// module id = 34\n// module chunks = 0","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * 三次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/contain/cubic.js\n// module id = 35\n// module chunks = 0","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * 二次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/contain/quadratic.js\n// module id = 36\n// module chunks = 0","\n\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * 圆弧描边包含判断\n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/contain/arc.js\n// module id = 37\n// module chunks = 0","\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/contain/util.js\n// module id = 38\n// module chunks = 0","\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/contain/windingLine.js\n// module id = 39\n// module chunks = 0","\n\n    var Pattern = function (image, repeat) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {image: ...}`, where this constructor will not be called.\n\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n        return ctx.createPattern(this.image, this.repeat || 'repeat');\n    };\n\n    module.exports = Pattern;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/Pattern.js\n// module id = 40\n// module chunks = 0","\n\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i] *= sx;\n                    data[i++] += x;\n                    // cy\n                    data[i] *= sy;\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/tool/transformPath.js\n// module id = 41\n// module chunks = 0","\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n\n    };\n\n    module.exports = Gradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/Gradient.js\n// module id = 42\n// module chunks = 0","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget).target;\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    function param(target, e) {\n        return {target: target, topTarget: e && e.topTarget};\n    }\n\n    module.exports = Draggable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/mixin/Draggable.js\n// module id = 43\n// module chunks = 0","/**\n * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * 所有子孙元素是否响应鼠标事件\n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         * 获取指定 index 的儿子节点\n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * 获取指定名字的儿子节点\n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * 添加子节点到最后\n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         * 添加子节点在 nextSibling 之前\n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToStorage(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * 移除子节点\n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromStorage(child);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * 移除所有子节点\n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromStorage(child);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * 遍历所有子节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * 深度优先遍历所有子孙节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToStorage(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromStorage(child);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/container/Group.js\n// module id = 44\n// module chunks = 0","/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n    var imageHelper = require('./helper/image');\n\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n\n            var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this);\n\n            if (!image || !imageHelper.isImageReady(image)) {\n                return;\n            }\n\n            // 图片已经加载完成\n            // if (image.nodeName.toUpperCase() == 'IMG') {\n            //     if (!image.complete) {\n            //         return;\n            //     }\n            // }\n            // Else is canvas\n\n            var x = style.x || 0;\n            var y = style.y || 0;\n            var width = style.width;\n            var height = style.height;\n            var aspect = image.width / image.height;\n            if (width == null && height != null) {\n                // Keep image/height ratio\n                width = height * aspect;\n            }\n            else if (height == null && width != null) {\n                height = width / aspect;\n            }\n            else if (width == null && height == null) {\n                width = image.width;\n                height = image.height;\n            }\n\n            // 设置transform\n            this.setTransform(ctx);\n\n            if (style.sWidth && style.sHeight) {\n                var sx = style.sx || 0;\n                var sy = style.sy || 0;\n                ctx.drawImage(\n                    image,\n                    sx, sy, style.sWidth, style.sHeight,\n                    x, y, width, height\n                );\n            }\n            else if (style.sx && style.sy) {\n                var sx = style.sx;\n                var sy = style.sy;\n                var sWidth = width - sx;\n                var sHeight = height - sy;\n                ctx.drawImage(\n                    image,\n                    sx, sy, sWidth, sHeight,\n                    x, y, width, height\n                );\n            }\n            else {\n                ctx.drawImage(image, x, y, width, height);\n            }\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/Image.js\n// module id = 45\n// module chunks = 0","/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n    var textHelper = require('./helper/text');\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n\n            // Optimize, avoid normalize every time.\n            this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n            // Use props with prefix 'text'.\n            style.fill = style.stroke = style.shadowBlur = style.shadowColor =\n                style.shadowOffsetX = style.shadowOffsetY = null;\n\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (!textHelper.needDrawText(text, style)) {\n                return;\n            }\n\n            this.setTransform(ctx);\n\n            textHelper.renderText(this, ctx, text, style);\n\n            this.restoreTransform(ctx);\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n\n            // Optimize, avoid normalize every time.\n            this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n            if (!this._rect) {\n                var text = style.text;\n                text != null ? (text += '') : (text = '');\n\n                var rect = textContain.getBoundingRect(\n                    style.text + '',\n                    style.font,\n                    style.textAlign,\n                    style.textVerticalAlign,\n                    style.textPadding,\n                    style.rich\n                );\n\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n\n                if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {\n                    var w = style.textStrokeWidth;\n                    rect.x -= w / 2;\n                    rect.y -= w / 2;\n                    rect.width += w;\n                    rect.height += w;\n                }\n\n                this._rect = rect;\n            }\n\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/Text.js\n// module id = 46\n// module chunks = 0","'use strict';\n/**\n * 圆形\n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // else {\n            //     if (ctx.allocate && !ctx.data.length) {\n            //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n            //     }\n            // }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/shape/Circle.js\n// module id = 47\n// module chunks = 0","/**\n * 扇形\n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    var Path = require('../Path');\n    var fixClipWithShadow = require('../helper/fixClipWithShadow');\n\n    module.exports = Path.extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        brush: fixClipWithShadow(Path.prototype.brush),\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/shape/Sector.js\n// module id = 48\n// module chunks = 0","\n\n    var env = require('../../core/env');\n\n    // Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n    // where exception \"unexpected call to method or property access\"\n    // might be thrown when calling ctx.fill or ctx.stroke after a path\n    // whose area size is zero is drawn and ctx.clip() is called and\n    // shadowBlur is set. See #4572, #3112, #5777.\n    // (e.g.,\n    //  ctx.moveTo(10, 10);\n    //  ctx.lineTo(20, 10);\n    //  ctx.closePath();\n    //  ctx.clip();\n    //  ctx.shadowBlur = 10;\n    //  ...\n    //  ctx.fill();\n    // )\n\n    var shadowTemp = [\n        ['shadowBlur', 0],\n        ['shadowColor', '#000'],\n        ['shadowOffsetX', 0],\n        ['shadowOffsetY', 0]\n    ];\n\n    module.exports = function (orignalBrush) {\n\n        // version string can be: '11.0'\n        return (env.browser.ie && env.browser.version >= 11)\n\n            ? function () {\n                var clipPaths = this.__clipPaths;\n                var style = this.style;\n                var modified;\n\n                if (clipPaths) {\n                    for (var i = 0; i < clipPaths.length; i++) {\n                        var clipPath = clipPaths[i];\n                        var shape = clipPath && clipPath.shape;\n                        var type = clipPath && clipPath.type;\n\n                        if (shape && (\n                            (type === 'sector' && shape.startAngle === shape.endAngle)\n                            || (type === 'rect' && (!shape.width || !shape.height))\n                        )) {\n                            for (var j = 0; j < shadowTemp.length; j++) {\n                                // It is save to put shadowTemp static, because shadowTemp\n                                // will be all modified each item brush called.\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n                            }\n                            modified = true;\n                            break;\n                        }\n                    }\n                }\n\n                orignalBrush.apply(this, arguments);\n\n                if (modified) {\n                    for (var j = 0; j < shadowTemp.length; j++) {\n                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n                    }\n                }\n            }\n\n            : orignalBrush;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/helper/fixClipWithShadow.js\n// module id = 49\n// module chunks = 0","/**\n * echarts设备环境识别\n *\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // 原生canvas支持，改极端点了\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n                // events currently. So we dont use that on other browsers unless tested sufficiently.\n                // Although IE 10 supports pointer event, it use old style and is different from the\n                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n                && (browser.edge || (browser.ie && browser.version >= 11))\n        };\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/core/env.js\n// module id = 50\n// module chunks = 0","/**\n * 圆环\n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/shape/Ring.js\n// module id = 51\n// module chunks = 0","/**\n * 多边形\n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/shape/Polygon.js\n// module id = 52\n// module chunks = 0","\n\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/helper/poly.js\n// module id = 53\n// module chunks = 0","/**\n * Catmull-Rom spline 插值折线\n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = require('../../core/vector');\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points 线段顶点数组\n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/helper/smoothSpline.js\n// module id = 54\n// module chunks = 0","/**\n * 贝塞尔平滑曲线\n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * 贝塞尔平滑曲线\n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points 线段顶点数组\n     * @param {number} smooth 平滑等级, 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n     *                           整个折线的包围盒做一个并集用来约束控制点。\n     * @param {Array} 计算出来的控制点数组\n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // 与指定的包围盒做并集\n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/helper/smoothBezier.js\n// module id = 55\n// module chunks = 0","/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/shape/Polyline.js\n// module id = 56\n// module chunks = 0","/**\n * 矩形\n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = require('../helper/roundRect');\n\n    module.exports = require('../Path').extend({\n\n        type: 'rect',\n\n        shape: {\n            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n            // r缩写为1         相当于 [1, 1, 1, 1]\n            // r缩写为[1]       相当于 [1, 1, 1, 1]\n            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/shape/Rect.js\n// module id = 57\n// module chunks = 0","/**\n * 直线\n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = require('../Path').extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/shape/Line.js\n// module id = 58\n// module chunks = 0","'use strict';\n/**\n * 贝塞尔曲线\n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = require('../Path').extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/shape/BezierCurve.js\n// module id = 59\n// module chunks = 0","/**\n * 圆弧\n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = require('../Path').extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/shape/Arc.js\n// module id = 60\n// module chunks = 0","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'linear', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/LinearGradient.js\n// module id = 61\n// module chunks = 0","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'radial', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/RadialGradient.js\n// module id = 62\n// module chunks = 0","/**\n * States machine for managing graphic states\n */\n\n\n\n    /**\n     * @typedef {Object} IGraphicState\n     * @property {number} [zlevel]\n     * @property {number} [z]\n     * @property {Array.<number>} {position}\n     * @property {Array.<number>|number} {rotation}\n     * @property {Array.<number>} {scale}\n     * @property {Object} style\n     *\n     * @property {Function} onenter\n     * @property {Function} onleave\n     * @property {Function} ontransition\n     * @property {Array.<IGraphicStateTransition|string>} transition\n     *           Transition object or a string descriptor like '* 30 0 Linear'\n     */\n\n    var zrUtil = require('../core/util');\n    var Style = require('./Style');\n    var vec2Copy = require('../core/vector').copy;\n\n    var transitionProperties = ['position', 'rotation', 'scale', 'style', 'shape'];\n    /**\n     * @module zrender/graphic/States~TransitionObject\n     */\n    var TransitionObject = function (opts) {\n        if (typeof opts == 'string') {\n            this._fromStr(opts);\n        }\n        else if (opts) {\n            opts.property && (this.property = opts.property);\n            opts.duration != null && (this.duration = opts.duration);\n            opts.easing && (this.easing = opts.easing);\n            opts.delay && (this.delay = opts.delay);\n        }\n        if (this.property !== '*') {\n            this.property = this.property.split(',');\n        }\n        else {\n            this.property = transitionProperties;\n        }\n    };\n\n    TransitionObject.prototype = {\n\n        constructor: TransitionObject,\n\n        /**\n         * List of all transition properties. Splitted by comma. Must not have spaces in the string.\n         * e.g. 'position,style.color'. '*' will match all the valid properties.\n         * @type {string}\n         * @default *\n         */\n        property: '*',\n\n        /**\n         * @type {string}\n         * @default 'Linear'\n         */\n        easing: 'Linear',\n\n        /**\n         * @type {number}\n         * @default 'number'\n         */\n        duration: 500,\n\n        /**\n         * @type {number}\n         */\n        delay: 0,\n\n        _fromStr: function (str) {\n            var arr = str.split(/\\s+/g);\n            this.property = arr[0];\n            this.duration = +arr[1];\n            this.delay = +arr[2];\n            this.easing = arr[3];\n        }\n    };\n\n\n    /**\n     * @alias module:zrender/graphic/States\n     */\n    var GraphicStates = function (opts) {\n\n        opts = opts || {};\n\n        this._states = {};\n\n        /**\n         * Target element\n         * @type {zrender/graphic/Displayable|zrender/container/Group}\n         */\n        this._el = opts.el;\n\n        this._subStates = [];\n\n        this._transitionAnimators = [];\n\n        if (opts.initialState) {\n            this._initialState = opts.initialState;\n        }\n\n        var optsStates = opts.states;\n        if (optsStates) {\n            for (var name in optsStates) {\n                if (optsStates.hasOwnProperty(name)) {\n                    var state = optsStates[name];\n                    this._addState(name, state);\n                }\n            }\n        }\n\n        this.setState(this._initialState);\n    };\n\n    GraphicStates.prototype = {\n\n        constructor: GraphicStates,\n\n        /**\n         * All other state will be extended from initial state\n         * @type {string}\n         * @private\n         */\n        _initialState: 'normal',\n\n        /**\n         * Current state\n         * @type {string}\n         * @private\n         */\n        _currentState: '',\n\n        el: function () {\n            return this._el;\n        },\n\n        _addState: function (name, state) {\n            this._states[name] = state;\n\n            if (state.transition) {\n                state.transition = new TransitionObject(state.transition);\n            }\n\n            // Extend from initial state\n            if (name !== this._initialState) {\n                this._extendFromInitial(state);\n            }\n            else {\n                var el = this._el;\n                // setState 的时候自带的 style 和 shape 都会被直接覆盖\n                // 所以这边先把自带的 style 和 shape 扩展到初始状态中\n                zrUtil.merge(state.style, el.style, false, false);\n                if (state.shape) {\n                    zrUtil.merge(state.shape, el.shape, false, true);\n                }\n                else {\n                    state.shape = zrUtil.clone(el.shape, true);\n                }\n\n                for (var name in this._states) {\n                    if (this._states.hasOwnProperty(name)) {\n                        this._extendFromInitial(this._states[name]);\n                    }\n                }\n            }\n        },\n\n        _extendFromInitial: function (state) {\n            var initialState = this._states[this._initialState];\n            if (initialState && state !== initialState) {\n                zrUtil.merge(state, initialState, false, true);\n            }\n        },\n\n        setState: function (name, silent) {\n            if (name === this._currentState\n                && ! this.transiting()\n            ) {\n                return;\n            }\n\n            var state = this._states[name];\n\n            if (state) {\n                this._stopTransition();\n\n                if (! silent) {\n                    var prevState = this._states[this._currentState];\n                    if (prevState) {\n                        prevState.onleave && prevState.onleave.call(this);\n                    }\n\n                    state.onenter && state.onenter.call(this);\n                }\n\n                this._currentState = name;\n\n                if (this._el) {\n                    var el = this._el;\n\n                    // Setting attributes\n                    if (state.zlevel != null) {\n                        el.zlevel = state.zlevel;\n                    }\n                    if (state.z != null) {\n                        el.z = state.z;\n                    }\n\n                    // SRT\n                    state.position && vec2Copy(el.position, state.position);\n                    state.scale && vec2Copy(el.scale, state.scale);\n                    if (state.rotation != null) {\n                        el.rotation = state.rotation;\n                    }\n\n                    // Style\n                    if (state.style) {\n                        var initialState = this._states[this._initialState];\n                        el.style = new Style();\n                        if (initialState) {\n                            el.style.extendFrom(initialState.style, false);\n                        }\n                        if (\n                            // Not initial state\n                            name != this._initialState\n                            // Not copied from initial state in _extendFromInitial method\n                            && initialState.style !== state.style\n                        ) {\n                            el.style.extendFrom(state.style, true);\n                        }\n                    }\n                    if (state.shape) {\n                        el.shape = zrUtil.clone(state.shape, true);\n                    }\n\n                    el.dirty();\n                }\n            }\n\n            for (var i = 0; i < this._subStates.length; i++) {\n                this._subStates.setState(name);\n            }\n        },\n\n        getState: function () {\n            return this._currentState;\n        },\n\n        transitionState: function (target, done) {\n            if (\n                target === this._currentState\n                && ! this.transiting()\n            ) {\n                return;\n            }\n\n            var state = this._states[target];\n            var styleShapeReg = /$[style|shape]\\./;\n            var self = this;\n\n            // Animation 去重\n            var propPathMap = {};\n\n            if (state) {\n\n                self._stopTransition();\n\n                var el = self._el;\n\n                if (state.transition && el && el.__zr) {// El can be animated\n                    var transitionCfg = state.transition;\n                    var property = transitionCfg.property;\n\n                    var animatingCount = 0;\n                    var animationDone = function () {\n                        animatingCount--;\n                        if (animatingCount === 0) {\n                            self.setState(target);\n                            done && done();\n                        }\n                    };\n                    for (var i = 0; i < property.length; i++) {\n                        var propName = property[i];\n\n                        // Animating all the properties in style or shape\n                        if (propName === 'style' || propName === 'shape') {\n                            if (state[propName]) {\n                                for (var key in state[propName]) {\n                                    if (!state[propName].hasOwnProperty(key)) {\n                                        continue;\n                                    }\n                                    var path = propName + '.' + key;\n                                    if (propPathMap[path]) {\n                                        continue;\n                                    }\n                                    propPathMap[path] = 1;\n                                    animatingCount += self._animProp(\n                                        state, propName, key, transitionCfg, animationDone\n                                    );\n                                }\n                            }\n                        }\n                        else {\n                            if (propPathMap[propName]) {\n                                continue;\n                            }\n                            propPathMap[propName] = 1;\n                            // Animating particular property in style or style\n                            if (propName.match(styleShapeReg)) {\n                                // remove 'style.', 'shape.' prefix\n                                var subProp = propName.slice(0, 5);\n                                propName = propName.slice(6);\n                                animatingCount += self._animProp(\n                                    state, subProp, propName, transitionCfg, animationDone\n                                );\n                            }\n                            else {\n                                animatingCount += self._animProp(\n                                    state, '', propName, transitionCfg, animationDone\n                                );\n                            }\n\n                        }\n                    }\n                    // No transition properties\n                    if (animatingCount === 0) {\n                        self.setState(target);\n                        done && done();\n                    }\n                }\n                else {\n                    self.setState(target);\n                    done && done();\n                }\n            }\n\n            var subStates = self._subStates;\n            for (var i = 0; i < subStates.length; i++) {\n                subStates.transitionState(target);\n            }\n        },\n\n        /**\n         * Do transition animation of particular property\n         * @param {Object} state\n         * @param {string} subPropKey\n         * @param {string} key\n         * @param {Object} transitionCfg\n         * @param {Function} done\n         * @private\n         */\n        _animProp: function (state, subPropKey, key, transitionCfg, done) {\n            var el = this._el;\n            var stateObj = subPropKey ? state[subPropKey] : state;\n            var elObj = subPropKey ? el[subPropKey] : el;\n            var availableProp = stateObj && (key in stateObj)\n                && elObj && (key in elObj);\n\n            var transitionAnimators = this._transitionAnimators;\n            if (availableProp) {\n                var obj = {};\n                if (stateObj[key] === elObj[key]) {\n                    return 0;\n                }\n                obj[key] = stateObj[key];\n\n                var animator = el.animate(subPropKey)\n                    .when(transitionCfg.duration, obj)\n                    .delay(transitionCfg.dealy)\n                    .done(function () {\n                        var idx = zrUtil.indexOf(transitionAnimators, 1);\n                        if (idx > 0) {\n                            transitionAnimators.splice(idx, 1);\n                        }\n                        done();\n                    })\n                    .start(transitionCfg.easing);\n                transitionAnimators.push(animator);\n\n                return 1;\n            }\n            return 0;\n        },\n\n        _stopTransition: function () {\n            var transitionAnimators = this._transitionAnimators;\n            for (var i = 0; i < transitionAnimators.length; i++) {\n                transitionAnimators[i].stop();\n            }\n            transitionAnimators.length = 0;\n        },\n\n        transiting: function () {\n            return this._transitionAnimators.length > 0;\n        },\n\n        addSubStates: function (states) {\n            this._subStates.push(states);\n        },\n\n        removeSubStates: function (states) {\n            var idx = zrUtil.indexOf(this._subStates, states);\n            if (idx >= 0) {\n                this._subStates.splice(states, 1);\n            }\n        }\n    };\n\n    module.exports = GraphicStates;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/graphic/States.js\n// module id = 63\n// module chunks = 0","\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect.js');\r\n    function Minimap(bigCanvas,groupPosition, group,eagleEyeNode,distance,imgSrc) {\r\n\r\n        this.bigCanvas = bigCanvas;\r\n        this.eagleEyeNode = eagleEyeNode;\r\n        this.distance = distance;\r\n        this.imgSrc = imgSrc;\r\n        this.ratio;\r\n        this.groupRatio;\r\n        this.group = group;\r\n        this.img = document.createElement(\"img\");\r\n        this.selection = document.createElement('div');\r\n        this.groupPosition = zrUtil.clone(groupPosition);\r\n        this.selectPosition = [0,0];\r\n        this.render();\r\n    }\r\n\r\n    Minimap.prototype.render = function() {\r\n        var that = this;\r\n        that.ratio = 0.12;\r\n        var eagleEyeNodeWidth = that.group.width  * that.ratio;\r\n        var eagleEyeNodeHeight = that.group.height  * that.ratio;\r\n        that.eagleEyeNode.style.width = eagleEyeNodeWidth+\"px\";\r\n        that.eagleEyeNode.style.height = eagleEyeNodeHeight+\"px\";\r\n        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+\"px\";\r\n        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+\"px\";\r\n        that.eagleEyeNode.style.position=\"relative\";\r\n        that.eagleEyeNode.style.background = \"url(\"+that.imgSrc+\") no-repeat\";\r\n        that.eagleEyeNode.style.backgroundSize = eagleEyeNodeWidth/(that.group.width*that.distance[2]/that.bigCanvas.getWidth())+\"px\";\r\n        that.backgroundSize = zrUtil.clone(that.eagleEyeNode.style.backgroundSize);\r\n        that.eagleEyeNode.innerHTML = \"\";\r\n        that.selection.style.border = \"1px solid #ff0000\";\r\n        that.selection.style.cursor = \"pointer\";\r\n        that.selection.style.width = that.bigCanvas.getWidth()/that.group.width*eagleEyeNodeWidth+\"px\";\r\n        that.selection.style.height = that.bigCanvas.getHeight()/that.group.height*eagleEyeNodeHeight+\"px\";\r\n        that.selectWidth = that.selection.style.width;\r\n        that.selectHeight = that.selection.style.height;\r\n        that.selection.style.position=\"absolute\";\r\n        that.selection.style.top = 0+\"px\";\r\n        that.selection.style.left = 0+\"px\";\r\n        that.eagleEyeNode.appendChild(this.selection);\r\n    };\r\n    Minimap.prototype.updataSelection = function(offectLeft,offectTop,zoomScale,nowZoom){\r\n        var that = this;\r\n        that.zoomScale = zoomScale;\r\n        this.selection.style.width = this.selection.style.width.replace(\"px\",\"\")/zoomScale+\"px\";\r\n        this.selection.style.height = this.selection.style.height.replace(\"px\",\"\")/zoomScale+\"px\";\r\n        that.selectPosition[0] = zrUtil.clone(offectLeft)*that.ratio/nowZoom;\r\n        that.selectPosition[1] = zrUtil.clone(offectTop)*that.ratio/nowZoom;\r\n        this.selection.style.left = -that.selectPosition[0]+\"px\";\r\n        this.selection.style.top = -that.selectPosition[1]+\"px\";\r\n    };\r\n    Minimap.prototype.updataMap = function(imgSrc,newGroup){\r\n        var that = this;\r\n        that.eagleEyeNode.style.backgroundImage = \"url(\"+imgSrc+\")\";\r\n        var eagleEyeNodeWidth = newGroup.width  * that.ratio;\r\n        var eagleEyeNodeHeight = newGroup.height  * that.ratio;\r\n        that.eagleEyeNode.style.width = eagleEyeNodeWidth+\"px\";\r\n        that.eagleEyeNode.style.height = eagleEyeNodeHeight+\"px\";\r\n        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+\"px\";\r\n        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+\"px\";\r\n    };\r\n    Minimap.prototype.updataSelectionPosition = function(nowGroupPosition,nowZoom){\r\n        var that = this;\r\n        that.selectPosition[0] = zrUtil.clone(nowGroupPosition[0])*that.ratio/nowZoom;\r\n        that.selectPosition[1] = zrUtil.clone(nowGroupPosition[1])*that.ratio/nowZoom;\r\n        this.selection.style.left = -that.selectPosition[0]+\"px\";\r\n        this.selection.style.top = -that.selectPosition[1]+\"px\";\r\n    };\r\n    Minimap.prototype.updataGroupPosition = function(group,nowZoom){\r\n        var that = this;\r\n        var positionX = -Number(that.selection.style.left.substring(0,that.selection.style.left.length-2))/that.ratio*nowZoom;\r\n        var positionY = -Number(that.selection.style.top.substring(0,that.selection.style.top.length-2))/that.ratio*nowZoom;\r\n        group.attr(\"position\",[positionX,positionY]);\r\n    };\r\n\r\n    module.exports = Minimap;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/minimap.js\n// module id = 64\n// module chunks = 0","/**\r\n * 工具方法类\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Point = require(\"./Point.js\");\r\n    var Line = require(\"./LineStruct.js\");\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    /**\r\n     * 构造类继承关系\r\n     *\r\n     * @param {Function} clazz 源类\r\n     * @param {Function} baseClazz 基类\r\n     */\r\n    function inherits(clazz, baseClazz) {\r\n        var clazzPrototype = clazz.prototype;\r\n\r\n        function F() {}\r\n        F.prototype = baseClazz.prototype;\r\n        clazz.prototype = new F();\r\n\r\n        for (var prop in clazzPrototype) {\r\n            clazz.prototype[prop] = clazzPrototype[prop];\r\n        }\r\n        clazz.prototype.constructor = clazz;\r\n        clazz.superClass = baseClazz;\r\n    }\r\n\r\n    function getUUID() {\r\n        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),\r\n            uuid = new Array(36),\r\n            rnd = 0,\r\n            r;\r\n        for (var i = 0; i < 36; i++) {\r\n            if (i == 8 || i == 13 || i == 18 || i == 23) {\r\n                uuid[i] = '-';\r\n            } else if (i == 14) {\r\n                uuid[i] = '4';\r\n            } else {\r\n                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\r\n                r = rnd & 0xf;\r\n                rnd = rnd >> 4;\r\n                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\r\n            }\r\n        }\r\n        return \"sid-\" + uuid.join('');\r\n    }\r\n\r\n\r\n    /**\r\n     * 计算两点之间的距离\r\n     *@param {Point} p1 - first {Point}\r\n     *@param {Point} p2 - second {Point}\r\n     *@return {Number} - the distance between those 2 points. It is always positive.\r\n     **/\r\n    function distance(p1, p2) {\r\n        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\r\n    }\r\n\r\n    /**\r\n     * 返回一条折线 最长的两个点\r\n     * @param  {[type]} points [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    function getMaxLineLength(points) {\r\n        var m = distance(points[0], points[1]);\r\n        var result = [points[0], points[1]];\r\n        for (var i = 1; i < points.length - 1; i++) {\r\n\r\n            if (m < distance(points[i], points[i + 1])) {\r\n                m = distance(points[i], points[i + 1])\r\n                result = [points[i], points[i + 1]];\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**Returns the length of a Polyline that would be created with a set of points\r\n     *@param {Array} v - an {Array} of {Points}\r\n     *@return {Number} - a positive number equal with total length*/\r\n    function getPolylineLength(v) {\r\n        var l = 0;\r\n        for (var i = 0; i < v.length - 1; i++) {\r\n            l += distance(v[i], v[i + 1]);\r\n        }\r\n\r\n        return l;\r\n    }\r\n\r\n\r\n    /**Returns the max of a vector\r\n     *@param {Array} v - vector of {Number}s\r\n     *@return {Number} - the maximum number from the vector or NaN if vector is empty\r\n     **/\r\n    function max(v) {\r\n        if (v.lenght == 0) {\r\n            return NaN;\r\n        } else {\r\n            var m = v[0];\r\n            for (var i = 0; i < v.length; i++) {\r\n                if (m < v[i]) {\r\n                    m = v[i];\r\n                }\r\n            }\r\n\r\n            return m;\r\n        }\r\n    }\r\n\r\n\r\n    /**Returns the min of a vector\r\n     *@param {Array} v - vector of {Number}s\r\n     *@return {Number} - the minimum number from the vector or NaN if vector is empty\r\n     *@author alex@scriptoid.com\r\n     **/\r\n    function min(v) {\r\n        if (v.lenght == 0) {\r\n            return NaN;\r\n        } else {\r\n            var m = v[0];\r\n            for (var i = 0; i < v.length; i++) {\r\n                if (m > v[i]) {\r\n                    m = v[i];\r\n                }\r\n            }\r\n\r\n            return m;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 判断 点数组 是否正交直线路径\r\n     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)\r\n     *@param {Array} v - an {Array} of {Point}s\r\n     *@return {Boolean} - true if path is valid, false otherwise\r\n     **/\r\n    function orthogonalPath(v) {\r\n        if (v.length <= 1) {\r\n            return true;\r\n        }\r\n\r\n        for (var i = 0; i < v.length - 1; i++) {\r\n            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     *Test to see if 2 {Line}s intersects. They are considered finite segments\r\n     *and not the infinite lines from geometry\r\n     *@param {Line} l1 - fist line/segment\r\n     *@param {Line} l2 - last line/segment\r\n     *@return {Boolean} true - if the lines intersect or false if not\r\n     **/\r\n    function lineIntersectsLine(l1, l2) {\r\n        // check for two vertical lines\r\n        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {\r\n            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,\r\n                // then check segment bounds for overlapping\r\n                l1.contains(l2.startPoint.x, l2.startPoint.y) ||\r\n                l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n                // lines are paralel\r\n                false;\r\n        }\r\n        // if one line is vertical, and another line is not vertical\r\n        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {\r\n            // let assume l2 is vertical, otherwise exchange them\r\n            if (l1.startPoint.x == l1.endPoint.x) {\r\n                var l = l1;\r\n                l1 = l2;\r\n                l2 = l;\r\n            }\r\n            // finding intersection of 'infinite' lines\r\n            // equation of the first line is y = ax + b, second: x = c\r\n            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n            var b = l1.startPoint.y - a * l1.startPoint.x;\r\n            var x0 = l2.startPoint.x;\r\n            var y0 = a * x0 + b;\r\n            return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n        }\r\n\r\n        // check normal case - both lines are not vertical\r\n        else {\r\n            //line equation is : y = a*x + b, b = y - a * x\r\n            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;\r\n\r\n            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);\r\n            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;\r\n\r\n            if (a1 == a2) { //paralel lines\r\n                return b1 == b2 ?\r\n                    // for coincide lines, check for segment bounds overlapping\r\n                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n                    // not coincide paralel lines have no chance to intersect\r\n                    false;\r\n            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment\r\n\r\n                /*\r\n                 * if one of the lines are vertical, then x0 is equal to their x,\r\n                 * otherwise:\r\n                 * y1 = a1 * x + b1\r\n                 * y2 = a2 * x + b2\r\n                 * => x0 = (b2 - b1) / (a1 - a2)\r\n                 * => y0 = a1 * x0 + b1\r\n                 **/\r\n                x0 = (b2 - b1) / (a1 - a2);\r\n                y0 = a1 * x0 + b1;\r\n                return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     *Tests if a a polyline defined by a set of points intersects a rectangle\r\n     *@param {Array} points - and {Array} of {Point}s\r\n     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)\r\n     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false\r\n     *\r\n     *@return true - if line intersects the rectangle, false - if not\r\n     **/\r\n    function polylineIntersectsRectangle(points, bounds, closedPolyline) {\r\n\r\n\r\n        //get the 4 lines/segments represented by the bounds\r\n        var lines = [];\r\n        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));\r\n        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));\r\n        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));\r\n        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));\r\n\r\n        for (var k = 0; k < points.length - 1; k++) {\r\n            //create a line out of each 2 consecutive points\r\n            var tempLine = new Line(points[k], points[k + 1]);\r\n\r\n            //see if that line intersect any of the line on bounds border\r\n            for (var i = 0; i < lines.length; i++) {\r\n                if (lineIntersectsLine(tempLine, lines[i])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        //check the closed figure - that is last point connected to the first\r\n        if (closedPolyline) {\r\n            //create a line out of each 2 consecutive points\r\n            var tempLine1 = new Line(points[points.length - 1], points[0]);\r\n\r\n            //see if that line intersect any of the line on bounds border\r\n            for (var j = 0; j < lines.length; j++) {\r\n                if (lineIntersectsLine(tempLine1, lines[j])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * 计算路径的分数\r\n     * Score a ortogonal path made out of Points\r\n     *Iterates over a set of points (minimum 3)\r\n     *For each 3 points (i, i+1, i+2) :\r\n     *  - if the 3rd one is after the 2nd on the same line we add +1\r\n     *  - if the 3rd is up or down related to the 2nd we do not do anything +0\r\n     *  - if the 3rd goes back we imediatelly return -1\r\n     *@param {Array} v - an array of {Point}s\r\n     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine\r\n     *  The bigger the number the smooth the path is\r\n     **/\r\n    function scorePath(v) {\r\n        if (v.length <= 2) {\r\n            return -1;\r\n        }\r\n\r\n        var score = 0;\r\n        for (var i = 1; i < v.length - 1; i++) {\r\n            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical\r\n                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction\r\n                    score++;\r\n                } else { //going back - no good\r\n                    return -1;\r\n                }\r\n            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal\r\n                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction\r\n                    score++;\r\n                } else { //going back - no good\r\n                    return -1;\r\n                }\r\n            } else { //not on same vertical nor horizontal\r\n                score--;\r\n            }\r\n        }\r\n\r\n        return score;\r\n    }\r\n\r\n    /**\r\n     * 返回数字符号（+ -)\r\n     * Returns the sign of a number\r\n     *@param {Number} x - the number\r\n     *@returns {Number}\r\n     *@see <a href=\"http://en.wikipedia.org/wiki/Sign_function\">http://en.wikipedia.org/wiki/Sign_function</a>\r\n     **/\r\n    function signum(x) {\r\n        if (x > 0)\r\n            return 1;\r\n        else if (x < 0)\r\n            return -1;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    /**\r\n     * 判断 点数组 是不是有效路径（没有回路）\r\n     *Tests if a vector of points is a valid path (not going back)\r\n     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that\r\n     *@param {Array} v - an {Array} of {Point}s\r\n     *@return {Boolean} - true if path is valid, false otherwise\r\n     **/\r\n    function forwardPath(v) {\r\n        if (v.length <= 2) {\r\n            return true;\r\n        }\r\n\r\n        for (var i = 0; i < v.length - 2; i++) {\r\n            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical\r\n                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path\r\n                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)\r\n                        return false;\r\n                    }\r\n                }\r\n            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal\r\n                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path\r\n                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n     * @param  {[type]} points [description]\r\n     * @param  {[type]} isRevert [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    function traslatePoints(points, isRevert) {\r\n        var newPoints = [];\r\n        if (isRevert) {\r\n            for (var i = 0; i < points.length; i++) {\r\n                var point = points[i];\r\n                newPoints.push(new Point(point[0], point[1]));\r\n            }\r\n            return newPoints;\r\n        } else {\r\n            for (var j = 0; j < points.length; j++) {\r\n                var point1 = points[j];\r\n                newPoints.push([point1.x, point1.y]);\r\n            }\r\n            return newPoints;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    function rotationMatrix(angle) {\r\n        var mReturn = [\r\n            [Math.cos(angle), -Math.sin(angle), 0],\r\n            [Math.sin(angle), Math.cos(angle), 0],\r\n            [0, 0, 1]\r\n        ];\r\n        return mReturn;\r\n    }\r\n\r\n    function translationMatrix(dx, dy) {\r\n        return [\r\n            [1, 0, dx],\r\n            [0, 1, dy],\r\n            [0, 0, 1]\r\n        ];\r\n    }\r\n\r\n    function scaleMatrix(sx, sy) {\r\n        if (sy == null) {\r\n            sy = sx;\r\n        }\r\n        return [\r\n            [sx, 0, 0],\r\n            [0, sy, 0],\r\n            [0, 0, 1]\r\n        ];\r\n    }\r\n\r\n    /** It will return the end point of a line on a given angle (clockwise).\r\n     * @param {Point} startPoint - the start of the line\r\n     * @param {Number} length - the length of the line\r\n     * @param {Number} angle - the angle of the line in radians\r\n     * @return {Point} - the endPoint of the line\r\n     */\r\n    function getEndPoint(startPoint, length, angle) {\r\n        var endPoint = startPoint.clone();\r\n        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));\r\n        endPoint.y -= length;\r\n        endPoint.transform(rotationMatrix(angle));\r\n        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));\r\n        return endPoint;\r\n    }\r\n\r\n    /**\r\n     * 获取获取两个图形的外面四个连接点\r\n     * @param  {[type]} node [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    function getConnectorPoints(node) {\r\n        return {\r\n            left: new Point(node.x, node.y + node.height / 2), //矩形 左中的位置\r\n            top: new Point(node.x + node.width / 2, node.y), //矩形 上中的位置\r\n            right: new Point(node.x + node.width, node.y + node.height / 2), //矩形 右中的位置\r\n            bottom: new Point(node.x + node.width / 2, node.y + node.height), //矩形 下中的位置\r\n            center: new Point(node.x + node.width / 2, node.y + node.height / 2) //中间位置\r\n\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 获取获取两个图形的外面四个连接点\r\n     * @param  {[type]} node [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    function getSoltPoints(node) {\r\n        return [\r\n            //top\r\n            [Math.round(node.getRect().width / 3 /10)*10, 0 ],\r\n            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],\r\n            //right\r\n            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],\r\n            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],\r\n            //bottom\r\n            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n            //left\r\n            [0, Math.round(node.getRect().height / 3 /10)*10 ],\r\n            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]\r\n\r\n        ]\r\n    }\r\n\r\n    /**\r\n     * 计算 p1 p2两点所连接的直线的角度\r\n     * @param  {[type]} p1 [description]\r\n     * @param  {[type]} p2 [description]\r\n     * @return {[type]}    [description]\r\n     */\r\n    function tangentRotation(p1, p2) {\r\n        return -Math.PI / 2 - Math.atan2(\r\n            p2.y - p1.y, p2.x - p1.x\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 判断3点是否在一条直线上\r\n     * Tests if 3 points are coliniar with matrix determinants.\r\n     * If the determinat of matrix\r\n     * /         \\\r\n     * | x1 y1 1 |\r\n     * | x2 y2 1 |\r\n     * | x3 y3 1 |\r\n     * \\         /\r\n     * is zero it means that the points are colinear\r\n     *@param {Point} p1 - first point\r\n     *@param {Point} p2 - second point\r\n     *@param {Point} p3 - third point\r\n     * @param {Number} precission\r\n     *@return {Boolean} - true if coliniar and false if not\r\n     *@author Alex\r\n     *@see http://en.wikipedia.org/wiki/Determinant\r\n     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html\r\n     **/\r\n    function collinearity(p1, p2, p3, precission) {\r\n        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);\r\n\r\n        if (precission) {\r\n            return Math.abs(determinant) <= precission;\r\n        } else {\r\n            return determinant === 0;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 四舍五入 保存decimals的小数\r\n     **/\r\n    function enhancedRound(number, decimals) {\r\n        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);\r\n    }\r\n\r\n    /**\r\n     * 获取两点之间的长度\r\n     **/\r\n    function getLength(startPoint, endPoint) {\r\n        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));\r\n    }\r\n\r\n    /**\r\n     * 获取角度\r\n     * @param  {[type]} centerPoint  [description]\r\n     * @param  {[type]} outsidePoint [description]\r\n     * @param  {[type]} round        [description]\r\n     * @return {[type]}              [description]\r\n     */\r\n    function getAngle(centerPoint, outsidePoint, round) {\r\n        centerPoint.x = enhancedRound(centerPoint.x, 5);\r\n        centerPoint.y = enhancedRound(centerPoint.y, 5);\r\n        outsidePoint.x = enhancedRound(outsidePoint.x, 5);\r\n        outsidePoint.y = enhancedRound(outsidePoint.y, 5);\r\n        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));\r\n        angle = -angle;\r\n\r\n        //endAngle+=90;\r\n        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n            angle += Math.PI;\r\n        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n            angle += Math.PI;\r\n        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {\r\n            angle += Math.PI * 2;\r\n        }\r\n        while (angle >= Math.PI * 2) {\r\n            angle -= Math.PI * 2;\r\n        }\r\n        if (isNaN(angle)) { //Nan\r\n            angle = 0; //we are at center point;\r\n        }\r\n        if (round) {\r\n            angle = Math.round(angle / round) * round\r\n        }\r\n        return angle;\r\n    }\r\n\r\n    function getRect(node, isCalcParent) {\r\n        var boundingRect = node.getBoundingRect();\r\n        //创建最小包围盒虚线\r\n        var points = [];\r\n        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];\r\n        points[2] = [boundingRect.width / 2, boundingRect.height / 2];\r\n        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];\r\n        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\r\n        var positionX = node.position[0];\r\n        var positionY = node.position[1];\r\n        //这里要循环判断一把 有没有父节点 并且父节点不是根节点 然后进行相加\r\n        if (node.parent.type === \"GroupNode\" && isCalcParent) {\r\n            positionX = positionX + node.parent.position[0];\r\n            positionY = positionY + node.parent.position[1];\r\n        }\r\n\r\n        var boundRect = new BoundingRect(\r\n                Number(positionX + boundingRect.x),   //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半\r\n                Number(positionY + boundingRect.y),\r\n                Number(boundingRect.width),\r\n                Number(boundingRect.height)\r\n            );\r\n        //中心点\r\n        var cx = Number(node.position[0]) + Number(boundingRect.width) / 2 + Number(boundingRect.x);\r\n        var cy = Number(node.position[1]) + Number(boundingRect.height) / 2 + Number(boundingRect.y);\r\n        return {\r\n            x: Number(cx),\r\n            y: Number(cy),\r\n            width: Number(boundingRect.width),\r\n            height: Number(boundingRect.height),\r\n            points: points,\r\n            boundingRect: boundRect\r\n        };\r\n    }\r\n\r\n    var StackedMap = {\r\n        createNew: function() {\r\n            var stack = [];\r\n\r\n            return {\r\n                add: function(key, value) {\r\n                    var arrKey = this.get(key);\r\n                    arrKey.push(value)\r\n\r\n                },\r\n                get: function(key) {\r\n                    for (var i = 0; i < stack.length; i++) {\r\n                        if (key == stack[i].key) {\r\n                            return stack[i].value;\r\n                        }\r\n                    }\r\n                    //如果没有找到的话，则创建一个新的数组\r\n                    var value = [];\r\n                    stack.push({ key: key, value: value });\r\n                    return value;\r\n                },\r\n                keys: function() {\r\n                    var keys = [];\r\n                    for (var i = 0; i < stack.length; i++) {\r\n                        keys.push(stack[i].key);\r\n                    }\r\n                    return keys;\r\n                },\r\n                top: function() {\r\n                    return stack[stack.length - 1];\r\n                },\r\n                remove: function(key) {\r\n                    var idx = -1;\r\n                    for (var i = 0; i < stack.length; i++) {\r\n                        if (key == stack[i].key) {\r\n                            idx = i;\r\n                            break;\r\n                        }\r\n                    }\r\n                    return stack.splice(idx, 1)[0];\r\n                },\r\n                removeItem: function(key, item) {\r\n                    var arrKey = this.get(key);\r\n                    var index = zrUtil.indexOf(arrKey, item);\r\n                    arrKey.splice(index, 1);\r\n\r\n                },\r\n                removeTop: function() {\r\n                    return stack.splice(stack.length - 1, 1)[0];\r\n                },\r\n                length: function() {\r\n                    return stack.length;\r\n                },\r\n                clear: function() {\r\n                    stack.splice(0, stack.length);\r\n                }\r\n            };\r\n        }\r\n    };\r\n\r\n    function randomColor() {\r\n        var arrHex = [\"0\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\"],\r\n            strHex = \"#\",\r\n            index;\r\n        for (var i = 0; i < 6; i++) {\r\n            index = Math.round(Math.random() * 15);\r\n            strHex += arrHex[index];\r\n        }\r\n        return strHex;\r\n    }\r\n\r\n    function isUndefined(obj) {\r\n        return obj === void 0;\r\n    }\r\n\r\n    function collinearReduction (v) {\r\n        var r = [];\r\n\r\n        if(v.length < 3){\r\n            return Point.cloneArray(v);\r\n        }\r\n\r\n        r.push( v[0].clone() );\r\n        for(var i=1; i < v.length-1; i++){\r\n            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )\r\n            {\r\n                continue;\r\n            }\r\n            else{\r\n                r.push( v[i].clone() );\r\n            }\r\n        }\r\n        r.push( v[v.length-1].clone() );\r\n\r\n        return r;\r\n    }\r\n\r\n    // By default, Underscore uses ERB-style template delimiters, change the\r\n    // following template settings to use alternative delimiters.\r\n    var templateSettings = {\r\n        evaluate: /<%([\\s\\S]+?)%>/g,\r\n        interpolate: /<%=([\\s\\S]+?)%>/g,\r\n        escape: /<%-([\\s\\S]+?)%>/g\r\n    };\r\n\r\n    // When customizing `templateSettings`, if you don't want to define an\r\n    // interpolation, evaluation or escaping regex, we need one that is\r\n    // guaranteed not to match.\r\n    var noMatch = /(.)^/;\r\n\r\n    // Certain characters need to be escaped so that they can be put into a\r\n    // string literal.\r\n    var escapes = {\r\n        \"'\": \"'\",\r\n        '\\\\': '\\\\',\r\n        '\\r': 'r',\r\n        '\\n': 'n',\r\n        '\\u2028': 'u2028',\r\n        '\\u2029': 'u2029'\r\n    };\r\n\r\n    var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\r\n\r\n    var escapeChar = function(match) {\r\n        return '\\\\' + escapes[match];\r\n    };\r\n\r\n    // JavaScript micro-templating, similar to John Resig's implementation.\r\n    // Underscore templating handles arbitrary delimiters, preserves whitespace,\r\n    // and correctly escapes quotes within interpolated code.\r\n    // NB: `oldSettings` only exists for backwards compatibility.\r\n    function template(text, settings, oldSettings) {\r\n        if (!settings && oldSettings) settings = oldSettings;\r\n        settings = settings || {};\r\n        settings = zrUtil.defaults(settings, templateSettings, true);\r\n\r\n        // Combine delimiters into one regular expression via alternation.\r\n        var matcher = RegExp([\r\n            (settings.escape || noMatch).source,\r\n            (settings.interpolate || noMatch).source,\r\n            (settings.evaluate || noMatch).source\r\n        ].join('|') + '|$', 'g');\r\n\r\n        // Compile the template source, escaping string literals appropriately.\r\n        var index = 0;\r\n        var source = \"__p+='\";\r\n        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\r\n            source += text.slice(index, offset).replace(escaper, escapeChar);\r\n            index = offset + match.length;\r\n\r\n            if (escape) {\r\n                source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\r\n            } else if (interpolate) {\r\n                source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\r\n            } else if (evaluate) {\r\n                source += \"';\\n\" + evaluate + \"\\n__p+='\";\r\n            }\r\n\r\n            // Adobe VMs need the match returned to produce the correct offest.\r\n            return match;\r\n        });\r\n        source += \"';\\n\";\r\n\r\n        // If a variable is not specified, place data values in local scope.\r\n        if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\r\n\r\n        source = \"var __t,__p='',__j=Array.prototype.join,\" +\r\n            \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\r\n            source + 'return __p;\\n';\r\n\r\n        try {\r\n            var render = new Function(settings.variable || 'obj', source);\r\n        } catch (e) {\r\n            e.source = source;\r\n            throw e;\r\n        }\r\n\r\n        var template = function(data) {\r\n            return render.call(this, data);\r\n        };\r\n\r\n        // Provide the compiled source as a convenience for precompilation.\r\n        var argument = settings.variable || 'obj';\r\n        template.source = 'function(' + argument + '){\\n' + source + '}';\r\n\r\n        return template;\r\n    }\r\n\r\n    function isEmpty(obj) {\r\n        if (obj == null) return true;\r\n        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;\r\n    }\r\n    function Class() {}\r\n    Class.extend = function(proto) {\r\n        var base = function() {},\r\n            member,\r\n            that = this,\r\n            subclass = proto && proto.init ? proto.init : function () {\r\n                that.apply(this, arguments);\r\n            },\r\n            fn;\r\n\r\n        base.prototype = that.prototype;\r\n        fn = subclass.fn = subclass.prototype = new base();\r\n\r\n        for (member in proto) {\r\n            if (proto[member] != null && proto[member].constructor === Object) {\r\n                // Merge object members\r\n                fn[member] = zrUtil.mergeAll([{}, base.prototype[member], proto[member]],true);\r\n            } else {\r\n                fn[member] = proto[member];\r\n            }\r\n        }\r\n\r\n        fn.constructor = subclass;\r\n        subclass.extend = that.extend;\r\n\r\n        return subclass;\r\n    };\r\n\r\n    module.exports = {\r\n        inherits: inherits,\r\n        getUUID: getUUID,\r\n        distance: distance,\r\n        getPolylineLength: getPolylineLength,\r\n        max: max,\r\n        min: min,\r\n        isEmpty: isEmpty,\r\n        orthogonalPath: orthogonalPath,\r\n        polylineIntersectsRectangle: polylineIntersectsRectangle,\r\n        scorePath: scorePath,\r\n        forwardPath: forwardPath,\r\n        traslatePoints: traslatePoints,\r\n        getEndPoint: getEndPoint,\r\n        getConnectorPoints: getConnectorPoints,\r\n        tangentRotation: tangentRotation,\r\n        collinearity: collinearity,\r\n        translationMatrix: translationMatrix,\r\n        scaleMatrix: scaleMatrix,\r\n        round: enhancedRound,\r\n        getLength: getLength,\r\n        getAngle: getAngle,\r\n        getRect: getRect,\r\n        StackedMap: StackedMap,\r\n        getMaxLineLength: getMaxLineLength,\r\n        randomColor: randomColor,\r\n        template: template,\r\n        isUndefined: isUndefined,\r\n        getSoltPoints:getSoltPoints,\r\n        collinearReduction: collinearReduction,\r\n        Class:Class\r\n    };\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/util.js\n// module id = 65\n// module chunks = 0","\r\n\r\n    /**\r\n      * Creates an instance of Point\r\n      *\r\n      *\r\n      * @constructor\r\n      * @this {Point}\r\n      * @param {Number} x The x coordinate of point.\r\n      * @param {Number} y The y coordinate of point.\r\n      * Note: Even if it is named Point this class should be named Dot as Dot is closer\r\n      * then Point from math perspective.\r\n      **/\r\n    function Point(x, y){\r\n        /**The x coordinate of point*/\r\n        this.x = x;\r\n\r\n        /**The y coordinate of point*/\r\n        this.y = y;\r\n\r\n\r\n    }\r\n\r\n    /**Creates a {Point} out of JSON parsed object\r\n     *@param {JSONObject} o - the JSON parsed object\r\n     *@return {Point} a newly constructed Point\r\n     **/\r\n    Point.load = function(o){\r\n        var newPoint = new Point(Number(o.x), Number(o.y));\r\n        return newPoint;\r\n    };\r\n\r\n\r\n    /**Creates an array of points from an array of {JSONObject}s\r\n     *@param {Array} v - the array of JSONObjects\r\n     *@return an {Array} of {Point}s\r\n     **/\r\n    Point.loadArray = function(v){\r\n        var newPoints = [];\r\n        for(var i=0; i< v.length; i++){\r\n            newPoints.push(Point.load(v[i]));\r\n        }\r\n        return newPoints;\r\n    };\r\n\r\n\r\n    /**Clones an array of points\r\n     *@param {Array} v - the array of {Point}s\r\n     *@return an {Array} of {Point}s\r\n     **/\r\n    Point.cloneArray = function(v){\r\n        var newPoints = [];\r\n        for(var i=0; i< v.length; i++){\r\n            newPoints.push(v[i].clone());\r\n        }\r\n        return newPoints;\r\n    };\r\n\r\n    Point.prototype = {\r\n        constructor : Point,\r\n\r\n        transform:function(matrix){\r\n            var oldX = this.x;\r\n            var oldY = this.y;\r\n            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];\r\n            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];\r\n        },\r\n\r\n        /**Tests if this point is similar to other point\r\n         *@param {Point} anotherPoint - the other point\r\n         **/\r\n        equals:function(anotherPoint){\r\n            if(! (anotherPoint instanceof Point) ){\r\n                return false;\r\n            }\r\n            return (this.x == anotherPoint.x)\r\n            && (this.y == anotherPoint.y)\r\n        },\r\n\r\n        /**Clone current Point\r\n         **/\r\n        clone: function(){\r\n            var newPoint = new Point(this.x, this.y);\r\n            return newPoint;\r\n        },\r\n\r\n        add: function(point) {\r\n            this.x = this.x + point.x;\r\n            this.y = this.y + point.y;\r\n            return this;\r\n        },\r\n\r\n        /**Tests to see if a point (x, y) is within a range of current Point\r\n         *@param {Numeric} x - the x coordinate of tested point\r\n         *@param {Numeric} y - the x coordinate of tested point\r\n         *@param {Numeric} radius - the radius of the vicinity\r\n         **/\r\n        near:function(x, y, radius){\r\n            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));\r\n\r\n            return (distance <= radius);\r\n        },\r\n\r\n        contains: function(x,y){\r\n            return this.x == x && this.y == y;\r\n        },\r\n\r\n        toString:function(){\r\n            return '[' + this.x + ',' + this.y + ']';\r\n        },\r\n\r\n        getPoints:function(){\r\n            return [this];\r\n        }\r\n    };\r\n    module.exports = Point;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/Point.js\n// module id = 66\n// module chunks = 0","\r\n\r\n    /**\r\n      * Creates an instance of a Line. A Line is actually a segment and not a pure\r\n      * geometrical Line\r\n      *\r\n      * @constructor\r\n      * @this {Line}\r\n      * @param {Point} startPoint - starting point of the line\r\n      * @param {Point} endPoint - the ending point of the line\r\n      **/\r\n    function Line(startPoint, endPoint){\r\n        /**Starting {@link Point} of the line*/\r\n        this.startPoint = startPoint;\r\n\r\n        /**Ending {@link Point} of the line*/\r\n        this.endPoint = endPoint;\r\n\r\n        /**Serialization type*/\r\n        this.oType = 'Line'; //object type used for JSON deserialization\r\n    }\r\n\r\n    /**Creates a {Line} out of JSON parsed object\r\n     *@param {JSONObject} o - the JSON parsed object\r\n     *@return {Line} a newly constructed Line\r\n     **/\r\n    Line.load = function(o){\r\n        var newLine = new Line(\r\n            Point.load(o.startPoint),\r\n            Point.load(o.endPoint)\r\n        );\r\n\r\n        return newLine;\r\n    };\r\n\r\n    Line.prototype = {\r\n        contructor: Line,\r\n\r\n\r\n\r\n        clone:function(){\r\n            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());\r\n            return ret;\r\n        },\r\n\r\n        equals:function(anotherLine){\r\n            if(!anotherLine instanceof Line){\r\n                return false;\r\n            }\r\n            return this.startPoint.equals(anotherLine.startPoint)\r\n            && this.endPoint.equals(anotherLine.endPoint)\r\n        },\r\n\r\n        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)\r\n         * Algorithm: Compute line's equation and see if (x, y) verifies it.\r\n         * @param {Number} x - the X coordinates\r\n         * @param {Number} y - the Y coordinates\r\n         **/\r\n        contains: function(x, y){\r\n            // if the point is inside rectangle bounds of the segment\r\n            if (Math.min(this.startPoint.x, this.endPoint.x) <= x\r\n                && x <= Math.max(this.startPoint.x, this.endPoint.x)\r\n                && Math.min(this.startPoint.y, this.endPoint.y) <= y\r\n                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {\r\n\r\n                // check for vertical line\r\n                if (this.startPoint.x == this.endPoint.x) {\r\n                    return x == this.startPoint.x;\r\n                } else { // usual (not vertical) line can be represented as y = a * x + b\r\n                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);\r\n                    var b = this.startPoint.y - a * this.startPoint.x;\r\n                    return y == a * x + b;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        },\r\n\r\n        /*\r\n         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)\r\n         *@param {Number} x - the x coordinates\r\n         *@param {Number} y - the y coordinates\r\n         *@param {Number} radius - the radius to search for\r\n         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n         *@see \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n         **/\r\n        near:function(x,y,radius){\r\n\r\n            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle\r\n                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)\r\n                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))\r\n                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;\r\n            }\r\n\r\n            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle\r\n                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)\r\n                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))\r\n                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;\r\n            }\r\n\r\n\r\n            var startX = Math.min(this.endPoint.x,this.startPoint.x);\r\n            var startY = Math.min(this.endPoint.y,this.startPoint.y);\r\n            var endX = Math.max(this.endPoint.x,this.startPoint.x);\r\n            var endY = Math.max(this.endPoint.y,this.startPoint.y);\r\n\r\n            /*We will compute the distance from point to the line\r\n             * by using the algorithm from\r\n             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n             * */\r\n\r\n            //First we need to find a,b,c of the line equation ax + by + c = 0\r\n            var a = this.endPoint.y - this.startPoint.y;\r\n            var b = this.startPoint.x - this.endPoint.x;\r\n            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);\r\n\r\n            //Secondly we get the distance \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );\r\n\r\n            //Thirdly we get coordinates of closest line's point to target point\r\n            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates\r\n            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n\r\n            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment\r\n                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment\r\n\r\n            return  r;\r\n\r\n        },\r\n\r\n        /**we need to create a new array each time, or we will affect the actual shape*/\r\n        getPoints:function(){\r\n            var points = [];\r\n            points.push(this.startPoint);\r\n            points.push(this.endPoint);\r\n            return points;\r\n        },\r\n\r\n        /**Return the {Point} corresponding the t certain t value\r\n         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/\r\n        getPoint: function(t){\r\n            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;\r\n            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;\r\n\r\n            return new Point(Xp, Yp);\r\n        },\r\n\r\n        // /**\r\n        //  * Returns the middle of the line\r\n        //  * @return {Point} the middle point\r\n        //  * */\r\n        // getMiddle : function(){\r\n        //     return Util.getMiddle(this.startPoint, this.endPoint);\r\n        // },\r\n\r\n\r\n        // getLength : function(){\r\n        //     return Util.getLength(this.startPoint, this.endPoint);\r\n        // },\r\n\r\n        // /**\r\n        //  *Get bounds for this line\r\n        //  *@author Alex Gheorghiu <alex@scriptoid.com>\r\n        //  **/\r\n        // getBounds:function(){\r\n        //     return Util.getBounds(this.getPoints());\r\n        // },\r\n\r\n        /**String representation*/\r\n        toString:function(){\r\n            return 'line(' + this.startPoint + ',' + this.endPoint + ')';\r\n        }\r\n    };\r\n    module.exports = Line;\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/LineStruct.js\n// module id = 67\n// module chunks = 0","'use strict';\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var apiList = [\r\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',\r\n        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',\r\n        \"remove\", \"_getParentZr\", \"changeSelectConnectorType\"\r\n    ];\r\n\r\n    function ExtensionAPI(instance) {\r\n        zrUtil.each(apiList, function (name) {\r\n            this[name] = zrUtil.bind(instance[name], instance);\r\n        }, this);\r\n    }\r\n\r\n    module.exports = ExtensionAPI;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/ExtensionApi.js\n// module id = 68\n// module chunks = 0","/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n    var zrUtil = require('./core/util');\n\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: require('./Painter')\n    };\n\n    var instances = {};    // ZRender实例map索引\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.6.3';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function (dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function (id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        // TODO WebGL\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        // 修改 storage.delFromStorage, 每次删除元素之前删除动画\n        // FIXME 有点ugly\n        var oldDelFromStorage = storage.delFromStorage;\n        var oldAddToStorage = storage.addToStorage;\n\n        storage.delFromStorage = function (el) {\n            oldDelFromStorage.call(storage, el);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToStorage = function (el) {\n            oldAddToStorage.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * 获取实例唯一标识\n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * 添加元素\n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * 删除元素\n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // var start = new Date();\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n            // var end = new Date();\n\n            // var log = document.getElementById('log');\n            // if (log) {\n            //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n            // }\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, dpr) {\n            return this.painter.pathToImage(e, dpr);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default'] 例如 crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Find hovered element\n         * @param {number} x\n         * @param {number} y\n         * @return {Object} {target, topTarget}\n         */\n        findHover: function (x, y) {\n            return this.handler.findHover(x, y);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/zrender.js\n// module id = 69\n// module chunks = 0","'use strict';\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = require('./core/util');\n    var vec2 = require('./core/vector');\n    var Draggable = require('./mixin/Draggable');\n\n    var Eventful = require('./mixin/Eventful');\n\n    var SILENT = 'silent';\n\n    function makeEventPacket(eveType, targetInfo, event) {\n        return {\n            type: eveType,\n            event: event,\n            // target can only be an element that is not silent.\n            target: targetInfo.target,\n            // topTarget can be a silent element.\n            topTarget: targetInfo.topTarget,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch,\n            which: event.which\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * {target, topTarget, x, y}\n         * @private\n         * @type {Object}\n         */\n        this._hovered = {};\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var lastHovered = this._hovered;\n            var lastHoveredTarget = lastHovered.target;\n\n            // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n            // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n            // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n            // See #6198.\n            if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n                lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n                lastHoveredTarget = lastHovered.target;\n            }\n\n            var hovered = this._hovered = this.findHover(x, y);\n            var hoveredTarget = hovered.target;\n\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = {};\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * 设置默认的cursor style\n         * @param {string} [cursorStyle='default'] 例如 crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * 事件分发代理\n         *\n         * @private\n         * @param {Object} targetInfo {target, topTarget} 目标图形元素\n         * @param {string} eventName 事件名称\n         * @param {Object} event 事件对象\n         */\n        dispatchToElement: function (targetInfo, eventName, event) {\n            targetInfo = targetInfo || {};\n            var el = targetInfo.target;\n            if (el && el.silent) {\n                return;\n            }\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                // 冒泡到顶级 zrender 对象\n                this.trigger(eventName, eventPacket);\n                // 分发事件到用户自定义层\n                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @return {model:zrender/Element}\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            var out = {x: x, y: y};\n\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                var hoverCheckResult;\n                if (list[i] !== exclude\n                    // getDisplayList may include ignored item in VML mode\n                    && !list[i].ignore\n                    && (hoverCheckResult = isHover(list[i], x, y))\n                ) {\n                    !out.topTarget && (out.topTarget = list[i]);\n                    if (hoverCheckResult !== SILENT) {\n                        out.target = list[i];\n                        break;\n                    }\n                }\n            }\n\n            return out;\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY);\n            var hoveredTarget = hovered.target;\n\n            if (name === 'mousedown') {\n                this._downEl = hoveredTarget;\n                this._downPoint = [event.zrX, event.zrY];\n                // In case click triggered before mouseup\n                this._upEl = hoveredTarget;\n            }\n            else if (name === 'mosueup') {\n                this._upEl = hoveredTarget;\n            }\n            else if (name === 'click') {\n                if (this._downEl !== this._upEl\n                    // Original click event is triggered on the whole canvas element,\n                    // including the case that `mousedown` - `mousemove` - `mouseup`,\n                    // which should be filtered, otherwise it will bring trouble to\n                    // pan and zoom.\n                    || !this._downPoint\n                    // Arbitrary value\n                    || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4\n                ) {\n                    return;\n                }\n                this._downPoint = null;\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            var isSilent;\n            while (el) {\n                // If clipped by ancestor.\n                // FIXME: If clipPath has neither stroke nor fill,\n                // el.clipPath.contain(x, y) will always return false.\n                if (el.clipPath && !el.clipPath.contain(x, y))  {\n                    return false;\n                }\n                if (el.silent) {\n                    isSilent = true;\n                }\n                el = el.parent;\n            }\n            return isSilent ? SILENT : true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/Handler.js\n// module id = 70\n// module chunks = 0","'use strict';\n/**\n * Storage内容仓库模块\n * @module zrender/Storage\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = require('./core/util');\n    var env = require('./core/env');\n\n    var Group = require('./container/Group');\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     * 内容仓库 (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * 返回所有图形的绘制队列\n         * @param {boolean} [update=false] 是否在返回前更新该数组\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n         *\n         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * 更新图形的绘制队列。\n         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var userSetClipPath = el.clipPath;\n            if (userSetClipPath) {\n\n                // FIXME 效率影响\n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                // Recursively add clip path\n                while (currentClipPath) {\n                    // clipPath 的变换是基于使用这个 clipPath 的元素\n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n\n                    clipPaths.push(currentClipPath);\n\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.clipPath;\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * 添加图形(Shape)或者组(Group)到根节点\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            if (el.__storage === this) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToStorage(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * 删除指定的图形(Shape)或者组(Group)\n         * @param {string|Array.<string>} [el] 如果为空清空整个Storage\n         */\n        delRoot: function (el) {\n            if (el == null) {\n                // 不指定el清空\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (el instanceof Array) {\n                for (var i = 0, l = el.length; i < l; i++) {\n                    this.delRoot(el[i]);\n                }\n                return;\n            }\n\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromStorage(el);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToStorage: function (el) {\n            el.__storage = this;\n            el.dirty(false);\n\n            return this;\n        },\n\n        delFromStorage: function (el) {\n            if (el) {\n                el.__storage = null;\n            }\n\n            return this;\n        },\n\n        /**\n         * 清空并且释放Storage\n         */\n        dispose: function () {\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/Storage.js\n// module id = 71\n// module chunks = 0","// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/core/timsort.js\n// module id = 72\n// module chunks = 0","'use strict';\n/**\n * 动画主类, 调度和管理所有动画控制器\n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n\n    var requestAnimationFrame = require('./requestAnimationFrame');\n\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         * 添加 clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         * 添加 animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time, delta);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * 开始运行动画\n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * 停止运行动画\n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * 清除所有动画片段\n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] 是否循环播放动画\n         * @param  {Function} [options.getter=null]\n         *         如果指定getter函数，会通过getter函数取属性值\n         * @param  {Function} [options.setter=null]\n         *         如果指定setter函数，会通过setter函数设置属性值\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            this.addAnimator(animator);\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/animation/Animation.js\n// module id = 73\n// module chunks = 0","'use strict';\n/**\n * 事件辅助类\n * @module zrender/core/event\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = require('../mixin/Eventful');\n    var env = require('./env');\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n        // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n        // If e.which has been defined, if may be readonly,\n        // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n        var button = e.button;\n        if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n            e.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * preventDefault and stopPropagation.\n     * Notice: do not do that in zrender. Upper application\n     * do that if necessary.\n     *\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event对象\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    function notLeftMouse(e) {\n        // If e.which is undefined, considered as left mouse event.\n        return e.which > 1;\n    }\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n        notLeftMouse: notLeftMouse,\n\n        stop: stop,\n        // 做向上兼容\n        Dispatcher: Eventful\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/core/event.js\n// module id = 74\n// module chunks = 0","\n\n    module.exports = (typeof window !== 'undefined' &&\n                ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window))\n                // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\n                || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))\n                || window.mozRequestAnimationFrame\n                || window.webkitRequestAnimationFrame)\n            )\n            || function (func) {\n                setTimeout(func, 16);\n            };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/animation/requestAnimationFrame.js\n// module id = 75\n// module chunks = 0","\n\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerEventNames = {\n        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n    };\n\n    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n        var nm = name.replace('mouse', 'pointer');\n        return pointerEventNames[nm] ? nm : name;\n    });\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null).target,\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        // Do not do any preventDefault here. Upper application do that if necessary.\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement({target: gestureInfo.target}, type, gestureInfo.event);\n        }\n    }\n\n    // function onMSGestureChange(proxy, event) {\n    //     if (event.translationX || event.translationY) {\n    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n    //     }\n    //     if (event.scale !== 1) {\n    //         event.pinchX = event.offsetX;\n    //         event.pinchY = event.offsetY;\n    //         event.pinchScale = event.scale;\n    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n    //     }\n    // }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // 忽略包含在root中的dom引起的mouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch开始响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered, and must before `mousedown` triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch移动响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch结束响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        },\n\n        pointerdown: function (event) {\n            domHandlers.mousedown.call(this, event);\n\n            // if (useMSGuesture(this, event)) {\n            //     this._msGesture.addPointer(event.pointerId);\n            // }\n        },\n\n        pointermove: function (event) {\n            // FIXME\n            // pointermove is so sensitive that it always triggered when\n            // tap(click) on touch screen, which affect some judgement in\n            // upper application. So, we dont support mousemove on MS touch\n            // device yet.\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mousemove.call(this, event);\n            }\n        },\n\n        pointerup: function (event) {\n            domHandlers.mouseup.call(this, event);\n        },\n\n        pointerout: function (event) {\n            // pointerout will be triggered when tap on touch screen\n            // (IE11+/Edge on MS Surface) after click event triggered,\n            // which is inconsistent with the mousout behavior we defined\n            // in touchend. So we unify them.\n            // (check domHandlers.touchend for detailed explanation)\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n\n    // function useMSGuesture(handlerProxy, event) {\n    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n    // }\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * 为控制类实例初始化dom 事件处理函数\n     *\n     * @inner\n     * @param {module:zrender/Handler} instance 控制类实例\n     */\n    function initDomHandler(instance) {\n        zrUtil.each(touchHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(pointerHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(mouseHandlerNames, function (name) {\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        });\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (env.pointerEventsSupported) { // Only IE11+/Edge\n            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n            // at the same time.\n            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n            // screen, which do not occurs in pointer event.\n            // So we use pointer event to both detect touch gesture and mouse behavior.\n            mountHandlers(pointerHandlerNames, this);\n\n            // FIXME\n            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n            // which does not prevent defuault behavior occasionally (which may cause view port\n            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n            // touch screen. And we only support click behavior on MS touch screen now.\n\n            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n            // We dont support touch on IE on win7.\n            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n            // if (typeof MSGesture === 'function') {\n            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n            // }\n        }\n        else {\n            if (env.touchEventsSupported) {\n                mountHandlers(touchHandlerNames, this);\n                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n            }\n\n            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n            // mouse event can not be handle in those devices.\n            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n            // mouseevent after touch event triggered, see `setTouchTimer`.\n            mountHandlers(mouseHandlerNames, this);\n        }\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/dom/HandlerProxy.js\n// module id = 76\n// module chunks = 0","'use strict';\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = require('./event');\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/core/GestureMgr.js\n// module id = 77\n// module chunks = 0","'use strict';\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n\n    var Layer = require('./Layer');\n\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.__builtin__) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n\n            clipPath.setTransform(ctx);\n            ctx.beginPath();\n            clipPath.buildPath(ctx, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root 绘图容器\n     * @param {module:zrender/Storage} storage\n     * @param {Object} opts\n     */\n    var Painter = function (root, storage, opts) {\n\n        this.type = 'canvas';\n\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * 绘图容器\n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            if (opts.width != null) {\n                root.width = opts.width;\n            }\n            if (opts.height != null) {\n                root.height = opts.height;\n            }\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n\n            this._domRoot = root;\n        }\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        getType: function () {\n            return 'canvas';\n        },\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._domRoot;\n        },\n\n        getViewportRootOffset: function () {\n            var viewportRoot = this.getViewportRoot();\n            if (viewportRoot) {\n                return {\n                    offsetLeft: viewportRoot.offsetLeft || 0,\n                    offsetTop: viewportRoot.offsetTop || 0\n                };\n            }\n        },\n\n        /**\n         * 刷新\n         * @param {boolean} [paintAll=false] 强制绘制所有displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.__builtin__ && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuiltinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuiltinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.__builtin__) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.__builtin__ = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            layersMap[zlevel] = layer;\n\n            // Vitual layer will not directly show on the screen.\n            // (It can be a WebGL layer and assigned to a ZImage element)\n            // But it still under management of zrender.\n            if (!layer.virtual) {\n                if (prevLayer) {\n                    var prevDom = prevLayer.dom;\n                    if (prevDom.nextSibling) {\n                        domRoot.insertBefore(\n                            layer.dom,\n                            prevDom.nextSibling\n                        );\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n                else {\n                    if (domRoot.firstChild) {\n                        domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n            }\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuiltinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (!layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * 获取所有已创建的层\n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuiltinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // 层中的元素数量有发生变化\n            this.eachBuiltinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * 清除hover层外所有内容\n         */\n        clear: function () {\n            this.eachBuiltinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * 修改指定zlevel的绘制参数\n         *\n         * @param {string} zlevel\n         * @param {Object} config 配置对象\n         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * 删除指定层\n         * @param {number} zlevel 层所在的zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * 区域大小变化后重绘\n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // 优化没有实际改变的resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * 清除单独的一个层\n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * 释放\n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            var zlevel;\n\n            var self = this;\n            function findAndDrawOtherLayer(smaller, larger) {\n                var zlevelList = self._zlevelList;\n                if (smaller == null) {\n                    smaller = -Infinity;\n                }\n                var intermediateLayer;\n                for (var i = 0; i < zlevelList.length; i++) {\n                    var z = zlevelList[i];\n                    var layer = self._layers[z];\n                    if (!layer.__builtin__ && z > smaller && z < larger) {\n                        intermediateLayer = layer;\n                        break;\n                    }\n                }\n                if (intermediateLayer && intermediateLayer.renderToCanvas) {\n                    imageLayer.ctx.save();\n                    intermediateLayer.renderToCanvas(imageLayer.ctx);\n                    imageLayer.ctx.restore();\n                }\n            }\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n\n                if (el.zlevel !== zlevel) {\n                    findAndDrawOtherLayer(zlevel, el.zlevel);\n                    zlevel = el.zlevel;\n                }\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            findAndDrawOtherLayer(zlevel, Infinity);\n\n            return imageLayer.dom;\n        },\n        /**\n         * 获取绘图区域宽度\n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * 获取绘图区域高度\n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            // IE8 does not support getComputedStyle, but it use VML.\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        pathToImage: function (path, dpr) {\n            dpr = dpr || this.dpr;\n\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            var rect = path.getBoundingRect();\n            var style = path.style;\n            var shadowBlurSize = style.shadowBlur;\n            var shadowOffsetX = style.shadowOffsetX;\n            var shadowOffsetY = style.shadowOffsetY;\n            var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\n            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n            var width = rect.width + leftMargin + rightMargin;\n            var height = rect.height + topMargin + bottomMargin;\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.scale(dpr, dpr);\n            ctx.clearRect(0, 0, width, height);\n            ctx.dpr = dpr;\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [leftMargin - rect.x, topMargin - rect.y];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            path.updateTransform();\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/Painter.js\n// module id = 78\n// module chunks = 0","/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * 创建dom\n     *\n     * @inner\n     * @param {string} id dom id 待用\n     * @param {string} type dom type，such as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // 没append呢，请原谅我这样写，清晰~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id不作为索引用，避免可能造成的重名，定义为私有属性\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * 每次清空画布的颜色\n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * 是否开启动态模糊\n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n            this.ctx.__currentValues = {};\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n            this.ctxBack.__currentValues = {};\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * 清空该层画布\n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/Layer.js\n// module id = 79\n// module chunks = 0","/**\r\n * 选中节点后，出现的操作框及按钮\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Node = require(\"../Node\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../graphic.js\");\r\n    var Connector = require(\"../shapes/Connector.js\");\r\n    var env = require('zrender/lib/core/env');\r\n    var icon = require('./IconOperation');\r\n    var symbolUtil = require('../shapes/Symbol');\r\n    function OperationNode(node, zr, api,forbidEdit) {\r\n        Node.call(this);\r\n        this.node = node;\r\n        this.zr = zr;\r\n        this.forbidEdit = forbidEdit;\r\n        this._api = api;\r\n        this.render();\r\n    }\r\n\r\n    //事件\r\n    OperationNode.ARROW_DRAGEND = \"OperationNode:dragendArrow\";\r\n    OperationNode.ARROW_DRAG = \"OperationNode:dragArrow\";\r\n    OperationNode.ARROW_DRAGSTART = \"OperationNode:dragstartArrow\";\r\n    OperationNode.DELETE_CLICK = \"OperationNode:deleteClick\";\r\n    OperationNode.DEL = \"DEL\";\r\n    if(!env.canvasSupported) {//IE8不支持canvas 以及base64  此处是为了兼容IE8. 实际都可以用SVG图标,但没有找到好的SVG图标, 如果有的话那就没有必要用这些base64了\r\n        //内置操作图标的图像\r\n        OperationNode.opicons = {\r\n            STRAIGHT: icon.STRAIGHT_SVG,\r\n            JAGGED: icon.JAGGED_SVG,\r\n            CURVE: icon.CURVE_SVG,\r\n            DEL: icon.DEL_SVG\r\n        };\r\n    }else{\r\n        OperationNode.opicons = {\r\n            STRAIGHT: icon.STRAIGHT_IMG,\r\n            JAGGED: icon.JAGGED_IMG,\r\n            CURVE: icon.CURVE_IMG,\r\n            DEL: icon.DEL_SVG\r\n        };\r\n    }\r\n\r\n    OperationNode.prototype.render = function() {\r\n        this.renderBase();\r\n        if (!this.forbidEdit) {\r\n            this.renderOther();\r\n        }\r\n    };\r\n\r\n    OperationNode.prototype.renderBase = function() {\r\n        this.createOperation();\r\n    };\r\n\r\n    OperationNode.prototype.createOperation = function() {\r\n        var me = this;\r\n        if (!this.node.selectStyle) {\r\n            this.virtualRect = new graphic.Polyline({ style: { lineDash: [2] } });\r\n            this.virtualRect.isSelfComputePos = true;  // 自己计算位置\r\n            this.add(this.virtualRect);\r\n        } else {\r\n            this._api.getZr().addHover(this.node, this.node.selectStyle);\r\n        }\r\n\r\n        if (this.node.operationIcons) {\r\n            zrUtil.each(this.node.operationIcons, function(item) {\r\n                //检查是否是内置图标\r\n                var opIconInstance = null;\r\n                var operationIcon = OperationNode.opicons[item.name.toUpperCase() + \"\"]\r\n                if (operationIcon) {\r\n\r\n                    if (this.forbidEdit) {\r\n                        return;\r\n                    }\r\n                    if (item.name == OperationNode.DEL) {\r\n                        //垃圾桶\r\n                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#000000' },z:me.node.z+1,rectHover: true }, { x: 0, y: 0, width: 10, height: 15 });\r\n                        if(item.iconPath) {\r\n                            opIconInstance = new graphic.Image({\r\n                                style: {\r\n                                    image:item.iconPath,\r\n                                    width:15,\r\n                                    height:15\r\n                                },\r\n                                z: me.node.z + 2 //zIndex 置为 节点+2 节点+1为组\r\n                            });\r\n                        }\r\n\r\n                        if(item.callback){\r\n                            opIconInstance.on(\"click\", function(e) {\r\n                                e.data = item;\r\n                                e.node = me.node;  // 将所附的节点也传递出去\r\n                                if (item.callback) {\r\n                                    item.callback(e);\r\n                                }\r\n                            });\r\n                        }else{\r\n                            opIconInstance.on(\"click\", function(e) {\r\n                                var params = {};\r\n                                params.event = e;\r\n                                params.target = this;\r\n                                params.type = OperationNode.DELETE_CLICK;\r\n                                me.trigger(params.type, params);\r\n                            });\r\n                        }\r\n\r\n\r\n                    } else {\r\n                        if(!env.canvasSupported){\r\n                            var rect = { x: 0, y: 0, width: 15, height: 15 };\r\n                            opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#000000' },draggable:true,z:me.node.z+2,lineType: Connector[\"TYPE_\" + item.name.toUpperCase()],rectHover: true }, rect);\r\n                        }else{\r\n                            var imageUrl = document.createElement('img');\r\n                            imageUrl.src = item.iconPath || operationIcon;\r\n                            opIconInstance = new graphic.Image({\r\n                                style: {\r\n                                    image:imageUrl,\r\n                                    width:15,\r\n                                    height:15\r\n                                },\r\n                                draggable: true,\r\n                                z: me.node.z + 2, //zIndex 置为 节点+2 节点+1为组\r\n                                lineType: Connector[\"TYPE_\" + item.name.toUpperCase()] //区分不同的线段\r\n                            });\r\n                        }\r\n\r\n                        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];\r\n                        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n                            opIconInstance.on(eveName, function(e) {\r\n                                var params = {};\r\n                                params.event = e;\r\n                                params.data = item.options\r\n                                params.type = \"OperationNode:\" + eveName + \"Arrow\";\r\n                                me.trigger(params.type, params);\r\n                            });\r\n                        });\r\n                    }\r\n\r\n                } else {\r\n                    opIconInstance = symbolUtil.createSymbol(item.iconPath, 0, 0, item.width || 15, item.height || 15, me.node.z+1, item.color||'#000');\r\n                    opIconInstance.on(\"click\", function(e) {\r\n                        e.data = item;\r\n                        e.node = me.node;  // 将所附的节点也传递出去\r\n                        if (item.callback) {\r\n                            item.callback(e);\r\n                        }\r\n                        var param = {event:e, type:\"OperationNode:\" + item.name + \"Click\"};\r\n                        me._api.trigger(param.type, param);\r\n                    });\r\n                }\r\n                opIconInstance.name = item.name;\r\n                me.add(opIconInstance);\r\n            });\r\n        }\r\n    };\r\n\r\n    OperationNode.prototype.refreshPostion = function(node,nodeRect) {\r\n        var i = 0;\r\n        var rbPoint = nodeRect.points[2]; //取右下角坐标\r\n        //1.定位虚框\r\n        this.virtualRect && this.virtualRect.setShape({ points: nodeRect.points });\r\n        //2.定位每个小图标\r\n        this.eachChild(function(nodeItem) {\r\n            if (!nodeItem.isSelfComputePos) {\r\n                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离\r\n                nodeItem.attr(\"position\", [rbPoint[0] + 8 + (i++ * 20), rbPoint[1] - 10]);\r\n            }\r\n        });\r\n\r\n        this.refreshPositionOther(node,nodeRect);\r\n    };\r\n\r\n    OperationNode.prototype.renderOther = function() {\r\n        //留给扩展使用\r\n    };\r\n    OperationNode.prototype.refreshPositionOther = function(node,nodeRect) {\r\n        //留给扩展使用\r\n        //3.定位整个operationNode\r\n        if (node.parent && node.parent.isBg && node.parent.isBg == true) {\r\n            this.attr(\"position\", [nodeRect.x, nodeRect.y])\r\n        } else {\r\n            var nodeShapeX = node.shape? node.shape.x:0;\r\n            var nodeSahpeY = node.shape? node.shape.y:0;\r\n            this.attr(\"position\", [nodeRect.x + node.parent.position[0]+nodeShapeX, nodeRect.y + node.parent.position[1]+nodeSahpeY])\r\n        }\r\n    };\r\n\r\n    OperationNode.prototype.cleanup = function() {\r\n        if(this.node.selectStyle) {\r\n            this._api.getZr().removeHover(this.node);\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(OperationNode, Node);\r\n    module.exports = OperationNode;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/manager/OperationNode.js\n// module id = 80\n// module chunks = 0","\r\n    var graphic = require('./graphic');\r\n    var util = require(\"./util.js\")\r\n    //创建Node类 所有形状都继承Node  包括fromJSON toJSON\r\n    function Node() {\r\n        this.resourceId = util.getUUID(); // 生成节点ID\r\n        graphic.Group.call(this);\r\n    }\r\n\r\n    /**\r\n     * 由父类实现\r\n     * @return {[type]} [description]\r\n     */\r\n    Node.prototype.render = function() {};\r\n\r\n    /**\r\n     * 由父类实现\r\n     * @param  {[type]} json [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    Node.prototype.getRect = function(json) {};\r\n\r\n    /**\r\n     * drawText\r\n     * @description 画一个文本\r\n     * @param {string} name\r\n     * @param {string} color\r\n     */\r\n    Node.prototype.drawText = function(name,color) {\r\n        var textName = this.bpmnInfo.name;\r\n        if(name != null){\r\n            textName = name;\r\n        }\r\n        var text = new graphic.Text({\r\n            style: {\r\n                text: textName,\r\n                color: color ? color : this.options.text.color,\r\n                textFont: '12px Microsoft YaHei'\r\n            },\r\n            zlevel: 20\r\n        });\r\n        //文字绘制的位置  \r\n        //x = 中心点.x - 起始位置.x - 文字宽度的一半\r\n        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n        //y = 中心点.y - 起始位置.y + 节点高度的一半 + 偏移值（6）\r\n        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;\r\n        text.attr(\"style\", { x: x, y: y });\r\n        return {\r\n            text: text,\r\n            rect: text.getBoundingRect()\r\n        };\r\n    };\r\n    /**\r\n     * refreshText\r\n     * @description 刷新文本\r\n     */\r\n    Node.prototype.refreshText = function() {\r\n        var text = this.childOfName(\"Title\");\r\n        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;\r\n        text.attr(\"style\", { x: x, y: y });\r\n    };\r\n    /**\r\n     * 由父类实现\r\n     * @return {[type]} [description]\r\n     */\r\n    Node.prototype.toJSON = function() {};\r\n\r\n    graphic.Util.inherits(Node, graphic.Group);\r\n    module.exports = Node;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/Node.js\n// module id = 81\n// module chunks = 0","/**\r\n * 连接线\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Util = require(\"../util.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../graphic.js\");\r\n    var Node = require(\"../Node.js\");\r\n    var symbolUtil = require(\"./Symbol.js\");\r\n    var Handle = require(\"./Handle.js\");\r\n    var EffectLine = require(\"./EffectLine.js\");\r\n    var ConnectionPoint = require(\"./ConnectionPoint.js\");\r\n    var Point = require(\"../Point.js\");\r\n    var Model = require(\"../model.js\");\r\n\r\n    Connector.TYPE_STRAIGHT = 'straight';\r\n    Connector.TYPE_JAGGED = 'jagged';\r\n    Connector.TYPE_CURVE = 'curve';\r\n    Connector.RADIUS = 3;\r\n    Connector.START_NODE = \"startNode\";\r\n    Connector.END_NODE = \"endNode\";\r\n    Connector.LEFT = \"left\";\r\n    Connector.RIGHT = \"right\";\r\n    Connector.TOP = \"top\";\r\n    Connector.BOTTOM = \"bottom\";\r\n    Connector.BOTTOM = \"bottom\";\r\n    Connector.SEPERATOR = \"-\";\r\n    Connector.NORMAL_COLOR = \"#BBBBBB\";\r\n    Connector.SELECTED_COLOR = '#74B7E0';\r\n    /**\r\n     * 构造函数\r\n     * @param {[type]} options [description]\r\n     */\r\n    function Connector(options) {\r\n        Node.call(this);\r\n        var opt = options || {};\r\n        if (opt.model) {\r\n            this.resourceId = opt.model.get(\"resourceId\");\r\n            this.model = opt.model;\r\n        } else {\r\n            this.resourceId = Util.getUUID(); // 生成节点ID\r\n            this.model = new Model({});\r\n        }\r\n        var defaultOptions = {\r\n            symbol: { type: \"arrow\", size: 10, color: Connector.NORMAL_COLOR, both:false }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n            style: { lineWidth: 1, stroke: Connector.NORMAL_COLOR, lineType: Connector.TYPE_STRAIGHT }, //样式\r\n            hoverStyle: { lineWidth: 2, stroke: Connector.SELECTED_COLOR }, //移上去的样式\r\n            arrowHoverStyle: { fill: Connector.SELECTED_COLOR},\r\n            shape: { points: null, smooth: false, smoothConstraint: null }, //形状\r\n            position: { startPos:null, endPos:null,  //指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n                        startOffset:[0,0],  // 起始线段离节点的偏移\r\n                        endOffset:[0,0],    // 终止线段离节点的偏移\r\n                        escapeDistance:[30,30], // 第一条折线的长度，最后一条折线的长度\r\n                        points:null    //不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n                    },\r\n            autoChangePosition: false,\r\n            isEdit: true, //是否可编辑\r\n            text: {\r\n                text: \"\",\r\n                color: '#000000', // 文本颜色\r\n                textFont: '12px Microsoft YaHei',\r\n                textPos: 'center'\r\n            },\r\n            z: 0\r\n        }\r\n\r\n        this.options = zrUtil.merge(defaultOptions, opt, true);\r\n        this.handles = [];\r\n        this.conPointsGroup = new graphic.Group();\r\n        this.startNode = null;\r\n        this.endNode = null;\r\n        this.line = null;\r\n        this.groupCurve = new graphic.Group();\r\n        this.icons = []; // 用于存储线段上面的操作图标\r\n        this.render();\r\n    }\r\n\r\n\r\n    /**\r\n     * 重新画线，如果传空则根据turningPoints 重新画线\r\n     * @param  {[type]} points [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    Connector.prototype.refresh = function(arrPoints) {\r\n        if (arrPoints) {\r\n            this.turningPoints = arrPoints;\r\n        }\r\n        //将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n        var points = Util.traslatePoints(this.turningPoints);\r\n\r\n        if ((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {\r\n            this.modifyCurve(this.turningPoints);\r\n        } else {\r\n            this.line.attr('shape', { points: points });\r\n        }\r\n\r\n        var lineText = this.childOfName('lineText');\r\n        //开始没有创建文本，后来传进来text了，需要先创建文本\r\n        if (!lineText && this.options.text.text) {\r\n            var text = this.drawText(\"lineText\", this.options.text.text, 0, 0);\r\n            this.add(text.text);\r\n            lineText = this.childOfName('lineText');\r\n        }\r\n        if (lineText) {\r\n            lineText.setStyle(\"text\", this.options.text.text);\r\n\r\n            var textPoint = this.getTextPostion(this.options.text);\r\n\r\n            // if (this.options.style.lineType == Connector.TYPE_STRAIGHT ) {\r\n            //     lineText.attr('rotation', this.getTextRotation(textPoint));\r\n            // }\r\n\r\n            lineText.attr(\"position\", textPoint);\r\n        }\r\n\r\n        this.refreshFromToSymbol(points);\r\n    };\r\n    /**\r\n     * 渲染\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.render = function() {\r\n        var that = this;\r\n        //1.创建箭头\r\n        this.renderFromToSymbol();\r\n\r\n        //2.创建线\r\n        this.curveLine = new graphic.BezierCurve({\r\n            //position: this.options.position,\r\n            style: this.options.style,\r\n            z: this.options.z\r\n        });\r\n        this.groupCurve.add(this.curveLine);\r\n        this.add(this.groupCurve);\r\n        this.add(this.conPointsGroup);\r\n\r\n        this.polyLine = new graphic.Polyline({\r\n            //position: this.options.position,\r\n            shape: this.options.shape,\r\n            style: this.options.style,\r\n            z: this.options.z\r\n        });\r\n        this.add(this.polyLine);\r\n\r\n        if ((this.options.style.lineType == Connector.TYPE_CURVE)) {\r\n            this.line = this.groupCurve;\r\n            this.createHoverStyle(this.curveLine);\r\n            this.polyLine.hide();\r\n        } else {\r\n            this.line = this.polyLine;\r\n            this.createHoverStyle(this.polyLine);\r\n            this.curveLine.hide();\r\n        }\r\n\r\n        //3.侦听线事件\r\n        var MOUSE_EVENT_NAMES = ['dblclick', 'click']; //'click', 'dblclick', 'mouseover', 'mouseout'\r\n        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n            this.line.on(eveName, zrUtil.bind(function(e) {\r\n                e.cancelBubble = true;\r\n                var params = {};\r\n                params.event = e;\r\n                params.type = \"Connector:\" + eveName;\r\n                params.target = that;\r\n                this.trigger(params.type, params);\r\n                this.setStyle({color:Connector.SELECTED_COLOR});\r\n                if (this.options.isEdit == false) {\r\n                    return; }\r\n\r\n                if (this.options.isEdit && this.turningPoints.length >= 2) {\r\n                    this.createAllconnectionPoint()\r\n                }\r\n                if (this.handles.length < 1) {\r\n                    this.shapeSetHandle();\r\n                }\r\n\r\n            }, this));\r\n        }, this);\r\n\r\n        //4.创建线上文本\r\n        if (this.options.text.text) {\r\n            var text = this.drawText(\"lineText\", this.options.text.text, 0, 0);\r\n            this.add(text.text);\r\n        }\r\n    };\r\n\r\n    Connector.prototype.renderFromToSymbol = function(options) {\r\n        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle\r\n        if (symbolTo) {\r\n            this.add(symbolTo);\r\n        }\r\n        //如果双向箭头 则再创建首箭头\r\n        if (this.options.symbol.both) {\r\n            var symbolFrom = this.createSymbol('fromSymbol', this.options); //arrow,triangle\r\n            if (symbolFrom) {\r\n                this.add(symbolFrom);\r\n            }\r\n        }\r\n    }\r\n\r\n    Connector.prototype.refreshFromToSymbol = function(points) {\r\n        var symbolTo = this.childOfName('toSymbol');\r\n        var symbolFrom = this.childOfName('fromSymbol');\r\n        if (symbolTo) {\r\n            if (this.options.effect && this.options.effect.show) {\r\n                new EffectLine(symbolTo, this.options, this.groupCurve, this.polyLine);\r\n            } else {\r\n                symbolTo.attr('position', points[points.length - 1]);\r\n                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]));\r\n            }\r\n        }\r\n\r\n        if (symbolFrom) {\r\n            symbolFrom.attr('position', points[0]);\r\n            symbolFrom.attr('rotation', Util.tangentRotation(this.turningPoints[1], this.turningPoints[0]));\r\n        }\r\n    }\r\n    //设置style\r\n    Connector.prototype.setStyle = function(options) {\r\n        var symbolTo = null;\r\n        if (options.color) {\r\n            if (this.options.style.lineType == Connector.TYPE_CURVE) {\r\n                this.groupCurve.eachChild(function(curve) {\r\n                    curve.attr(\"style\", { stroke: options.color });\r\n                    graphic.setNormalStyle(curve, { stroke: options.color });\r\n                });\r\n            } else {\r\n                this.polyLine.attr(\"style\", { stroke: options.color });\r\n                graphic.setNormalStyle(this.polyLine, { stroke: options.color });\r\n            }\r\n            symbolTo = this.childOfName('toSymbol');\r\n            if (symbolTo) {\r\n                symbolTo.attr(\"style\", { fill: options.color });\r\n                graphic.setNormalStyle(symbolTo, { fill: options.color });\r\n            }\r\n            this.options.style.stroke = options.color;\r\n            this.model.set(\"options.style.stroke\", options.color);\r\n            this.model.set(\"options.symbol.color\", options.color);\r\n            this.options.symbol.color = options.color;\r\n        }\r\n\r\n        if (options.text) {\r\n            var lineText = this.childOfName('lineText');\r\n            //开始没有创建文本，后来传进来text了，需要先创建文本\r\n            if (!lineText && options.text.text) {\r\n                var text = this.drawText(\"lineText\", options.text.text, 0, 0);\r\n                this.add(text.text);\r\n                lineText = this.childOfName('lineText');\r\n            }\r\n\r\n            if (options.text.text || options.text.text == \"\") {\r\n                lineText.setStyle(\"text\", options.text.text);\r\n                this.options.text.text = options.text.text;\r\n            }\r\n            var textPoint = this.getTextPostion(options.text);\r\n            lineText.attr(\"position\", textPoint);\r\n            if (options.text.textPos) {\r\n                this.options.text.textPos = options.text.textPos;\r\n            }\r\n\r\n            if (options.text.color) {\r\n                lineText.attr(\"style\", {\r\n                    fill: options.text.color\r\n                });\r\n                this.options.text.color = options.text.color;\r\n            }\r\n            this.model.set(\"options.text\", options.text);\r\n        }\r\n\r\n        if (options.symbol) {\r\n            if (options.symbol.type) {\r\n                this.options.symbol.type = options.symbol.type;\r\n                this.model.set(\"options.symbol.type\", options.symbol.type);\r\n            }\r\n            if (options.symbol.size) {\r\n                this.options.symbol.size = options.symbol.size;\r\n                this.model.set(\"options.symbol.size\", options.symbol.size);\r\n            }\r\n            if (options.symbol.color) {\r\n                this.options.symbol.color = options.symbol.color;\r\n                this.model.set(\"options.symbol.color\", options.symbol.color);\r\n            }\r\n            if (options.symbol.z) {\r\n                this.options.symbol.z = options.symbol.z;\r\n                this.model.set(\"options.symbol.z\", options.symbol.z);\r\n            }\r\n\r\n            symbolTo = this.childOfName('toSymbol');\r\n            if (symbolTo) {\r\n                this.remove(symbolTo);\r\n            }\r\n            var symbol = this.createSymbol(\"toSymbol\", this.model.get(\"options\"))\r\n            if (symbol) {\r\n                this.add(symbol);\r\n            }\r\n            this.refresh();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 获取线段的位置\r\n     * @param  {Object} text {text:'', color:'', textPos:''}\r\n     * @return {Object}      {x,y}\r\n     */\r\n    Connector.prototype.getTextPostion = function(text) {\r\n        var textPostion = [];\r\n        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n        if (text && text.textPos) {\r\n            var offset = text.offset || 0;\r\n            var arrOffset = offset;\r\n            if (!zrUtil.isArray(offset)) {\r\n                arrOffset = [offset, 0];\r\n            }\r\n            if (text.textPos == 'start') {\r\n                textPostion = [this.turningPoints[0].x + arrOffset[0], this.turningPoints[0].y + arrOffset[1]];\r\n            } else if (text.textPos == 'end') {\r\n                var points = Util.getMaxLineLength([this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]]);\r\n                var angle = Util.getAngle(points[0], points[1]);\r\n                var length = Util.distance(points[0], points[1]) - textWidth;\r\n                var newPoint = Util.getEndPoint(points[0], length, angle);\r\n                textPostion = [newPoint.x + arrOffset[0], newPoint.y + arrOffset[1]];\r\n            } else {\r\n                var midPoint = this.middle(text);\r\n                textPostion = [midPoint[0] + arrOffset[0], midPoint[1] + arrOffset[1]];\r\n            }\r\n        } else {\r\n            var position = this.middle(text);\r\n            textPostion = [position[0] - textWidth / 2, position[1]];\r\n        }\r\n\r\n        return textPostion;\r\n    };\r\n\r\n    /**\r\n     * 获取线段的旋转角度\r\n     * @param  {Object} textPostion {x,y}\r\n     * @return {Number}             角度值\r\n     */\r\n    Connector.prototype.getTextRotation = function(textPostion) {\r\n        //计算出极坐标的角度\r\n        var points = Util.getMaxLineLength(this.turningPoints);\r\n        var angle = -Math.atan2(points[1].y - textPostion[1], points[1].x - textPostion[0]); //,Math.PI/2\r\n        return angle;\r\n    };\r\n\r\n    Connector.prototype.createHoverStyle = function(el) {\r\n        if (this.options.hoverStyle) {\r\n            graphic.setElementHoverStl(el, this.options.hoverStyle);\r\n\r\n            var symbolTo = this.childOfName('toSymbol');\r\n            if (symbolTo) { graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle); }\r\n\r\n            el.on('mouseover', zrUtil.bind(function() {\r\n                    graphic.doEnterHover(el);\r\n                    if (symbolTo) { graphic.doEnterHover(symbolTo); }\r\n\r\n                    this.groupCurve.eachChild(function(line) {\r\n                        graphic.doEnterHover(line);\r\n                    });\r\n                }, this))\r\n                .on('mouseout', zrUtil.bind(function() {\r\n                    graphic.doLeaveHover(el);\r\n                    if (symbolTo) { graphic.doLeaveHover(symbolTo); }\r\n                    this.groupCurve.eachChild(function(line) {\r\n                        graphic.doLeaveHover(line);\r\n                    });\r\n                }, this));\r\n        }\r\n    };\r\n    /**\r\n     * 创建Node的连接点\r\n     * @private\r\n     *\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.createAllconnectionPoint = function() {\r\n        var sRect = this.startNode.getRect ? this.startNode.getRect().boundingRect : Util.getRect(this.startNode).boundingRect;\r\n\r\n        var eRect = this.endNode.getRect ? this.endNode.getRect().boundingRect : Util.getRect(this.endNode).boundingRect;\r\n\r\n        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\r\n        this.connectionPointCreate(this.startNode, sConnectorPoint.left, Connector.START_NODE + Connector.SEPERATOR + Connector.LEFT);\r\n        this.connectionPointCreate(this.startNode, sConnectorPoint.right, Connector.START_NODE + Connector.SEPERATOR + Connector.RIGHT);\r\n        this.connectionPointCreate(this.startNode, sConnectorPoint.top, Connector.START_NODE + Connector.SEPERATOR + Connector.TOP);\r\n        this.connectionPointCreate(this.startNode, sConnectorPoint.bottom, Connector.START_NODE + Connector.SEPERATOR + Connector.BOTTOM);\r\n\r\n        this.connectionPointCreate(this.endNode, eConnectorPoint.left, Connector.END_NODE + Connector.SEPERATOR + Connector.LEFT);\r\n        this.connectionPointCreate(this.endNode, eConnectorPoint.right, Connector.END_NODE + Connector.SEPERATOR + Connector.RIGHT);\r\n        this.connectionPointCreate(this.endNode, eConnectorPoint.top, Connector.END_NODE + Connector.SEPERATOR + Connector.TOP);\r\n        this.connectionPointCreate(this.endNode, eConnectorPoint.bottom, Connector.END_NODE + Connector.SEPERATOR + Connector.BOTTOM);\r\n\r\n\r\n        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n\r\n        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length - 1].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n    };\r\n\r\n    /**\r\n     * 创建连接点\r\n     * @private\r\n     * @param  {[type]} shape [description]\r\n     * @param  {[type]} point [description]\r\n     * @param  {[type]} type  [description]\r\n     * @return {[type]}       [description]\r\n     */\r\n    Connector.prototype.connectionPointCreate = function(shape, point, type) {\r\n        var conPoint = new ConnectionPoint(this, point, type, this.options);\r\n        this.conPointsGroup.add(conPoint.shape);\r\n    };\r\n\r\n    /**\r\n     * 清空控制点\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.clearHandles = function() {\r\n        for (var i = 0; i < this.handles.length; i++) {\r\n            this.remove(this.handles[i].handleShape);\r\n        }\r\n        this.handles = [];\r\n        if (this.conPointsGroup) {\r\n            this.conPointsGroup.removeAll();\r\n        }\r\n        //恢复原来的颜色\r\n        this.setStyle({color:this.options.style.stroke});\r\n    };\r\n\r\n    /**\r\n     * 创建拆线 线断的控制点\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.shapeSetHandle = function() {\r\n        for (var i = 1; i < this.turningPoints.length - 2; i++) {\r\n            var h;\r\n            var x, y;\r\n            //是否在一条线上\r\n            var isCollineaityFirst = Util.collinearity(this.turningPoints[i - 1], this.turningPoints[i], this.turningPoints[i + 1]);\r\n            var isCollineaitySecond = Util.collinearity(this.turningPoints[i], this.turningPoints[i + 1], this.turningPoints[i + 2]);\r\n            if ((!isCollineaityFirst && (!isCollineaitySecond || this.turningPoints[i + 1].equals(this.turningPoints[i + 2]))) || ((!isCollineaityFirst || this.turningPoints[i - 1].equals(this.turningPoints[i])) && !isCollineaitySecond)) {\r\n\r\n                if (this.turningPoints[i].x === this.turningPoints[i + 1].x) { //same vertical\r\n                    x = this.turningPoints[i].x;\r\n                    y = (this.turningPoints[i].y + this.turningPoints[i + 1].y) / 2;\r\n\r\n                    h = new Handle('h', x, y, this);\r\n\r\n\r\n                } else if (this.turningPoints[i].y === this.turningPoints[i + 1].y) { // same horizontal\r\n                    x = (this.turningPoints[i].x + this.turningPoints[i + 1].x) / 2;\r\n                    y = this.turningPoints[i].y;\r\n                    h = new Handle('v', x, y, this);\r\n                }\r\n                if (h) {\r\n                    this.add(h.handleShape);\r\n                    this.handles.push(h);\r\n                }\r\n\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * 创建箭头\r\n     * @param  {[type]} name       [description]\r\n     * @param  {[type]} options [description]\r\n     * @return {[type]}            [description]\r\n     */\r\n    Connector.prototype.createSymbol = function(name, options) {\r\n        var symbolType = options.symbol.type;\r\n        var symbolSize = options.symbol.size;\r\n        if (symbolType === 'none') {\r\n            return;\r\n        }\r\n\r\n        if (!zrUtil.isArray(symbolSize)) {\r\n            symbolSize = [symbolSize, symbolSize];\r\n        }\r\n\r\n        var symbolZIndex = options.z;\r\n\r\n        if (options.symbol.z) { symbolZIndex = options.symbol.z }\r\n\r\n        var symbolPath = symbolUtil.createSymbol(\r\n            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,\r\n            symbolSize[0], symbolSize[1], symbolZIndex, options.symbol.color\r\n        );\r\n        symbolPath.name = name;\r\n\r\n        return symbolPath;\r\n    };\r\n\r\n    /**\r\n     * 绘制线段上的文本\r\n     * @param  {[type]} content [description]\r\n     * @param  {[type]} name [description]\r\n     * @param  {[type]} x       [description]\r\n     * @param  {[type]} y       [description]\r\n     * @param  {[type]} color   [description]\r\n     * @return {[type]}         [description]\r\n     */\r\n    Connector.prototype.drawText = function(name, content, x, y, color) {\r\n        var textStyle = zrUtil.defaults(this.options.text, {text:content, x:x, y:y, fill:color}, true);\r\n        var text = new graphic.Text({\r\n            style: textStyle,\r\n            zlevel: 20,\r\n            name : name\r\n        });\r\n        return {\r\n            text: text,\r\n            rect: text.getBoundingRect()\r\n        };\r\n    };\r\n\r\n    /**\r\n     * 获取线段的中间值\r\n     * @return {[type]} text\r\n     */\r\n    Connector.prototype.middle = function() {\r\n\r\n        if (this.options.style.lineType == Connector.TYPE_STRAIGHT) {\r\n            var points = Util.getMaxLineLength(this.turningPoints);\r\n            //如果是求线段上的文字的中间值\r\n            // if(text) {\r\n            //     //取出字的长度，计算角度，\r\n            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n            //     var angle = Util.getAngle(points[0],points[1]);\r\n            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;\r\n            //     var newPoint = Util.getEndPoint(points[0], length, angle);\r\n            //     return [newPoint.x, newPoint.y];\r\n            // } else {\r\n            //     var middleX = (points[0].x + points[1].x)/2;\r\n            //     var middleY = (points[0].y + points[1].y) /2;\r\n            //     return [middleX, middleY];\r\n            // }\r\n            var middleX = (points[0].x + points[1].x) / 2;\r\n            var middleY = (points[0].y + points[1].y) / 2;\r\n            return [middleX, middleY];\r\n        } else if (this.options.style.lineType == Connector.TYPE_JAGGED) {\r\n\r\n            //find total distance\r\n            var distance = this.getLength();\r\n\r\n            //find between what turning points the half distance is\r\n            var index = -1;\r\n            var ellapsedDistance = 0;\r\n            for (var i = 0; i < this.turningPoints.length - 1; i++) {\r\n                index = i;\r\n                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);\r\n                if (ellapsedDistance + segment < distance / 2) {\r\n                    ellapsedDistance += segment;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            //we have the middle distance somewhere between i(ndex) and i(ndex)+1\r\n            if (index != -1) {\r\n                var missingDistance = distance / 2 - ellapsedDistance;\r\n                if (Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3)) { //vertical segment (same x)\r\n                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];\r\n                } else if (Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3)) { //horizontal segment (same y)\r\n                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];\r\n                } else {\r\n                    console.error(\"Connector:middle() - this should never happen \" + this.turningPoints[index] + \" \" + this.turningPoints[index + 1] + \" nr of points \" + this.turningPoints.length);\r\n                }\r\n\r\n            }\r\n        } else if (this.options.style.lineType == Connector.TYPE_CURVE) {\r\n            var t = 0.5;\r\n            var l = this.getLength();\r\n\r\n            var walked = 0;\r\n            for (var j = 0; j < this.turningPoints.length - 1; j++) {\r\n                if (walked + Util.distance(this.turningPoints[j], this.turningPoints[j + 1]) > l * t) {\r\n                    break;\r\n                }\r\n\r\n                walked += Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);\r\n            }\r\n\r\n            var rest = l * t - walked;\r\n            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);\r\n\r\n            //find the position/ration of the middle of Polyline on current segment\r\n            var segmentPercent = rest / currentSegmentLength;\r\n\r\n            var Xp = segmentPercent * (this.turningPoints[j + 1].x - this.turningPoints[j].x) + this.turningPoints[j].x;\r\n            var Yp = segmentPercent * (this.turningPoints[j + 1].y - this.turningPoints[j].y) + this.turningPoints[j].y;\r\n\r\n            return [Xp, Yp];\r\n\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * find total distance\r\n     * @return {Number} [description]\r\n     */\r\n    Connector.prototype.getLength = function() {\r\n        //find total distance\r\n        var distance = 0;\r\n        for (var i = 0; i < this.turningPoints.length - 1; i++) {\r\n            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);\r\n        }\r\n        return distance;\r\n    };\r\n\r\n    /**\r\n     * 转JSON对象 bpmn使用\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.toJSON = function() {\r\n\r\n        this.model.set(\"resourceId\", this.resourceId);\r\n        this.model.set(\"properties.type\", 14);\r\n\r\n        this.model.set(\"bounds.upperLeft.x\", this.position[0]);\r\n        this.model.set(\"bounds.upperLeft.y\", this.position[1]);\r\n        this.model.set(\"bounds.lowerRight.x\", parseInt(this.position[0] + this.getBoundingRect().width));\r\n        this.model.set(\"bounds.lowerRight.y\", parseInt(this.position[1] + this.getBoundingRect().height));\r\n        this.model.set(\"style.sPos\", this.options.position.startPos);\r\n        this.model.set(\"style.ePos\", this.options.position.endPos);\r\n        this.model.set(\"dockers\", this.turningPoints);\r\n        return this.model.option;\r\n    };\r\n\r\n    /**\r\n     * refreshModel  flow当序列化的时候调用 更新线段的位置 及线上的icons\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.refreshModel = function() {\r\n        this.model.set(\"options\", zrUtil.clone(this.options));\r\n        this.model.set(\"options.dockers\", this.turningPoints);\r\n        var icons = [];\r\n        for (var i = 0; i < this.icons.length; i++) {\r\n            var iconNode = this.icons[i];\r\n            var option = [iconNode.key, {\r\n                icon: iconNode.style.image,\r\n                width: iconNode.style.width,\r\n                height: iconNode.style.height\r\n            }];\r\n            icons.push(option);\r\n        }\r\n        this.model.set(\"icons\", icons);\r\n    };\r\n\r\n    /**\r\n     * 调整曲线的形状\r\n     * @param  {array} points 点数组\r\n     * @return {void}\r\n     */\r\n    Connector.prototype.modifyCurve = function(points) {\r\n        var sol = this.getCurvePoint(points);\r\n\r\n        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段\r\n        var willDelCurves = [];\r\n        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve; j++) {\r\n            willDelCurves.push(this.groupCurve.childAt(j));\r\n        }\r\n        zrUtil.each(willDelCurves, function(curve) {\r\n            this.groupCurve.remove(curve);\r\n        }, this);\r\n        // 2. 遍历曲线   如果存在则直接设置形状，否则创建\r\n        for (var i = 0; i < sol.length; i++) {\r\n            var line = this.groupCurve.childAt(i);\r\n            if (line) {\r\n                line.attr('shape', sol[i]);\r\n            } else {\r\n                var cure = new graphic.BezierCurve({\r\n                   // position: this.options.position,\r\n                    style: this.options.style,\r\n                    shape: sol[i],\r\n                    z: this.options.z\r\n                });\r\n                this.groupCurve.add(cure);\r\n                this.createHoverStyle(cure);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * 根据传入的点数组计算曲线的点\r\n     * @param  {array} P 点数组\r\n     * @return {object}        曲线的点数组\r\n     */\r\n    Connector.prototype.getCurvePoint = function(P) {\r\n        var n = P.length;\r\n        var sol = [];\r\n        if (n === 3) {\r\n            sol.push({\r\n                x1: P[0].x,\r\n                y1: P[0].y,\r\n                cpx1: P[1].x,\r\n                cpy1: P[1].y,\r\n                x2: P[2].x,\r\n                y2: P[2].y\r\n            });\r\n            return sol;\r\n        } else if (n === 4) {\r\n            sol.push({\r\n                x1: P[0].x,\r\n                y1: P[0].y,\r\n                cpx1: P[1].x,\r\n                cpy1: P[1].y,\r\n                cpx2: P[2].x,\r\n                cpy2: P[2].y,\r\n                x2: P[3].x,\r\n                y2: P[3].y\r\n            });\r\n            return sol;\r\n        }\r\n\r\n\r\n        /**Computes the sum between two point\r\n         *@param p1 - {Point}\r\n         *@param p2 - {Point}\r\n         *@return {Point} the sum of initial points\r\n         **/\r\n        function sum(p1, p2) {\r\n            return new Point(p1.x + p2.x, p1.y + p2.y);\r\n        }\r\n\r\n\r\n        /**Computes the division of a {Point} by a number\r\n         *@param p - {Point}\r\n         *@param nr - {Number}\r\n         *@return {Point}\r\n         **/\r\n        function divide(p, nr) {\r\n            if (nr == 0) {\r\n                throw \"Division by zero not allowed (yet :) \" + this.callee;\r\n            }\r\n            return new Point(p.x / nr, p.y / nr);\r\n        }\r\n\r\n        /**Computes the multiplication of a {Point} by a number\r\n         *@param p - {Point}\r\n         *@param nr - {Number}\r\n         *@return {Point}\r\n         **/\r\n        function multiply(p, nr) {\r\n            return new Point(p.x * nr, p.y * nr);\r\n        }\r\n\r\n\r\n\r\n\r\n        /*\r\n         *I do not get why first 4 must be 0 and last 3 of same value.....\r\n         *but otherwise we will get division by zero\r\n         */\r\n        var k = [0, 0, 0];\r\n\r\n        var j;\r\n        for (j = 0; j <= n - 3; j++) {\r\n            k.push(j);\r\n        }\r\n\r\n        k.push(n - 3, n - 3);\r\n\r\n\r\n\r\n        for (var i = 1; i <= n - 3; i++) {\r\n            //q1 - compute start point\r\n            var q1 = divide(sum(multiply(P[i], k[i + 4] - k[i + 2]), multiply(P[i + 1], k[i + 2] - k[i + 1])), k[i + 4] - k[i + 1]);\r\n\r\n            //q0 - compute 1st controll point\r\n            var q_01 = (k[i + 3] - k[i + 2]) / (k[i + 3] - k[i + 1]);\r\n            var q_02 = divide(sum(multiply(P[i - 1], k[i + 3] - k[i + 2]), multiply(P[i], k[i + 2] - k[i])), k[i + 3] - k[i]);\r\n            var q_03 = multiply(q1, (k[i + 2] - k[i + 1]) / (k[i + 3] - k[i + 1]));\r\n            var q0 = sum(multiply(q_02, q_01), q_03);\r\n\r\n            //q2 - compute 2nd controll point\r\n            var q2 = divide(sum(multiply(P[i], k[i + 4] - k[i + 3]), multiply(P[i + 1], k[i + 3] - k[i + 1])), k[i + 4] - k[i + 1]);\r\n\r\n            //q3 - compute end point\r\n            var q_31 = (k[i + 3] - k[i + 2]) / (k[i + 4] - k[i + 2]);\r\n            var q_32 = divide(sum(multiply(P[i + 1], k[i + 5] - k[i + 3]), multiply(P[i + 2], k[i + 3] - k[i + 2])), k[i + 5] - k[i + 2]);\r\n            var q_33 = multiply(q2, (k[i + 4] - k[i + 3]) / (k[i + 4] - k[i + 2]));\r\n            var q3 = sum(multiply(q_32, q_31), q_33);\r\n\r\n            //store solution\r\n            //\r\n            sol.push({\r\n                x1: q0.x,\r\n                y1: q0.y,\r\n                cpx1: q1.x,\r\n                cpy1: q1.y,\r\n                cpx2: q2.x,\r\n                cpy2: q2.y,\r\n                x2: q3.x,\r\n                y2: q3.y\r\n            });\r\n        }\r\n\r\n        return sol;\r\n    };\r\n\r\n\r\n    Util.inherits(Connector, Node);\r\n\r\n    module.exports = Connector;\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/shapes/Connector.js\n// module id = 82\n// module chunks = 0","'use strict';\n// Symbol factory\r\n\r\n\r\n    var graphic = require('../graphic');\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    /**\r\n     * Triangle shape\r\n     * @inner\r\n     */\r\n    var Triangle = graphic.extendShape({\r\n        type: 'triangle',\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n        buildPath: function (path, shape) {\r\n            var cx = shape.cx;\r\n            var cy = shape.cy;\r\n            var width = shape.width / 2;\r\n            var height = shape.height / 2;\r\n            path.moveTo(cx, cy - height);\r\n            path.lineTo(cx + width, cy + height);\r\n            path.lineTo(cx - width, cy + height);\r\n            path.closePath();\r\n        }\r\n    });\r\n    /**\r\n     * Diamond shape\r\n     * @inner\r\n     */\r\n    var Diamond = graphic.extendShape({\r\n        type: 'diamond',\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n        buildPath: function (path, shape) {\r\n            var cx = shape.cx;\r\n            var cy = shape.cy;\r\n            var width = shape.width / 2;\r\n            var height = shape.height / 2;\r\n            path.moveTo(cx, cy - height);\r\n            path.lineTo(cx + width, cy);\r\n            path.lineTo(cx, cy + height);\r\n            path.lineTo(cx - width, cy);\r\n            path.closePath();\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Pin shape\r\n     * @inner\r\n     */\r\n    var Pin = graphic.extendShape({\r\n        type: 'pin',\r\n        shape: {\r\n            // x, y on the cusp\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        buildPath: function (path, shape) {\r\n            var x = shape.x;\r\n            var y = shape.y;\r\n            var w = shape.width / 5 * 3;\r\n            // Height must be larger than width\r\n            var h = Math.max(w, shape.height);\r\n            var r = w / 2;\r\n\r\n            // Dist on y with tangent point and circle center\r\n            var dy = r * r / (h - r);\r\n            var cy = y - h + r + dy;\r\n            var angle = Math.asin(dy / r);\r\n            // Dist on x with tangent point and circle center\r\n            var dx = Math.cos(angle) * r;\r\n\r\n            var tanX = Math.sin(angle);\r\n            var tanY = Math.cos(angle);\r\n\r\n            path.arc(\r\n                x, cy, r,\r\n                Math.PI - angle,\r\n                Math.PI * 2 + angle\r\n            );\r\n\r\n            var cpLen = r * 0.6;\r\n            var cpLen2 = r * 0.7;\r\n            path.bezierCurveTo(\r\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\r\n                x, y - cpLen2,\r\n                x, y\r\n            );\r\n            path.bezierCurveTo(\r\n                x, y - cpLen2,\r\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\r\n                x - dx, cy + dy\r\n            );\r\n            path.closePath();\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Arrow shape\r\n     * @inner\r\n     */\r\n    var Arrow = graphic.extendShape({\r\n\r\n        type: 'arrow',\r\n\r\n        shape: {\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var height = shape.height;\r\n            var width = shape.width;\r\n            var x = shape.x;\r\n            var y = shape.y;\r\n            var dx = width / 3 * 2;\r\n            ctx.moveTo(x, y);\r\n            ctx.lineTo(x + dx, y + height);\r\n            ctx.lineTo(x, y + height / 4 * 3);\r\n            ctx.lineTo(x - dx, y + height);\r\n            ctx.lineTo(x, y);\r\n            ctx.closePath();\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Map of path contructors\r\n     * @type {Object.<string, module:zrender/graphic/Path>}\r\n     */\r\n    var symbolCtors = {\r\n        line: graphic.Line,\r\n\r\n        rect: graphic.Rect,\r\n\r\n        roundRect: graphic.Rect,\r\n\r\n        square: graphic.Rect,\r\n\r\n        circle: graphic.Circle,\r\n\r\n        diamond: Diamond,\r\n\r\n        pin: Pin,\r\n\r\n        arrow: Arrow,\r\n\r\n        triangle: Triangle\r\n    };\r\n\r\n    var symbolShapeMakers = {\r\n\r\n        line: function (x, y, w, h, shape) {\r\n            // FIXME\r\n            shape.x1 = x;\r\n            shape.y1 = y + h / 2;\r\n            shape.x2 = x + w;\r\n            shape.y2 = y + h / 2;\r\n        },\r\n\r\n        rect: function (x, y, w, h, shape) {\r\n            shape.x = x;\r\n            shape.y = y;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        roundRect: function (x, y, w, h, shape) {\r\n            shape.x = x;\r\n            shape.y = y;\r\n            shape.width = w;\r\n            shape.height = h;\r\n            shape.r = Math.min(w, h) / 4;\r\n        },\r\n\r\n        square: function (x, y, w, h, shape) {\r\n            var size = Math.min(w, h);\r\n            shape.x = x;\r\n            shape.y = y;\r\n            shape.width = size;\r\n            shape.height = size;\r\n        },\r\n\r\n        circle: function (x, y, w, h, shape) {\r\n            // Put circle in the center of square\r\n            shape.cx = x + w / 2;\r\n            shape.cy = y + h / 2;\r\n            shape.r = Math.min(w, h) / 2;\r\n        },\r\n\r\n        diamond: function (x, y, w, h, shape) {\r\n            shape.cx = x + w / 2;\r\n            shape.cy = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        pin: function (x, y, w, h, shape) {\r\n            shape.x = x + w / 2;\r\n            shape.y = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        arrow: function (x, y, w, h, shape) {\r\n            shape.x = x + w / 2;\r\n            shape.y = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        triangle: function (x, y, w, h, shape) {\r\n            shape.cx = x + w / 2;\r\n            shape.cy = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        }\r\n    };\r\n\r\n    var symbolBuildProxies = {};\r\n    for (var name in symbolCtors) {\r\n        symbolBuildProxies[name] = new symbolCtors[name]();\r\n    }\r\n\r\n    var Symbol = graphic.extendShape({\r\n\r\n        type: 'symbol',\r\n\r\n        shape: {\r\n            symbolType: '',\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        beforeBrush: function () {\r\n            var style = this.style;\r\n            var shape = this.shape;\r\n            // FIXME\r\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\r\n                style.textPosition = ['50%', '40%'];\r\n                style.textAlign = 'center';\r\n                style.textVerticalAlign = 'middle';\r\n            }\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var symbolType = shape.symbolType;\r\n            var proxySymbol = symbolBuildProxies[symbolType];\r\n            if (shape.symbolType !== 'none') {\r\n                if (!proxySymbol) {\r\n                    // Default rect\r\n                    symbolType = 'rect';\r\n                    proxySymbol = symbolBuildProxies[symbolType];\r\n                }\r\n                symbolShapeMakers[symbolType](\r\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\r\n                );\r\n                proxySymbol.buildPath(ctx, proxySymbol.shape);\r\n            }\r\n        }\r\n    });\r\n\r\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\r\n    var symbolPathSetColor = function (color) {\r\n        if (this.type !== 'image') {\r\n            var symbolStyle = this.style;\r\n            var symbolShape = this.shape;\r\n            if (symbolShape && symbolShape.symbolType === 'line') {\r\n                symbolStyle.stroke = color;\r\n            }\r\n            else if (this.__isEmptyBrush) {\r\n                symbolStyle.stroke = color;\r\n                symbolStyle.fill = '#fff';\r\n            }\r\n            else {\r\n                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\r\n                symbolStyle.fill && (symbolStyle.fill = color);\r\n                symbolStyle.stroke && (symbolStyle.stroke = color);\r\n            }\r\n            this.dirty();\r\n        }\r\n    };\r\n\r\n    var symbolUtil = {\r\n        /**\r\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\r\n         * @param {string} symbolType\r\n         * @param {number} x\r\n         * @param {number} y\r\n         * @param {number} w\r\n         * @param {number} h\r\n         * @param {number} z\r\n         * @param {string} color\r\n         */\r\n        createSymbol: function (symbolType, x, y, w, h, z, color) {\r\n            var isEmpty = symbolType.indexOf('empty') === 0;\r\n            if (isEmpty) {\r\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\r\n            }\r\n            var symbolPath;\r\n\r\n            if (symbolType.indexOf('image://') === 0) {\r\n                symbolPath = new graphic.Image({\r\n                    style: {\r\n                        image: symbolType.slice(8),\r\n                        x: x,\r\n                        y: y,\r\n                        width: w,\r\n                        height: h\r\n                    },\r\n                    z: z\r\n                });\r\n            }\r\n            else if (symbolType.indexOf('path://') === 0) {\r\n                symbolPath = graphic.makePath(symbolType.slice(7), {z: z, rectHover: true}, new BoundingRect(x, y, w, h));\r\n            }\r\n            else {\r\n                symbolPath = new Symbol({\r\n                    shape: {\r\n                        symbolType: symbolType,\r\n                        x: x,\r\n                        y: y,\r\n                        width: w,\r\n                        height: h\r\n                    },\r\n                    z: z\r\n                });\r\n            }\r\n\r\n            symbolPath.__isEmptyBrush = isEmpty;\r\n\r\n            symbolPath.setColor = symbolPathSetColor;\r\n\r\n            symbolPath.setColor(color);\r\n\r\n            return symbolPath;\r\n        }\r\n    };\r\n\r\n    module.exports = symbolUtil;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/shapes/Symbol.js\n// module id = 83\n// module chunks = 0","/**\r\n * 画句柄\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var graphic = require(\"../graphic.js\");\r\n    var Util = require(\"../util.js\");\r\n    function Handle(type, x, y, connector){\r\n        this.type = type;\r\n\r\n        this.x = x;\r\n\r\n        this.y = y;\r\n\r\n        this.visible = true;\r\n\r\n        this.connector = connector;\r\n\r\n        this.handleShape = new graphic.Circle({\r\n            shape: {\r\n                cx: x,\r\n                cy: y,\r\n                r: Handle.RADIUS\r\n            },\r\n\r\n            style: {\r\n                fill: \"rgb(0,255,0)\",\r\n                stroke:\"rgb(0,0,0)\"\r\n            },\r\n            z : connector.options.z + 2,  //节点Z为1 线段为0;\r\n            draggable:true\r\n        });\r\n\r\n        var that = this;\r\n        this.handleShape.on(\"drag\", function(e) {\r\n            that.actionConnector(e.offsetX,e.offsetY);\r\n        });\r\n       // return this.circle;\r\n    }\r\n\r\n    Handle.RADIUS = 4;\r\n\r\n    Handle.prototype = {\r\n\r\n        constructor : Handle,\r\n\r\n        equals : function(anotherHandle){\r\n            if(!anotherHandle instanceof Handle){\r\n                return false;\r\n            }\r\n\r\n            return this.type == anotherHandle.type\r\n            && this.x == anotherHandle.x\r\n            && this.y == anotherHandle.y\r\n            && this.visible == anotherHandle.visible;\r\n        },\r\n\r\n        /**\r\n         * 移动句柄\r\n         * @param  {[type]} newX [description]\r\n         * @param  {[type]} newY [description]\r\n         * @return {[type]}      [description]\r\n         */\r\n        actionConnector: function(newX, newY){\r\n            switch(this.type){\r\n                case 'v':\r\n                    var index;\r\n                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y\r\n                            && this.connector.turningPoints[i].y == this.y\r\n                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x\r\n                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)\r\n                        {\r\n                            index = i;\r\n                        }\r\n                    }\r\n                    var deltaY = newY - this.y;\r\n                    var translationMatrix = Util.translationMatrix(0, deltaY);\r\n\r\n                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n                    this.connector.turningPoints[index].transform(translationMatrix);\r\n                    this.connector.refresh();\r\n                    this.y = newY;  //将句柄新的位置赋值给y\r\n\r\n                    break;\r\n\r\n                case 'h':\r\n                    var index;\r\n                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x\r\n                            && this.connector.turningPoints[i].x == this.x\r\n                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y\r\n                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)\r\n                            {\r\n                            index = i;\r\n                        }\r\n                    }\r\n                    var deltaX = newX-this.x;\r\n                    var translationMatrix = Util.translationMatrix(deltaX, 0);\r\n                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n                    this.connector.turningPoints[index].transform(translationMatrix);\r\n                    this.connector.refresh();\r\n                    this.x = newX; //将句柄新的位置赋值给x\r\n\r\n                    break;\r\n            }\r\n           //. this.shape.updateMiddleText();\r\n        }\r\n    };\r\n    module.exports = Handle;\r\n\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/shapes/Handle.js\n// module id = 84\n// module chunks = 0","/**\r\n * 连线动态效果\r\n * @author miao.cunzhi\r\n */\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var curveUtil = require('zrender/lib/core/curve');\r\n    var symbolUtil = require('./Symbol.js');\r\n\r\n    function EffectLine(symbol, options, groupCurve, polyLine) {\r\n        this._lastFrame = 0;\r\n        this._lastFramePercent = 0;\r\n        this.symbol = symbol;\r\n        this.groupCurve = groupCurve;\r\n        this.initSymbol(options, polyLine);\r\n    }\r\n    var EffectLineProto = EffectLine.prototype;\r\n\r\n    EffectLineProto.initSymbol = function(options, polyLine) {\r\n        var that = this;\r\n        this.symbol.z2 = 100;\r\n        this.symbol.culling = true;\r\n        var period = options.effect.period * 1000;\r\n        this.symbol.__t = 0;\r\n        this.symbol.stopAnimation();\r\n        if ((options.style.lineType == \"curve\")) {\r\n            if (this.groupCurve) {\r\n                var i = 0;\r\n                period = period / this.groupCurve._children.length;\r\n                this.groupCurveAnimate(this.groupCurve._children[0], i, period);\r\n            }\r\n\r\n        } else {\r\n            this.symbol.animate('', true)\r\n                .when(period, {\r\n                    __t: 1\r\n                })\r\n                .delay(0)\r\n                .during(function() {\r\n                    that.updateSymbolPositionPolyline();\r\n                })\r\n                .start();\r\n            this.setAnimationPointsPolyline(polyLine.shape.points);\r\n        }\r\n\r\n    };\r\n\r\n    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {\r\n        var that = this;\r\n        if (curveLine == undefined) {\r\n            curveLine = this.groupCurve._children[0];\r\n            i = 0;\r\n        }\r\n        var points;\r\n        var pos = curveLine.shape;\r\n        points = [\r\n            [pos.x1, pos.y1],\r\n            [pos.x2, pos.y2],\r\n            [pos.cpx1, pos.cpy1],\r\n            [pos.cpx2, pos.cpy2]\r\n        ];\r\n        this.setAnimationPointsBezierCurve(points);\r\n        this.symbol.animate('')\r\n            .when(period, {\r\n                __t: 1\r\n            })\r\n            .delay(0)\r\n            .during(function() {\r\n                that.updateSymbolPositionBezierCurve();\r\n            })\r\n            .done(function() {\r\n                that.symbol.__t = 0;\r\n                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);\r\n            })\r\n            .start();\r\n\r\n    };\r\n\r\n\r\n    EffectLineProto.setAnimationPointsBezierCurve = function(points) {\r\n        this.symbol.__p1 = points[0];\r\n        this.symbol.__p2 = points[1];\r\n        this.symbol.__cp1 = points[2] || [\r\n            (points[0][0] + points[1][0]) / 2,\r\n            (points[0][1] + points[1][1]) / 2\r\n        ];\r\n        this.symbol.__cp2 = points[3];\r\n    };\r\n\r\n    EffectLineProto.updateSymbolPositionBezierCurve = function() {\r\n        var p1 = this.symbol.__p1;\r\n        var p2 = this.symbol.__p2;\r\n        var cp1 = this.symbol.__cp1;\r\n        var cp2 = this.symbol.__cp2;\r\n        var t = this.symbol.__t;\r\n        var pos = this.symbol.position;\r\n        var tx, ty;\r\n        if (cp2[0] != undefined) {\r\n            var cubicAt = curveUtil.cubicAt;\r\n            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;\r\n            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n            // Tangent\r\n            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n        } else {\r\n            var quadraticAt = curveUtil.quadraticAt;\r\n            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;\r\n            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);\r\n            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);\r\n            // Tangent\r\n            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);\r\n            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);\r\n        }\r\n        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;\r\n\r\n        this.symbol.ignore = false;\r\n    };\r\n\r\n    EffectLineProto.setAnimationPointsPolyline = function(points) {\r\n        this._points = points;\r\n        var accLenArr = [0];\r\n        var len = 0;\r\n        for (var i = 1; i < points.length; i++) {\r\n            var p1 = points[i - 1];\r\n            var p2 = points[i];\r\n            len += vec2.dist(p1, p2);\r\n            accLenArr.push(len);\r\n        }\r\n        if (len === 0) {\r\n            return;\r\n        }\r\n\r\n        for (var j = 0; j < accLenArr.length; j++) {\r\n            accLenArr[j] /= len;\r\n        }\r\n        this._offsets = accLenArr;\r\n        this._length = len;\r\n        this.symbol._lastFrame = 0;\r\n        this.symbol.__lastFramePercent = 0;\r\n    };\r\n\r\n    EffectLineProto.updateSymbolPositionPolyline = function() {\r\n        var t = this.symbol.__t;\r\n        var points = this._points;\r\n        var offsets = this._offsets;\r\n        var len = points.length;\r\n\r\n        if (!offsets) {\r\n            // Has length 0\r\n            return;\r\n        }\r\n\r\n        var lastFrame = this._lastFrame;\r\n        var frame;\r\n\r\n        if (t < this._lastFramePercent) {\r\n            // Start from the next frame\r\n            // PENDING start from lastFrame ?\r\n            var start = Math.min(lastFrame + 1, len - 1);\r\n            for (frame = start; frame >= 0; frame--) {\r\n                if (offsets[frame] <= t) {\r\n                    break;\r\n                }\r\n            }\r\n            // PENDING really need to do this ?\r\n            frame = Math.min(frame, len - 2);\r\n        } else {\r\n            for (var frame = lastFrame; frame < len; frame++) {\r\n                if (offsets[frame] > t) {\r\n                    break;\r\n                }\r\n            }\r\n            frame = Math.min(frame - 1, len - 2);\r\n        }\r\n        vec2.lerp(\r\n            this.symbol.position, points[frame], points[frame + 1],\r\n            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])\r\n        );\r\n\r\n        this._lastFrame = frame;\r\n        this._lastFramePercent = t;\r\n        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);\r\n        this.symbol.rotation = angle - Math.PI / 2;\r\n        this.symbol.ignore = false;\r\n    };\r\n    module.exports = EffectLine;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/shapes/EffectLine.js\n// module id = 85\n// module chunks = 0","/**\r\n * 控制点\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var graphic = require(\"../graphic.js\");\r\n    function ConnectionPoint(connector, point, type, options){\r\n        this.connector = connector;\r\n\r\n        this.point = point.clone();\r\n\r\n        this.type = type;\r\n\r\n        this.color = ConnectionPoint.NORMAL_COLOR;\r\n\r\n        this.oType = 'ConnectionPoint';\r\n\r\n        this.shape = new graphic.Circle({\r\n            shape: {\r\n                cx: this.point.x,\r\n                cy: this.point.y,\r\n                r: ConnectionPoint.RADIUS\r\n            },\r\n\r\n            style: {\r\n                fill: this.color,\r\n                stroke:'#000000'\r\n            },\r\n            z : options.z + 2  //节点Z为1 线段为0;\r\n        });\r\n        this.shape.type =  this.type;\r\n\r\n        this.shape.connector = connector;\r\n        //return this.circle;\r\n    }\r\n\r\n    ConnectionPoint.NORMAL_COLOR = \"#FFFF33\"; //yellow.\r\n\r\n    ConnectionPoint.OVER_COLOR = \"#FF9900\"; //orange\r\n\r\n    ConnectionPoint.CONNECTED_COLOR = \"#ff0000\"; //red\r\n\r\n    ConnectionPoint.RADIUS = 4;\r\n\r\n    ConnectionPoint.TYPE_FIGURE = 'figure';\r\n\r\n    ConnectionPoint.TYPE_CONNECTOR = 'connector';\r\n\r\n    ConnectionPoint.prototype = {\r\n\r\n        constructor : ConnectionPoint,\r\n\r\n        equals : function(anotherConnectionPoint){\r\n            return this.point.equals(anotherConnectionPoint.point)\r\n            && this.connector == anotherConnectionPoint.connector\r\n            && this.type == anotherConnectionPoint.type\r\n            && this.color == anotherConnectionPoint.color\r\n            && this.radius == anotherConnectionPoint.radius;\r\n        }\r\n\r\n\r\n    };\r\n    module.exports = ConnectionPoint;\r\n\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/shapes/ConnectionPoint.js\n// module id = 86\n// module chunks = 0","/**\r\n * 节点等的模型\r\n * 里面存的数据用来处理序列化和反序列化\r\n * @class fish.topo.model\r\n */\r\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var clazzUtil = require('./clazz');\r\n\r\n    function Model(option, parentModel,  extraOpt) {\r\n        this.parentModel = parentModel;\r\n        this.option = option;\r\n\r\n        // Simple optimization\r\n        if (this.init) {\r\n            if (arguments.length <= 3) {\r\n                this.init(option, parentModel,  extraOpt);\r\n            }\r\n            else {\r\n                this.init.apply(this, arguments);\r\n            }\r\n        }\r\n    }\r\n\r\n    Model.prototype = {\r\n\r\n        constructor: Model,\r\n\r\n        /**\r\n         * Model 的初始化函数\r\n         * @private\r\n         * @param {Object} option\r\n         */\r\n        init: function (option) {\r\n            zrUtil.merge(option, this.getDefaultOption());\r\n        },\r\n\r\n        getDefaultOption: function () {\r\n            if (!this.hasOwnProperty('__defaultOption')) {\r\n                var optList = [];\r\n                var Class = this.constructor;\r\n                while (Class) {\r\n                    var opt = Class.prototype.defaultOption;\r\n                    opt && optList.push(opt);\r\n                    Class = Class.superClass;\r\n                }\r\n\r\n                var defaultOption = {};\r\n                for (var i = optList.length - 1; i >= 0; i--) {\r\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\r\n                }\r\n                this.__defaultOption = defaultOption;\r\n            }\r\n            return this.__defaultOption;\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        mergeOption: function (option) {\r\n            zrUtil.merge(this.option, option, true);\r\n        },\r\n\r\n        /**\r\n         * 获取model的某个属性的值\r\n         * @param {string} path model中的属性\r\n         * @return {String}\r\n         *\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *          node.model.get(\"options.text\");\r\n         */\r\n        get: function (path, ignoreParent) {\r\n            if (!path) {\r\n                return this.option;\r\n            }\r\n\r\n            if (typeof path === 'string') {\r\n                path = path.split('.');\r\n            }\r\n\r\n            var obj = this.option;\r\n            var parentModel = this.parentModel;\r\n            for (var i = 0; i < path.length; i++) {\r\n                // obj could be number/string/... (like 0)\r\n                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;\r\n                if (obj == null) {\r\n                    break;\r\n                }\r\n            }\r\n            if (obj == null && parentModel && !ignoreParent) {\r\n                obj = parentModel.get(path);\r\n            }\r\n            return obj;\r\n        },\r\n\r\n        /**\r\n         * 设置model的某个属性的值\r\n         * @param {string} path model中的属性\r\n         * @param {String} value 所需要设置的值\r\n         * @return {String}\r\n         *\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *          node.model.set(\"options.text\",\"例子\");\r\n         */\r\n        set: function (path, value) {\r\n            var obj = this.option;\r\n\r\n            if (path.indexOf(\".\") == -1) {\r\n                obj[path] = value;\r\n            } else {\r\n                var fieldArray  = path.split('.');\r\n                var n = fieldArray.length;\r\n                var currentRef = obj;\r\n                var fieldName;\r\n\r\n                for (var i = 0; i < n - 1; i++) {\r\n                    fieldName = fieldArray[i];\r\n                    if(currentRef[fieldName] == null) {\r\n                        currentRef[fieldName] = {};\r\n                    }\r\n                    currentRef = currentRef[fieldName];\r\n                }\r\n                fieldName = fieldArray[n-1];\r\n                currentRef[fieldName] = value;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        getShallow: function (key, ignoreParent) {\r\n            var option = this.option;\r\n            var val = option && option[key];\r\n            var parentModel = this.parentModel;\r\n            if (val == null && parentModel && !ignoreParent) {\r\n                val = parentModel.getShallow(key);\r\n            }\r\n            return val;\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        getModel: function (path, parentModel) {\r\n            var obj = this.get(path, true);\r\n            var thisParentModel = this.parentModel;\r\n            var model = new Model(\r\n                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))\r\n            );\r\n            return model;\r\n        },\r\n\r\n        /**\r\n         *清空model的option\r\n         * @private\r\n         */\r\n        isEmpty: function () {\r\n            return this.option == null;\r\n        },\r\n\r\n        restoreData: function () {},\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        clone: function () {\r\n            var Ctor = this.constructor;\r\n            return new Ctor(zrUtil.clone(this.option));\r\n        }\r\n    };\r\n\r\n    // Enable Model.extend.\r\n    clazzUtil.enableClassExtend(Model);\r\n\r\n    module.exports = Model;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/model.js\n// module id = 87\n// module chunks = 0","\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var clazz = {};\r\n\r\n    var TYPE_DELIMITER = '.';\r\n    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';\r\n    /**\r\n     * @public\r\n     */\r\n    var parseClassType = clazz.parseClassType = function (componentType) {\r\n        var ret = {main: '', sub: ''};\r\n        if (componentType) {\r\n            componentType = componentType.split(TYPE_DELIMITER);\r\n            ret.main = componentType[0] || '';\r\n            ret.sub = componentType[1] || '';\r\n        }\r\n        return ret;\r\n    };\r\n    /**\r\n     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数\r\n     */\r\n    clazz.enableClassExtend = function (RootClass, preConstruct) {\r\n        RootClass.extend = function (proto) {\r\n            var ExtendedClass = function () {\r\n                preConstruct && preConstruct.apply(this, arguments);\r\n                RootClass.apply(this, arguments);\r\n            };\r\n\r\n            zrUtil.extend(ExtendedClass.prototype, proto);\r\n\r\n            ExtendedClass.extend = this.extend;\r\n            ExtendedClass.superCall = superCall;\r\n            ExtendedClass.superApply = superApply;\r\n            zrUtil.inherits(ExtendedClass, this);\r\n            ExtendedClass.superClass = this;\r\n\r\n            return ExtendedClass;\r\n        };\r\n    };\r\n\r\n    // superCall should have class info, which can not be fetch from 'this'.\r\n    // Consider this case:\r\n    // class A has method f,\r\n    // class B inherits class A, overrides method f, f call superApply('f'),\r\n    // class C inherits class B, do not overrides method f,\r\n    // then when method of class C is called, dead loop occured.\r\n    function superCall(context, methodName) {\r\n        var args = zrUtil.slice(arguments, 2);\r\n        return this.superClass.prototype[methodName].apply(context, args);\r\n    }\r\n\r\n    function superApply(context, methodName, args) {\r\n        return this.superClass.prototype[methodName].apply(context, args);\r\n    }\r\n\r\n    /**\r\n     * @param {Object} entity\r\n     * @param {Object} options\r\n     * @param {boolean} [options.registerWhenExtend]\r\n     * @public\r\n     */\r\n    clazz.enableClassManagement = function (entity, options) {\r\n        options = options || {};\r\n\r\n        /**\r\n         * Component model classes\r\n         * key: componentType,\r\n         * value:\r\n         *     componentClass, when componentType is 'xxx'\r\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\r\n         * @type {Object}\r\n         */\r\n        var storage = {};\r\n\r\n        entity.registerClass = function (Clazz, componentType) {\r\n            if (componentType) {\r\n                componentType = parseClassType(componentType);\r\n\r\n                if (!componentType.sub) {\r\n                    if (storage[componentType.main]) {\r\n                        //已经注册过了，直接返回\r\n                        return;\r\n                    }\r\n                    storage[componentType.main] = Clazz;\r\n                }\r\n                else if (componentType.sub !== IS_CONTAINER) {\r\n                    var container = makeContainer(componentType);\r\n                    container[componentType.sub] = Clazz;\r\n                }\r\n            }\r\n            return Clazz;\r\n        };\r\n\r\n        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\r\n            var Clazz = storage[componentTypeMain];\r\n\r\n            if (Clazz && Clazz[IS_CONTAINER]) {\r\n                Clazz = subType ? Clazz[subType] : null;\r\n            }\r\n\r\n            if (throwWhenNotFound && !Clazz) {\r\n                throw new Error(\r\n                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'\r\n                );\r\n            }\r\n\r\n            return Clazz;\r\n        };\r\n\r\n        entity.getClassesByMainType = function (componentType) {\r\n            componentType = parseClassType(componentType);\r\n\r\n            var result = [];\r\n            var obj = storage[componentType.main];\r\n\r\n            if (obj && obj[IS_CONTAINER]) {\r\n                zrUtil.each(obj, function (o, type) {\r\n                    type !== IS_CONTAINER && result.push(o);\r\n                });\r\n            }\r\n            else {\r\n                result.push(obj);\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        entity.hasClass = function (componentType) {\r\n            // Just consider componentType.main.\r\n            componentType = parseClassType(componentType);\r\n            return !!storage[componentType.main];\r\n        };\r\n\r\n        /**\r\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\r\n         */\r\n        entity.getAllClassMainTypes = function () {\r\n            var types = [];\r\n            zrUtil.each(storage, function (obj, type) {\r\n                types.push(type);\r\n            });\r\n            return types;\r\n        };\r\n\r\n        /**\r\n         * If a main type is container and has sub types\r\n         * @param  {string}  componentType\r\n         * @return {boolean}\r\n         */\r\n        entity.hasSubTypes = function (componentType) {\r\n            componentType = parseClassType(componentType);\r\n            var obj = storage[componentType.main];\r\n            return obj && obj[IS_CONTAINER];\r\n        };\r\n\r\n        entity.parseClassType = parseClassType;\r\n\r\n        function makeContainer(componentType) {\r\n            var container = storage[componentType.main];\r\n            if (!container || !container[IS_CONTAINER]) {\r\n                container = storage[componentType.main] = {};\r\n                container[IS_CONTAINER] = true;\r\n            }\r\n            return container;\r\n        }\r\n\r\n        if (options.registerWhenExtend) {\r\n            var originalExtend = entity.extend;\r\n            if (originalExtend) {\r\n                entity.extend = function (proto) {\r\n                    var ExtendedClass = originalExtend.call(this, proto);\r\n                    return entity.registerClass(ExtendedClass, proto.type);\r\n                };\r\n            }\r\n        }\r\n\r\n        return entity;\r\n    };\r\n\r\n    module.exports = clazz;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/clazz.js\n// module id = 88\n// module chunks = 0","/**\r\n * 操作图标类\r\n * @author wang.xiaohu\r\n */\r\n\r\n\r\n    var IconOperation = {\r\n        STRAIGHT_SVG: 'M13.961,2.309c-0.051-0.122-0.148-0.22-0.27-0.27L13.5,2h-5C8.224,2,8,2.224,8,2.5S8.224,3,8.5,3h3.793L2.146,13.146c-0.195,0.195-0.195,0.512,0,0.707s0.512,0.195,0.707,0L13,3.707V7.5C13,7.776,13.225,8,13.5,8S14,7.776,14,7.5v-5L13.961,2.309z',\r\n        JAGGED_SVG: 'M653.604571 440.905143l289.499429 339.529143 414.134857-538.404572v195.803429h104.155429V0l-381.805715 144.969143 37.083429 97.426286 153.526857-58.294858-331.190857 430.738286-279.698286-327.753143-657.846857 663.552L75.483429 1024z',\r\n        CURVE_SVG: 'M956.9 67.6h-240v240h92.5c1.6 22.6 3.6 68.3-0.8 116.7C803.3 483 787.5 558 742.4 582c-45.5 24.2-121.1-6.6-218.7-89-57.5-48.5-109.5-80.6-154.3-95.3-43.7-14.3-82.3-13-114.6 4-53.6 28.2-86.2 96.8-96.7 204-4.3 43.5-4 84.2-2.9 111.5H68.3v240h240v-240H205.2c-1.1-25.6-1.5-65 2.6-106.6 6.1-61.5 23.1-140 70.2-164.7 45.3-23.8 119.1 5.7 213.5 85.3 59.4 50.1 112.7 83.3 158.5 98.5 44.5 14.9 83.5 13.6 116-3.6 52.2-27.7 83.3-94.4 92.6-198.1 4.4-49.5 2.7-95.2 1.1-120.4h97.4v-240zM258.3 907.2h-140v-140h140v140z m648.6-649.6h-140v-140h140v140z',\r\n        DEL_SVG: 'M73.641,45.957l-0.021,0.252c0,0.032,0.021,0.06,0.021,0.088c0,0.065-0.022,0.126-0.026,0.191l-2.685,54.878H70.91c-0.231,4.304-5.166,10.81-31.748,10.81c-26.58,0-31.509-6.506-31.746-10.81H7.41L4.731,46.488c-0.009-0.06-0.028-0.126-0.028-0.191c0-0.032,0.01-0.06,0.01-0.088l-0.01-0.252h0.028c0.099-0.466,0.364-0.919,0.784-1.353c3.439,3.477,17.191,4.051,33.646,4.051s30.221-0.574,33.642-4.051c0.426,0.434,0.711,0.887,0.784,1.353H73.641z M78.335,25.102v6.407c0,1.316-1.34,2.567-3.715,3.696c-6.266,2.936-19.777,4.975-35.459,4.975c-15.666,0-29.189-2.039-35.442-4.975C1.33,34.075,0,32.825,0,31.509v-6.407c0-3.374,8.681-6.286,21.359-7.724V3.929c0-2.16,1.768-3.929,3.93-3.929h26.314c2.164,0,3.938,1.773,3.938,3.938v13.296C68.98,18.606,78.333,21.611,78.335,25.102z M48.416,11.395c0-2.348-0.321-4.27-0.715-4.27c-0.393,0-2.641,0-4.979,0h-8.545c-2.352,0-4.592,0-4.989,0c-0.388,0-0.714,1.922-0.714,4.27v5.367l1.083-0.065c3.067-0.173,6.286-0.27,9.595-0.271c3.202,0,6.292,0.098,9.264,0.252V11.395z',\r\n        STRAIGHT_IMG: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAABQSURBVHjalJFBDoAwCMCqH5ef1wshIeqGSzgstEAAla8AArDFSniTTvbP/ltXv1KI6jSB23hTuHJ/4Iewg5swgUuYwsnOYZUj94sagyNyDwDa1hn7ZCOKwwAAAABJRU5ErkJggg==',\r\n        JAGGED_IMG: 'data:image/png;base64,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',\r\n        CURVE_IMG: 'data:image/png;base64,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',\r\n        DEL_IMG: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAOBAMAAADpk+DfAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAtUExURQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGgKD4AAAAPdFJOUwDH/g+agESj4Y6zUiRnh7lnwbkAAABLSURBVAjXY2BgYDZgAIEnnkCa7a5cYGwCwwklIOhhMBEEgmIGnlAgOMDAprhQUGgDA5vWdJciXJRGR0dTAgPzQ0FBSaBpzMbGBgwAIoUW3sQ2EdkAAAAASUVORK5CYII=',\r\n        CHANGE_LINE_TYPE_IMG: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAPBAMAAAD9gUllAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAqUExURQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoTzogAAAAOdFJOUwD+CC3uuR7gVXeeFEnMRIEDJwAAAGRJREFUCNdjYOCZwIAA7YuUQADM1nQsDQWBBBBnoSAYiBiAOGeROWwLIzpAYANEE7JpDBtQKAiYqQCmlI1BYOFqMMfcBQQERcEGmkBMFwwAcWzLQcBRCuwItTQQWD4JybQ5DAwAO74b0S83OyMAAAAASUVORK5CYII='\r\n    }\r\n    module.exports = IconOperation;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/manager/IconOperation.js\n// module id = 89\n// module chunks = 0","/**\r\n * flow连线管理类\r\n * @author miao.cunzhi\r\n */\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var ConnectionManager = require(\"../../../fish-topo-core/lib/manager/ConnectionManager.js\");\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var Util = require('../../../fish-topo-core/lib/util');\r\n    var Point = require(\"../../../fish-topo-core/lib/Point.js\");\r\n    var Constants = require(\"../util/FlowConstants.js\");\r\n\r\n    function FlowConnectionManager(api) {\r\n        ConnectionManager.call(this);\r\n        this.bundleOffset = 30; //多线段的偏移\r\n        this.bundleGap = 20; // 多线段的间隔\r\n        this.connectorMap = Util.StackedMap.createNew(); //存放多线段\r\n        this._api = api;\r\n    }\r\n\r\n    FlowConnectionManager.prototype.add = function(connector) {\r\n        this.connectors.push(connector);\r\n        //1.处理事件\r\n        this.handleConnectorEvent(connector);\r\n        //2.判断是否两节点相联\r\n        if(connector.startNode && connector.endNode) {\r\n            var key = this.getTwoNodeId(connector.startNode, connector.endNode);\r\n            this.connectorMap.add(key, connector);\r\n\r\n            this.handleConnectorShrink(connector);\r\n\r\n            this.bundleOffset = connector.options.bundleOffset || this.bundleOffset;\r\n            this.bundleGap = connector.options.bundleGap || this.bundleGap;\r\n            //2. 获取这个key对应的线段数组\r\n            var arrCons = this.connectorMap.get(key);\r\n            if (arrCons.length == 1) {\r\n                //两个节点只有一个连线的情况\r\n                //判断一下 model里有没有dockers，如果有则调用构造point数组  或者调用refreshConnector计算如何画线\r\n                var dockers = connector.options.dockers;\r\n                var points = [];\r\n                if (dockers && dockers.length >= 2) {\r\n                    points = Point.loadArray(dockers);\r\n                    connector.refresh(points);\r\n                } else {\r\n                    if (connector.options.position.points) {\r\n                        var arrStartEndPoint = this.getStartEndPoint(connector);\r\n                        points = connector.options.position.points;\r\n                        points.unshift(arrStartEndPoint[0]);\r\n                        points.push(arrStartEndPoint[1]);\r\n                        connector.refresh(points);\r\n                    } else {\r\n                        this.refreshConnector(arrCons[0], true);\r\n                    }\r\n                }\r\n            } else if (arrCons.length > 1) {\r\n                //两个节点有多个连线的情况\r\n                this.refreshCons(arrCons);\r\n            }\r\n        } else {\r\n            //处理没有 起始节点与终止节点时的连线\r\n            this.handleConnectorPoints(connector)\r\n        }\r\n\r\n        //3.设置模型\r\n        this.handleConnectorModel(connector);\r\n        return connector;\r\n    }\r\n\r\n    FlowConnectionManager.prototype.handleConnectorEvent = function(connector) {\r\n        if (connector.conPointsGroup) {\r\n            connector.conPointsGroup.on(\"click\", function(e) {\r\n                var arrSplit = e.target.type.split(Connector.SEPERATOR);\r\n                var connector = e.target.connector;\r\n                if (arrSplit[0] === Connector.START_NODE) {\r\n                    connector.options.position.startPos = arrSplit[1];\r\n                } else if (arrSplit[0] === Connector.END_NODE) {\r\n                    connector.options.position.endPos = arrSplit[1];\r\n                }\r\n                this.refreshConnector(connector, true);\r\n                e.cancelBubble = true;\r\n                var params = {};\r\n                params.event = e;\r\n                params.type = \"conPointsGroup:click\";\r\n                params.lineNode = this.selConnector;\r\n                this._api.trigger(params.type, params);\r\n            }.bind(this));\r\n        }\r\n\r\n\r\n        var MOUSE_EVENT_NAMES = ['click', 'dblclick'];\r\n        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n            connector.on(\"Connector:\" + eveName, function(e) {\r\n                var selected = e.target;\r\n                if (this.selConnector !== selected) {\r\n                    this.selConnector && this.refreshConnector(this.selConnector);\r\n                    this.selConnector = selected;\r\n                }\r\n                e.cancelBubble = true;\r\n                var params = {};\r\n                params.event = e;\r\n                params.type = eveName;\r\n                params.target = this.selConnector;\r\n                this._api.trigger(params.type, params);\r\n            }.bind(this));\r\n        }.bind(this));\r\n    }\r\n\r\n    FlowConnectionManager.prototype.handleConnectorModel = function(connector) {\r\n        connector.model.set(Constants.ELEMENT_TYPE, Constants.CONNECTION);\r\n        if(connector.startNode && connector.endNode) {\r\n            connector.model.set(Constants.START_ID, connector.startNode.id);\r\n            connector.model.set(Constants.END_ID, connector.endNode.id);\r\n        }\r\n        connector.model.set(Constants.OPTIONS, zrUtil.clone(connector.options));\r\n    }\r\n\r\n    FlowConnectionManager.prototype.handleConnectorShrink = function(connector) {\r\n        var that = this;\r\n        //双击收紧为一条线\r\n        connector.line.on(\"dblclick\", function() {\r\n            if (connector.options.isShrink == false) {\r\n                return;\r\n            }\r\n            var con = this.parent;\r\n            var startNode = con.startNode;\r\n            var endNode = con.endNode;\r\n            //1.获取所有的线段\r\n            var key = that.getTwoNodeId(startNode, endNode);\r\n            var cons = that.connectorMap.get(key);\r\n            if (cons.length == 1) {\r\n                return\r\n            }\r\n            //2.判断线是否处于隐藏状态\r\n            //2.将除中间的一条线进行隐藏\r\n            var half = parseInt(cons.length / 2);\r\n            for (var i = 0; i < cons.length; i++) {\r\n                if (i != (half)) {\r\n                    if (cons[i].ignore) {\r\n                        cons[i].show();\r\n                    } else {\r\n                        cons[i].hide();\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    //处理没有 起始节点与终止节点时的连线\r\n    FlowConnectionManager.prototype.handleConnectorPoints = function(connector) {\r\n        var options = connector.options;\r\n        var dockers = connector.options.dockers;\r\n        if (dockers && dockers.length >= 2) {\r\n            var points = Point.loadArray(dockers);\r\n            connector.refresh(points);\r\n        } else {\r\n            if (options.position && options.position.points) {\r\n                var oPoints = options.position.points;\r\n                connector.refresh(oPoints);\r\n            }\r\n        }\r\n    }\r\n\r\n    FlowConnectionManager.prototype.getTwoNodeId = function(startNode, endNode) {\r\n            return startNode.id + \",\" + endNode.id;\r\n    }\r\n        //处理多条线段\r\n    FlowConnectionManager.prototype.refreshCons = function(arrCons) {\r\n        //如果是折线的话\r\n        if (arrCons[0].options.style.lineType == Connector.TYPE_JAGGED) {\r\n            for (var i = 0; i < arrCons.length; i++) {\r\n                this.refreshConnector(arrCons[i], true);\r\n            }\r\n        } else {\r\n            this.refreshConsStraight(arrCons);\r\n        }\r\n    }\r\n\r\n    //处理多条线段(直线)\r\n    FlowConnectionManager.prototype.refreshConsStraight = function(arrCons) {\r\n        var half = parseInt(arrCons.length / 2);\r\n        var arrConnectResult = []\r\n\r\n        var startNode = arrCons[0].startNode;\r\n        var endNode = arrCons[0].endNode;\r\n        var sRect = Util.getRect(startNode).boundingRect;\r\n        var eRect = Util.getRect(endNode).boundingRect;\r\n        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n        var position = arrCons[0].options.position;\r\n        if (!position.startPos || !position.endPos) {\r\n            if (sRect.x < eRect.x) {\r\n                position.startPos = \"right\";\r\n                position.endPos = \"left\";\r\n            } else {\r\n                position.startPos = \"left\";\r\n                position.endPos = \"right\";\r\n            }\r\n        }\r\n\r\n        var startPoint = sConnectorPoint[position.startPos];\r\n        var endPoint = eConnectorPoint[position.endPos];\r\n        var angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);\r\n        var points = [];\r\n        for (var i = half; i >= 1; i--) {\r\n            points = []; //var points = [];\r\n            points.push(startPoint); //\r\n            // points.push(new Point(startPoint.x + bundleOffset , startPoint.y + i * bundleGap));\r\n            // points.push(new Point(endPoint.x - bundleOffset , startPoint.y + i * bundleGap)); //startPoint.x + bundleOffset\r\n            var secondPoint = startPoint.clone();\r\n\r\n            //secondPoint.x =  secondPoint.x + this.bundleOffset;\r\n            secondPoint.transform(Util.translationMatrix(0, this.bundleGap * i));\r\n            //secondPoint = this.boundOffsetXY(secondPoint, true);\r\n            //\r\n            //直角坐标 x, 和 y, 计算出极坐标\r\n\r\n\r\n            //从极坐标计算出直角坐标\r\n            secondPoint.x = secondPoint.x + this.bundleOffset * Math.cos(angle);\r\n            secondPoint.y = secondPoint.y + this.bundleOffset * Math.sin(angle);\r\n\r\n\r\n\r\n            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n            points.push(secondPoint);\r\n\r\n            var thirdPoint = endPoint.clone();\r\n            //thirdPoint.x =  thirdPoint.x - this.bundleOffset;\r\n\r\n\r\n\r\n            thirdPoint.transform(Util.translationMatrix(0, this.bundleGap * i));\r\n            //thirdPoint = this.boundOffsetXY(thirdPoint, false);\r\n            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n            //\r\n            //直角坐标 x, 和 y, 计算出极坐标\r\n\r\n            //从极坐标计算出直角坐标\r\n            thirdPoint.x = thirdPoint.x - this.bundleOffset * Math.cos(angle);\r\n            thirdPoint.y = thirdPoint.y - this.bundleOffset * Math.sin(angle);\r\n\r\n            points.push(thirdPoint);\r\n\r\n            points.push(endPoint);\r\n            arrConnectResult.push(points);\r\n        }\r\n\r\n        arrConnectResult.push([startPoint, endPoint]);\r\n\r\n        var upHalf = Math.ceil(arrCons.length / 2);\r\n        for (i = 1; i < upHalf; i++) {\r\n            points = []; //var points = [];\r\n            points.push(startPoint);\r\n            var secPoint = startPoint.clone();\r\n            //secPoint.x =  secPoint.x + this.bundleOffset;\r\n            secPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));\r\n            secPoint.x = secPoint.x + this.bundleOffset * Math.cos(angle);\r\n            secPoint.y = secPoint.y + this.bundleOffset * Math.sin(angle);\r\n            points.push(secPoint);\r\n\r\n            var thdPoint = endPoint.clone();\r\n            //thdPoint.x =  thdPoint.x - this.bundleOffset;\r\n            thdPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));\r\n            //从极坐标计算出直角坐标\r\n            thdPoint.x = thdPoint.x - this.bundleOffset * Math.cos(angle);\r\n            thdPoint.y = thdPoint.y - this.bundleOffset * Math.sin(angle);\r\n            //secondPoint.transform(Util.scaleMatrix(0.5));\r\n            points.push(thdPoint);\r\n\r\n            points.push(endPoint);\r\n            arrConnectResult.push(points);\r\n        }\r\n\r\n\r\n        for (i = 0; i < arrConnectResult.length; i++) {\r\n            arrCons[i].refresh(arrConnectResult[i]);\r\n        }\r\n\r\n    }\r\n\r\n    FlowConnectionManager.prototype.boundOffsetXY = function(point, isPositive) {\r\n        var resultPoint = point.clone();\r\n        //直角坐标 x, 和 y, 计算出极坐标\r\n        var angle = Math.atan2(resultPoint.y, resultPoint.x);\r\n        var r = Math.sqrt(Math.pow(resultPoint.x, 2) + Math.pow(resultPoint.y, 2));\r\n        if (isPositive) {\r\n            r = r + this.bundleOffset;\r\n        } else {\r\n            r = r - this.bundleOffset;\r\n        }\r\n\r\n\r\n        //从极坐标计算出直角坐标\r\n        resultPoint.x = r * Math.cos(angle);\r\n        resultPoint.y = r * Math.sin(angle);\r\n        return resultPoint;\r\n    }\r\n\r\n    /**\r\n     * 设置线段的模型数据  (类型 文字)\r\n     * @param {[type]} connector [description]\r\n     * @param {[type]} option    [description]\r\n     */\r\n    FlowConnectionManager.prototype.setModel = function(connector, option) {\r\n        var originLineType = connector.model.get(\"style.lineType\");\r\n        connector.model.mergeOption(option);\r\n        zrUtil.merge(connector.model.get(\"options\"), option, true);\r\n        if (originLineType !== option.style.lineType) {\r\n            this.refreshConnector(connector, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 删除指定的线\r\n     * @param connector 欲删除的连线\r\n     * @param _zr zr\r\n     */\r\n    ConnectionManager.prototype.deleteByLine = function (connector,_zr) {\r\n        //1.将线 所联的startNode的outgoing数据删除\r\n        if(connector.startNode){\r\n            var startNodeOutgoing = connector.startNode.model.get(\"outgoing\");\r\n            index = zrUtil.indexOf(startNodeOutgoing, connector.resourceId);\r\n            if (index != -1) {\r\n                startNodeOutgoing.splice(index, 1);\r\n            }\r\n\r\n            if (this.connectorMap) {\r\n                var key = this.getTwoNodeId(connector.startNode, connector.endNode);\r\n                this.connectorMap.removeItem(key, connector);\r\n            }\r\n        }\r\n\r\n\r\n        //2.从_zr上删除\r\n        _zr.remove(connector);\r\n\r\n\r\n        //3.从线数据中删除\r\n        var index = zrUtil.indexOf(this.connectors, connector);\r\n        if (index != -1) {\r\n            this.connectors.splice(index, 1);\r\n        }\r\n        if (this.selConnector === connector) {\r\n            this.selConnector = null;\r\n        }\r\n    }\r\n    /**\r\n     * 刷新连接线\r\n     * @param  {[type]} node [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    FlowConnectionManager.prototype.refreshLineByNode = function(node) {\r\n        // 判断这个节点是否有多条线段\r\n        var keys = this.connectorMap.keys();\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            if (key.indexOf(node.id) != -1) {\r\n                var arrCons = this.connectorMap.get(key);\r\n                this.countLinePos(arrCons)\r\n                if (arrCons.length == 1) {\r\n                    //两个节点只有一个连线的情况\r\n                    this.refreshConnector(arrCons[0], true);\r\n                } else if (arrCons.length > 1) {\r\n                    //两个节点有多个连线的情况\r\n                    this.refreshCons(arrCons);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 刷新连接线\r\n     * @param  {[type]} node [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    FlowConnectionManager.prototype.toggleLineByNode = function(node, isShow) {\r\n        // 判断这个节点是否有多条线段\r\n        var keys = this.connectorMap.keys();\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            if (key.indexOf(node.id) != -1) {\r\n                var arrCons = this.connectorMap.get(key);\r\n\r\n                zrUtil.each(arrCons, function(connection) {\r\n                    if(isShow) {\r\n                        connection.show();\r\n                    } else {\r\n                        connection.hide();\r\n                    }\r\n                })\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 重新调整线的位置\r\n     */\r\n    FlowConnectionManager.prototype.countLinePos = function(arrCons) {\r\n        zrUtil.each(arrCons, function(connector) {\r\n            var options = connector.options;\r\n            if (options.autoChangePosition == true) {\r\n                var sRect = Util.getRect(connector.startNode).boundingRect;\r\n                var eRect = Util.getRect(connector.endNode).boundingRect;\r\n                var startPos = options.position.startPos;\r\n                var endPos = options.position.endPos;\r\n                var startPosNow = this.posIsChange(startPos, sRect, eRect, \"startNode\");\r\n                var endPosNow = this.posIsChange(endPos, sRect, eRect, \"endNode\");\r\n                if (startPos != startPosNow || endPos != endPosNow) {\r\n                    options.position.startPos = startPosNow;\r\n                    options.position.endPos = endPosNow;\r\n                }\r\n            }\r\n        },this);\r\n    }\r\n\r\n    FlowConnectionManager.prototype.posIsChange = function(pos, sRect, eRect, nodeType) {\r\n        var newPos\r\n        if (pos.indexOf(\"top\") != -1 || pos.indexOf(\"bottom\") != -1) {\r\n            if (sRect.y + sRect.height < eRect.y) {\r\n                if (nodeType == \"startNode\") {\r\n                    newPos = pos.replace(/(top|bottom)/g, \"bottom\");\r\n                } else {\r\n                    newPos = pos.replace(/(top|bottom)/g, \"top\");\r\n                }\r\n            } else if (eRect.y + eRect.height < sRect.y) {\r\n                if (nodeType == \"endNode\") {\r\n                    newPos = pos.replace(/(top|bottom)/g, \"bottom\");\r\n                } else {\r\n                    newPos = pos.replace(/(top|bottom)/g, \"top\");\r\n                }\r\n            } else {\r\n                newPos = pos;\r\n            }\r\n        } else if (pos.indexOf(\"left\") != -1 || pos.indexOf(\"right\") != -1) {\r\n            if (sRect.x + sRect.width < eRect.x) {\r\n                if (nodeType == \"startNode\") {\r\n                    newPos = pos.replace(/(right|left)/g, \"right\");\r\n                } else {\r\n                    newPos = pos.replace(/(right|left)/g, \"left\");\r\n                }\r\n            } else if (eRect.x + eRect.width < sRect.x) {\r\n                if (nodeType == \"endNode\") {\r\n                    newPos = pos.replace(/(right|left)/g, \"right\");\r\n                } else {\r\n                    newPos = pos.replace(/(right|left)/g, \"left\");\r\n                }\r\n            } else {\r\n                newPos = pos;\r\n            }\r\n        } else {\r\n            newPos = pos;\r\n        }\r\n        return newPos;\r\n    }\r\n\r\n\r\n    zrUtil.inherits(FlowConnectionManager, ConnectionManager);\r\n    module.exports = FlowConnectionManager;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/manager/FlowConnectionManager.js\n// module id = 90\n// module chunks = 0","/**\r\n * 连线管理类\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Util = require('../util');\r\n    var Point = require(\"../Point.js\");\r\n    var Connector = require(\"../shapes/Connector.js\");\r\n    var Log = require(\"../Log.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    function ConnectionManager() {\r\n        this.connectors = []; //当前画布所有的线段\r\n        this.selConnector = null; //当前选中的线段\r\n        this.tempConnector = null; //临时线段\r\n    }\r\n\r\n    /**\r\n     * 设置线的不可编辑\r\n     * @param  {[type]} forbidEdit [description]\r\n     * @return {[type]}            [description]\r\n     */\r\n    ConnectionManager.prototype.connectorForbidEdit = function (forbidEdit) {\r\n        for (var i = 0; i < this.connectors.length; i++) {\r\n            this.connectors[i].options.isEdit = !forbidEdit;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 清空连接线上的调整位置按钮\r\n     * @return {[type]} [description]\r\n     */\r\n    ConnectionManager.prototype.clearSelectCon = function () {\r\n        if (this.selConnector != null) {\r\n            this.refreshConnector(this.selConnector);\r\n        }\r\n    }\r\n    /**\r\n     * 删除和节点相关联的连接线\r\n     * @return {[type]} [description]\r\n     */\r\n    ConnectionManager.prototype.deleteSelectCon = function (node, _zr) {\r\n        for (var i = 0; i < this.connectors.length; i++) {\r\n            if (this.connectors[i].startNode == node || this.connectors[i].endNode == node) {\r\n                //1.将线 所联的startNode的outgoing数据删除\r\n                var startNodeOutgoing = this.connectors[i].startNode.model.get(\"outgoing\");\r\n                var index = zrUtil.indexOf(startNodeOutgoing, this.connectors[i].resourceId);\r\n                if (index != -1) {\r\n                    startNodeOutgoing.splice(index, 1);\r\n                }\r\n                //2.从_zr上删除\r\n                _zr.remove(this.connectors[i]);\r\n                this.connectors.splice(i, 1);\r\n                i--;\r\n                this.selConnector = null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 删除选定的线\r\n     * @return {[type]} [description]\r\n     */\r\n    ConnectionManager.prototype.deleteLine = function (_zr) {\r\n        //1.将线 所联的startNode的outgoing数据删除\r\n        if(this.selConnector.startNode){\r\n            var startNodeOutgoing = this.selConnector.startNode.model.get(\"outgoing\");\r\n            index = zrUtil.indexOf(startNodeOutgoing, this.selConnector.resourceId);\r\n            if (index != -1) {\r\n                startNodeOutgoing.splice(index, 1);\r\n            }\r\n\r\n            if (this.connectorMap) {\r\n                var key = this.getTwoNodeId(this.selConnector.startNode, this.selConnector.endNode);\r\n                this.connectorMap.removeItem(key, this.selConnector);\r\n            }\r\n        }\r\n\r\n\r\n        //2.从_zr上删除\r\n        _zr.remove(this.selConnector);\r\n\r\n\r\n        //3.从线数据中删除\r\n        var index = zrUtil.indexOf(this.connectors, this.selConnector);\r\n        if (index != -1) {\r\n            this.connectors.splice(index, 1);\r\n        }\r\n        this.selConnector = null;\r\n    }\r\n\r\n    /**\r\n     * 重新画线\r\n     * @param  {[type]} connector          [description]\r\n     * @param  {[type]} force\r\n     * @return {[type]}                    [description]\r\n     */\r\n    ConnectionManager.prototype.refreshConnector = function (connector, force) {\r\n        // 只有需要强制刷新  或者 连线为空（<2)时 才进行重新计算重绘\r\n        if (force || (!connector.turningPoints) || (connector.turningPoints.length < 2)) {\r\n            if (connector.model && connector.model.get(\"style.lineType\")) {\r\n                connector.options.style.lineType = connector.model.get(\"style.lineType\");\r\n            }\r\n            var arrStartEndPoint = this.getStartEndPoint(connector);\r\n            var escapeDistance = null;\r\n            if (connector.options.position && connector.options.position.escapeDistance) {\r\n                escapeDistance = connector.options.position.escapeDistance;\r\n            }\r\n            var solutions = this.connector2Points(connector.options.style.lineType, arrStartEndPoint[0],\r\n                arrStartEndPoint[1],\r\n                arrStartEndPoint[2], arrStartEndPoint[3], escapeDistance); // TYPE_STRAIGHT TYPE_JAGGED\r\n\r\n            connector.refresh(solutions[0][2]);\r\n        }\r\n\r\n        connector.clearHandles(); //清空handle\r\n    }\r\n\r\n\r\n    ConnectionManager.prototype.getStartEndPoint = function (connector) {\r\n        var startNode = connector.startNode;\r\n        var endNode = connector.endNode;\r\n\r\n        var isNotInSameGroup = startNode.parent !== endNode.parent;\r\n\r\n        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode, isNotInSameGroup).boundingRect;\r\n        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(\r\n            sRect.y) + Number(sRect.height)];\r\n\r\n        var eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode, isNotInSameGroup).boundingRect;\r\n        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(\r\n            eRect.y) + Number(eRect.height)];\r\n\r\n\r\n        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\r\n        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n        var position = connector.options.position;\r\n        if (!position.startPos || !position.endPos) {\r\n            if (sRect.x < eRect.x) {\r\n                position.startPos = \"right\";\r\n                position.endPos = \"left\";\r\n            } else {\r\n                position.startPos = \"left\";\r\n                position.endPos = \"right\";\r\n            }\r\n        }\r\n        var startPoint = this.calcPointExpression(position.startPos, sConnectorPoint);\r\n        var endPoint = this.calcPointExpression(position.endPos, eConnectorPoint);\r\n        startPoint.add(new Point(position.startOffset[0], position.startOffset[1]));\r\n        endPoint.add(new Point(position.endOffset[0], position.endOffset[1]));\r\n        return [startPoint, endPoint, sBounds, eBounds];\r\n    }\r\n\r\n    ConnectionManager.prototype.calcPointExpression = function (pos, point) {\r\n        var variable = {\r\n            top: point.top.x,\r\n            left: point.left.y,\r\n            right: point.right.y,\r\n            bottom: point.bottom.x,\r\n            center: point.center.x\r\n        };\r\n\r\n        var expression = \"<% print(\" + pos + \") %>\";\r\n        var val = parseInt(Util.template(expression)(variable));\r\n        if (pos.indexOf(\"top\") != -1) {\r\n            return new Point(val, point.top.y);\r\n        } else if (pos.indexOf(\"left\") != -1) {\r\n            return new Point(point.left.x, val);\r\n        } else if (pos.indexOf(\"right\") != -1) {\r\n            return new Point(point.right.x, val);\r\n        } else if (pos.indexOf(\"bottom\") != -1) {\r\n            return new Point(val, point.bottom.y);\r\n        } else if (pos.indexOf(\"center\") != -1) {\r\n            return new Point(val, point.bottom.y);\r\n        } else {\r\n            throw new Error(\"pos参数错误\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 创建或修改临时线\r\n     * @param  {[type]} startNode             [description]\r\n     * @param  {[type]} rEndPoint             [description]\r\n     * @param  {[type]} lineType [description]\r\n     * @return {[type]}                       [description]\r\n     */\r\n    ConnectionManager.prototype.manageTempConnector = function (startNode, rEndPoint, lineType) {\r\n\r\n        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode).boundingRect;\r\n\r\n        var sBounds = [sRect.x, sRect.y, sRect.x + sRect.width, sRect.y + sRect.height];\r\n        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n\r\n        if (!this.tempConnector) {\r\n            this.tempConnector = new Connector({\r\n                isEdit: false,\r\n                style: {\r\n                    lineType: lineType\r\n                }\r\n            });\r\n        }\r\n\r\n        var connector = this.tempConnector;\r\n        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n        var position = connector.options.position;\r\n        if (sRect.x < rEndPoint.x) {\r\n            position.startPos = \"right\";\r\n            position.endPos = \"left\";\r\n        } else {\r\n            position.startPos = \"left\";\r\n            position.endPos = \"right\";\r\n        }\r\n\r\n        connector.options.style.lineType = lineType;\r\n        var solutions = this.connector2Points(lineType, sConnectorPoint[position.startPos], rEndPoint,\r\n            sBounds, null); // TYPE_STRAIGHT TYPE_JAGGED\r\n\r\n        connector.refresh(solutions[0][2]);\r\n        return connector;\r\n    }\r\n\r\n    /**\r\n     * 删除临时线\r\n     * @param  {[type]} zr             [description]\r\n     */\r\n    ConnectionManager.prototype.removeTempConnector = function (zr) {\r\n        if (this.tempConnector) {\r\n            zr.remove(this.tempConnector);\r\n            this.tempConnector = null;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 算出 两个节点 指定两个点如何联线\r\n     * @param  {[type]} type       [description]\r\n     * @param  {[type]} startPoint [description]\r\n     * @param  {[type]} endPoint   [description]\r\n     * @param  {[type]} sBounds    [description]\r\n     * @param  {[type]} eBounds    [description]\r\n     * @return {[type]}            [description]\r\n     */\r\n    ConnectionManager.prototype.connector2Points = function (type, startPoint, endPoint, sBounds, eBounds,\r\n        escapeDistance) {\r\n        var figureEscapeDistance = [30, 30];\r\n        if (escapeDistance) {\r\n            if (!zrUtil.isArray(escapeDistance)) {\r\n                figureEscapeDistance = [escapeDistance, escapeDistance];\r\n            } else {\r\n                figureEscapeDistance = escapeDistance;\r\n            }\r\n        }\r\n\r\n        Log.group(\"connectionManager: connector2Points\");\r\n\r\n\r\n        Log.info(\"ConnectionManager: connector2Points (\" + type + \", \" + startPoint + \", \" + endPoint +\r\n            \", \" + sBounds + \", \" + eBounds + ')');\r\n        var solutions = [];\r\n\r\n\r\n\r\n        switch (type) {\r\n            case Connector.TYPE_STRAIGHT: //直线\r\n                var points = [startPoint.clone(), endPoint.clone()];\r\n                solutions.push(['straight', 'straight', points]);\r\n                break;\r\n\r\n            case Connector.TYPE_CURVE: //曲线\r\n\r\n            case Connector.TYPE_JAGGED: //折线\r\n                var startExitPoint = null;\r\n                var endExitPoint = null;\r\n\r\n                //find start exit point  寻找开始出口\r\n                if (sBounds != null) {\r\n                    var potentialExits = [];\r\n\r\n                    potentialExits.push(new Point(startPoint.x, sBounds[1] - figureEscapeDistance[0])); //north 北\r\n                    potentialExits.push(new Point(sBounds[2] + figureEscapeDistance[0], startPoint.y)); //east  东\r\n                    potentialExits.push(new Point(startPoint.x, sBounds[3] + figureEscapeDistance[0])); //south  南\r\n                    potentialExits.push(new Point(sBounds[0] - figureEscapeDistance[0], startPoint.y)); //west  西\r\n\r\n                    //pick closest exit point  寻找与 startPoint 最靠近的出口点\r\n                    startExitPoint = potentialExits[0];\r\n                    for (var i = 1; i < potentialExits.length; i++) {\r\n                        if (Util.distance(startPoint, potentialExits[i]) < Util.distance(startPoint,\r\n                                startExitPoint)) {\r\n                            startExitPoint = potentialExits[i];\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                //find end exit point  寻找结束出口\r\n                if (eBounds != null) {\r\n                    var potentialExits = [];\r\n\r\n                    potentialExits.push(new Point(endPoint.x, eBounds[1] - figureEscapeDistance[1])); //north\r\n                    potentialExits.push(new Point(eBounds[2] + figureEscapeDistance[1], endPoint.y)); //east\r\n                    potentialExits.push(new Point(endPoint.x, eBounds[3] + figureEscapeDistance[1])); //south\r\n                    potentialExits.push(new Point(eBounds[0] - figureEscapeDistance[1], endPoint.y)); //west\r\n\r\n                    //pick closest exit point  寻找与 endPoint 最靠近的出口点\r\n                    endExitPoint = potentialExits[0];\r\n                    for (var i = 1; i < potentialExits.length; i++) {\r\n                        if (Util.distance(endPoint, potentialExits[i]) < Util.distance(endPoint,\r\n                                endExitPoint)) {\r\n                            endExitPoint = potentialExits[i];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                //Basic solution 最基本的解决方案   为其他解决方案做准备\r\n                var s = [startPoint];\r\n                var gapIndex = 0; //the index of the gap (where do we need to insert new points) DO NOT CHANGE IT\r\n                if (startExitPoint) {\r\n                    s.push(startExitPoint);\r\n                    gapIndex = 1;\r\n                }\r\n                if (endExitPoint) {\r\n                    s.push(endExitPoint);\r\n                }\r\n                s.push(endPoint);\r\n\r\n\r\n\r\n                //SO - no additional points     S0 解决方案 不添加任何点  基本不会被采用\r\n                var s0 = Point.cloneArray(s);\r\n                solutions.push(['s0', 's0', s0]);\r\n\r\n\r\n\r\n                //S1   S1 解决方案  只有一个折点\r\n                var s1 = Point.cloneArray(s);\r\n\r\n                //first variant   第一个变体 s1 s1_1方案  折线点在 startExitPoint的X 与 endExitPoint的 Y位置\r\n                var s1_1 = Point.cloneArray(s1);\r\n                s1_1.splice(gapIndex + 1, 0, new Point(s1_1[gapIndex].x, s1_1[gapIndex + 1].y));\r\n                solutions.push(['s1', 's1_1', s1_1]);\r\n\r\n                //second variant  第二变体 s1 s1-2方案  折线点在 endExitPoint的X 与  startExitPoint的Y位置\r\n                var s1_2 = Point.cloneArray(s1);\r\n                s1_2.splice(gapIndex + 1, 0, new Point(s1_2[gapIndex + 1].x, s1_2[gapIndex].y));\r\n                solutions.push(['s1', 's1_2', s1_2]);\r\n\r\n\r\n                //S2  S2 解决方案  添加两个折点\r\n\r\n                //Variant I   s2_1方案\r\n                var s2_1 = Point.cloneArray(s);\r\n                var s2_1_1 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex].y);\r\n                var s2_1_2 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex + 1].y);\r\n                s2_1.splice(gapIndex + 1, 0, s2_1_1, s2_1_2);\r\n                solutions.push(['s2', 's2_1', s2_1]);\r\n\r\n\r\n                //Variant II  s2_1方案  1折线点 x: startExitPoint的X 位置 y: startExitPoint的y+endExitPoint的y/2\r\n                //1折线点 x:endExitPoint的x  y:startExitPoint的y+endExitPoint的y/2\r\n                var s2_2 = Point.cloneArray(s);\r\n                var s2_2_1 = new Point(s2_2[gapIndex].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);\r\n                var s2_2_2 = new Point(s2_2[gapIndex + 1].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);\r\n                s2_2.splice(gapIndex + 1, 0, s2_2_1, s2_2_2);\r\n                solutions.push(['s2', 's2_2', s2_2]);\r\n\r\n\r\n                //Variant III\r\n                var s2_3 = Point.cloneArray(s);\r\n                //find the amount (stored in delta) of pixels we need to move right so no intersection with a figure will be present\r\n                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\r\n                var eastExits = [s2_3[gapIndex].x + 20, s2_3[gapIndex + 1].x + 20]; //add points X coordinates to be able to generate Variant III even in the absence of figures :p\r\n\r\n                if (sBounds) {\r\n                    eastExits.push(sBounds[2] + 20);\r\n                }\r\n\r\n                if (eBounds) {\r\n                    eastExits.push(eBounds[2] + 20);\r\n                }\r\n\r\n                var eastExit = Util.max(eastExits);\r\n                var s2_3_1 = new Point(eastExit, s2_3[gapIndex].y);\r\n                var s2_3_2 = new Point(eastExit, s2_3[gapIndex + 1].y);\r\n                s2_3.splice(gapIndex + 1, 0, s2_3_1, s2_3_2);\r\n                solutions.push(['s2', 's2_3', s2_3]);\r\n\r\n\r\n                //Variant IV  s2_4方案\r\n                var s2_4 = Point.cloneArray(s);\r\n                //find the amount (stored in delta) of pixels we need to move up so no intersection with a figure will be present\r\n                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\r\n                var northExits = [s2_4[gapIndex].y - 20, s2_4[gapIndex + 1].y - 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p\r\n\r\n                if (sBounds) {\r\n                    northExits.push(sBounds[1] - 20);\r\n                }\r\n\r\n                if (eBounds) {\r\n                    northExits.push(eBounds[1] - 20);\r\n                }\r\n\r\n                var northExit = Util.min(northExits);\r\n                var s2_4_1 = new Point(s2_4[gapIndex].x, northExit);\r\n                var s2_4_2 = new Point(s2_4[gapIndex + 1].x, northExit);\r\n                s2_4.splice(gapIndex + 1, 0, s2_4_1, s2_4_2);\r\n                solutions.push(['s2', 's2_4', s2_4]);\r\n\r\n\r\n                //Variant V\r\n                var s2_5 = Point.cloneArray(s);\r\n                //find the amount (stored in delta) of pixels we need to move left so no intersection with a figure will be present\r\n                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\r\n                var westExits = [s2_5[gapIndex].x - 20, s2_5[gapIndex + 1].x - 20]; //add points x coordinates to be able to generate Variant III even in the absence of figures :p\r\n\r\n                if (sBounds) {\r\n                    westExits.push(sBounds[0] - 20);\r\n                }\r\n\r\n                if (eBounds) {\r\n                    westExits.push(eBounds[0] - 20);\r\n                }\r\n\r\n                var westExit = Util.min(westExits);\r\n                var s2_5_1 = new Point(westExit, s2_5[gapIndex].y);\r\n                var s2_5_2 = new Point(westExit, s2_5[gapIndex + 1].y);\r\n                s2_5.splice(gapIndex + 1, 0, s2_5_1, s2_5_2);\r\n                solutions.push(['s2', 's2_5', s2_5]);\r\n\r\n\r\n                //Variant VI\r\n                var s2_6 = Point.cloneArray(s);\r\n                //find the amount (stored in delta) of pixels we need to move down so no intersection with a figure will be present\r\n                //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\r\n                var southExits = [s2_6[gapIndex].y + 20, s2_6[gapIndex + 1].y + 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p\r\n\r\n                if (sBounds) {\r\n                    southExits.push(sBounds[3] + 20);\r\n                }\r\n\r\n                if (eBounds) {\r\n                    southExits.push(eBounds[3] + 20);\r\n                }\r\n\r\n                var southExit = Util.max(southExits);\r\n                var s2_6_1 = new Point(s2_6[gapIndex].x, southExit);\r\n                var s2_6_2 = new Point(s2_6[gapIndex + 1].x, southExit);\r\n                s2_6.splice(gapIndex + 1, 0, s2_6_1, s2_6_2);\r\n                solutions.push(['s2', 's2_6', s2_6]);\r\n\r\n\r\n\r\n                //FILTER solutions\r\n\r\n                /*Algorithm\r\n                 * 0. solutions are ordered from minimmun nr of points to maximum >:)\r\n                 * 1. remove all solutions that are not orthogonal (mainly s0 solution)\r\n                 * 2. remove all solutions that go backward (we will not need them ever)\r\n                 * 3. remove all solutions with intersections\r\n                 * 4. pick first class of solutions with same nr of points (ex: 2)\r\n                 * 5. pick the first solution with 90 degree angles (less turnarounds)\r\n                 * (not interesteted) sort by length :p\r\n                 */\r\n\r\n                //1. filter non ortogonal solutions 删除不是正交直线的方案\r\n                Log.info(\"Filter orthogonal solutions. Initial number of solutions = \" + solutions.length);\r\n                var orthogonalSolution = [];\r\n                for (var l = 0; l < solutions.length; l++) {\r\n                    var solution = solutions[l][2];\r\n                    if (Util.orthogonalPath(solution)) {\r\n                        orthogonalSolution.push(solutions[l]);\r\n                    }\r\n                }\r\n                solutions = orthogonalSolution;\r\n                Log.info(\"\\n\\tOrthogonalSolutions = \" + solutions.length);\r\n\r\n                //2. filter backward solutions  过滤 倒退的方案\r\n                //do not allow start and end points to coincide - ignore them\r\n                if (startPoint.equals(endPoint)) {\r\n                    Log.info(\r\n                        \"Start and end point coincide...skip backward solution. I think we will just fall on s0 :)\"\r\n                    );\r\n                } else {\r\n                    Log.info(\"Filter backward solutions. Initial number of solutions = \" + solutions.length);\r\n                    var forwardSolutions = [];\r\n                    var temp = '';\r\n                    for (var l = 0; l < solutions.length; l++) {\r\n                        var solution = solutions[l][2];\r\n                        if (Util.forwardPath(solution)) {\r\n                            forwardSolutions.push(solutions[l]);\r\n                        } else {\r\n                            temp = temp + \"\\n\\t\" + solution;\r\n                        }\r\n                    }\r\n                    solutions = forwardSolutions;\r\n                    Log.info(\"\\n\\t ForwardSolutions = \" + solutions.length);\r\n                    if (solutions.length == 0) {\r\n                        Log.info(\"Discarded solutions: \" + temp);\r\n                    }\r\n                }\r\n\r\n\r\n                //3. Filter non intersecting solutions  去除没有交集()的方案\r\n                Log.info(\"Filter non intersecting solutions. Initial number of solutions = \" + solutions.length);\r\n                var nonIntersectionSolutions = []\r\n                for (var l = 0; l < solutions.length; l++) {\r\n                    var solution = solutions[l][2];\r\n                    //Log.info(\"Solution id= \" + solutions[l][1] + ' nr points = ' + solution.length + \", points = \" + solution);\r\n                    var intersect = false;\r\n\r\n                    var innerLines = solution.slice(); //just a shallow copy\r\n\r\n                    /*If any bounds just trim the solution. So we avoid the strange case when a connection\r\n                     *startes from a point on a figure and ends inside of the same figure, but not on a connection point*/\r\n                    if (eBounds || sBounds) {\r\n                        //i0nnerLines = innerLines.slice(0, innerLines.length - 1);\r\n                        innerLines = innerLines.slice(1, innerLines.length - 1);\r\n                        //Log.info(\"\\t eBounds present,innerLines nr. points = \" + innerLines.length + \", points = \" + innerLines);\r\n                    }\r\n\r\n\r\n\r\n                    //now test for intersection\r\n                    if (sBounds) {\r\n                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, sBounds);\r\n                    }\r\n                    if (eBounds) {\r\n                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, eBounds);\r\n                    }\r\n\r\n                    if (!intersect) {\r\n                        nonIntersectionSolutions.push(solutions[l]);\r\n                    }\r\n                }\r\n\r\n                //If all solutions intersect than this is destiny  :) and just ignore the intersection filter\r\n                if (nonIntersectionSolutions.length != 0) {\r\n                    //reasign to solutions\r\n                    solutions = nonIntersectionSolutions;\r\n                }\r\n\r\n                Log.info(\"\\n\\t nonIntersectionSolutions = \" + solutions.length);\r\n\r\n\r\n                //4. get first class of solutions with same nr of points 选择与第一个方案点数一样多的方案（因为第一个方案点数最少）\r\n                Log.info(\"Get first class of solutions with same nr of points\");\r\n                if (solutions.length == 0) {\r\n                    Log.info(\"This is not possible\");\r\n                }\r\n\r\n                var firstSolution = solutions[0][2]; //pick first solution\r\n                var nrOfPoints = firstSolution.length;\r\n                var sameNrPointsSolution = [];\r\n\r\n                for (var l = 0; l < solutions.length; l++) {\r\n                    var solution = solutions[l][2];\r\n                    if (solution.length == nrOfPoints) {\r\n                        sameNrPointsSolution.push(solutions[l]);\r\n                    }\r\n                }\r\n\r\n                solutions = sameNrPointsSolution;\r\n\r\n\r\n\r\n\r\n                /*5.  计算路径分数 ，取最分数高的\r\n                 Pick the first solution with 90 degree angles (less turnarounds)\r\n                 *in case we have more than one solution in our class\r\n                 */\r\n                Log.info(\"pick the first solution with 90 degree angles (less turnarounds)\");\r\n                var solIndex = 0;\r\n                for (var l = 0; l < solutions.length; l++) {\r\n                    var solution = solutions[l][2];\r\n                    if (Util.scorePath(solutions[solIndex][2]) < Util.scorePath(solutions[l][2])) {\r\n                        solIndex = l;\r\n                    }\r\n                }\r\n                solutions = [solutions[solIndex]];\r\n\r\n\r\n                break;\r\n        }\r\n\r\n        //SMOOTHING curve\r\n        if (type === Connector.TYPE_CURVE) {\r\n            this.smoothCurve(solutions);\r\n        }\r\n        //END SMOOTHING curve\r\n\r\n        Log.groupEnd();\r\n\r\n        return solutions;\r\n    }\r\n\r\n    ConnectionManager.prototype.smoothCurve = function (solutions) {\r\n        var option = 3;\r\n\r\n        switch (option) {\r\n            case 0:\r\n                //do nothing\r\n                break;\r\n\r\n            case 1: //add intermediate points\r\n                //Add the middle point for start and end segment so that we \"force\" the\r\n                //curve to both come \"perpendicular\" on bounds and also make the curve\r\n                //\"flee\" more from bounds (on exit)\r\n                for (var s = 0; s < solutions.length; s++) {\r\n                    var solTurningPoints = solutions[s][2];\r\n\r\n                    //first segment\r\n                    var a1 = solTurningPoints[0];\r\n                    var a2 = solTurningPoints[1];\r\n                    var startMiddlePoint = Util.getMiddle(a1, a2);\r\n                    solTurningPoints.splice(1, 0, startMiddlePoint);\r\n\r\n                    //last segment\r\n                    var a3 = solTurningPoints[solTurningPoints.length - 2];\r\n                    var a4 = solTurningPoints[solTurningPoints.length - 1];\r\n                    var endMiddlePoint = Util.getMiddle(a3, a4);\r\n                    solTurningPoints.splice(solTurningPoints.length - 1, 0, endMiddlePoint);\r\n                }\r\n                break;\r\n\r\n            case 2: //remove points\r\n\r\n                zrUtil.each(solutions, function(solution) {\r\n                    var solType = solution[0];\r\n                    if (solType == 's1' || solType == 's2') {\r\n                        var solTurningPoints = solution[2];\r\n                        solTurningPoints.splice(1, 1);\r\n                        solTurningPoints.splice(solTurningPoints.length - 2, 1);\r\n                    }\r\n                });\r\n                break;\r\n\r\n            case 3:\r\n                /*remove colinear point for s1 as it seems that more colinear points do not look good\r\n                 * on organic solutions >:D*/\r\n                zrUtil.each(solutions, function(solution) {\r\n                    var solType = solution[0];\r\n                    if (solType == 's1') {\r\n                        var solTurningPoints = solution[2];\r\n                        var reducedSolution = Util.collinearReduction(solTurningPoints);\r\n                        solution[2] = reducedSolution;\r\n                    }\r\n                });\r\n                break;\r\n        } //end switch\r\n\r\n    }\r\n\r\n    module.exports = ConnectionManager;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/manager/ConnectionManager.js\n// module id = 91\n// module chunks = 0","/**\r\n * 日志类\r\n * @author wang.xiaohu\r\n */\r\n\r\n\r\n    var Log  = {\r\n        LOG_LEVEL_NONE  : 0,\r\n\r\n        LOG_LEVEL_DEBUG : 1,\r\n\r\n        LOG_LEVEL_INFO : 2,\r\n\r\n        LOG_LEVEL_ERROR : 3,\r\n\r\n        level : this.LOG_LEVEL_ERROR,\r\n        \r\n        /**\r\n        * The less important of all messages\r\n        * @param {String} message - the message to be logged\r\n        **/\r\n        debug: function (message){\r\n            if(typeof console !== 'undefined'){\r\n                if(this.level <= this.LOG_LEVEL_DEBUG){\r\n                    \r\n                    //in FF is debug\r\n                    if(typeof console.debug == 'function'){\r\n                        console.debug(message);\r\n                    }\r\n                    else{//TODO: in IE is log\r\n    //                    console.info(message);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n\r\n        /**\r\n        * The commonly used log message\r\n        * @param {String} message - the message to be logged\r\n        **/\r\n        info : function (message){\r\n            if(typeof console !== 'undefined'){\r\n                if(this.level <= this.LOG_LEVEL_INFO){\r\n                    console.info(message);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n        * The worse kind of message. Usually a crash\r\n        * @param {String} message - the message to be logged\r\n        **/\r\n        error : function (message){\r\n            if(typeof console !== 'undefined'){\r\n                if(this.level <= this.LOG_LEVEL_ERROR){\r\n                    console.error(message);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         *Start grouping the log messages\r\n         *@param {String} title - the title of the group\r\n         *@see <a href=\"http://getfirebug.com/logging\">http://getfirebug.com/logging</a>\r\n         **/\r\n        group : function(title){\r\n            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info\r\n                if(typeof console !== 'undefined'){           \r\n                    /**If we do not test for group() function you will get an error in Opera\r\n                     *as Opera has it's own console...which does not have a group() function*/\r\n                    if(typeof console.group === 'function'){\r\n                        console.group(title);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        /**Ends current message grouping*/\r\n        groupEnd : function(){\r\n            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info\r\n                if(typeof console !== 'undefined'){\r\n                    /**If we do not test for groupEnd() function you will get an error in Opera\r\n                     *as Opera has it's own console...which does not have a group() function*/\r\n                    if(typeof console.groupEnd === 'function'){\r\n                        console.groupEnd();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    //Log.level = Log.LOG_LEVEL_DEBUG; \r\n    Log.level = Log.LOG_LEVEL_ERROR; \r\n    //Log.level = Log.LOG_LEVEL_ERROR;\r\n    //Log.level = Log.LOG_LEVEL_NONE;\r\n    module.exports = Log;\r\n    \r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/Log.js\n// module id = 92\n// module chunks = 0","/**\r\n * 常量定义\r\n */\r\n\r\n\tmodule.exports = \t{\r\n\t\tELEMENT_TYPE: \"elementType\",\r\n\t\tMODE: \"mode\",\r\n\t\tBACKGROUND: \"backgroud\",\r\n\t\tOPTIONS: \"options\",\r\n\t\tUSERDATA: \"userData\",\r\n\t\tID: \"id\",\r\n\t\tSTART_ID: \"startNodeId\",\r\n\t\tEND_ID: \"endNodeId\",\r\n\t\tALARM: \"Alarm\",\r\n\t\tRELATIONID:\"relationId\",\r\n\t\tRELATION_IMAGE:\"relationImage\",\r\n\t\tGROUP: \"Group\",\r\n\t\tCONNECTION: \"connection\",\r\n\t\tCHILDS: \"childs\",\r\n\t\tTREE_ROOT: \"treeRoot\",\r\n\t\tDOCKERS:\"options.dockers\",\r\n\t\tSTYLE_LINETYPE:\"style.lineType\",\r\n\t\tLINEOPERATIONICON:\"LineOperationIcon\",\r\n\t\tDEL:\"DEL\",\r\n\t\tLINK:\"straight\",\r\n\t\tFOLD:\"jagged\",\r\n\t\tCURVE:\"curve\"\r\n\t};\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/util/FlowConstants.js\n// module id = 93\n// module chunks = 0","/**\r\n * Flow工具类\r\n * @author wang.xiaohu9\r\n */\r\n\r\n    var Constants = require(\"./FlowConstants.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var GroupNode = require(\"../node/GroupNode.js\");\r\n    var Rect = require(\"../node/Rect.js\");\r\n    var Circle = require(\"../node/Circle.js\");\r\n    var Image = require(\"../node/Image.js\");\r\n    var Text = require(\"../node/Text.js\");\r\n    var Sector = require(\"../node/Sector.js\");\r\n    var Ring = require(\"../node/Ring.js\");\r\n    var Ellipse = require(\"../node/Ellipse.js\");\r\n    var Heart = require(\"../node/Heart.js\");\r\n    var Droplet = require(\"../node/Droplet.js\");\r\n    var Rose = require(\"../node/Rose.js\");\r\n    var Isogon = require(\"../node/Isogon.js\");\r\n    var Polygon = require(\"../node/Polygon.js\");\r\n    var Line = require(\"../node/Line.js\");\r\n    var Polyline = require(\"../node/Polyline.js\");\r\n    var BezierCurve = require(\"../node/BezierCurve.js\");\r\n    var Arc = require(\"../node/Arc.js\");\r\n    var Star = require(\"../node/Star.js\");\r\n    var Trochoid = require(\"../node/Trochoid.js\");\r\n    var Path = require(\"../node/Path.js\");\r\n    var IconButton = require(\"../node/IconButton\");\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var flowLink = require(\"../link/flowLink\");\r\n    /**\r\n     * 根据结点数组 导出JSON格式的数据\r\n     *\r\n     * @param {Array} model 总的模型\r\n     * @return {JSON} JSON格式的数据\r\n     */\r\n    function toJson(model, group) {\r\n        var jsonArr = [];\r\n        group.eachChild(function (node) {\r\n            if (node.model) {\r\n                //如果是组的话\r\n                if (node instanceof GroupNode) {\r\n                    var childArr = [];\r\n                    node.eachChild(function (childNode) {\r\n                        if (childNode.model) {\r\n                            childArr.push(childNode.model.option);\r\n                        }\r\n                    });\r\n                    node.model.set(Constants.CHILDS, childArr);\r\n                }\r\n                if (node instanceof Connector) {\r\n                    node.refreshModel();\r\n                }\r\n                jsonArr.push(node.model.option);\r\n\r\n            }\r\n\r\n\r\n        })\r\n        model.set(Constants.CHILDS, jsonArr);\r\n        return model.option;\r\n    }\r\n\r\n    /**\r\n     * 根据 JSON 生成节点\r\n     * @param  {[type]} fishTopoflow [description]\r\n     * @param  {[type]} json         [description]\r\n     * @return {[type]}              [description]\r\n     */\r\n    function fromJson(fishTopoflow, group, childShapes, isChild, layoutRootNode) {\r\n        var connectors = [];\r\n        // 1.先创建节点  遍历形状 获取模型\r\n        for (var i = 0; i < childShapes.length; i++) {\r\n            var shape = childShapes[i];\r\n            if (shape.elementType === Constants.CONNECTION) {\r\n                connectors.push(shape);\r\n            } else if (shape.elementType === Constants.ALARM) {\r\n                var relationNode = findNodeById(fishTopoflow.group, shape.relationId);\r\n                fishTopoflow.createAlarm(relationNode, shape.options);\r\n            } else if (shape.elementType === Constants.GROUP) {\r\n                shape.options.id = shape.id;\r\n                var createdGroup = fishTopoflow.createNode(shape.elementType, shape.options, shape.userData);\r\n                fromJson(fishTopoflow, createdGroup, shape.childs, true, layoutRootNode);\r\n\r\n                fishTopoflow.addNode(createdGroup);\r\n\r\n\r\n            } else {\r\n                // 根据options创建节点\r\n                var node = fishTopoflow.createNode(shape.elementType, shape.options, shape.userData);\r\n                if (isChild) {\r\n                    group.add(node);\r\n                } else {\r\n                    fishTopoflow.addNode(node);\r\n                }\r\n\r\n                if (shape.options.layout) {\r\n                    if (shape.options.layout.layout === Constants.TREE_ROOT) {\r\n                        var nodeForLayout = findNodeById(group, shape.id)\r\n                        layoutRootNode.push(nodeForLayout);\r\n                        //  fishTopo.layoutNode(\"tree\",{\"node\":node});\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        // 2. 再创建线\r\n        zrUtil.each(connectors, function (line) {\r\n            var startNode = findNodeById(group, line.startNodeId);\r\n            var endNode = findNodeById(group, line.endNodeId);\r\n            if (startNode && endNode) {\r\n                var link = fishTopoflow.createLink(startNode, endNode, line.options, line.userData);\r\n                if (isChild) {\r\n                    group.add(link);\r\n                } else {\r\n                    fishTopoflow.addNode(link);\r\n                }\r\n            }else{\r\n                var thisLink = flowLink.Link.createByPoint(line.options,line.userData);\r\n                if (isChild) {\r\n                    group.add(thisLink);\r\n                } else {\r\n                    fishTopoflow.addNode(thisLink);\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * 根据id在group中查找\r\n     * @param  {[type]} group  [description]\r\n     * @param  {[type]} nodeId [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    function findNodeById(group, nodeId) {\r\n        var retNode = null;\r\n        group.eachChild(function (node) {\r\n            if (node.id === nodeId) {\r\n                retNode = node;\r\n            }\r\n        })\r\n        return retNode;\r\n    }\r\n\r\n\r\n    /**\r\n     * Get canvas which has all thing rendered\r\n     * @param {Object} opts\r\n     * @param {string} [opts.backgroundColor]\r\n     */\r\n    function getRenderedCanvas(zr, opts) {\r\n        opts = opts || {};\r\n        opts.pixelRatio = opts.pixelRatio || 1;\r\n        opts.backgroundColor = opts.backgroundColor ||\r\n            \"#FFFFFF\";\r\n        var list = zr.storage.getDisplayList();\r\n        // Stop animations\r\n        zrUtil.each(list, function (el) {\r\n            el.stopAnimation(true);\r\n        });\r\n        return zr.painter.getRenderedCanvas(opts);\r\n    }\r\n\r\n    function toDataURL(zr, opts) {\r\n        opts = opts || {};\r\n        var url = getRenderedCanvas(zr, opts).toDataURL(\r\n            'image/' + (opts && opts.type || 'png')\r\n        );\r\n        return url;\r\n    }\r\n\r\n    function truncPosition(position) {\r\n        var x = parseInt(position[0], 10);\r\n        var y = parseInt(position[1], 10);\r\n        if (x < 0) {\r\n            x = 0\r\n        }\r\n        if (y < 0) {\r\n            y = 0\r\n        }\r\n        return [x, y];\r\n    }\r\n\r\n    function registerFlowNode(flowNode) {\r\n        var nodeCtors = {\r\n            Rect: Rect,\r\n            Circle: Circle,\r\n            Image: Image,\r\n            Text: Text,\r\n            Sector: Sector,\r\n            Ring: Ring,\r\n            Ellipse: Ellipse,\r\n            Heart: Heart,\r\n            Droplet: Droplet,\r\n            Rose: Rose,\r\n            Isogon: Isogon,\r\n            Polygon: Polygon,\r\n            Line: Line,\r\n            Polyline: Polyline,\r\n            BezierCurve: BezierCurve,\r\n            Arc: Arc,\r\n            Star: Star,\r\n            Trochoid: Trochoid,\r\n            Path: Path,\r\n            Group: GroupNode,\r\n            IconButton: IconButton\r\n        }\r\n        for (var name in nodeCtors) {\r\n            flowNode[name] = nodeCtors[name]\r\n        }\r\n        return flowNode;\r\n    }\r\n\r\n    /**\r\n     * Normalize css liked array configuration\r\n     * e.g.\r\n     *  3 => [3, 3, 3, 3]\r\n     *  [4, 2] => [4, 2, 4, 2]\r\n     *  [4, 3, 2] => [4, 3, 2, 3]\r\n     * @param {number|Array.<number>} val\r\n     */\r\n    function normalizeCssArray(val) {\r\n        var len = val.length;\r\n        if (typeof (val) === 'number') {\r\n            return [val, val, val, val];\r\n        } else if (len === 2) {\r\n            // vertical | horizontal\r\n            return [val[0], val[1], val[0], val[1]];\r\n        } else if (len === 3) {\r\n            // top | horizontal | bottom\r\n            return [val[0], val[1], val[2], val[1]];\r\n        }\r\n        return val;\r\n    }\r\n\r\n    function _trim(str) {\r\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\r\n    }\r\n\r\n    function parsePercent(percent, all) {\r\n        switch (percent) {\r\n            case 'center':\r\n            case 'middle':\r\n                percent = '50%';\r\n                break;\r\n            case 'left':\r\n            case 'top':\r\n                percent = '0%';\r\n                break;\r\n            case 'right':\r\n            case 'bottom':\r\n                percent = '100%';\r\n                break;\r\n        }\r\n        if (typeof percent === 'string') {\r\n            if (_trim(percent).match(/%$/)) {\r\n                return parseFloat(percent) / 100 * all;\r\n            }\r\n\r\n            return parseFloat(percent);\r\n        }\r\n\r\n        return percent == null ? NaN : +percent;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @param {string} str\r\n     * @param {boolean} [upperCaseFirst=false]\r\n     * @return {string} str\r\n     */\r\n    function toCamelCase(str, upperCaseFirst) {\r\n        str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {\r\n            return group1.toUpperCase();\r\n        });\r\n\r\n        if (upperCaseFirst && str) {\r\n            str = str.charAt(0).toUpperCase() + str.slice(1);\r\n        }\r\n\r\n        return str;\r\n    }\r\n    /**\r\n     * Enable property storage to any host object.\r\n     * Notice: Serialization is not supported.\r\n     *\r\n     * For example:\r\n     * var get = modelUitl.makeGetter();\r\n     *\r\n     * function some(hostObj) {\r\n     *      get(hostObj)._someProperty = 1212;\r\n     *      ...\r\n     * }\r\n     *\r\n     * @return {Function}\r\n     */\r\n    var makeGetter = (function () {\r\n        var index = 0;\r\n        return function () {\r\n            var key = '\\0__topo_prop_getter_' + index++;\r\n            return function (hostObj) {\r\n                return hostObj[key] || (hostObj[key] = {});\r\n            };\r\n        };\r\n    })();\r\n    var encodeHTML = function (source) {\r\n        return String(source)\r\n            .replace(/&/g, '&amp;')\r\n            .replace(/</g, '&lt;')\r\n            .replace(/>/g, '&gt;')\r\n            .replace(/\"/g, '&quot;')\r\n            .replace(/'/g, '&#39;');\r\n    };\r\n\r\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\r\n\r\n    var wrapVar = function (varName, seriesIdx) {\r\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\r\n    };\r\n    /**\r\n     * Template formatter\r\n     * @param {string} tpl\r\n     * @param {Array.<Object>|Object} paramsList\r\n     * @param {boolean} [encode=false]\r\n     * @return {string}\r\n     */\r\n    function formatTpl(tpl, paramsList, encode) {\r\n        if (!zrUtil.isArray(paramsList)) {\r\n            paramsList = [paramsList];\r\n        }\r\n        var seriesLen = paramsList.length;\r\n        if (!seriesLen) {\r\n            return '';\r\n        }\r\n\r\n        var $vars = paramsList[0].$vars || [];\r\n        for (var i = 0; i < $vars.length; i++) {\r\n            var alias = TPL_VAR_ALIAS[i];\r\n            var val = wrapVar(alias, 0);\r\n            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\r\n        }\r\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\r\n            for (var k = 0; k < $vars.length; k++) {\r\n                var ret = paramsList[seriesIdx][$vars[k]];\r\n                tpl = tpl.replace(\r\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\r\n                    encode ? encodeHTML(ret) : ret\r\n                );\r\n            }\r\n        }\r\n\r\n        return tpl;\r\n    }\r\n\r\n\r\n    module.exports = {\r\n        toJson: toJson,\r\n        fromJson: fromJson,\r\n        toDataURL: toDataURL,\r\n        truncPosition: truncPosition,\r\n        registerFlowNode: registerFlowNode,\r\n        normalizeCssArray: normalizeCssArray,\r\n        parsePercent: parsePercent,\r\n        toCamelCase: toCamelCase,\r\n        makeGetter: makeGetter,\r\n        formatTpl: formatTpl,\r\n        findNodeById: findNodeById\r\n    };\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/util/FlowUtil.js\n// module id = 94\n// module chunks = 0","/**\r\n * 组， 组中元素的坐标都是相对于这个组的<br>\r\n * @class fishTopoFlow.node.GroupNode\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var group1 = new node.Group({\r\n *           position:[60,50]\r\n *       });\r\n *\r\n *       var rect1 = new node.Rect({\r\n *           shape:{width:120,height:30},\r\n *           style:{text:\"标题\", fill:\"#FFB90F\",stroke:\"#bbbbbb\"},\r\n *           position:[0,0],\r\n *           selectable:false\r\n *       });\r\n *\r\n *       var rect2 = new node.Rect({\r\n *           shape:{width:120,height:60},\r\n *           style:{text:\"内容\", fill:\"#FFFFFF\",stroke:\"#bbbbbb\"},\r\n *           position:[0,30],\r\n *           selectable:false\r\n *       });\r\n *\r\n *       group1.add(rect1);\r\n *       group1.add(rect2);\r\n *       fishTopo.add(group1);\r\n */\r\n\r\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect.js');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var util = require(\"../../../fish-topo-core/lib/util.js\");\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var flowNode =require('./flowNode');\r\n\r\n    function GroupNode(opts) {\r\n        this.model = flowNode.genModel(\"GroupNode\", opts);\r\n        graphic.Group.call(this, opts);\r\n\r\n        var defaultOptions = {\r\n            shape: {\r\n                width: 5,\r\n                height: 5,\r\n                r: 5\r\n            },\r\n            style: {\r\n                fill: 'rgba(0,0,0,0)',//'#f9f9f9',\r\n                stroke: 'rgba(0,0,0,0)'//'#bbbbbb'\r\n            },\r\n            position: [0, 0]\r\n        };\r\n        this.options = zrUtil.merge(defaultOptions, opts, true);\r\n        //函数无法clone 原型clone不上\r\n        this.options.layout = opts.layout;\r\n        this.max = [1024, 960];\r\n        this.render(this.options);\r\n    }\r\n    GroupNode.RECT_NAME = \"GROUP_RECT_NAME\";\r\n    GroupNode.prototype = {\r\n        constructor: GroupNode,\r\n        type: \"GroupNode\",\r\n        render: function (model) {\r\n            var rect = new graphic.Rect({\r\n                shape: model.shape,\r\n                style: model.style,\r\n                //silent:true, //加上后 拖动 组中没有子元素的地方 无法手动了\r\n                z2:-1\r\n            });\r\n            rect.name = GroupNode.RECT_NAME;\r\n            this.add(rect);\r\n            this.position = model.position;\r\n            this.mergedImage = model.mergedImage;\r\n        },\r\n        rectContain: function (x, y) {\r\n            var rect = util.getRect(this);\r\n            return rect.boundingRect.contain(x, y);\r\n        },\r\n\r\n        /**\r\n         * 遍历组中每一个子节点\r\n         * @param  {Function} cb 回调函数cb\r\n         * @param  {Object} context   上下文context\r\n         */\r\n        each: function (cb, context) {\r\n            var children = this._children;\r\n            for (var i = 0; i < children.length; i++) {\r\n                var child = children[i];\r\n                if (child.name != GroupNode.RECT_NAME) {\r\n                    cb.call(context, child, i);\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n        // 设置 group中框形大小为 group的包围和\r\n        willRender:function () {\r\n            if (this.options.layout) {\r\n                this.setLayout(this.options.layout);\r\n            }\r\n            this.setProperties({\r\n                shape: {\r\n                    width: this.getBoundingRect().width,\r\n                    height: this.getBoundingRect().height\r\n                }\r\n            });\r\n        },\r\n\r\n        setLayout: function(Layout) {\r\n            Layout.run(this);\r\n        },\r\n\r\n        getRect: function () {\r\n            var boundingRect = this.getBoundingRect();\r\n            //创建最小包围盒虚线\r\n            var points = [];\r\n            points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n            points[1] = [boundingRect.width / 2, -boundingRect.height / 2];\r\n            points[2] = [boundingRect.width / 2, boundingRect.height / 2];\r\n            points[3] = [-boundingRect.width / 2, boundingRect.height / 2];\r\n            points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\r\n            var boundRect = new BoundingRect(this.position[0],\r\n                this.position[1],\r\n                boundingRect.width, boundingRect.height);\r\n            return {\r\n                x: this.position[0] + boundingRect.width / 2,\r\n                y: this.position[1] + boundingRect.height / 2,\r\n                width: boundingRect.width,\r\n                height: boundingRect.height,\r\n                points: points,\r\n                boundingRect: boundRect\r\n            };\r\n        },\r\n        /**\r\n         * 拖拽组内节点的时候，动态更改背景rect的大小\r\n         * @param nodeMessage 拖拽的组内节点的信息\r\n         */\r\n        modifyGroupRect: function (nodeMessage) {\r\n            //1.重置背景rect 的长宽\r\n            var minLength = this.options.shape.r;\r\n            this.setProperties({\r\n                shape: {\r\n                    width: minLength,\r\n                    height: minLength,\r\n                    r: minLength\r\n                }\r\n            });\r\n\r\n            var rect = this.childOfName(GroupNode.RECT_NAME);\r\n            var boundingRect = this.getBoundingRect();\r\n            var width = boundingRect.width;\r\n            var height = boundingRect.height;\r\n            var rx = rect.position[0],//rect.shape.x,\r\n                ry = rect.position[1];//rect.shape.y;\r\n            //2.取group中所有节点最靠上边和最高左边的值，不包括背景rect的值\r\n            var minX = this._children[1].position[0],\r\n                minY = this._children[1].position[1];\r\n            var maxX = this._children[1].position[0],\r\n                maxY = this._children[1].position[1];\r\n            var nowNodePosition = zrUtil.clone(nodeMessage.position);\r\n            for (var i = 1; i < this._children.length; i++) {\r\n                if (this._children[i] instanceof Connector || this._children[i].isIcon == true) {\r\n                    continue;\r\n                } else {\r\n                    if (minX > this._children[i].position[0]) {\r\n                        minX = this._children[i].position[0];\r\n                    }\r\n                    if (maxX < this._children[i].position[0]) {\r\n                        maxX = this._children[i].position[0];\r\n                    }\r\n                    if (minY > this._children[i].position[1]) {\r\n                        minY = this._children[i].position[1];\r\n                    }\r\n                    if (maxY < this._children[i].position[1]) {\r\n                        maxY = this._children[i].position[1];\r\n                    }\r\n                }\r\n            }\r\n\r\n            // 3. 宽度大于最大宽度\r\n            if (width > this.max[0]) {\r\n                width = this.max[0] - 2;\r\n                if (nodeMessage.position[0] > minX) {\r\n                    nowNodePosition[0] = minX + this.max[0] - nodeMessage.width;\r\n                } else {\r\n                    nowNodePosition[0] = maxX - this.max[0] + nodeMessage.width;\r\n                }\r\n            } else {\r\n                //移动节点改变group中背景rect的x位置，不超过最小的值\r\n                rx = rect.position[0] + nodeMessage.position[0];\r\n                if (rx > minX) {\r\n                    rx = minX;\r\n                }\r\n                nowNodePosition[0] = nodeMessage.movePosition[0] + nodeMessage.moveX;\r\n                if (nodeMessage.position[0] > minX) {\r\n                    if (nowNodePosition[0] > minX + this.max[0] - nodeMessage.width) {\r\n                        nowNodePosition[0] = minX + this.max[0] - nodeMessage.width;\r\n                    }\r\n                } else {\r\n                    if (nowNodePosition[0] < maxX - this.max[0] + nodeMessage.width) {\r\n                        nowNodePosition[0] = maxX - this.max[0] + nodeMessage.width\r\n                    }\r\n                }\r\n            }\r\n            if (height > this.max[1]) {\r\n                height = this.max[1] - 2;\r\n                if (nodeMessage.position[1] > minY) {\r\n                    nowNodePosition[1] = minY + this.max[1] - nodeMessage.height;\r\n                } else {\r\n                    nowNodePosition[1] = maxY - this.max[1] + nodeMessage.height;\r\n                }\r\n            } else {\r\n                //移动节点改变group中背景rect的y位置，不超过最小的值\r\n                ry = rect.position[1] + (nodeMessage.position[1]);\r\n                if (ry > minY) {\r\n                    ry = minY;\r\n                }\r\n                nowNodePosition[1] = nodeMessage.movePosition[1] + nodeMessage.moveY;\r\n                if (nodeMessage.position[1] > minY) {\r\n                    if (nowNodePosition[1] > minY + this.max[1] - nodeMessage.height) {\r\n                        nowNodePosition[1] = minY + this.max[1] - nodeMessage.height;\r\n                    }\r\n                } else {\r\n                    if (nowNodePosition[1] < maxY - this.max[1] + nodeMessage.height) {\r\n                        nowNodePosition[1] = maxY - this.max[1] + nodeMessage.height\r\n                    }\r\n                }\r\n            }\r\n            if (nodeMessage.node.alarm) {\r\n                var newAlarmPosition = [nowNodePosition[0] + nodeMessage.node.getBoundingRect().width - (nodeMessage.node.alarm\r\n                        .getBoundingRect().width - 6), nowNodePosition[1] - nodeMessage.node.alarm.getBoundingRect()\r\n                    .height - 3\r\n                ];\r\n                nodeMessage.node.alarm.attr(\"position\", newAlarmPosition);\r\n            }\r\n            //改变背景rect的长宽和位置\r\n            this.setProperties({\r\n                shape: {\r\n                    width: width,\r\n                    height: height,\r\n                    x: rx,\r\n                    y: ry\r\n                }\r\n            });\r\n\r\n        },\r\n\r\n        setProperties: function (opt) {\r\n            var rect = this.childOfName(GroupNode.RECT_NAME);\r\n            rect.setShape(opt.shape);\r\n           // rect.attr(\"style\", opt.style);\r\n            rect.attr('position', opt.position);\r\n           // this.attr(\"shape\", opt.shape);\r\n        },\r\n\r\n        merged: function () {\r\n            var that = this;\r\n            //保留group的初始位置\r\n            var groupPosition = zrUtil.clone(this.position);\r\n            //给小图片设置属性，隐藏group\r\n            var width = this._relationImage.getBoundingRect().width;\r\n            var height = this._relationImage.getBoundingRect().height;\r\n            //计算合并后的小图片的position\r\n            var relationImagePosition = [this.position[0] + this.childOfName(GroupNode.RECT_NAME).shape.x + (this.getBoundingRect()\r\n                    .width / 2 - width / 2), this.position[1] + this.childOfName(GroupNode.RECT_NAME).shape.y +\r\n                (this.getBoundingRect().height / 2 - height / 2)\r\n            ];\r\n            //将小图片的位置保留下来\r\n            var cloneImagePosition = zrUtil.clone(relationImagePosition);\r\n            this._relationImage.attr(\"style\", {\r\n                image: this.mergedImage,\r\n                width: width,\r\n                height: height\r\n            });\r\n            this._relationImage.attr(\"position\", relationImagePosition);\r\n            if (width > 0 && height > 0) {\r\n                this.hide();\r\n                this._relationImage.show();\r\n            }\r\n\r\n            //双击图片放出组\r\n            this._relationImage.on(\"dblclick\", function () {\r\n                //设置组的位置根据小图片的偏移量来计算\r\n                that.attr('position',[groupPosition[0] + (this.position[0] -cloneImagePosition[0]),\r\n                    groupPosition[1] + (this.position[1] - cloneImagePosition[1])]);\r\n                this.hide();\r\n                that.show();\r\n            });\r\n            return this._relationImage;\r\n        }\r\n    }\r\n\r\n    zrUtil.inherits(GroupNode, graphic.Group);\r\n    module.exports = GroupNode;\r\n\r\n/**\r\n * @method add\r\n * 将节点加入到这个组中最后\r\n * @param {Object} node 欲添加到组的节点\r\n */\r\n/**\r\n * @method removeAll\r\n * 移除所有子节点\r\n */\r\n\r\n/**\r\n * @method remove\r\n * 移除所有子节点\r\n * @param {Object} child 子节点\r\n */\r\n/**\r\n * @method childOfName\r\n * 获取指定名字的儿子节点\r\n * @param {String} name\r\n * @return {Object} 节点\r\n */\r\n/**\r\n * @method traverse\r\n * 深度优先遍历所有子孙节点（each只遍历子节点）\r\n * @param {String} name\r\n * @return {Object} 节点\r\n */\r\n\r\n/**\r\n * @cfg {String} mergedImage=''  控制当双击时 组可以缩小为指定的图形。\r\n */\r\n\r\n/**\r\n * @cfg {Boolean} childDraggable=false  控制组内成员是否可以拖动\r\n */\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/GroupNode.js\n// module id = 95\n// module chunks = 0","'use strict';\n/**\r\n * fishTopoFlow的node对象，框架提供的节点都放在这个对象下。通过extend方法创建自定义节点<br>\r\n * @class fishTopoFlow.node\r\n * @abstract\r\n *\r\n    * **使用范例**：\r\n    *\r\n    *      @example\r\n    *       var node = fishTopoFlow.node;\r\n    *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n    *      var Diamond = node.extend({\r\n    *          type: 'Diamond',\r\n    *          shape: {\r\n    *              width: 0,\r\n    *              height: 0\r\n    *          },\r\n    *          buildPath: function (path, shape) {\r\n    *              var cx = 0;\r\n    *              var cy = 0;\r\n    *              var width = shape.width / 2;\r\n    *              var height = shape.height / 2;\r\n    *              path.moveTo(cx, cy - height);\r\n    *              path.lineTo(cx + width, cy);\r\n    *              path.lineTo(cx, cy + height);\r\n    *              path.lineTo(cx - width, cy);\r\n    *              path.closePath();\r\n    *          }\r\n    *      });\r\n    *        var diamod = new Diamond({\r\n    *            shape: {\r\n    *                width:50,\r\n    *                height:50\r\n    *            },\r\n    *            position:[60,60]\r\n    *        })\r\n    *        fishTopo.add(diamod);\r\n */\r\n\r\n    var Path = require('zrender/lib/graphic/Path');\r\n    var Constants = require(\"../util/FlowConstants.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var util = require(\"../../../fish-topo-core/lib/util.js\");\r\n    var Model = require(\"../../../fish-topo-core/lib/model.js\");\r\n    var flowNode = {};\r\n    /**\r\n     * 构造模型\r\n     * @private\r\n     */\r\n    flowNode.genModel = function (type, opts) {\r\n        var model = new Model({});\r\n        // 没有id的时候，缺少给一个UUID。创建节点或者反序列化的时候 节点的ID取的是opts.id\r\n\t\tif (!opts.id) {\r\n\t\t\topts.id = util.getUUID();\r\n\t\t}\r\n        model.set(Constants.ELEMENT_TYPE, type);\r\n        // 防止 new el.constructor({ style: el.style,shape: el.shape }); zrUtil.clone报错\r\n        if (opts.style && opts.style.host) {\r\n            delete opts.style.host;\r\n        }\r\n        model.set(Constants.OPTIONS, zrUtil.clone(opts));\r\n        if (\"draggable\" in opts) {\r\n            opts.isdraggable = opts.draggable;\r\n            delete opts.draggable;\r\n        }\r\n        if (!opts.z) {\r\n            opts.z = 1; //节点默认为1，线段0;\r\n        }\r\n\r\n        if (util.isUndefined(opts.hoverAnimation)) {\r\n            opts.hoverAnimation = false;\r\n        }\r\n\r\n        if (util.isUndefined(opts.selectable)) {\r\n            opts.selectable = true;  //默认可以选中\r\n        }\r\n        return model;\r\n    }\r\n\r\n    flowNode.addHoverAnimation = function(node) {\r\n        var scale = zrUtil.clone(node.scale) || [1,1];\r\n        var onEmphasis = function() {\r\n            this.animateTo({\r\n                scale: [scale[0] * 1.1, scale[1] * 1.1]\r\n            }, 400, 'elasticOut');\r\n        };\r\n        var onNormal = function() {\r\n            this.animateTo({\r\n                scale: scale\r\n            }, 400, 'elasticOut');\r\n        };\r\n        node.on('mouseover', onEmphasis)\r\n            .on('mouseout', onNormal)\r\n            .on('emphasis', onEmphasis)\r\n            .on('normal', onNormal);\r\n    }\r\n    /**\r\n     * @method extend\r\n     * 扩展一个 自定义节点, 比如钻石形等。\r\n     * @param {Object} props\r\n     * @param {string} props.type 自定义结节的名称 Path type\r\n     * @param {Function} [props.init] 初始化 Initialize\r\n     * @param {Function} props.buildPath 进行构建节点 Overwrite buildPath method\r\n     * @param {Object} [props.style] 缺省样式 Extended default style config\r\n     * @param {Object} [props.shape] 缺省节点参数 Extended default shape config\r\n     *\r\n     */\r\n    flowNode.extend = function (defaults) {\r\n        var Sub = function (opts) {\r\n            this.model = flowNode.genModel(defaults.type, opts);\r\n            Path.call(this, opts);\r\n\r\n            if (defaults.style) {\r\n                // Extend default style\r\n                this.style.extendFrom(defaults.style, false);\r\n            }\r\n\r\n            // Extend default shape\r\n            var defaultShape = defaults.shape;\r\n            if (defaultShape) {\r\n                this.shape = this.shape || {};\r\n                var thisShape = this.shape;\r\n                for (var name in defaultShape) {\r\n                    if (\r\n                        !thisShape.hasOwnProperty(name)\r\n                        && defaultShape.hasOwnProperty(name)\r\n                    ) {\r\n                        thisShape[name] = defaultShape[name];\r\n                    }\r\n                }\r\n            }\r\n\r\n            defaults.init && defaults.init.call(this, opts);\r\n\r\n        };\r\n\r\n        zrUtil.inherits(Sub, Path);\r\n\r\n        // FIXME 不能 extend position, rotation 等引用对象\r\n        for (var name in defaults) {\r\n            // Extending prototype values and methods\r\n            if (name !== 'style' && name !== 'shape') {\r\n                Sub.prototype[name] = defaults[name];\r\n            }\r\n        }\r\n\r\n        return Sub;\r\n    };\r\n\r\n    module.exports = flowNode;\r\n\r\n\r\n/**\r\n * @cfg {Array} position 节点的位置,统一使用position进行定位[x,y] eg. [100,100]\r\n */\r\n\r\n/**\r\n * @cfg {Object} style 样式参数\r\n * @cfg {string} style.fill=#000 填充色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red | gradient\r\n * @cfg {string} style.stroke=null 笔画颜色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red | gradient\r\n * @cfg {number} style.lineWidth=1 笔画宽度\r\n * @cfg {Array} style.lineDash=null 笔画的虚线间隔，参数为交替绘制线段和间距长度的数字 参见[lineDashOffset](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/setLineDash) eg. lineDash:[6,10]\r\n * @cfg {number} style.lineDashOffset=0  笔画的虚线偏移量 参见[lineDashOffset](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset)\r\n * @cfg {string} style.text=\"\" 节点上显示的文本,可以使用 \\n 来换行\r\n * @cfg {string} style.textFont='12px sans-serif' 字体大小、字体类型、粗细、字体样式。格式参见[css font](https://developer.mozilla.org/en-US/docs/Web/CSS/font) eg.textFont: 'italic bolder 14px Microsoft YaHei'\r\n * @cfg {string} style.fontStyle=null 字体样式\r\n * @cfg {string} style.fontWeight=#000 字体粗细\r\n * @cfg {number} style.fontSize=null 字体大小\r\n * @cfg {string} style.fontFamily=null 字体类型\r\n * @cfg {string} style.textFill=#000 节点上文本的填充色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red\r\n * @cfg {string} style.textStoke=null 节点上文本的描边色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red\r\n * @cfg {string|Array} style.textPosition=\"\" 文本在节点中的位置left|right|top|bottom|inside|insideLeft|insideRight|insideTop|insideBottom|insideTopLeft|insideTopRight|insideBottomLeft|insideBottomRight|[x,y]|[%,%]\r\n * @cfg {string} style.textBaseline=\"alphabetic\" 当前文本基线的属性 \"top\" || \"hanging\" || \"middle\" || \"alphabetic\" || \"ideographic\" || \"bottom\" 参见[css font](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/textBaseline)\r\n * @cfg {Array} style.textOffset=null 文本在节点的偏移值[x,y] eg. [10,10]\r\n * @cfg {string} style.textAlign=\"\" 文本在节点中的对齐方式 left | center | right\r\n * @cfg {string} style.textVerticalAlign=null 文本在节点中的垂直对齐方式 top | middle | bottom\r\n * @cfg {number} style.textDistance=5 文字的相对textPos的偏移量 eg. textPosition='left' textDistance=5 则文字的x坐标的值为 (left的坐标x值) -5\r\n * @cfg {string} style.textShadowColor='transparent' 文字阴影颜色\r\n * @cfg {number} style.textShadowBlur=0 文本阴影宽度 参见[shadowBlur](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowBlur)\r\n * @cfg {number} style.textShadowOffsetX=0 文本阴影 X 方向偏移 参见shadowOffsetX[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX]\r\n * @cfg {number} style.textShadowOffsetY=0 文本阴影 Y 方向偏移 参见shadowOffsetY[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY]\r\n * @cfg {number} style.textRotation=0 文本旋转的角度\r\n * @cfg {number} style.textBorderWidth=0 文字描边宽度\r\n * @cfg {string} style.textBorderColor=null 文字描边颜色\r\n * @cfg {number} style.textBorderRadius=0 文字描边半径\r\n * @cfg {string|Object} style.textBackgroundColor=null 文字背景(颜色或图片) eg. '#333' | {image:'./asset/img/clund.png'}\r\n * @cfg {number|Array} style.textPadding=null 文字padding  eg. `2` or `[2, 4]` or `[2, 3, 4, 5]`\r\n * @cfg {Object} style.rich=null 富文本样式属性\r\n * @cfg {number} style.textLineHeight=0 文字的行高\r\n * @cfg {number} style.opacity=1 图形透明度。支持从 0 到 1 的数字，为 0 时不绘制该图形。\r\n * @cfg {number} style.shadowBlur=0 阴影宽度 参见[shadowBlur](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowBlur)\r\n * @cfg {number} style.shadowOffsetX=0 阴影 X 方向偏移 参见shadowOffsetX[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX]\r\n * @cfg {number} style.shadowOffsetY=0 阴影 Y 方向偏移 参见shadowOffsetY[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY]\r\n * @cfg {string} style.shadowColor='#000' 阴影颜色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red 参见[shadowColor](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowColor)\r\n * @cfg {string} style.image=\"\" 图片的路径 用于Image\r\n * @cfg {number} style.width 图片的宽度 用于Image\r\n * @cfg {number} style.height 图片的高度 用于Image\r\n */\r\n\r\n /**\r\n * @cfg {Object} hoverStyle hover样式, 参数见style\r\n  */\r\n /**\r\n * @cfg {Object} selectStyle 选中节点的样式, 参数见style;  默认是一个虚的边框;  设为空对象则不显示选中边框;\r\n*/\r\n/**\r\n * @cfg {Boolean} draggable=true 是否可以被拖拽。\r\n */\r\n\r\n/**\r\n * @cfg {Boolean} selectable=true 节点是否可选中，默认是true\r\n */\r\n\r\n/**\r\n * @cfg {String} id 为了避免重复，目前由系统自动生成，如果不需要用可以忽略。建议使用nmae\r\n */\r\n\r\n/**\r\n *  @cfg {Boolean} hoverAnimation=false 是否开启 hover 在节点上的提示动画效果。，默认是false\r\n */\r\n\r\n/**\r\n * @cfg {String} name 指定节点的name, 可以使用childOfName等函数根据name查找节点\r\n */\r\n\r\n/**\r\n * @cfg {String} tooltip 节点的tooltip 内容可以包括HTML标签\r\n */\r\n\r\n/**\r\n * @cfg {Object} relative relative描述怎么根据父元素进行定位，设置了relative属性 就不需要设置position。支持：left、right、top、bottom\r\n * @cfg {Number|String} relative.left  距离父元素左边的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.left 和 right 只有一个可以生效。\r\n * @cfg {Number|String} relative.right  距离父元素右边的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.left 和 right 只有一个可以生效。\r\n * @cfg {Number|String} relative.top  距离父元素顶部的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.top 和 bottom 只有一个可以生效。\r\n * @cfg {Number|String} relative.bottom  距离父元素底部的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.top 和 bottom 只有一个可以生效。\r\n * @cfg {String} [bounding='all'] 决定此图形元素在定位时，对自身的包围盒计算方式。 1.'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。2.'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。\r\n */\r\n\r\n/**\r\n * @cfg {Array} scale 节点的缩放因子, [x,y] 水平与垂直方向的 eg. [1,1]\r\n */\r\n\r\n/**\r\n * @cfg {number} rotation 节点的旋转因子, 单位是角度 eg. 0.5* Math.PI\r\n */\r\n\r\n/**\r\n * @cfg {Array} origin 旋转和缩放的原点, [x,y] eg. [75,75]\r\n */\r\n\r\n/**\r\n * @cfg {number} z=0  z方向的高度，决定层叠关系。类似css zIndex\r\n */\r\n\r\n/**\r\n * @cfg {number} zlevel=0  决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。\r\n */\r\n\r\n/**\r\n * @cfg {Boolean} silent=false  是否不响应鼠标以及触摸事件。\r\n */\r\n/**\r\n * @cfg {Boolean} invisible=false  节点是否可见。\r\n */\r\n\r\n/**\r\n * @cfg {Object} parent  节点的父元素\r\n */\r\n/**\r\n * @cfg {Object} operationIcons  节点操作为选中的节点，提供默认操作或用户自定操作。 默认提供的操作：{ name: constants.DEL } 删除节点, { constants.LINK} 直线, { constants.FOLD} 折线, { constants.CURVE } 曲线。也可以自定义操作\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var image1 = new node.Image({\r\n *           style: {\r\n *               image: \"img/img-cic/icon-send-sms.svg\",\r\n *               width:120,\r\n *               height:70,\r\n *               text:\"操作:线段\",\r\n *               textPosition:\"insideBottom\"\r\n *           },\r\n *           position:[60,60],\r\n *           operationIcons: [\r\n *               { name: constants.LINK} ,\r\n *               { name: constants.FOLD },\r\n *               { name: constants.CURVE }\r\n *           ]\r\n *       });\r\n */\r\n\r\n/**\r\n * @property {Object} states\r\n * 用于设置节点的状态\r\n */\r\n\r\n\r\n/**\r\n * @property {Object} model\r\n * 节点的模型，用于存储序列化数据 以及用户自定义数据\r\n */\r\n\r\n/**\r\n * @method setStyle\r\n * 创建节点后，设置节点的样式（style属性）\r\n * @param {String} key 键名\r\n * @param {*} value 键值\r\n * @return {Object} 返回节点对象自身\r\n */\r\n\r\n/**\r\n * @method setShape\r\n * 创建节点后，设置节点的形状（shape属性）\r\n * @param {String} key 键名\r\n * @param {*} value 键值\r\n * @return {Object} 返回节点对象自身\r\n */\r\n\r\n/**\r\n * @method hide\r\n * 隐藏节点\r\n */\r\n\r\n/**\r\n * @method show\r\n * 显示节点\r\n */\r\n\r\n\r\n/**\r\n * @method on\r\n * 绑定事件\r\n * @param {String} event 事件名\r\n * @param {Function} handler 事件处理函数\r\n * @param {Object} [context] 上下文\r\n */\r\n\r\n/**\r\n * @method off\r\n * 解绑事件\r\n * @param {String} event 事件名\r\n * @param {Function} handler 事件处理函数\r\n */\r\n\r\n/**\r\n * @method one\r\n * 单次触发绑定,trigger后销毁\r\n * @param {String} event 事件名\r\n * @param {Function} handler 事件处理函数\r\n * @param {Object} [context] 上下文\r\n */\r\n\r\n/**\r\n * @method trigger\r\n * 事件分发\r\n * @param {String} type 事件类型\r\n */\r\n\r\n/**\r\n * @method isSilent\r\n * 是否绑定了事件\r\n * @param {String} event 事件名\r\n * @return {boolean}\r\n */\r\n\r\n/**\r\n * @method animate\r\n * 动画\r\n * @param {String} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\r\n * @param {Boolean} [loop] 动画是否循环\r\n * @return {Object} 返回Animator对象\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *      el.animate('style', false)\r\n *         .when(1000, {x: 10} )\r\n *         .done(function(){ // Animation done })\r\n *         .start()\r\n */\r\n\r\n/**\r\n * @method stopAnimation\r\n * 停止动画\r\n * @param {boolean} forwardToLast 是否在停止前移动到最后一帧\r\n */\r\n\r\n/**\r\n * @method animateTo\r\n * 从一动属性过渡到另一种属性的动画\r\n * @param {Object} target 目前属性\r\n * @param {number} [time=500] 动画时间 单位ms\r\n * @param {string} [easing='linear'] 动画函数 参见[缓动示例](http://echarts.baidu.com/gallery/editor.html?c=line-easing)\r\n * @param {number} [delay=0] 延时时间\r\n * @param {Function} [callback] 动画结束回调\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          // Animate position\r\n *          el.animateTo({\r\n *              position: [10, 10]\r\n *          }, function () { // done })\r\n *\r\n *          // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\r\n *          el.animateTo({\r\n *              shape: {\r\n *                  width: 500\r\n *              },\r\n *              style: {\r\n *                  fill: 'red'\r\n *              }\r\n *              position: [10, 10]\r\n *          }, 100, 100, 'cubicOut', function () { // done })\r\n */\r\n\r\n/**\r\n * @event click\r\n * 单击事件\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象\r\n * <pre>\r\n * node.on('click', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n/**\r\n * @event dblclick\r\n * 当双击元素时，会发生 dblclick 事件。\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象\r\n * <pre>\r\n * node.on('dblclick', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n/**\r\n * @event mouseover\r\n * 当鼠标指针位于元素上方时，会发生 mouseover 事件\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象\r\n * <pre>\r\n * node.on('mouseover', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n/**\r\n * @event mouseout\r\n * 当鼠标指针从元素上移开时，发生 mouseout 事件。\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象\r\n * <pre>\r\n * node.on('mouseout', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n\r\n/**\r\n * @event mousemove\r\n * 当鼠标指针在指定的元素中移动时，就会发生 mousemove 事件\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象\r\n * <pre>\r\n * node.on('mousemove', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n\r\n/**\r\n * @event mousewheel\r\n * 当用户在指定的元素时滚动鼠标滑轮时,就会发生 mousewheel事件\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象\r\n * <pre>\r\n * node.on('mousewheel', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n\r\n/**\r\n * @event mousedown\r\n * 当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象\r\n * <pre>\r\n * node.on('mousedown', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n\r\n/**\r\n * @event mouseup\r\n * 当在元素上放松鼠标按钮时，会发生 mouseup 事件。\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象\r\n * <pre>\r\n * node.on('mouseup', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n/**\r\n * @event contextmenu\r\n * 当在元素上点击鼠标右键时，会发生 contextmenu 事件。\r\n * @param {Object} event 事件\r\n * @param {Object} event.target 目标对象\r\n * @param {Object} event.event 实际的浏览器事件对象，如果想阻止默认的浏览器右键菜单请使用 event.event.preventDefault(); event.event.stopPropagation();\r\n\r\n * <pre>\r\n * node.on('contextmenu', function(event) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n/**\r\n * @event dragstart\r\n * 当开始拖动节点的时候，会发生 dragstart 事件。\r\n *\r\n * <pre>\r\n * node.on('dragstart', function(e) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n\r\n/**\r\n * @event drag\r\n * 当拖动节点的时候，会发生 drag 事件。\r\n *\r\n * <pre>\r\n * node.on('drag', function(e) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n/**\r\n * @event dragend\r\n * 当拖动节点结束的时候，会发生 dragend 事件。\r\n *\r\n * <pre>\r\n * node.on('dragend', function(e) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/flowNode.js\n// module id = 96\n// module chunks = 0","/**\r\n * 矩形<br>\r\n * @class fishTopoFlow.node.Rect\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var rect = new node.Rect({\r\n *           shape:{width:100,height:60},\r\n *           position:[20,20]\r\n *       });\r\n *       fishTopo.add(rect);\r\n */\r\n\r\n    var roundRectHelper = require('zrender/lib/graphic/helper/roundRect');\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Rect',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Array} shape.points=null 拆线点的坐标 可以从AI中获取。\r\n         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑\r\n         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效\r\n         */\r\n        shape: {\r\n            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\r\n            // r缩写为1         相当于 [1, 1, 1, 1]\r\n            // r缩写为[1]       相当于 [1, 1, 1, 1]\r\n            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\r\n            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\r\n            x: 0,\r\n            y: 0,\r\n            r: 0,\r\n            width: 50,\r\n            height: 50\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var x = 0;\r\n            var y = 0;\r\n            var width = shape.width;\r\n            var height = shape.height;\r\n            if (!shape.r) {\r\n                ctx.rect(x, y, width, height);\r\n            }\r\n            else {\r\n                roundRectHelper.buildPath(ctx, shape);\r\n            }\r\n            ctx.closePath();\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Rect.js\n// module id = 97\n// module chunks = 0","'use strict';\n/**\r\n * 圆形<br>\r\n * @class fishTopoFlow.node.Circle\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var circle = new node.Circle({\r\n *           shape:{r:24},\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(circle);\r\n */\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Circle',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.r=20 半径。\r\n         */\r\n        shape: {\r\n            r: 20\r\n        },\r\n\r\n        buildPath : function (ctx, shape, inBundle) {\r\n            // Better stroking in ShapeBundle\r\n            // Always do it may have performence issue ( fill may be 2x more cost)\r\n            if (inBundle) {\r\n                ctx.moveTo(shape.r, 0);\r\n            }\r\n            // Better stroking in ShapeBundle\r\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\r\n            ctx.arc(0, 0, shape.r, 0, Math.PI * 2, true);\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Circle.js\n// module id = 98\n// module chunks = 0","/**\r\n * 图片节点<br>\r\n * @class fishTopoFlow.node.Image\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var image = new node.Image({\r\n *           style: {\r\n *               image: \"../../examples/flow/img/img-cic/start.svg\",\r\n *               width:120,\r\n *               height:70,\r\n *               text:\"Event Name\"\r\n *           },\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(image);\r\n */\r\n\r\n\r\n    var Displayable = require('zrender/lib/graphic/Displayable');\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var flowNode = require('./flowNode');\r\n    var LRU = require('zrender/lib/core/LRU');\r\n    var globalImageCache = new LRU(50);\r\n\r\n\r\n    function ZImage(opts) {\r\n        this.model = flowNode.genModel(\"Image\", opts);\r\n        Displayable.call(this, opts);\r\n\r\n        if (window.jQuery) {   //判断jQuery是否存在\r\n            this.resultDeferrd = jQuery.Deferred();\r\n            this.result = this.resultDeferrd.promise();\r\n        }\r\n    }\r\n\r\n    ZImage.prototype = {\r\n\r\n        constructor: ZImage,\r\n\r\n        type: 'Image',\r\n\r\n        brush: function (ctx, prevEl) {\r\n            var style = this.style;\r\n            var src = style.image;\r\n            var image;\r\n\r\n            // Must bind each time\r\n            style.bind(ctx, this, prevEl);\r\n            // style.image is a url string\r\n            if (typeof src === 'string') {\r\n                image = this._image;\r\n            }\r\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\r\n            else {\r\n                image = src;\r\n                image.isLoaded = true;\r\n            }\r\n            // FIXME Case create many images with src\r\n            if (!image && src) {\r\n                // Try get from global image cache\r\n                var cachedImgObj = globalImageCache.get(src);\r\n                if (!cachedImgObj) {\r\n                    // Create a new image\r\n                    image = new Image();\r\n                    image.isLoaded = false;\r\n                    image.onload = function () {\r\n                        image.isLoaded = true;\r\n                        image.onload = null;\r\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\r\n                            cachedImgObj.pending[i].dirty();\r\n                        }\r\n                    };\r\n                    cachedImgObj = {\r\n                        image: image,\r\n                        pending: [this]\r\n                    };\r\n                    image.src = src;\r\n                    globalImageCache.put(src, cachedImgObj);\r\n                    this._image = image;\r\n                    return;\r\n                }\r\n                else {\r\n                    image = cachedImgObj.image;\r\n                    this._image = image;\r\n                    // Image is not complete finish, add to pending list  如果使用的svg图片, IE11下就算加载成功image.width, image.height也都是为0\r\n                    if ((!image.width || !image.height) && (!image.src.endsWith(\"svg\"))) {\r\n                        cachedImgObj.pending.push(this);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (image) {\r\n                // 图片已经加载完成\r\n                // if (image.nodeName.toUpperCase() == 'IMG') {\r\n                //     if (!image.complete) {\r\n                //         return;\r\n                //     }\r\n                // }\r\n                // Else is canvas\r\n\r\n                var x = style.x || 0;\r\n                var y = style.y || 0;\r\n                // 如果使用的svg图片, IE11下就算加载成功image.width, image.height也都是为0\r\n                //此处如不注释, 会导致IE11下svg图片无法使用\r\n                // 图片加载失败\r\n                // if (!image.width || !image.height) {\r\n                //     return;\r\n                // }\r\n                if (!image.isLoaded) {\r\n                    if (window.jQuery) {\r\n                        this.resultDeferrd.reject(image);\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                var width = style.width;\r\n                var height = style.height;\r\n                var aspect = image.width / image.height;\r\n                if (width == null && height != null) {\r\n                    // Keep image/height ratio\r\n                    width = height * aspect;\r\n                }\r\n                else if (height == null && width != null) {\r\n                    height = width / aspect;\r\n                }\r\n                else if (width == null && height == null) {\r\n                    width = image.width;\r\n                    height = image.height;\r\n                }\r\n\r\n                // 设置transform\r\n                this.setTransform(ctx);\r\n\r\n                if (style.sWidth && style.sHeight) {\r\n                    var sx = style.sx || 0;\r\n                    var sy = style.sy || 0;\r\n                    ctx.drawImage(\r\n                        image,\r\n                        sx, sy, style.sWidth, style.sHeight,\r\n                        x, y, width, height\r\n                    );\r\n                }\r\n                else if (style.sx && style.sy) {\r\n                    var sx2 = style.sx;\r\n                    var sy2 = style.sy;\r\n                    var sWidth = width - sx2;\r\n                    var sHeight = height - sy2;\r\n                    ctx.drawImage(\r\n                        image,\r\n                        sx2, sy2, sWidth, sHeight,\r\n                        x, y, width, height\r\n                    );\r\n                }\r\n                else {\r\n                    ctx.drawImage(image, x, y, width, height);\r\n                }\r\n                // 如果没设置宽和高的话自动根据图片宽高设置\r\n                if (style.width == null) {\r\n                    style.width = width;\r\n                }\r\n                if (style.height == null) {\r\n                    style.height = height;\r\n                }\r\n\r\n                this.restoreTransform(ctx);\r\n\r\n                // Draw rect text\r\n                if (style.text != null) {\r\n                    this.drawRectText(ctx, this.getBoundingRect());\r\n                }\r\n                if (window.jQuery) {\r\n                    this.resultDeferrd.resolve(image);\r\n                }\r\n            }\r\n        },\r\n\r\n        getBoundingRect: function () {\r\n            var style = this.style;\r\n            if (! this._rect) {\r\n                this._rect = new BoundingRect(\r\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\r\n                );\r\n            }\r\n            return this._rect;\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(ZImage, Displayable);\r\n\r\n    module.exports = ZImage;\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Image.js\n// module id = 99\n// module chunks = 0","/**\r\n * 文本<br>\r\n * @class fishTopoFlow.node.Text\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n *       var text = new node.Text({\r\n *           style:{text:\"文本也可以作为独立的节点进行拖拽\",fill:\"#ff0000\", textFont:\"16px Microsoft YaHei\"},\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(text);\r\n */\r\n\r\n    var Text = require('zrender/lib/graphic/Text');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var flowNode = require('./flowNode');\r\n    function ZText(opts) {\r\n        var defaultOptions = {\r\n            style:{textBaseline:\"top\"}   // 默认值  这样选中时的框才正确\r\n        };\r\n        var options = zrUtil.merge(defaultOptions, opts, true);\r\n        this.model = flowNode.genModel(\"Text\", opts);\r\n        Text.call(this, options);\r\n    }\r\n    zrUtil.inherits(ZText, Text);\r\n    module.exports = ZText;\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Text.js\n// module id = 100\n// module chunks = 0","/**\r\n * 扇形<br>\r\n * @class fishTopoFlow.node.Sector\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n *       var sector = new node.Sector({\r\n *           shape: {r:30, startAngle:0, endAngle:Math.PI * 0.5}, // startAngle\\endAngle是弧度单位\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(sector);\r\n */\r\n\r\n    var env = require('zrender/lib/core/env');\r\n    var Path = require('zrender/lib/graphic/Path');\r\n\r\n    var shadowTemp = [\r\n        ['shadowBlur', 0],\r\n        ['shadowColor', '#000'],\r\n        ['shadowOffsetX', 0],\r\n        ['shadowOffsetY', 0]\r\n    ];\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Sector',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.r=0 外半径。\r\n         * @cfg {Number} shape.r0=0 内半径。\r\n         * @cfg {Number} shape.startAngle=0 开始弧度。\r\n         * @cfg {Number} shape.endAngle=Math.PI * 2  结束弧度。\r\n         * @cfg {Boolean} shape.clockwise=true 是否顺时针。\r\n         */\r\n        shape: {\r\n            cx: 0,\r\n\r\n            cy: 0,\r\n\r\n            r0: 0,\r\n\r\n            r: 0,\r\n\r\n            startAngle: 0,\r\n\r\n            endAngle: Math.PI * 2,\r\n\r\n            clockwise: true\r\n        },\r\n\r\n        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\r\n            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\r\n            // where exception \"unexpected call to method or property access\"\r\n            // might be thrown when calling ctx.fill after a path whose area size\r\n            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\r\n            // (e.g.,\r\n            //  ctx.moveTo(10, 10);\r\n            //  ctx.lineTo(20, 10);\r\n            //  ctx.closePath();\r\n            //  ctx.clip();\r\n            //  ctx.shadowBlur = 10;\r\n            //  ...\r\n            //  ctx.fill();\r\n            // )\r\n            ? function () {\r\n                var clipPaths = this.__clipPaths;\r\n                var style = this.style;\r\n                var modified;\r\n\r\n                if (clipPaths) {\r\n                    for (var i = 0; i < clipPaths.length; i++) {\r\n                        var shape = clipPaths[i] && clipPaths[i].shape;\r\n                        if (shape && shape.startAngle === shape.endAngle) {\r\n                            for (var j = 0; j < shadowTemp.length; j++) {\r\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\r\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\r\n                            }\r\n                            modified = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                Path.prototype.brush.apply(this, arguments);\r\n\r\n                if (modified) {\r\n                    for (var k = 0; k < shadowTemp.length; k++) {\r\n                        style[shadowTemp[k][0]] = shadowTemp[k][2];\r\n                    }\r\n                }\r\n            }\r\n            : Path.prototype.brush,\r\n\r\n        buildPath: function (ctx, shape) {\r\n\r\n            var x = shape.cx;\r\n            var y = shape.cy;\r\n            var r0 = Math.max(shape.r0 || 0, 0);\r\n            var r = Math.max(shape.r, 0);\r\n            var startAngle = shape.startAngle;\r\n            var endAngle = shape.endAngle;\r\n            var clockwise = shape.clockwise;\r\n\r\n            var unitX = Math.cos(startAngle);\r\n            var unitY = Math.sin(startAngle);\r\n\r\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\r\n\r\n            ctx.lineTo(unitX * r + x, unitY * r + y);\r\n\r\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\r\n\r\n            ctx.lineTo(\r\n                Math.cos(endAngle) * r0 + x,\r\n                Math.sin(endAngle) * r0 + y\r\n            );\r\n\r\n            if (r0 !== 0) {\r\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\r\n            }\r\n\r\n            ctx.closePath();\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Sector.js\n// module id = 101\n// module chunks = 0","/**\r\n * 环形<br>\r\n * @class fishTopoFlow.node.Ring\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n *       var ring = new node.Ring({\r\n *           shape: {r:30,  r0:10},  // r0 内半径\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(ring);\r\n */\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n         type: 'Ring',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.r=0 外半径。\r\n         * @cfg {Number} shape.r0=0 内半径。\r\n         */\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            r: 0,\r\n            r0: 0\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var x = shape.cx;\r\n            var y = shape.cy;\r\n            var PI2 = Math.PI * 2;\r\n            ctx.moveTo(x + shape.r, y);\r\n            ctx.arc(x, y, shape.r, 0, PI2, false);\r\n            ctx.moveTo(x + shape.r0, y);\r\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Ring.js\n// module id = 102\n// module chunks = 0","'use strict';\n/**\r\n * 椭圆<br>\r\n * @class fishTopoFlow.node.Droplet\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var ellipse = new node.Ellipse({\r\n *           shape: {rx:70,  ry:30},  // rx:椭圆横半轴长 ry:椭圆纵半轴长\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(ellipse);\r\n */\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Ellipse',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.rx=0 椭圆横半轴长\r\n         * @cfg {Number} shape.ry=0 椭圆纵半轴长\r\n         */\r\n        shape: {\r\n            rx: 0, ry: 0\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var k = 0.5522848;\r\n            var x = 0;\r\n            var y = 0;\r\n            var a = shape.rx;\r\n            var b = shape.ry;\r\n            var ox = a * k; // 水平控制点偏移量\r\n            var oy = b * k; // 垂直控制点偏移量\r\n            // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线\r\n            ctx.moveTo(x - a, y);\r\n            ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);\r\n            ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);\r\n            ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);\r\n            ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);\r\n            ctx.closePath();\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Ellipse.js\n// module id = 103\n// module chunks = 0","/**\r\n * 心形<br>\r\n * @class fishTopoFlow.node.Heart\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var heart  = new node.Heart({\r\n *           shape: {width:40,  height:50},\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(heart );\r\n */\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Heart',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.cx=0 中心在父节点坐标系（以父节点左上角为原点）中的横坐标值。\r\n         * @cfg {Number} shape.cy=0 中心在父节点坐标系（以父节点左上角为原点）中的纵坐标值。\r\n         * @cfg {Number} shape.width=0 宽度。\r\n         * @cfg {Number} shape.height=0 高度。\r\n         */\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var x = shape.cx;\r\n            var y = shape.cy;\r\n            var a = shape.width;\r\n            var b = shape.height;\r\n            ctx.moveTo(x, y);\r\n            ctx.bezierCurveTo(\r\n                x + a / 2, y - b * 2 / 3,\r\n                x + a * 2, y + b / 3,\r\n                x, y + b\r\n            );\r\n            ctx.bezierCurveTo(\r\n                x - a *  2, y + b / 3,\r\n                x - a / 2, y - b * 2 / 3,\r\n                x, y\r\n            );\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Heart.js\n// module id = 104\n// module chunks = 0","'use strict';\n/**\r\n * 水滴形<br>\r\n * @class fishTopoFlow.node.Droplet\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var droplet = new node.Droplet({\r\n *           shape: {width:10,  height:30},\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(droplet);\r\n */\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Droplet',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.width=0 宽度。\r\n         * @cfg {Number} shape.height=0 高度。\r\n         */\r\n        shape: {\r\n            cx: 0, cy: 0,\r\n            width: 0, height: 0\r\n        },\r\n\r\n        buildPath : function (ctx, shape) {\r\n            var x = shape.cx;\r\n            var y = shape.cy;\r\n            var a = shape.width;\r\n            var b = shape.height;\r\n\r\n            ctx.moveTo(x, y + a);\r\n            ctx.bezierCurveTo(\r\n                x + a,\r\n                y + a,\r\n                x + a * 3 / 2,\r\n                y - a / 3,\r\n                x,\r\n                y - b\r\n            );\r\n            ctx.bezierCurveTo(\r\n                x - a * 3 / 2,\r\n                y - a / 3,\r\n                x - a,\r\n                y + a,\r\n                x,\r\n                y + a\r\n            );\r\n            ctx.closePath();\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Droplet.js\n// module id = 105\n// module chunks = 0","/**\r\n * 玫瑰形<br>\r\n * @class fishTopoFlow.node.Rose\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n *       var rose = new node.Rose({\r\n *           shape: {r:[35], k:7, n:4},\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(rose);\r\n */\r\n\r\n    var sin = Math.sin;\r\n    var cos = Math.cos;\r\n    var radian = Math.PI / 180;\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Rose',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Array} shape.r=[]\r\n         * @cfg {Number} shape.k=0\r\n         * @cfg {Number} shape.n=1\r\n         */\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            r: [],\r\n            k: 0,\r\n            n: 1\r\n        },\r\n\r\n        style: {\r\n            stroke: '#000',\r\n            fill: null,\r\n            lineWidth: 2\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var x;\r\n            var y;\r\n            var R = shape.r;\r\n            var r;\r\n            var k = shape.k;\r\n            var n = shape.n;\r\n\r\n            var x0 = shape.cx;\r\n            var y0 = shape.cy;\r\n\r\n            ctx.moveTo(x0, y0);\r\n\r\n            for (var i = 0, len = R.length; i < len ; i++) {\r\n                r = R[i];\r\n\r\n                for (var j = 0; j <= 360 * n; j++) {\r\n                    x = r\r\n                         * sin(k / n * j % 360 * radian)\r\n                         * cos(j * radian)\r\n                         + x0;\r\n                    y = r\r\n                         * sin(k / n * j % 360 * radian)\r\n                         * sin(j * radian)\r\n                         + y0;\r\n                    ctx.lineTo(x, y);\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Rose.js\n// module id = 106\n// module chunks = 0","/**\r\n * 正多边形<br>\r\n * @class fishTopoFlow.node.Isogon\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var isogon = new node.Isogon({\r\n *           shape: {r:40,  n:9},  // r半径 n几个边\r\n *           position:[60,50]\r\n *       });\r\n *       fishTopo.add(isogon);\r\n */\r\n\r\n    var PI = Math.PI;\r\n    var sin = Math.sin;\r\n    var cos = Math.cos;\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Isogon',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.r=0 半径\r\n         * @cfg {Number} shape.n=0 几个边\r\n         */\r\n       shape: {\r\n            x: 0, y: 0,\r\n            r: 0, n: 0\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var n = shape.n;\r\n            if (!n || n < 2) {\r\n                return;\r\n            }\r\n\r\n            var x = shape.x;\r\n            var y = shape.y;\r\n            var r = shape.r;\r\n\r\n            var dStep = 2 * PI / n;\r\n            var deg = -PI / 2;\r\n\r\n            ctx.moveTo(x + r * cos(deg), y + r * sin(deg));\r\n            for (var i = 0, end = n - 1; i < end; i++) {\r\n                deg += dStep;\r\n                ctx.lineTo(x + r * cos(deg), y + r * sin(deg));\r\n            }\r\n\r\n            ctx.closePath();\r\n\r\n            return;\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Isogon.js\n// module id = 107\n// module chunks = 0","/**\r\n * 多边形<br>\r\n * @class fishTopoFlow.node.Polygon\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var polygon = new node.Polygon({\r\n *           shape: {points:[[85.275,0], [100,25.41], [85.275,50.821], [14.138,50.821], [0,25.41], [14.138,0]]},  // r半径 n几个边\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(polygon);\r\n */\r\n\r\n    var polyHelper = require('zrender/lib/graphic/helper/poly');\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n       type: 'Polygon',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Array} shape.points=null 多边形点的坐标 可以从AI中获取。\r\n         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑\r\n         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效\r\n         */\r\n        shape: {\r\n            points: null,\r\n\r\n            smooth: false,\r\n\r\n            smoothConstraint: null\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            polyHelper.buildPath(ctx, shape, true);\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Polygon.js\n// module id = 108\n// module chunks = 0","/**\r\n * 直线<br>\r\n * @class fishTopoFlow.node.Line\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var line = new node.Line({\r\n *           shape: {x1:60,  y1:60, x2:100, y2:100},  // x 起点 y终点\r\n *           style: {lineWidth:3}\r\n *       });\r\n *       fishTopo.add(line);\r\n */\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Line',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.x1=0 起始点的横坐标值。\r\n         * @cfg {Number} shape.y1=0 起始点的纵坐标值。\r\n         * @cfg {Number} shape.x2=0 终止点的横坐标值。\r\n         * @cfg {Number} shape.y2=0 终止点的纵坐标值。\r\n         */\r\n        shape: {\r\n            // Start point\r\n            x1: 0,\r\n            y1: 0,\r\n            // End point\r\n            x2: 0,\r\n            y2: 0,\r\n\r\n            percent: 1\r\n        },\r\n\r\n        style: {\r\n            stroke: '#000',\r\n            fill: null\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var x1 = shape.x1;\r\n            var y1 = shape.y1;\r\n            var x2 = shape.x2;\r\n            var y2 = shape.y2;\r\n            var percent = shape.percent;\r\n\r\n            if (percent === 0) {\r\n                return;\r\n            }\r\n\r\n            ctx.moveTo(x1, y1);\r\n\r\n            if (percent < 1) {\r\n                x2 = x1 * (1 - percent) + x2 * percent;\r\n                y2 = y1 * (1 - percent) + y2 * percent;\r\n            }\r\n            ctx.lineTo(x2, y2);\r\n        },\r\n\r\n        /**\r\n         * Get point at percent\r\n         * @param  {number} percent\r\n         * @return {Array.<number>}\r\n         */\r\n        pointAt: function (p) {\r\n            var shape = this.shape;\r\n            return [\r\n                shape.x1 * (1 - p) + shape.x2 * p,\r\n                shape.y1 * (1 - p) + shape.y2 * p\r\n            ];\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Line.js\n// module id = 109\n// module chunks = 0","'use strict';\n/**\r\n * 拆线<br>\r\n * @class fishTopoFlow.node.Polyline\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var polyline = new node.Polyline({\r\n *           shape: {points:[[57,138],[95,184],[115,166],[151,184] ]}\r\n *       });\r\n *       fishTopo.add(polyline);\r\n */\r\n\r\n    var polyHelper = require('zrender/lib/graphic/helper/poly');\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Polyline',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Array} shape.points=null 拆线点的坐标 可以从AI中获取。\r\n         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑\r\n         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效\r\n         */\r\n        shape: {\r\n            points: null,\r\n\r\n            smooth: false,\r\n\r\n            smoothConstraint: null\r\n        },\r\n\r\n        style: {\r\n            stroke: '#000',\r\n\r\n            fill: null\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            polyHelper.buildPath(ctx, shape, false);\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Polyline.js\n// module id = 110\n// module chunks = 0","'use strict';\n/**\r\n * 贝塞尔曲线<br>\r\n * @class fishTopoFlow.node.BezierCurve\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var bezierCurve = new node.BezierCurve({\r\n *           shape: {x1:0, y1:100, cpx1:0, cpy1:0, cpx2:0, cpy2:0, x2:100, y2:0},\r\n *           position: [60, 60]\r\n *       });\r\n *       fishTopo.add(bezierCurve);\r\n */\r\n\r\n\r\n    var curveTool = require('zrender/lib/core/curve');\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\r\n    var cubicSubdivide = curveTool.cubicSubdivide;\r\n    var quadraticAt = curveTool.quadraticAt;\r\n    var cubicAt = curveTool.cubicAt;\r\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\r\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\r\n\r\n    var out = [];\r\n\r\n    function someVectorAt(shape, t, isTangent) {\r\n        var cpx2 = shape.cpx2;\r\n        var cpy2 = shape.cpy2;\r\n        if (cpx2 === null || cpy2 === null) {\r\n            return [\r\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\r\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\r\n            ];\r\n        }\r\n        else {\r\n            return [\r\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\r\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\r\n            ];\r\n        }\r\n    }\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'BezierCurve',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.x1=0 起始点的横坐标值。\r\n         * @cfg {Number} shape.y1=0 起始点的纵坐标值。\r\n         * @cfg {Number} shape.x2=0 终止点的横坐标值。\r\n         * @cfg {Number} shape.y2=0 终止点的纵坐标值。\r\n         * @cfg {Number} shape.cpx1=0 控制点的横坐标值。\r\n         * @cfg {Boolean} shape.cpx2=0 控制点的纵坐标值。\r\n         */\r\n        shape: {\r\n            x1: 0,\r\n            y1: 0,\r\n            x2: 0,\r\n            y2: 0,\r\n            cpx1: 0,\r\n            cpy1: 0,\r\n\r\n            // Curve show percent, for animating\r\n            percent: 1\r\n        },\r\n\r\n        style: {\r\n            stroke: '#000',\r\n            fill: null\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var x1 = shape.x1;\r\n            var y1 = shape.y1;\r\n            var x2 = shape.x2;\r\n            var y2 = shape.y2;\r\n            var cpx1 = shape.cpx1;\r\n            var cpy1 = shape.cpy1;\r\n            var cpx2 = shape.cpx2;\r\n            var cpy2 = shape.cpy2;\r\n            var percent = shape.percent;\r\n            if (percent === 0) {\r\n                return;\r\n            }\r\n\r\n            ctx.moveTo(x1, y1);\r\n\r\n            if (cpx2 == null || cpy2 == null) {\r\n                if (percent < 1) {\r\n                    quadraticSubdivide(\r\n                        x1, cpx1, x2, percent, out\r\n                    );\r\n                    cpx1 = out[1];\r\n                    x2 = out[2];\r\n                    quadraticSubdivide(\r\n                        y1, cpy1, y2, percent, out\r\n                    );\r\n                    cpy1 = out[1];\r\n                    y2 = out[2];\r\n                }\r\n\r\n                ctx.quadraticCurveTo(\r\n                    cpx1, cpy1,\r\n                    x2, y2\r\n                );\r\n            }\r\n            else {\r\n                if (percent < 1) {\r\n                    cubicSubdivide(\r\n                        x1, cpx1, cpx2, x2, percent, out\r\n                    );\r\n                    cpx1 = out[1];\r\n                    cpx2 = out[2];\r\n                    x2 = out[3];\r\n                    cubicSubdivide(\r\n                        y1, cpy1, cpy2, y2, percent, out\r\n                    );\r\n                    cpy1 = out[1];\r\n                    cpy2 = out[2];\r\n                    y2 = out[3];\r\n                }\r\n                ctx.bezierCurveTo(\r\n                    cpx1, cpy1,\r\n                    cpx2, cpy2,\r\n                    x2, y2\r\n                );\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Get point at percent\r\n         * @param  {number} t\r\n         * @return {Array.<number>}\r\n         */\r\n        pointAt: function (t) {\r\n            return someVectorAt(this.shape, t, false);\r\n        },\r\n\r\n        /**\r\n         * Get tangent at percent\r\n         * @param  {number} t\r\n         * @return {Array.<number>}\r\n         */\r\n        tangentAt: function (t) {\r\n            var p = someVectorAt(this.shape, t, true);\r\n            return vec2.normalize(p, p);\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/BezierCurve.js\n// module id = 111\n// module chunks = 0","'use strict';\n/**\r\n * 圆弧<br>\r\n * @class fishTopoFlow.node.Arc\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var arc = new node.Arc({\r\n *           shape: {r:50, startAngle:0, endAngle:1.2*Math.PI},\r\n *           position: [60, 60]\r\n *       });\r\n *       fishTopo.add(arc);\r\n */\r\n\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Arc',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.r=0 半径。\r\n         * @cfg {Number} shape.startAngle=0 开始弧度。\r\n         * @cfg {Number} shape.endAngle=Math.PI * 2  结束弧度。\r\n         * @cfg {Boolean} shape.clockwise=true 是否顺时针。\r\n         */\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            r: 0,\r\n            startAngle: 0,\r\n            endAngle: Math.PI * 2,\r\n            clockwise: true\r\n        },\r\n\r\n        style: {\r\n\r\n            stroke: '#000',\r\n\r\n            fill: null\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n\r\n            var x = shape.cx;\r\n            var y = shape.cy;\r\n            var r = Math.max(shape.r, 0);\r\n            var startAngle = shape.startAngle;\r\n            var endAngle = shape.endAngle;\r\n            var clockwise = shape.clockwise;\r\n\r\n            var unitX = Math.cos(startAngle);\r\n            var unitY = Math.sin(startAngle);\r\n\r\n            ctx.moveTo(unitX * r + x, unitY * r + y);\r\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Arc.js\n// module id = 112\n// module chunks = 0","'use strict';\n/**\r\n * 星形<br>\r\n * @class fishTopoFlow.node.Star\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n *       var star = new node.Star({\r\n *           shape: {n:7, r:30},  //r半径 n几个角\r\n *           position:[60,60]\r\n *       });\r\n *       fishTopo.add(star);\r\n */\r\n\r\n    var PI = Math.PI;\r\n\r\n    var cos = Math.cos;\r\n    var sin = Math.sin;\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Star',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.n=3 几个角。\r\n         * @cfg {Number} shape.r=0 外半径。\r\n         * @cfg {Number} shape.r0=0 内半径。\r\n         */\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            n: 3,\r\n            r0: null,\r\n            r: 0\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n\r\n            var n = shape.n;\r\n            if (!n || n < 2) {\r\n                return;\r\n            }\r\n\r\n            var x = shape.cx;\r\n            var y = shape.cy;\r\n            var r = shape.r;\r\n            var r0 = shape.r0;\r\n\r\n            // 如果未指定内部顶点外接圆半径，则自动计算\r\n            if (r0 == null) {\r\n                r0 = n > 4\r\n                    // 相隔的外部顶点的连线的交点，\r\n                    // 被取为内部交点，以此计算r0\r\n                    ? r * cos(2 * PI / n) / cos(PI / n)\r\n                    // 二三四角星的特殊处理\r\n                    : r / 3;\r\n            }\r\n\r\n            var dStep = PI / n;\r\n            var deg = -PI / 2;\r\n            var xStart = x + r * cos(deg);\r\n            var yStart = y + r * sin(deg);\r\n            deg += dStep;\r\n\r\n            // 记录边界点，用于判断inside\r\n            ctx.moveTo(xStart, yStart);\r\n            for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {\r\n                ri = i % 2 === 0 ? r0 : r;\r\n                ctx.lineTo(x + ri * cos(deg), y + ri * sin(deg));\r\n                deg += dStep;\r\n            }\r\n\r\n            ctx.closePath();\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Star.js\n// module id = 113\n// module chunks = 0","'use strict';\n/**\r\n * 旋轮曲线<br>\r\n * @class fishTopoFlow.node.Trochoid\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n *       var trochoid = new node.Trochoid({\r\n *           shape: {r:50, r0:35, d:30, location:null},  //r半径 n几个角\r\n *           position:[60,60],\r\n *           tooltip: \"旋轮曲线\"\r\n *       });\r\n *       fishTopo.add(trochoid);\r\n */\r\n\r\n\r\n    var cos = Math.cos;\r\n    var sin = Math.sin;\r\n    module.exports = require('./flowNode').extend({\r\n\r\n        type: 'Trochoid',\r\n        /**\r\n         * @cfg {Object} shape 形状参数\r\n         * @cfg {Number} shape.r=0 外半径。\r\n         * @cfg {Number} shape.r0=0 内半径。\r\n         * @cfg {Number} shape.d=0\r\n         * @cfg {Number} shape.location='out'\r\n         */\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            r: 0,\r\n            r0: 0,\r\n            d: 0,\r\n            location: 'out'\r\n        },\r\n\r\n        style: {\r\n            stroke: '#000',\r\n\r\n            fill: null\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var x1;\r\n            var y1;\r\n            var x2;\r\n            var y2;\r\n            var R = shape.r;\r\n            var r = shape.r0;\r\n            var d = shape.d;\r\n            var offsetX = shape.cx;\r\n            var offsetY = shape.cy;\r\n            var delta = shape.location == 'out' ? 1 : -1;\r\n\r\n            if (shape.location && R <= r) {\r\n                return;\r\n            }\r\n\r\n            var num = 0;\r\n            var i = 1;\r\n            var theta;\r\n\r\n            x1 = (R + delta * r) * cos(0)\r\n                - delta * d * cos(0) + offsetX;\r\n            y1 = (R + delta * r) * sin(0)\r\n                - d * sin(0) + offsetY;\r\n\r\n            ctx.moveTo(x1, y1);\r\n\r\n            // 计算结束时的i\r\n            do {\r\n                num++;\r\n            }\r\n            while ((r * num) % (R + delta * r) !== 0);\r\n\r\n            do {\r\n                theta = Math.PI / 180 * i;\r\n                x2 = (R + delta * r) * cos(theta)\r\n                     - delta * d * cos((R / r +  delta) * theta)\r\n                     + offsetX;\r\n                y2 = (R + delta * r) * sin(theta)\r\n                     - d * sin((R / r + delta) * theta)\r\n                     + offsetY;\r\n                ctx.lineTo(x2, y2);\r\n                i++;\r\n            }\r\n            while (i <= (r * num) / (R + delta * r) * 360);\r\n\r\n        }\r\n    });\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Trochoid.js\n// module id = 114\n// module chunks = 0","/**\r\n * 路径<br>\r\n * @class fishTopoFlow.node.Path\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var path = new node.Path({\r\n *           pathData: 'M9 0l8 8-17 17 7 7 17-17 8 8v-23h-23z',\r\n *           rect: {x:0,y:0,width:30,height:30},\r\n *           position: [60,60]\r\n *       });\r\n *       fishTopo.add(path);\r\n */\r\n\r\n    var pathTool = require('zrender/lib/tool/path');\r\n    var Draggable = require('zrender/lib/mixin/Draggable');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var flowNode = require('./flowNode');\r\n\r\n    function ZPath(opts) {\r\n        /**\r\n         * @cfg {Object} options 参数\r\n         * @cfg {String} options.pathData path数据。\r\n         * @cfg {Object} options.rect 图形的大小。\r\n         * @cfg {Object} options.rect.width 图形的宽度。\r\n         * @cfg {Object} options.rect.height 图形的高度。\r\n         * @cfg {Number} [options.layout=null] 默认为null  仅支持\"center\"\r\n         *\r\n         */\r\n        var defaultOptions = {\r\n            style:{ fill: 'none',stroke: '#2c2c2c'},\r\n            rect:{x:0,y:0,width:0,height:0},\r\n            rectHover: true\r\n        }\r\n\r\n        var pathData = opts.pathData;\r\n        var model = flowNode.genModel(\"Path\", opts);\r\n        delete opts.pathData;\r\n        this.options = zrUtil.merge(defaultOptions, opts, true);\r\n        var path = pathTool.createFromString(pathData, this.options);\r\n        path.model = model;\r\n        Draggable.call(path);\r\n        var boundingRect = path.getBoundingRect();\r\n        var rect = this.options.rect;\r\n        var layout = opts.layout;\r\n        if (rect) {\r\n            var aspect = boundingRect.width / boundingRect.height;\r\n\r\n            if (layout === 'center') {\r\n                // Set rect to center, keep width / height ratio.\r\n                var width = rect.height * aspect;\r\n                var height;\r\n                if (width <= rect.width) {\r\n                    height = rect.height;\r\n                }\r\n                else {\r\n                    width = rect.width;\r\n                    height = width / aspect;\r\n                }\r\n                var cx = rect.x + rect.width / 2;\r\n                var cy = rect.y + rect.height / 2;\r\n\r\n                rect.x = cx - width / 2;\r\n                rect.y = cy - height / 2;\r\n                rect.width = width;\r\n                rect.height = height;\r\n            }\r\n\r\n            this.resizePath(path, rect);\r\n        }\r\n\r\n        return path;\r\n    }\r\n\r\n    ZPath.prototype = {\r\n\r\n        constructor: ZPath,\r\n\r\n        type: 'Path',\r\n        /**\r\n         * Resize a path to fit the rect\r\n         */\r\n        resizePath: function (path, rect) {\r\n                if (!path.applyTransform) {\r\n                    return;\r\n                }\r\n\r\n                var pathRect = path.getBoundingRect();\r\n\r\n                var m = pathRect.calculateTransform(rect);\r\n\r\n                path.applyTransform(m);\r\n        }\r\n    }\r\n    zrUtil.inherits(ZPath, Draggable);\r\n    module.exports = ZPath;\r\n\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/Path.js\n// module id = 115\n// module chunks = 0","/**\r\n * 图形按钮<br>\r\n * @class fishTopoFlow.node.IconButton\r\n * @extends fishTopoFlow.node\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       var iconButton   = new node.IconButton({\r\n *          title:'IconButton',\r\n *          icon:'path://M432.45,595.444c0,2.177-4.661,6.82-11.305,6.82c-6.475,0-11.306-4.567-11.306-6.82s4.852-6.812,11.306-6.812C427.841,588.632,432.452,593.191,432.45,595.444L432.45,595.444z M421.155,589.876c-3.009,0-5.448,2.495-5.448,5.572s2.439,5.572,5.448,5.572c3.01,0,5.449-2.495,5.449-5.572C426.604,592.371,424.165,589.876,421.155,589.876L421.155,589.876z M421.146,591.891c-1.916,0-3.47,1.589-3.47,3.549c0,1.959,1.554,3.548,3.47,3.548s3.469-1.589,3.469-3.548C424.614,593.479,423.062,591.891,421.146,591.891L421.146,591.891zM421.146,591.891',\r\n *          itemSize:50,\r\n *          position:[60,60]\r\n *       });\r\n *       fishTopo.add(iconButton);\r\n */\r\n\r\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var flowNode = require('./flowNode');\r\n\r\n    function IconButton(opts) {\r\n\r\n        /**\r\n         * @cfg {Object} options 构造参数\r\n         * @cfg {String} options.title=\"\" 鼠标移上去显示的文字\r\n         * @cfg {String} options.icon=\"\" Icon 的 path 字符串，支持使用自定义的 svg path 作为 icon，格式参见 [SVG PathData](https://www.w3.org/TR/SVG/paths.html#PathData)。可以从 Adobe Illustrator 等工具编辑导出。\r\n         * @cfg {Number} options.itemSize=15  icon 的大小\r\n         * @cfg {Object} options.iconStyle  图标样式\r\n         * @cfg {Object} options.iconStyle.normal 正常的样式\r\n         * @cfg {Number} options.iconStyle.normal.stroke='#666' 正常的样式（描边色）\r\n         * @cfg {Number} options.iconStyle.normal.fill='none' 正常的样式（填充色）\r\n         * @cfg {Object} options.iconStyle.emphasis 高亮状态下的样式\r\n         * @cfg {Number} options.iconStyle.emphasis.stroke='#666' 高亮状态下的样式（描边色）\r\n         * @cfg {Number} options.iconStyle.emphasis.fill='none' 高亮状态下的样式（填充色）\r\n         */\r\n        var defaultOptions = {\r\n            backgroundColor: 'transparent',\r\n            borderColor: '#ccc',\r\n            draggable:false,\r\n            selectable:false,\r\n            borderWidth: 0,\r\n            itemSize: 15,\r\n            showTitle: true,\r\n            icon:\"\",  //Icon 的 path 字符串，支持使用自定义的 svg path 作为 icon，格式参见 SVG PathData。可以从 Adobe Illustrator 等工具编辑导出。\r\n            iconStyle: {\r\n                normal: {\r\n                    stroke: '#666',\r\n                    fill: 'none'\r\n                },\r\n                emphasis: {\r\n                    stroke: '#3E98c5'\r\n                }\r\n            }\r\n        };\r\n        this.options = zrUtil.merge(defaultOptions, opts, true);\r\n\r\n        this.model = flowNode.genModel(\"IconButton\", this.options);\r\n        graphic.Group.call(this, this.options);\r\n        this.render();\r\n    }\r\n    IconButton.prototype = {\r\n        constructor: IconButton,\r\n        type: \"IconButton\",\r\n        render: function () {\r\n            var normalStyle = this.options.iconStyle.normal;\r\n            var hoverStyle = this.options.iconStyle.emphasis;\r\n            var itemSize = this.options.itemSize;\r\n            var icon = this.options.icon;\r\n            var style = {\r\n                x: -itemSize / 2,\r\n                y: -itemSize / 2,\r\n                width: itemSize,\r\n                height: itemSize\r\n            };\r\n            var path = icon.indexOf('image://') === 0 ?\r\n                (\r\n                    style.image = icon.slice(8),\r\n                    new graphic.Image({\r\n                        style: style\r\n                    })\r\n                ) :\r\n                graphic.makePath(\r\n                    icon.replace('path://', ''), {\r\n                        style: normalStyle,\r\n                        hoverStyle: hoverStyle,\r\n                        rectHover: true\r\n                    },\r\n                    style,\r\n                    'center'\r\n                );\r\n\r\n            graphic.setHoverStyle(path);\r\n\r\n            if (this.options.showTitle) {\r\n                path.__title = this.options.title;\r\n                path.on('mouseover', function () {\r\n                        // Should not reuse above hoverStyle, which might be modified.\r\n                        path.setStyle({\r\n                            text: this.options.title,\r\n                            textPosition: hoverStyle.textPosition || 'bottom',\r\n                            textFill: hoverStyle.fill || hoverStyle.stroke || '#000',\r\n                            textAlign: hoverStyle.textAlign || 'center'\r\n                        });\r\n                    }.bind(this))\r\n                    .on('mouseout', function () {\r\n                        path.setStyle({\r\n                            textFill: null\r\n                        });\r\n                    });\r\n            }\r\n\r\n            path.trigger('normal');\r\n            this.add(path);\r\n        }\r\n    }\r\n\r\n    zrUtil.inherits(IconButton, graphic.Group);\r\n    module.exports = IconButton;\r\n\r\n/**\r\n * @method extend\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/node/IconButton.js\n// module id = 116\n// module chunks = 0","'use strict';\n/**\r\n * fishTopoFlow的link对象，框架提供的连线都放在这个对象下。\r\n * @class fishTopoFlow.link\r\n * @abstract\r\n */\r\n\r\n    var Link = require('./Link');\r\n    var Fold = require('./Fold');\r\n    var Curve = require('./Curve');\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var flowLink = {};\r\n    flowLink.Link = flowLink[Connector.TYPE_STRAIGHT] = Link;\r\n    flowLink.Fold = flowLink[Connector.TYPE_JAGGED] = Fold;\r\n    flowLink.Curve = flowLink[Connector.TYPE_CURVE] = Curve;\r\n    module.exports = flowLink;\r\n\r\n\r\n/**\r\n * @method constructor\r\n * 连线的构造函数\r\n * @param  {Object} startNode 开始节点\r\n * @param  {Object} endNode   结束节点\r\n * @param  {Object} options 线段选项\r\n * @param {Object} [options.style] 节点的样式\r\n * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n * @param {Object} [options.symbol] 线段的箭头\r\n * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n * @param {Object} [options.text] 线段上的文字\r\n * @param {String} [options.text.text] 线段上的文字内容\r\n * @param {String} [options.text.color] 线段上的文字颜色\r\n * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n * @param {String} [options.position] 指定线段位置\r\n * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n * @param {Object} [options.effect] 线上动态效果\r\n * @param {String} [options.effect.show] 是否显示箭头动效\r\n * @param {Number} [options.effect.period] 动效移动速度\r\n * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n * @return {Object} 返回创建成功的连线对象\r\n */\r\n\r\n\r\n/**\r\n * @method setStyle\r\n * 创建连线后，设置连线的样式\r\n * @param {Object} options 对应创建节点，传递的options参数\r\n */\r\n/**\r\n * @method on\r\n * 绑定事件\r\n * @param {String} event 事件名\r\n * @param {Function} handler 事件处理函数\r\n * @param {Object} [context] 上下文\r\n */\r\n\r\n/**\r\n * @method off\r\n * 解绑事件\r\n * @param {String} event 事件名\r\n * @param {Function} handler 事件处理函数\r\n */\r\n\r\n/**\r\n * @method one\r\n * 单次触发绑定,trigger后销毁\r\n * @param {String} event 事件名\r\n * @param {Function} handler 事件处理函数\r\n * @param {Object} [context] 上下文\r\n */\r\n\r\n/**\r\n * @method trigger\r\n * 事件分发\r\n * @param {String} type 事件类型\r\n */\r\n/**\r\n * @event click\r\n * 单击事件\r\n *\r\n * <pre>\r\n * flink.on('Connector:click', function(e) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\r\n/**\r\n * @event dblclick\r\n * 当双击元素时，会发生 dblclick 事件。\r\n *\r\n * <pre>\r\n * flink.on('Connector:dblclick', function(e) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/link/flowLink.js\n// module id = 117\n// module chunks = 0","/**\r\n * 直线<br>\r\n * @class fishTopoFlow.link.Link\r\n * @extends fishTopoFlow.link\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var link = fishTopoFlow.link;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       //节点\r\n *       function newNode(x, y, w, h) {\r\n *           var rect = new node.Rect({\r\n *               shape: {width: w,height: h},\r\n *               position: [x, y],\r\n *               style: {fill: \"#167CFF\"}\r\n *           });\r\n *           fishTopo.add(rect);\r\n *           return rect;\r\n *       }\r\n *       //简单连线\r\n *       function newLink(startNode, endNode, text, dashedPattern) {\r\n *           var slink = new link.Link(startNode, endNode, {\r\n *               style: {lineDash: [dashedPattern]},\r\n *               text: {text: text}\r\n *           })\r\n *           fishTopo.add(slink);\r\n *           return slink;\r\n *       }\r\n *       var from = newNode(100, 60, 30, 30);\r\n *       var to = newNode(300, 60, 30, 30);\r\n *       newLink(from, to, '虚线带箭头', 5);\r\n */\r\n\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var Flow = require(\"../Flow\");\r\n\r\n    function Link(startNode,endNode,options) {\r\n        var opt = Flow.translateLinkOptions(options);\r\n        //默认就是直线\r\n        var connector = new Connector(opt);\r\n        connector.startNode = startNode;\r\n        connector.endNode = endNode;\r\n\r\n        return connector;\r\n    }\r\n    /**\r\n     * @method createByPoint\r\n     * 用户指定连线的点，来进行画线\r\n     * @param  {Object} options 线段选项\r\n     * @param {Object} [options.style] 节点的样式\r\n     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n     * @param {Object} [options.symbol] 线段的箭头\r\n     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n     * @param {Object} [options.text] 线段上的文字\r\n     * @param {String} [options.text.text] 线段上的文字内容\r\n     * @param {String} [options.text.color] 线段上的文字颜色\r\n     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {String} [options.position] 指定线段位置\r\n     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n     * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n     * @param {Object} [options.effect] 线上动态效果\r\n     * @param {String} [options.effect.show] 是否显示箭头动效\r\n     * @param {Number} [options.effect.period] 动效移动速度\r\n     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n     * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n     */\r\n    Link.createByPoint = function(options) {\r\n        var opt = Flow.translateLinkOptions(options);\r\n        //默认就是直线\r\n        var connector = new Connector(opt);\r\n        return connector;\r\n    }\r\n\r\n    module.exports = Link;\r\n\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/link/Link.js\n// module id = 118\n// module chunks = 0","/**\r\n * Flow静态方法类\r\n * @class fish.topo.FishTopoFlow.Flow\r\n */\r\n\r\n\r\n    var Constants = require(\"./util/FlowConstants.js\");\r\n    var GroupNode = require(\"./node/GroupNode.js\");\r\n    var Flow = {\r\n        FLOW_TYPE: \"elementType\",\r\n        LINK: \"connection\",\r\n        RECT: \"Rect\",\r\n        Group: 'Group',\r\n        IMAGE: 'Image',\r\n        TEXT: 'Text',\r\n        CIRCLE: 'Circle',\r\n        SECTOR: 'Sector',\r\n        RING: 'Ring',\r\n        POLYGON: 'Polygon',\r\n        POLYLINE: 'Polyline',\r\n        LINE: 'Line',\r\n        BEZIERCURVE: 'Beziercurve',\r\n        ARC: 'Arc',\r\n        SCENE:'scene',\r\n\r\n        /**\r\n         * @method setUserData\r\n         * 设置用户数据\r\n         * @param {Object} node 需要设置数据的节点\r\n         * @param {Object} obj 数据\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //设置自定义数据\r\n         *      this.fishTopo.Flow.setUserData(rect, { customObj: \"rect\" });\r\n         */\r\n        setUserData: function(node, obj) {\r\n            node.model.set(Constants.USERDATA, obj);\r\n        },\r\n        /**\r\n         * 获取设置的用户数据\r\n         * @param {Object} node 需要获取数据的节点\r\n         * @return {String}      数据\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //获取自定义数据\r\n         *      this.fishTopo.Flow.getUserData(rect);\r\n         */\r\n        getUserData: function(node) {\r\n            return node.model.get(Constants.USERDATA);\r\n        },\r\n        /**\r\n         * 判断是否是连线\r\n         * @param {Object} model 对象的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是连线\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isLink(nodeModel)) { return true;}\r\n         */\r\n        isLink: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType == Flow.LINK;\r\n        },\r\n        /**\r\n         * 判断是否是节点\r\n         * @param {Object} model 对象的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是节点\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isNode(nodeModel)) { return true;}\r\n         */\r\n\r\n        isNode: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            var isNode;\r\n            if(elementType !=  Flow.LINK && elementType !=  Flow.SCENE){\r\n                isNode = true;\r\n            }else{\r\n                isNode = false;\r\n            }\r\n            return isNode;\r\n        },\r\n\r\n        isInGroup: function(node) {\r\n            return node.parent && node.parent instanceof GroupNode;\r\n        },\r\n\r\n        isGroupNode: function(node) {\r\n            return node instanceof GroupNode;\r\n        },\r\n\r\n        /**\r\n         * 判断节点是否是矩形节点\r\n         * @param {Object} model 节点的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是矩形节点\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isRect(nodeModel)) { return true;}\r\n         */\r\n        isRect: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return  elementType == Flow.RECT;\r\n        },\r\n        /**\r\n         * 判断节点是否是图片节点\r\n         * @param {Object} model 节点的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是图片节点\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isImage(nodeModel)) { return true;}\r\n         */\r\n        isImage: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType == Flow.IMAGE;\r\n        },\r\n        /**\r\n         * 判断节点是否是文字节点\r\n         * @param {Object} model 节点的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是文字节点\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isText(nodeModel)) { return true;}\r\n         */\r\n        isText: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType == Flow.TEXT;\r\n        },\r\n        /**\r\n         * 判断节点是否是圆形节点\r\n         * @param {Object} model 节点的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是圆形节点\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isCircle(nodeModel)) { return true;}\r\n         */\r\n        isCircle: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType == Flow.CIRCLE;\r\n        },\r\n        /**\r\n         * 获取节点的类型\r\n         * @param {Object} model 节点的model\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //获取节点类型\r\n         *      var nodeModel = e.target.model;\r\n         *      return this.fishTopo.Flow.getType(nodeModel);\r\n         */\r\n        getType: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType;\r\n        },\r\n        translateLinkOptions: function(options) {\r\n            if (options && options.pos) {\r\n                var arrPos = options.pos.split(\",\");\r\n                if (arrPos.length >= 2) {\r\n                    if (!options.position) {\r\n                        options.position = {};\r\n                    }\r\n                    options.position.startPos = arrPos[0];\r\n                    options.position.endPos = arrPos[1];\r\n                }\r\n            }\r\n            return options;\r\n        }\r\n    };\r\n\r\n    module.exports = Flow;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/Flow.js\n// module id = 119\n// module chunks = 0","/**\r\n * 折线<br>\r\n * @class fishTopoFlow.link.Fold\r\n * @extends fishTopoFlow.link\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var link = fishTopoFlow.link;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       //节点\r\n *       function newNode(x, y, w, h) {\r\n *           var rect = new node.Rect({\r\n *               shape: {width: w,height: h},\r\n *               position: [x, y],\r\n *               style: {fill: \"#167CFF\"}\r\n *           });\r\n *           fishTopo.add(rect);\r\n *           return rect;\r\n *       }\r\n *       //折线\r\n *       function newFoldLink(startNode, endNode, text, direction, dashedPattern) {\r\n *           var flink = new link.Fold(startNode, endNode, {\r\n *               style: {lineDash: [dashedPattern]},\r\n *               text: {text: text},\r\n *               pos: direction\r\n *           })\r\n *           fishTopo.add(flink);\r\n *           return flink;\r\n *       }\r\n *       var from = newNode(100, 40, 30, 30);\r\n *       var to = newNode(300, 80, 30, 30);\r\n *       newFoldLink(from, to, '折线');\r\n */\r\n\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var Flow = require(\"../Flow\");\r\n\r\n    function Fold(startNode,endNode,options) {\r\n        //折线\r\n        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_JAGGED}}, options, true);\r\n        opt = Flow.translateLinkOptions(opt);\r\n        var connector = new Connector(opt);\r\n        connector.startNode = startNode;\r\n        connector.endNode = endNode;\r\n\r\n        return connector;\r\n    }\r\n\r\n    /**\r\n     * @method createByPoint\r\n     * 用户指定连线的点，来进行画线\r\n     * @param  {Object} options 线段选项\r\n     * @param {Object} [options.style] 节点的样式\r\n     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n     * @param {Object} [options.symbol] 线段的箭头\r\n     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n     * @param {Object} [options.text] 线段上的文字\r\n     * @param {String} [options.text.text] 线段上的文字内容\r\n     * @param {String} [options.text.color] 线段上的文字颜色\r\n     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {String} [options.position] 指定线段位置\r\n     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n     * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n     * @param {Object} [options.effect] 线上动态效果\r\n     * @param {String} [options.effect.show] 是否显示箭头动效\r\n     * @param {Number} [options.effect.period] 动效移动速度\r\n     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n     * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n     */\r\n    Fold.createByPoint = function(options) {\r\n        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_JAGGED}}, options, true);\r\n        opt = Flow.translateLinkOptions(opt);\r\n        var connector = new Connector(opt);\r\n        return connector;\r\n    }\r\n    module.exports = Fold;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/link/Fold.js\n// module id = 120\n// module chunks = 0","/**\r\n * 曲线<br>\r\n * @class fishTopoFlow.link.Curve\r\n * @extends fishTopoFlow.link\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var link = fishTopoFlow.link;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       //节点\r\n *       function newNode(x, y, w, h) {\r\n *           var rect = new node.Rect({\r\n *               shape: {width: w,height: h},\r\n *               position: [x, y],\r\n *               style: {fill: \"#167CFF\"}\r\n *           });\r\n *           fishTopo.add(rect);\r\n *           return rect;\r\n *       }\r\n *       //曲线\r\n *       function newCurveLink(startNode, endNode, text, direction, dashedPattern) {\r\n *           var clink = new link.Curve(startNode, endNode, {\r\n *               style: {lineDash: [dashedPattern]},\r\n *               text: {text: text},\r\n *               pos: direction\r\n *           })\r\n *           fishTopo.add(clink);\r\n *           return clink;\r\n *       }\r\n *       var from = newNode(100, 40, 30, 30);\r\n *       var to = newNode(300, 80, 30, 30);\r\n *       newCurveLink(from, to, '曲线');\r\n */\r\n\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var Flow = require(\"../Flow\");\r\n    function Curve(startNode,endNode,options) {\r\n        //曲线\r\n        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_CURVE}}, options, true);\r\n        opt = Flow.translateLinkOptions(opt);\r\n\r\n        var connector = new Connector(opt);\r\n        connector.startNode = startNode;\r\n        connector.endNode = endNode;\r\n\r\n        return connector;\r\n    }\r\n    /**\r\n     * @method createByPoint\r\n     * 用户指定连线的点，来进行画线\r\n     * @param  {Object} options 线段选项\r\n     * @param {Object} [options.style] 节点的样式\r\n     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n     * @param {Object} [options.symbol] 线段的箭头\r\n     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]\r\n     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]\r\n     * @param {Object} [options.text] 线段上的文字\r\n     * @param {String} [options.text.text] 线段上的文字内容\r\n     * @param {String} [options.text.color] 线段上的文字颜色\r\n     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]\r\n     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {String} [options.position] 指定线段位置\r\n     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {Object} [options.position.startOffset] 线段开始位置的偏移\r\n     * @param {Object} [options.position.endOffset] 线段结束位置的偏移\r\n     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]\r\n     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom\r\n     * @param {Object} [options.effect] 线上动态效果\r\n     * @param {String} [options.effect.show] 是否显示箭头动效\r\n     * @param {Number} [options.effect.period] 动效移动速度\r\n     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n     * @param {Number} [options.z] 连线的层级，越大越在前面显示\r\n     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)\r\n     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)\r\n     */\r\n    Curve.createByPoint = function(options) {\r\n        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_CURVE}}, options, true);\r\n        opt = Flow.translateLinkOptions(opt);\r\n        var connector = new Connector(opt);\r\n        return connector;\r\n    }\r\n    module.exports = Curve;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/link/Curve.js\n// module id = 121\n// module chunks = 0","/**\r\n * 连线操作类\r\n * @author miao.cunzhi\r\n */\r\n\r\n    var symbolUtil = require('../shapes/Symbol');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var icon = require('./IconOperation');\r\n    function LineOperationManager(connectionManager, api) {\r\n        this.lineOperations = [],\r\n        this.isEdit = true;\r\n        this.connectionManager = connectionManager;\r\n        this._api = api;\r\n    }\r\n\r\n    /**\r\n     *  this.lineOperationManager.addIcon(key, options);\r\n     */\r\n    LineOperationManager.prototype.addIcon = function(key, options) {\r\n        //判断是小图标否存在 ，存在则直接返回\r\n        var lineOperationIcon = zrUtil.find(options.lineNode.icons, function(icon) {\r\n            return icon.key === key;\r\n        });\r\n\r\n        if (lineOperationIcon) {\r\n            this.bindOperation(options.lineNode);\r\n            return;\r\n        }else {\r\n            var lineOperation = this.creatOperation(key, options);\r\n            this._api._getParentZr().add(lineOperation);\r\n            this.bindOperation(options.lineNode);\r\n            return lineOperation;\r\n        }\r\n    }\r\n\r\n\r\n    LineOperationManager.prototype.creatOperation = function(key, options) {\r\n        var lineOperation = symbolUtil.createSymbol(options.iconPath, 0, 0, options.width || 15, options.height || 15, 0, options.color||'#000');\r\n        lineOperation.key = key;\r\n        lineOperation._width =  options.width || 15;  // path情况下无法计算\r\n        lineOperation._isLineOperationIcon = true;\r\n        lineOperation.hide();\r\n        options.lineNode.icons.push(lineOperation);\r\n        this.lineOperations.push(lineOperation);\r\n\r\n        //小图标 点击事件  如果有回调则调用回调，否则派发事件\r\n        lineOperation.on(\"click\", function(event) {\r\n            if (options.callback) {\r\n                event.data = options;\r\n                event.lineNode = options.lineNode;\r\n                options.callback(event);\r\n            } else {\r\n                var params = {};\r\n                params.event = event;\r\n                params.type = \"click\";\r\n                params.elementType = \"LineOperationIcon\";\r\n                this._api.trigger(params.type, params);\r\n            }\r\n        }.bind(this));\r\n        return lineOperation;\r\n    }\r\n\r\n    /**\r\n     * 计算小图标的位置，并显示\r\n     * @param  {[type]} connector [description]\r\n     * @return {[type]}           [description]\r\n     */\r\n    LineOperationManager.prototype.bindOperation = function(connector) {\r\n        if (this.isEdit == false) {\r\n            return;\r\n        }\r\n        var pointPosition = connector.middle();\r\n\r\n        var arrLength = zrUtil.map(connector.icons, function(icon) {\r\n            return icon._width;\r\n        });\r\n\r\n        var totalLength = zrUtil.reduce(arrLength, function(previousValue,currentValue) {\r\n            return previousValue + currentValue + 10;\r\n        }, 0 );\r\n\r\n        zrUtil.each(connector.icons, function(icon, index) {\r\n            var connectorPosition = 0;\r\n            for (var k = 0; k < index; k++) {\r\n                connectorPosition += arrLength[k] + 10;\r\n            }\r\n            icon.attr(\"position\", [pointPosition[0] + connectorPosition - totalLength / 2, pointPosition[1] + 5]);\r\n            icon.show();\r\n            icon.attachLine = connector;\r\n        })\r\n    }\r\n\r\n    LineOperationManager.prototype.hideAllLineOperation = function() {\r\n        zrUtil.each(this.lineOperations, function(lineOperation) {\r\n            lineOperation.hide();\r\n        });\r\n    }\r\n\r\n    LineOperationManager.prototype.addDeleteIcon = function(lineNode,options) {\r\n        var opts = zrUtil.defaults({\r\n            iconPath: 'image://' + icon.DEL_IMG,\r\n            width: 12,\r\n            height: 14,\r\n            lineNode: lineNode,\r\n            callback: function(e) {\r\n                this._api.remove(e.target.attachLine);//this.connectionManager.selConnector);\r\n            }.bind(this)\r\n        }, options,true);\r\n\r\n        this.addIcon(\"delete\", opts);\r\n    }\r\n\r\n    LineOperationManager.prototype.addChangeLineTypeIcon = function(lineNode,options) {\r\n        var opts = zrUtil.defaults({\r\n            iconPath: 'image://' + icon.CHANGE_LINE_TYPE_IMG,\r\n            width: 15,\r\n            height: 15,\r\n            lineNode: lineNode,\r\n            callback: function () {\r\n                this._api.changeSelectConnectorType();\r\n            }.bind(this)\r\n        }, options,true);\r\n\r\n        this.addIcon(\"change\", opts)\r\n    }\r\n\r\n    module.exports = LineOperationManager;\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/manager/LineOperationManager.js\n// module id = 122\n// module chunks = 0","'use strict';\n/**\r\n * fishTopoFlow的layout对象，框架提供的布局都放在这个对象下。通过addCustomLayout方法添加自定义布局\r\n * @class fishTopoFlow.layout\r\n * @abstract\r\n */\r\n\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var flowUtil = require(\"../util/FlowUtil\");\r\n    var HLayout = require('./HLayout');\r\n    var VLayout = require('./VLayout');\r\n    var TreeLayout = require('./TreeLayout');\r\n    var ForceLayout = require('./ForceLayout');\r\n    var parsePercent = flowUtil.parsePercent;\r\n    var Tree = require('../data/Tree');\r\n    var layout = {};\r\n    layout.HLayout = HLayout;\r\n    layout.VLayout = VLayout;\r\n    layout.TreeLayout = TreeLayout;\r\n    layout.ForceLayout = ForceLayout;\r\n    layout.Tree = Tree\r\n\r\n    /**\r\n     * @method addCustomLayout\r\n     * 添加自定义布局类\r\n     * @param {Object} customLayout 自定义布局的类\r\n     */\r\n    layout.addCustomLayout = function(customLayout) {\r\n        layout.customLayout = customLayout;\r\n    }\r\n\r\n\r\n    layout.getLayoutRect = function (positionInfo, containerRect, margin) {\r\n        margin = flowUtil.normalizeCssArray(margin || 0);\r\n\r\n        var containerWidth = containerRect.width;\r\n        var containerHeight = containerRect.height;\r\n\r\n        var left = parsePercent(positionInfo.left, containerWidth);\r\n        var top = parsePercent(positionInfo.top, containerHeight);\r\n        var right = parsePercent(positionInfo.right, containerWidth);\r\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\r\n        var width = parsePercent(positionInfo.width, containerWidth);\r\n        var height = parsePercent(positionInfo.height, containerHeight);\r\n\r\n        var verticalMargin = margin[2] + margin[0];\r\n        var horizontalMargin = margin[1] + margin[3];\r\n        var aspect = positionInfo.aspect;\r\n\r\n        // If width is not specified, calculate width from left and right\r\n        if (isNaN(width)) {\r\n            width = containerWidth - right - horizontalMargin - left;\r\n        }\r\n        if (isNaN(height)) {\r\n            height = containerHeight - bottom - verticalMargin - top;\r\n        }\r\n\r\n        // If width and height are not given\r\n        // 1. Graph should not exceeds the container\r\n        // 2. Aspect must be keeped\r\n        // 3. Graph should take the space as more as possible\r\n        if (isNaN(width) && isNaN(height)) {\r\n            if (aspect > containerWidth / containerHeight) {\r\n                width = containerWidth * 0.8;\r\n            }\r\n            else {\r\n                height = containerHeight * 0.8;\r\n            }\r\n        }\r\n\r\n        if (aspect != null) {\r\n            // Calculate width or height with given aspect\r\n            if (isNaN(width)) {\r\n                width = aspect * height;\r\n            }\r\n            if (isNaN(height)) {\r\n                height = width / aspect;\r\n            }\r\n        }\r\n\r\n        // If left is not specified, calculate left from right and width\r\n        if (isNaN(left)) {\r\n            left = containerWidth - right - width - horizontalMargin;\r\n        }\r\n        if (isNaN(top)) {\r\n            top = containerHeight - bottom - height - verticalMargin;\r\n        }\r\n\r\n        // Align left and top\r\n        switch (positionInfo.left || positionInfo.right) {\r\n            case 'center':\r\n                left = containerWidth / 2 - width / 2 - margin[3];\r\n                break;\r\n            case 'right':\r\n                left = containerWidth - width - horizontalMargin;\r\n                break;\r\n        }\r\n        switch (positionInfo.top || positionInfo.bottom) {\r\n            case 'middle':\r\n            case 'center':\r\n                top = containerHeight / 2 - height / 2 - margin[0];\r\n                break;\r\n            case 'bottom':\r\n                top = containerHeight - height - verticalMargin;\r\n                break;\r\n        }\r\n        // If something is wrong and left, top, width, height are calculated as NaN\r\n        left = left || 0;\r\n        top = top || 0;\r\n        if (isNaN(width)) {\r\n            // Width may be NaN if only one value is given except width\r\n            width = containerWidth - left - (right || 0);\r\n        }\r\n        if (isNaN(height)) {\r\n            // Height may be NaN if only one value is given except height\r\n            height = containerHeight - top - (bottom || 0);\r\n        }\r\n\r\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\r\n        rect.margin = margin;\r\n        return rect;\r\n    };\r\n\r\n\r\n    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\r\n        var h = !opt || !opt.hv || opt.hv[0];\r\n        var v = !opt || !opt.hv || opt.hv[1];\r\n        var boundingMode = opt && opt.boundingMode || 'all';\r\n\r\n        if (!h && !v) {\r\n            return;\r\n        }\r\n\r\n        var rect;\r\n        if (boundingMode === 'raw') {\r\n            rect = (el.type === 'group' || el.type === 'GroupNode')\r\n                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\r\n                : el.getBoundingRect();\r\n        }\r\n        else {\r\n            rect = el.getBoundingRect();\r\n            if (el.needLocalTransform()) {\r\n                var transform = el.getLocalTransform();\r\n                // Notice: raw rect may be inner object of el,\r\n                // which should not be modified.\r\n                rect = rect.clone();\r\n                rect.applyTransform(transform);\r\n            }\r\n        }\r\n\r\n        positionInfo = layout.getLayoutRect(\r\n            zrUtil.defaults(\r\n                {width: rect.width, height: rect.height},\r\n                positionInfo\r\n            ),\r\n            containerRect,\r\n            margin\r\n        );\r\n\r\n        // Because 'tranlate' is the last step in transform\r\n        // (see zrender/core/Transformable#getLocalTransfrom),\r\n        // we can just only modify el.position to get final result.\r\n        var elPos = el.position;\r\n        var dx = h ? positionInfo.x - rect.x : 0;\r\n        var dy = v ? positionInfo.y - rect.y : 0;\r\n\r\n        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\r\n    };\r\n\r\n\r\n    module.exports = layout;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/layout/layout.js\n// module id = 123\n// module chunks = 0","/**\r\n * 水平布局<br>\r\n * @class fishTopoFlow.layout.HLayout\r\n * @extends fishTopoFlow.layout\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var layout = fishTopoFlow.layout;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       function newNode(group,text) {\r\n *           var rect = new node.Rect({\r\n *                   shape:{width:25,height:25},\r\n *                   style: {text:text,fill: \"#167CFF\"}\r\n *               });\r\n *           group.add(rect);\r\n *           return rect;\r\n *       }\r\n *       var hGroup =  new node.Group({\r\n *           style: {\r\n *               text: \"水平布局\",\r\n *               textPosition:\"bottom\"\r\n *           },\r\n *           position:[50,50],\r\n *           layout : new layout.HLayout({gap:10})\r\n *       });\r\n *       newNode(hGroup, \"A_1\")\r\n *       newNode(hGroup, \"A_2\");\r\n *       newNode(hGroup, \"A_3\");\r\n *       newNode(hGroup, \"A_4\");\r\n *       newNode(hGroup, \"A_5\");\r\n *       fishTopo.add(hGroup);\r\n */\r\n\r\n            var zrUtil = require('zrender/lib/core/util');\r\n             var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n            function HLayout(opts) {\r\n                /**\r\n                 * @cfg {Number} gap 节点之间的间隔\r\n                 */\r\n                /**\r\n                 * @cfg {Number} maxHeight=Infinity 组最大的宽度，如果超过会换行\r\n                 */\r\n                var defaultOptions = {\r\n                    gap: 5,\r\n                    maxWidth: Infinity\r\n                };\r\n                this.options = zrUtil.merge(defaultOptions, opts, true);\r\n            }\r\n            /**\r\n             * @method run\r\n             * 进行垂直布局，一般不需要调用，直接将布局类 赋值给组layout 属性即可\r\n             * @param {Object} group 需要进行垂直布局的组\r\n             */\r\n            HLayout.prototype.run = function(group)  {\r\n                var x = 0;\r\n                var y = 0;\r\n                var currentLineMaxSize = 0;\r\n                group.each(function (child, idx) {\r\n                    if (child instanceof Connector) {\r\n                        return;\r\n                    }\r\n\r\n                    var position = child.position;\r\n                    var rect = child.getBoundingRect();\r\n                    var nextChild = group.childAt(idx + 1);\r\n                    var nextChildRect = nextChild && nextChild.getBoundingRect();\r\n                    var nextX;\r\n\r\n                    var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\r\n                    nextX = x + moveX;\r\n                    // Wrap when width exceeds maxWidth or meet a `newline` group\r\n                    if (nextX > this.options.maxWidth || child.newline) {\r\n                        x = 0;\r\n                        nextX = moveX;\r\n                        y += currentLineMaxSize + parseInt(this.options.gap,10);\r\n                        currentLineMaxSize = rect.height;\r\n                    } else {\r\n                        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\r\n                    }\r\n\r\n                    if (child.newline) {\r\n                        return;\r\n                    }\r\n\r\n                    position[0] = x;\r\n                    position[1] = y;\r\n                    x = nextX + this.options.gap;\r\n                },this);\r\n\r\n                return HLayout;\r\n            }\r\n        module.exports = HLayout;\r\n\r\n/**\r\n * @method addCustomLayout\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/layout/HLayout.js\n// module id = 124\n// module chunks = 0","/**\r\n * 垂直布局<br>\r\n * @class fishTopoFlow.layout.VLayout\r\n * @extends fishTopoFlow.layout\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var layout = fishTopoFlow.layout;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       function newNode(group,text) {\r\n *           var rect = new node.Rect({\r\n *                   shape:{width:25,height:25},\r\n *                   style: {text:text,fill: \"#167CFF\"}\r\n *               });\r\n *           group.add(rect);\r\n *           return rect;\r\n *       }\r\n *       var vGroup =  new node.Group({\r\n *           style: {\r\n *               text: \"垂直布局\",\r\n *               textPosition:\"bottom\"\r\n *           },\r\n *           position:[60,60],\r\n *           layout : new layout.VLayout({gap:10})\r\n *       });\r\n*\r\n *       newNode(vGroup, \"A_1\")\r\n *       newNode(vGroup, \"A_2\");\r\n *       newNode(vGroup, \"A_3\");\r\n *       newNode(vGroup, \"A_4\");\r\n *       newNode(vGroup, \"A_5\");\r\n *       fishTopo.add(vGroup);\r\n */\r\n\r\n            var zrUtil = require('zrender/lib/core/util');\r\n            var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n            function VLayout(opts) {\r\n                /**\r\n                 * @cfg {Number} gap 节点之间的间隔\r\n                 */\r\n                /**\r\n                 * @cfg {Number} maxHeight=Infinity 组最大的高度，如果超过会换行\r\n                 */\r\n                var defaultOptions = {\r\n                    gap: 5,\r\n                    maxHeight: Infinity\r\n                };\r\n                this.options = zrUtil.merge(defaultOptions, opts, true);\r\n            }\r\n\r\n            /**\r\n             * @method run\r\n             * 进行垂直布局，一般不需要调用，直接将布局类 赋值给组layout 属性即可\r\n             * @param {Object} group 需要进行垂直布局的组\r\n             */\r\n            VLayout.prototype.run = function(group)  {\r\n                var x = 0;\r\n                var y = 0;\r\n                var currentLineMaxSize = 0;\r\n                group.each(function (child, idx) {\r\n                    if (child instanceof Connector) {\r\n                        return;\r\n                    }\r\n\r\n                    var position = child.position;\r\n                    var rect = child.getBoundingRect();\r\n                    var nextChild = group.childAt(idx + 1);\r\n                    var nextChildRect = nextChild && nextChild.getBoundingRect();\r\n                    var nextY;\r\n\r\n                    var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\r\n                    nextY = y + moveY;\r\n                    // Wrap when width exceeds maxHeight or meet a `newline` group\r\n                    if (nextY > this.options.maxHeight || child.newline) {\r\n                        x += currentLineMaxSize + parseInt(this.options.gap,10);\r\n                        y = 0;\r\n                        nextY = moveY;\r\n                        currentLineMaxSize = rect.width;\r\n                    }\r\n                    else {\r\n                        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\r\n                    }\r\n\r\n                    if (child.newline) {\r\n                        return;\r\n                    }\r\n\r\n                    position[0] = x;\r\n                    position[1] = y;\r\n                    y = nextY + this.options.gap;\r\n                },this);\r\n\r\n                return VLayout;\r\n            }\r\n        module.exports = VLayout;\r\n\r\n\r\n/**\r\n * @method addCustomLayout\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/layout/VLayout.js\n// module id = 125\n// module chunks = 0","/**\r\n * 树布局<br>\r\n * @class fishTopoFlow.layout.TreeLayout\r\n * @extends fishTopoFlow.layout\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var layout = fishTopoFlow.layout;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"));\r\n *       function newNode(data) {\r\n *           var circle = new node.Circle({\r\n *               shape: { r: 15 },\r\n *               style: { fill: \"#4883b4\" },\r\n *               name: data.name\r\n *           });\r\n *           return circle;\r\n *       }\r\n *       var options = {\r\n *           createNodeFunction: newNode,\r\n *           data:[{\r\n *               name: '根节点',\r\n *               children: [\r\n *                   {   name: '节点1',\r\n *                       children: [\r\n *                           {name: '叶子节点1'},\r\n *                           {name: '叶子节点2'},\r\n *                           {name: '叶子节点3'},\r\n *                           {name: '叶子节点4'},\r\n *                           {name: '叶子节点5'},\r\n *                           {name: '叶子节点6'}\r\n *                       ]\r\n *                   },\r\n *                   {   name: '节点2',\r\n *                       children: [\r\n *                           {name: '叶子节点7'},\r\n *                           {name: '叶子节点8'}]\r\n *                   },\r\n *                   {   name: '节点3',\r\n *                       children: [\r\n *                           {name: '叶子节点9'},\r\n *                           {name: '叶子节点10'},\r\n *                           {name: '叶子节点11'},\r\n *                           {name: '叶子节点12'}\r\n *                       ]\r\n *                   }\r\n *               ]\r\n *           }]\r\n *       }\r\n*\r\n *       var treeLayout = new layout.TreeLayout({\r\n *           fishTopo:fishTopo,\r\n *           rootLocation:{x:'center', y:50},\r\n *           nodePadding:1\r\n *       });\r\n *       treeLayout.doLayout(options);\r\n */\r\n\r\n            var zrUtil = require('zrender/lib/core/util');\r\n            var BoundingRect = require('zrender/lib/core/BoundingRect');\r\n            var flowUtil = require('../util/FlowUtil');\r\n            var parsePercent = flowUtil.parsePercent;\r\n            var TreeData = require('../data/Tree');  // 数据依赖\r\n            var TreeHelper = require(\"./treeHelper\"); // 布局依赖\r\n            function TreeLayout(opts) {\r\n                /**\r\n                 * @cfg {Object} fishTopo fishTopo实例\r\n                 */\r\n                /**\r\n                 * @cfg {Object} rootLocation 根节点坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number\r\n                 * @cfg {Number|String} rootLocation.x  根节点横坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number\r\n                 * @cfg {Number|String} rootLocation.y  根节点纵坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number\r\n                 */\r\n                /**\r\n                 * @cfg {Number} layerPadding=100 层间距,默认:100\r\n                 */\r\n                /**\r\n                 * @cfg {Number} nodePadding=30 节点间距,默认:30\r\n                 */\r\n                /**\r\n                 *@cfg {String} direction 树的方向可选：'vertical' | 'horizontal' ,默认:vertical\r\n                 */\r\n                /**\r\n                 * @cfg {Object} lineStyle 连线的样式  参见{@link fishTopoFlow.link#constructor 构造函数options参数}\r\n                 */\r\n                var defaultOptions = {\r\n                    orient:'vertical',  // vertical,horizontal\r\n                    nodePadding:30, //节点间距\r\n                    layerPadding:100,  //层间距\r\n                    rootLocation: {x:100, y:230}, // 根节点坐标，支持绝对值（px）、字符和百分比\r\n                    animateTime : 500,\r\n                    lineStyle: {pos:'bottom,top', symbol:{type:'none'}}\r\n                };\r\n                if (opts.orient === 'horizontal') {\r\n                    defaultOptions.lineStyle.pos = 'right,left';\r\n                }\r\n\r\n                this.options = zrUtil.defaults(defaultOptions, opts, true);\r\n                this.nodePadding = this.options.nodePadding;\r\n                this.layerPadding = this.options.layerPadding;\r\n                this.fishTopo = this.options.fishTopo;\r\n                this._layerOffsets = [];\r\n                this._layers = [];\r\n                this._hideNodes = [];\r\n            }\r\n\r\n            /**\r\n             * @method layoutByRootNode\r\n             * 根据根节点及连线的关系 ，生成树\r\n             * @param {Object} rootNode 树的根节点\r\n             * @return {Object} boundingbox 包围和\r\n             */\r\n            TreeLayout.prototype.layoutByRootNode = function(rootNode) {\r\n                var connectors = this.fishTopo.connectionManager.connectors;  //所有线段的数组\r\n                //递归生成树型数据结构\r\n                function traverseNode(parentNode, treeData) {\r\n                    var childrenData = [];\r\n                    var childrenNode = [];\r\n                    //1.根据连线，找出起始节点的所有子节点\r\n                    zrUtil.each(connectors, function(connector) {\r\n                        if(connector.startNode === parentNode) {\r\n                            if(!connector.endNode.exclude) {   //如果是排斥的节点则不加入\r\n                                childrenNode.push(connector.endNode);\r\n                            }\r\n                        }\r\n                    })\r\n\r\n                    if (childrenNode.length > 0) {\r\n                        //2.遍历子节点\r\n                        zrUtil.each(childrenNode, function(node) {\r\n                             var nodeData = {name: node.id, node:node};\r\n                             childrenData.push(nodeData);\r\n                             traverseNode(node, nodeData);\r\n                        })\r\n                    }\r\n                    //3.将子节点放入children中\r\n                    if (childrenData.length > 0) {\r\n                        treeData.children = childrenData;\r\n                    }\r\n                }\r\n                var rootTreeData = {name: rootNode.id, node:rootNode};\r\n                traverseNode(rootNode,rootTreeData);\r\n                return this.doLayout({data:[rootTreeData]}, true);\r\n            }\r\n\r\n            /**\r\n             * @method doLayout\r\n             * 根据传过来树型结构数据进行树布局\r\n             * @param {Object} treeData 树形数据\r\n             * @param {Function} treeData.createNodeFunction=null 创建节点的函数 会把data中的数据 传递过去  如果没有默认就是创建圆形\r\n             * @param {Object} treeData.data 创建树布局数据（必须包括name属性）\r\n             * @param {boolean} isNotBuildLink=true 默认是自动创建连线，传true则不会自动创建连线\r\n             * @return {Object} boundingbox 包围和\r\n             */\r\n            TreeLayout.prototype.doLayout = function(treeData, isNotBuildLink)  {\r\n                var rootData = treeData.data[0];\r\n                this.treeData = treeData;\r\n\r\n                this.tree = TreeData.fromOptionData(rootData.name, rootData.children);\r\n                this.tree.root.data = rootData;\r\n\r\n\r\n                this._buildNode(treeData);\r\n\r\n                //根据root坐标 方向 对每个节点的坐标进行映射\r\n                this._setTreeShape(function() {\r\n                    this._buildAllLink(isNotBuildLink);\r\n                }.bind(this));\r\n\r\n                return this.getBoundingRect();\r\n            }\r\n\r\n            /**\r\n             * @private\r\n             * @method _buildAllLink\r\n             * 递归画出连接线 与设置节点坐标\r\n             */\r\n             TreeLayout.prototype._buildAllLink = function (isNotBuildLink) {\r\n                this.tree.traverse(function(treeNode) {\r\n                    //画连接线\r\n                    if (treeNode.children.length > 0 && !isNotBuildLink) {\r\n                        this._buildLinkByParent(treeNode, this.treeData.createLinkFunction)\r\n                    } else {\r\n                        this.fishTopo.connectionManager.refreshLineByNode(treeNode.data.node);\r\n                    }\r\n                },this)\r\n             }\r\n\r\n\r\n            /**\r\n             * @method getBoundingRect\r\n             * 计算出树的包围和\r\n             * @return {Object} boundingbox 包围和\r\n             */\r\n            TreeLayout.prototype.getBoundingRect = function() {\r\n                var rect = null;\r\n                this.tree.traverse(function(treeNode) {\r\n                    var childRect = BoundingRect.create({x:treeNode.layout.position[0], y:treeNode.layout.position[1], width:treeNode.layout.width, height: treeNode.layout.height});\r\n                    if (!rect) rect = childRect.clone();\r\n                    rect.union(childRect);\r\n                },this)\r\n                return rect;\r\n            }\r\n\r\n\r\n\r\n            TreeLayout.prototype._setTreeShape = function(doneCallback) {\r\n                var animateCount = 0;\r\n                var treeHelper = new TreeHelper(\r\n                    {\r\n                        nodePadding: this.nodePadding,\r\n                        layerPadding: this.layerPadding\r\n                    }\r\n                );\r\n\r\n\r\n                this.tree.traverse(function(treeNode) {\r\n                    if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){\r\n                        var boundingRect = treeNode.data.node.getBoundingRect();\r\n                        treeNode.layout = {\r\n                            width: treeNode.data.node._width || boundingRect.width,\r\n                            height: treeNode.data.node._height || boundingRect.height\r\n                        }\r\n                    }\r\n\r\n                },this);\r\n                treeHelper._hideNodes = this._hideNodes;\r\n                treeHelper.run(this.tree);\r\n                // 树的方向\r\n                var orient = this.options.orient;\r\n                var rootX = this.options.rootLocation.x;\r\n                var rootY = this.options.rootLocation.y;\r\n                var zrWidth = this.fishTopo.getWidth();\r\n                var zrHeight = this.fishTopo.getHeight();\r\n                if (rootX === 'center') {\r\n                    rootX = zrWidth * 0.5;\r\n                }\r\n                else {\r\n                    rootX = parsePercent(rootX, zrWidth);\r\n                }\r\n                if (rootY === 'center') {\r\n                    rootY = zrHeight * 0.5;\r\n                }\r\n                else {\r\n                    rootY = parsePercent(rootY, zrHeight);\r\n                }\r\n                rootY = parsePercent(rootY, zrHeight);\r\n                // 水平树\r\n                if (orient === 'horizontal') {\r\n                    rootX = isNaN(rootX) ? 10 : rootX;\r\n                    rootY = isNaN(rootY) ? zrHeight * 0.5 : rootY;\r\n                }\r\n                // 纵向树\r\n                else {\r\n                    rootX = isNaN(rootX) ? zrWidth * 0.5 : rootX;\r\n                    rootY = isNaN(rootY) ? 10 : rootY;\r\n                }\r\n                // tree layout自动算出来的root的坐标\r\n                var originRootX = this.tree.root.layout.position[0];\r\n\r\n                var treeNodeCount = treeHelper.count(this.tree) - this._hideNodes.length;\r\n                var minY = Infinity;\r\n\r\n                this.tree.traverse(\r\n                    function (treeNode) {\r\n                        var x;\r\n                        var y;\r\n                        if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){\r\n                            if (orient === 'vertical' && this.options.direction === 'inverse') {\r\n                                x = treeNode.layout.position[0] - originRootX + rootX;\r\n                                y = rootY - treeNode.layout.position[1];\r\n                            }\r\n                            else if (orient === 'vertical') {\r\n                                x = treeNode.layout.position[0] - originRootX + rootX;\r\n                                y = treeNode.layout.position[1] + rootY;\r\n                            }\r\n                            else if (orient === 'horizontal' && this.options.direction === 'inverse') {\r\n                                y = treeNode.layout.position[0] - originRootX + rootY;\r\n                                x = rootX - treeNode.layout.position[1];\r\n                            }\r\n                            else if (orient === 'horizontal') {\r\n                                y = treeNode.layout.position[0] - originRootX + rootY;\r\n                                x = treeNode.layout.position[1] + rootX;\r\n                            }\r\n                            treeNode.layout.__x = x;\r\n                            treeNode.layout.__y = y;\r\n                            if (y < minY) {\r\n                                minY = y;\r\n                            }\r\n                        }\r\n                    },\r\n                    this\r\n                );\r\n\r\n                this.tree.traverse(function (treeNode) {\r\n                    if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){\r\n                        if (minY > 0) {\r\n                            treeNode.layout.position[0] = treeNode.layout.__x;\r\n                            treeNode.layout.position[1] = treeNode.layout.__y;\r\n                        } else  {\r\n                            treeNode.layout.position[0] = treeNode.layout.__x;\r\n                            treeNode.layout.position[1] = treeNode.layout.__y - minY;\r\n                        }\r\n\r\n                        treeNode.data.node.animateTo({\r\n                            position: [treeNode.layout.position[0], treeNode.layout.position[1]]\r\n                        }, this.options.animateTime, function() {\r\n                            if (++animateCount === treeNodeCount) {\r\n                                doneCallback();\r\n                            }\r\n                        }.bind(this));\r\n                        //节点有孩子才显示 收缩按钮\r\n                        if(this._hideNodes.length == 0){\r\n                            if (treeNode.children.length > 0 && treeNode.data.node._toggleShrink) {\r\n                                treeNode.data.node._toggleShrink(true);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                },this)\r\n            }\r\n\r\n            TreeLayout.prototype._buildNode = function(treeData) {\r\n                if(!treeData.createNodeFunction) {\r\n                    treeData.createNodeFunction = this._defaultCreateNodeFunction;\r\n                }\r\n                //判断一下是否有node 如果没有则自己创建\r\n                this.tree.traverse(function(treeNode) {\r\n                    if(!treeNode.data.node) {\r\n                        var createNodeFunction = treeNode.data.createNodeFunction || treeData.createNodeFunction;\r\n                        var node = createNodeFunction(treeNode.data, this);\r\n                        node._childShow = true;\r\n                        this.fishTopo.add(node);\r\n                        treeNode.data.node = node;\r\n                    }\r\n                },this);\r\n            }\r\n\r\n            TreeLayout.prototype._defaultCreateNodeFunction = function(item) {\r\n                var circle = this.fishTopo.createNode(\"Circle\",{\r\n                    shape: { r: 15 },\r\n                    style: { fill: \"#4883b4\" },\r\n                    name: item.lable || item.name\r\n                });\r\n                return circle;\r\n            }\r\n\r\n            TreeLayout.prototype._buildLinkByParent = function (parentTreeNode, createLinkFunction) {\r\n                for (var i = 0, childLength = parentTreeNode.children.length; i < childLength; i++) {\r\n                    this._buildLink(parentTreeNode, parentTreeNode.children[i], createLinkFunction);\r\n                }\r\n            };\r\n\r\n\r\n            TreeLayout.prototype._buildLink = function (startTreeNode, endTreeNode, createLinkFunction) {\r\n                    var connector = null;\r\n                    var startNode = startTreeNode.data.node;\r\n                    var endNode = endTreeNode.data.node;\r\n                    if(createLinkFunction) {\r\n                        var paramObj =  endTreeNode.data;\r\n                        paramObj.startNode = startNode;\r\n                        paramObj.endNode = endNode;\r\n                        connector = createLinkFunction(paramObj);\r\n                    } else {\r\n                        var linkStyle = this.options.lineStyle;\r\n                        if (endTreeNode.data.lineStyle) {\r\n                            linkStyle = zrUtil.merge(zrUtil.clone(linkStyle), endTreeNode.data.lineStyle, true);\r\n                        }\r\n                        connector = this.fishTopo.createLink(startNode,endNode,linkStyle)\r\n                    }\r\n                    this.fishTopo.add(connector);\r\n            };\r\n\r\n\r\n            TreeLayout.prototype.addChild = function (treeNode, data, callback) {\r\n                var newTreeNode = (new TreeData(data.name)).root;\r\n                newTreeNode.data = data;\r\n\r\n                var node = this.treeData.createNodeFunction(newTreeNode.data, this);\r\n                node._childShow = true;\r\n                if (treeNode.children.length >= 1) {\r\n                    node.attr('position', zrUtil.clone(treeNode.children[treeNode.children.length - 1].layout.position));\r\n                } else {\r\n                    node.attr('position', zrUtil.clone(treeNode.layout.position));\r\n                }\r\n\r\n                this.fishTopo.add(node);\r\n                newTreeNode.data.node = node;\r\n                setTimeout(function () {\r\n                    this._buildLink(treeNode, newTreeNode, this.treeData.createLinkFunction);\r\n                }.bind(this), this.options.animateTime);\r\n\r\n                treeNode.add(newTreeNode);\r\n                this.refreshPositionAndLine(callback);\r\n                return node;\r\n            };\r\n\r\n            TreeLayout.prototype.toggleChild = function (node) {\r\n                var toggleTreeNode = this.findTreeNodeByNode(node);\r\n                if (node._childShow) {\r\n                    toggleTreeNode.traverse(function (treeNode) {\r\n                        if (treeNode.data.node !== node) {\r\n                            treeNode.data.node.hide();\r\n                            if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){\r\n                                this._hideNodes.push(treeNode);\r\n                            }\r\n                            this.fishTopo.connectionManager.toggleLineByNode(treeNode.data.node, false);\r\n                            if (treeNode.children.length > 0) {\r\n                                treeNode.data.node._childShow = false;\r\n                                treeNode.data.node._toggleShrink && treeNode.data.node._toggleShrink(false);\r\n                            }\r\n                        }\r\n                    },this);\r\n                    node._childShow = false;\r\n                    node._toggleShrink && node._toggleShrink(false);\r\n                    this.refreshPositionAndLine();\r\n                } else {\r\n                    toggleTreeNode.traverse(function (treeNode) {\r\n                        if (treeNode.data.node !== node) {\r\n                            treeNode.data.node.show();\r\n                            this._hideNodes.splice(zrUtil.indexOf(this._hideNodes, treeNode),1);\r\n                            this.fishTopo.connectionManager.toggleLineByNode(treeNode.data.node, true);\r\n                            if (treeNode.children.length > 0) {\r\n                                treeNode.data.node._childShow = true;\r\n                                treeNode.data.node._toggleShrink && treeNode.data.node._toggleShrink(true);\r\n                            }\r\n                        }\r\n                    },this);\r\n                    node._childShow = true;\r\n                    node._toggleShrink && node._toggleShrink(true);\r\n                    this.refreshPositionAndLine();\r\n                }\r\n            };\r\n\r\n\r\n            TreeLayout.prototype.findTreeNodeByNode = function (node) {\r\n                var returnTreeNode = null;\r\n                this.tree.traverse(function (treeNode) {\r\n                    if (treeNode.data.node === node) {\r\n                        returnTreeNode = treeNode;\r\n                    }\r\n                });\r\n                return returnTreeNode;\r\n            };\r\n\r\n            TreeLayout.prototype.removeNode = function (node) {\r\n                var treeNode = this.findTreeNodeByNode(node);\r\n                var parentTreeNode = treeNode.parent;\r\n                if (!parentTreeNode) return false;\r\n                //遍历 topo中删除自己及孩子节点\r\n                treeNode.traverse(function (eachTreeNode) {\r\n                    this.fishTopo.remove(eachTreeNode.data.node); //删除节点\r\n                },this)\r\n\r\n                parentTreeNode.remove(treeNode);\r\n\r\n                //判断一下父节点是不是没有了,如果没有的话,要把线与+-号给隐藏掉\r\n                if (parentTreeNode.children.length === 0) {\r\n                    parentTreeNode.data.node._hideToggle && parentTreeNode.data.node._hideToggle();\r\n                }\r\n\r\n                //重新生成数据\r\n                this.refreshPositionAndLine();\r\n                return true;\r\n            };\r\n\r\n\r\n            TreeLayout.prototype.removeChildren = function (node) {\r\n                var treeNode = this.findTreeNodeByNode(node);\r\n                //遍历 topo中删除孩子节点\r\n                treeNode.traverse(function (eachTreeNode) {\r\n                    if (eachTreeNode !== treeNode) {\r\n                        this.fishTopo.remove(eachTreeNode.data.node); //删除节点\r\n                    }\r\n                },this)\r\n\r\n                treeNode.removeAllChildren();\r\n                node._hideToggle && node._hideToggle(); //this._hidePath(node);\r\n\r\n                //重新生成数据\r\n                this.refreshPositionAndLine();\r\n                return true;\r\n            };\r\n\r\n            TreeLayout.prototype.refreshPositionAndLine = function (callback) {\r\n                this.tree.root.updateDepthAndHeight(0);\r\n                this._setTreeShape(function () {\r\n                    this.tree.traverse(function (eachTreeNode) {\r\n                        this.fishTopo.connectionManager.refreshLineByNode(eachTreeNode.data.node);\r\n                    }, this);\r\n                    callback && callback();\r\n                }.bind(this));\r\n            }\r\n\r\n            TreeLayout.prototype.changePosition = function (node, direction) {\r\n                var parentNode = node.parent;\r\n                var nowIndex = zrUtil.indexOf(parentNode.children, node);\r\n                var targetIndex;\r\n                if(direction == \"next\"){\r\n                    targetIndex = nowIndex + 1;\r\n                }else if(direction == \"prev\"){\r\n                    targetIndex = nowIndex - 1;\r\n                }\r\n                var targetNode = parentNode.children[targetIndex];\r\n                if(targetNode){\r\n                    var storage = targetNode;\r\n                    parentNode.children[targetIndex] = node;\r\n                    parentNode.children[nowIndex] = storage;\r\n                }\r\n                this.refreshPositionAndLine();\r\n                this.fishTopo.trigger('treeLayout:changePosition',{\r\n                    node:node,\r\n                    parentNode:parentNode,\r\n                    targetNode:targetNode\r\n                })\r\n            }\r\n\r\n        module.exports = TreeLayout;\r\n\r\n\r\n/**\r\n * @method addCustomLayout\r\n * @hide\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/layout/TreeLayout.js\n// module id = 126\n// module chunks = 0","\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    /**\r\n     * @constructor TreeNode\r\n     * @param {string} id Node ID\r\n     * @param {Object} [data]\r\n     */\r\n    function TreeNode(id, data) {\r\n        /**\r\n         * @type {string}\r\n         */\r\n        this.id = id;\r\n        /**\r\n         * 节点的深度\r\n         * @type {number}\r\n         */\r\n        this.depth = 0;\r\n        /**\r\n         * 以当前节点为根节点的子树的高度\r\n         * @type {number}\r\n         */\r\n        this.height = 0;\r\n        /**\r\n         * 子节点列表\r\n         * @type {Array.<TreeNode>}\r\n         */\r\n        this.children = [];\r\n\r\n        /**\r\n         * @type {TreeNode}\r\n         */\r\n        this.parent = null;\r\n\r\n        /**\r\n         * 存储的用户数据\r\n         * @type {Object}\r\n         */\r\n        this.data = data || null;\r\n    }\r\n\r\n    /**\r\n     * 添加子节点\r\n     * @param {TreeNode} child\r\n     */\r\n    TreeNode.prototype.add = function (child) {\r\n        var children = this.children;\r\n        if (child.parent === this) {\r\n            return;\r\n        }\r\n\r\n        children.push(child);\r\n        child.parent = this;\r\n    };\r\n\r\n    /**\r\n     * 移除子节点\r\n     * @param {TreeNode} child\r\n     */\r\n    TreeNode.prototype.remove = function (child) {\r\n        var children = this.children;\r\n        var idx = zrUtil.indexOf(children, child);\r\n        if (idx >= 0) {\r\n            children.splice(idx, 1);\r\n            child.parent = null;\r\n        }\r\n    };\r\n\r\n     TreeNode.prototype.removeAllChildren = function () {\r\n         var children = this.children;\r\n         for (var i = 0; i < children.length; i++) {\r\n             var child = children[i];\r\n            child.parent = null;\r\n         }\r\n        this.children = [];\r\n     }\r\n\r\n    /**\r\n     * 遍历当前节点及其所有子节点\r\n     * @param  {Function} cb\r\n     * @param  {Object}   [context]\r\n     */\r\n    TreeNode.prototype.traverse = function (cb, context) {\r\n        cb.call(context, this);\r\n\r\n        for (var i = 0; i < this.children.length; i++) {\r\n            this.children[i].traverse(cb, context);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 遍历节前节点及所有子节点的数量\r\n     */\r\n    TreeNode.prototype.count = function () {\r\n        var count = 0;\r\n        this.traverse(function() {\r\n            count++;\r\n         });\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * 更新当前树及所有子树的高度和深度\r\n     * @param  {number} depth\r\n     */\r\n    TreeNode.prototype.updateDepthAndHeight = function (depth) {\r\n        var height = 0;\r\n        this.depth = depth;\r\n        for (var i = 0; i < this.children.length; i++) {\r\n            var child = this.children[i];\r\n            child.updateDepthAndHeight(depth + 1);\r\n            if (child.height > height) {\r\n                height = child.height;\r\n            }\r\n        }\r\n        this.height = height + 1;\r\n    };\r\n\r\n    /**\r\n     * @param  {string} id\r\n     * @return TreeNode\r\n     */\r\n    TreeNode.prototype.getNodeById = function (id) {\r\n        if (this.id === id) {\r\n            return this;\r\n        }\r\n        for (var i = 0; i < this.children.length; i++) {\r\n            var res = this.children[i].getNodeById(id);\r\n            if (res) {\r\n                return res;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @constructor\r\n     * @alias module:echarts/data/Tree\r\n     * @param {string} id\r\n     */\r\n    function Tree(id) {\r\n        /**\r\n         * @type {TreeNode}\r\n         */\r\n        this.root = new TreeNode(id);\r\n    }\r\n\r\n    /**\r\n     * 遍历树的所有子节点(深度优先遍历)\r\n     * @param  {Function} cb\r\n     * @param  {Object}   [context]\r\n     */\r\n    Tree.prototype.traverse = function(cb, context) {\r\n        this.root.traverse(cb, context);\r\n    };\r\n\r\n    /**\r\n     * 生成子树\r\n     * @param  {string} id 子树根节点 id\r\n     * @return {module:echarts/data/Tree}\r\n     */\r\n    Tree.prototype.getSubTree = function(id) {\r\n        var root = this.getNodeById(id);\r\n        if (root) {\r\n            var tree = new Tree(root.id);\r\n            tree.root = root;\r\n            return tree;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @param  {string} id\r\n     * @return TreeNode\r\n     */\r\n    Tree.prototype.getNodeById = function (id) {\r\n        return this.root.getNodeById(id);\r\n    };\r\n\r\n\r\n    /**\r\n     * 从 option 里的 data 数据构建树\r\n     * @param {string} id\r\n     * @param {Array.<Object>} data\r\n     * @return Tree\r\n     */\r\n    Tree.fromOptionData = function (id, data) {\r\n        var tree = new Tree(id);\r\n        var rootNode = tree.root;\r\n        // Root node\r\n        rootNode.data = {\r\n            name: id,\r\n            children: data\r\n        };\r\n\r\n        function buildHierarchy(dataNode, parentNode) {\r\n            var node = new TreeNode(dataNode.name, dataNode);\r\n            parentNode.add(node);\r\n            // 遍历添加子节点\r\n            var children = dataNode.children;\r\n            if (children) {\r\n                for (var i = 0; i < children.length; i++) {\r\n                    buildHierarchy(children[i], node);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (var i = 0; i < data.length; i++) {\r\n            buildHierarchy(data[i], rootNode);\r\n        }\r\n\r\n        tree.root.updateDepthAndHeight(0);\r\n\r\n        return tree;\r\n    };\r\n\r\n\r\n    Tree.fromDataSource = function (dataSource, rootItem) {\r\n\r\n        function _findChildItem(nodeName) {\r\n            return zrUtil.filter(dataSource.link,function(item){\r\n                if(item.from === nodeName && !item.pos) {  // 数据中有pos属性的不是子节点\r\n                    return item;\r\n                }\r\n            });\r\n        }\r\n\r\n\r\n        function buildHierarchy(root) {\r\n            var childItem = _findChildItem(root.id);\r\n            for (var i = 0; i < childItem.length; i++) {\r\n                var item = childItem[i];\r\n                var childTreeNode = treeNodesMap[item.to];\r\n                root.children.push(childTreeNode);\r\n                buildHierarchy(childTreeNode);\r\n            }\r\n        }\r\n\r\n        var treeNodesMap = {};\r\n        for (var i = 0; i < dataSource.node.length; i++) {\r\n            var node = dataSource.node[i];\r\n            var treeNode = new TreeNode(node.name,node);\r\n            treeNodesMap[node.name] = treeNode;\r\n        }\r\n\r\n        var tree = new Tree(rootItem.name);\r\n        var rootNode = tree.root;\r\n        // Root node\r\n        rootNode.data = rootItem;\r\n\r\n\r\n        buildHierarchy(tree.root);\r\n        tree.root.updateDepthAndHeight(0);\r\n\r\n        return tree;\r\n    };\r\n\r\n    module.exports = Tree;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/data/Tree.js\n// module id = 127\n// module chunks = 0","\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    function TreeHelper(opts) {\r\n        opts = opts || {};\r\n\r\n        this.nodePadding = opts.nodePadding || 30;\r\n\r\n        this.layerPadding = opts.layerPadding || 100;\r\n\r\n        this._layerOffsets = [];\r\n\r\n        this._layers = [];\r\n\r\n        this._hideNodes = [];\r\n    }\r\n\r\n    TreeHelper.prototype.count = function (tree) {\r\n        var count = 0;\r\n        tree.traverse(function() {\r\n            count++;\r\n         });\r\n        return count;\r\n    }\r\n\r\n    TreeHelper.prototype.run = function (tree) {\r\n        this._layerOffsets.length = 0;\r\n        for (var i = 0; i < tree.root.height + 1; i++) {\r\n            this._layerOffsets[i] = 0;\r\n            this._layers[i] = [];\r\n        }\r\n        this._updateNodeXPosition(tree.root);\r\n        var root = tree.root;\r\n        this._updateNodeYPosition(root, 0, root.layout.height);\r\n    };\r\n\r\n    TreeHelper.prototype._updateNodeXPosition = function (node) {\r\n        var minX = Infinity;\r\n        var maxX = -Infinity;\r\n        node.layout.position = node.layout.position || vec2.create();\r\n        for (var i = 0; i < node.children.length; i++) {\r\n            var child = node.children[i];\r\n            if(zrUtil.indexOf(this._hideNodes, child) == -1){\r\n                this._updateNodeXPosition(child);\r\n                var x = child.layout.position[0];\r\n                if (x < minX) {\r\n                    minX = x;\r\n                }\r\n                if (x > maxX) {\r\n                    maxX = x;\r\n                }\r\n            }\r\n        }\r\n        if (node.children.length > 0 && (zrUtil.indexOf(this._hideNodes, node.children[0]) == -1)) {\r\n            node.layout.position[0] = (minX + maxX) / 2;\r\n        } else {\r\n            node.layout.position[0] = 0;\r\n            node.height = 0;   // 隐藏节点的 深度设为0\r\n        }\r\n        var off = this._layerOffsets[node.depth] || 0;\r\n        if (off > node.layout.position[0]) {\r\n            var shift = off - node.layout.position[0];\r\n            this._shiftSubtree(node, shift);\r\n            for (var j = node.depth + 1; j < node.height + node.depth; j++) {\r\n                this._layerOffsets[j] += shift;\r\n            }\r\n        }\r\n        this._layerOffsets[node.depth] = node.layout.position[0] + node.layout.width + this.nodePadding;\r\n\r\n        if(zrUtil.indexOf(this._layers[node.depth], node) == -1){\r\n            this._layers[node.depth].push(node);\r\n        }\r\n    };\r\n\r\n    TreeHelper.prototype._shiftSubtree = function (root, offset) {\r\n        root.layout.position[0] += offset;\r\n        for (var i = 0; i < root.children.length; i++) {\r\n            if(zrUtil.indexOf(this._hideNodes,root.children[i]) == -1){\r\n                this._shiftSubtree(root.children[i], offset);\r\n            }\r\n        }\r\n    };\r\n\r\n    TreeHelper.prototype._updateNodeYPosition = function (node, y, prevLayerHeight) {\r\n        if(zrUtil.indexOf(this._hideNodes,node) == -1){\r\n            node.layout.position[1] = y;\r\n            var layerHeight = 0;\r\n            for (var i = 0; i < node.children.length; i++) {\r\n                layerHeight = Math.max(node.children[i].layout.height, layerHeight);\r\n            }\r\n            var layerPadding = this.layerPadding;\r\n            if (typeof (layerPadding) === 'function') {\r\n                layerPadding = layerPadding(node.depth);\r\n            }\r\n            for (var j = 0; j < node.children.length; j++) {\r\n                this._updateNodeYPosition(node.children[j], y + layerPadding + prevLayerHeight, layerHeight);\r\n            }\r\n        }\r\n\r\n    };\r\n    module.exports = TreeHelper;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/layout/treeHelper.js\n// module id = 128\n// module chunks = 0","/**\r\n * 力导向布局<br>\r\n * @class fishTopoFlow.layout.ForceLayout\r\n * @extends fishTopoFlow.layout\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *       var node = fishTopoFlow.node;\r\n *       var layout = fishTopoFlow.layout;\r\n *       var fishTopo = fishTopoFlow.init(document.getElementById(\"flowIns\"), {roam:false});\r\n *       function newNode(data) {\r\n *           var circle = new node.Circle({\r\n *               shape: { r: 15 },\r\n *               style: { fill: \"#4883b4\" },\r\n *               name: data.name\r\n *           });\r\n *           return circle;\r\n *       }\r\n *       var options = {\r\n *           createNodeFunction: newNode,\r\n *           data:[{nodes:[\r\n *                           {name: '节点1'},\r\n *                           {name: '节点2'},\r\n *                           {name: '节点3'},\r\n *                           {name: '节点4'},\r\n *                           {name: '节点5'},\r\n *                           {name: '节点6'},\r\n *                           {name: '节点7'},\r\n *                           {name: '节点8'}\r\n *                       ],\r\n *                   links:[\r\n *                           {source:'节点1', target:'节点2'},\r\n *                           {source:'节点2', target:'节点3'},\r\n *                           {source:'节点3', target:'节点4'},\r\n *                           {source:'节点4', target:'节点5'},\r\n *                           {source:'节点5', target:'节点6'},\r\n *                           {source:'节点6', target:'节点7'},\r\n *                           {source:'节点7', target:'节点8'}\r\n *                       ]\r\n *           }]\r\n *       }\r\n *       var forceLayout = new layout.ForceLayout({\r\n *          fishTopo:fishTopo,\r\n *           repulsion: 200\r\n *       });\r\n *       forceLayout.doLayout(options);\r\n */\r\n\r\n\r\n\r\n    var forceHelper = require('./forceHelper');\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    function ForceLayout(opts) {\r\n         /**\r\n         * @cfg {Object} fishTopo fishTopo实例\r\n         */\r\n         /**\r\n         * @cfg {Number} [repulsion=100] 节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100\r\n         */\r\n         /**\r\n         * @cfg {Number} [gravity=0.1] 节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1\r\n         */\r\n        /**\r\n         * @cfg {Number} [edgeLength=30] 边的两个节点之间的距离，这个距离也会受 repulsion影响。 默认为30\r\n         */\r\n        /**\r\n         * @cfg {Boolean} [once=true] 是否只进行布局一次\r\n         */\r\n        /**\r\n         * @cfg {Object} [rect] 布局显示范围\r\n         *\r\n         * @cfg {Object} [rect.x] 布局显示范围x坐标\r\n         * @cfg {Object} [rect.y] 布局显示范围y坐标\r\n         * @cfg {Object} [rect.width] 布局显示宽度\r\n         * @cfg {Object} [rect.height] 布局显示高度\r\n         */\r\n        /**\r\n         * @cfg {Boolean} [layoutAnimation=true] 是否显示布局动画\r\n         */\r\n        /**\r\n         * @cfg {Object} [lineStyle] 连线的样式  参见{@link fishTopoFlow.link#constructor 构造函数options参数}\r\n         */\r\n        this.fishTopo = opts.fishTopo;\r\n        var defaultOptions = {\r\n            repulsion: 100,  //节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100\r\n            gravity: 0.1, //节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1\r\n            edgeLength: 30, // 边的两个节点之间的距离，这个距离也会受 repulsion。 默认为30\r\n            once:true,\r\n            layoutAnimation:true,\r\n            rect: {x:0, y:0, width:this.fishTopo.getWidth() ,height:this.fishTopo.getHeight()},\r\n            lineStyle: {symbol:{type:'none'}},\r\n            preservedPoints: {}\r\n        };\r\n\r\n        this.options = zrUtil.defaults(defaultOptions, opts, true);\r\n    }\r\n\r\n    /**\r\n     * @method doLayout\r\n     * 根据forceData进行力导向布局\r\n     * @param {Object} forceData 力导向数据\r\n     * @param {Function} forceData.createNodeFunction=null 创建节点的函数 会把data中nodes的数据 传递过去  如果没有默认就是创建圆形\r\n     * @param {Object} forceData.data 创建力导向布局数据\r\n     * @param {Object} forceData.data.nodes 创建力导向布局节点的对象数据（必须包括name属性）\r\n     * @param {Object} forceData.data.links 创建力导向布局连线的对象数据（必须包括name属性）\r\n     *\r\n     */\r\n    ForceLayout.prototype.doLayout = function(forceData) {\r\n         var rootData = forceData.data[0];\r\n        this.allNodes = this._buildNode(rootData.nodes);\r\n        this.allLinks = this._buildLinks(rootData.links);\r\n        this._forceIns();\r\n\r\n        this._startForceLayoutIteration();\r\n    }\r\n\r\n    ForceLayout.prototype._buildNode = function(datas) {\r\n        if(!datas.createNodeFunction) {\r\n            datas.createNodeFunction = this._defaultCreateNodeFunction.bind(this);\r\n        }\r\n        var allNodes = [];\r\n        //判断一下是否有node 如果没有则自己创建\r\n        zrUtil.each(datas,  function(item,idx) {\r\n            if(!item.node) {\r\n                var createNodeFunction = item.createNodeFunction || datas.createNodeFunction;\r\n                var node = createNodeFunction(item);\r\n                this.fishTopo.add(node);\r\n                this._addNodeEvent(node,idx);\r\n                allNodes.push(node);\r\n            }\r\n        },this);\r\n        return allNodes;\r\n    }\r\n\r\n    ForceLayout.prototype._addNodeEvent = function(node,idx) {\r\n        if(!this.options.once) {\r\n            node.on('drag', function() {\r\n                if(this.options.forceLayout) {\r\n                    this.options.forceLayout.warmUp();\r\n                    !this._layouting && this._startForceLayoutIteration();\r\n                    this.options.forceLayout.setFixed(idx);\r\n                }\r\n            },this).on('dragend', function() {\r\n                if(this.options.forceLayout) {\r\n                    this.options.forceLayout.setUnfixed(idx);\r\n                }\r\n            },this)\r\n        }\r\n    }\r\n\r\n    ForceLayout.prototype._defaultCreateNodeFunction = function(item) {\r\n        var circle = this.fishTopo.createNode(\"Circle\",{\r\n            shape: { r: 15 },\r\n            style: { fill: \"#4883b4\" },\r\n            name: item.lable || item.name\r\n        });\r\n        return circle;\r\n    }\r\n\r\n    ForceLayout.prototype._buildLinks = function(links,createLinkFunction) {\r\n        var allLinks = [];\r\n\r\n        zrUtil.each(links, function(link) {\r\n            var startNode = this.fishTopo.childOfName(link.source);\r\n            var endNode = this.fishTopo.childOfName(link.target);\r\n            if(startNode && endNode) {\r\n                 var connector = null;\r\n                if(createLinkFunction) {\r\n                    var paramObj = link;\r\n                    paramObj.startNode = startNode;\r\n                    paramObj.endNode = endNode;\r\n                    connector = createLinkFunction(paramObj);\r\n                } else {\r\n                    var linkStyle = this.options.lineStyle;\r\n                    if (link.style) {\r\n                        linkStyle = zrUtil.merge(zrUtil.clone(linkStyle), link.style, true);\r\n                    }\r\n                    connector = this.fishTopo.createLink(startNode,endNode,linkStyle);\r\n                }\r\n                this.fishTopo.add(connector);\r\n                allLinks.push(connector);\r\n            }\r\n        },this);\r\n        return allLinks;\r\n    }\r\n\r\n\r\n    ForceLayout.prototype._forceIns = function() {\r\n        var rect = this.options.rect;\r\n        var self = this;\r\n        var preservedPoints = this.options.preservedPoints;\r\n        var nodes = zrUtil.map(this.allNodes, function(node) {\r\n            var rep = this.options.repulsion; node.w = rep; node.rep = rep; node.p = null;\r\n            return {\r\n                w: rep,\r\n                rep: rep,\r\n                p: null\r\n            };\r\n        },this);\r\n        if (preservedPoints) {\r\n            zrUtil.each(this.allNodes, function(node,idx) {\r\n                node.attr(\"position\", preservedPoints[idx]);\r\n            })\r\n        }\r\n        zrUtil.each(this.allLinks, function(link) {\r\n            link.n1 = link.startNode,\r\n            link.n2 = link.endNode,\r\n            link.d = this.options.edgeLength;\r\n            link.curveness = 0;\r\n        },this)\r\n\r\n        var forceInstance = forceHelper(this.allNodes, this.allLinks, {\r\n            rect: rect,\r\n            gravity: this.options.gravity\r\n        });\r\n        var oldStep = forceInstance.step;\r\n        forceInstance.step = function(cb) {\r\n            zrUtil.each(this.allNodes, function(node) {\r\n                if (nodes.fixed) {\r\n                    vec2.copy(nodes.p, nodes.position);\r\n                }\r\n            })\r\n\r\n            oldStep(function(allNodes, allLinks, stopped) {\r\n                for (var i = 0, l = allNodes.length; i < l; i++) {\r\n                    if (!allNodes[i].fixed) {\r\n                        allNodes[i].attr(\"position\", allNodes[i].p);\r\n                    }\r\n                    preservedPoints[i] = allNodes[i].p;\r\n                }\r\n\r\n                zrUtil.each(allLinks, function(connector) {\r\n                    self.fishTopo.connectionManager.refreshConnector(connector, true);\r\n                })\r\n\r\n                cb && cb(stopped);\r\n            });\r\n        };\r\n        this.options.forceLayout = forceInstance;\r\n        this.options.preservedPoints = preservedPoints;\r\n        // Step to get the layout\r\n        forceInstance.step();\r\n    }\r\n\r\n\r\n    ForceLayout.prototype._startForceLayoutIteration = function () {\r\n        var self = this;\r\n        var layoutAnimation = this.options.layoutAnimation;\r\n        (function step() {\r\n            self.options.forceLayout.step(function (stopped) {\r\n                self._layouting = !stopped;\r\n                if (self._layouting) {\r\n                    if (layoutAnimation) {\r\n                        self._layoutTimeout = setTimeout(step, 16)\r\n                    } else {\r\n                        step();\r\n                    }\r\n                } else {\r\n                     self.fishTopo.trigger(\"forceLayoutEnd\");  //派发布局结束事件\r\n                }\r\n            })\r\n        })();\r\n    };\r\n    module.exports = ForceLayout;\r\n\r\n/**\r\n * @method addCustomLayout\r\n * @hide\r\n */\r\n\r\n/**\r\n * @event forceLayoutEnd\r\n * 布局结束事件\r\n *\r\n * <pre>\r\n * fishtopo.on('forceLayoutEnd', function(e) {\r\n *   //do something\r\n * })\r\n * </pre>\r\n */\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/layout/ForceLayout.js\n// module id = 129\n// module chunks = 0","\r\n\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var scaleAndAdd = vec2.scaleAndAdd;\r\n\r\n    // function adjacentNode(n, e) {\r\n    //     return e.n1 === n ? e.n2 : e.n1;\r\n    // }\r\n\r\n    module.exports = function (nodes, edges, opts) {\r\n        var rect = opts.rect;\r\n        var width = rect.width;\r\n        var height = rect.height;\r\n        var center = [rect.x + width / 2, rect.y + height / 2];\r\n        // var scale = opts.scale || 1;\r\n        var gravity = opts.gravity == null ? 0.1 : opts.gravity;\r\n\r\n        // for (var i = 0; i < edges.length; i++) {\r\n        //     var e = edges[i];\r\n        //     var n1 = e.n1;\r\n        //     var n2 = e.n2;\r\n        //     n1.edges = n1.edges || [];\r\n        //     n2.edges = n2.edges || [];\r\n        //     n1.edges.push(e);\r\n        //     n2.edges.push(e);\r\n        // }\r\n        // Init position\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            var n = nodes[i];\r\n            if (!n.p) {\r\n                // Use the position from first adjecent node with defined position\r\n                // Or use a random position\r\n                // From d3\r\n                // if (n.edges) {\r\n                //     var j = -1;\r\n                //     while (++j < n.edges.length) {\r\n                //         var e = n.edges[j];\r\n                //         var other = adjacentNode(n, e);\r\n                //         if (other.p) {\r\n                //             n.p = vec2.clone(other.p);\r\n                //             break;\r\n                //         }\r\n                //     }\r\n                // }\r\n                // if (!n.p) {\r\n                    n.p = vec2.create(\r\n                        width * (Math.random() - 0.5) + center[0],\r\n                        height * (Math.random() - 0.5) + center[1]\r\n                    );\r\n                // }\r\n            }\r\n            n.pp = vec2.clone(n.p);\r\n            n.edges = null;\r\n        }\r\n\r\n        // Formula in 'Graph Drawing by Force-directed Placement'\r\n        // var k = scale * Math.sqrt(width * height / nodes.length);\r\n        // var k2 = k * k;\r\n\r\n        var friction = 0.6;\r\n\r\n        return {\r\n            warmUp: function () {\r\n                friction = 0.5;\r\n            },\r\n\r\n            setFixed: function (idx) {\r\n                nodes[idx].fixed = true;\r\n            },\r\n\r\n            setUnfixed: function (idx) {\r\n                nodes[idx].fixed = false;\r\n            },\r\n\r\n            step: function (cb) {\r\n                var v12 = [];\r\n                var nLen = nodes.length;\r\n                for (var i = 0; i < edges.length; i++) {\r\n                    var e = edges[i];\r\n                    var n1 = e.n1;\r\n                    var n2 = e.n2;\r\n\r\n                    vec2.sub(v12, n2.p, n1.p);\r\n                    var d = vec2.len(v12) - e.d;\r\n                    var w = n2.w / (n1.w + n2.w);\r\n                    vec2.normalize(v12, v12);\r\n\r\n                    !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);\r\n                    !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);\r\n                }\r\n                // Gravity\r\n                for (var i = 0; i < nLen; i++) {\r\n                    var n = nodes[i];\r\n                    if (!n.fixed) {\r\n                        vec2.sub(v12, center, n.p);\r\n                        // var d = vec2.len(v12);\r\n                        // vec2.scale(v12, v12, 1 / d);\r\n                        // var gravityFactor = gravity;\r\n                        vec2.scaleAndAdd(n.p, n.p, v12, gravity * friction);\r\n                    }\r\n                }\r\n\r\n                // Repulsive\r\n                // PENDING\r\n                for (var i = 0; i < nLen; i++) {\r\n                    var n1 = nodes[i];\r\n                    for (var j = i + 1; j < nLen; j++) {\r\n                        var n2 = nodes[j];\r\n                        vec2.sub(v12, n2.p, n1.p);\r\n                        var d = vec2.len(v12);\r\n                        if (d === 0) {\r\n                            // Random repulse\r\n                            vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);\r\n                            d = 1;\r\n                        }\r\n                        var repFact = (n1.rep + n2.rep) / d / d;\r\n                        !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);\r\n                        !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);\r\n                    }\r\n                }\r\n                var v = [];\r\n                for (var i = 0; i < nLen; i++) {\r\n                    var n = nodes[i];\r\n                    if (!n.fixed) {\r\n                        vec2.sub(v, n.p, n.pp);\r\n                        vec2.scaleAndAdd(n.p, n.p, v, friction);\r\n                        vec2.copy(n.pp, n.p);\r\n                    }\r\n                }\r\n\r\n                friction = friction * 0.992;\r\n\r\n                cb && cb(nodes, edges, friction < 0.01);\r\n            }\r\n        };\r\n    }\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/layout/forceHelper.js\n// module id = 130\n// module chunks = 0","/**\r\n * 工具类\r\n * @class fishTopoFlow.util\r\n */\r\n\r\n/**\r\n * @method initImagePool\r\n * 初始化图片池  用于对图片加载进行管理\r\n * @param {number} max 最大连接数。数值。\r\n * @returns {{load: Function, info: Function}}\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n        var imagepool = fishTopoFlow.util.initImagePool(100);\r\n        imagepool.load(grayArray, {\r\n            success: function(imgs) {\r\n            },\r\n            once: true\r\n        });\r\n */\r\n\r\n/**\r\n * @method inherits\r\n * 构造类继承关系\r\n *\r\n * @param {Function} clazz 源类\r\n * @param {Function} baseClazz 基类\r\n */\r\n\r\n\r\n    var emptyFn = function() {};\r\n    //初始默认配置\r\n    var config_default = {\r\n        //线程池\"线程\"数量\r\n        thread: 5,\r\n        //图片加载失败重试次数\r\n        //重试2次，加上原有的一次，总共是3次\r\n        \"tries\": 2\r\n    };\r\n    //工具\r\n    var _helpers = {\r\n        //设置dom属性\r\n        setAttr: (function() {\r\n            var img = new Image();\r\n            //判断浏览器是否支持HTML5 dataset\r\n            if (img.dataset) {\r\n                return function(dom, name, value) {\r\n                    dom.dataset[name] = value;\r\n                    return value;\r\n                };\r\n            } else {\r\n                return function(dom, name, value) {\r\n                    dom.setAttribute(\"data-\" + name, value);\r\n                    return value;\r\n                };\r\n            }\r\n        }()),\r\n        //获取dom属性\r\n        getAttr: (function() {\r\n            var img = new Image();\r\n            //判断浏览器是否支持HTML5 dataset\r\n            if (img.dataset) {\r\n                return function(dom, name) {\r\n                    if(!dom.dataset[name]){\r\n                        return dom.getAttribute(\"data-\" + name);\r\n                    }else{\r\n                        return dom.dataset[name];\r\n                    }\r\n                };\r\n            } else {\r\n                return function(dom, name) {\r\n                    return dom.getAttribute(\"data-\" + name);\r\n                };\r\n            }\r\n        }())\r\n    };\r\n    /**\r\n     * 构造方法\r\n     * @private\r\n     * @param max 最大连接数。数值。\r\n     */\r\n    function ImagePool(max) {\r\n        //最大并发数量\r\n        this.max = max || config_default.thread;\r\n        this.linkHead = null;\r\n        this.linkNode = null;\r\n        //加载池\r\n        //[{img: dom,free: true, node: node}]\r\n        //node\r\n        //{src: \"\", options: {success: \"fn\",error: \"fn\", once: true}, tries: 0}\r\n        this.pool = [];\r\n    }\r\n    /**\r\n     * 初始化\r\n     * @private\r\n     */\r\n    ImagePool.prototype.initPool = function() {\r\n        var i, img, obj, _s;\r\n        _s = this;\r\n        for (i = 0; i < this.max; i++) {\r\n            obj = {};\r\n            img = new Image();\r\n            _helpers.setAttr(img, \"id\", i);\r\n            img.onload = function() {\r\n                //回调\r\n                _s.notice(_s.getNode(this), \"success\", this);\r\n                //处理任务\r\n                _s.executeLink(this);\r\n            };\r\n            img.onerror = function() {\r\n                var node = _s.getNode(this);\r\n                //判断尝试次数\r\n                if (node.tries < config_default.tries) {\r\n                    node.tries = node.tries+1;\r\n                    //再次追加到任务链表末尾\r\n                    _s.appendNode(_s.createNode(node.src, node.options, node.notice, node.group, node.tries));\r\n                } else {\r\n                    //error回调\r\n                    //node.options.error.call(null, this.src);\r\n                    _s.notice(node, \"error\", this);\r\n                }\r\n                //处理任务\r\n                _s.executeLink(this);\r\n            };\r\n            obj.img = img;\r\n            obj.free = true;\r\n            this.pool.push(obj);\r\n        }\r\n    };\r\n    /**\r\n     * 回调封装\r\n     * @private\r\n     * @param node 节点。对象。\r\n     * @param status 状态。字符串。可选值：success(成功)|error(失败)\r\n     * @param img 图片。\r\n     */\r\n    ImagePool.prototype.notice = function(node, status, img) {\r\n        node.notice(status, img);\r\n    };\r\n    /**\r\n     * 处理链表任务\r\n     * @private\r\n     * @param dom 图像dom对象。对象。\r\n     */\r\n    ImagePool.prototype.executeLink = function(dom) {\r\n        //判断链表是否存在节点\r\n        if (this.linkHead) {\r\n            //加载下一个图片\r\n            this.setSrc(dom, this.linkHead);\r\n            //去除链表头\r\n            this.shiftNode();\r\n        } else {\r\n            //设置自身状态为空闲\r\n            this.status(dom, true);\r\n        }\r\n    };\r\n    /**\r\n     * 获取空闲\"线程\"\r\n     * @private\r\n     */\r\n    ImagePool.prototype.getFree = function() {\r\n        var length, i;\r\n        for (i = 0, length = this.pool.length; i < length; i++) {\r\n            if (this.pool[i].free) {\r\n                return this.pool[i];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * 封装src属性设置\r\n     * 因为改变src属性相当于加载图片，所以把操作封装起来\r\n     * @private\r\n     * @param dom 图像dom对象。对象。\r\n     * @param node 节点。对象。\r\n     */\r\n    ImagePool.prototype.setSrc = function(dom, node) {\r\n        //设置池中的\"线程\"为非空闲状态\r\n        this.status(dom, false);\r\n        //关联节点\r\n        this.setNode(dom, node);\r\n        //加载图片\r\n        dom.src = node.src;\r\n    };\r\n    /**\r\n     * 更新池中的\"线程\"状态\r\n     * @private\r\n     * @param dom 图像dom对象。对象。\r\n     * @param status 状态。布尔。可选值：true(空闲)|false(非空闲)\r\n     */\r\n    ImagePool.prototype.status = function(dom, status) {\r\n        var id = _helpers.getAttr(dom, \"id\");\r\n        if(id){\r\n            this.pool[id].free = status;\r\n        }\r\n\r\n        //空闲状态，清除关联的节点\r\n        if (status) {\r\n            this.pool[id].node = null;\r\n        }\r\n    };\r\n    /**\r\n     * 更新池中的\"线程\"的关联节点\r\n     * @private\r\n     * @param dom 图像dom对象。对象。\r\n     * @param node 节点。对象。\r\n     */\r\n    ImagePool.prototype.setNode = function(dom, node) {\r\n        var id = _helpers.getAttr(dom, \"id\");\r\n        if(id){\r\n            this.pool[id].node = node;\r\n            return this.pool[id].node === node;\r\n        }\r\n\r\n    };\r\n    /**\r\n     * 获取池中的\"线程\"的关联节点\r\n     * @private\r\n     * @param dom 图像dom对象。对象。\r\n     */\r\n    ImagePool.prototype.getNode = function(dom) {\r\n        var id = _helpers.getAttr(dom, \"id\");\r\n        if(id){\r\n            return this.pool[id].node;\r\n        }\r\n\r\n    };\r\n    /**\r\n     * 对外接口，加载图片\r\n     * @private\r\n     * @param src 可以是src字符串，也可以是src字符串数组。\r\n     * @param options 用户自定义参数。包含：success回调、error回调、once标识。\r\n     */\r\n    ImagePool.prototype._load = function(src, options) {\r\n        var srcs = [],\r\n            free = null,\r\n            length = 0,\r\n            i = 0,\r\n            //只初始化一次回调策略\r\n            notice = (function() {\r\n                if (options.once) {\r\n                    return function(status, img) {\r\n                        var g = this.group,\r\n                            o = this.options;\r\n                        //记录\r\n                        g[status].push(img);\r\n                        //判断改组是否全部处理完成\r\n                        if (g.success.length + g.error.length === g.count) {\r\n                            //异步\r\n                            //实际上是作为另一个任务单独执行，防止回调函数执行时间过长影响图片加载速度\r\n                            setTimeout(function() {\r\n                                o.success.call(null, g.success, g.error, g.count);\r\n                            }, 1);\r\n                        }\r\n                    };\r\n                } else {\r\n                    return function(status, img) {\r\n                        var o = this.options;\r\n                        //直接回调\r\n                        setTimeout(function() {\r\n                            o[status].call(null, img);\r\n                        }, 1);\r\n                    };\r\n                }\r\n            }()),\r\n            group = {\r\n                count: 0,\r\n                success: [],\r\n                error: []\r\n            },\r\n            node = null;\r\n        options = options || {};\r\n        options.success = options.success || emptyFn;\r\n        options.error = options.error || emptyFn;\r\n        srcs = srcs.concat(src);\r\n        //设置组元素个数\r\n        group.count = srcs.length;\r\n        //遍历需要加载的图片\r\n        for (i = 0, length = srcs.length; i < length; i++) {\r\n            //创建节点\r\n            node = this.createNode(srcs[i], options, notice, group);\r\n            //判断线程池是否有空闲\r\n            free = this.getFree();\r\n            if (free) {\r\n                //有空闲，则立即加载图片\r\n                this.setSrc(free.img, node);\r\n            } else {\r\n                //没有空闲，将任务添加到链表\r\n                this.appendNode(node);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * 获取内部状态信息\r\n     * @private\r\n     * @returns {Object}\r\n     */\r\n    ImagePool.prototype._info = function() {\r\n        var info = {},\r\n            length = 0,\r\n            i = 0,\r\n            node = null;\r\n        //线程\r\n        info.thread = {};\r\n        //线程总数量\r\n        info.thread.count = this.pool.length;\r\n        //空闲线程数量\r\n        info.thread.free = 0;\r\n        //任务\r\n        info.task = {};\r\n        //待处理任务数量\r\n        info.task.count = 0;\r\n        //获取空闲\"线程\"数量\r\n        for (i = 0, length = this.pool.length; i < length; i++) {\r\n            if (this.pool[i].free) {\r\n                info.thread.free = info.thread.free + 1;\r\n            }\r\n        }\r\n        //获取任务数量(任务链长度)\r\n        node = this.linkHead;\r\n        if (node) {\r\n            info.task.count = info.task.count + 1;\r\n            while (node.next) {\r\n                info.task.count = info.task.count + 1;\r\n                node = node.next;\r\n            }\r\n        }\r\n        return info;\r\n    };\r\n\r\n    /**\r\n     * 创建节点\r\n     * @private\r\n     * @param src 图片路径。字符串。\r\n     * @param options 用户自定义参数。包含：success回调、error回调、once标识。\r\n     * @param notice 回调策略。 函数。\r\n     * @param group 组信息。对象。{count: 0, success: [], error: []}\r\n     * @param tr 出错重试次数。数值。默认为0。\r\n     * @returns {Object}\r\n     */\r\n    ImagePool.prototype.createNode = function(src, options, notice, group, tr) {\r\n        var node = {};\r\n        node.src = src;\r\n        node.options = options;\r\n        node.notice = notice;\r\n        node.group = group;\r\n        node.tries = tr || 0;\r\n        return node;\r\n    };\r\n    /**\r\n     * 向任务链表末尾追加节点\r\n     * @private\r\n     * @param node 节点。对象。\r\n     */\r\n    ImagePool.prototype.appendNode = function(node) {\r\n        //判断链表是否为空\r\n        if (!this.linkHead) {\r\n            this.linkHead = node;\r\n            this.linkNode = node;\r\n        } else {\r\n            this.linkNode.next = node;\r\n            this.linkNode = node;\r\n        }\r\n    };\r\n    /**\r\n     * 删除链表头\r\n     * @private\r\n     */\r\n    ImagePool.prototype.shiftNode = function() {\r\n        //判断链表是否存在节点\r\n        if (this.linkHead) {\r\n            //修改链表头\r\n            this.linkHead = this.linkHead.next || null;\r\n        }\r\n    };\r\n    /**\r\n     * 初始化图片池\r\n     * @param {number} max 最大连接数。数值。\r\n     * @returns {{load: Function, info: Function}}\r\n     */\r\n    var initImagePool = function(max) {\r\n        var instance = new ImagePool(max);\r\n        instance.initPool();\r\n        return {\r\n            /**\r\n             * 加载图片\r\n             * @param {string|Array} src 可以是src字符串，也可以是src字符串数组。\r\n             * @param {Object} options 用户自定义参数。包含：success回调、error回调、once标识。\r\n             * @param {Function} [options.success] success回调\r\n             * @param {Function} [options.error] error回调\r\n             * @param {boolean} [options.once] 是否全部加载完毕后，一次回调\r\n             */\r\n            load: function() {\r\n                instance._load.apply(instance, arguments);\r\n            },\r\n            /**\r\n             * 获取内部状态信息\r\n             * @returns {Object}\r\n             */\r\n            info: function() {\r\n                return instance._info.call(instance);\r\n            }\r\n        };\r\n    };\r\n\r\n    module.exports = { initImagePool: initImagePool }\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-core/lib/ImagePool.js\n// module id = 131\n// module chunks = 0","\r\n    var TooltipContent = require('./TooltipContent');\r\n    var globalListener = require('./globalListener');\r\n    var Model = require('../../../fish-topo-core/lib/model');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var env = require('zrender/lib/core/env');\r\n    var flowUtil = require('../util/FlowUtil');\r\n    var layout = require(\"../layout/layout\");\r\n    function TooltipView(tooltipModel, api) {\r\n        this._tooltipContent = new TooltipContent(api.getDom(),api);\r\n        this._api = api;\r\n        this._tooltipModel = tooltipModel;\r\n        this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\r\n        this._initGloablListener();\r\n    }\r\n\r\n    TooltipView.prototype._initGloablListener = function() {\r\n        var triggerOn = this._tooltipModel.get('triggerOn');\r\n        // 当有 'click' | 'mousemove' | 'none' 事件时触发回调\r\n        globalListener.register(\r\n            'itemTooltip',\r\n            this._api,\r\n            function(currTrigger, e, dispatchAction){\r\n                if (triggerOn !== 'none') {\r\n                    if (triggerOn.indexOf(currTrigger) >= 0 ) {\r\n                        this._tryShow(e, dispatchAction);\r\n                    }\r\n                    else if (currTrigger === 'leave') {\r\n                        this._hide(dispatchAction)\r\n                    }\r\n                }\r\n            }.bind(this)\r\n        )\r\n    };\r\n\r\n    TooltipView.prototype._tryShow = function(e, dispatchAction) {\r\n            var el = e.target;\r\n            var tooltipModel = this._tooltipModel;\r\n\r\n            if (!tooltipModel) {\r\n                return;\r\n            }\r\n\r\n            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\r\n            this._lastX = e.offsetX;\r\n            this._lastY = e.offsetY;\r\n\r\n            if (el && el.tooltip) {\r\n                this._showComponentItemTooltip(e, el);\r\n            }\r\n            else {\r\n                this._hide(dispatchAction);\r\n            }\r\n    };\r\n\r\n     TooltipView.prototype._hide = function(dispatchAction) {\r\n            // Do not directly hideLater here, because this behavior may be prevented\r\n            // in dispatchAction when showTip is dispatched.\r\n\r\n            // FIXME\r\n            // duplicated hideTip if manuallyHideTip is called from dispatchAction.\r\n            this._lastDataByCoordSys = null;\r\n            dispatchAction({\r\n                type: 'hideTip',\r\n                from: this.uid\r\n            });\r\n            this.manuallyHideTip();\r\n        };\r\n\r\n       TooltipView.prototype.dispose = function () {\r\n            if (env.node) {\r\n                return;\r\n            }\r\n            this._tooltipContent.hide();\r\n            globalListener.unregister('itemTooltip', this._api);\r\n        };\r\n\r\n        TooltipView.prototype.manuallyHideTip = function () {\r\n            var tooltipContent = this._tooltipContent;\r\n\r\n            if (!this._alwaysShowContent) {\r\n                tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\r\n            }\r\n\r\n            this._lastX = this._lastY = null;\r\n\r\n\r\n        },\r\n\r\n    TooltipView.prototype._showComponentItemTooltip = function (e, el) {\r\n            var tooltipOpt = el.tooltip;\r\n            if (typeof tooltipOpt === 'string') {\r\n                var content = tooltipOpt;\r\n                tooltipOpt = {\r\n                    content: content,\r\n                    // Fixed formatter\r\n                    formatter: content\r\n                };\r\n            }\r\n            var subTooltipModel = new Model(tooltipOpt, this._tooltipModel);\r\n            var defaultHtml = subTooltipModel.get('content');\r\n            var asyncTicket = Math.random();\r\n\r\n            // Do not check whether `trigger` is 'none' here, because `trigger`\r\n            // only works on cooridinate system. In fact, we have not found case\r\n            // that requires setting `trigger` nothing on component yet.\r\n\r\n            this._showOrMove(subTooltipModel, function () {\r\n                this._showTooltipContent(\r\n                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\r\n                    asyncTicket, e.offsetX, e.offsetY, e.position, el\r\n                );\r\n            });\r\n\r\n\r\n        };\r\n\r\n      TooltipView.prototype._showOrMove = function (tooltipModel, cb) {\r\n            // showDelay is used in this case: tooltip.enterable is set\r\n            // as true. User intent to move mouse into tooltip and click\r\n            // something. `showDelay` makes it easyer to enter the content\r\n            // but tooltip do not move immediately.\r\n            var delay = tooltipModel.get('showDelay');\r\n            cb = zrUtil.bind(cb, this);\r\n            clearTimeout(this._showTimout);\r\n            delay > 0\r\n                ? (this._showTimout = setTimeout(cb, delay))\r\n                : cb();\r\n        };\r\n\r\n        TooltipView.prototype._showTooltipContent = function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {\r\n            // Reset ticket\r\n            this._ticket = '';\r\n\r\n            if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\r\n                return;\r\n            }\r\n\r\n            var tooltipContent = this._tooltipContent;\r\n\r\n            var formatter = tooltipModel.get('formatter');\r\n            positionExpr = positionExpr || tooltipModel.get('position');\r\n            var html = defaultHtml;\r\n\r\n            if (formatter && typeof formatter === 'string') {\r\n                html = flowUtil.formatTpl(formatter, params, true);\r\n            }\r\n            else if (typeof formatter === 'function') {\r\n                var callback = function (cbTicket, html) {\r\n                    if (cbTicket === this._ticket) {\r\n                        tooltipContent.setContent(html);\r\n                        this._updatePosition(\r\n                            tooltipModel, positionExpr, x, y, tooltipContent, params, el\r\n                        );\r\n                    }\r\n                }.bind(this);\r\n                this._ticket = asyncTicket;\r\n                html = formatter(params, asyncTicket, callback);\r\n            }\r\n\r\n            tooltipContent.setContent(html);\r\n            tooltipContent.show(tooltipModel);\r\n\r\n            this._updatePosition(\r\n                tooltipModel, positionExpr, x, y, tooltipContent, params, el\r\n            );\r\n        };\r\n\r\n        /**\r\n         * @param  {string|Function|Array.<number>} positionExpr\r\n         * @param  {number} x Mouse x\r\n         * @param  {number} y Mouse y\r\n         * @param  {boolean} confine Whether confine tooltip content in view rect.\r\n         * @param  {Object|<Array.<Object>} params\r\n         * @param  {module:zrender/Element} el target element\r\n         * @param  {module:echarts/ExtensionAPI} api\r\n         * @return {Array.<number>}\r\n         */\r\n        TooltipView.prototype._updatePosition = function (tooltipModel, positionExpr, x, y, content, params, el) {\r\n            var viewWidth = this._api.getWidth();\r\n            var viewHeight = this._api.getHeight();\r\n            positionExpr = positionExpr || tooltipModel.get('position');\r\n\r\n            var contentSize = content.getSize();\r\n            var align = tooltipModel.get('align');\r\n            var vAlign = tooltipModel.get('verticalAlign');\r\n            var rect = el && el.getBoundingRect().clone();\r\n            el && rect.applyTransform(el.transform);\r\n\r\n            if (typeof positionExpr === 'function') {\r\n                // Callback of position can be an array or a string specify the position\r\n                positionExpr = positionExpr([x, y], params, content.el, rect, {\r\n                    viewSize: [viewWidth, viewHeight],\r\n                    contentSize: contentSize.slice()\r\n                });\r\n            }\r\n\r\n            if (zrUtil.isArray(positionExpr)) {\r\n                x = flowUtil.parsePercent(positionExpr[0], viewWidth);\r\n                y = flowUtil.parsePercent(positionExpr[1], viewHeight);\r\n            }\r\n            else if (zrUtil.isObject(positionExpr)) {\r\n                positionExpr.width = contentSize[0];\r\n                positionExpr.height = contentSize[1];\r\n                var layoutRect = layout.getLayoutRect(\r\n                    positionExpr, {width: viewWidth, height: viewHeight}\r\n                );\r\n                x = layoutRect.x;\r\n                y = layoutRect.y;\r\n                align = null;\r\n                // When positionExpr is left/top/right/bottom,\r\n                // align and verticalAlign will not work.\r\n                vAlign = null;\r\n            }\r\n            // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\r\n            else if (typeof positionExpr === 'string' && el) {\r\n                var pos = calcTooltipPosition(\r\n                    positionExpr, rect, contentSize\r\n                );\r\n                x = pos[0];\r\n                y = pos[1];\r\n            }\r\n            else {\r\n                var pos1 = refixTooltipPosition(\r\n                    x, y, content.el, viewWidth, viewHeight, align ? 0 : 20, vAlign ? 0 : 20\r\n                );\r\n                x = pos1[0];\r\n                y = pos1[1];\r\n            }\r\n\r\n            align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\r\n            vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\r\n\r\n            if (tooltipModel.get('confine')) {\r\n                var pos2 = confineTooltipPosition(\r\n                    x, y, content.el, viewWidth, viewHeight\r\n                );\r\n                x = pos2[0];\r\n                y = pos2[1];\r\n            }\r\n\r\n            content.moveTo(x, y);\r\n        }\r\n\r\n    function calcTooltipPosition(position, rect, contentSize) {\r\n        var domWidth = contentSize[0];\r\n        var domHeight = contentSize[1];\r\n        var gap = 5;\r\n        var x = 0;\r\n        var y = 0;\r\n        var rectWidth = rect.width;\r\n        var rectHeight = rect.height;\r\n        switch (position) {\r\n            case 'inside':\r\n                x = rect.x + rectWidth / 2 - domWidth / 2;\r\n                y = rect.y + rectHeight / 2 - domHeight / 2;\r\n                break;\r\n            case 'top':\r\n                x = rect.x + rectWidth / 2 - domWidth / 2;\r\n                y = rect.y - domHeight - gap;\r\n                break;\r\n            case 'bottom':\r\n                x = rect.x + rectWidth / 2 - domWidth / 2;\r\n                y = rect.y + rectHeight + gap;\r\n                break;\r\n            case 'left':\r\n                x = rect.x - domWidth - gap;\r\n                y = rect.y + rectHeight / 2 - domHeight / 2;\r\n                break;\r\n            case 'right':\r\n                x = rect.x + rectWidth + gap;\r\n                y = rect.y + rectHeight / 2 - domHeight / 2;\r\n        }\r\n        return [x, y];\r\n    }\r\n    function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\r\n        var width = el.clientWidth;\r\n        var height = el.clientHeight;\r\n\r\n        if (x + width + gapH > viewWidth) {\r\n            x -= width + gapH;\r\n        }\r\n        else {\r\n            x += gapH;\r\n        }\r\n        if (y + height + gapV > viewHeight) {\r\n            y -= height + gapV;\r\n        }\r\n        else {\r\n            y += gapV;\r\n        }\r\n        return [x, y];\r\n    }\r\n\r\n    function isCenterAlign(align) {\r\n        return align === 'center' || align === 'middle';\r\n    }\r\n\r\n    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\r\n        var width = el.clientWidth;\r\n        var height = el.clientHeight;\r\n\r\n        x = Math.min(x + width, viewWidth) - width;\r\n        y = Math.min(y + height, viewHeight) - height;\r\n        x = Math.max(x, 0);\r\n        y = Math.max(y, 0);\r\n\r\n        return [x, y];\r\n    }\r\n    module.exports = TooltipView;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/tooltip/TooltipView.js\n// module id = 132\n// module chunks = 0","\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var zrColor = require('zrender/lib/tool/color');\r\n    var env = require('zrender/lib/core/env');\r\n    var eventUtil = require('zrender/lib/core/event');\r\n    var flowUtil = require('../util/FlowUtil');\r\n    var toCamelCase = flowUtil.toCamelCase;\r\n    var normalizeCssArray = flowUtil.normalizeCssArray;\r\n    var each = zrUtil.each;\r\n\r\n\r\n    var vendors = ['', '-webkit-', '-moz-', '-o-'];\r\n\r\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:999;';//fish popup zindex:1050\r\n    /**\r\n     * @param {number} duration\r\n     * @return {string}\r\n     * @inner\r\n     */\r\n    function assembleTransition(duration) {\r\n        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\r\n        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\r\n                            + 'top ' + duration + 's ' + transitionCurve;\r\n        return zrUtil.map(vendors, function (vendorPrefix) {\r\n            return vendorPrefix + 'transition:' + transitionText;\r\n        }).join(';');\r\n    }\r\n\r\n    /**\r\n     * @param {Object} textStyle\r\n     * @return {string}\r\n     * @inner\r\n     */\r\n    function assembleFont(textStyleModel) {\r\n        var cssText = [];\r\n\r\n        var fontSize = textStyleModel.get('fontSize');\r\n        var color = textStyleModel.get(\"color\");\r\n\r\n        color && cssText.push('color:' + color);\r\n\r\n        var font = textStyleModel.get(\"font\");\r\n        font && cssText.push('font:' + font);\r\n\r\n        fontSize &&\r\n            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\r\n\r\n        each(['decoration', 'align'], function (name) {\r\n            var val = textStyleModel.get(name);\r\n            val && cssText.push('text-' + name + ':' + val);\r\n        });\r\n\r\n        return cssText.join(';');\r\n    }\r\n    /**\r\n     * @param {Object} tooltipModel\r\n     * @return {string}\r\n     * @inner\r\n     */\r\n    function assembleCssText(tooltipModel) {\r\n\r\n        var cssText = [];\r\n\r\n        var transitionDuration = tooltipModel.get('transitionDuration');\r\n        var backgroundColor = tooltipModel.get('backgroundColor');\r\n        var textStyleModel = tooltipModel.getModel('textStyle');\r\n        var padding = tooltipModel.get('padding');\r\n\r\n        // Animation transition. Do not animate when transitionDuration is 0.\r\n        transitionDuration &&\r\n            cssText.push(assembleTransition(transitionDuration));\r\n\r\n        if (backgroundColor) {\r\n            if (env.canvasSupported) {\r\n                cssText.push('background-Color:' + backgroundColor);\r\n            }\r\n            else {\r\n                // for ie\r\n                cssText.push(\r\n                    'background-Color:#' + zrColor.toHex(backgroundColor)\r\n                );\r\n                cssText.push('filter:alpha(opacity=70)');\r\n            }\r\n        }\r\n\r\n        // Border style\r\n        each(['width', 'color', 'radius'], function (name) {\r\n            var borderName = 'border-' + name;\r\n            var camelCase = toCamelCase(borderName);\r\n            var val = tooltipModel.get(camelCase);\r\n            val != null &&\r\n                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\r\n        });\r\n\r\n        // Text style\r\n        cssText.push(assembleFont(textStyleModel));\r\n\r\n        // Padding\r\n        if (padding != null) {\r\n            cssText.push('padding:' + normalizeCssArray(padding).join('px ') + 'px');\r\n        }\r\n\r\n        return cssText.join(';') + ';';\r\n    }\r\n    /**\r\n     *\r\n     *\r\n     * @param {any} container\r\n     * @param {any} api\r\n     */\r\n    function TooltipContent(container, api) {\r\n        var el = document.createElement('div');\r\n        var zr = this._zr = api.getZr();\r\n\r\n        this.el = el;\r\n\r\n        this._x = api.getWidth() / 2;\r\n        this._y = api.getHeight() / 2;\r\n\r\n        container.appendChild(el);\r\n\r\n        this._container = container;\r\n\r\n        this._show = false;\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        this._hideTimeout;\r\n\r\n        var self = this;\r\n        el.onmouseenter = function () {\r\n            // clear the timeout in hideLater and keep showing tooltip\r\n            if (self._enterable) {\r\n                clearTimeout(self._hideTimeout);\r\n                self._show = true;\r\n            }\r\n            self._inContent = true;\r\n        };\r\n        el.onmousemove = function (e) {\r\n            e = e || window.event;\r\n            if (!self._enterable) {\r\n                // Try trigger zrender event to avoid mouse\r\n                // in and out shape too frequently\r\n                var handler = zr.handler;\r\n                eventUtil.normalizeEvent(container, e, true);\r\n                handler.dispatch('mousemove', e);\r\n            }\r\n        };\r\n        el.onmouseleave = function () {\r\n            if (self._enterable) {\r\n                if (self._show) {\r\n                    self.hideLater(self._hideDelay);\r\n                }\r\n            }\r\n            self._inContent = false;\r\n        };\r\n    }\r\n    TooltipContent.prototype = {\r\n\r\n        constructor: TooltipContent,\r\n\r\n        /**\r\n         * @private\r\n         * @type {boolean}\r\n         */\r\n        _enterable: true,\r\n\r\n        /**\r\n         * Update when tooltip is rendered\r\n         */\r\n        update: function () {\r\n            // FIXME\r\n            // Move this logic to ec main?\r\n            var container = this._container;\r\n            var stl = container.currentStyle\r\n                || document.defaultView.getComputedStyle(container);\r\n            var domStyle = container.style;\r\n            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\r\n                domStyle.position = 'relative';\r\n            }\r\n            // Hide the tooltip\r\n            // PENDING\r\n            // this.hide();\r\n        },\r\n\r\n        show: function (tooltipModel) {\r\n            clearTimeout(this._hideTimeout);\r\n            var el = this.el;\r\n\r\n            el.style.cssText = gCssText + assembleCssText(tooltipModel)\r\n                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\r\n                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\r\n                + (tooltipModel.get('extraCssText') || '');\r\n\r\n            el.style.display = el.innerHTML ?  'block' : 'none';\r\n\r\n            this._show = true;\r\n        },\r\n\r\n        setContent: function (content) {\r\n            this.el.innerHTML = content;\r\n        },\r\n\r\n        setEnterable: function (enterable) {\r\n            this._enterable = enterable;\r\n        },\r\n\r\n        getSize: function () {\r\n            var el = this.el;\r\n            return [el.clientWidth, el.clientHeight];\r\n        },\r\n\r\n        moveTo: function (x, y) {\r\n            // xy should be based on canvas root. But tooltipContent is\r\n            // the sibling of canvas root. So padding of ec container\r\n            // should be considered here.\r\n            var zr = this._zr;\r\n            var viewportRoot;\r\n            if (zr && zr.painter && (viewportRoot = zr.painter.getViewportRoot())) {\r\n                x += viewportRoot.offsetLeft || 0;\r\n                y += viewportRoot.offsetTop || 0;\r\n            }\r\n\r\n            var style = this.el.style;\r\n            style.left = x + 'px';\r\n            style.top = y + 'px';\r\n\r\n            this._x = x;\r\n            this._y = y;\r\n        },\r\n\r\n        hide: function () {\r\n            this.el.style.display = 'none';\r\n            this._show = false;\r\n        },\r\n\r\n        hideLater: function (time) {\r\n            if (this._show && !(this._inContent && this._enterable)) {\r\n                if (time) {\r\n                    this._hideDelay = time;\r\n                    // Set show false to avoid invoke hideLater mutiple times\r\n                    this._show = false;\r\n                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\r\n                }\r\n                else {\r\n                    this.hide();\r\n                }\r\n            }\r\n        },\r\n\r\n        isShow: function () {\r\n            return this._show;\r\n        }\r\n    };\r\n\r\n    module.exports = TooltipContent;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/tooltip/TooltipContent.js\n// module id = 133\n// module chunks = 0","\r\n\r\n    var env = require('zrender/lib/core/env');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var get = require('../util/FlowUtil').makeGetter();\r\n\r\n    var each = zrUtil.each;\r\n\r\n    var globalListener = {};\r\n\r\n    /**\r\n     * @param key 注册的字符串\r\n     * @param api ExtensionAPI\r\n     * @param handler 处理回调\r\n     */\r\n    globalListener.register = function (key, api, handler) {\r\n        if (env.node) {   //node环境下不执行\r\n            return;\r\n        }\r\n        //判断zrender的 records  并初始化\r\n        var zr = api.getZr();\r\n        get(zr).records || (get(zr).records = {});\r\n\r\n        initGlobalListeners(zr, api);\r\n\r\n        //将回调加入record\r\n        var record = get(zr).records[key] || (get(zr).records[key] = {});\r\n        record.handler = handler;\r\n    };\r\n\r\n    /**\r\n     * 初始化全局侦听\r\n     *\r\n     * @param {object} zr   zrender\r\n     * @param {object} api  ExtensionAPI\r\n     * @returns\r\n     */\r\n    function initGlobalListeners(zr, api) {\r\n        if (get(zr).initialized) {   //避免重复初始化\r\n            return;\r\n        }\r\n\r\n        get(zr).initialized = true;\r\n\r\n        //侦听事件\r\n        useHandler('click', zrUtil.curry(doEnter, 'click'));\r\n        useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove'));\r\n        // useHandler('mouseout', onLeave);\r\n        useHandler('globalout', onLeave);\r\n\r\n        function useHandler(eventType, cb) {\r\n            zr.on(eventType, function (e) {\r\n                var dis = makeDispatchAction(api);\r\n                //遍历注册的 所有records， 并进行调用\r\n                each(get(zr).records, function (record) {\r\n                    record && cb(record, e, dis.dispatchAction);\r\n                });\r\n\r\n                dispatchTooltipFinally(dis.pendings, api);\r\n            });\r\n        }\r\n    }\r\n\r\n    function dispatchTooltipFinally(pendings, api) {\r\n        var showLen = pendings.showTip.length;\r\n        var hideLen = pendings.hideTip.length;\r\n\r\n        var actuallyPayload;\r\n        if (showLen) {\r\n            actuallyPayload = pendings.showTip[showLen - 1];\r\n        }\r\n        else if (hideLen) {\r\n            actuallyPayload = pendings.hideTip[hideLen - 1];\r\n        }\r\n        if (actuallyPayload) {\r\n            actuallyPayload.dispatchAction = null;\r\n            api.dispatchAction(actuallyPayload);\r\n        }\r\n    }\r\n\r\n    function onLeave(record, e, dispatchAction) {\r\n        record.handler('leave', null, dispatchAction);\r\n    }\r\n\r\n    function doEnter(currTrigger, record, e, dispatchAction) {\r\n        record.handler(currTrigger, e, dispatchAction);\r\n    }\r\n\r\n    /**\r\n     * 派发action   行将发生的\r\n     *\r\n     * @param {any} api\r\n     * @returns\r\n     */\r\n    function makeDispatchAction(api) {\r\n        var pendings = {\r\n            showTip: [],\r\n            hideTip: []\r\n        };\r\n        // FIXME\r\n        // better approach?\r\n        // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\r\n        // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\r\n        // So we have to add \"final stage\" to merge those dispatched actions.\r\n        var dispatchAction = function (payload) {\r\n            var pendingList = pendings[payload.type];\r\n            if (pendingList) {\r\n                pendingList.push(payload);\r\n            }\r\n            else {\r\n                payload.dispatchAction = dispatchAction;\r\n                api.dispatchAction(payload);\r\n            }\r\n        };\r\n\r\n        return {\r\n            dispatchAction: dispatchAction,\r\n            pendings: pendings\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @param {string} key\r\n     * @param {module:echarts/ExtensionAPI} api\r\n     */\r\n    globalListener.unregister = function (key, api) {\r\n        if (env.node) {\r\n            return;\r\n        }\r\n        var zr = api.getZr();\r\n        var record = (get(zr).records || {})[key];\r\n        if (record) {\r\n            get(zr).records[key] = null;\r\n        }\r\n    };\r\n\r\n    module.exports = globalListener;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/tooltip/globalListener.js\n// module id = 134\n// module chunks = 0","\r\n\r\n    var Model = require('../../../fish-topo-core/lib/model');\r\n    module.exports = Model.extend({\r\n\r\n        type: 'tooltip',\r\n\r\n        defaultOption: {\r\n            zlevel: 0,\r\n\r\n            z: 8,\r\n\r\n            show: true,\r\n\r\n            // tooltip主体内容\r\n            showContent: true,\r\n\r\n\r\n\r\n            // 'click' | 'mousemove' | 'none'\r\n            triggerOn: 'mousemove',\r\n\r\n            alwaysShowContent: false,\r\n\r\n            displayMode: 'single', // 'single' | 'multipleByCoordSys'\r\n\r\n            // 位置 {Array} | {Function}\r\n            // position: null\r\n            // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\r\n            // align: null,\r\n            // verticalAlign: null,\r\n\r\n            // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。\r\n            confine: false,\r\n\r\n            // 内容格式器：{string}（Template） ¦ {Function}\r\n            // formatter: null\r\n\r\n            showDelay: 0,\r\n\r\n            // 隐藏延迟，单位ms\r\n            hideDelay: 100,\r\n\r\n            // 动画变换时间，单位s\r\n            transitionDuration: 0.4,\r\n\r\n            enterable: false,\r\n\r\n            // 提示背景颜色，默认为透明度为0.7的黑色\r\n            backgroundColor: 'rgba(50,50,50,0.7)',\r\n\r\n            // 提示边框颜色\r\n            borderColor: '#333',\r\n\r\n            // 提示边框圆角，单位px，默认为4\r\n            borderRadius: 4,\r\n\r\n            // 提示边框线宽，单位px，默认为0（无边框）\r\n            borderWidth: 0,\r\n\r\n            // 提示内边距，单位px，默认各方向内边距为5，\r\n            // 接受数组分别设定上右下左边距，同css\r\n            padding: 5,\r\n\r\n            // Extra css text\r\n            extraCssText: '',\r\n\r\n            textStyle: {\r\n                color: '#fff',\r\n                fontSize: 14\r\n            }\r\n        }\r\n    });\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/fish-topo-flow/lib/tooltip/TooltipModel.js\n// module id = 135\n// module chunks = 0","\n    require('./graphic');\n    require('../zrender').registerPainter('vml', require('./Painter'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/vml/vml.js\n// module id = 136\n// module chunks = 0","// http://www.w3.org/TR/NOTE-VML\n// TODO Use proxy like svg instead of overwrite brush methods\n\n\nif (!require('../core/env').canvasSupported) {\n    var vec2 = require('../core/vector');\n    var BoundingRect = require('../core/BoundingRect');\n    var CMD = require('../core/PathProxy').CMD;\n    var colorTool = require('../tool/color');\n    var textContain = require('../contain/text');\n    var textHelper = require('../graphic/helper/text');\n    var RectText = require('../graphic/mixin/RectText');\n    var Displayable = require('../graphic/Displayable');\n    var ZImage = require('../graphic/Image');\n    var Text = require('../graphic/Text');\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n\n    var Gradient = require('../graphic/Gradient');\n\n    var vmlCore = require('./core');\n\n    var round = Math.round;\n    var sqrt = Math.sqrt;\n    var abs = Math.abs;\n    var cos = Math.cos;\n    var sin = Math.sin;\n    var mathMax = Math.max;\n\n    var applyTransform = vec2.applyTransform;\n\n    var comma = ',';\n    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\n    var Z = 21600;\n    var Z2 = Z / 2;\n\n    var ZLEVEL_BASE = 100000;\n    var Z_BASE = 1000;\n\n    var initRootElStyle = function (el) {\n        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n        el.coordsize = Z + ','  + Z;\n        el.coordorigin = '0,0';\n    };\n\n    var encodeHtmlAttribute = function (s) {\n        return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n    };\n\n    var rgb2Str = function (r, g, b) {\n        return 'rgb(' + [r, g, b].join(',') + ')';\n    };\n\n    var append = function (parent, child) {\n        if (child && parent && child.parentNode !== parent) {\n            parent.appendChild(child);\n        }\n    };\n\n    var remove = function (parent, child) {\n        if (child && parent && child.parentNode === parent) {\n            parent.removeChild(child);\n        }\n    };\n\n    var getZIndex = function (zlevel, z, z2) {\n        // z 的取值范围为 [0, 1000]\n        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n    };\n\n    var parsePercent = function (value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    };\n\n    /***************************************************\n     * PATH\n     **************************************************/\n\n    var setColorAndOpacity = function (el, color, opacity) {\n        var colorArr = colorTool.parse(color);\n        opacity = +opacity;\n        if (isNaN(opacity)) {\n            opacity = 1;\n        }\n        if (colorArr) {\n            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n            el.opacity = opacity * colorArr[3];\n        }\n    };\n\n    var getColorAndAlpha = function (color) {\n        var colorArr = colorTool.parse(color);\n        return [\n            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),\n            colorArr[3]\n        ];\n    };\n\n    var updateFillNode = function (el, style, zrEl) {\n        // TODO pattern\n        var fill = style.fill;\n        if (fill != null) {\n            // Modified from excanvas\n            if (fill instanceof Gradient) {\n                var gradientType;\n                var angle = 0;\n                var focus = [0, 0];\n                // additional offset\n                var shift = 0;\n                // scale factor for offset\n                var expansion = 1;\n                var rect = zrEl.getBoundingRect();\n                var rectWidth = rect.width;\n                var rectHeight = rect.height;\n                if (fill.type === 'linear') {\n                    gradientType = 'gradient';\n                    var transform = zrEl.transform;\n                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n                    if (transform) {\n                        applyTransform(p0, p0, transform);\n                        applyTransform(p1, p1, transform);\n                    }\n                    var dx = p1[0] - p0[0];\n                    var dy = p1[1] - p0[1];\n                    angle = Math.atan2(dx, dy) * 180 / Math.PI;\n                    // The angle should be a non-negative number.\n                    if (angle < 0) {\n                        angle += 360;\n                    }\n\n                    // Very small angles produce an unexpected result because they are\n                    // converted to a scientific notation string.\n                    if (angle < 1e-6) {\n                        angle = 0;\n                    }\n                }\n                else {\n                    gradientType = 'gradientradial';\n                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n                    var transform = zrEl.transform;\n                    var scale = zrEl.scale;\n                    var width = rectWidth;\n                    var height = rectHeight;\n                    focus = [\n                        // Percent in bounding rect\n                        (p0[0] - rect.x) / width,\n                        (p0[1] - rect.y) / height\n                    ];\n                    if (transform) {\n                        applyTransform(p0, p0, transform);\n                    }\n\n                    width /= scale[0] * Z;\n                    height /= scale[1] * Z;\n                    var dimension = mathMax(width, height);\n                    shift = 2 * 0 / dimension;\n                    expansion = 2 * fill.r / dimension - shift;\n                }\n\n                // We need to sort the color stops in ascending order by offset,\n                // otherwise IE won't interpret it correctly.\n                var stops = fill.colorStops.slice();\n                stops.sort(function(cs1, cs2) {\n                    return cs1.offset - cs2.offset;\n                });\n\n                var length = stops.length;\n                // Color and alpha list of first and last stop\n                var colorAndAlphaList = [];\n                var colors = [];\n                for (var i = 0; i < length; i++) {\n                    var stop = stops[i];\n                    var colorAndAlpha = getColorAndAlpha(stop.color);\n                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n                    if (i === 0 || i === length - 1) {\n                        colorAndAlphaList.push(colorAndAlpha);\n                    }\n                }\n\n                if (length >= 2) {\n                    var color1 = colorAndAlphaList[0][0];\n                    var color2 = colorAndAlphaList[1][0];\n                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\n                    el.type = gradientType;\n                    el.method = 'none';\n                    el.focus = '100%';\n                    el.angle = angle;\n                    el.color = color1;\n                    el.color2 = color2;\n                    el.colors = colors.join(',');\n                    // When colors attribute is used, the meanings of opacity and o:opacity2\n                    // are reversed.\n                    el.opacity = opacity2;\n                    // FIXME g_o_:opacity ?\n                    el.opacity2 = opacity1;\n                }\n                if (gradientType === 'radial') {\n                    el.focusposition = focus.join(',');\n                }\n            }\n            else {\n                // FIXME Change from Gradient fill to color fill\n                setColorAndOpacity(el, fill, style.opacity);\n            }\n        }\n    };\n\n    var updateStrokeNode = function (el, style) {\n        // if (style.lineJoin != null) {\n        //     el.joinstyle = style.lineJoin;\n        // }\n        // if (style.miterLimit != null) {\n        //     el.miterlimit = style.miterLimit * Z;\n        // }\n        // if (style.lineCap != null) {\n        //     el.endcap = style.lineCap;\n        // }\n        if (style.lineDash != null) {\n            el.dashstyle = style.lineDash.join(' ');\n        }\n        if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n            setColorAndOpacity(el, style.stroke, style.opacity);\n        }\n    };\n\n    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n        var isFill = type == 'fill';\n        var el = vmlEl.getElementsByTagName(type)[0];\n        // Stroke must have lineWidth\n        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {\n            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';\n            // FIXME Remove before updating, or set `colors` will throw error\n            if (style[type] instanceof Gradient) {\n                remove(vmlEl, el);\n            }\n            if (!el) {\n                el = vmlCore.createNode(type);\n            }\n\n            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n            append(vmlEl, el);\n        }\n        else {\n            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n            remove(vmlEl, el);\n        }\n    };\n\n    var points = [[], [], []];\n    var pathDataToString = function (data, m) {\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        var str = [];\n        var nPoint;\n        var cmdStr;\n        var cmd;\n        var i;\n        var xi;\n        var yi;\n        for (i = 0; i < data.length;) {\n            cmd = data[i++];\n            cmdStr = '';\n            nPoint = 0;\n            switch (cmd) {\n                case M:\n                    cmdStr = ' m ';\n                    nPoint = 1;\n                    xi = data[i++];\n                    yi = data[i++];\n                    points[0][0] = xi;\n                    points[0][1] = yi;\n                    break;\n                case L:\n                    cmdStr = ' l ';\n                    nPoint = 1;\n                    xi = data[i++];\n                    yi = data[i++];\n                    points[0][0] = xi;\n                    points[0][1] = yi;\n                    break;\n                case Q:\n                case C:\n                    cmdStr = ' c ';\n                    nPoint = 3;\n                    var x1 = data[i++];\n                    var y1 = data[i++];\n                    var x2 = data[i++];\n                    var y2 = data[i++];\n                    var x3;\n                    var y3;\n                    if (cmd === Q) {\n                        // Convert quadratic to cubic using degree elevation\n                        x3 = x2;\n                        y3 = y2;\n                        x2 = (x2 + 2 * x1) / 3;\n                        y2 = (y2 + 2 * y1) / 3;\n                        x1 = (xi + 2 * x1) / 3;\n                        y1 = (yi + 2 * y1) / 3;\n                    }\n                    else {\n                        x3 = data[i++];\n                        y3 = data[i++];\n                    }\n                    points[0][0] = x1;\n                    points[0][1] = y1;\n                    points[1][0] = x2;\n                    points[1][1] = y2;\n                    points[2][0] = x3;\n                    points[2][1] = y3;\n\n                    xi = x3;\n                    yi = y3;\n                    break;\n                case A:\n                    var x = 0;\n                    var y = 0;\n                    var sx = 1;\n                    var sy = 1;\n                    var angle = 0;\n                    if (m) {\n                        // Extract SRT from matrix\n                        x = m[4];\n                        y = m[5];\n                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n                        angle = Math.atan2(-m[1] / sy, m[0] / sx);\n                    }\n\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var startAngle = data[i++] + angle;\n                    var endAngle = data[i++] + startAngle + angle;\n                    // FIXME\n                    // var psi = data[i++];\n                    i++;\n                    var clockwise = data[i++];\n\n                    var x0 = cx + cos(startAngle) * rx;\n                    var y0 = cy + sin(startAngle) * ry;\n\n                    var x1 = cx + cos(endAngle) * rx;\n                    var y1 = cy + sin(endAngle) * ry;\n\n                    var type = clockwise ? ' wa ' : ' at ';\n                    if (Math.abs(x0 - x1) < 1e-4) {\n                        // IE won't render arches drawn counter clockwise if x0 == x1.\n                        if (Math.abs(endAngle - startAngle) > 1e-2) {\n                            // Offset x0 by 1/80 of a pixel. Use something\n                            // that can be represented in binary\n                            if (clockwise) {\n                                x0 += 270 / Z;\n                            }\n                        }\n                        else {\n                            // Avoid case draw full circle\n                            if (Math.abs(y0 - cy) < 1e-4) {\n                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {\n                                    y1 -= 270 / Z;\n                                }\n                                else {\n                                    y1 += 270 / Z;\n                                }\n                            }\n                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {\n                                x1 += 270 / Z;\n                            }\n                            else {\n                                x1 -= 270 / Z;\n                            }\n                        }\n                    }\n                    str.push(\n                        type,\n                        round(((cx - rx) * sx + x) * Z - Z2), comma,\n                        round(((cy - ry) * sy + y) * Z - Z2), comma,\n                        round(((cx + rx) * sx + x) * Z - Z2), comma,\n                        round(((cy + ry) * sy + y) * Z - Z2), comma,\n                        round((x0 * sx + x) * Z - Z2), comma,\n                        round((y0 * sy + y) * Z - Z2), comma,\n                        round((x1 * sx + x) * Z - Z2), comma,\n                        round((y1 * sy + y) * Z - Z2)\n                    );\n\n                    xi = x1;\n                    yi = y1;\n                    break;\n                case CMD.R:\n                    var p0 = points[0];\n                    var p1 = points[1];\n                    // x0, y0\n                    p0[0] = data[i++];\n                    p0[1] = data[i++];\n                    // x1, y1\n                    p1[0] = p0[0] + data[i++];\n                    p1[1] = p0[1] + data[i++];\n\n                    if (m) {\n                        applyTransform(p0, p0, m);\n                        applyTransform(p1, p1, m);\n                    }\n\n                    p0[0] = round(p0[0] * Z - Z2);\n                    p1[0] = round(p1[0] * Z - Z2);\n                    p0[1] = round(p0[1] * Z - Z2);\n                    p1[1] = round(p1[1] * Z - Z2);\n                    str.push(\n                        // x0, y0\n                        ' m ', p0[0], comma, p0[1],\n                        // x1, y0\n                        ' l ', p1[0], comma, p0[1],\n                        // x1, y1\n                        ' l ', p1[0], comma, p1[1],\n                        // x0, y1\n                        ' l ', p0[0], comma, p1[1]\n                    );\n                    break;\n                case CMD.Z:\n                    // FIXME Update xi, yi\n                    str.push(' x ');\n            }\n\n            if (nPoint > 0) {\n                str.push(cmdStr);\n                for (var k = 0; k < nPoint; k++) {\n                    var p = points[k];\n\n                    m && applyTransform(p, p, m);\n                    // 不 round 会非常慢\n                    str.push(\n                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),\n                        k < nPoint - 1 ? comma : ''\n                    );\n                }\n            }\n        }\n\n        return str.join('');\n    };\n\n    // Rewrite the original path method\n    Path.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n\n        var vmlEl = this._vmlEl;\n        if (!vmlEl) {\n            vmlEl = vmlCore.createNode('shape');\n            initRootElStyle(vmlEl);\n\n            this._vmlEl = vmlEl;\n        }\n\n        updateFillAndStroke(vmlEl, 'fill', style, this);\n        updateFillAndStroke(vmlEl, 'stroke', style, this);\n\n        var m = this.transform;\n        var needTransform = m != null;\n        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n        if (strokeEl) {\n            var lineWidth = style.lineWidth;\n            // Get the line scale.\n            // Determinant of this.m_ means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            if (needTransform && !style.strokeNoScale) {\n                var det = m[0] * m[3] - m[1] * m[2];\n                lineWidth *= sqrt(abs(det));\n            }\n            strokeEl.weight = lineWidth + 'px';\n        }\n\n        var path = this.path || (this.path = new PathProxy());\n        if (this.__dirtyPath) {\n            path.beginPath();\n            this.buildPath(path, this.shape);\n            path.toStatic();\n            this.__dirtyPath = false;\n        }\n\n        vmlEl.path = pathDataToString(path.data, this.transform);\n\n        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Append to root\n        append(vmlRoot, vmlEl);\n\n        // Text\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, this.getBoundingRect());\n        }\n        else {\n            this.removeRectText(vmlRoot);\n        }\n    };\n\n    Path.prototype.onRemove = function (vmlRoot) {\n        remove(vmlRoot, this._vmlEl);\n        this.removeRectText(vmlRoot);\n    };\n\n    Path.prototype.onAdd = function (vmlRoot) {\n        append(vmlRoot, this._vmlEl);\n        this.appendRectText(vmlRoot);\n    };\n\n    /***************************************************\n     * IMAGE\n     **************************************************/\n    var isImage = function (img) {\n        // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';\n        // return img instanceof Image;\n    };\n\n    // Rewrite the original path method\n    ZImage.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n        var image = style.image;\n\n        // Image original width, height\n        var ow;\n        var oh;\n\n        if (isImage(image)) {\n            var src = image.src;\n            if (src === this._imageSrc) {\n                ow = this._imageWidth;\n                oh = this._imageHeight;\n            }\n            else {\n                var imageRuntimeStyle = image.runtimeStyle;\n                var oldRuntimeWidth = imageRuntimeStyle.width;\n                var oldRuntimeHeight = imageRuntimeStyle.height;\n                imageRuntimeStyle.width = 'auto';\n                imageRuntimeStyle.height = 'auto';\n\n                // get the original size\n                ow = image.width;\n                oh = image.height;\n\n                // and remove overides\n                imageRuntimeStyle.width = oldRuntimeWidth;\n                imageRuntimeStyle.height = oldRuntimeHeight;\n\n                // Caching image original width, height and src\n                this._imageSrc = src;\n                this._imageWidth = ow;\n                this._imageHeight = oh;\n            }\n            image = src;\n        }\n        else {\n            if (image === this._imageSrc) {\n                ow = this._imageWidth;\n                oh = this._imageHeight;\n            }\n        }\n        if (!image) {\n            return;\n        }\n\n        var x = style.x || 0;\n        var y = style.y || 0;\n\n        var dw = style.width;\n        var dh = style.height;\n\n        var sw = style.sWidth;\n        var sh = style.sHeight;\n        var sx = style.sx || 0;\n        var sy = style.sy || 0;\n\n        var hasCrop = sw && sh;\n\n        var vmlEl = this._vmlEl;\n        if (!vmlEl) {\n            // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n            // vmlEl = vmlCore.createNode('group');\n            vmlEl = vmlCore.doc.createElement('div');\n            initRootElStyle(vmlEl);\n\n            this._vmlEl = vmlEl;\n        }\n\n        var vmlElStyle = vmlEl.style;\n        var hasRotation = false;\n        var m;\n        var scaleX = 1;\n        var scaleY = 1;\n        if (this.transform) {\n            m = this.transform;\n            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\n            hasRotation = m[1] || m[2];\n        }\n        if (hasRotation) {\n            // If filters are necessary (rotation exists), create them\n            // filters are bog-slow, so only create them if abbsolutely necessary\n            // The following check doesn't account for skews (which don't exist\n            // in the canvas spec (yet) anyway.\n            // From excanvas\n            var p0 = [x, y];\n            var p1 = [x + dw, y];\n            var p2 = [x, y + dh];\n            var p3 = [x + dw, y + dh];\n            applyTransform(p0, p0, m);\n            applyTransform(p1, p1, m);\n            applyTransform(p2, p2, m);\n            applyTransform(p3, p3, m);\n\n            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\n            var transformFilter = [];\n            transformFilter.push('M11=', m[0] / scaleX, comma,\n                        'M12=', m[2] / scaleY, comma,\n                        'M21=', m[1] / scaleX, comma,\n                        'M22=', m[3] / scaleY, comma,\n                        'Dx=', round(x * scaleX + m[4]), comma,\n                        'Dy=', round(y * scaleY + m[5]));\n\n            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';\n            // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n            vmlElStyle.filter = imageTransformPrefix + '.Matrix('\n                + transformFilter.join('') + ', SizingMethod=clip)';\n\n        }\n        else {\n            if (m) {\n                x = x * scaleX + m[4];\n                y = y * scaleY + m[5];\n            }\n            vmlElStyle.filter = '';\n            vmlElStyle.left = round(x) + 'px';\n            vmlElStyle.top = round(y) + 'px';\n        }\n\n        var imageEl = this._imageEl;\n        var cropEl = this._cropEl;\n\n        if (!imageEl) {\n            imageEl = vmlCore.doc.createElement('div');\n            this._imageEl = imageEl;\n        }\n        var imageELStyle = imageEl.style;\n        if (hasCrop) {\n            // Needs know image original width and height\n            if (! (ow && oh)) {\n                var tmpImage = new Image();\n                var self = this;\n                tmpImage.onload = function () {\n                    tmpImage.onload = null;\n                    ow = tmpImage.width;\n                    oh = tmpImage.height;\n                    // Adjust image width and height to fit the ratio destinationSize / sourceSize\n                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\n                    // Caching image original width, height and src\n                    self._imageWidth = ow;\n                    self._imageHeight = oh;\n                    self._imageSrc = image;\n                };\n                tmpImage.src = image;\n            }\n            else {\n                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n            }\n\n            if (! cropEl) {\n                cropEl = vmlCore.doc.createElement('div');\n                cropEl.style.overflow = 'hidden';\n                this._cropEl = cropEl;\n            }\n            var cropElStyle = cropEl.style;\n            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='\n                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';\n\n            if (! cropEl.parentNode) {\n                vmlEl.appendChild(cropEl);\n            }\n            if (imageEl.parentNode != cropEl) {\n                cropEl.appendChild(imageEl);\n            }\n        }\n        else {\n            imageELStyle.width = round(scaleX * dw) + 'px';\n            imageELStyle.height = round(scaleY * dh) + 'px';\n\n            vmlEl.appendChild(imageEl);\n\n            if (cropEl && cropEl.parentNode) {\n                vmlEl.removeChild(cropEl);\n                this._cropEl = null;\n            }\n        }\n\n        var filterStr = '';\n        var alpha = style.opacity;\n        if (alpha < 1) {\n            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n        }\n        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\n        imageELStyle.filter = filterStr;\n\n        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Append to root\n        append(vmlRoot, vmlEl);\n\n        // Text\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, this.getBoundingRect());\n        }\n    };\n\n    ZImage.prototype.onRemove = function (vmlRoot) {\n        remove(vmlRoot, this._vmlEl);\n\n        this._vmlEl = null;\n        this._cropEl = null;\n        this._imageEl = null;\n\n        this.removeRectText(vmlRoot);\n    };\n\n    ZImage.prototype.onAdd = function (vmlRoot) {\n        append(vmlRoot, this._vmlEl);\n        this.appendRectText(vmlRoot);\n    };\n\n\n    /***************************************************\n     * TEXT\n     **************************************************/\n\n    var DEFAULT_STYLE_NORMAL = 'normal';\n\n    var fontStyleCache = {};\n    var fontStyleCacheCount = 0;\n    var MAX_FONT_CACHE_SIZE = 100;\n    var fontEl = document.createElement('div');\n\n    var getFontStyle = function (fontString) {\n        var fontStyle = fontStyleCache[fontString];\n        if (!fontStyle) {\n            // Clear cache\n            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n                fontStyleCacheCount = 0;\n                fontStyleCache = {};\n            }\n\n            var style = fontEl.style;\n            var fontFamily;\n            try {\n                style.font = fontString;\n                fontFamily = style.fontFamily.split(',')[0];\n            }\n            catch (e) {\n            }\n\n            fontStyle = {\n                style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n                size: parseFloat(style.fontSize || 12) | 0,\n                family: fontFamily || 'Microsoft YaHei'\n            };\n\n            fontStyleCache[fontString] = fontStyle;\n            fontStyleCacheCount++;\n        }\n        return fontStyle;\n    };\n\n    var textMeasureEl;\n    // Overwrite measure text method\n    textContain.measureText = function (text, textFont) {\n        var doc = vmlCore.doc;\n        if (!textMeasureEl) {\n            textMeasureEl = doc.createElement('div');\n            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'\n                + 'padding:0;margin:0;border:none;white-space:pre;';\n            vmlCore.doc.body.appendChild(textMeasureEl);\n        }\n\n        try {\n            textMeasureEl.style.font = textFont;\n        } catch (ex) {\n            // Ignore failures to set to invalid font.\n        }\n        textMeasureEl.innerHTML = '';\n        // Don't use innerHTML or innerText because they allow markup/whitespace.\n        textMeasureEl.appendChild(doc.createTextNode(text));\n        return {\n            width: textMeasureEl.offsetWidth\n        };\n    };\n\n    var tmpRect = new BoundingRect();\n\n    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\n        var style = this.style;\n\n        // Optimize, avoid normalize every time.\n        this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n        var text = style.text;\n        // Convert to string\n        text != null && (text += '');\n        if (!text) {\n            return;\n        }\n\n        // Convert rich text to plain text. Rich text is not supported in\n        // IE8-, but tags in rich text template will be removed.\n        if (style.rich) {\n            var contentBlock = textContain.parseRichText(text, style);\n            text = [];\n            for (var i = 0; i < contentBlock.lines.length; i++) {\n                var tokens = contentBlock.lines[i].tokens;\n                var textLine = [];\n                for (var j = 0; j < tokens.length; j++) {\n                    textLine.push(tokens[j].text);\n                }\n                text.push(textLine.join(''));\n            }\n            text = text.join('\\n');\n        }\n\n        var x;\n        var y;\n        var align = style.textAlign;\n        var verticalAlign = style.textVerticalAlign;\n\n        var fontStyle = getFontStyle(style.font);\n        // FIXME encodeHtmlAttribute ?\n        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '\n            + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\n        textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign);\n\n        // Transform rect to view space\n        var m = this.transform;\n        // Ignore transform for text in other element\n        if (m && !fromTextEl) {\n            tmpRect.copy(rect);\n            tmpRect.applyTransform(m);\n            rect = tmpRect;\n        }\n\n        if (!fromTextEl) {\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n\n                align = align || 'left';\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, distance\n                );\n                x = res.x;\n                y = res.y;\n\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                verticalAlign = verticalAlign || res.textVerticalAlign;\n            }\n        }\n        else {\n            x = rect.x;\n            y = rect.y;\n        }\n\n        x = textContain.adjustTextX(x, textRect.width, align);\n        y = textContain.adjustTextY(y, textRect.height, verticalAlign);\n\n        // Force baseline 'middle'\n        y += textRect.height / 2;\n\n        // var fontSize = fontStyle.size;\n        // 1.75 is an arbitrary number, as there is no info about the text baseline\n        // switch (baseline) {\n            // case 'hanging':\n            // case 'top':\n            //     y += fontSize / 1.75;\n            //     break;\n        //     case 'middle':\n        //         break;\n        //     default:\n        //     // case null:\n        //     // case 'alphabetic':\n        //     // case 'ideographic':\n        //     // case 'bottom':\n        //         y -= fontSize / 2.25;\n        //         break;\n        // }\n\n        // switch (align) {\n        //     case 'left':\n        //         break;\n        //     case 'center':\n        //         x -= textRect.width / 2;\n        //         break;\n        //     case 'right':\n        //         x -= textRect.width;\n        //         break;\n            // case 'end':\n                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n                // break;\n            // case 'start':\n                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n                // break;\n            // default:\n            //     align = 'left';\n        // }\n\n        var createNode = vmlCore.createNode;\n\n        var textVmlEl = this._textVmlEl;\n        var pathEl;\n        var textPathEl;\n        var skewEl;\n        if (!textVmlEl) {\n            textVmlEl = createNode('line');\n            pathEl = createNode('path');\n            textPathEl = createNode('textpath');\n            skewEl = createNode('skew');\n\n            // FIXME Why here is not cammel case\n            // Align 'center' seems wrong\n            textPathEl.style['v-text-align'] = 'left';\n\n            initRootElStyle(textVmlEl);\n\n            pathEl.textpathok = true;\n            textPathEl.on = true;\n\n            textVmlEl.from = '0 0';\n            textVmlEl.to = '1000 0.05';\n\n            append(textVmlEl, skewEl);\n            append(textVmlEl, pathEl);\n            append(textVmlEl, textPathEl);\n\n            this._textVmlEl = textVmlEl;\n        }\n        else {\n            // 这里是在前面 appendChild 保证顺序的前提下\n            skewEl = textVmlEl.firstChild;\n            pathEl = skewEl.nextSibling;\n            textPathEl = pathEl.nextSibling;\n        }\n\n        var coords = [x, y];\n        var textVmlElStyle = textVmlEl.style;\n        // Ignore transform for text in other element\n        if (m && fromTextEl) {\n            applyTransform(coords, coords, m);\n\n            skewEl.on = true;\n\n            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +\n            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';\n\n            // Text position\n            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);\n            // Left top point as origin\n            skewEl.origin = '0 0';\n\n            textVmlElStyle.left = '0px';\n            textVmlElStyle.top = '0px';\n        }\n        else {\n            skewEl.on = false;\n            textVmlElStyle.left = round(x) + 'px';\n            textVmlElStyle.top = round(y) + 'px';\n        }\n\n        textPathEl.string = encodeHtmlAttribute(text);\n        // TODO\n        try {\n            textPathEl.style.font = font;\n        }\n        // Error font format\n        catch (e) {}\n\n        updateFillAndStroke(textVmlEl, 'fill', {\n            fill: style.textFill,\n            opacity: style.opacity\n        }, this);\n        updateFillAndStroke(textVmlEl, 'stroke', {\n            stroke: style.textStroke,\n            opacity: style.opacity,\n            lineDash: style.lineDash\n        }, this);\n\n        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Attached to root\n        append(vmlRoot, textVmlEl);\n    };\n\n    var removeRectText = function (vmlRoot) {\n        remove(vmlRoot, this._textVmlEl);\n        this._textVmlEl = null;\n    };\n\n    var appendRectText = function (vmlRoot) {\n        append(vmlRoot, this._textVmlEl);\n    };\n\n    var list = [RectText, Displayable, ZImage, Path, Text];\n\n    // In case Displayable has been mixed in RectText\n    for (var i = 0; i < list.length; i++) {\n        var proto = list[i].prototype;\n        proto.drawRectText = drawRectText;\n        proto.removeRectText = removeRectText;\n        proto.appendRectText = appendRectText;\n    }\n\n    Text.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, {\n                x: style.x || 0, y: style.y || 0,\n                width: 0, height: 0\n            }, this.getBoundingRect(), true);\n        }\n        else {\n            this.removeRectText(vmlRoot);\n        }\n    };\n\n    Text.prototype.onRemove = function (vmlRoot) {\n        this.removeRectText(vmlRoot);\n    };\n\n    Text.prototype.onAdd = function (vmlRoot) {\n        this.appendRectText(vmlRoot);\n    };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/vml/graphic.js\n// module id = 137\n// module chunks = 0","\n\nif (!require('../core/env').canvasSupported) {\n    var urn = 'urn:schemas-microsoft-com:vml';\n\n    var createNode;\n    var win = window;\n    var doc = win.document;\n\n    var vmlInited = false;\n\n    try {\n        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n        createNode = function (tagName) {\n            return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n        };\n    }\n    catch (e) {\n        createNode = function (tagName) {\n            return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n        };\n    }\n\n    // From raphael\n    var initVML = function () {\n        if (vmlInited) {\n            return;\n        }\n        vmlInited = true;\n\n        var styleSheets = doc.styleSheets;\n        if (styleSheets.length < 31) {\n            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n        }\n        else {\n            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n        }\n    };\n\n    // Not useing return to avoid error when converting to CommonJS module\n    module.exports = {\n        doc: doc,\n        initVML: initVML,\n        createNode: createNode\n    };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/vml/core.js\n// module id = 138\n// module chunks = 0","/**\n * VML Painter.\n *\n * @module zrender/vml/Painter\n */\n\n\n\n    var zrLog = require('../core/log');\n    var vmlCore = require('./core');\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    /**\n     * @alias module:zrender/vml/Painter\n     */\n    function VMLPainter(root, storage) {\n\n        vmlCore.initVML();\n\n        this.root = root;\n\n        this.storage = storage;\n\n        var vmlViewport = document.createElement('div');\n\n        var vmlRoot = document.createElement('div');\n\n        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\n        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\n        root.appendChild(vmlViewport);\n\n        this._vmlRoot = vmlRoot;\n        this._vmlViewport = vmlViewport;\n\n        this.resize();\n\n        // Modify storage\n        var oldDelFromStorage = storage.delFromStorage;\n        var oldAddToStorage = storage.addToStorage;\n        storage.delFromStorage = function (el) {\n            oldDelFromStorage.call(storage, el);\n\n            if (el) {\n                el.onRemove && el.onRemove(vmlRoot);\n            }\n        };\n\n        storage.addToStorage = function (el) {\n            // Displayable already has a vml node\n            el.onAdd && el.onAdd(vmlRoot);\n\n            oldAddToStorage.call(storage, el);\n        };\n\n        this._firstPaint = true;\n    }\n\n    VMLPainter.prototype = {\n\n        constructor: VMLPainter,\n\n        getType: function () {\n            return 'vml';\n        },\n\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._vmlViewport;\n        },\n\n        getViewportRootOffset: function () {\n            var viewportRoot = this.getViewportRoot();\n            if (viewportRoot) {\n                return {\n                    offsetLeft: viewportRoot.offsetLeft || 0,\n                    offsetTop: viewportRoot.offsetTop || 0\n                };\n            }\n        },\n\n        /**\n         * 刷新\n         */\n        refresh: function () {\n\n            var list = this.storage.getDisplayList(true, true);\n\n            this._paintList(list);\n        },\n\n        _paintList: function (list) {\n            var vmlRoot = this._vmlRoot;\n            for (var i = 0; i < list.length; i++) {\n                var el = list[i];\n                if (el.invisible || el.ignore) {\n                    if (!el.__alreadyNotVisible) {\n                        el.onRemove(vmlRoot);\n                    }\n                    // Set as already invisible\n                    el.__alreadyNotVisible = true;\n                }\n                else {\n                    if (el.__alreadyNotVisible) {\n                        el.onAdd(vmlRoot);\n                    }\n                    el.__alreadyNotVisible = false;\n                    if (el.__dirty) {\n                        el.beforeBrush && el.beforeBrush();\n                        (el.brushVML || el.brush).call(el, vmlRoot);\n                        el.afterBrush && el.afterBrush();\n                    }\n                }\n                el.__dirty = false;\n            }\n\n            if (this._firstPaint) {\n                // Detached from document at first time\n                // to avoid page refreshing too many times\n\n                // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n                this._vmlViewport.appendChild(vmlRoot);\n                this._firstPaint = false;\n            }\n        },\n\n        resize: function (width, height) {\n            var width = width == null ? this._getWidth() : width;\n            var height = height == null ? this._getHeight() : height;\n\n            if (this._width != width || this._height != height) {\n                this._width = width;\n                this._height = height;\n\n                var vmlViewportStyle = this._vmlViewport.style;\n                vmlViewportStyle.width = width + 'px';\n                vmlViewportStyle.height = height + 'px';\n            }\n        },\n\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this._vmlRoot =\n            this._vmlViewport =\n            this.storage = null;\n        },\n\n        getWidth: function () {\n            return this._width;\n        },\n\n        getHeight: function () {\n            return this._height;\n        },\n\n        clear: function () {\n            if (this._vmlViewport) {\n                this.root.removeChild(this._vmlViewport);\n            }\n        },\n\n        _getWidth: function () {\n            var root = this.root;\n            var stl = root.currentStyle;\n\n            return ((root.clientWidth || parseInt10(stl.width))\n                    - parseInt10(stl.paddingLeft)\n                    - parseInt10(stl.paddingRight)) | 0;\n        },\n\n        _getHeight: function () {\n            var root = this.root;\n            var stl = root.currentStyle;\n\n            return ((root.clientHeight || parseInt10(stl.height))\n                    - parseInt10(stl.paddingTop)\n                    - parseInt10(stl.paddingBottom)) | 0;\n        }\n    };\n\n    // Not supported methods\n    function createMethodNotSupport(method) {\n        return function () {\n            zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n        };\n    }\n\n    var notSupportedMethods = [\n        'getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers',\n        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'\n    ];\n\n    for (var i = 0; i < notSupportedMethods.length; i++) {\n        var name = notSupportedMethods[i];\n        VMLPainter.prototype[name] = createMethodNotSupport(name);\n    }\n\n    module.exports = VMLPainter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.3.6.3@zrender/lib/vml/Painter.js\n// module id = 139\n// module chunks = 0"]}