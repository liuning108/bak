(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["fishTopoBpmn"] = factory();
	else
		root["fishTopoBpmn"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Export fishTopo as CommonJS module
	 */
	module.exports = __webpack_require__(2);
	//兼容IE8 引入VML 如果不需要兼容IE8请删除
	__webpack_require__(110);
	


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * BPMN对象
	 * @class fish.topo.FishTopoBpmn
	 */
	
	/**
	 * @event click
	 * 节点或者线段的click事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *      this.fishTopoBpmn.on("click",function(e) {
	 *          var target = e.target;
	 *          if(FishTopoBpmn.Bpmn.isFlow(target)) { //判断类型
	 *              var lineNode = e.target;
	 *              that.fishTopoBpmn.bindLineDelete(lineNode); //给线段增加删除图标
	 *              //todo
	 *          }
	 *      }
	 */
	
	/**
	 * @event dblclick
	 * 节点或者线段的双击事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          //双击弹出节点对应的json
	 *          this.fishTopoBpmn.on("dblclick",function(e) {
	 *              var target = e.target;
	 *
	 *              if(FishTopoBpmn.Bpmn.isFlow(target)) {
	 *                  console.log("dblclick line");
	 *              }
	 *              else{
	 *                  var json = nodeModel.option;
	 *                  fish.popupView({
	 *                      url: "views/dialog/ExportJsonDlg.js",
	 *                      viewOption:{bpmnJson:JSON.stringify(json,null,4)},
	 *                      callback: function(popup,view) {
	 *                          console.log("OK");
	 *                      },
	 *                      close: function(msg) {
	 *                          console.log("return value: " + msg);
	 *                      }
	 *                  });
	 *              }
	 *          });
	 */
	
	/**
	 * @event create
	 * 节点与线段创建完毕的事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          this.fishTopoBpmn.on("create", function(e) {
	 *              if(FishTopoBpmn.Bpmn.isFlow(e.target)) {
	 *                  var line = e.target;
	 *                  console.log("连线创建完毕，从" + line.startNode.model.get("properties.name") + " 至 " + line.endNode.model.get("properties.name"));
	 *              } else {
	 *                  var node = e.target;
	 *                  console.log("节点：" + node.model.get("properties.name") + " 创建完毕");
	 *              }
	 *          });
	 */
	
	/**
	 * @event delete
	 * 节点与线段删除完毕的事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          //节点删除完毕事件
	 *          this.fishTopoBpmn.on("delete", function(event) {
	 *              console.log("删除的是：" + event.target);
	 *          });
	 */
	
	
	    var graphic = __webpack_require__(3);
	    var ExtensionAPI = __webpack_require__(59);
	    var Point = __webpack_require__(60);
	    var Eventful = __webpack_require__(11);
	    var zrender = __webpack_require__(61);
	    var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(25);
	    var BpmnUtil = __webpack_require__(72);
	    var util = __webpack_require__(73);
	    var BPMNModel = __webpack_require__(78);
	    var BPMNNode = __webpack_require__(75);
	    var OperationNode = __webpack_require__(102);
	    var BpmnConnectionManager = __webpack_require__(104);
	    var Connector = __webpack_require__(96);
	    var LineOperationManager = __webpack_require__(107);
	    var Guidelines = __webpack_require__(108);
	    var Bpmn = __webpack_require__(101);
	    __webpack_require__(109);
	    function FishTopoBpmn(dom, opts) {
	        this.id;
	        this.group;
	        this._dom = dom;
	        this._zr = zrender.init(dom, {
	            renderer: opts.renderer || 'canvas',
	            devicePixelRatio: opts.devicePixelRatio
	        });
	        this.allNodes = []; //存放所有节点
	        this.subProcessNode = [];  //存放子节点
	        this.domArray = []; //存放节点的位置信息，拖动的时候用到
	        this.overlapArray = []; // 存放节点的位置信息，判断重叠用到，除去了子流程里面的节点
	        this.selectedNode = null;  //选中的节点
	        this.isNode = false;
	        this.rect;  // 对齐线和移动框节点
	        this.operationNode;
	        this.step = 0;//前进后退计步数
	        this.stepJson = [];//存放每步的json
	        this.opts = opts;
	        this._api = new ExtensionAPI(this);
	        /**
	         * @cfg {Boolean} forbidEdit 是否禁用编辑功能
	         */
	        this.forbidEdit = false;
	        this.connectionManager = new BpmnConnectionManager();
	        this.lineOperationManager = new LineOperationManager(this.connectionManager);
	        this.model = new BPMNModel({});
	        this.model.set(Bpmn.RESOURCE_ID, util.getUUID());
	        this.model.set(Bpmn.BPMN_TYPE, Bpmn.TEMPLATE);
	        Eventful.call(this);
	        BpmnUtil.registerBPMNNode();
	    }
	
	    var fishTopoProto = FishTopoBpmn.prototype;
	
	    /**
	     * 获取 fishTopo 实例容器的 dom 节点
	     * @return {HTMLElement}
	     */
	    fishTopoProto.getDom = function() {
	        return this._dom;
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.getZr = function() {
	        return this._zr;
	    };
	    /**
	     * 获取 fishTopo 实例容器的宽度。
	     * @return {number}
	     */
	    fishTopoProto.getWidth = function() {
	        return this._zr.getWidth();
	    };
	
	    /**
	     * 获取 fishTopo 实例容器的高度。
	     * @return {number}
	     */
	    fishTopoProto.getHeight = function() {
	        return this._zr.getHeight();
	    };
	
	
	    /**
	     * 当前实例是否已经被释放。
	     * @return {boolean}
	     */
	    fishTopoProto.isDisposed = function() {
	        return this._disposed;
	    };
	
	    /**
	     * Dispose instance
	     */
	    fishTopoProto.dispose = function() {
	        this._disposed = true;
	
	        this._zr.dispose();
	
	        instances[this.id] = null;
	    };
	
	
	    /**
	     * 调整尺寸  在窗口大小发生改变时需要手工调用
	     * @param {number} width 宽度
	     * @param {number} height 高度
	     */
	    fishTopoProto.resize = function(width, height) {
	        $(this.getDom()).css("width", width);
	        $(this.getDom()).css("height", height);
	        this._zr.resize();
	        this._zr.remove(this.group);
	        this.group = new graphic.Group();
	        this.gridLine(0.2);
	        this._zr.add(this.group);
	    };
	
	    /** @private 初始化 */
	    fishTopoProto.init = function() {
	        this.group = new graphic.Group();
	        if (this.opts.showGridLine == true || opts.showGridLine == "true") {
	            this.gridLine(0.2);
	            this._zr.add(this.group);
	        }
	
	        //mouseup 会在各个node或线的点击事件之前执行  在选中节点或线前 先清空选中效果
	        this._zr.on("mouseup", function(e) {
	            if (this.operationNode) {
	                this._zr.remove(this.operationNode);
	                this.operationNode = null;
	            }
	            var shape = e.target;
	            if (shape && shape.connector instanceof Connector) {
	                return;
	            }
	            this.connectionManager.clearSelectCon();
	            if (shape && shape.operation && shape.operation == true) {
	                return;
	            }
	            this.lineOperationManager.hideAllLineOperation();
	        }.bind(this));
	        //派发不是节点或线 的画布点击事件
	        this._zr.on("click", function(e) {
	
	            var shape = e.target;
	            //点击的线
	            if (shape && shape.parent && shape.parent.resourceId) {
	                return;
	            } else {
	                var params = {};
	                params.event = e;
	                params.type = "click";
	                params.target = this;
	                this._api.trigger(params.type, params);
	            }
	        }.bind(this));
	        this.on('conPointsGroup:click', function(argument) {
	            this.lineOperationManager.bindOperation(argument.lineNode);
	        }.bind(this))
	    };
	
	    /**
	     * 根据传过来的值  设置节点模型
	     * @param {Object} shape  节点或线
	     * @param {Object} option 模型数据
	     * @param {number} width 宽度(仅用于调整画布大小)
	     * @param {number} height 高度(仅用于调整画布大小)
	     */
	    fishTopoProto.setShapeModel = function(shape, option, width, height) {
	        if (Bpmn.isTemplate(shape)) {
	            this.model.mergeOption(option);
	            if (width > 0 && height > 0) {
	                this.resize(width, height);
	            }
	        } else if (Bpmn.isFlow(shape)) {
	            this.connectionManager.setModel(shape, option);
	        } else {
	            shape.setModel(option);
	        }
	    };
	
	    /**
	     * 清空当前实例，会移除实例中所有的节点与线
	     * @method clear
	     */
	    fishTopoProto.clear = function(isNoCount) {
	        this.allNodes = [];
	
	        this.subProcessNode = [];
	
	        this.domArray = [];
	
	        this.overlapArray = [];
	
	        this.selectedNode = null;
	        this.rect = null;
	        this.connectionManager.connectors = [];
	        this._zr.clear();
	        this._zr.add(this.group); // 画网格线  代码放这比较恶心 后面改
	        if (isNoCount != true) {
	            this.stepCounter();
	        }
	    };
	
	    /**
	     * 设置是否显示网络线
	     * @param  {Boolean} isForbidden 是否显示网络线
	     */
	    fishTopoProto.forbidGridLine = function(isForbidden) {
	        if (isForbidden == true) {
	            this._zr.remove(this.group);
	        } else {
	            this._zr.remove(this.group);
	            this.group = new graphic.Group();
	            this.gridLine(0.2);
	            this._zr.add(this.group);
	        }
	    };
	
	    /**
	     * 导出json
	     * @return {string} json字符串
	     */
	    fishTopoProto.toJson = function() {
	        return BpmnUtil.toJson(this.model, this.allNodes, this.connectionManager.connectors);
	    };
	
	    /**
	     * 导入json
	     * @param  {string} json json格式的字符串
	     */
	    fishTopoProto.fromJson = function(json) {
	        BpmnUtil.fromJson(this, json);
	    };
	
	    //背景网格线
	    fishTopoProto.gridLine = function(opacity) {
	        var pixel = this.opts.gridLineSpacing;
	        var widthLen = parseInt(this.getWidth() / pixel);
	        for (var x = 0; x <= widthLen; x++) {
	            var lineX = new graphic.Line({
	                shape: {
	                    x1: x * pixel,
	                    y1: 0,
	                    x2: x * pixel,
	                    y2: this.getHeight()
	                },
	                style: {
	                    lineDash: [1],
	                    opacity: opacity
	                },
	                z: 0,
	                draggable: false,
	                cursor: 'default'
	            });
	            this.group.add(lineX);
	        }
	
	        var heightLen = parseInt(this.getHeight() / pixel, pixel);
	        for (var y = 0; y <= heightLen; y++) {
	            var lineY = new graphic.Line({
	                shape: {
	                    x1: 0,
	                    y1: y * pixel,
	                    x2: this.getWidth(),
	                    y2: y * pixel
	                },
	                style: {
	                    lineDash: [1],
	                    opacity: opacity
	                },
	                z: 0,
	                draggable: false,
	                cursor: 'default'
	            });
	            this.group.add(lineY);
	        }
	    };
	
	
	    /**
	     * 通过界面拖动 增加节点
	     * @param {string} itemType 创建节点的类型（已有预定义类型包括StartNoneEvent、EndNoneEvent、UserTask、ManualTask、ScriptTask、MailTask、CatchTimerEvent、CatchSignalEvent、ThrowSignalEvent、InclusiveGateway、ExclusiveGateway、ParallelGateway、SubProcess）
	     * @param {number} x        节点创建的x坐标
	     * @param {number} y        节点创建的y坐标
	     * @param {Object} options 选项
	     * @param {Object} [options.name] 节点下面显示名称
	     * @param {Array} [options.operationIcons] 设置选中节点时 显示的操作小图标， 默认提供了 删除、直线、折线、曲线4种图标，也可以自定图标 eg.
	     * <pre>
	     *          operationIcons: [{ name: 'DEL' },
	     *              { name: 'STRAIGHT' },
	     *              { name: 'JAGGED' },
	     *              { name: 'CURVE' },
	     *              {
	     *                  name: "custom1",
	     *                  iconPath: "img/host.png",
	     *                  callback: function(e) { alert(e.data.name + " clicked") }  //e.node是当前的节点
	     *              }
	     *          ]
	     * </pre>
	     * @param {Object} userData 用户传递的业务数据
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *      fishTopo.addNode(itemType, x, y, {
	     *                      name: itemType,   //节点的名称
	     *                      operationIcons:[{name:'DEL'},{ name: 'STRAIGHT' },{name:'JAGGED'},{ name: 'CURVE' }],
	     *                      // 增加节点操作图标 上面分别是"删除、直线、折线、曲线"，
	     *                      // 也可以增加自定图标 如{name: "custom1", iconPath: "img/host.png", callback: function(e) { alert(e.data.name + " clicked") }} //e.node是当前的节点
	     *                      userData:{businessData:'我是业务数据,通过Bpmn.getUserData可获取'}
	     *                      // 增加节点的自定义业务，可以通过Bpmn.getUserData(node)获取
	     *                  });
	     */
	    fishTopoProto.addNode = function(itemType, x, y, options) {
	
	        //判断是否在范围内
	        if (x >= 0 && y >= 0) {
	            var model = new BPMNModel({});
	            model.set(Bpmn.BPMN_TYPE, itemType);
	            model.set("bounds.upperLeft", {x: x, y: y});
	            if (options) {
	                model.set("properties", options);
	            }
	
	            return this.addNodeByModel(model, true);
	        }
	    };
	
	    /**
	     * 根据模型增加节点
	     * @private
	     * @param {Object} model [description]
	     * @return {Object} 创建完成的节点
	     */
	    fishTopoProto.addNodeByModel = function(model, isFromDrag, isNoCount) {
	        var that = this;
	        var Shape = BPMNNode.getClass(model.get(Bpmn.BPMN_TYPE));
	        var mesArray;
	        if (Shape) {
	            var node = new Shape(model, this._api);
	            if (this.subProcessNode.length == 0) {
	                this._zr.add(node);
	                mesArray = {
	                    id: node.id,
	                    position: [node.getRect().x, node.getRect().y],
	                    width: node.getRect().width,
	                    height: node.getRect().height
	                };
	                if (!Bpmn.isSlotEvent(node)) {
	                    this.overlapArray.push(mesArray);
	                }
	
	            } else {
	                this._zr.add(node);
	                mesArray = {
	                    id: node.id,
	                    position: [node.getRect().x, node.getRect().y],
	                    width: node.getRect().width,
	                    height: node.getRect().height
	                };
	                if (!Bpmn.isSlotEvent(node)) {
	                    this.overlapArray.push(mesArray);
	                }
	                if (isFromDrag) {
	                    //1.判断所有的子节点
	                    for (var i = 0; i < this.subProcessNode.length; i++) {
	                        //2.如果节点拖放在 子节点中
	                        if (this.subProcessNode[i].rectContain(node.getRect().x, node.getRect().y)) {
	                            //2.1重新计算节点在 子节点中的位置  并加入到子节点
	                            var groupNodePositionX = this.subProcessNode[i].getRect().width / 2 + (node.getRect().x - this.subProcessNode[i].getRect().x);
	                            var groupNodePositionY = this.subProcessNode[i].getRect().height / 2 + (node.getRect().y - this.subProcessNode[i].getRect().y);
	                            node.setPosition(groupNodePositionX, groupNodePositionY);
	                            this.subProcessNode[i].add(node);
	                            //2.2从zr中删除
	                            this._zr.remove(node);
	                            //2.3从 节点位置 信息数组中删除此节点
	                            for (var j = 0; j < that.overlapArray.length; j++) {
	                                if (node.id == that.overlapArray[j].id) {
	                                    that.overlapArray.splice(j, 1);
	                                }
	                            }
	                            break;
	                        }
	                    }
	                }
	
	            }
	            //2.如果是子节点 则加入到子节点数组中
	            if (Bpmn.isSubProcess(node)) {
	                this.subProcessNode.push(node);
	            }
	            this.allNodes.push(node);
	            //放入节点位置信息 用于拖拽
	            this.domArray.push(mesArray);
	
	            //侦听节点的事件 并把事件给取消掉 防止 如果父是子节点侦听到
	            node.on('mousedown', function(e) {
	                if (that.forbidEdit == true) {
	                    return;
	                }
	                that.newDrag(this, e.event.clientX, e.event.clientY);
	                //如果选择的是事件节点，则为其他task绑定插槽
	                if (Bpmn.isSlotEvent(this)) {
	                    that.bindEventNode();
	                }
	                e.cancelBubble = true;
	            });
	            node.on('click', function(e) {
	
	                that.nodeClickHandler(this);
	                e.cancelBubble = true;
	            });
	
	            //添加tip
	            if (Bpmn.isActivity(node)) {
	                that.creatTip(node);
	            }
	
	            node.on("mouseover", function() {
	                if (this.alarm && this.alarm.isShow == true) {
	
	                    this.alarm.show();
	                    this.alarm.eachChild(function(child) {
	                        child.show();
	                    });
	                    //根据字内容更改tip外框的大小
	                    var text = this.alarm.childOfName("Text");
	                    var groupWidth = text.getBoundingRect().width + 4;
	                    var groupHeight = text.getBoundingRect().height + 8;
	                    var points = [
	                        [0, 0],
	                        [groupWidth, 0],
	                        [groupWidth, groupHeight],
	                        [groupWidth / 2 - 3, groupHeight],
	                        [groupWidth / 2, groupHeight + 3],
	                        [groupWidth / 2 + 3, groupHeight],
	                        [0, groupHeight],
	                        [0, 0]
	                    ];
	                    var Polyline = this.alarm.childOfName("Polyline");
	                    Polyline.attr("shape", {points: points});
	                    var groupPosition = [node.position[0] + node.getBoundingRect().width - this.alarm.getBoundingRect().width / 2, node.position[1] - this.alarm.getBoundingRect().height - 3];
	                    this.alarm.attr("position", groupPosition);
	                }
	            });
	            node.on("mouseout", function() {
	                if (this.alarm) {
	                    this.alarm.hide();
	                    this.alarm.eachChild(function(child) {
	                        child.hide();
	                    });
	                }
	            });
	            this._triggerCreateEvent(node);
	            if (isNoCount != true) {
	                this.stepCounter();
	            }
	            return node;
	        }
	    };
	
	    /**
	     * 根据name获取节点
	     * @param  {String} name 在创建节点中  name属性设置的值
	     * @return {Object}      name对应的节点
	     */
	    fishTopoProto.childOfName = function(name) {
	        var arrResult = [];
	        for (var i = 0; i < this.allNodes.length; i++) {
	            if (this.allNodes[i].model.get("properties.name") == name) {
	                arrResult.push(this.allNodes[i]);
	            }
	        }
	        if (arrResult.length > 1) {
	            return arrResult;
	        } else {
	            return arrResult[0];
	        }
	    };
	
	    /**
	     * 查找场景中的对象   例如: x坐标大于100的节点 findElements(function(e){ return e.position[0] > 100; });
	     * @param  {Function} cb      回调函数
	     * @param  {Object}   context 回调函数执行的上下文
	     * @return {Array}           返回查找到的对象
	     */
	    fishTopoProto.findElements = function(cb, context) {
	        var childrenNode = this.allNodes;
	        var childrenLine = this.connectionManager.connectors;
	        var arr = [];
	        for (var i = 0; i < childrenNode.length; i++) {
	            var child = childrenNode[i];
	            if (cb.call(context, child, i)) {
	                arr.push(child);
	            }
	        }
	        for (var j = 0; j < childrenLine.length; j++) {
	            var childLine = childrenLine[j];
	            if (cb.call(context, childLine, j)) {
	                arr.push(childLine);
	            }
	        }
	        return arr;
	    };
	
	    /**
	     * @private
	     * 根据模型增加线
	     */
	    fishTopoProto.addConnectorByModel = function(model, parentZr) {
	        //找出 startNode 与 endNode
	        var startNode = null,
	            endNode = null;
	        zrUtil.each(this.allNodes, function(node) {
	            //startNode: 从allNode中找出outgoing为 线的id的起始节点
	            var nodeOutgoing = node.model.get("outgoing");
	            if (nodeOutgoing.indexOf(model.get("resourceId")) !== -1) {
	                startNode = node;
	            }
	            //endNode : 从allNode中找出 id 为线的outgoing的结束节点
	            var connectorOutgoing = model.get("outgoing");
	            if (connectorOutgoing.indexOf(node.resourceId) !== -1) {
	                endNode = node;
	            }
	        });
	        if (startNode && endNode) {
	            var connector = this.connectionManager.connectorCreateByOptions(startNode, endNode, {model: model,isFromModel:true}, this._api);
	            if (parentZr) {
	                parentZr.add(connector);
	            } else {
	
	                this._zr.add(connector);
	            }
	            connector.on("mousedown", function() {
	                this.connectionManager.connectorForbidEdit(that.forbidEdit);
	                this.lineOperationManager.isEdit = !this.forbidEdit;
	                this.isNode = false;
	            }.bind(this));
	        }
	
	    };
	
	    /**
	     * 创建连线的小图标操作
	     * @param {string} key 小图标的名称
	     * @param {Object} obj 小图标的相关参数
	     * @param {Object} options 小图标选项
	     * @param {String} [options.icon] 小图标路径
	     * @param {Object} [options.lineNode] 线段实例
	     * @param {Function} [options.callback] 点击后的回调
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *      fishTopoBpmn.addIcon("icon1",{  //线上图标的名称
	     *                    icon:"bpmn2.0/icons/activity/list/mail.send.png", //线上图标的路径
	     *                     lineNode:lineNode,  //线
	     *                     callback:function(lineNode){  //回调
	     *                          alert(JSON.stringify(lineNode))
	     *                      },
	     *                  });*
	     */
	    fishTopoProto.addIcon = function(key, obj) {
	        this.lineOperationManager.addIcon(key, obj, this._zr, this._api);
	    };
	
	    /**
	     * 创建连线的默认删除操作
	     * @param  {Object} lineNode 线
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopoBpmn.bindLineDelete(lineNode);
	     */
	    fishTopoProto.bindLineDelete = function(lineNode) {
	        var parentZr = this._zr;;
	        if (lineNode.parent) {
	            parentZr = lineNode.parent;
	        }
	        //创建删除
	        var lineOperation = this.lineOperationManager.addIcon("delete", this.lineOperationManager.deleteIconObj(parentZr, lineNode), parentZr, this._api);
	        if (lineOperation) {
	            lineOperation.on("click", function() {
	                this._triggerDeleteEvent(lineNode);
	            }.bind(this));
	        }
	    };
	    /**
	     * @private
	     * 返回 连向该节点的节点数组：nodeArray[0]  以及该节点连向的节点数组 nodeArray[0]
	     */
	    fishTopoProto.checkLineNode = function(node) {
	        var startArray = [],
	            endArray = [];
	        var lineArray = this.connectionManager.connectors;
	        for (var i = 0, len = lineArray.length; i < len; i++) {
	            if (lineArray[i].startNode == node) {
	                endArray.push(lineArray[i].endNode);
	            }
	        }
	        for (var j = 0, lenEnd = lineArray.length; j < lenEnd; j++) {
	            if (lineArray[j].endNode == node) {
	                startArray.push(lineArray[j].startNode);
	            }
	        }
	        return [startArray, endArray];
	    };
	    /**
	     * @private
	     * 初始化 操作的虚线框
	     */
	    fishTopoProto.initOperationNode = function(node) {
	        var that = this;
	        this.operationNode = new OperationNode(node, that._zr, this.forbidEdit);
	        // 侦听 箭头 拖拽开始事件
	        this.operationNode.on(OperationNode.ARROW_DRAGSTART, function(e) {
	            var x = e.event.offsetX;
	            var y = e.event.offsetY;
	            //拖拽开始先把 箭头图标 给隐藏
	            var arrow = e.event.target;
	            arrow.hide();
	            var rEndPoint = new Point(x, y);
	            if (that.selectedNode.parent && Bpmn.isSubProcess(that.selectedNode.parent)) {
	                var subProcessNode = that.selectedNode.parent;
	                rEndPoint = new Point(x - subProcessNode.position[0], y - subProcessNode.position[1]);
	            }
	
	            var connector = that.connectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType);
	            if (that.selectedNode.parent && Bpmn.isSubProcess(that.selectedNode.parent)) {
	                that.selectedNode.parent.add(connector);
	            } else {
	                that._zr.add(connector);
	            }
	        });
	
	        // 侦听 箭头 拖拽事件
	        this.operationNode.on(OperationNode.ARROW_DRAG, function(e) {
	            var x = e.event.offsetX;
	            var y = e.event.offsetY;
	            var rEndPoint = new Point(x, y);
	            var arrow = e.event.target;
	            if (that.selectedNode.parent && Bpmn.isSubProcess(that.selectedNode.parent)) {
	                var subProcessNode = that.selectedNode.parent;
	                rEndPoint = new Point(x - subProcessNode.position[0], y - subProcessNode.position[1]);
	            }
	            that.connectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType);
	        });
	
	        //侦听 箭头 拖拽结束事件 画线
	        this.operationNode.on(OperationNode.ARROW_DRAGEND, function(e) {
	            var x = e.event.offsetX;
	            var y = e.event.offsetY;
	            var targetNode = null;
	            //拖拽结束先把 箭头图标 给显示
	            var arrow = e.event.target;
	            arrow.show();
	
	            //1.如果是子节点 内 节点拖拽 则 增加排除子节点的参数
	            if (node.parent) {
	                if (Bpmn.isSubProcess(node.parent)) {
	                    //删除临时线
	                    that.connectionManager.removeTempConnector(node.parent);
	                    targetNode = BpmnUtil.findHover(that.allNodes, x, y, that.subProcessNode);
	                }
	            } else {
	                targetNode = BpmnUtil.findHover(that.allNodes, x, y);
	                //删除临时线
	                that.connectionManager.removeTempConnector(that._zr);
	            }
	            //2.如果找到目标结点 则画线
	            if (targetNode && (that.selectedNode != targetNode)) {
	                that._createConnectorByNodes(that.selectedNode, targetNode, arrow.lineType);
	            }
	            var shapeRect = that.selectedNode.getRect();
	            that.operationNode.render(node, that._zr, shapeRect);
	            that.stepCounter();
	        });
	        //删除按钮点击事件
	        this.operationNode.on("OperationNode:deleteClick", function() {
	            that._triggerDeleteEvent(that.selectedNode);
	            that.removeNode(that.selectedNode);
	            that.stepCounter();
	        });
	        //放大缩小拖动过程
	        this.operationNode.on("OperationNode:scaleDragLeft", function(e) {
	            this.virtualRect.setShape({points: e.points});
	        });
	        this.operationNode.on("OperationNode:scaleDragRight", function(e) {
	            this.virtualRect.setShape({points: e.points});
	        });
	        //放大缩小拖动结束
	        this.operationNode.on("OperationNode:scaleDragEnd", function(e) {
	            //1.进行节点大小的设置，并维护位置信息数组
	            if (this.virtualRect.shape.points || this.virtualRect.shape.points != null) {
	                var width = this.virtualRect.shape.points[1][0] - this.virtualRect.shape.points[0][0] - 1;
	                var height = this.virtualRect.shape.points[2][1] - this.virtualRect.shape.points[1][1] - 1;
	                var position;
	                if (e.arrowName == "left") {
	                    position = [that.selectedNode.position[0] - (width + 1 - that.selectedNode.getRect().width), that.selectedNode.position[1] - (height + 1 - that.selectedNode.getRect().height)];
	                }
	                if (e.arrowName == "right") {
	                    position = [that.selectedNode.position[0], that.selectedNode.position[1]];
	                }
	                that.selectedNode.refresh({shape: {width: width, height: height}});
	                var isChange = true;
	                if (height + 1 < that.selectedNode.getBoundingRect().height) {
	                    that.selectedNode.refresh({shape: {height: that.selectedNode.getBoundingRect().height}});
	                    isChange = false;
	                }
	                if (width + 1 < that.selectedNode.getBoundingRect().width) {
	                    that.selectedNode.refresh({shape: {width: that.selectedNode.getBoundingRect().width}});
	                    isChange = false;
	                }
	                if (isChange == true) {
	                    that.selectedNode.refresh({position: position});
	                }
	                for (var m = 0; m < that.domArray.length; m++) {
	                    if (that.selectedNode.id == that.domArray[m].id) {
	                        that.domArray[m].position = [position[0] + (width + 1) / 2, position[1] + (height + 1) / 2];
	                    }
	                }
	                that.nodeClickHandler(that.selectedNode);
	                for (var n = 0; n < that.overlapArray.length; n++) {
	                    if (that.selectedNode.id == that.overlapArray[n].id) {
	                        that.overlapArray[n] = {
	                            id: that.selectedNode.id,
	                            position: [that.selectedNode.getRect().x, that.selectedNode.getRect().y],
	                            width: that.selectedNode.getRect().width,
	                            height: that.selectedNode.getRect().height
	                        };
	                    }
	                }
	            }
	            //2.刷新线
	            that.connectionManager.refreshLineByNode(that.selectedNode);
	            var endSlotPoints = util.getSoltPoints(that.selectedNode);
	            if (that.selectedNode.slotEvent && that.selectedNode.slotEvent.length > 0) {
	                for (var i = 0; i < that.selectedNode.slotEvent.length; i++) {
	                    var slotNode = that.selectedNode.slotEvent[i];
	                    for (var j = 0; j < e.startSlotPoints.length; j++) {
	                        if (that.selectedNode.slotEvent[i].position[0] - e.startPosition[0] == e.startSlotPoints[j][0] && that.selectedNode.slotEvent[i].position[1] - e.startPosition[1] == e.startSlotPoints[j][1]) {
	                            that.selectedNode.slotEvent[i].attr("position", [endSlotPoints[j][0] + that.selectedNode.position[0], endSlotPoints[j][1] + that.selectedNode.position[1]]);
	                            that.connectionManager.refreshLineByNode(that.selectedNode.slotEvent[i]);
	                        }
	                    }
	                }
	            }
	            that.stepCounter();
	        });
	        this._zr.add(this.operationNode);
	
	
	    };
	
	    /**
	     * 移除场景中的某个节点
	     * @param  {Object} selectedNode 待删除的节点
	     */
	    fishTopoProto.removeNode = function(selectedNode) {
	        var that = this;
	        //1.如果是子节点 内 节点  则 调用子节点的删除
	        var parentZr;
	        if (selectedNode.parent) {
	            parentZr = selectedNode.parent;
	        } else {
	            parentZr = that._zr;
	        }
	        parentZr.remove(selectedNode);
	        //2.从allNodes数组中删除
	        for (var i = 0; i < that.allNodes.length; i++) {
	            if (selectedNode.id == that.allNodes[i].id) {
	                that.allNodes.splice(i, 1);
	            }
	        }
	        for (var j = 0; j < that.domArray.length; j++) {
	            if (selectedNode.id == that.domArray[j].id) {
	                that.domArray.splice(j, 1);
	            }
	        }
	        for (var k = 0; k < that.overlapArray.length; k++) {
	            if (selectedNode.id == that.overlapArray[k].id) {
	                that.overlapArray.splice(k, 1);
	            }
	        }
	        //3.将此节点交联的线也删除
	        that.connectionManager.deleteSelectCon(selectedNode, parentZr);
	        //如果删除节点是task节点，需要将依附它的事件节点删除
	        if (Bpmn.isActivity(selectedNode) || Bpmn.isSubProcess(selectedNode)) {
	            if (selectedNode.slotEvent && selectedNode.slotEvent.length > 0) {
	                for (var m = 0; m < selectedNode.slotEvent.length; m++) {
	                    if (selectedNode.slotEvent[m].parent) {
	                        if (Bpmn.isSubProcess(selectedNode.slotEvent[m].parent)) {
	                            selectedNode.slotEvent[m].parent.remove(selectedNode.slotEvent[m]);
	                        }
	                    } else {
	                        that._zr.remove(selectedNode.slotEvent[m]);
	                    }
	                    for (var n = 0; n < that.allNodes.length; n++) {
	                        if (selectedNode.slotEvent[m].id == that.allNodes[n].id) {
	                            that.allNodes.splice(n, 1);
	                        }
	                    }
	                    for (var a = 0; a < that.domArray.length; a++) {
	                        if (selectedNode.slotEvent[m].id == that.domArray[a].id) {
	                            that.domArray.splice(a, 1);
	                        }
	                    }
	                }
	            }
	        }
	        //4.如果删除的是事件节点，需要将绑定它的task节点的标识删除
	        if (Bpmn.isSlotEvent(selectedNode)) {
	            for (var b = 0; b < that.allNodes.length; b++) {
	                if (that.allNodes[b].isCanSlot) {
	                    if (that.allNodes[b].slotEvent && that.allNodes[b].slotEvent.length > 0) {
	                        for (var c = 0; c < that.allNodes[b].slotEvent.length; c++) {
	                            if (selectedNode.id == that.allNodes[b].slotEvent[c].id) {
	                                that.allNodes[b].slotEvent.splice(c, 1);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        this.stepCounter();
	    };
	
	    fishTopoProto._createConnectorByNodes = function(startNode, endNode, lineType) {
	        var connector = this.connectionManager.connectorCreate(startNode, endNode, lineType, this._api);
	        if (startNode.parent && endNode.parent) {
	            endNode.parent.add(connector);
	        } else {
	            this._zr.add(connector);
	        }
	        connector.on("mousedown", zrUtil.bind(function() {
	            this.connectionManager.connectorForbidEdit(this.forbidEdit);
	            this.lineOperationManager.isEdit = !this.forbidEdit;
	            this.isNode = false;
	        }, this));
	
	        this._triggerCreateEvent(connector);
	        return connector;
	    };
	
	    fishTopoProto._triggerDeleteEvent = function(target) {
	        var eventParams = {};
	        eventParams.type = "delete";
	        eventParams.target = target;
	        this._api.trigger(eventParams.type, eventParams);
	    };
	    fishTopoProto._triggerCreateEvent = function(target) {
	        var eventParams = {};
	        eventParams.type = "create";
	        eventParams.target = target;
	        this._api.trigger(eventParams.type, eventParams);
	    };
	
	    /**
	     * @private
	     * 鼠标点下 将操作框 移到对应的节点上
	     * @param  {Object} node [description]
	     * @return {Object}      [description]
	     */
	    fishTopoProto.nodeClickHandler = function(node) {
	        this.selectedNode = node;
	        var shapeRect = node.getRect();
	        if (!this.operationNode) {
	            this.initOperationNode(node);
	        }
	        if (!this.forbidEdit) {
	            this.rect.attr("style", {
	                stroke: "rgba(0, 0, 0, 1)"
	            });
	        }
	
	        this.operationNode.refreshPostion(node, shapeRect);
	    };
	
	    /**
	     * 初始化虚框对齐线
	     * @private
	     * @param  {Object} shapeList [description]
	     */
	    fishTopoProto.initVirtualLine = function(shapeList) {
	        Guidelines.createGuidelines(this._zr);
	        this.rect = new graphic.Polyline({
	            position: [shapeList.x, shapeList.y],
	            shape: {
	                points: shapeList.points
	            },
	            style: {
	                lineDash: [2]
	            },
	            z: 3
	        });
	        this._zr.add(this.rect);
	    };
	    //绑定事件节点
	    fishTopoProto.bindEventNode = function() {
	        //mousedown的时候为每个task创建插槽
	        for (var i = 0; i < this.allNodes.length; i++) {
	            if (this.allNodes[i].isCanSlot) {
	                this.creatSlot(this.allNodes[i]);
	            }
	        }
	        //mouseup的时候删除插槽
	        this._zr.on("mouseup", function() {
	            for (var i = 0; i < this.allNodes.length; i++) {
	                if (this.allNodes[i].isCanSlot) {
	                    if (this.allNodes[i].slot && this.allNodes[i].slot.length > 0) {
	                        for (var m = 0; m < this.allNodes[i].slot.length; m++) {
	                            this.allNodes[i].remove(this.allNodes[i].slot[m]);
	                        }
	                    }
	                }
	            }
	        }.bind(this))
	
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.creatSlot = function(node) {
	        //给task创建8个插槽
	        node.slot = [];
	        var position = util.getSoltPoints(node);
	        for (var j = 0; j < 8; j++) {
	            var Circle = new graphic.Circle({
	                position: position[j],
	                shape: {
	                    cx: 0,
	                    cy: 0,
	                    r: 10
	                },
	                style: {
	                    lineWidth: 1,
	                    stroke: 'rgba(0,0,0,0.6)',
	                    fill: 'transparent'
	                }
	            });
	            node.slot.push(Circle);
	            node.add(Circle);
	        }
	    };
	
	    /**
	     * @private
	     * mousedown后 开始拖动
	     */
	    fishTopoProto.newDrag = function(dom, sX, sY) {
	        var that = this;
	        that.selectedNode = dom;
	        that.isNode = true;
	        var pixel = this.opts.gridLineSpacing;
	        var shapeList = dom.getRect();
	        var domArray = that.domArray;
	        //zrender不支持键盘事件，只能侦听body元素上的了
	        $('body').one('keydown', function(e) {
	            var ev = e || window.event;
	            //判断 delete按键
	            if (ev.keycode == 46 || ev.charCode == 46 || ev.which == 46) {
	                //1.如果是节点,移除事件,进行删除  如果是子节点 通过parent删除
	                if (that.isNode == true) {
	                    that.selectedNode.off();
	                    if (that.selectedNode.parent) {
	                        if (Bpmn.isSubProcess(that.selectedNode.parent)) {
	                            that.selectedNode.parent.remove(that.selectedNode);
	                        }
	                    } else {
	                        that._zr.remove(that.selectedNode);
	                    }
	                    //2.删除维护的节点数组
	                    for (var i = 0; i < that.allNodes.length; i++) {
	                        if (that.selectedNode.id == that.allNodes[i].id) {
	                            that.allNodes.splice(i, 1);
	                        }
	                    }
	                    for (var j = 0; j < domArray.length; j++) {
	                        if (that.selectedNode.id == domArray[j].id) {
	                            domArray.splice(j, 1);
	                        }
	                    }
	                    for (var k = 0; k < that.overlapArray.length; k++) {
	                        if (that.selectedNode.id == that.overlapArray[k].id) {
	                            that.overlapArray.splice(k, 1);
	                        }
	                    }
	                    //3.移去操作框
	                    if (that.operationNode) {
	                        that._zr.remove(that.operationNode);
	                        that.operationNode = null;
	                    }
	                    //3.删除对应的线
	                    that.connectionManager.deleteSelectCon(that.selectedNode, that._zr);
	                } else { //否则直接删除线
	                    that.connectionManager.deleteLine(that._zr);
	                }
	                this.stepCounter();
	            }
	        });
	
	        //初始化 对齐线
	        var startX, startY, rectPositionX, rectPositionY;
	        startX = sX;
	        startY = sY;
	        if (dom.parent) {
	            if (Bpmn.isSubProcess(dom.parent)) {
	                rectPositionX = shapeList.x + dom.parent.position[0];
	                rectPositionY = shapeList.y + dom.parent.position[1];
	            }
	        } else {
	            rectPositionX = shapeList.x;
	            rectPositionY = shapeList.y;
	        }
	        if (!that.rect) {
	            that.initVirtualLine(shapeList);
	            that.rect.attr("position", [rectPositionX, rectPositionY]);
	        } else {
	            that.rect.attr("position", [rectPositionX, rectPositionY]);
	            that.rect.setShape({points: shapeList.points});
	            that.rect.show();
	        }
	
	        var nowRectPosition = [rectPositionX, rectPositionY];
	        var isLap = 0;
	        var isMove = 0;
	        var moveFunction = function(e) {
	            moveDrag(e);
	        };
	        var upFunction = function(e) {
	            endDrag(e);
	        };
	        this._zr.on('mousemove', moveFunction);
	
	        //开始移动
	        function moveDrag(e) {
	            //以10个像素为单位进行移动
	            var maxRectPosition = [that.getWidth() - (that.rect.shape.points[1][0] - that.rect.shape.points[0][0]) / 2, that.getHeight() - (that.rect.shape.points[2][1] - that.rect.shape.points[1][1]) / 2];
	            var minRectPosition = [(that.rect.shape.points[1][0] - that.rect.shape.points[0][0]) / 2, (that.rect.shape.points[2][1] - that.rect.shape.points[1][1]) / 2];
	            for (var n = 0; n < Math.abs(parseInt((e.event.clientX - startX) / pixel)); n++) {
	                isMove = 1;
	                if (e.event.clientX - startX < 0) {
	                    nowRectPosition[0] = rectPositionX - pixel * (n);
	                } else {
	                    nowRectPosition[0] = rectPositionX + pixel * (n);
	                }
	                if (nowRectPosition[0] < minRectPosition[0]) {
	                    nowRectPosition[0] = minRectPosition[0];
	                }
	                if (nowRectPosition[0] > maxRectPosition[0]) {
	                    nowRectPosition[0] = maxRectPosition[0];
	                }
	            }
	            for (var m = 0; m < Math.abs(parseInt((e.event.clientY - startY) / pixel)); m++) {
	                isMove = 1;
	                if (e.event.clientY - startY < 0) {
	                    nowRectPosition[1] = rectPositionY - pixel * (m);
	                } else {
	                    nowRectPosition[1] = rectPositionY + pixel * (m);
	                }
	                if (nowRectPosition[1] < minRectPosition[1]) {
	                    nowRectPosition[1] = minRectPosition[1];
	                }
	                if (nowRectPosition[1] > maxRectPosition[1]) {
	                    nowRectPosition[1] = maxRectPosition[1];
	                }
	            }
	            that.rect.attr('position', nowRectPosition);
	
	            Guidelines.judgeAlignment(nowRectPosition, domArray, that.getWidth(), that.getHeight());
	            // 如果处于子节点内部  则不允许拖到外面 虚框标红
	            if (dom.parent) {
	                var centerX = Math.abs(nowRectPosition[0] - dom.parent.getRect().x);
	                var widthX = Math.abs(dom.getRect().width / 2 - dom.parent.getRect().width / 2);
	                var centerY = Math.abs(nowRectPosition[1] - dom.parent.getRect().y);
	                var heightY = Math.abs(dom.getRect().height / 2 - dom.parent.getRect().height / 2);
	                if (centerX > (widthX - pixel) || centerY > (heightY - pixel)) {
	                    resultFalse();
	                } else {
	                    resultSuccess();
	                }
	            }
	
	            function resultSuccess() {
	                isLap = 0;
	                that.rect.attr("style", {
	                    stroke: "rgba(0, 0, 0, 1)"
	                });
	            }
	
	            function resultFalse() {
	                isLap = 1;
	                that.rect.attr("style", {
	                    stroke: "rgba(255, 0, 0, 1)"
	                });
	            }
	
	            //判断是否有重叠  排除去了子流程里面的节点
	            if (!dom.parent) {
	                for (var l = 0, len = that.overlapArray.length; l < len; l++) {
	                    var rectDom = that.overlapArray[l];
	                    resultSuccess();
	                    //与拖拽节点不相等
	                    if (rectDom.id != that.rect.id && rectDom.id != dom.id) {
	                        if (shapeList.width > rectDom.width) {
	                            ////移动的位置 减去当前节点的位置 小于拖拽节点高度及宽度一半， 则有重叠 标红
	                            if (shapeList.height > rectDom.height) {
	                                if (Math.abs(nowRectPosition[0] - (rectDom.position[0])) < shapeList.width / 2 && Math.abs(nowRectPosition[1] - (rectDom.position[1])) < shapeList.height / 2) {
	                                    resultFalse();
	                                    break;
	                                } else {
	                                    resultSuccess();
	                                }
	                            } else {
	                                if (Math.abs(nowRectPosition[0] - (rectDom.position[0])) < shapeList.width / 2 && Math.abs(nowRectPosition[1] - (rectDom.position[1])) < rectDom.height / 2) {
	                                    resultFalse();
	                                    break;
	                                } else {
	                                    resultSuccess();
	                                }
	                            }
	
	                        } else {
	                            if (shapeList.height > rectDom.height) {
	                                if (Math.abs(nowRectPosition[0] - (rectDom.position[0])) < rectDom.width / 2 && Math.abs(nowRectPosition[1] - (rectDom.position[1])) < shapeList.height / 2) {
	                                    resultFalse();
	                                    break;
	                                } else {
	                                    resultSuccess();
	                                }
	                            } else {
	                                if (Math.abs(nowRectPosition[0] - (rectDom.position[0])) < (rectDom.width / 2) && Math.abs(nowRectPosition[1] - (rectDom.position[1])) < (rectDom.height / 2)) {
	                                    resultFalse();
	                                    break;
	                                } else {
	                                    resultSuccess();
	                                }
	                            }
	
	                        }
	
	                    }
	                }
	            }
	            //判断事件节点是否可以依附，可以依附显示绿框
	            if (Bpmn.isSlotEvent(dom)) {
	                for (var i = 0; i < that.allNodes.length; i++) {
	                    if (that.allNodes[i].isCanSlot) {
	                        if (that.allNodes[i].slot && that.allNodes[i].slot.length > 0) {
	                            for (var a = 0; a < that.allNodes[i].slot.length; a++) {
	                                var slotPosition = [that.allNodes[i].slot[a].position[0] + that.allNodes[i].position[0], that.allNodes[i].slot[a].position[1] + that.allNodes[i].position[1]];
	                                if (nowRectPosition[0] == slotPosition[0] && nowRectPosition[1] == slotPosition[1]) {
	                                    that.rect.attr("style", {
	                                        stroke: "rgba(0, 255, 0, 1)"
	                                    });
	                                    break;
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	
	        }
	
	        function endDrag() {
	            that._zr.off('mousemove', moveFunction);
	            that._zr.off('mouseup', upFunction);
	            that._zr.off('globalout', upFunction);
	            if (dom.parent) {
	                dom.parent.off("globalout", upFunction);
	            }
	            that.rect.hide();
	            Guidelines.virtualXLine.attr("shape", {
	                x2: 0
	            });
	            Guidelines.virtualYLine.attr("shape", {
	                y2: 0
	            });
	            if (isLap == 0) {
	                if (dom.parent) {
	                    if (Bpmn.isSubProcess(dom.parent)) {
	                        var groupNodePositionX = dom.parent.getRect().width / 2 + (nowRectPosition[0] - dom.parent.getRect().x);
	                        var groupNodePositionY = dom.parent.getRect().height / 2 + (nowRectPosition[1] - dom.parent.getRect().y);
	                        if (dom.slotEvent && dom.slotEvent.length > 0) {
	                            for (var m = 0; m < dom.slotEvent.length; m++) {
	                                var slotEventPosition = [dom.slotEvent[m].position[0] + groupNodePositionX - zrUtil.clone(dom.position[0]) - dom.getBoundingRect().width / 2, dom.slotEvent[m].position[1] + groupNodePositionY - zrUtil.clone(dom.position[1]) - dom.getBoundingRect().height / 2];
	                                dom.slotEvent[m].attr("position", slotEventPosition);
	                                that.connectionManager.refreshLineByNode(dom.slotEvent[m]);
	                            }
	                        }
	                        dom.setPosition(groupNodePositionX, groupNodePositionY);
	                    }
	                } else {
	                    if (dom.slotEvent && dom.slotEvent.length > 0) {
	                        for (var n = 0; n < dom.slotEvent.length; n++) {
	                            var slotEventPosition = [dom.slotEvent[n].position[0] + nowRectPosition[0] - zrUtil.clone(dom.position[0]) - dom.getBoundingRect().width / 2, dom.slotEvent[n].position[1] + nowRectPosition[1] - zrUtil.clone(dom.position[1]) - dom.getBoundingRect().height / 2];
	                            dom.slotEvent[n].attr("position", slotEventPosition);
	                            that.connectionManager.refreshLineByNode(dom.slotEvent[n]);
	                        }
	                    }
	                    dom.setPosition(nowRectPosition[0], nowRectPosition[1]);
	                }
	                // if (dom.alarm) {
	                //     var newAlarmPosition = [nowRectPosition[0] - dom.getBoundingRect().width / 2 - (dom.alarm.getBoundingRect().width - 6), nowRectPosition[1] - dom.getBoundingRect().height / 2 - dom.alarm.getBoundingRect().height - 3];
	                //     dom.alarm.attr("position", newAlarmPosition);
	                // };
	                for (var b = 0; b < that.domArray.length; b++) {
	                    if (dom.id == that.domArray[b].id) {
	                        that.domArray[b].position = [nowRectPosition[0], nowRectPosition[1]];
	                    }
	                }
	                for (var j = 0; j < that.overlapArray.length; j++) {
	                    if (dom.id == that.overlapArray[j].id) {
	                        that.overlapArray[j] = {
	                            id: dom.id,
	                            position: [nowRectPosition[0], nowRectPosition[1]],
	                            width: dom.getRect().width,
	                            height: dom.getRect().height
	                        };
	                    }
	                }
	            }
	
	            if (isMove == 1) {
	                that.nodeClickHandler(dom);
	                that.connectionManager.refreshLineByNode(dom);
	                that.stepCounter();
	            }
	
	            //将事件节点与task节点绑定或解绑
	            if (Bpmn.isSlotEvent(dom)) {
	                for (var i = 0; i < that.allNodes.length; i++) {
	                    if (that.allNodes[i].isCanSlot) {
	                        if (that.allNodes[i].slot && that.allNodes[i].slot.length > 0) {
	                            for (var c = 0; c < that.allNodes[i].slot.length; c++) {
	                                var slotPosition = [that.allNodes[i].slot[c].position[0] + that.allNodes[i].position[0], that.allNodes[i].slot[c].position[1] + that.allNodes[i].position[1]];
	                                var newRectPosition = [];
	                                if (dom.parent) {
	                                    if (Bpmn.isSubProcess(dom.parent)) {
	                                        newRectPosition[0] = dom.parent.getRect().width / 2 + (nowRectPosition[0] - dom.parent.getRect().x);
	                                        newRectPosition[1] = dom.parent.getRect().height / 2 + (nowRectPosition[1] - dom.parent.getRect().y);
	                                    }
	                                } else {
	                                    newRectPosition = nowRectPosition;
	                                }
	                                if (newRectPosition[0] == slotPosition[0] && newRectPosition[1] == slotPosition[1]) {
	                                    that.allNodes[i].slotEvent.push(dom);
	                                    break;
	                                } else {
	                                    for (var k = 0; k < that.allNodes[i].slotEvent.length; k++) {
	                                        if (dom.id == that.allNodes[i].slotEvent[k].id) {
	                                            that.allNodes[i].slotEvent.splice(k, 1);
	                                        }
	                                    }
	                                }
	
	                            }
	                        }
	                    }
	                }
	            }
	        }
	
	        this._zr.on("mouseup", upFunction);
	        this._zr.on("globalout", upFunction);
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.creatTip = function(node) {
	        //创建task内容的提示
	        var group = new graphic.Group();
	        group.isShow = false;
	        var name = node.model.get("properties.name") || "";
	        var showName;
	        if (name.length > 64) {
	            showName = name.substr(0, 64) + '..';
	        } else {
	            showName = name;
	        }
	        var text = new graphic.Text({
	            style: {
	                text: showName,
	                textFont: '16px Microsoft YaHei',
	                fill: "#000000",
	                textBaseline: "top" //垂直对齐
	            },
	            position: [2, 0],
	            z: 2
	        });
	        text.name = "Text";
	        group.add(text);
	        var Polyline = new graphic.Polyline({
	            style: {
	                fill: '#f9f9f9',
	                stroke: '#bbbbbb'
	            },
	            z: 1
	        });
	        Polyline.name = "Polyline";
	        group.add(Polyline);
	        // var groupPosition = [node.position[0] - node.getBoundingRect().width/2 - (group.getBoundingRect().width - 6), node.position[1]- node.getBoundingRect().height / 2 - group.getBoundingRect().height - 3];
	        // group.attr("position", groupPosition);
	        this._zr.add(group);
	        node.alarm = group;
	        group.hide();
	        group.eachChild(function(child) {
	            child.hide();
	        });
	    };
	
	    fishTopoProto.stepCounter = function() {
	        this.stepJson.splice(this.step, this.stepJson.length - (this.step));
	        this.step += 1;
	        var json = this.toJson();
	        this.stepJson.push(JSON.stringify(json));
	    };
	    // fishTopoProto.stepForward = function() {
	    //     if (this.step < this.stepJson.length) {
	    //         this.clear(true);
	    //         this.step += 1;
	    //         var json = JSON.parse(this.stepJson[this.step - 1]);
	    //         this.fromJson(json);
	    //     }
	    // };
	    // fishTopoProto.stepBack = function() {
	    //     if (this.step > 0) {
	    //         this.clear(true);
	    //         this.step -= 1;
	    //         if (this.step - 1 >= 0) {
	    //             var json = JSON.parse(this.stepJson[this.step - 1]);
	    //             this.fromJson(json);
	    //         }
	    //     }
	    // };
	
	
	    zrUtil.mixin(FishTopoBpmn, Eventful);
	
	    // ---------对外暴露fishTopoBpmn------------------
	    var idBase = new Date() - 0;
	    var instances = {};
	    var DOM_ATTRIBUTE_KEY = '_fishTopoBpmn_instance_';
	
	    /**
	     * fishTopoBpmn全局对象，如果是amd方式加载，则直接返回
	     * @class fishTopoBpmn
	     * @singleton
	     */
	    var fishTopoBpmn = {
	        /**
	         * 版本号
	         * @type {String}
	         */
	        version: '1.7.0',
	        dependencies: {
	            zrender: '3.0.4'
	        }
	    };
	
	    /**
	     * 初始化dom元素为 bpmn对象
	     * @member fishTopoBpmn
	     * @param {HTMLElement} dom  一个div元素
	     * @param {Object} opts  传递的选项参数
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg' or 'vml'
	     * @param {number} [opts.devicePixelRatio=1] retina 屏幕优化
	     * @return {fish.topo.FishTopoBpmn}
	     */
	    fishTopoBpmn.init = function(dom, opts) {
	        if (!dom) {
	            throw new Error('Initialize failed: invalid dom.');
	        }
	
	        opts = opts || {};
	        // Default value
	        zrUtil.defaults(opts, {
	            type: "bpmn",
	            showGridLine: true,
	            devicePixelRatio: 1,
	            gridLineSpacing: 10
	        });
	
	        var fishTopoBpmn = new FishTopoBpmn(dom, opts);
	        fishTopoBpmn.init();
	
	        fishTopoBpmn.id = 'ft_' + idBase++;
	        instances[fishTopoBpmn.id] = fishTopoBpmn;
	
	        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoBpmn.id);
	
	        return fishTopoBpmn;
	    };
	
	
	    /**
	     * 获取 dom 容器上的实例。
	     * @member fishTopoBpmn
	     * @param  {HTMLElement} dom 一个div元素
	     * @return {fish.topo.FishTopoBpmn}
	     */
	    fishTopoBpmn.getInstanceByDom = function(dom) {
	        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
	        return instances[key];
	    };
	
	    /**
	     * 销毁实例，实例销毁后无法再被使用。
	     * @member fishTopoBpmn
	     * @param  {Object|string} chart fishTopoBpmn实例 或 fishTopoBpmn的id
	     */
	    fishTopoBpmn.dispose = function(chart) {
	        var topo;
	        if (zrUtil.isDom(chart)) {
	            topo = fishTopoBpmn.getInstanceByDom(chart);
	        } else if (typeof chart === 'string') {
	            topo = instances[chart];
	        }
	        if ((topo instanceof fishTopoBpmn) && !topo.isDisposed()) {
	            topo.dispose();
	        }
	    };
	    //暴露出去的类 方便用户扩展图元
	    fishTopoBpmn.Bpmn = Bpmn;
	    fishTopoBpmn.BPMNNode = BPMNNode;
	    fishTopoBpmn.graphic = graphic;
	    fishTopoBpmn.BoundingRect = BoundingRect;
	
	    fishTopoBpmn.util = {};
	    zrUtil.each([
	            'map', 'each', 'filter', 'indexOf', 'inherits',
	            'reduce', 'filter', 'bind', 'curry', 'isArray',
	            'isString', 'isObject', 'isFunction', 'extend'
	        ],
	        function(name) {
	            fishTopoBpmn.util[name] = zrUtil[name];
	        }
	    );
	    module.exports = fishTopoBpmn;
	


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var pathTool = __webpack_require__(5);
	    var round = Math.round;
	    var Path = __webpack_require__(6);
	    var colorTool = __webpack_require__(19);
	    var matrix = __webpack_require__(13);
	    var vector = __webpack_require__(14);
	    var Gradient = __webpack_require__(38);
	    var Draggable = __webpack_require__(39);
	
	    var graphic = {};
	    graphic.Util = zrUtil;
	    graphic.Group = __webpack_require__(40);
	
	    graphic.Image = __webpack_require__(41);
	
	    graphic.Text = __webpack_require__(42);
	
	    graphic.textContain = __webpack_require__(24);
	
	    graphic.Circle = __webpack_require__(43);
	
	    graphic.Sector = __webpack_require__(44);
	
	    graphic.Ring = __webpack_require__(46);
	
	    graphic.Polygon = __webpack_require__(47);
	
	    graphic.Polyline = __webpack_require__(51);
	
	    graphic.Rect = __webpack_require__(52);
	
	    graphic.Line = __webpack_require__(54);
	
	    graphic.BezierCurve = __webpack_require__(55);
	
	    graphic.Arc = __webpack_require__(56);
	
	    graphic.LinearGradient = __webpack_require__(57);
	
	    graphic.RadialGradient = __webpack_require__(58);
	
	    graphic.BoundingRect = __webpack_require__(25);
	
	    /**
	     * Extend shape with parameters
	     */
	    graphic.extendShape = function (opts) {
	        return Path.extend(opts);
	    };
	
	    /**
	     * Extend path
	     */
	    graphic.extendPath = function (pathData, opts) {
	        return pathTool.extendFromString(pathData, opts);
	    };
	
	    /**
	     * Create a path element from path data string
	     * @param {string} pathData
	     * @param {Object} opts
	     * @param {module:zrender/core/BoundingRect} rect
	     * @param {string} [layout=cover] 'center' or 'cover'
	     */
	    graphic.makePath = function (pathData, opts, rect, layout) {
	        var path = pathTool.createFromString(pathData, opts);
	        Draggable.call(path);
	        var boundingRect = path.getBoundingRect();
	        if (rect) {
	            var aspect = boundingRect.width / boundingRect.height;
	
	            if (layout === 'center') {
	                // Set rect to center, keep width / height ratio.
	                var width = rect.height * aspect;
	                var height;
	                if (width <= rect.width) {
	                    height = rect.height;
	                }
	                else {
	                    width = rect.width;
	                    height = width / aspect;
	                }
	                var cx = rect.x + rect.width / 2;
	                var cy = rect.y + rect.height / 2;
	
	                rect.x = cx - width / 2;
	                rect.y = cy - height / 2;
	                rect.width = width;
	                rect.height = height;
	            }
	
	            this.resizePath(path, rect);
	        }
	
	        zrUtil.inherits(path, Draggable);
	        return path;
	    };
	
	    graphic.mergePath = pathTool.mergePath;
	
	    /**
	     * Resize a path to fit the rect
	     * @param {module:zrender/graphic/Path} path
	     * @param {Object} rect
	     */
	    graphic.resizePath = function (path, rect) {
	        if (!path.applyTransform) {
	            return;
	        }
	
	        var pathRect = path.getBoundingRect();
	
	        var m = pathRect.calculateTransform(rect);
	
	        path.applyTransform(m);
	    };
	
	    /**
	     * Sub pixel optimize line for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x1]
	     * @param {number} [param.shape.y1]
	     * @param {number} [param.shape.x2]
	     * @param {number} [param.shape.y2]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeLine = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	
	        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
	            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
	        }
	        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
	            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
	        }
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize rect for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x]
	     * @param {number} [param.shape.y]
	     * @param {number} [param.shape.width]
	     * @param {number} [param.shape.height]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeRect = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	        var originX = shape.x;
	        var originY = shape.y;
	        var originWidth = shape.width;
	        var originHeight = shape.height;
	        shape.x = subPixelOptimize(shape.x, lineWidth, true);
	        shape.y = subPixelOptimize(shape.y, lineWidth, true);
	        shape.width = Math.max(
	            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,
	            originWidth === 0 ? 0 : 1
	        );
	        shape.height = Math.max(
	            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,
	            originHeight === 0 ? 0 : 1
	        );
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize for canvas
	     *
	     * @param {number} position Coordinate, such as x, y
	     * @param {number} lineWidth Should be nonnegative integer.
	     * @param {boolean=} positiveOrNegative Default false (negative).
	     * @return {number} Optimized position.
	     */
	    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {
	        // Assure that (position + lineWidth / 2) is near integer edge,
	        // otherwise line will be fuzzy in canvas.
	        var doubledPosition = round(position * 2);
	        return (doubledPosition + round(lineWidth)) % 2 === 0
	            ? doubledPosition / 2
	            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
	    };
	
	    /**
	     * @private
	     */
	    function doSingleEnterHover(el) {
	        if (el.__isHover) {
	            return;
	        }
	        if (el.__hoverStlDirty) {
	            var stroke = el.style.stroke;
	            var fill = el.style.fill;
	
	            // Create hoverStyle on mouseover
	            var hoverStyle = el.__hoverStl;
	            var lift = colorTool.lift;
	            hoverStyle.fill = hoverStyle.fill
	                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));
	            hoverStyle.stroke = hoverStyle.stroke
	                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));
	
	            var normalStyle = {};
	            for (var name in hoverStyle) {
	                if (hoverStyle.hasOwnProperty(name)) {
	                    normalStyle[name] = el.style[name];
	                }
	            }
	
	            el.__normalStl = normalStyle;
	
	            el.__hoverStlDirty = false;
	        }
	        el.setStyle(el.__hoverStl);
	        el.z2 += 1;
	
	        el.__isHover = true;
	    }
	
	    /**
	     * @inner
	     */
	    function doSingleLeaveHover(el) {
	        if (!el.__isHover) {
	            return;
	        }
	
	        var normalStl = el.__normalStl;
	        normalStl && el.setStyle(normalStl);
	        el.z2 -= 1;
	
	        el.__isHover = false;
	    }
	
	    /**
	     * @inner
	     */
	    function doEnterHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleEnterHover(child);
	                }
	            })
	            : doSingleEnterHover(el);
	    }
	    graphic.doEnterHover = doEnterHover;
	    function doLeaveHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleLeaveHover(child);
	                }
	            })
	            : doSingleLeaveHover(el);
	    }
	    graphic.doLeaveHover = doLeaveHover;
	    /**
	     * @inner
	     */
	    function setElementHoverStl(el, hoverStl) {
	        // If element has sepcified hoverStyle, then use it instead of given hoverStyle
	        // Often used when item group has a label element and it's hoverStyle is different
	        el.__hoverStl = el.hoverStyle || hoverStl || {};
	        el.__hoverStlDirty = true;
	    }
	    graphic.setElementHoverStl = setElementHoverStl;
	    /**
	     * @inner
	     */
	    function onElementMouseOver() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function onElementMouseOut() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doLeaveHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function enterEmphasis() {
	        this.__isEmphasis = true;
	        doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function leaveEmphasis() {
	        this.__isEmphasis = false;
	        doLeaveHover(this);
	    }
	
	    /**
	     * Set hover style of element
	     * @param {module:zrender/Element} el
	     * @param {Object} [hoverStyle]
	     */
	    graphic.setHoverStyle = function (el, hoverStyle) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    setElementHoverStl(child, hoverStyle);
	                }
	            })
	            : setElementHoverStl(el, hoverStyle);
	        // Remove previous bound handlers
	        el.on('mouseover', onElementMouseOver)
	          .on('mouseout', onElementMouseOut);
	
	        // Emphasis, normal can be triggered manually
	        el.on('emphasis', enterEmphasis)
	          .on('normal', leaveEmphasis);
	    };
	
	    graphic.setNormalStyle = function(el, options) {
	        if (el.__normalStl) {
	            for (var name in options) {
	                if (el.__normalStl.hasOwnProperty(name)) {
	                    el.__normalStl[name] = options[name];
	                }
	            }
	        }
	    };
	
	    /**
	     * Set text option in the style
	     * @param {Object} textStyle
	     * @param {module:echarts/model/Model} labelModel
	     * @param {string} color
	     */
	    graphic.setText = function (textStyle, labelModel, color) {
	        var labelPosition = labelModel.getShallow('position') || 'inside';
	        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;
	        var textStyleModel = labelModel.getModel('textStyle');
	        zrUtil.extend(textStyle, {
	            textDistance: labelModel.getShallow('distance') || 5,
	            textFont: textStyleModel.getFont(),
	            textPosition: labelPosition,
	            textFill: textStyleModel.getTextColor() || labelColor
	        });
	    };
	
	    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {
	        var postfix = isUpdate ? 'Update' : '';
	        var duration = animatableModel
	            && animatableModel.getShallow('animationDuration' + postfix);
	        var animationEasing = animatableModel
	            && animatableModel.getShallow('animationEasing' + postfix);
	
	        animatableModel && animatableModel.getShallow('animation')
	            ? el.animateTo(props, duration, animationEasing, cb)
	            : (el.attr(props), cb && cb());
	    }
	    /**
	     * Update graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);
	
	    /**
	     * Init graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.initProps = zrUtil.curry(animateOrSetProps, false);
	
	    /**
	     * Get transform matrix of target (param target),
	     * in coordinate of its ancestor (param ancestor)
	     *
	     * @param {module:zrender/mixin/Transformable} target
	     * @param {module:zrender/mixin/Transformable} ancestor
	     */
	    graphic.getTransform = function (target, ancestor) {
	        var mat = matrix.identity([]);
	
	        while (target && target !== ancestor) {
	            matrix.mul(mat, target.getLocalTransform(), mat);
	            target = target.parent;
	        }
	
	        return mat;
	    };
	
	    /**
	     * Apply transform to an vertex.
	     * @param {Array.<number>} vertex [x, y]
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {Array.<number>} [x, y]
	     */
	    graphic.applyTransform = function (vertex, transform, invert) {
	        if (invert) {
	            transform = matrix.invert([], transform);
	        }
	        return vector.applyTransform([], vertex, transform);
	    };
	
	    /**
	     * @param {string} direction 'left' 'right' 'top' 'bottom'
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
	     */
	    graphic.transformDirection = function (direction, transform, invert) {
	
	        // Pick a base, ensure that transform result will not be (0, 0).
	        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[0]);
	        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[2]);
	
	        var vertex = [
	            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,
	            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0
	        ];
	
	        vertex = graphic.applyTransform(vertex, transform, invert);
	
	        return Math.abs(vertex[0]) > Math.abs(vertex[1])
	            ? (vertex[0] > 0 ? 'right' : 'left')
	            : (vertex[1] > 0 ? 'bottom' : 'top');
	    };
	
	    module.exports = graphic;
	


/***/ },
/* 4 */
/***/ function(module, exports) {

	/**
	 * @module zrender/core/util
	 */
	
	
	    // 用于处理merge时无法遍历Date等对象的问题
	    var BUILTIN_OBJECT = {
	        '[object Function]': 1,
	        '[object RegExp]': 1,
	        '[object Date]': 1,
	        '[object Error]': 1,
	        '[object CanvasGradient]': 1,
	        '[object CanvasPattern]': 1,
	        // For node-canvas
	        '[object Image]': 1,
	        '[object Canvas]': 1
	    };
	
	    var TYPED_ARRAY = {
	        '[object Int8Array]': 1,
	        '[object Uint8Array]': 1,
	        '[object Uint8ClampedArray]': 1,
	        '[object Int16Array]': 1,
	        '[object Uint16Array]': 1,
	        '[object Int32Array]': 1,
	        '[object Uint32Array]': 1,
	        '[object Float32Array]': 1,
	        '[object Float64Array]': 1
	    };
	
	    var objToString = Object.prototype.toString;
	
	    var arrayProto = Array.prototype;
	    var nativeForEach = arrayProto.forEach;
	    var nativeFilter = arrayProto.filter;
	    var nativeSlice = arrayProto.slice;
	    var nativeMap = arrayProto.map;
	    var nativeReduce = arrayProto.reduce;
	
	    /**
	     * Those data types can be cloned:
	     *     Plain object, Array, TypedArray, number, string, null, undefined.
	     * Those data types will be assgined using the orginal data:
	     *     BUILTIN_OBJECT
	     * Instance of user defined class will be cloned to a plain object, without
	     * properties in prototype.
	     * Other data types is not supported (not sure what will happen).
	     *
	     * Caution: do not support clone Date, for performance consideration.
	     * (There might be a large number of date in `series.data`).
	     * So date should not be modified in and out of echarts.
	     *
	     * @param {*} source
	     * @return {*} new
	     */
	    function clone(source) {
	        if (source == null || typeof source != 'object') {
	            return source;
	        }
	
	        var result = source;
	        var typeStr = objToString.call(source);
	
	        if (typeStr === '[object Array]') {
	            result = [];
	            for (var i = 0, len = source.length; i < len; i++) {
	                result[i] = clone(source[i]);
	            }
	        }
	        else if (TYPED_ARRAY[typeStr]) {
	            result = source.constructor.from(source);
	        }
	        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
	            result = {};
	            for (var key in source) {
	                if (source.hasOwnProperty(key)) {
	                    result[key] = clone(source[key]);
	                }
	            }
	        }
	
	        return result;
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} target
	     * @param {*} source
	     * @param {boolean} [overwrite=false]
	     */
	    function merge(target, source, overwrite) {
	        // We should escapse that source is string
	        // and enter for ... in ...
	        if (!isObject(source) || !isObject(target)) {
	            return overwrite ? clone(source) : target;
	        }
	
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                var targetProp = target[key];
	                var sourceProp = source[key];
	
	                if (isObject(sourceProp)
	                    && isObject(targetProp)
	                    && !isArray(sourceProp)
	                    && !isArray(targetProp)
	                    && !isDom(sourceProp)
	                    && !isDom(targetProp)
	                    && !isBuiltInObject(sourceProp)
	                    && !isBuiltInObject(targetProp)
	                    && !isPrimitive(sourceProp)
	                    && !isPrimitive(targetProp)
	                ) {
	                    // 如果需要递归覆盖，就递归调用merge
	                    merge(targetProp, sourceProp, overwrite);
	                }
	                else if (overwrite || !(key in target)) {
	                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
	                    // NOTE，在 target[key] 不存在的时候也是直接覆盖
	                    target[key] = clone(source[key], true);
	                }
	            }
	        }
	
	        return target;
	    }
	
	    /**
	     * @param {Array} targetAndSources The first item is target, and the rests are source.
	     * @param {boolean} [overwrite=false]
	     * @return {*} target
	     */
	    function mergeAll(targetAndSources, overwrite) {
	        var result = targetAndSources[0];
	        for (var i = 1, len = targetAndSources.length; i < len; i++) {
	            result = merge(result, targetAndSources[i], overwrite);
	        }
	        return result;
	    }
	
	    /**
	     * @param {*} target
	     * @param {*} source
	     * @memberOf module:zrender/core/util
	     */
	    function extend(target, source) {
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                target[key] = source[key];
	            }
	        }
	        return target;
	    }
	
	    /**
	     * @param {*} target
	     * @param {*} source
	     * @param {boolen} [overlay=false]
	     * @memberOf module:zrender/core/util
	     */
	    function defaults(target, source, overlay) {
	        for (var key in source) {
	            if (source.hasOwnProperty(key)
	                && (overlay ? source[key] != null : target[key] == null)
	            ) {
	                target[key] = source[key];
	            }
	        }
	        return target;
	    }
	
	    function createCanvas() {
	        return document.createElement('canvas');
	    }
	    // FIXME
	    var _ctx;
	    function getContext() {
	        if (!_ctx) {
	            // Use util.createCanvas instead of createCanvas
	            // because createCanvas may be overwritten in different environment
	            _ctx = util.createCanvas().getContext('2d');
	        }
	        return _ctx;
	    }
	
	    /**
	     * 查询数组中元素的index
	     * @memberOf module:zrender/core/util
	     */
	    function indexOf(array, value) {
	        if (array) {
	            if (array.indexOf) {
	                return array.indexOf(value);
	            }
	            for (var i = 0, len = array.length; i < len; i++) {
	                if (array[i] === value) {
	                    return i;
	                }
	            }
	        }
	        return -1;
	    }
	
	    /**
	     * 构造类继承关系
	     *
	     * @memberOf module:zrender/core/util
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
	    function inherits(clazz, baseClazz) {
	        var clazzPrototype = clazz.prototype;
	        function F() {}
	        F.prototype = baseClazz.prototype;
	        clazz.prototype = new F();
	
	        for (var prop in clazzPrototype) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	        clazz.prototype.constructor = clazz;
	        clazz.superClass = baseClazz;
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Object|Function} target
	     * @param {Object|Function} sorce
	     * @param {boolean} overlay
	     */
	    function mixin(target, source, overlay) {
	        target = 'prototype' in target ? target.prototype : target;
	        source = 'prototype' in source ? source.prototype : source;
	
	        defaults(target, source, overlay);
	    }
	
	    /**
	     * @param {Array|TypedArray} data
	     */
	    function isArrayLike(data) {
	        if (! data) {
	            return;
	        }
	        if (typeof data == 'string') {
	            return false;
	        }
	        return typeof data.length == 'number';
	    }
	
	    /**
	     * 数组或对象遍历
	     * @memberOf module:zrender/core/util
	     * @param {Object|Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     */
	    function each(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.forEach && obj.forEach === nativeForEach) {
	            obj.forEach(cb, context);
	        }
	        else if (obj.length === +obj.length) {
	            for (var i = 0, len = obj.length; i < len; i++) {
	                cb.call(context, obj[i], i, obj);
	            }
	        }
	        else {
	            for (var key in obj) {
	                if (obj.hasOwnProperty(key)) {
	                    cb.call(context, obj[key], key, obj);
	                }
	            }
	        }
	    }
	
	    /**
	     * 数组映射
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function map(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.map && obj.map === nativeMap) {
	            return obj.map(cb, context);
	        }
	        else {
	            var result = [];
	            for (var i = 0, len = obj.length; i < len; i++) {
	                result.push(cb.call(context, obj[i], i, obj));
	            }
	            return result;
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {Object} [memo]
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function reduce(obj, cb, memo, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.reduce && obj.reduce === nativeReduce) {
	            return obj.reduce(cb, memo, context);
	        }
	        else {
	            for (var i = 0, len = obj.length; i < len; i++) {
	                memo = cb.call(context, memo, obj[i], i, obj);
	            }
	            return memo;
	        }
	    }
	
	    /**
	     * 数组过滤
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function filter(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.filter && obj.filter === nativeFilter) {
	            return obj.filter(cb, context);
	        }
	        else {
	            var result = [];
	            for (var i = 0, len = obj.length; i < len; i++) {
	                if (cb.call(context, obj[i], i, obj)) {
	                    result.push(obj[i]);
	                }
	            }
	            return result;
	        }
	    }
	
	    /**
	     * 数组项查找
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function find(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        for (var i = 0, len = obj.length; i < len; i++) {
	            if (cb.call(context, obj[i], i, obj)) {
	                return obj[i];
	            }
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Function} func
	     * @param {*} context
	     * @return {Function}
	     */
	    function bind(func, context) {
	        var args = nativeSlice.call(arguments, 2);
	        return function () {
	            return func.apply(context, args.concat(nativeSlice.call(arguments)));
	        };
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Function} func
	     * @return {Function}
	     */
	    function curry(func) {
	        var args = nativeSlice.call(arguments, 1);
	        return function () {
	            return func.apply(this, args.concat(nativeSlice.call(arguments)));
	        };
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isArray(value) {
	        return objToString.call(value) === '[object Array]';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isFunction(value) {
	        return typeof value === 'function';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isString(value) {
	        return objToString.call(value) === '[object String]';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isObject(value) {
	        // Avoid a V8 JIT bug in Chrome 19-20.
	        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	        var type = typeof value;
	        return type === 'function' || (!!value && type == 'object');
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isBuiltInObject(value) {
	        return !!BUILTIN_OBJECT[objToString.call(value)];
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isDom(value) {
	        return typeof value === 'object'
	            && typeof value.nodeType === 'number'
	            && typeof value.ownerDocument === 'object';
	    }
	
	    /**
	     * Whether is exactly NaN. Notice isNaN('a') returns true.
	     * @param {*} value
	     * @return {boolean}
	     */
	    function eqNaN(value) {
	        return value !== value;
	    }
	
	    /**
	     * If value1 is not null, then return value1, otherwise judget rest of values.
	     * @memberOf module:zrender/core/util
	     * @return {*} Final value
	     */
	    function retrieve(values) {
	        for (var i = 0, len = arguments.length; i < len; i++) {
	            if (arguments[i] != null) {
	                return arguments[i];
	            }
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Array} arr
	     * @param {number} startIndex
	     * @param {number} endIndex
	     * @return {Array}
	     */
	    function slice() {
	        return Function.call.apply(nativeSlice, arguments);
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {boolean} condition
	     * @param {string} message
	     */
	    function assert(condition, message) {
	        if (!condition) {
	            throw new Error(message);
	        }
	    }
	
	    var primitiveKey = '__ec_primitive__';
	    /**
	     * Set an object as primitive to be ignored traversing children in clone or merge
	     */
	    function setAsPrimitive(obj) {
	        obj[primitiveKey] = true;
	    }
	
	    function isPrimitive(obj) {
	        return obj[primitiveKey];
	    }
	
	    var util = {
	        inherits: inherits,
	        mixin: mixin,
	        clone: clone,
	        merge: merge,
	        mergeAll: mergeAll,
	        extend: extend,
	        defaults: defaults,
	        getContext: getContext,
	        createCanvas: createCanvas,
	        indexOf: indexOf,
	        slice: slice,
	        find: find,
	        isArrayLike: isArrayLike,
	        each: each,
	        map: map,
	        reduce: reduce,
	        filter: filter,
	        bind: bind,
	        curry: curry,
	        isArray: isArray,
	        isString: isString,
	        isObject: isObject,
	        isFunction: isFunction,
	        isBuiltInObject: isBuiltInObject,
	        isDom: isDom,
	        eqNaN: eqNaN,
	        retrieve: retrieve,
	        assert: assert,
	        setAsPrimitive: setAsPrimitive,
	        noop: function () {}
	    };
	    module.exports = util;
	


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var Path = __webpack_require__(6);
	    var PathProxy = __webpack_require__(26);
	    var transformPath = __webpack_require__(37);
	    var matrix = __webpack_require__(13);
	
	    // command chars
	    var cc = [
	        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',
	        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'
	    ];
	
	    var mathSqrt = Math.sqrt;
	    var mathSin = Math.sin;
	    var mathCos = Math.cos;
	    var PI = Math.PI;
	
	    var vMag = function(v) {
	        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	    };
	    var vRatio = function(u, v) {
	        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
	    };
	    var vAngle = function(u, v) {
	        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)
	                * Math.acos(vRatio(u, v));
	    };
	
	    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
	        var psi = psiDeg * (PI / 180.0);
	        var xp = mathCos(psi) * (x1 - x2) / 2.0
	                 + mathSin(psi) * (y1 - y2) / 2.0;
	        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0
	                 + mathCos(psi) * (y1 - y2) / 2.0;
	
	        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
	
	        if (lambda > 1) {
	            rx *= mathSqrt(lambda);
	            ry *= mathSqrt(lambda);
	        }
	
	        var f = (fa === fs ? -1 : 1)
	            * mathSqrt((((rx * rx) * (ry * ry))
	                    - ((rx * rx) * (yp * yp))
	                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)
	                    + (ry * ry) * (xp * xp))
	                ) || 0;
	
	        var cxp = f * rx * yp / ry;
	        var cyp = f * -ry * xp / rx;
	
	        var cx = (x1 + x2) / 2.0
	                 + mathCos(psi) * cxp
	                 - mathSin(psi) * cyp;
	        var cy = (y1 + y2) / 2.0
	                + mathSin(psi) * cxp
	                + mathCos(psi) * cyp;
	
	        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);
	        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];
	        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];
	        var dTheta = vAngle(u, v);
	
	        if (vRatio(u, v) <= -1) {
	            dTheta = PI;
	        }
	        if (vRatio(u, v) >= 1) {
	            dTheta = 0;
	        }
	        if (fs === 0 && dTheta > 0) {
	            dTheta = dTheta - 2 * PI;
	        }
	        if (fs === 1 && dTheta < 0) {
	            dTheta = dTheta + 2 * PI;
	        }
	
	        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
	    }
	
	    function createPathProxyFromString(data) {
	        if (!data) {
	            return [];
	        }
	
	        // command string
	        var cs = data.replace(/-/g, ' -')
	            .replace(/  /g, ' ')
	            .replace(/ /g, ',')
	            .replace(/,,/g, ',');
	
	        var n;
	        // create pipes so that we can split the data
	        for (n = 0; n < cc.length; n++) {
	            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
	        }
	
	        // create array
	        var arr = cs.split('|');
	        // init context point
	        var cpx = 0;
	        var cpy = 0;
	
	        var path = new PathProxy();
	        var CMD = PathProxy.CMD;
	
	        var prevCmd;
	        for (n = 1; n < arr.length; n++) {
	            var str = arr[n];
	            var c = str.charAt(0);
	            var off = 0;
	            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
	            var cmd;
	
	            if (p.length > 0 && p[0] === '') {
	                p.shift();
	            }
	
	            for (var i = 0; i < p.length; i++) {
	                p[i] = parseFloat(p[i]);
	            }
	            while (off < p.length && !isNaN(p[off])) {
	                if (isNaN(p[0])) {
	                    break;
	                }
	                var ctlPtx;
	                var ctlPty;
	
	                var rx;
	                var ry;
	                var psi;
	                var fa;
	                var fs;
	
	                var x1 = cpx;
	                var y1 = cpy;
	
	                // convert l, H, h, V, and v to L
	                switch (c) {
	                    case 'l':
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'L':
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'm':
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.M;
	                        path.addData(cmd, cpx, cpy);
	                        c = 'l';
	                        break;
	                    case 'M':
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.M;
	                        path.addData(cmd, cpx, cpy);
	                        c = 'L';
	                        break;
	                    case 'h':
	                        cpx += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'H':
	                        cpx = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'v':
	                        cpy += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'V':
	                        cpy = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'C':
	                        cmd = CMD.C;
	                        path.addData(
	                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]
	                        );
	                        cpx = p[off - 2];
	                        cpy = p[off - 1];
	                        break;
	                    case 'c':
	                        cmd = CMD.C;
	                        path.addData(
	                            cmd,
	                            p[off++] + cpx, p[off++] + cpy,
	                            p[off++] + cpx, p[off++] + cpy,
	                            p[off++] + cpx, p[off++] + cpy
	                        );
	                        cpx += p[off - 2];
	                        cpy += p[off - 1];
	                        break;
	                    case 'S':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.C) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cmd = CMD.C;
	                        x1 = p[off++];
	                        y1 = p[off++];
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	                        break;
	                    case 's':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.C) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cmd = CMD.C;
	                        x1 = cpx + p[off++];
	                        y1 = cpy + p[off++];
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	                        break;
	                    case 'Q':
	                        x1 = p[off++];
	                        y1 = p[off++];
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, x1, y1, cpx, cpy);
	                        break;
	                    case 'q':
	                        x1 = p[off++] + cpx;
	                        y1 = p[off++] + cpy;
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, x1, y1, cpx, cpy);
	                        break;
	                    case 'T':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.Q) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 't':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.Q) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 'A':
	                        rx = p[off++];
	                        ry = p[off++];
	                        psi = p[off++];
	                        fa = p[off++];
	                        fs = p[off++];
	
	                        x1 = cpx, y1 = cpy;
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.A;
	                        processArc(
	                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path
	                        );
	                        break;
	                    case 'a':
	                        rx = p[off++];
	                        ry = p[off++];
	                        psi = p[off++];
	                        fa = p[off++];
	                        fs = p[off++];
	
	                        x1 = cpx, y1 = cpy;
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.A;
	                        processArc(
	                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path
	                        );
	                        break;
	                }
	            }
	
	            if (c === 'z' || c === 'Z') {
	                cmd = CMD.Z;
	                path.addData(cmd);
	            }
	
	            prevCmd = cmd;
	        }
	
	        path.toStatic();
	
	        return path;
	    }
	
	    // TODO Optimize double memory cost problem
	    function createPathOptions(str, opts) {
	        var pathProxy = createPathProxyFromString(str);
	        var transform;
	        opts = opts || {};
	        opts.buildPath = function (path) {
	            path.setData(pathProxy.data);
	            transform && transformPath(path, transform);
	            // Svg and vml renderer don't have context
	            var ctx = path.getContext();
	            if (ctx) {
	                path.rebuildPath(ctx);
	            }
	        };
	
	        opts.applyTransform = function (m) {
	            if (!transform) {
	                transform = matrix.create();
	            }
	            matrix.mul(transform, m, transform);
	            this.dirty(true);
	        };
	
	        return opts;
	    }
	
	    module.exports = {
	        /**
	         * Create a Path object from path string data
	         * http://www.w3.org/TR/SVG/paths.html#PathData
	         * @param  {Object} opts Other options
	         */
	        createFromString: function (str, opts) {
	            return new Path(createPathOptions(str, opts));
	        },
	
	        /**
	         * Create a Path class from path string data
	         * @param  {string} str
	         * @param  {Object} opts Other options
	         */
	        extendFromString: function (str, opts) {
	            return Path.extend(createPathOptions(str, opts));
	        },
	
	        /**
	         * Merge multiple paths
	         */
	        // TODO Apply transform
	        // TODO stroke dash
	        // TODO Optimize double memory cost problem
	        mergePath: function (pathEls, opts) {
	            var pathList = [];
	            var len = pathEls.length;
	            for (var i = 0; i < len; i++) {
	                var pathEl = pathEls[i];
	                if (pathEl.__dirty) {
	                    pathEl.buildPath(pathEl.path, pathEl.shape, true);
	                }
	                pathList.push(pathEl.path);
	            }
	
	            var pathBundle = new Path(opts);
	            pathBundle.buildPath = function (path) {
	                path.appendPath(pathList);
	                // Svg and vml renderer don't have context
	                var ctx = path.getContext();
	                if (ctx) {
	                    path.rebuildPath(ctx);
	                }
	            };
	
	            return pathBundle;
	        }
	    };


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Path element
	 * @module zrender/graphic/Path
	 */
	
	
	
	    var Displayable = __webpack_require__(7);
	    var zrUtil = __webpack_require__(4);
	    var PathProxy = __webpack_require__(26);
	    var pathContain = __webpack_require__(29);
	
	    var Pattern = __webpack_require__(36);
	    var getCanvasPattern = Pattern.prototype.getCanvasPattern;
	
	    var abs = Math.abs;
	
	    /**
	     * @alias module:zrender/graphic/Path
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    function Path(opts) {
	        Displayable.call(this, opts);
	
	        /**
	         * @type {module:zrender/core/PathProxy}
	         * @readOnly
	         */
	        this.path = new PathProxy();
	    }
	
	    Path.prototype = {
	
	        constructor: Path,
	
	        type: 'path',
	
	        __dirtyPath: true,
	
	        strokeContainThreshold: 5,
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var path = this.path;
	            var hasStroke = style.hasStroke();
	            var hasFill = style.hasFill();
	            var fill = style.fill;
	            var stroke = style.stroke;
	            var hasFillGradient = hasFill && !!(fill.colorStops);
	            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);
	            var hasFillPattern = hasFill && !!(fill.image);
	            var hasStrokePattern = hasStroke && !!(stroke.image);
	
	            style.bind(ctx, this, prevEl);
	            this.setTransform(ctx);
	
	            if (this.__dirty) {
	                var rect = this.getBoundingRect();
	                // Update gradient because bounding rect may changed
	                if (hasFillGradient) {
	                    this._fillGradient = style.getGradient(ctx, fill, rect);
	                }
	                if (hasStrokeGradient) {
	                    this._strokeGradient = style.getGradient(ctx, stroke, rect);
	                }
	            }
	            // Use the gradient or pattern
	            if (hasFillGradient) {
	                // PENDING If may have affect the state
	                ctx.fillStyle = this._fillGradient;
	            }
	            else if (hasFillPattern) {
	                ctx.fillStyle = getCanvasPattern.call(fill, ctx);
	            }
	            if (hasStrokeGradient) {
	                ctx.strokeStyle = this._strokeGradient;
	            }
	            else if (hasStrokePattern) {
	                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
	            }
	
	            var lineDash = style.lineDash;
	            var lineDashOffset = style.lineDashOffset;
	
	            var ctxLineDash = !!ctx.setLineDash;
	
	            // Update path sx, sy
	            var scale = this.getGlobalScale();
	            path.setScale(scale[0], scale[1]);
	
	            // Proxy context
	            // Rebuild path in following 2 cases
	            // 1. Path is dirty
	            // 2. Path needs javascript implemented lineDash stroking.
	            //    In this case, lineDash information will not be saved in PathProxy
	            if (this.__dirtyPath || (
	                lineDash && !ctxLineDash && hasStroke
	            )) {
	                path = this.path.beginPath(ctx);
	
	                // Setting line dash before build path
	                if (lineDash && !ctxLineDash) {
	                    path.setLineDash(lineDash);
	                    path.setLineDashOffset(lineDashOffset);
	                }
	
	                this.buildPath(path, this.shape, false);
	
	                // Clear path dirty flag
	                this.__dirtyPath = false;
	            }
	            else {
	                // Replay path building
	                ctx.beginPath();
	                this.path.rebuildPath(ctx);
	            }
	
	            hasFill && path.fill(ctx);
	
	            if (lineDash && ctxLineDash) {
	                ctx.setLineDash(lineDash);
	                ctx.lineDashOffset = lineDashOffset;
	            }
	
	            hasStroke && path.stroke(ctx);
	
	            if (lineDash && ctxLineDash) {
	                // PENDING
	                // Remove lineDash
	                ctx.setLineDash([]);
	            }
	
	
	            this.restoreTransform(ctx);
	
	            // Draw rect text
	            if (style.text != null) {
	                // var rect = this.getBoundingRect();
	                this.drawRectText(ctx, this.getBoundingRect());
	            }
	        },
	
	        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
	        // Like in circle
	        buildPath: function (ctx, shapeCfg, inBundle) {},
	
	        getBoundingRect: function () {
	            var rect = this._rect;
	            var style = this.style;
	            var needsUpdateRect = !rect;
	            if (needsUpdateRect) {
	                var path = this.path;
	                if (this.__dirtyPath) {
	                    path.beginPath();
	                    this.buildPath(path, this.shape, false);
	                }
	                rect = path.getBoundingRect();
	            }
	            this._rect = rect;
	
	            if (style.hasStroke()) {
	                // Needs update rect with stroke lineWidth when
	                // 1. Element changes scale or lineWidth
	                // 2. Shape is changed
	                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
	                if (this.__dirty || needsUpdateRect) {
	                    rectWithStroke.copy(rect);
	                    // FIXME Must after updateTransform
	                    var w = style.lineWidth;
	                    // PENDING, Min line width is needed when line is horizontal or vertical
	                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
	
	                    // Only add extra hover lineWidth when there are no fill
	                    if (!style.hasFill()) {
	                        w = Math.max(w, this.strokeContainThreshold || 4);
	                    }
	                    // Consider line width
	                    // Line scale can't be 0;
	                    if (lineScale > 1e-10) {
	                        rectWithStroke.width += w / lineScale;
	                        rectWithStroke.height += w / lineScale;
	                        rectWithStroke.x -= w / lineScale / 2;
	                        rectWithStroke.y -= w / lineScale / 2;
	                    }
	                }
	
	                // Return rect with stroke
	                return rectWithStroke;
	            }
	
	            return rect;
	        },
	
	        contain: function (x, y) {
	            var localPos = this.transformCoordToLocal(x, y);
	            var rect = this.getBoundingRect();
	            var style = this.style;
	            x = localPos[0];
	            y = localPos[1];
	
	            if (rect.contain(x, y)) {
	                var pathData = this.path.data;
	                if (style.hasStroke()) {
	                    var lineWidth = style.lineWidth;
	                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
	                    // Line scale can't be 0;
	                    if (lineScale > 1e-10) {
	                        // Only add extra hover lineWidth when there are no fill
	                        if (!style.hasFill()) {
	                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
	                        }
	                        if (pathContain.containStroke(
	                            pathData, lineWidth / lineScale, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                }
	                if (style.hasFill()) {
	                    return pathContain.contain(pathData, x, y);
	                }
	            }
	            return false;
	        },
	
	        /**
	         * @param  {boolean} dirtyPath
	         */
	        dirty: function (dirtyPath) {
	            if (dirtyPath == null) {
	                dirtyPath = true;
	            }
	            // Only mark dirty, not mark clean
	            if (dirtyPath) {
	                this.__dirtyPath = dirtyPath;
	                this._rect = null;
	            }
	
	            this.__dirty = true;
	
	            this.__zr && this.__zr.refresh();
	
	            // Used as a clipping path
	            if (this.__clipTarget) {
	                this.__clipTarget.dirty();
	            }
	        },
	
	        /**
	         * Alias for animate('shape')
	         * @param {boolean} loop
	         */
	        animateShape: function (loop) {
	            return this.animate('shape', loop);
	        },
	
	        // Overwrite attrKV
	        attrKV: function (key, value) {
	            // FIXME
	            if (key === 'shape') {
	                this.setShape(value);
	                this.__dirtyPath = true;
	                this._rect = null;
	            }
	            else {
	                Displayable.prototype.attrKV.call(this, key, value);
	            }
	        },
	
	        /**
	         * @param {Object|string} key
	         * @param {*} value
	         */
	        setShape: function (key, value) {
	            var shape = this.shape;
	            // Path from string may not have shape
	            if (shape) {
	                if (zrUtil.isObject(key)) {
	                    for (var name in key) {
	                        if (key.hasOwnProperty(name)) {
	                            shape[name] = key[name];
	                        }
	                    }
	                }
	                else {
	                    shape[key] = value;
	                }
	                this.dirty(true);
	            }
	            return this;
	        },
	
	        getLineScale: function () {
	            var m = this.transform;
	            // Get the line scale.
	            // Determinant of `m` means how much the area is enlarged by the
	            // transformation. So its square root can be used as a scale factor
	            // for width.
	            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10
	                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))
	                : 1;
	        }
	    };
	
	    /**
	     * 扩展一个 Path element, 比如星形，圆等。
	     * Extend a path element
	     * @param {Object} props
	     * @param {string} props.type Path type
	     * @param {Function} props.init Initialize
	     * @param {Function} props.buildPath Overwrite buildPath method
	     * @param {Object} [props.style] Extended default style config
	     * @param {Object} [props.shape] Extended default shape config
	     */
	    Path.extend = function (defaults) {
	        var Sub = function (opts) {
	            Path.call(this, opts);
	
	            if (defaults.style) {
	                // Extend default style
	                this.style.extendFrom(defaults.style, false);
	            }
	
	            // Extend default shape
	            var defaultShape = defaults.shape;
	            if (defaultShape) {
	                this.shape = this.shape || {};
	                var thisShape = this.shape;
	                for (var name in defaultShape) {
	                    if (
	                        ! thisShape.hasOwnProperty(name)
	                        && defaultShape.hasOwnProperty(name)
	                    ) {
	                        thisShape[name] = defaultShape[name];
	                    }
	                }
	            }
	
	            defaults.init && defaults.init.call(this, opts);
	        };
	
	        zrUtil.inherits(Sub, Path);
	
	        // FIXME 不能 extend position, rotation 等引用对象
	        for (var name in defaults) {
	            // Extending prototype values and methods
	            if (name !== 'style' && name !== 'shape') {
	                Sub.prototype[name] = defaults[name];
	            }
	        }
	
	        return Sub;
	    };
	
	    zrUtil.inherits(Path, Displayable);
	
	    module.exports = Path;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 可绘制的图形基类
	 * Base class of all displayable graphic objects
	 * @module zrender/graphic/Displayable
	 */
	
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var Style = __webpack_require__(8);
	
	    var Element = __webpack_require__(9);
	    var RectText = __webpack_require__(23);
	    // var Stateful = require('./mixin/Stateful');
	
	    /**
	     * @alias module:zrender/graphic/Displayable
	     * @extends module:zrender/Element
	     * @extends module:zrender/graphic/mixin/RectText
	     */
	    function Displayable(opts) {
	
	        opts = opts || {};
	
	        Element.call(this, opts);
	
	        // Extend properties
	        for (var name in opts) {
	            if (
	                opts.hasOwnProperty(name) &&
	                name !== 'style'
	            ) {
	                this[name] = opts[name];
	            }
	        }
	
	        /**
	         * @type {module:zrender/graphic/Style}
	         */
	        this.style = new Style(opts.style);
	
	        this._rect = null;
	        // Shapes for cascade clipping.
	        this.__clipPaths = [];
	
	        // FIXME Stateful must be mixined after style is setted
	        // Stateful.call(this, opts);
	    }
	
	    Displayable.prototype = {
	
	        constructor: Displayable,
	
	        type: 'displayable',
	
	        /**
	         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
	         * Dirty flag. From which painter will determine if this displayable object needs brush
	         * @name module:zrender/graphic/Displayable#__dirty
	         * @type {boolean}
	         */
	        __dirty: true,
	
	        /**
	         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
	         * If ignore drawing of the displayable object. Mouse event will still be triggered
	         * @name module:/zrender/graphic/Displayable#invisible
	         * @type {boolean}
	         * @default false
	         */
	        invisible: false,
	
	        /**
	         * @name module:/zrender/graphic/Displayable#z
	         * @type {number}
	         * @default 0
	         */
	        z: 0,
	
	        /**
	         * @name module:/zrender/graphic/Displayable#z
	         * @type {number}
	         * @default 0
	         */
	        z2: 0,
	
	        /**
	         * z层level，决定绘画在哪层canvas中
	         * @name module:/zrender/graphic/Displayable#zlevel
	         * @type {number}
	         * @default 0
	         */
	        zlevel: 0,
	
	        /**
	         * 是否可拖拽
	         * @name module:/zrender/graphic/Displayable#draggable
	         * @type {boolean}
	         * @default false
	         */
	        draggable: false,
	
	        /**
	         * 是否正在拖拽
	         * @name module:/zrender/graphic/Displayable#draggable
	         * @type {boolean}
	         * @default false
	         */
	        dragging: false,
	
	        /**
	         * 是否相应鼠标事件
	         * @name module:/zrender/graphic/Displayable#silent
	         * @type {boolean}
	         * @default false
	         */
	        silent: false,
	
	        /**
	         * If enable culling
	         * @type {boolean}
	         * @default false
	         */
	        culling: false,
	
	        /**
	         * Mouse cursor when hovered
	         * @name module:/zrender/graphic/Displayable#cursor
	         * @type {string}
	         */
	        cursor: 'pointer',
	
	        /**
	         * If hover area is bounding rect
	         * @name module:/zrender/graphic/Displayable#rectHover
	         * @type {string}
	         */
	        rectHover: false,
	
	        /**
	         * Render the element progressively when the value >= 0,
	         * usefull for large data.
	         * @type {number}
	         */
	        progressive: -1,
	
	        beforeBrush: function (ctx) {},
	
	        afterBrush: function (ctx) {},
	
	        /**
	         * 图形绘制方法
	         * @param {Canvas2DRenderingContext} ctx
	         */
	        // Interface
	        brush: function (ctx, prevEl) {},
	
	        /**
	         * 获取最小包围盒
	         * @return {module:zrender/core/BoundingRect}
	         */
	        // Interface
	        getBoundingRect: function () {},
	
	        /**
	         * 判断坐标 x, y 是否在图形上
	         * If displayable element contain coord x, y
	         * @param  {number} x
	         * @param  {number} y
	         * @return {boolean}
	         */
	        contain: function (x, y) {
	            return this.rectContain(x, y);
	        },
	
	        /**
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {
	            cb.call(context, this);
	        },
	
	        /**
	         * 判断坐标 x, y 是否在图形的包围盒上
	         * If bounding rect of element contain coord x, y
	         * @param  {number} x
	         * @param  {number} y
	         * @return {boolean}
	         */
	        rectContain: function (x, y) {
	            var coord = this.transformCoordToLocal(x, y);
	            var rect = this.getBoundingRect();
	            return rect.contain(coord[0], coord[1]);
	        },
	
	        /**
	         * 标记图形元素为脏，并且在下一帧重绘
	         * Mark displayable element dirty and refresh next frame
	         */
	        dirty: function () {
	            this.__dirty = true;
	
	            this._rect = null;
	
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * 图形是否会触发事件
	         * If displayable object binded any event
	         * @return {boolean}
	         */
	        // TODO, 通过 bind 绑定的事件
	        // isSilent: function () {
	        //     return !(
	        //         this.hoverable || this.draggable
	        //         || this.onmousemove || this.onmouseover || this.onmouseout
	        //         || this.onmousedown || this.onmouseup || this.onclick
	        //         || this.ondragenter || this.ondragover || this.ondragleave
	        //         || this.ondrop
	        //     );
	        // },
	        /**
	         * Alias for animate('style')
	         * @param {boolean} loop
	         */
	        animateStyle: function (loop) {
	            return this.animate('style', loop);
	        },
	
	        attrKV: function (key, value) {
	            if (key !== 'style') {
	                Element.prototype.attrKV.call(this, key, value);
	            }
	            else {
	                this.style.set(value);
	            }
	        },
	
	        /**
	         * @param {Object|string} key
	         * @param {*} value
	         */
	        setStyle: function (key, value) {
	            this.style.set(key, value);
	            this.dirty(false);
	            return this;
	        },
	
	        /**
	         * Use given style object
	         * @param  {Object} obj
	         */
	        useStyle: function (obj) {
	            this.style = new Style(obj);
	            this.dirty(false);
	            return this;
	        }
	    };
	
	    zrUtil.inherits(Displayable, Element);
	
	    zrUtil.mixin(Displayable, RectText);
	    // zrUtil.mixin(Displayable, Stateful);
	
	    module.exports = Displayable;


/***/ },
/* 8 */
/***/ function(module, exports) {

	/**
	 * @module zrender/graphic/Style
	 */
	
	
	    var STYLE_COMMON_PROPS = [
	        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],
	        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]
	    ];
	
	    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
	    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);
	
	    var Style = function (opts) {
	        this.extendFrom(opts);
	    };
	
	    function createLinearGradient(ctx, obj, rect) {
	        // var size =
	        var x = obj.x;
	        var x2 = obj.x2;
	        var y = obj.y;
	        var y2 = obj.y2;
	
	        if (!obj.global) {
	            x = x * rect.width + rect.x;
	            x2 = x2 * rect.width + rect.x;
	            y = y * rect.height + rect.y;
	            y2 = y2 * rect.height + rect.y;
	        }
	
	        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
	
	        return canvasGradient;
	    }
	
	    function createRadialGradient(ctx, obj, rect) {
	        var width = rect.width;
	        var height = rect.height;
	        var min = Math.min(width, height);
	
	        var x = obj.x;
	        var y = obj.y;
	        var r = obj.r;
	        if (!obj.global) {
	            x = x * width + rect.x;
	            y = y * height + rect.y;
	            r = r * min;
	        }
	
	        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
	
	        return canvasGradient;
	    }
	
	
	    Style.prototype = {
	
	        constructor: Style,
	
	        /**
	         * @type {string}
	         */
	        fill: '#000000',
	
	        /**
	         * @type {string}
	         */
	        stroke: null,
	
	        /**
	         * @type {number}
	         */
	        opacity: 1,
	
	        /**
	         * @type {Array.<number>}
	         */
	        lineDash: null,
	
	        /**
	         * @type {number}
	         */
	        lineDashOffset: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowBlur: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowOffsetX: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowOffsetY: 0,
	
	        /**
	         * @type {number}
	         */
	        lineWidth: 1,
	
	        /**
	         * If stroke ignore scale
	         * @type {Boolean}
	         */
	        strokeNoScale: false,
	
	        // Bounding rect text configuration
	        // Not affected by element transform
	        /**
	         * @type {string}
	         */
	        text: null,
	
	        /**
	         * @type {string}
	         */
	        textFill: '#000',
	
	        /**
	         * @type {string}
	         */
	        textStroke: null,
	
	        /**
	         * 'inside', 'left', 'right', 'top', 'bottom'
	         * [x, y]
	         * @type {string|Array.<number>}
	         * @default 'inside'
	         */
	        textPosition: 'inside',
	
	        /**
	         * [x, y]
	         * @type {Array.<number>}
	         */
	        textOffset: null,
	
	        /**
	         * @type {string}
	         */
	        textBaseline: null,
	
	        /**
	         * @type {string}
	         */
	        textAlign: null,
	
	        /**
	         * @type {string}
	         */
	        textVerticalAlign: null,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textDistance: 5,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textShadowBlur: 0,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textShadowOffsetX: 0,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textShadowOffsetY: 0,
	
	        /**
	         * If transform text
	         * Only useful in Path and Image element
	         * @type {boolean}
	         */
	        textTransform: false,
	
	        /**
	         * Text rotate around position of Path or Image
	         * Only useful in Path and Image element and textTransform is false.
	         */
	        textRotation: 0,
	
	        /**
	         * @type {string}
	         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
	         */
	        blend: null,
	
	        /**
	         * @param {CanvasRenderingContext2D} ctx
	         */
	        bind: function (ctx, el, prevEl) {
	            var style = this;
	            var prevStyle = prevEl && prevEl.style;
	            var firstDraw = !prevStyle;
	
	            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	                var prop = STYLE_COMMON_PROPS[i];
	                var styleName = prop[0];
	
	                if (firstDraw || style[styleName] !== prevStyle[styleName]) {
	                    // FIXME Invalid property value will cause style leak from previous element.
	                    ctx[styleName] = style[styleName] || prop[1];
	                }
	            }
	
	            if ((firstDraw || style.fill !== prevStyle.fill)) {
	                ctx.fillStyle = style.fill;
	            }
	            if ((firstDraw || style.stroke !== prevStyle.stroke)) {
	                ctx.strokeStyle = style.stroke;
	            }
	            if ((firstDraw || style.opacity !== prevStyle.opacity)) {
	                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
	            }
	
	            if ((firstDraw || style.blend !== prevStyle.blend)) {
	                ctx.globalCompositeOperation = style.blend || 'source-over';
	            }
	            if (this.hasStroke()) {
	                var lineWidth = style.lineWidth;
	                ctx.lineWidth = lineWidth / (
	                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1
	                );
	            }
	        },
	
	        hasFill: function () {
	            var fill = this.fill;
	            return fill != null && fill !== 'none';
	        },
	
	        hasStroke: function () {
	            var stroke = this.stroke;
	            return stroke != null && stroke !== 'none' && this.lineWidth > 0;
	        },
	
	        /**
	         * Extend from other style
	         * @param {zrender/graphic/Style} otherStyle
	         * @param {boolean} overwrite
	         */
	        extendFrom: function (otherStyle, overwrite) {
	            if (otherStyle) {
	                var target = this;
	                for (var name in otherStyle) {
	                    if (otherStyle.hasOwnProperty(name)
	                        && (overwrite || ! target.hasOwnProperty(name))
	                    ) {
	                        target[name] = otherStyle[name];
	                    }
	                }
	            }
	        },
	
	        /**
	         * Batch setting style with a given object
	         * @param {Object|string} obj
	         * @param {*} [obj]
	         */
	        set: function (obj, value) {
	            if (typeof obj === 'string') {
	                this[obj] = value;
	            }
	            else {
	                this.extendFrom(obj, true);
	            }
	        },
	
	        /**
	         * Clone
	         * @return {zrender/graphic/Style} [description]
	         */
	        clone: function () {
	            var newStyle = new this.constructor();
	            newStyle.extendFrom(this, true);
	            return newStyle;
	        },
	
	        getGradient: function (ctx, obj, rect) {
	            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
	            var canvasGradient = method(ctx, obj, rect);
	            var colorStops = obj.colorStops;
	            for (var i = 0; i < colorStops.length; i++) {
	                canvasGradient.addColorStop(
	                    colorStops[i].offset, colorStops[i].color
	                );
	            }
	            return canvasGradient;
	        }
	    };
	
	    var styleProto = Style.prototype;
	    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	        var prop = STYLE_COMMON_PROPS[i];
	        if (!(prop[0] in styleProto)) {
	            styleProto[prop[0]] = prop[1];
	        }
	    }
	
	    // Provide for others
	    Style.getGradient = styleProto.getGradient;
	
	    module.exports = Style;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module zrender/Element
	 */
	
	
	    var guid = __webpack_require__(10);
	    var Eventful = __webpack_require__(11);
	    var Transformable = __webpack_require__(12);
	    var Animatable = __webpack_require__(15);
	    var zrUtil = __webpack_require__(4);
	
	    /**
	     * @alias module:zrender/Element
	     * @constructor
	     * @extends {module:zrender/mixin/Animatable}
	     * @extends {module:zrender/mixin/Transformable}
	     * @extends {module:zrender/mixin/Eventful}
	     */
	    var Element = function (opts) {
	
	        Transformable.call(this, opts);
	        Eventful.call(this, opts);
	        Animatable.call(this, opts);
	
	        /**
	         * 画布元素ID
	         * @type {string}
	         */
	        this.id = opts.id || guid();
	    };
	
	    Element.prototype = {
	
	        /**
	         * 元素类型
	         * Element type
	         * @type {string}
	         */
	        type: 'element',
	
	        /**
	         * 元素名字
	         * Element name
	         * @type {string}
	         */
	        name: '',
	
	        /**
	         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
	         * ZRender instance will be assigned when element is associated with zrender
	         * @name module:/zrender/Element#__zr
	         * @type {module:zrender/ZRender}
	         */
	        __zr: null,
	
	        /**
	         * 图形是否忽略，为true时忽略图形的绘制以及事件触发
	         * If ignore drawing and events of the element object
	         * @name module:/zrender/Element#ignore
	         * @type {boolean}
	         * @default false
	         */
	        ignore: false,
	
	        /**
	         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
	         * 该路径会继承被裁减对象的变换
	         * @type {module:zrender/graphic/Path}
	         * @see http://www.w3.org/TR/2dcontext/#clipping-region
	         * @readOnly
	         */
	        clipPath: null,
	
	        /**
	         * Drift element
	         * @param  {number} dx dx on the global space
	         * @param  {number} dy dy on the global space
	         */
	        drift: function (dx, dy) {
	            switch (this.draggable) {
	                case 'horizontal':
	                    dy = 0;
	                    break;
	                case 'vertical':
	                    dx = 0;
	                    break;
	            }
	
	            var m = this.transform;
	            if (!m) {
	                m = this.transform = [1, 0, 0, 1, 0, 0];
	            }
	            m[4] += dx;
	            m[5] += dy;
	
	            this.decomposeTransform();
	            this.dirty(false);
	        },
	
	        /**
	         * Hook before update
	         */
	        beforeUpdate: function () {},
	        /**
	         * Hook after update
	         */
	        afterUpdate: function () {},
	        /**
	         * Update each frame
	         */
	        update: function () {
	            this.updateTransform();
	        },
	
	        /**
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {},
	
	        /**
	         * @protected
	         */
	        attrKV: function (key, value) {
	            if (key === 'position' || key === 'scale' || key === 'origin') {
	                // Copy the array
	                if (value) {
	                    var target = this[key];
	                    if (!target) {
	                        target = this[key] = [];
	                    }
	                    target[0] = value[0];
	                    target[1] = value[1];
	                }
	            }
	            else {
	                this[key] = value;
	            }
	        },
	
	        /**
	         * Hide the element
	         */
	        hide: function () {
	            this.ignore = true;
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * Show the element
	         */
	        show: function () {
	            this.ignore = false;
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * @param {string|Object} key
	         * @param {*} value
	         */
	        attr: function (key, value) {
	            if (typeof key === 'string') {
	                this.attrKV(key, value);
	            }
	            else if (zrUtil.isObject(key)) {
	                for (var name in key) {
	                    if (key.hasOwnProperty(name)) {
	                        this.attrKV(name, key[name]);
	                    }
	                }
	            }
	
	            this.dirty(false);
	
	            return this;
	        },
	
	        /**
	         * @param {module:zrender/graphic/Path} clipPath
	         */
	        setClipPath: function (clipPath) {
	            var zr = this.__zr;
	            if (zr) {
	                clipPath.addSelfToZr(zr);
	            }
	
	            // Remove previous clip path
	            if (this.clipPath && this.clipPath !== clipPath) {
	                this.removeClipPath();
	            }
	
	            this.clipPath = clipPath;
	            clipPath.__zr = zr;
	            clipPath.__clipTarget = this;
	
	            this.dirty(false);
	        },
	
	        /**
	         */
	        removeClipPath: function () {
	            var clipPath = this.clipPath;
	            if (clipPath) {
	                if (clipPath.__zr) {
	                    clipPath.removeSelfFromZr(clipPath.__zr);
	                }
	
	                clipPath.__zr = null;
	                clipPath.__clipTarget = null;
	                this.clipPath = null;
	
	                this.dirty(false);
	            }
	        },
	
	        /**
	         * Add self from zrender instance.
	         * Not recursively because it will be invoked when element added to storage.
	         * @param {module:zrender/ZRender} zr
	         */
	        addSelfToZr: function (zr) {
	            this.__zr = zr;
	            // 添加动画
	            var animators = this.animators;
	            if (animators) {
	                for (var i = 0; i < animators.length; i++) {
	                    zr.animation.addAnimator(animators[i]);
	                }
	            }
	
	            if (this.clipPath) {
	                this.clipPath.addSelfToZr(zr);
	            }
	        },
	
	        /**
	         * Remove self from zrender instance.
	         * Not recursively because it will be invoked when element added to storage.
	         * @param {module:zrender/ZRender} zr
	         */
	        removeSelfFromZr: function (zr) {
	            this.__zr = null;
	            // 移除动画
	            var animators = this.animators;
	            if (animators) {
	                for (var i = 0; i < animators.length; i++) {
	                    zr.animation.removeAnimator(animators[i]);
	                }
	            }
	
	            if (this.clipPath) {
	                this.clipPath.removeSelfFromZr(zr);
	            }
	        }
	    };
	
	    zrUtil.mixin(Element, Animatable);
	    zrUtil.mixin(Element, Transformable);
	    zrUtil.mixin(Element, Eventful);
	
	    module.exports = Element;


/***/ },
/* 10 */
/***/ function(module, exports) {

	/**
	 * zrender: 生成唯一id
	 *
	 * @author errorrik (errorrik@gmail.com)
	 */
	
	
	    var idStart = 0x0907;
	
	    module.exports = function () {
	        return idStart++;
	    };
	


/***/ },
/* 11 */
/***/ function(module, exports) {

	/**
	 * 事件扩展
	 * @module zrender/mixin/Eventful
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	
	
	    var arrySlice = Array.prototype.slice;
	
	    /**
	     * 事件分发器
	     * @alias module:zrender/mixin/Eventful
	     * @constructor
	     */
	    var Eventful = function () {
	        this._$handlers = {};
	    };
	
	    Eventful.prototype = {
	
	        constructor: Eventful,
	
	        /**
	         * 单次触发绑定，trigger后销毁
	         *
	         * @param {string} event 事件名
	         * @param {Function} handler 响应函数
	         * @param {Object} context
	         */
	        one: function (event, handler, context) {
	            var _h = this._$handlers;
	
	            if (!handler || !event) {
	                return this;
	            }
	
	            if (!_h[event]) {
	                _h[event] = [];
	            }
	
	            for (var i = 0; i < _h[event].length; i++) {
	                if (_h[event][i].h === handler) {
	                    return this;
	                }
	            }
	
	            _h[event].push({
	                h: handler,
	                one: true,
	                ctx: context || this
	            });
	
	            return this;
	        },
	
	        /**
	         * 绑定事件
	         * @param {string} event 事件名
	         * @param {Function} handler 事件处理函数
	         * @param {Object} [context]
	         */
	        on: function (event, handler, context) {
	            var _h = this._$handlers;
	
	            if (!handler || !event) {
	                return this;
	            }
	
	            if (!_h[event]) {
	                _h[event] = [];
	            }
	
	            for (var i = 0; i < _h[event].length; i++) {
	                if (_h[event][i].h === handler) {
	                    return this;
	                }
	            }
	
	            _h[event].push({
	                h: handler,
	                one: false,
	                ctx: context || this
	            });
	
	            return this;
	        },
	
	        /**
	         * 是否绑定了事件
	         * @param  {string}  event
	         * @return {boolean}
	         */
	        isSilent: function (event) {
	            var _h = this._$handlers;
	            return _h[event] && _h[event].length;
	        },
	
	        /**
	         * 解绑事件
	         * @param {string} event 事件名
	         * @param {Function} [handler] 事件处理函数
	         */
	        off: function (event, handler) {
	            var _h = this._$handlers;
	
	            if (!event) {
	                this._$handlers = {};
	                return this;
	            }
	
	            if (handler) {
	                if (_h[event]) {
	                    var newList = [];
	                    for (var i = 0, l = _h[event].length; i < l; i++) {
	                        if (_h[event][i]['h'] != handler) {
	                            newList.push(_h[event][i]);
	                        }
	                    }
	                    _h[event] = newList;
	                }
	
	                if (_h[event] && _h[event].length === 0) {
	                    delete _h[event];
	                }
	            }
	            else {
	                delete _h[event];
	            }
	
	            return this;
	        },
	
	        /**
	         * 事件分发
	         *
	         * @param {string} type 事件类型
	         */
	        trigger: function (type) {
	            if (this._$handlers[type]) {
	                var args = arguments;
	                var argLen = args.length;
	
	                if (argLen > 3) {
	                    args = arrySlice.call(args, 1);
	                }
	
	                var _h = this._$handlers[type];
	                var len = _h.length;
	                for (var i = 0; i < len;) {
	                    // Optimize advise from backbone
	                    switch (argLen) {
	                        case 1:
	                            _h[i]['h'].call(_h[i]['ctx']);
	                            break;
	                        case 2:
	                            _h[i]['h'].call(_h[i]['ctx'], args[1]);
	                            break;
	                        case 3:
	                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
	                            break;
	                        default:
	                            // have more than 2 given arguments
	                            _h[i]['h'].apply(_h[i]['ctx'], args);
	                            break;
	                    }
	
	                    if (_h[i]['one']) {
	                        _h.splice(i, 1);
	                        len--;
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	
	            return this;
	        },
	
	        /**
	         * 带有context的事件分发, 最后一个参数是事件回调的context
	         * @param {string} type 事件类型
	         */
	        triggerWithContext: function (type) {
	            if (this._$handlers[type]) {
	                var args = arguments;
	                var argLen = args.length;
	
	                if (argLen > 4) {
	                    args = arrySlice.call(args, 1, args.length - 1);
	                }
	                var ctx = args[args.length - 1];
	
	                var _h = this._$handlers[type];
	                var len = _h.length;
	                for (var i = 0; i < len;) {
	                    // Optimize advise from backbone
	                    switch (argLen) {
	                        case 1:
	                            _h[i]['h'].call(ctx);
	                            break;
	                        case 2:
	                            _h[i]['h'].call(ctx, args[1]);
	                            break;
	                        case 3:
	                            _h[i]['h'].call(ctx, args[1], args[2]);
	                            break;
	                        default:
	                            // have more than 2 given arguments
	                            _h[i]['h'].apply(ctx, args);
	                            break;
	                    }
	
	                    if (_h[i]['one']) {
	                        _h.splice(i, 1);
	                        len--;
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	
	            return this;
	        }
	    };
	
	    // 对象可以通过 onxxxx 绑定事件
	    /**
	     * @event module:zrender/mixin/Eventful#onclick
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseover
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseout
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousemove
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousewheel
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousedown
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseup
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondrag
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragstart
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragend
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragenter
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragleave
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragover
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondrop
	     * @type {Function}
	     * @default null
	     */
	
	    module.exports = Eventful;
	


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 提供变换扩展
	 * @module zrender/mixin/Transformable
	 * @author pissang (https://www.github.com/pissang)
	 */
	
	
	    var matrix = __webpack_require__(13);
	    var vector = __webpack_require__(14);
	    var mIdentity = matrix.identity;
	
	    var EPSILON = 5e-5;
	
	    function isNotAroundZero(val) {
	        return val > EPSILON || val < -EPSILON;
	    }
	
	    /**
	     * @alias module:zrender/mixin/Transformable
	     * @constructor
	     */
	    var Transformable = function (opts) {
	        opts = opts || {};
	        // If there are no given position, rotation, scale
	        if (!opts.position) {
	            /**
	             * 平移
	             * @type {Array.<number>}
	             * @default [0, 0]
	             */
	            this.position = [0, 0];
	        }
	        if (opts.rotation == null) {
	            /**
	             * 旋转
	             * @type {Array.<number>}
	             * @default 0
	             */
	            this.rotation = 0;
	        }
	        if (!opts.scale) {
	            /**
	             * 缩放
	             * @type {Array.<number>}
	             * @default [1, 1]
	             */
	            this.scale = [1, 1];
	        }
	        /**
	         * 旋转和缩放的原点
	         * @type {Array.<number>}
	         * @default null
	         */
	        this.origin = this.origin || null;
	    };
	
	    var transformableProto = Transformable.prototype;
	    transformableProto.transform = null;
	
	    /**
	     * 判断是否需要有坐标变换
	     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
	     */
	    transformableProto.needLocalTransform = function () {
	        return isNotAroundZero(this.rotation)
	            || isNotAroundZero(this.position[0])
	            || isNotAroundZero(this.position[1])
	            || isNotAroundZero(this.scale[0] - 1)
	            || isNotAroundZero(this.scale[1] - 1);
	    };
	
	    transformableProto.updateTransform = function () {
	        var parent = this.parent;
	        var parentHasTransform = parent && parent.transform;
	        var needLocalTransform = this.needLocalTransform();
	
	        var m = this.transform;
	        if (!(needLocalTransform || parentHasTransform)) {
	            m && mIdentity(m);
	            return;
	        }
	
	        m = m || matrix.create();
	
	        if (needLocalTransform) {
	            this.getLocalTransform(m);
	        }
	        else {
	            mIdentity(m);
	        }
	
	        // 应用父节点变换
	        if (parentHasTransform) {
	            if (needLocalTransform) {
	                matrix.mul(m, parent.transform, m);
	            }
	            else {
	                matrix.copy(m, parent.transform);
	            }
	        }
	        // 保存这个变换矩阵
	        this.transform = m;
	
	        this.invTransform = this.invTransform || matrix.create();
	        matrix.invert(this.invTransform, m);
	    };
	
	    transformableProto.getLocalTransform = function (m) {
	        m = m || [];
	        mIdentity(m);
	
	        var origin = this.origin;
	
	        var scale = this.scale;
	        var rotation = this.rotation;
	        var position = this.position;
	        if (origin) {
	            // Translate to origin
	            m[4] -= origin[0];
	            m[5] -= origin[1];
	        }
	        matrix.scale(m, m, scale);
	        if (rotation) {
	            matrix.rotate(m, m, rotation);
	        }
	        if (origin) {
	            // Translate back from origin
	            m[4] += origin[0];
	            m[5] += origin[1];
	        }
	
	        m[4] += position[0];
	        m[5] += position[1];
	
	        return m;
	    };
	    /**
	     * 将自己的transform应用到context上
	     * @param {Context2D} ctx
	     */
	    transformableProto.setTransform = function (ctx) {
	        var m = this.transform;
	        var dpr = ctx.dpr || 1;
	        if (m) {
	            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
	        }
	        else {
	            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	        }
	    };
	
	    transformableProto.restoreTransform = function (ctx) {
	        var m = this.transform;
	        var dpr = ctx.dpr || 1;
	        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	    }
	
	    var tmpTransform = [];
	
	    /**
	     * 分解`transform`矩阵到`position`, `rotation`, `scale`
	     */
	    transformableProto.decomposeTransform = function () {
	        if (!this.transform) {
	            return;
	        }
	        var parent = this.parent;
	        var m = this.transform;
	        if (parent && parent.transform) {
	            // Get local transform and decompose them to position, scale, rotation
	            matrix.mul(tmpTransform, parent.invTransform, m);
	            m = tmpTransform;
	        }
	        var sx = m[0] * m[0] + m[1] * m[1];
	        var sy = m[2] * m[2] + m[3] * m[3];
	        var position = this.position;
	        var scale = this.scale;
	        if (isNotAroundZero(sx - 1)) {
	            sx = Math.sqrt(sx);
	        }
	        if (isNotAroundZero(sy - 1)) {
	            sy = Math.sqrt(sy);
	        }
	        if (m[0] < 0) {
	            sx = -sx;
	        }
	        if (m[3] < 0) {
	            sy = -sy;
	        }
	        position[0] = m[4];
	        position[1] = m[5];
	        scale[0] = sx;
	        scale[1] = sy;
	        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
	    };
	
	    /**
	     * Get global scale
	     * @return {Array.<number>}
	     */
	    transformableProto.getGlobalScale = function () {
	        var m = this.transform;
	        if (!m) {
	            return [1, 1];
	        }
	        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
	        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
	        if (m[0] < 0) {
	            sx = -sx;
	        }
	        if (m[3] < 0) {
	            sy = -sy;
	        }
	        return [sx, sy];
	    };
	    /**
	     * 变换坐标位置到 shape 的局部坐标空间
	     * @method
	     * @param {number} x
	     * @param {number} y
	     * @return {Array.<number>}
	     */
	    transformableProto.transformCoordToLocal = function (x, y) {
	        var v2 = [x, y];
	        var invTransform = this.invTransform;
	        if (invTransform) {
	            vector.applyTransform(v2, v2, invTransform);
	        }
	        return v2;
	    };
	
	    /**
	     * 变换局部坐标位置到全局坐标空间
	     * @method
	     * @param {number} x
	     * @param {number} y
	     * @return {Array.<number>}
	     */
	    transformableProto.transformCoordToGlobal = function (x, y) {
	        var v2 = [x, y];
	        var transform = this.transform;
	        if (transform) {
	            vector.applyTransform(v2, v2, transform);
	        }
	        return v2;
	    };
	
	    module.exports = Transformable;
	


/***/ },
/* 13 */
/***/ function(module, exports) {

	
	    var ArrayCtor = typeof Float32Array === 'undefined'
	        ? Array
	        : Float32Array;
	    /**
	     * 3x2矩阵操作类
	     * @exports zrender/tool/matrix
	     */
	    var matrix = {
	        /**
	         * 创建一个单位矩阵
	         * @return {Float32Array|Array.<number>}
	         */
	        create : function() {
	            var out = new ArrayCtor(6);
	            matrix.identity(out);
	
	            return out;
	        },
	        /**
	         * 设置矩阵为单位矩阵
	         * @param {Float32Array|Array.<number>} out
	         */
	        identity : function(out) {
	            out[0] = 1;
	            out[1] = 0;
	            out[2] = 0;
	            out[3] = 1;
	            out[4] = 0;
	            out[5] = 0;
	            return out;
	        },
	        /**
	         * 复制矩阵
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} m
	         */
	        copy: function(out, m) {
	            out[0] = m[0];
	            out[1] = m[1];
	            out[2] = m[2];
	            out[3] = m[3];
	            out[4] = m[4];
	            out[5] = m[5];
	            return out;
	        },
	        /**
	         * 矩阵相乘
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} m1
	         * @param {Float32Array|Array.<number>} m2
	         */
	        mul : function (out, m1, m2) {
	            // Consider matrix.mul(m, m2, m);
	            // where out is the same as m2.
	            // So use temp variable to escape error.
	            var out0 = m1[0] * m2[0] + m1[2] * m2[1];
	            var out1 = m1[1] * m2[0] + m1[3] * m2[1];
	            var out2 = m1[0] * m2[2] + m1[2] * m2[3];
	            var out3 = m1[1] * m2[2] + m1[3] * m2[3];
	            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
	            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
	            out[0] = out0;
	            out[1] = out1;
	            out[2] = out2;
	            out[3] = out3;
	            out[4] = out4;
	            out[5] = out5;
	            return out;
	        },
	        /**
	         * 平移变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {Float32Array|Array.<number>} v
	         */
	        translate : function(out, a, v) {
	            out[0] = a[0];
	            out[1] = a[1];
	            out[2] = a[2];
	            out[3] = a[3];
	            out[4] = a[4] + v[0];
	            out[5] = a[5] + v[1];
	            return out;
	        },
	        /**
	         * 旋转变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {number} rad
	         */
	        rotate : function(out, a, rad) {
	            var aa = a[0];
	            var ac = a[2];
	            var atx = a[4];
	            var ab = a[1];
	            var ad = a[3];
	            var aty = a[5];
	            var st = Math.sin(rad);
	            var ct = Math.cos(rad);
	
	            out[0] = aa * ct + ab * st;
	            out[1] = -aa * st + ab * ct;
	            out[2] = ac * ct + ad * st;
	            out[3] = -ac * st + ct * ad;
	            out[4] = ct * atx + st * aty;
	            out[5] = ct * aty - st * atx;
	            return out;
	        },
	        /**
	         * 缩放变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {Float32Array|Array.<number>} v
	         */
	        scale : function(out, a, v) {
	            var vx = v[0];
	            var vy = v[1];
	            out[0] = a[0] * vx;
	            out[1] = a[1] * vy;
	            out[2] = a[2] * vx;
	            out[3] = a[3] * vy;
	            out[4] = a[4] * vx;
	            out[5] = a[5] * vy;
	            return out;
	        },
	        /**
	         * 求逆矩阵
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         */
	        invert : function(out, a) {
	
	            var aa = a[0];
	            var ac = a[2];
	            var atx = a[4];
	            var ab = a[1];
	            var ad = a[3];
	            var aty = a[5];
	
	            var det = aa * ad - ab * ac;
	            if (!det) {
	                return null;
	            }
	            det = 1.0 / det;
	
	            out[0] = ad * det;
	            out[1] = -ab * det;
	            out[2] = -ac * det;
	            out[3] = aa * det;
	            out[4] = (ac * aty - ad * atx) * det;
	            out[5] = (ab * atx - aa * aty) * det;
	            return out;
	        }
	    };
	
	    module.exports = matrix;
	


/***/ },
/* 14 */
/***/ function(module, exports) {

	
	    var ArrayCtor = typeof Float32Array === 'undefined'
	        ? Array
	        : Float32Array;
	
	    /**
	     * @typedef {Float32Array|Array.<number>} Vector2
	     */
	    /**
	     * 二维向量类
	     * @exports zrender/tool/vector
	     */
	    var vector = {
	        /**
	         * 创建一个向量
	         * @param {number} [x=0]
	         * @param {number} [y=0]
	         * @return {Vector2}
	         */
	        create: function (x, y) {
	            var out = new ArrayCtor(2);
	            if (x == null) {
	                x = 0;
	            }
	            if (y == null) {
	                y = 0;
	            }
	            out[0] = x;
	            out[1] = y;
	            return out;
	        },
	
	        /**
	         * 复制向量数据
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @return {Vector2}
	         */
	        copy: function (out, v) {
	            out[0] = v[0];
	            out[1] = v[1];
	            return out;
	        },
	
	        /**
	         * 克隆一个向量
	         * @param {Vector2} v
	         * @return {Vector2}
	         */
	        clone: function (v) {
	            var out = new ArrayCtor(2);
	            out[0] = v[0];
	            out[1] = v[1];
	            return out;
	        },
	
	        /**
	         * 设置向量的两个项
	         * @param {Vector2} out
	         * @param {number} a
	         * @param {number} b
	         * @return {Vector2} 结果
	         */
	        set: function (out, a, b) {
	            out[0] = a;
	            out[1] = b;
	            return out;
	        },
	
	        /**
	         * 向量相加
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        add: function (out, v1, v2) {
	            out[0] = v1[0] + v2[0];
	            out[1] = v1[1] + v2[1];
	            return out;
	        },
	
	        /**
	         * 向量缩放后相加
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @param {number} a
	         */
	        scaleAndAdd: function (out, v1, v2, a) {
	            out[0] = v1[0] + v2[0] * a;
	            out[1] = v1[1] + v2[1] * a;
	            return out;
	        },
	
	        /**
	         * 向量相减
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        sub: function (out, v1, v2) {
	            out[0] = v1[0] - v2[0];
	            out[1] = v1[1] - v2[1];
	            return out;
	        },
	
	        /**
	         * 向量长度
	         * @param {Vector2} v
	         * @return {number}
	         */
	        len: function (v) {
	            return Math.sqrt(this.lenSquare(v));
	        },
	
	        /**
	         * 向量长度平方
	         * @param {Vector2} v
	         * @return {number}
	         */
	        lenSquare: function (v) {
	            return v[0] * v[0] + v[1] * v[1];
	        },
	
	        /**
	         * 向量乘法
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        mul: function (out, v1, v2) {
	            out[0] = v1[0] * v2[0];
	            out[1] = v1[1] * v2[1];
	            return out;
	        },
	
	        /**
	         * 向量除法
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        div: function (out, v1, v2) {
	            out[0] = v1[0] / v2[0];
	            out[1] = v1[1] / v2[1];
	            return out;
	        },
	
	        /**
	         * 向量点乘
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        dot: function (v1, v2) {
	            return v1[0] * v2[0] + v1[1] * v2[1];
	        },
	
	        /**
	         * 向量缩放
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @param {number} s
	         */
	        scale: function (out, v, s) {
	            out[0] = v[0] * s;
	            out[1] = v[1] * s;
	            return out;
	        },
	
	        /**
	         * 向量归一化
	         * @param {Vector2} out
	         * @param {Vector2} v
	         */
	        normalize: function (out, v) {
	            var d = vector.len(v);
	            if (d === 0) {
	                out[0] = 0;
	                out[1] = 0;
	            }
	            else {
	                out[0] = v[0] / d;
	                out[1] = v[1] / d;
	            }
	            return out;
	        },
	
	        /**
	         * 计算向量间距离
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        distance: function (v1, v2) {
	            return Math.sqrt(
	                (v1[0] - v2[0]) * (v1[0] - v2[0])
	                + (v1[1] - v2[1]) * (v1[1] - v2[1])
	            );
	        },
	
	        /**
	         * 向量距离平方
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        distanceSquare: function (v1, v2) {
	            return (v1[0] - v2[0]) * (v1[0] - v2[0])
	                + (v1[1] - v2[1]) * (v1[1] - v2[1]);
	        },
	
	        /**
	         * 求负向量
	         * @param {Vector2} out
	         * @param {Vector2} v
	         */
	        negate: function (out, v) {
	            out[0] = -v[0];
	            out[1] = -v[1];
	            return out;
	        },
	
	        /**
	         * 插值两个点
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @param {number} t
	         */
	        lerp: function (out, v1, v2, t) {
	            out[0] = v1[0] + t * (v2[0] - v1[0]);
	            out[1] = v1[1] + t * (v2[1] - v1[1]);
	            return out;
	        },
	
	        /**
	         * 矩阵左乘向量
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @param {Vector2} m
	         */
	        applyTransform: function (out, v, m) {
	            var x = v[0];
	            var y = v[1];
	            out[0] = m[0] * x + m[2] * y + m[4];
	            out[1] = m[1] * x + m[3] * y + m[5];
	            return out;
	        },
	        /**
	         * 求两个向量最小值
	         * @param  {Vector2} out
	         * @param  {Vector2} v1
	         * @param  {Vector2} v2
	         */
	        min: function (out, v1, v2) {
	            out[0] = Math.min(v1[0], v2[0]);
	            out[1] = Math.min(v1[1], v2[1]);
	            return out;
	        },
	        /**
	         * 求两个向量最大值
	         * @param  {Vector2} out
	         * @param  {Vector2} v1
	         * @param  {Vector2} v2
	         */
	        max: function (out, v1, v2) {
	            out[0] = Math.max(v1[0], v2[0]);
	            out[1] = Math.max(v1[1], v2[1]);
	            return out;
	        }
	    };
	
	    vector.length = vector.len;
	    vector.lengthSquare = vector.lenSquare;
	    vector.dist = vector.distance;
	    vector.distSquare = vector.distanceSquare;
	
	    module.exports = vector;
	


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module zrender/mixin/Animatable
	 */
	
	
	    var Animator = __webpack_require__(16);
	    var util = __webpack_require__(4);
	    var isString = util.isString;
	    var isFunction = util.isFunction;
	    var isObject = util.isObject;
	    var log = __webpack_require__(21);
	
	    /**
	     * @alias modue:zrender/mixin/Animatable
	     * @constructor
	     */
	    var Animatable = function () {
	
	        /**
	         * @type {Array.<module:zrender/animation/Animator>}
	         * @readOnly
	         */
	        this.animators = [];
	    };
	
	    Animatable.prototype = {
	
	        constructor: Animatable,
	
	        /**
	         * 动画
	         *
	         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性
	         * @param {boolean} [loop] 动画是否循环
	         * @return {module:zrender/animation/Animator}
	         * @example:
	         *     el.animate('style', false)
	         *         .when(1000, {x: 10} )
	         *         .done(function(){ // Animation done })
	         *         .start()
	         */
	        animate: function (path, loop) {
	            var target;
	            var animatingShape = false;
	            var el = this;
	            var zr = this.__zr;
	            if (path) {
	                var pathSplitted = path.split('.');
	                var prop = el;
	                // If animating shape
	                animatingShape = pathSplitted[0] === 'shape';
	                for (var i = 0, l = pathSplitted.length; i < l; i++) {
	                    if (!prop) {
	                        continue;
	                    }
	                    prop = prop[pathSplitted[i]];
	                }
	                if (prop) {
	                    target = prop;
	                }
	            }
	            else {
	                target = el;
	            }
	
	            if (!target) {
	                log(
	                    'Property "'
	                    + path
	                    + '" is not existed in element '
	                    + el.id
	                );
	                return;
	            }
	
	            var animators = el.animators;
	
	            var animator = new Animator(target, loop);
	
	            animator.during(function (target) {
	                el.dirty(animatingShape);
	            })
	            .done(function () {
	                // FIXME Animator will not be removed if use `Animator#stop` to stop animation
	                animators.splice(util.indexOf(animators, animator), 1);
	            });
	
	            animators.push(animator);
	
	            // If animate after added to the zrender
	            if (zr) {
	                zr.animation.addAnimator(animator);
	            }
	
	            return animator;
	        },
	
	        /**
	         * 停止动画
	         * @param {boolean} forwardToLast If move to last frame before stop
	         */
	        stopAnimation: function (forwardToLast) {
	            var animators = this.animators;
	            var len = animators.length;
	            for (var i = 0; i < len; i++) {
	                animators[i].stop(forwardToLast);
	            }
	            animators.length = 0;
	
	            return this;
	        },
	
	        /**
	         * @param {Object} target
	         * @param {number} [time=500] Time in ms
	         * @param {string} [easing='linear']
	         * @param {number} [delay=0]
	         * @param {Function} [callback]
	         *
	         * @example
	         *  // Animate position
	         *  el.animateTo({
	         *      position: [10, 10]
	         *  }, function () { // done })
	         *
	         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
	         *  el.animateTo({
	         *      shape: {
	         *          width: 500
	         *      },
	         *      style: {
	         *          fill: 'red'
	         *      }
	         *      position: [10, 10]
	         *  }, 100, 100, 'cubicOut', function () { // done })
	         */
	         // TODO Return animation key
	        animateTo: function (target, time, delay, easing, callback) {
	            // animateTo(target, time, easing, callback);
	            if (isString(delay)) {
	                callback = easing;
	                easing = delay;
	                delay = 0;
	            }
	            // animateTo(target, time, delay, callback);
	            else if (isFunction(easing)) {
	                callback = easing;
	                easing = 'linear';
	                delay = 0;
	            }
	            // animateTo(target, time, callback);
	            else if (isFunction(delay)) {
	                callback = delay;
	                delay = 0;
	            }
	            // animateTo(target, callback)
	            else if (isFunction(time)) {
	                callback = time;
	                time = 500;
	            }
	            // animateTo(target)
	            else if (!time) {
	                time = 500;
	            }
	            // Stop all previous animations
	            this.stopAnimation();
	            this._animateToShallow('', this, target, time, delay, easing, callback);
	
	            // Animators may be removed immediately after start
	            // if there is nothing to animate
	            var animators = this.animators.slice();
	            var count = animators.length;
	            function done() {
	                count--;
	                if (!count) {
	                    callback && callback();
	                }
	            }
	
	            // No animators. This should be checked before animators[i].start(),
	            // because 'done' may be executed immediately if no need to animate.
	            if (!count) {
	                callback && callback();
	            }
	            // Start after all animators created
	            // Incase any animator is done immediately when all animation properties are not changed
	            for (var i = 0; i < animators.length; i++) {
	                animators[i]
	                    .done(done)
	                    .start(easing);
	            }
	        },
	
	        /**
	         * @private
	         * @param {string} path=''
	         * @param {Object} source=this
	         * @param {Object} target
	         * @param {number} [time=500]
	         * @param {number} [delay=0]
	         *
	         * @example
	         *  // Animate position
	         *  el._animateToShallow({
	         *      position: [10, 10]
	         *  })
	         *
	         *  // Animate shape, style and position in 100ms, delayed 100ms
	         *  el._animateToShallow({
	         *      shape: {
	         *          width: 500
	         *      },
	         *      style: {
	         *          fill: 'red'
	         *      }
	         *      position: [10, 10]
	         *  }, 100, 100)
	         */
	        _animateToShallow: function (path, source, target, time, delay) {
	            var objShallow = {};
	            var propertyCount = 0;
	            for (var name in target) {
	                if (!target.hasOwnProperty(name)) {
	                    continue;
	                }
	
	                if (source[name] != null) {
	                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {
	                        this._animateToShallow(
	                            path ? path + '.' + name : name,
	                            source[name],
	                            target[name],
	                            time,
	                            delay
	                        );
	                    }
	                    else {
	                        objShallow[name] = target[name];
	                        propertyCount++;
	                    }
	                }
	                else if (target[name] != null) {
	                    // Attr directly if not has property
	                    // FIXME, if some property not needed for element ?
	                    if (!path) {
	                        this.attr(name, target[name]);
	                    }
	                    else {  // Shape or style
	                        var props = {};
	                        props[path] = {};
	                        props[path][name] = target[name];
	                        this.attr(props);
	                    }
	                }
	            }
	
	            if (propertyCount > 0) {
	                this.animate(path, false)
	                    .when(time == null ? 500 : time, objShallow)
	                    .delay(delay || 0);
	            }
	
	            return this;
	        }
	    };
	
	    module.exports = Animatable;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module echarts/animation/Animator
	 */
	
	
	    var Clip = __webpack_require__(17);
	    var color = __webpack_require__(19);
	    var util = __webpack_require__(4);
	    var isArrayLike = util.isArrayLike;
	
	    var arraySlice = Array.prototype.slice;
	
	    function defaultGetter(target, key) {
	        return target[key];
	    }
	
	    function defaultSetter(target, key, value) {
	        target[key] = value;
	    }
	
	    /**
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} percent
	     * @return {number}
	     */
	    function interpolateNumber(p0, p1, percent) {
	        return (p1 - p0) * percent + p0;
	    }
	
	    /**
	     * @param  {string} p0
	     * @param  {string} p1
	     * @param  {number} percent
	     * @return {string}
	     */
	    function interpolateString(p0, p1, percent) {
	        return percent > 0.5 ? p1 : p0;
	    }
	
	    /**
	     * @param  {Array} p0
	     * @param  {Array} p1
	     * @param  {number} percent
	     * @param  {Array} out
	     * @param  {number} arrDim
	     */
	    function interpolateArray(p0, p1, percent, out, arrDim) {
	        var len = p0.length;
	        if (arrDim == 1) {
	            for (var i = 0; i < len; i++) {
	                out[i] = interpolateNumber(p0[i], p1[i], percent);
	            }
	        }
	        else {
	            var len2 = p0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    out[i][j] = interpolateNumber(
	                        p0[i][j], p1[i][j], percent
	                    );
	                }
	            }
	        }
	    }
	
	    // arr0 is source array, arr1 is target array.
	    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1
	    function fillArr(arr0, arr1, arrDim) {
	        var arr0Len = arr0.length;
	        var arr1Len = arr1.length;
	        if (arr0Len !== arr1Len) {
	            // FIXME Not work for TypedArray
	            var isPreviousLarger = arr0Len > arr1Len;
	            if (isPreviousLarger) {
	                // Cut the previous
	                arr0.length = arr1Len;
	            }
	            else {
	                // Fill the previous
	                for (var i = arr0Len; i < arr1Len; i++) {
	                    arr0.push(
	                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])
	                    );
	                }
	            }
	        }
	        // Handling NaN value
	        var len2 = arr0[0] && arr0[0].length;
	        for (var i = 0; i < arr0.length; i++) {
	            if (arrDim === 1) {
	                if (isNaN(arr0[i])) {
	                    arr0[i] = arr1[i];
	                }
	            }
	            else {
	                for (var j = 0; j < len2; j++) {
	                    if (isNaN(arr0[i][j])) {
	                        arr0[i][j] = arr1[i][j];
	                    }
	                }
	            }
	        }
	    }
	
	    /**
	     * @param  {Array} arr0
	     * @param  {Array} arr1
	     * @param  {number} arrDim
	     * @return {boolean}
	     */
	    function isArraySame(arr0, arr1, arrDim) {
	        if (arr0 === arr1) {
	            return true;
	        }
	        var len = arr0.length;
	        if (len !== arr1.length) {
	            return false;
	        }
	        if (arrDim === 1) {
	            for (var i = 0; i < len; i++) {
	                if (arr0[i] !== arr1[i]) {
	                    return false;
	                }
	            }
	        }
	        else {
	            var len2 = arr0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    if (arr0[i][j] !== arr1[i][j]) {
	                        return false;
	                    }
	                }
	            }
	        }
	        return true;
	    }
	
	    /**
	     * Catmull Rom interpolate array
	     * @param  {Array} p0
	     * @param  {Array} p1
	     * @param  {Array} p2
	     * @param  {Array} p3
	     * @param  {number} t
	     * @param  {number} t2
	     * @param  {number} t3
	     * @param  {Array} out
	     * @param  {number} arrDim
	     */
	    function catmullRomInterpolateArray(
	        p0, p1, p2, p3, t, t2, t3, out, arrDim
	    ) {
	        var len = p0.length;
	        if (arrDim == 1) {
	            for (var i = 0; i < len; i++) {
	                out[i] = catmullRomInterpolate(
	                    p0[i], p1[i], p2[i], p3[i], t, t2, t3
	                );
	            }
	        }
	        else {
	            var len2 = p0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    out[i][j] = catmullRomInterpolate(
	                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],
	                        t, t2, t3
	                    );
	                }
	            }
	        }
	    }
	
	    /**
	     * Catmull Rom interpolate number
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @param  {number} t2
	     * @param  {number} t3
	     * @return {number}
	     */
	    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
	        var v0 = (p2 - p0) * 0.5;
	        var v1 = (p3 - p1) * 0.5;
	        return (2 * (p1 - p2) + v0 + v1) * t3
	                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
	                + v0 * t + p1;
	    }
	
	    function cloneValue(value) {
	        if (isArrayLike(value)) {
	            var len = value.length;
	            if (isArrayLike(value[0])) {
	                var ret = [];
	                for (var i = 0; i < len; i++) {
	                    ret.push(arraySlice.call(value[i]));
	                }
	                return ret;
	            }
	
	            return arraySlice.call(value);
	        }
	
	        return value;
	    }
	
	    function rgba2String(rgba) {
	        rgba[0] = Math.floor(rgba[0]);
	        rgba[1] = Math.floor(rgba[1]);
	        rgba[2] = Math.floor(rgba[2]);
	
	        return 'rgba(' + rgba.join(',') + ')';
	    }
	
	    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {
	        var getter = animator._getter;
	        var setter = animator._setter;
	        var useSpline = easing === 'spline';
	
	        var trackLen = keyframes.length;
	        if (!trackLen) {
	            return;
	        }
	        // Guess data type
	        var firstVal = keyframes[0].value;
	        var isValueArray = isArrayLike(firstVal);
	        var isValueColor = false;
	        var isValueString = false;
	
	        // For vertices morphing
	        var arrDim = (
	                isValueArray
	                && isArrayLike(firstVal[0])
	            )
	            ? 2 : 1;
	        var trackMaxTime;
	        // Sort keyframe as ascending
	        keyframes.sort(function(a, b) {
	            return a.time - b.time;
	        });
	
	        trackMaxTime = keyframes[trackLen - 1].time;
	        // Percents of each keyframe
	        var kfPercents = [];
	        // Value of each keyframe
	        var kfValues = [];
	        var prevValue = keyframes[0].value;
	        var isAllValueEqual = true;
	        for (var i = 0; i < trackLen; i++) {
	            kfPercents.push(keyframes[i].time / trackMaxTime);
	            // Assume value is a color when it is a string
	            var value = keyframes[i].value;
	
	            // Check if value is equal, deep check if value is array
	            if (!((isValueArray && isArraySame(value, prevValue, arrDim))
	                || (!isValueArray && value === prevValue))) {
	                isAllValueEqual = false;
	            }
	            prevValue = value;
	
	            // Try converting a string to a color array
	            if (typeof value == 'string') {
	                var colorArray = color.parse(value);
	                if (colorArray) {
	                    value = colorArray;
	                    isValueColor = true;
	                }
	                else {
	                    isValueString = true;
	                }
	            }
	            kfValues.push(value);
	        }
	        if (isAllValueEqual) {
	            return;
	        }
	
	        var lastValue = kfValues[trackLen - 1];
	        // Polyfill array and NaN value
	        for (var i = 0; i < trackLen - 1; i++) {
	            if (isValueArray) {
	                fillArr(kfValues[i], lastValue, arrDim);
	            }
	            else {
	                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
	                    kfValues[i] = lastValue;
	                }
	            }
	        }
	        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);
	
	        // Cache the key of last frame to speed up when
	        // animation playback is sequency
	        var lastFrame = 0;
	        var lastFramePercent = 0;
	        var start;
	        var w;
	        var p0;
	        var p1;
	        var p2;
	        var p3;
	
	        if (isValueColor) {
	            var rgba = [0, 0, 0, 0];
	        }
	
	        var onframe = function (target, percent) {
	            // Find the range keyframes
	            // kf1-----kf2---------current--------kf3
	            // find kf2 and kf3 and do interpolation
	            var frame;
	            // In the easing function like elasticOut, percent may less than 0
	            if (percent < 0) {
	                frame = 0;
	            }
	            else if (percent < lastFramePercent) {
	                // Start from next key
	                // PENDING start from lastFrame ?
	                start = Math.min(lastFrame + 1, trackLen - 1);
	                for (frame = start; frame >= 0; frame--) {
	                    if (kfPercents[frame] <= percent) {
	                        break;
	                    }
	                }
	                // PENDING really need to do this ?
	                frame = Math.min(frame, trackLen - 2);
	            }
	            else {
	                for (frame = lastFrame; frame < trackLen; frame++) {
	                    if (kfPercents[frame] > percent) {
	                        break;
	                    }
	                }
	                frame = Math.min(frame - 1, trackLen - 2);
	            }
	            lastFrame = frame;
	            lastFramePercent = percent;
	
	            var range = (kfPercents[frame + 1] - kfPercents[frame]);
	            if (range === 0) {
	                return;
	            }
	            else {
	                w = (percent - kfPercents[frame]) / range;
	            }
	            if (useSpline) {
	                p1 = kfValues[frame];
	                p0 = kfValues[frame === 0 ? frame : frame - 1];
	                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
	                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
	                if (isValueArray) {
	                    catmullRomInterpolateArray(
	                        p0, p1, p2, p3, w, w * w, w * w * w,
	                        getter(target, propName),
	                        arrDim
	                    );
	                }
	                else {
	                    var value;
	                    if (isValueColor) {
	                        value = catmullRomInterpolateArray(
	                            p0, p1, p2, p3, w, w * w, w * w * w,
	                            rgba, 1
	                        );
	                        value = rgba2String(rgba);
	                    }
	                    else if (isValueString) {
	                        // String is step(0.5)
	                        return interpolateString(p1, p2, w);
	                    }
	                    else {
	                        value = catmullRomInterpolate(
	                            p0, p1, p2, p3, w, w * w, w * w * w
	                        );
	                    }
	                    setter(
	                        target,
	                        propName,
	                        value
	                    );
	                }
	            }
	            else {
	                if (isValueArray) {
	                    interpolateArray(
	                        kfValues[frame], kfValues[frame + 1], w,
	                        getter(target, propName),
	                        arrDim
	                    );
	                }
	                else {
	                    var value;
	                    if (isValueColor) {
	                        interpolateArray(
	                            kfValues[frame], kfValues[frame + 1], w,
	                            rgba, 1
	                        );
	                        value = rgba2String(rgba);
	                    }
	                    else if (isValueString) {
	                        // String is step(0.5)
	                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);
	                    }
	                    else {
	                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
	                    }
	                    setter(
	                        target,
	                        propName,
	                        value
	                    );
	                }
	            }
	        };
	
	        var clip = new Clip({
	            target: animator._target,
	            life: trackMaxTime,
	            loop: animator._loop,
	            delay: animator._delay,
	            onframe: onframe,
	            ondestroy: oneTrackDone
	        });
	
	        if (easing && easing !== 'spline') {
	            clip.easing = easing;
	        }
	
	        return clip;
	    }
	
	    /**
	     * @alias module:zrender/animation/Animator
	     * @constructor
	     * @param {Object} target
	     * @param {boolean} loop
	     * @param {Function} getter
	     * @param {Function} setter
	     */
	    var Animator = function(target, loop, getter, setter) {
	        this._tracks = {};
	        this._target = target;
	
	        this._loop = loop || false;
	
	        this._getter = getter || defaultGetter;
	        this._setter = setter || defaultSetter;
	
	        this._clipCount = 0;
	
	        this._delay = 0;
	
	        this._doneList = [];
	
	        this._onframeList = [];
	
	        this._clipList = [];
	    };
	
	    Animator.prototype = {
	        /**
	         * 设置动画关键帧
	         * @param  {number} time 关键帧时间，单位是ms
	         * @param  {Object} props 关键帧的属性值，key-value表示
	         * @return {module:zrender/animation/Animator}
	         */
	        when: function(time /* ms */, props) {
	            var tracks = this._tracks;
	            for (var propName in props) {
	                if (!props.hasOwnProperty(propName)) {
	                    continue;
	                }
	
	                if (!tracks[propName]) {
	                    tracks[propName] = [];
	                    // Invalid value
	                    var value = this._getter(this._target, propName);
	                    if (value == null) {
	                        // zrLog('Invalid property ' + propName);
	                        continue;
	                    }
	                    // If time is 0
	                    //  Then props is given initialize value
	                    // Else
	                    //  Initialize value from current prop value
	                    if (time !== 0) {
	                        tracks[propName].push({
	                            time: 0,
	                            value: cloneValue(value)
	                        });
	                    }
	                }
	                tracks[propName].push({
	                    time: time,
	                    value: props[propName]
	                });
	            }
	            return this;
	        },
	        /**
	         * 添加动画每一帧的回调函数
	         * @param  {Function} callback
	         * @return {module:zrender/animation/Animator}
	         */
	        during: function (callback) {
	            this._onframeList.push(callback);
	            return this;
	        },
	
	        pause: function () {
	            for (var i = 0; i < this._clipList.length; i++) {
	                this._clipList[i].pause();
	            }
	            this._paused = true;
	        },
	
	        resume: function () {
	            for (var i = 0; i < this._clipList.length; i++) {
	                this._clipList[i].resume();
	            }
	            this._paused = false;
	        },
	
	        isPaused: function () {
	            return !!this._paused;
	        },
	
	        _doneCallback: function () {
	            // Clear all tracks
	            this._tracks = {};
	            // Clear all clips
	            this._clipList.length = 0;
	
	            var doneList = this._doneList;
	            var len = doneList.length;
	            for (var i = 0; i < len; i++) {
	                doneList[i].call(this);
	            }
	        },
	        /**
	         * 开始执行动画
	         * @param  {string|Function} easing
	         *         动画缓动函数，详见{@link module:zrender/animation/easing}
	         * @return {module:zrender/animation/Animator}
	         */
	        start: function (easing) {
	
	            var self = this;
	            var clipCount = 0;
	
	            var oneTrackDone = function() {
	                clipCount--;
	                if (!clipCount) {
	                    self._doneCallback();
	                }
	            };
	
	            var lastClip;
	            for (var propName in this._tracks) {
	                if (!this._tracks.hasOwnProperty(propName)) {
	                    continue;
	                }
	                var clip = createTrackClip(
	                    this, easing, oneTrackDone,
	                    this._tracks[propName], propName
	                );
	                if (clip) {
	                    this._clipList.push(clip);
	                    clipCount++;
	
	                    // If start after added to animation
	                    if (this.animation) {
	                        this.animation.addClip(clip);
	                    }
	
	                    lastClip = clip;
	                }
	            }
	
	            // Add during callback on the last clip
	            if (lastClip) {
	                var oldOnFrame = lastClip.onframe;
	                lastClip.onframe = function (target, percent) {
	                    oldOnFrame(target, percent);
	
	                    for (var i = 0; i < self._onframeList.length; i++) {
	                        self._onframeList[i](target, percent);
	                    }
	                };
	            }
	
	            if (!clipCount) {
	                this._doneCallback();
	            }
	            return this;
	        },
	        /**
	         * 停止动画
	         * @param {boolean} forwardToLast If move to last frame before stop
	         */
	        stop: function (forwardToLast) {
	            var clipList = this._clipList;
	            var animation = this.animation;
	            for (var i = 0; i < clipList.length; i++) {
	                var clip = clipList[i];
	                if (forwardToLast) {
	                    // Move to last frame before stop
	                    clip.onframe(this._target, 1);
	                }
	                animation && animation.removeClip(clip);
	            }
	            clipList.length = 0;
	        },
	        /**
	         * 设置动画延迟开始的时间
	         * @param  {number} time 单位ms
	         * @return {module:zrender/animation/Animator}
	         */
	        delay: function (time) {
	            this._delay = time;
	            return this;
	        },
	        /**
	         * 添加动画结束的回调
	         * @param  {Function} cb
	         * @return {module:zrender/animation/Animator}
	         */
	        done: function(cb) {
	            if (cb) {
	                this._doneList.push(cb);
	            }
	            return this;
	        },
	
	        /**
	         * @return {Array.<module:zrender/animation/Clip>}
	         */
	        getClips: function () {
	            return this._clipList;
	        }
	    };
	
	    module.exports = Animator;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 动画主控制器
	 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
	 * @config life(1000) 动画时长
	 * @config delay(0) 动画延迟时间
	 * @config loop(true)
	 * @config gap(0) 循环的间隔时间
	 * @config onframe
	 * @config easing(optional)
	 * @config ondestroy(optional)
	 * @config onrestart(optional)
	 *
	 * TODO pause
	 */
	
	
	    var easingFuncs = __webpack_require__(18);
	
	    function Clip(options) {
	
	        this._target = options.target;
	
	        // 生命周期
	        this._life = options.life || 1000;
	        // 延时
	        this._delay = options.delay || 0;
	        // 开始时间
	        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒
	        this._initialized = false;
	
	        // 是否循环
	        this.loop = options.loop == null ? false : options.loop;
	
	        this.gap = options.gap || 0;
	
	        this.easing = options.easing || 'Linear';
	
	        this.onframe = options.onframe;
	        this.ondestroy = options.ondestroy;
	        this.onrestart = options.onrestart;
	
	        this._pausedTime = 0;
	        this._paused = false;
	    }
	
	    Clip.prototype = {
	
	        constructor: Clip,
	
	        step: function (globalTime, deltaTime) {
	            // Set startTime on first step, or _startTime may has milleseconds different between clips
	            // PENDING
	            if (!this._initialized) {
	                this._startTime = globalTime + this._delay;
	                this._initialized = true;
	            }
	
	            if (this._paused) {
	                this._pausedTime += deltaTime;
	                return;
	            }
	
	            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;
	
	            // 还没开始
	            if (percent < 0) {
	                return;
	            }
	
	            percent = Math.min(percent, 1);
	
	            var easing = this.easing;
	            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
	            var schedule = typeof easingFunc === 'function'
	                ? easingFunc(percent)
	                : percent;
	
	            this.fire('frame', schedule);
	
	            // 结束
	            if (percent == 1) {
	                if (this.loop) {
	                    this.restart (globalTime);
	                    // 重新开始周期
	                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
	                    return 'restart';
	                }
	
	                // 动画完成将这个控制器标识为待删除
	                // 在Animation.update中进行批量删除
	                this._needsRemove = true;
	                return 'destroy';
	            }
	
	            return null;
	        },
	
	        restart: function (globalTime) {
	            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
	            this._startTime = globalTime - remainder + this.gap;
	            this._pausedTime = 0;
	
	            this._needsRemove = false;
	        },
	
	        fire: function (eventType, arg) {
	            eventType = 'on' + eventType;
	            if (this[eventType]) {
	                this[eventType](this._target, arg);
	            }
	        },
	
	        pause: function () {
	            this._paused = true;
	        },
	
	        resume: function () {
	            this._paused = false;
	        }
	    };
	
	    module.exports = Clip;
	


/***/ },
/* 18 */
/***/ function(module, exports) {

	/**
	 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
	 * @see http://sole.github.io/tween.js/examples/03_graphs.html
	 * @exports zrender/animation/easing
	 */
	
	    var easing = {
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        linear: function (k) {
	            return k;
	        },
	
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticIn: function (k) {
	            return k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticOut: function (k) {
	            return k * (2 - k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k;
	            }
	            return -0.5 * (--k * (k - 2) - 1);
	        },
	
	        // 三次方的缓动（t^3）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicIn: function (k) {
	            return k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicOut: function (k) {
	            return --k * k * k + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k;
	            }
	            return 0.5 * ((k -= 2) * k * k + 2);
	        },
	
	        // 四次方的缓动（t^4）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticIn: function (k) {
	            return k * k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticOut: function (k) {
	            return 1 - (--k * k * k * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k * k;
	            }
	            return -0.5 * ((k -= 2) * k * k * k - 2);
	        },
	
	        // 五次方的缓动（t^5）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticIn: function (k) {
	            return k * k * k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticOut: function (k) {
	            return --k * k * k * k * k + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k * k * k;
	            }
	            return 0.5 * ((k -= 2) * k * k * k * k + 2);
	        },
	
	        // 正弦曲线的缓动（sin(t)）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalIn: function (k) {
	            return 1 - Math.cos(k * Math.PI / 2);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalOut: function (k) {
	            return Math.sin(k * Math.PI / 2);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalInOut: function (k) {
	            return 0.5 * (1 - Math.cos(Math.PI * k));
	        },
	
	        // 指数曲线的缓动（2^t）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialIn: function (k) {
	            return k === 0 ? 0 : Math.pow(1024, k - 1);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialOut: function (k) {
	            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialInOut: function (k) {
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if ((k *= 2) < 1) {
	                return 0.5 * Math.pow(1024, k - 1);
	            }
	            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
	        },
	
	        // 圆形曲线的缓动（sqrt(1-t^2)）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularIn: function (k) {
	            return 1 - Math.sqrt(1 - k * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularOut: function (k) {
	            return Math.sqrt(1 - (--k * k));
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return -0.5 * (Math.sqrt(1 - k * k) - 1);
	            }
	            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	        },
	
	        // 创建类似于弹簧在停止前来回振荡的动画
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticIn: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            return -(a * Math.pow(2, 10 * (k -= 1)) *
	                        Math.sin((k - s) * (2 * Math.PI) / p));
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticOut: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            return (a * Math.pow(2, -10 * k) *
	                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticInOut: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            if ((k *= 2) < 1) {
	                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))
	                    * Math.sin((k - s) * (2 * Math.PI) / p));
	            }
	            return a * Math.pow(2, -10 * (k -= 1))
	                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
	
	        },
	
	        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backIn: function (k) {
	            var s = 1.70158;
	            return k * k * ((s + 1) * k - s);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backOut: function (k) {
	            var s = 1.70158;
	            return --k * k * ((s + 1) * k + s) + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backInOut: function (k) {
	            var s = 1.70158 * 1.525;
	            if ((k *= 2) < 1) {
	                return 0.5 * (k * k * ((s + 1) * k - s));
	            }
	            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	        },
	
	        // 创建弹跳效果
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceIn: function (k) {
	            return 1 - easing.bounceOut(1 - k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceOut: function (k) {
	            if (k < (1 / 2.75)) {
	                return 7.5625 * k * k;
	            }
	            else if (k < (2 / 2.75)) {
	                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
	            }
	            else if (k < (2.5 / 2.75)) {
	                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
	            }
	            else {
	                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
	            }
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceInOut: function (k) {
	            if (k < 0.5) {
	                return easing.bounceIn(k * 2) * 0.5;
	            }
	            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
	        }
	    };
	
	    module.exports = easing;
	
	


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module zrender/tool/color
	 */
	
	
	    var LRU = __webpack_require__(20);
	
	    var kCSSColorTable = {
	        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],
	        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],
	        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],
	        'beige': [245,245,220,1], 'bisque': [255,228,196,1],
	        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],
	        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],
	        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],
	        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],
	        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],
	        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],
	        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],
	        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],
	        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],
	        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],
	        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],
	        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],
	        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],
	        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],
	        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],
	        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],
	        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],
	        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],
	        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],
	        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],
	        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],
	        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],
	        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],
	        'gray': [128,128,128,1], 'green': [0,128,0,1],
	        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],
	        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],
	        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],
	        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],
	        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],
	        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],
	        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],
	        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],
	        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],
	        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],
	        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],
	        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],
	        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],
	        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],
	        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],
	        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],
	        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],
	        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],
	        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],
	        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],
	        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],
	        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],
	        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],
	        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],
	        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],
	        'orange': [255,165,0,1], 'orangered': [255,69,0,1],
	        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],
	        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],
	        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],
	        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],
	        'pink': [255,192,203,1], 'plum': [221,160,221,1],
	        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],
	        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],
	        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],
	        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],
	        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],
	        'sienna': [160,82,45,1], 'silver': [192,192,192,1],
	        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],
	        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],
	        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],
	        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],
	        'teal': [0,128,128,1], 'thistle': [216,191,216,1],
	        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],
	        'violet': [238,130,238,1], 'wheat': [245,222,179,1],
	        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],
	        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]
	    };
	
	    function clampCssByte(i) {  // Clamp to integer 0 .. 255.
	        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
	        return i < 0 ? 0 : i > 255 ? 255 : i;
	    }
	
	    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.
	        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
	        return i < 0 ? 0 : i > 360 ? 360 : i;
	    }
	
	    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.
	        return f < 0 ? 0 : f > 1 ? 1 : f;
	    }
	
	    function parseCssInt(str) {  // int or percentage.
	        if (str.length && str.charAt(str.length - 1) === '%') {
	            return clampCssByte(parseFloat(str) / 100 * 255);
	        }
	        return clampCssByte(parseInt(str, 10));
	    }
	
	    function parseCssFloat(str) {  // float or percentage.
	        if (str.length && str.charAt(str.length - 1) === '%') {
	            return clampCssFloat(parseFloat(str) / 100);
	        }
	        return clampCssFloat(parseFloat(str));
	    }
	
	    function cssHueToRgb(m1, m2, h) {
	        if (h < 0) {
	            h += 1;
	        }
	        else if (h > 1) {
	            h -= 1;
	        }
	
	        if (h * 6 < 1) {
	            return m1 + (m2 - m1) * h * 6;
	        }
	        if (h * 2 < 1) {
	            return m2;
	        }
	        if (h * 3 < 2) {
	            return m1 + (m2 - m1) * (2/3 - h) * 6;
	        }
	        return m1;
	    }
	
	    function lerp(a, b, p) {
	        return a + (b - a) * p;
	    }
	
	    function setRgba(out, r, g, b, a) {
	        out[0] = r; out[1] = g; out[2] = b; out[3] = a;
	        return out;
	    }
	    function copyRgba(out, a) {
	        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
	        return out;
	    }
	    var colorCache = new LRU(20);
	    var lastRemovedArr = null;
	    function putToCache(colorStr, rgbaArr) {
	        // Reuse removed array
	        if (lastRemovedArr) {
	            copyRgba(lastRemovedArr, rgbaArr);
	        }
	        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));
	    }
	    /**
	     * @param {string} colorStr
	     * @param {Array.<number>} out
	     * @return {Array.<number>}
	     * @memberOf module:zrender/util/color
	     */
	    function parse(colorStr, rgbaArr) {
	        if (!colorStr) {
	            return;
	        }
	        rgbaArr = rgbaArr || [];
	
	        var cached = colorCache.get(colorStr);
	        if (cached) {
	            return copyRgba(rgbaArr, cached);
	        }
	
	        // colorStr may be not string
	        colorStr = colorStr + '';
	        // Remove all whitespace, not compliant, but should just be more accepting.
	        var str = colorStr.replace(/ /g, '').toLowerCase();
	
	        // Color keywords (and transparent) lookup.
	        if (str in kCSSColorTable) {
	            copyRgba(rgbaArr, kCSSColorTable[str]);
	            putToCache(colorStr, rgbaArr);
	            return rgbaArr;
	        }
	
	        // #abc and #abc123 syntax.
	        if (str.charAt(0) === '#') {
	            if (str.length === 4) {
	                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
	                if (!(iv >= 0 && iv <= 0xfff)) {
	                    setRgba(rgbaArr, 0, 0, 0, 1);
	                    return;  // Covers NaN.
	                }
	                setRgba(rgbaArr,
	                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
	                    (iv & 0xf0) | ((iv & 0xf0) >> 4),
	                    (iv & 0xf) | ((iv & 0xf) << 4),
	                    1
	                );
	                putToCache(colorStr, rgbaArr);
	                return rgbaArr;
	            }
	            else if (str.length === 7) {
	                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
	                if (!(iv >= 0 && iv <= 0xffffff)) {
	                    setRgba(rgbaArr, 0, 0, 0, 1);
	                    return;  // Covers NaN.
	                }
	                setRgba(rgbaArr,
	                    (iv & 0xff0000) >> 16,
	                    (iv & 0xff00) >> 8,
	                    iv & 0xff,
	                    1
	                );
	                putToCache(colorStr, rgbaArr);
	                return rgbaArr;
	            }
	
	            return;
	        }
	        var op = str.indexOf('('), ep = str.indexOf(')');
	        if (op !== -1 && ep + 1 === str.length) {
	            var fname = str.substr(0, op);
	            var params = str.substr(op + 1, ep - (op + 1)).split(',');
	            var alpha = 1;  // To allow case fallthrough.
	            switch (fname) {
	                case 'rgba':
	                    if (params.length !== 4) {
	                        setRgba(rgbaArr, 0, 0, 0, 1);
	                        return;
	                    }
	                    alpha = parseCssFloat(params.pop()); // jshint ignore:line
	                // Fall through.
	                case 'rgb':
	                    if (params.length !== 3) {
	                        setRgba(rgbaArr, 0, 0, 0, 1);
	                        return;
	                    }
	                    setRgba(rgbaArr,
	                        parseCssInt(params[0]),
	                        parseCssInt(params[1]),
	                        parseCssInt(params[2]),
	                        alpha
	                    );
	                    putToCache(colorStr, rgbaArr);
	                    return rgbaArr;
	                case 'hsla':
	                    if (params.length !== 4) {
	                        setRgba(rgbaArr, 0, 0, 0, 1);
	                        return;
	                    }
	                    params[3] = parseCssFloat(params[3]);
	                    hsla2rgba(params, rgbaArr);
	                    putToCache(colorStr, rgbaArr);
	                    return rgbaArr;
	                case 'hsl':
	                    if (params.length !== 3) {
	                        setRgba(rgbaArr, 0, 0, 0, 1);
	                        return;
	                    }
	                    hsla2rgba(params, rgbaArr);
	                    putToCache(colorStr, rgbaArr);
	                    return rgbaArr;
	                default:
	                    return;
	            }
	        }
	
	        setRgba(rgbaArr, 0, 0, 0, 1);
	        return;
	    }
	
	    /**
	     * @param {Array.<number>} hsla
	     * @param {Array.<number>} rgba
	     * @return {Array.<number>} rgba
	     */
	    function hsla2rgba(hsla, rgba) {
	        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
	        // NOTE(deanm): According to the CSS spec s/l should only be
	        // percentages, but we don't bother and let float or percentage.
	        var s = parseCssFloat(hsla[1]);
	        var l = parseCssFloat(hsla[2]);
	        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	        var m1 = l * 2 - m2;
	
	        rgba = rgba || [];
	        setRgba(rgba,
	            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),
	            clampCssByte(cssHueToRgb(m1, m2, h) * 255),
	            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),
	            1
	        );
	
	        if (hsla.length === 4) {
	            rgba[3] = hsla[3];
	        }
	
	        return rgba;
	    }
	
	    /**
	     * @param {Array.<number>} rgba
	     * @return {Array.<number>} hsla
	     */
	    function rgba2hsla(rgba) {
	        if (!rgba) {
	            return;
	        }
	
	        // RGB from 0 to 255
	        var R = rgba[0] / 255;
	        var G = rgba[1] / 255;
	        var B = rgba[2] / 255;
	
	        var vMin = Math.min(R, G, B); // Min. value of RGB
	        var vMax = Math.max(R, G, B); // Max. value of RGB
	        var delta = vMax - vMin; // Delta RGB value
	
	        var L = (vMax + vMin) / 2;
	        var H;
	        var S;
	        // HSL results from 0 to 1
	        if (delta === 0) {
	            H = 0;
	            S = 0;
	        }
	        else {
	            if (L < 0.5) {
	                S = delta / (vMax + vMin);
	            }
	            else {
	                S = delta / (2 - vMax - vMin);
	            }
	
	            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
	            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
	            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;
	
	            if (R === vMax) {
	                H = deltaB - deltaG;
	            }
	            else if (G === vMax) {
	                H = (1 / 3) + deltaR - deltaB;
	            }
	            else if (B === vMax) {
	                H = (2 / 3) + deltaG - deltaR;
	            }
	
	            if (H < 0) {
	                H += 1;
	            }
	
	            if (H > 1) {
	                H -= 1;
	            }
	        }
	
	        var hsla = [H * 360, S, L];
	
	        if (rgba[3] != null) {
	            hsla.push(rgba[3]);
	        }
	
	        return hsla;
	    }
	
	    /**
	     * @param {string} color
	     * @param {number} level
	     * @return {string}
	     * @memberOf module:zrender/util/color
	     */
	    function lift(color, level) {
	        var colorArr = parse(color);
	        if (colorArr) {
	            for (var i = 0; i < 3; i++) {
	                if (level < 0) {
	                    colorArr[i] = colorArr[i] * (1 - level) | 0;
	                }
	                else {
	                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;
	                }
	            }
	            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
	        }
	    }
	
	    /**
	     * @param {string} color
	     * @return {string}
	     * @memberOf module:zrender/util/color
	     */
	    function toHex(color, level) {
	        var colorArr = parse(color);
	        if (colorArr) {
	            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);
	        }
	    }
	
	    /**
	     * Map value to color. Faster than mapToColor methods because color is represented by rgba array
	     * @param {number} normalizedValue A float between 0 and 1.
	     * @param {Array.<Array.<number>>} colors List of rgba color array
	     * @param {Array.<number>} [out] Mapped gba color array
	     * @return {Array.<number>}
	     */
	    function fastMapToColor(normalizedValue, colors, out) {
	        out = out || [0, 0, 0, 0];
	        if (!(colors && colors.length)
	            || !(normalizedValue >= 0 && normalizedValue <= 1)
	        ) {
	            return out;
	        }
	        var value = normalizedValue * (colors.length - 1);
	        var leftIndex = Math.floor(value);
	        var rightIndex = Math.ceil(value);
	        var leftColor = colors[leftIndex];
	        var rightColor = colors[rightIndex];
	        var dv = value - leftIndex;
	        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));
	        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));
	        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));
	        out[3] = clampCssFloat(lerp(leftColor[3], rightColor[3], dv));
	        return out;
	    }
	    /**
	     * @param {number} normalizedValue A float between 0 and 1.
	     * @param {Array.<string>} colors Color list.
	     * @param {boolean=} fullOutput Default false.
	     * @return {(string|Object)} Result color. If fullOutput,
	     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
	     * @memberOf module:zrender/util/color
	     */
	    function mapToColor(normalizedValue, colors, fullOutput) {
	        if (!(colors && colors.length)
	            || !(normalizedValue >= 0 && normalizedValue <= 1)
	        ) {
	            return;
	        }
	
	        var value = normalizedValue * (colors.length - 1);
	        var leftIndex = Math.floor(value);
	        var rightIndex = Math.ceil(value);
	        var leftColor = parse(colors[leftIndex]);
	        var rightColor = parse(colors[rightIndex]);
	        var dv = value - leftIndex;
	
	        var color = stringify(
	            [
	                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),
	                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),
	                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),
	                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))
	            ],
	            'rgba'
	        );
	
	        return fullOutput
	            ? {
	                color: color,
	                leftIndex: leftIndex,
	                rightIndex: rightIndex,
	                value: value
	            }
	            : color;
	    }
	
	    /**
	     * @param {string} color
	     * @param {number=} h 0 ~ 360, ignore when null.
	     * @param {number=} s 0 ~ 1, ignore when null.
	     * @param {number=} l 0 ~ 1, ignore when null.
	     * @return {string} Color string in rgba format.
	     * @memberOf module:zrender/util/color
	     */
	    function modifyHSL(color, h, s, l) {
	        color = parse(color);
	
	        if (color) {
	            color = rgba2hsla(color);
	            h != null && (color[0] = clampCssAngle(h));
	            s != null && (color[1] = parseCssFloat(s));
	            l != null && (color[2] = parseCssFloat(l));
	
	            return stringify(hsla2rgba(color), 'rgba');
	        }
	    }
	
	    /**
	     * @param {string} color
	     * @param {number=} alpha 0 ~ 1
	     * @return {string} Color string in rgba format.
	     * @memberOf module:zrender/util/color
	     */
	    function modifyAlpha(color, alpha) {
	        color = parse(color);
	
	        if (color && alpha != null) {
	            color[3] = clampCssFloat(alpha);
	            return stringify(color, 'rgba');
	        }
	    }
	
	    /**
	     * @param {Array.<string>} colors Color list.
	     * @param {string} type 'rgba', 'hsva', ...
	     * @return {string} Result color. (If input illegal, return undefined).
	     */
	    function stringify(arrColor, type) {
	        if (!arrColor) {
	            return;
	        }
	        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
	        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
	            colorStr += ',' + arrColor[3];
	        }
	        return type + '(' + colorStr + ')';
	    }
	
	    module.exports = {
	        parse: parse,
	        lift: lift,
	        toHex: toHex,
	        fastMapToColor: fastMapToColor,
	        mapToColor: mapToColor,
	        modifyHSL: modifyHSL,
	        modifyAlpha: modifyAlpha,
	        stringify: stringify
	    };
	
	


/***/ },
/* 20 */
/***/ function(module, exports) {

	// Simple LRU cache use doubly linked list
	// @module zrender/core/LRU
	
	
	    /**
	     * Simple double linked list. Compared with array, it has O(1) remove operation.
	     * @constructor
	     */
	    var LinkedList = function () {
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.head = null;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.tail = null;
	
	        this._len = 0;
	    };
	
	    var linkedListProto = LinkedList.prototype;
	    /**
	     * Insert a new value at the tail
	     * @param  {} val
	     * @return {module:zrender/core/LRU~Entry}
	     */
	    linkedListProto.insert = function (val) {
	        var entry = new Entry(val);
	        this.insertEntry(entry);
	        return entry;
	    };
	
	    /**
	     * Insert an entry at the tail
	     * @param  {module:zrender/core/LRU~Entry} entry
	     */
	    linkedListProto.insertEntry = function (entry) {
	        if (!this.head) {
	            this.head = this.tail = entry;
	        }
	        else {
	            this.tail.next = entry;
	            entry.prev = this.tail;
	            entry.next = null;
	            this.tail = entry;
	        }
	        this._len++;
	    };
	
	    /**
	     * Remove entry.
	     * @param  {module:zrender/core/LRU~Entry} entry
	     */
	    linkedListProto.remove = function (entry) {
	        var prev = entry.prev;
	        var next = entry.next;
	        if (prev) {
	            prev.next = next;
	        }
	        else {
	            // Is head
	            this.head = next;
	        }
	        if (next) {
	            next.prev = prev;
	        }
	        else {
	            // Is tail
	            this.tail = prev;
	        }
	        entry.next = entry.prev = null;
	        this._len--;
	    };
	
	    /**
	     * @return {number}
	     */
	    linkedListProto.len = function () {
	        return this._len;
	    };
	
	    /**
	     * Clear list
	     */
	    linkedListProto.clear = function () {
	        this.head = this.tail = null;
	        this._len = 0;
	    };
	
	    /**
	     * @constructor
	     * @param {} val
	     */
	    var Entry = function (val) {
	        /**
	         * @type {}
	         */
	        this.value = val;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.next;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.prev;
	    };
	
	    /**
	     * LRU Cache
	     * @constructor
	     * @alias module:zrender/core/LRU
	     */
	    var LRU = function (maxSize) {
	
	        this._list = new LinkedList();
	
	        this._map = {};
	
	        this._maxSize = maxSize || 10;
	
	        this._lastRemovedEntry = null;
	    };
	
	    var LRUProto = LRU.prototype;
	
	    /**
	     * @param  {string} key
	     * @param  {} value
	     * @return {} Removed value
	     */
	    LRUProto.put = function (key, value) {
	        var list = this._list;
	        var map = this._map;
	        var removed = null;
	        if (map[key] == null) {
	            var len = list.len();
	            // Reuse last removed entry
	            var entry = this._lastRemovedEntry;
	
	            if (len >= this._maxSize && len > 0) {
	                // Remove the least recently used
	                var leastUsedEntry = list.head;
	                list.remove(leastUsedEntry);
	                delete map[leastUsedEntry.key];
	
	                removed = leastUsedEntry.value;
	                this._lastRemovedEntry = leastUsedEntry;
	            }
	
	            if (entry) {
	                entry.value = value;
	            }
	            else {
	                entry = new Entry(value);
	            }
	            entry.key = key;
	            list.insertEntry(entry);
	            map[key] = entry;
	        }
	
	        return removed;
	    };
	
	    /**
	     * @param  {string} key
	     * @return {}
	     */
	    LRUProto.get = function (key) {
	        var entry = this._map[key];
	        var list = this._list;
	        if (entry != null) {
	            // Put the latest used entry in the tail
	            if (entry !== list.tail) {
	                list.remove(entry);
	                list.insertEntry(entry);
	            }
	
	            return entry.value;
	        }
	    };
	
	    /**
	     * Clear the cache
	     */
	    LRUProto.clear = function () {
	        this._list.clear();
	        this._map = {};
	    };
	
	    module.exports = LRU;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	
	        var config = __webpack_require__(22);
	
	        /**
	         * @exports zrender/tool/log
	         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	         */
	        module.exports = function() {
	            if (config.debugMode === 0) {
	                return;
	            }
	            else if (config.debugMode == 1) {
	                for (var k in arguments) {
	                    throw new Error(arguments[k]);
	                }
	            }
	            else if (config.debugMode > 1) {
	                for (var k in arguments) {
	                    console.log(arguments[k]);
	                }
	            }
	        };
	
	        /* for debug
	        return function(mes) {
	            document.getElementById('wrong-message').innerHTML =
	                mes + ' ' + (new Date() - 0)
	                + '<br/>'
	                + document.getElementById('wrong-message').innerHTML;
	        };
	        */
	    


/***/ },
/* 22 */
/***/ function(module, exports) {

	
	    var dpr = 1;
	    // If in browser environment
	    if (typeof window !== 'undefined') {
	        dpr = Math.max(window.devicePixelRatio || 1, 1);
	    }
	    /**
	     * config默认配置项
	     * @exports zrender/config
	     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	     */
	    var config = {
	        /**
	         * debug日志选项：catchBrushException为true下有效
	         * 0 : 不生成debug数据，发布用
	         * 1 : 异常抛出，调试用
	         * 2 : 控制台输出，调试用
	         */
	        debugMode: 0,
	
	        // retina 屏幕优化
	        devicePixelRatio: dpr
	    };
	    module.exports = config;
	
	


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Mixin for drawing text in a element bounding rect
	 * @module zrender/mixin/RectText
	 */
	
	
	
	    var textContain = __webpack_require__(24);
	    var BoundingRect = __webpack_require__(25);
	
	    var tmpRect = new BoundingRect();
	
	    var RectText = function () {};
	
	    function parsePercent(value, maxValue) {
	        if (typeof value === 'string') {
	            if (value.lastIndexOf('%') >= 0) {
	                return parseFloat(value) / 100 * maxValue;
	            }
	            return parseFloat(value);
	        }
	        return value;
	    }
	
	    RectText.prototype = {
	
	        constructor: RectText,
	
	        /**
	         * Draw text in a rect with specified position.
	         * @param  {CanvasRenderingContext} ctx
	         * @param  {Object} rect Displayable rect
	         * @return {Object} textRect Alternative precalculated text bounding rect
	         */
	        drawRectText: function (ctx, rect, textRect) {
	            var style = this.style;
	            var text = style.text;
	            // Convert to string
	            text != null && (text += '');
	            if (!text) {
	                return;
	            }
	
	            // FIXME
	            ctx.save();
	
	            var x;
	            var y;
	            var textPosition = style.textPosition;
	            var textOffset = style.textOffset;
	            var distance = style.textDistance;
	            var align = style.textAlign;
	            var font = style.textFont || style.font;
	            var baseline = style.textBaseline;
	            var verticalAlign = style.textVerticalAlign;
	
	            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);
	
	            // Transform rect to view space
	            var transform = this.transform;
	            if (!style.textTransform) {
	                if (transform) {
	                    tmpRect.copy(rect);
	                    tmpRect.applyTransform(transform);
	                    rect = tmpRect;
	                }
	            }
	            else {
	                this.setTransform(ctx);
	            }
	
	            // Text position represented by coord
	            if (textPosition instanceof Array) {
	                // Percent
	                x = rect.x + parsePercent(textPosition[0], rect.width);
	                y = rect.y + parsePercent(textPosition[1], rect.height);
	                align = align || 'left';
	                baseline = baseline || 'top';
	
	                if (verticalAlign) {
	                    switch (verticalAlign) {
	                        case 'middle':
	                            y -= textRect.height / 2 - textRect.lineHeight / 2;
	                            break;
	                        case 'bottom':
	                            y -= textRect.height - textRect.lineHeight / 2;
	                            break;
	                        default:
	                            y += textRect.lineHeight / 2;
	                    }
	                    // Force bseline to be middle
	                    baseline = 'middle';
	                }
	            }
	            else {
	                var res = textContain.adjustTextPositionOnRect(
	                    textPosition, rect, textRect, distance
	                );
	                x = res.x;
	                y = res.y;
	                // Default align and baseline when has textPosition
	                align = align || res.textAlign;
	                baseline = baseline || res.textBaseline;
	            }
	
	            if (textOffset) {
	                x += textOffset[0];
	                y += textOffset[1];
	            }
	
	            // Use canvas default left textAlign. Giving invalid value will cause state not change
	            ctx.textAlign = align || 'left';
	            // Use canvas default alphabetic baseline
	            ctx.textBaseline = baseline || 'alphabetic';
	
	            var textFill = style.textFill;
	            var textStroke = style.textStroke;
	            textFill && (ctx.fillStyle = textFill);
	            textStroke && (ctx.strokeStyle = textStroke);
	
	            // TODO Invalid font
	            ctx.font = font || '12px sans-serif';
	
	            // Text shadow
	            // Always set shadowBlur and shadowOffset to avoid leak from displayable
	            ctx.shadowBlur = style.textShadowBlur;
	            ctx.shadowColor = style.textShadowColor || 'transparent';
	            ctx.shadowOffsetX = style.textShadowOffsetX;
	            ctx.shadowOffsetY = style.textShadowOffsetY;
	
	            var textLines = text.split('\n');
	
	            if (style.textRotation) {
	                transform && ctx.translate(transform[4], transform[5]);
	                ctx.rotate(style.textRotation);
	                transform && ctx.translate(-transform[4], -transform[5]);
	            }
	
	            for (var i = 0; i < textLines.length; i++) {
	                    // Fill after stroke so the outline will not cover the main part.
	                textStroke && ctx.strokeText(textLines[i], x, y);
	                textFill && ctx.fillText(textLines[i], x, y);
	                y += textRect.lineHeight;
	            }
	
	            ctx.restore();
	        }
	    };
	
	    module.exports = RectText;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var textWidthCache = {};
	    var textWidthCacheCounter = 0;
	    var TEXT_CACHE_MAX = 5000;
	
	    var util = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(25);
	    var retrieve = util.retrieve;
	
	    function getTextWidth(text, textFont) {
	        var key = text + ':' + textFont;
	        if (textWidthCache[key]) {
	            return textWidthCache[key];
	        }
	
	        var textLines = (text + '').split('\n');
	        var width = 0;
	
	        for (var i = 0, l = textLines.length; i < l; i++) {
	            // measureText 可以被覆盖以兼容不支持 Canvas 的环境
	            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);
	        }
	
	        if (textWidthCacheCounter > TEXT_CACHE_MAX) {
	            textWidthCacheCounter = 0;
	            textWidthCache = {};
	        }
	        textWidthCacheCounter++;
	        textWidthCache[key] = width;
	
	        return width;
	    }
	
	    function getTextRect(text, textFont, textAlign, textBaseline) {
	        var textLineLen = ((text || '') + '').split('\n').length;
	
	        var width = getTextWidth(text, textFont);
	        // FIXME 高度计算比较粗暴
	        var lineHeight = getTextWidth('国', textFont);
	        var height = textLineLen * lineHeight;
	
	        var rect = new BoundingRect(0, 0, width, height);
	        // Text has a special line height property
	        rect.lineHeight = lineHeight;
	
	        switch (textBaseline) {
	            case 'bottom':
	            case 'alphabetic':
	                rect.y -= lineHeight;
	                break;
	            case 'middle':
	                rect.y -= lineHeight / 2;
	                break;
	            // case 'hanging':
	            // case 'top':
	        }
	
	        // FIXME Right to left language
	        switch (textAlign) {
	            case 'end':
	            case 'right':
	                rect.x -= rect.width;
	                break;
	            case 'center':
	                rect.x -= rect.width / 2;
	                break;
	            // case 'start':
	            // case 'left':
	        }
	
	        return rect;
	    }
	
	    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {
	
	        var x = rect.x;
	        var y = rect.y;
	
	        var height = rect.height;
	        var width = rect.width;
	
	        var textHeight = textRect.height;
	
	        var halfHeight = height / 2 - textHeight / 2;
	
	        var textAlign = 'left';
	
	        switch (textPosition) {
	            case 'left':
	                x -= distance;
	                y += halfHeight;
	                textAlign = 'right';
	                break;
	            case 'right':
	                x += distance + width;
	                y += halfHeight;
	                textAlign = 'left';
	                break;
	            case 'top':
	                x += width / 2;
	                y -= distance + textHeight;
	                textAlign = 'center';
	                break;
	            case 'bottom':
	                x += width / 2;
	                y += height + distance;
	                textAlign = 'center';
	                break;
	            case 'inside':
	                x += width / 2;
	                y += halfHeight;
	                textAlign = 'center';
	                break;
	            case 'insideLeft':
	                x += distance;
	                y += halfHeight;
	                textAlign = 'left';
	                break;
	            case 'insideRight':
	                x += width - distance;
	                y += halfHeight;
	                textAlign = 'right';
	                break;
	            case 'insideTop':
	                x += width / 2;
	                y += distance;
	                textAlign = 'center';
	                break;
	            case 'insideBottom':
	                x += width / 2;
	                y += height - textHeight - distance;
	                textAlign = 'center';
	                break;
	            case 'insideTopLeft':
	                x += distance;
	                y += distance;
	                textAlign = 'left';
	                break;
	            case 'insideTopRight':
	                x += width - distance;
	                y += distance;
	                textAlign = 'right';
	                break;
	            case 'insideBottomLeft':
	                x += distance;
	                y += height - textHeight - distance;
	                break;
	            case 'insideBottomRight':
	                x += width - distance;
	                y += height - textHeight - distance;
	                textAlign = 'right';
	                break;
	        }
	
	        return {
	            x: x,
	            y: y,
	            textAlign: textAlign,
	            textBaseline: 'top'
	        };
	    }
	
	    /**
	     * Show ellipsis if overflow.
	     *
	     * @param  {string} text
	     * @param  {string} containerWidth
	     * @param  {string} textFont
	     * @param  {number} [ellipsis='...']
	     * @param  {Object} [options]
	     * @param  {number} [options.maxIterations=3]
	     * @param  {number} [options.minChar=0] If truncate result are less
	     *                  then minChar, ellipsis will not show, which is
	     *                  better for user hint in some cases.
	     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
	     * @return {string}
	     */
	    function truncateText(text, containerWidth, textFont, ellipsis, options) {
	        if (!containerWidth) {
	            return '';
	        }
	
	        options = options || {};
	
	        ellipsis = retrieve(ellipsis, '...');
	        var maxIterations = retrieve(options.maxIterations, 2);
	        var minChar = retrieve(options.minChar, 0);
	        // FIXME
	        // Other languages?
	        var cnCharWidth = getTextWidth('国', textFont);
	        // FIXME
	        // Consider proportional font?
	        var ascCharWidth = getTextWidth('a', textFont);
	        var placeholder = retrieve(options.placeholder, '');
	
	        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
	        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.
	        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.
	        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
	            contentWidth -= ascCharWidth;
	        }
	
	        var ellipsisWidth = getTextWidth(ellipsis);
	        if (ellipsisWidth > contentWidth) {
	            ellipsis = '';
	            ellipsisWidth = 0;
	        }
	
	        contentWidth = containerWidth - ellipsisWidth;
	
	        var textLines = (text + '').split('\n');
	
	        for (var i = 0, len = textLines.length; i < len; i++) {
	            var textLine = textLines[i];
	            var lineWidth = getTextWidth(textLine, textFont);
	
	            if (lineWidth <= containerWidth) {
	                continue;
	            }
	
	            for (var j = 0;; j++) {
	                if (lineWidth <= contentWidth || j >= maxIterations) {
	                    textLine += ellipsis;
	                    break;
	                }
	
	                var subLength = j === 0
	                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)
	                    : lineWidth > 0
	                    ? Math.floor(textLine.length * contentWidth / lineWidth)
	                    : 0;
	
	                textLine = textLine.substr(0, subLength);
	                lineWidth = getTextWidth(textLine, textFont);
	            }
	
	            if (textLine === '') {
	                textLine = placeholder;
	            }
	
	            textLines[i] = textLine;
	        }
	
	        return textLines.join('\n');
	    }
	
	    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
	        var width = 0;
	        var i = 0;
	        for (var len = text.length; i < len && width < contentWidth; i++) {
	            var charCode = text.charCodeAt(i);
	            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;
	        }
	        return i;
	    }
	
	    var textContain = {
	
	        getWidth: getTextWidth,
	
	        getBoundingRect: getTextRect,
	
	        adjustTextPositionOnRect: adjustTextPositionOnRect,
	
	        truncateText: truncateText,
	
	        measureText: function (text, textFont) {
	            var ctx = util.getContext();
	            ctx.font = textFont || '12px sans-serif';
	            return ctx.measureText(text);
	        }
	    };
	
	    module.exports = textContain;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module echarts/core/BoundingRect
	 */
	
	
	    var vec2 = __webpack_require__(14);
	    var matrix = __webpack_require__(13);
	
	    var v2ApplyTransform = vec2.applyTransform;
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    /**
	     * @alias module:echarts/core/BoundingRect
	     */
	    function BoundingRect(x, y, width, height) {
	
	        if (width < 0) {
	            x = x + width;
	            width = -width;
	        }
	        if (height < 0) {
	            y = y + height;
	            height = -height;
	        }
	
	        /**
	         * @type {number}
	         */
	        this.x = x;
	        /**
	         * @type {number}
	         */
	        this.y = y;
	        /**
	         * @type {number}
	         */
	        this.width = width;
	        /**
	         * @type {number}
	         */
	        this.height = height;
	    }
	
	    BoundingRect.prototype = {
	
	        constructor: BoundingRect,
	
	        /**
	         * @param {module:echarts/core/BoundingRect} other
	         */
	        union: function (other) {
	            var x = mathMin(other.x, this.x);
	            var y = mathMin(other.y, this.y);
	
	            this.width = mathMax(
	                    other.x + other.width,
	                    this.x + this.width
	                ) - x;
	            this.height = mathMax(
	                    other.y + other.height,
	                    this.y + this.height
	                ) - y;
	            this.x = x;
	            this.y = y;
	        },
	
	        /**
	         * @param {Array.<number>} m
	         * @methods
	         */
	        applyTransform: (function () {
	            var lt = [];
	            var rb = [];
	            var lb = [];
	            var rt = [];
	            return function (m) {
	                // In case usage like this
	                // el.getBoundingRect().applyTransform(el.transform)
	                // And element has no transform
	                if (!m) {
	                    return;
	                }
	                lt[0] = lb[0] = this.x;
	                lt[1] = rt[1] = this.y;
	                rb[0] = rt[0] = this.x + this.width;
	                rb[1] = lb[1] = this.y + this.height;
	
	                v2ApplyTransform(lt, lt, m);
	                v2ApplyTransform(rb, rb, m);
	                v2ApplyTransform(lb, lb, m);
	                v2ApplyTransform(rt, rt, m);
	
	                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
	                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
	                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
	                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
	                this.width = maxX - this.x;
	                this.height = maxY - this.y;
	            };
	        })(),
	
	        /**
	         * Calculate matrix of transforming from self to target rect
	         * @param  {module:zrender/core/BoundingRect} b
	         * @return {Array.<number>}
	         */
	        calculateTransform: function (b) {
	            var a = this;
	            var sx = b.width / a.width;
	            var sy = b.height / a.height;
	
	            var m = matrix.create();
	
	            // 矩阵右乘
	            matrix.translate(m, m, [-a.x, -a.y]);
	            matrix.scale(m, m, [sx, sy]);
	            matrix.translate(m, m, [b.x, b.y]);
	
	            return m;
	        },
	
	        /**
	         * @param {(module:echarts/core/BoundingRect|Object)} b
	         * @return {boolean}
	         */
	        intersect: function (b) {
	            if (!b) {
	                return false;
	            }
	
	            if (!(b instanceof BoundingRect)) {
	                // Normalize negative width/height.
	                b = BoundingRect.create(b);
	            }
	
	            var a = this;
	            var ax0 = a.x;
	            var ax1 = a.x + a.width;
	            var ay0 = a.y;
	            var ay1 = a.y + a.height;
	
	            var bx0 = b.x;
	            var bx1 = b.x + b.width;
	            var by0 = b.y;
	            var by1 = b.y + b.height;
	
	            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
	        },
	
	        contain: function (x, y) {
	            var rect = this;
	            return x >= rect.x
	                && x <= (rect.x + rect.width)
	                && y >= rect.y
	                && y <= (rect.y + rect.height);
	        },
	
	        /**
	         * @return {module:echarts/core/BoundingRect}
	         */
	        clone: function () {
	            return new BoundingRect(this.x, this.y, this.width, this.height);
	        },
	
	        /**
	         * Copy from another rect
	         */
	        copy: function (other) {
	            this.x = other.x;
	            this.y = other.y;
	            this.width = other.width;
	            this.height = other.height;
	        },
	
	        plain: function () {
	            return {
	                x: this.x,
	                y: this.y,
	                width: this.width,
	                height: this.height
	            };
	        }
	    };
	
	    /**
	     * @param {Object|module:zrender/core/BoundingRect} rect
	     * @param {number} rect.x
	     * @param {number} rect.y
	     * @param {number} rect.width
	     * @param {number} rect.height
	     * @return {module:zrender/core/BoundingRect}
	     */
	    BoundingRect.create = function (rect) {
	        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
	    };
	
	    module.exports = BoundingRect;


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
	 * 可以用于 isInsidePath 判断以及获取boundingRect
	 *
	 * @module zrender/core/PathProxy
	 * @author Yi Shen (http://www.github.com/pissang)
	 */
	
	 // TODO getTotalLength, getPointAtLength
	
	
	    var curve = __webpack_require__(27);
	    var vec2 = __webpack_require__(14);
	    var bbox = __webpack_require__(28);
	    var BoundingRect = __webpack_require__(25);
	    var dpr = __webpack_require__(22).devicePixelRatio;
	
	    var CMD = {
	        M: 1,
	        L: 2,
	        C: 3,
	        Q: 4,
	        A: 5,
	        Z: 6,
	        // Rect
	        R: 7
	    };
	
	    var min = [];
	    var max = [];
	    var min2 = [];
	    var max2 = [];
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    var mathCos = Math.cos;
	    var mathSin = Math.sin;
	    var mathSqrt = Math.sqrt;
	    var mathAbs = Math.abs;
	
	    var hasTypedArray = typeof Float32Array != 'undefined';
	
	    /**
	     * @alias module:zrender/core/PathProxy
	     * @constructor
	     */
	    var PathProxy = function () {
	
	        /**
	         * Path data. Stored as flat array
	         * @type {Array.<Object>}
	         */
	        this.data = [];
	
	        this._len = 0;
	
	        this._ctx = null;
	
	        this._xi = 0;
	        this._yi = 0;
	
	        this._x0 = 0;
	        this._y0 = 0;
	
	        // Unit x, Unit y. Provide for avoiding drawing that too short line segment
	        this._ux = 0;
	        this._uy = 0;
	    };
	
	    /**
	     * 快速计算Path包围盒（并不是最小包围盒）
	     * @return {Object}
	     */
	    PathProxy.prototype = {
	
	        constructor: PathProxy,
	
	        _lineDash: null,
	
	        _dashOffset: 0,
	
	        _dashIdx: 0,
	
	        _dashSum: 0,
	
	        /**
	         * @readOnly
	         */
	        setScale: function (sx, sy) {
	            this._ux = mathAbs(1 / dpr / sx) || 0;
	            this._uy = mathAbs(1 / dpr / sy) || 0;
	        },
	
	        getContext: function () {
	            return this._ctx;
	        },
	
	        /**
	         * @param  {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        beginPath: function (ctx) {
	
	            this._ctx = ctx;
	
	            ctx && ctx.beginPath();
	
	            ctx && (this.dpr = ctx.dpr);
	
	            // Reset
	            this._len = 0;
	
	            if (this._lineDash) {
	                this._lineDash = null;
	
	                this._dashOffset = 0;
	            }
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x
	         * @param  {number} y
	         * @return {module:zrender/core/PathProxy}
	         */
	        moveTo: function (x, y) {
	            this.addData(CMD.M, x, y);
	            this._ctx && this._ctx.moveTo(x, y);
	
	            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
	            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
	            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
	            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持
	            this._x0 = x;
	            this._y0 = y;
	
	            this._xi = x;
	            this._yi = y;
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x
	         * @param  {number} y
	         * @return {module:zrender/core/PathProxy}
	         */
	        lineTo: function (x, y) {
	            var exceedUnit = mathAbs(x - this._xi) > this._ux
	                || mathAbs(y - this._yi) > this._uy
	                // Force draw the first segment
	                || this._len < 5;
	
	            this.addData(CMD.L, x, y);
	
	            if (this._ctx && exceedUnit) {
	                this._needsDash() ? this._dashedLineTo(x, y)
	                    : this._ctx.lineTo(x, y);
	            }
	            if (exceedUnit) {
	                this._xi = x;
	                this._yi = y;
	            }
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x1
	         * @param  {number} y1
	         * @param  {number} x2
	         * @param  {number} y2
	         * @param  {number} x3
	         * @param  {number} y3
	         * @return {module:zrender/core/PathProxy}
	         */
	        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
	            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
	            if (this._ctx) {
	                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)
	                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
	            }
	            this._xi = x3;
	            this._yi = y3;
	            return this;
	        },
	
	        /**
	         * @param  {number} x1
	         * @param  {number} y1
	         * @param  {number} x2
	         * @param  {number} y2
	         * @return {module:zrender/core/PathProxy}
	         */
	        quadraticCurveTo: function (x1, y1, x2, y2) {
	            this.addData(CMD.Q, x1, y1, x2, y2);
	            if (this._ctx) {
	                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)
	                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
	            }
	            this._xi = x2;
	            this._yi = y2;
	            return this;
	        },
	
	        /**
	         * @param  {number} cx
	         * @param  {number} cy
	         * @param  {number} r
	         * @param  {number} startAngle
	         * @param  {number} endAngle
	         * @param  {boolean} anticlockwise
	         * @return {module:zrender/core/PathProxy}
	         */
	        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
	            this.addData(
	                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1
	            );
	            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
	
	            this._xi = mathCos(endAngle) * r + cx;
	            this._yi = mathSin(endAngle) * r + cx;
	            return this;
	        },
	
	        // TODO
	        arcTo: function (x1, y1, x2, y2, radius) {
	            if (this._ctx) {
	                this._ctx.arcTo(x1, y1, x2, y2, radius);
	            }
	            return this;
	        },
	
	        // TODO
	        rect: function (x, y, w, h) {
	            this._ctx && this._ctx.rect(x, y, w, h);
	            this.addData(CMD.R, x, y, w, h);
	            return this;
	        },
	
	        /**
	         * @return {module:zrender/core/PathProxy}
	         */
	        closePath: function () {
	            this.addData(CMD.Z);
	
	            var ctx = this._ctx;
	            var x0 = this._x0;
	            var y0 = this._y0;
	            if (ctx) {
	                this._needsDash() && this._dashedLineTo(x0, y0);
	                ctx.closePath();
	            }
	
	            this._xi = x0;
	            this._yi = y0;
	            return this;
	        },
	
	        /**
	         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
	         * stroke 同样
	         * @param {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        fill: function (ctx) {
	            ctx && ctx.fill();
	            this.toStatic();
	        },
	
	        /**
	         * @param {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        stroke: function (ctx) {
	            ctx && ctx.stroke();
	            this.toStatic();
	        },
	
	        /**
	         * 必须在其它绘制命令前调用
	         * Must be invoked before all other path drawing methods
	         * @return {module:zrender/core/PathProxy}
	         */
	        setLineDash: function (lineDash) {
	            if (lineDash instanceof Array) {
	                this._lineDash = lineDash;
	
	                this._dashIdx = 0;
	
	                var lineDashSum = 0;
	                for (var i = 0; i < lineDash.length; i++) {
	                    lineDashSum += lineDash[i];
	                }
	                this._dashSum = lineDashSum;
	            }
	            return this;
	        },
	
	        /**
	         * 必须在其它绘制命令前调用
	         * Must be invoked before all other path drawing methods
	         * @return {module:zrender/core/PathProxy}
	         */
	        setLineDashOffset: function (offset) {
	            this._dashOffset = offset;
	            return this;
	        },
	
	        /**
	         *
	         * @return {boolean}
	         */
	        len: function () {
	            return this._len;
	        },
	
	        /**
	         * 直接设置 Path 数据
	         */
	        setData: function (data) {
	
	            var len = data.length;
	
	            if (! (this.data && this.data.length == len) && hasTypedArray) {
	                this.data = new Float32Array(len);
	            }
	
	            for (var i = 0; i < len; i++) {
	                this.data[i] = data[i];
	            }
	
	            this._len = len;
	        },
	
	        /**
	         * 添加子路径
	         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
	         */
	        appendPath: function (path) {
	            if (!(path instanceof Array)) {
	                path = [path];
	            }
	            var len = path.length;
	            var appendSize = 0;
	            var offset = this._len;
	            for (var i = 0; i < len; i++) {
	                appendSize += path[i].len();
	            }
	            if (hasTypedArray && (this.data instanceof Float32Array)) {
	                this.data = new Float32Array(offset + appendSize);
	            }
	            for (var i = 0; i < len; i++) {
	                var appendPathData = path[i].data;
	                for (var k = 0; k < appendPathData.length; k++) {
	                    this.data[offset++] = appendPathData[k];
	                }
	            }
	            this._len = offset;
	        },
	
	        /**
	         * 填充 Path 数据。
	         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
	         */
	        addData: function (cmd) {
	            var data = this.data;
	            if (this._len + arguments.length > data.length) {
	                // 因为之前的数组已经转换成静态的 Float32Array
	                // 所以不够用时需要扩展一个新的动态数组
	                this._expandData();
	                data = this.data;
	            }
	            for (var i = 0; i < arguments.length; i++) {
	                data[this._len++] = arguments[i];
	            }
	
	            this._prevCmd = cmd;
	        },
	
	        _expandData: function () {
	            // Only if data is Float32Array
	            if (!(this.data instanceof Array)) {
	                var newData = [];
	                for (var i = 0; i < this._len; i++) {
	                    newData[i] = this.data[i];
	                }
	                this.data = newData;
	            }
	        },
	
	        /**
	         * If needs js implemented dashed line
	         * @return {boolean}
	         * @private
	         */
	        _needsDash: function () {
	            return this._lineDash;
	        },
	
	        _dashedLineTo: function (x1, y1) {
	            var dashSum = this._dashSum;
	            var offset = this._dashOffset;
	            var lineDash = this._lineDash;
	            var ctx = this._ctx;
	
	            var x0 = this._xi;
	            var y0 = this._yi;
	            var dx = x1 - x0;
	            var dy = y1 - y0;
	            var dist = mathSqrt(dx * dx + dy * dy);
	            var x = x0;
	            var y = y0;
	            var dash;
	            var nDash = lineDash.length;
	            var idx;
	            dx /= dist;
	            dy /= dist;
	
	            if (offset < 0) {
	                // Convert to positive offset
	                offset = dashSum + offset;
	            }
	            offset %= dashSum;
	            x -= offset * dx;
	            y -= offset * dy;
	
	            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)
	            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {
	                idx = this._dashIdx;
	                dash = lineDash[idx];
	                x += dx * dash;
	                y += dy * dash;
	                this._dashIdx = (idx + 1) % nDash;
	                // Skip positive offset
	                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {
	                    continue;
	                }
	                ctx[idx % 2 ? 'moveTo' : 'lineTo'](
	                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),
	                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)
	                );
	            }
	            // Offset for next lineTo
	            dx = x - x1;
	            dy = y - y1;
	            this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	        },
	
	        // Not accurate dashed line to
	        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
	            var dashSum = this._dashSum;
	            var offset = this._dashOffset;
	            var lineDash = this._lineDash;
	            var ctx = this._ctx;
	
	            var x0 = this._xi;
	            var y0 = this._yi;
	            var t;
	            var dx;
	            var dy;
	            var cubicAt = curve.cubicAt;
	            var bezierLen = 0;
	            var idx = this._dashIdx;
	            var nDash = lineDash.length;
	
	            var x;
	            var y;
	
	            var tmpLen = 0;
	
	            if (offset < 0) {
	                // Convert to positive offset
	                offset = dashSum + offset;
	            }
	            offset %= dashSum;
	            // Bezier approx length
	            for (t = 0; t < 1; t += 0.1) {
	                dx = cubicAt(x0, x1, x2, x3, t + 0.1)
	                    - cubicAt(x0, x1, x2, x3, t);
	                dy = cubicAt(y0, y1, y2, y3, t + 0.1)
	                    - cubicAt(y0, y1, y2, y3, t);
	                bezierLen += mathSqrt(dx * dx + dy * dy);
	            }
	
	            // Find idx after add offset
	            for (; idx < nDash; idx++) {
	                tmpLen += lineDash[idx];
	                if (tmpLen > offset) {
	                    break;
	                }
	            }
	            t = (tmpLen - offset) / bezierLen;
	
	            while (t <= 1) {
	
	                x = cubicAt(x0, x1, x2, x3, t);
	                y = cubicAt(y0, y1, y2, y3, t);
	
	                // Use line to approximate dashed bezier
	                // Bad result if dash is long
	                idx % 2 ? ctx.moveTo(x, y)
	                    : ctx.lineTo(x, y);
	
	                t += lineDash[idx] / bezierLen;
	
	                idx = (idx + 1) % nDash;
	            }
	
	            // Finish the last segment and calculate the new offset
	            (idx % 2 !== 0) && ctx.lineTo(x3, y3);
	            dx = x3 - x;
	            dy = y3 - y;
	            this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	        },
	
	        _dashedQuadraticTo: function (x1, y1, x2, y2) {
	            // Convert quadratic to cubic using degree elevation
	            var x3 = x2;
	            var y3 = y2;
	            x2 = (x2 + 2 * x1) / 3;
	            y2 = (y2 + 2 * y1) / 3;
	            x1 = (this._xi + 2 * x1) / 3;
	            y1 = (this._yi + 2 * y1) / 3;
	
	            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
	        },
	
	        /**
	         * 转成静态的 Float32Array 减少堆内存占用
	         * Convert dynamic array to static Float32Array
	         */
	        toStatic: function () {
	            var data = this.data;
	            if (data instanceof Array) {
	                data.length = this._len;
	                if (hasTypedArray) {
	                    this.data = new Float32Array(data);
	                }
	            }
	        },
	
	        /**
	         * @return {module:zrender/core/BoundingRect}
	         */
	        getBoundingRect: function () {
	            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
	            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
	
	            var data = this.data;
	            var xi = 0;
	            var yi = 0;
	            var x0 = 0;
	            var y0 = 0;
	
	            for (var i = 0; i < data.length;) {
	                var cmd = data[i++];
	
	                if (i == 1) {
	                    // 如果第一个命令是 L, C, Q
	                    // 则 previous point 同绘制命令的第一个 point
	                    //
	                    // 第一个命令为 Arc 的情况下会在后面特殊处理
	                    xi = data[i];
	                    yi = data[i + 1];
	
	                    x0 = xi;
	                    y0 = yi;
	                }
	
	                switch (cmd) {
	                    case CMD.M:
	                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	                        // 在 closePath 的时候使用
	                        x0 = data[i++];
	                        y0 = data[i++];
	                        xi = x0;
	                        yi = y0;
	                        min2[0] = x0;
	                        min2[1] = y0;
	                        max2[0] = x0;
	                        max2[1] = y0;
	                        break;
	                    case CMD.L:
	                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.C:
	                        bbox.fromCubic(
	                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            min2, max2
	                        );
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.Q:
	                        bbox.fromQuadratic(
	                            xi, yi, data[i++], data[i++], data[i], data[i + 1],
	                            min2, max2
	                        );
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.A:
	                        // TODO Arc 判断的开销比较大
	                        var cx = data[i++];
	                        var cy = data[i++];
	                        var rx = data[i++];
	                        var ry = data[i++];
	                        var startAngle = data[i++];
	                        var endAngle = data[i++] + startAngle;
	                        // TODO Arc 旋转
	                        var psi = data[i++];
	                        var anticlockwise = 1 - data[i++];
	
	                        if (i == 1) {
	                            // 直接使用 arc 命令
	                            // 第一个命令起点还未定义
	                            x0 = mathCos(startAngle) * rx + cx;
	                            y0 = mathSin(startAngle) * ry + cy;
	                        }
	
	                        bbox.fromArc(
	                            cx, cy, rx, ry, startAngle, endAngle,
	                            anticlockwise, min2, max2
	                        );
	
	                        xi = mathCos(endAngle) * rx + cx;
	                        yi = mathSin(endAngle) * ry + cy;
	                        break;
	                    case CMD.R:
	                        x0 = xi = data[i++];
	                        y0 = yi = data[i++];
	                        var width = data[i++];
	                        var height = data[i++];
	                        // Use fromLine
	                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
	                        break;
	                    case CMD.Z:
	                        xi = x0;
	                        yi = y0;
	                        break;
	                }
	
	                // Union
	                vec2.min(min, min, min2);
	                vec2.max(max, max, max2);
	            }
	
	            // No data
	            if (i === 0) {
	                min[0] = min[1] = max[0] = max[1] = 0;
	            }
	
	            return new BoundingRect(
	                min[0], min[1], max[0] - min[0], max[1] - min[1]
	            );
	        },
	
	        /**
	         * Rebuild path from current data
	         * Rebuild path will not consider javascript implemented line dash.
	         * @param {CanvasRenderingContext} ctx
	         */
	        rebuildPath: function (ctx) {
	            var d = this.data;
	            var x0, y0;
	            var xi, yi;
	            var x, y;
	            var ux = this._ux;
	            var uy = this._uy;
	            var len = this._len;
	            for (var i = 0; i < len;) {
	                var cmd = d[i++];
	
	                if (i == 1) {
	                    // 如果第一个命令是 L, C, Q
	                    // 则 previous point 同绘制命令的第一个 point
	                    //
	                    // 第一个命令为 Arc 的情况下会在后面特殊处理
	                    xi = d[i];
	                    yi = d[i + 1];
	
	                    x0 = xi;
	                    y0 = yi;
	                }
	                switch (cmd) {
	                    case CMD.M:
	                        x0 = xi = d[i++];
	                        y0 = yi = d[i++];
	                        ctx.moveTo(xi, yi);
	                        break;
	                    case CMD.L:
	                        x = d[i++];
	                        y = d[i++];
	                        // Not draw too small seg between
	                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
	                            ctx.lineTo(x, y);
	                            xi = x;
	                            yi = y;
	                        }
	                        break;
	                    case CMD.C:
	                        ctx.bezierCurveTo(
	                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]
	                        );
	                        xi = d[i - 2];
	                        yi = d[i - 1];
	                        break;
	                    case CMD.Q:
	                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
	                        xi = d[i - 2];
	                        yi = d[i - 1];
	                        break;
	                    case CMD.A:
	                        var cx = d[i++];
	                        var cy = d[i++];
	                        var rx = d[i++];
	                        var ry = d[i++];
	                        var theta = d[i++];
	                        var dTheta = d[i++];
	                        var psi = d[i++];
	                        var fs = d[i++];
	                        var r = (rx > ry) ? rx : ry;
	                        var scaleX = (rx > ry) ? 1 : rx / ry;
	                        var scaleY = (rx > ry) ? ry / rx : 1;
	                        var isEllipse = Math.abs(rx - ry) > 1e-3;
	                        var endAngle = theta + dTheta;
	                        if (isEllipse) {
	                            ctx.translate(cx, cy);
	                            ctx.rotate(psi);
	                            ctx.scale(scaleX, scaleY);
	                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
	                            ctx.scale(1 / scaleX, 1 / scaleY);
	                            ctx.rotate(-psi);
	                            ctx.translate(-cx, -cy);
	                        }
	                        else {
	                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
	                        }
	
	                        if (i == 1) {
	                            // 直接使用 arc 命令
	                            // 第一个命令起点还未定义
	                            x0 = mathCos(theta) * rx + cx;
	                            y0 = mathSin(theta) * ry + cy;
	                        }
	                        xi = mathCos(endAngle) * rx + cx;
	                        yi = mathSin(endAngle) * ry + cy;
	                        break;
	                    case CMD.R:
	                        x0 = xi = d[i];
	                        y0 = yi = d[i + 1];
	                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);
	                        break;
	                    case CMD.Z:
	                        ctx.closePath();
	                        xi = x0;
	                        yi = y0;
	                }
	            }
	        }
	    };
	
	    PathProxy.CMD = CMD;
	
	    module.exports = PathProxy;


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 曲线辅助模块
	 * @module zrender/core/curve
	 * @author pissang(https://www.github.com/pissang)
	 */
	
	
	    var vec2 = __webpack_require__(14);
	    var v2Create = vec2.create;
	    var v2DistSquare = vec2.distSquare;
	    var mathPow = Math.pow;
	    var mathSqrt = Math.sqrt;
	
	    var EPSILON = 1e-8;
	    var EPSILON_NUMERIC = 1e-4;
	
	    var THREE_SQRT = mathSqrt(3);
	    var ONE_THIRD = 1 / 3;
	
	    // 临时变量
	    var _v0 = v2Create();
	    var _v1 = v2Create();
	    var _v2 = v2Create();
	    // var _v3 = vec2.create();
	
	    function isAroundZero(val) {
	        return val > -EPSILON && val < EPSILON;
	    }
	    function isNotAroundZero(val) {
	        return val > EPSILON || val < -EPSILON;
	    }
	    /**
	     * 计算三次贝塞尔值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @return {number}
	     */
	    function cubicAt(p0, p1, p2, p3, t) {
	        var onet = 1 - t;
	        return onet * onet * (onet * p0 + 3 * t * p1)
	             + t * t * (t * p3 + 3 * onet * p2);
	    }
	
	    /**
	     * 计算三次贝塞尔导数值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @return {number}
	     */
	    function cubicDerivativeAt(p0, p1, p2, p3, t) {
	        var onet = 1 - t;
	        return 3 * (
	            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet
	            + (p3 - p2) * t * t
	        );
	    }
	
	    /**
	     * 计算三次贝塞尔方程根，使用盛金公式
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} val
	     * @param  {Array.<number>} roots
	     * @return {number} 有效根数目
	     */
	    function cubicRootAt(p0, p1, p2, p3, val, roots) {
	        // Evaluate roots of cubic functions
	        var a = p3 + 3 * (p1 - p2) - p0;
	        var b = 3 * (p2 - p1 * 2 + p0);
	        var c = 3 * (p1  - p0);
	        var d = p0 - val;
	
	        var A = b * b - 3 * a * c;
	        var B = b * c - 9 * a * d;
	        var C = c * c - 3 * b * d;
	
	        var n = 0;
	
	        if (isAroundZero(A) && isAroundZero(B)) {
	            if (isAroundZero(b)) {
	                roots[0] = 0;
	            }
	            else {
	                var t1 = -c / b;  //t1, t2, t3, b is not zero
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = B * B - 4 * A * C;
	
	            if (isAroundZero(disc)) {
	                var K = B / A;
	                var t1 = -b / a + K;  // t1, a is not zero
	                var t2 = -K / 2;  // t2, t3
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var Y1 = A * b + 1.5 * a * (-B + discSqrt);
	                var Y2 = A * b + 1.5 * a * (-B - discSqrt);
	                if (Y1 < 0) {
	                    Y1 = -mathPow(-Y1, ONE_THIRD);
	                }
	                else {
	                    Y1 = mathPow(Y1, ONE_THIRD);
	                }
	                if (Y2 < 0) {
	                    Y2 = -mathPow(-Y2, ONE_THIRD);
	                }
	                else {
	                    Y2 = mathPow(Y2, ONE_THIRD);
	                }
	                var t1 = (-b - (Y1 + Y2)) / (3 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	            else {
	                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
	                var theta = Math.acos(T) / 3;
	                var ASqrt = mathSqrt(A);
	                var tmp = Math.cos(theta);
	
	                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
	                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
	                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	                if (t3 >= 0 && t3 <= 1) {
	                    roots[n++] = t3;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 计算三次贝塞尔方程极限值的位置
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {Array.<number>} extrema
	     * @return {number} 有效数目
	     */
	    function cubicExtrema(p0, p1, p2, p3, extrema) {
	        var b = 6 * p2 - 12 * p1 + 6 * p0;
	        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
	        var c = 3 * p1 - 3 * p0;
	
	        var n = 0;
	        if (isAroundZero(a)) {
	            if (isNotAroundZero(b)) {
	                var t1 = -c / b;
	                if (t1 >= 0 && t1 <=1) {
	                    extrema[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = b * b - 4 * a * c;
	            if (isAroundZero(disc)) {
	                extrema[0] = -b / (2 * a);
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var t1 = (-b + discSqrt) / (2 * a);
	                var t2 = (-b - discSqrt) / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    extrema[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    extrema[n++] = t2;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 细分三次贝塞尔曲线
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @param  {Array.<number>} out
	     */
	    function cubicSubdivide(p0, p1, p2, p3, t, out) {
	        var p01 = (p1 - p0) * t + p0;
	        var p12 = (p2 - p1) * t + p1;
	        var p23 = (p3 - p2) * t + p2;
	
	        var p012 = (p12 - p01) * t + p01;
	        var p123 = (p23 - p12) * t + p12;
	
	        var p0123 = (p123 - p012) * t + p012;
	        // Seg0
	        out[0] = p0;
	        out[1] = p01;
	        out[2] = p012;
	        out[3] = p0123;
	        // Seg1
	        out[4] = p0123;
	        out[5] = p123;
	        out[6] = p23;
	        out[7] = p3;
	    }
	
	    /**
	     * 投射点到三次贝塞尔曲线上，返回投射距离。
	     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x3
	     * @param {number} y3
	     * @param {number} x
	     * @param {number} y
	     * @param {Array.<number>} [out] 投射点
	     * @return {number}
	     */
	    function cubicProjectPoint(
	        x0, y0, x1, y1, x2, y2, x3, y3,
	        x, y, out
	    ) {
	        // http://pomax.github.io/bezierinfo/#projections
	        var t;
	        var interval = 0.005;
	        var d = Infinity;
	        var prev;
	        var next;
	        var d1;
	        var d2;
	
	        _v0[0] = x;
	        _v0[1] = y;
	
	        // 先粗略估计一下可能的最小距离的 t 值
	        // PENDING
	        for (var _t = 0; _t < 1; _t += 0.05) {
	            _v1[0] = cubicAt(x0, x1, x2, x3, _t);
	            _v1[1] = cubicAt(y0, y1, y2, y3, _t);
	            d1 = v2DistSquare(_v0, _v1);
	            if (d1 < d) {
	                t = _t;
	                d = d1;
	            }
	        }
	        d = Infinity;
	
	        // At most 32 iteration
	        for (var i = 0; i < 32; i++) {
	            if (interval < EPSILON_NUMERIC) {
	                break;
	            }
	            prev = t - interval;
	            next = t + interval;
	            // t - interval
	            _v1[0] = cubicAt(x0, x1, x2, x3, prev);
	            _v1[1] = cubicAt(y0, y1, y2, y3, prev);
	
	            d1 = v2DistSquare(_v1, _v0);
	
	            if (prev >= 0 && d1 < d) {
	                t = prev;
	                d = d1;
	            }
	            else {
	                // t + interval
	                _v2[0] = cubicAt(x0, x1, x2, x3, next);
	                _v2[1] = cubicAt(y0, y1, y2, y3, next);
	                d2 = v2DistSquare(_v2, _v0);
	
	                if (next <= 1 && d2 < d) {
	                    t = next;
	                    d = d2;
	                }
	                else {
	                    interval *= 0.5;
	                }
	            }
	        }
	        // t
	        if (out) {
	            out[0] = cubicAt(x0, x1, x2, x3, t);
	            out[1] = cubicAt(y0, y1, y2, y3, t);
	        }
	        // console.log(interval, i);
	        return mathSqrt(d);
	    }
	
	    /**
	     * 计算二次方贝塞尔值
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @return {number}
	     */
	    function quadraticAt(p0, p1, p2, t) {
	        var onet = 1 - t;
	        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
	    }
	
	    /**
	     * 计算二次方贝塞尔导数值
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @return {number}
	     */
	    function quadraticDerivativeAt(p0, p1, p2, t) {
	        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
	    }
	
	    /**
	     * 计算二次方贝塞尔方程根
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @param  {Array.<number>} roots
	     * @return {number} 有效根数目
	     */
	    function quadraticRootAt(p0, p1, p2, val, roots) {
	        var a = p0 - 2 * p1 + p2;
	        var b = 2 * (p1 - p0);
	        var c = p0 - val;
	
	        var n = 0;
	        if (isAroundZero(a)) {
	            if (isNotAroundZero(b)) {
	                var t1 = -c / b;
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = b * b - 4 * a * c;
	            if (isAroundZero(disc)) {
	                var t1 = -b / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var t1 = (-b + discSqrt) / (2 * a);
	                var t2 = (-b - discSqrt) / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 计算二次贝塞尔方程极限值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @return {number}
	     */
	    function quadraticExtremum(p0, p1, p2) {
	        var divider = p0 + p2 - 2 * p1;
	        if (divider === 0) {
	            // p1 is center of p0 and p2
	            return 0.5;
	        }
	        else {
	            return (p0 - p1) / divider;
	        }
	    }
	
	    /**
	     * 细分二次贝塞尔曲线
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @param  {Array.<number>} out
	     */
	    function quadraticSubdivide(p0, p1, p2, t, out) {
	        var p01 = (p1 - p0) * t + p0;
	        var p12 = (p2 - p1) * t + p1;
	        var p012 = (p12 - p01) * t + p01;
	
	        // Seg0
	        out[0] = p0;
	        out[1] = p01;
	        out[2] = p012;
	
	        // Seg1
	        out[3] = p012;
	        out[4] = p12;
	        out[5] = p2;
	    }
	
	    /**
	     * 投射点到二次贝塞尔曲线上，返回投射距离。
	     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x
	     * @param {number} y
	     * @param {Array.<number>} out 投射点
	     * @return {number}
	     */
	    function quadraticProjectPoint(
	        x0, y0, x1, y1, x2, y2,
	        x, y, out
	    ) {
	        // http://pomax.github.io/bezierinfo/#projections
	        var t;
	        var interval = 0.005;
	        var d = Infinity;
	
	        _v0[0] = x;
	        _v0[1] = y;
	
	        // 先粗略估计一下可能的最小距离的 t 值
	        // PENDING
	        for (var _t = 0; _t < 1; _t += 0.05) {
	            _v1[0] = quadraticAt(x0, x1, x2, _t);
	            _v1[1] = quadraticAt(y0, y1, y2, _t);
	            var d1 = v2DistSquare(_v0, _v1);
	            if (d1 < d) {
	                t = _t;
	                d = d1;
	            }
	        }
	        d = Infinity;
	
	        // At most 32 iteration
	        for (var i = 0; i < 32; i++) {
	            if (interval < EPSILON_NUMERIC) {
	                break;
	            }
	            var prev = t - interval;
	            var next = t + interval;
	            // t - interval
	            _v1[0] = quadraticAt(x0, x1, x2, prev);
	            _v1[1] = quadraticAt(y0, y1, y2, prev);
	
	            var d1 = v2DistSquare(_v1, _v0);
	
	            if (prev >= 0 && d1 < d) {
	                t = prev;
	                d = d1;
	            }
	            else {
	                // t + interval
	                _v2[0] = quadraticAt(x0, x1, x2, next);
	                _v2[1] = quadraticAt(y0, y1, y2, next);
	                var d2 = v2DistSquare(_v2, _v0);
	                if (next <= 1 && d2 < d) {
	                    t = next;
	                    d = d2;
	                }
	                else {
	                    interval *= 0.5;
	                }
	            }
	        }
	        // t
	        if (out) {
	            out[0] = quadraticAt(x0, x1, x2, t);
	            out[1] = quadraticAt(y0, y1, y2, t);
	        }
	        // console.log(interval, i);
	        return mathSqrt(d);
	    }
	
	    module.exports = {
	
	        cubicAt: cubicAt,
	
	        cubicDerivativeAt: cubicDerivativeAt,
	
	        cubicRootAt: cubicRootAt,
	
	        cubicExtrema: cubicExtrema,
	
	        cubicSubdivide: cubicSubdivide,
	
	        cubicProjectPoint: cubicProjectPoint,
	
	        quadraticAt: quadraticAt,
	
	        quadraticDerivativeAt: quadraticDerivativeAt,
	
	        quadraticRootAt: quadraticRootAt,
	
	        quadraticExtremum: quadraticExtremum,
	
	        quadraticSubdivide: quadraticSubdivide,
	
	        quadraticProjectPoint: quadraticProjectPoint
	    };


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @author Yi Shen(https://github.com/pissang)
	 */
	
	
	    var vec2 = __webpack_require__(14);
	    var curve = __webpack_require__(27);
	
	    var bbox = {};
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    var mathSin = Math.sin;
	    var mathCos = Math.cos;
	
	    var start = vec2.create();
	    var end = vec2.create();
	    var extremity = vec2.create();
	
	    var PI2 = Math.PI * 2;
	    /**
	     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
	     * @module zrender/core/bbox
	     * @param {Array<Object>} points 顶点数组
	     * @param {number} min
	     * @param {number} max
	     */
	    bbox.fromPoints = function(points, min, max) {
	        if (points.length === 0) {
	            return;
	        }
	        var p = points[0];
	        var left = p[0];
	        var right = p[0];
	        var top = p[1];
	        var bottom = p[1];
	        var i;
	
	        for (i = 1; i < points.length; i++) {
	            p = points[i];
	            left = mathMin(left, p[0]);
	            right = mathMax(right, p[0]);
	            top = mathMin(top, p[1]);
	            bottom = mathMax(bottom, p[1]);
	        }
	
	        min[0] = left;
	        min[1] = top;
	        max[0] = right;
	        max[1] = bottom;
	    };
	
	    /**
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromLine = function (x0, y0, x1, y1, min, max) {
	        min[0] = mathMin(x0, x1);
	        min[1] = mathMin(y0, y1);
	        max[0] = mathMax(x0, x1);
	        max[1] = mathMax(y0, y1);
	    };
	
	    var xDim = [];
	    var yDim = [];
	    /**
	     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x3
	     * @param {number} y3
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromCubic = function(
	        x0, y0, x1, y1, x2, y2, x3, y3, min, max
	    ) {
	        var cubicExtrema = curve.cubicExtrema;
	        var cubicAt = curve.cubicAt;
	        var i;
	        var n = cubicExtrema(x0, x1, x2, x3, xDim);
	        min[0] = Infinity;
	        min[1] = Infinity;
	        max[0] = -Infinity;
	        max[1] = -Infinity;
	
	        for (i = 0; i < n; i++) {
	            var x = cubicAt(x0, x1, x2, x3, xDim[i]);
	            min[0] = mathMin(x, min[0]);
	            max[0] = mathMax(x, max[0]);
	        }
	        n = cubicExtrema(y0, y1, y2, y3, yDim);
	        for (i = 0; i < n; i++) {
	            var y = cubicAt(y0, y1, y2, y3, yDim[i]);
	            min[1] = mathMin(y, min[1]);
	            max[1] = mathMax(y, max[1]);
	        }
	
	        min[0] = mathMin(x0, min[0]);
	        max[0] = mathMax(x0, max[0]);
	        min[0] = mathMin(x3, min[0]);
	        max[0] = mathMax(x3, max[0]);
	
	        min[1] = mathMin(y0, min[1]);
	        max[1] = mathMax(y0, max[1]);
	        min[1] = mathMin(y3, min[1]);
	        max[1] = mathMax(y3, max[1]);
	    };
	
	    /**
	     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {
	        var quadraticExtremum = curve.quadraticExtremum;
	        var quadraticAt = curve.quadraticAt;
	        // Find extremities, where derivative in x dim or y dim is zero
	        var tx =
	            mathMax(
	                mathMin(quadraticExtremum(x0, x1, x2), 1), 0
	            );
	        var ty =
	            mathMax(
	                mathMin(quadraticExtremum(y0, y1, y2), 1), 0
	            );
	
	        var x = quadraticAt(x0, x1, x2, tx);
	        var y = quadraticAt(y0, y1, y2, ty);
	
	        min[0] = mathMin(x0, x2, x);
	        min[1] = mathMin(y0, y2, y);
	        max[0] = mathMax(x0, x2, x);
	        max[1] = mathMax(y0, y2, y);
	    };
	
	    /**
	     * 从圆弧中计算出最小包围盒，写入`min`和`max`中
	     * @method
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x
	     * @param {number} y
	     * @param {number} rx
	     * @param {number} ry
	     * @param {number} startAngle
	     * @param {number} endAngle
	     * @param {number} anticlockwise
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromArc = function (
	        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max
	    ) {
	        var vec2Min = vec2.min;
	        var vec2Max = vec2.max;
	
	        var diff = Math.abs(startAngle - endAngle);
	
	
	        if (diff % PI2 < 1e-4 && diff > 1e-4) {
	            // Is a circle
	            min[0] = x - rx;
	            min[1] = y - ry;
	            max[0] = x + rx;
	            max[1] = y + ry;
	            return;
	        }
	
	        start[0] = mathCos(startAngle) * rx + x;
	        start[1] = mathSin(startAngle) * ry + y;
	
	        end[0] = mathCos(endAngle) * rx + x;
	        end[1] = mathSin(endAngle) * ry + y;
	
	        vec2Min(min, start, end);
	        vec2Max(max, start, end);
	
	        // Thresh to [0, Math.PI * 2]
	        startAngle = startAngle % (PI2);
	        if (startAngle < 0) {
	            startAngle = startAngle + PI2;
	        }
	        endAngle = endAngle % (PI2);
	        if (endAngle < 0) {
	            endAngle = endAngle + PI2;
	        }
	
	        if (startAngle > endAngle && !anticlockwise) {
	            endAngle += PI2;
	        }
	        else if (startAngle < endAngle && anticlockwise) {
	            startAngle += PI2;
	        }
	        if (anticlockwise) {
	            var tmp = endAngle;
	            endAngle = startAngle;
	            startAngle = tmp;
	        }
	
	        // var number = 0;
	        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
	        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
	            if (angle > startAngle) {
	                extremity[0] = mathCos(angle) * rx + x;
	                extremity[1] = mathSin(angle) * ry + y;
	
	                vec2Min(min, extremity, min);
	                vec2Max(max, extremity, max);
	            }
	        }
	    };
	
	    module.exports = bbox;
	


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var CMD = __webpack_require__(26).CMD;
	    var line = __webpack_require__(30);
	    var cubic = __webpack_require__(31);
	    var quadratic = __webpack_require__(32);
	    var arc = __webpack_require__(33);
	    var normalizeRadian = __webpack_require__(34).normalizeRadian;
	    var curve = __webpack_require__(27);
	
	    var windingLine = __webpack_require__(35);
	
	    var containStroke = line.containStroke;
	
	    var PI2 = Math.PI * 2;
	
	    var EPSILON = 1e-4;
	
	    function isAroundEqual(a, b) {
	        return Math.abs(a - b) < EPSILON;
	    }
	
	    // 临时数组
	    var roots = [-1, -1, -1];
	    var extrema = [-1, -1];
	
	    function swapExtrema() {
	        var tmp = extrema[0];
	        extrema[0] = extrema[1];
	        extrema[1] = tmp;
	    }
	
	    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
	        // Quick reject
	        if (
	            (y > y0 && y > y1 && y > y2 && y > y3)
	            || (y < y0 && y < y1 && y < y2 && y < y3)
	        ) {
	            return 0;
	        }
	        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
	        if (nRoots === 0) {
	            return 0;
	        }
	        else {
	            var w = 0;
	            var nExtrema = -1;
	            var y0_, y1_;
	            for (var i = 0; i < nRoots; i++) {
	                var t = roots[i];
	
	                // Avoid winding error when intersection point is the connect point of two line of polygon
	                var unit = (t === 0 || t === 1) ? 0.5 : 1;
	
	                var x_ = curve.cubicAt(x0, x1, x2, x3, t);
	                if (x_ < x) { // Quick reject
	                    continue;
	                }
	                if (nExtrema < 0) {
	                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
	                    if (extrema[1] < extrema[0] && nExtrema > 1) {
	                        swapExtrema();
	                    }
	                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
	                    if (nExtrema > 1) {
	                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
	                    }
	                }
	                if (nExtrema == 2) {
	                    // 分成三段单调函数
	                    if (t < extrema[0]) {
	                        w += y0_ < y0 ? unit : -unit;
	                    }
	                    else if (t < extrema[1]) {
	                        w += y1_ < y0_ ? unit : -unit;
	                    }
	                    else {
	                        w += y3 < y1_ ? unit : -unit;
	                    }
	                }
	                else {
	                    // 分成两段单调函数
	                    if (t < extrema[0]) {
	                        w += y0_ < y0 ? unit : -unit;
	                    }
	                    else {
	                        w += y3 < y0_ ? unit : -unit;
	                    }
	                }
	            }
	            return w;
	        }
	    }
	
	    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
	        // Quick reject
	        if (
	            (y > y0 && y > y1 && y > y2)
	            || (y < y0 && y < y1 && y < y2)
	        ) {
	            return 0;
	        }
	        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
	        if (nRoots === 0) {
	            return 0;
	        }
	        else {
	            var t = curve.quadraticExtremum(y0, y1, y2);
	            if (t >= 0 && t <= 1) {
	                var w = 0;
	                var y_ = curve.quadraticAt(y0, y1, y2, t);
	                for (var i = 0; i < nRoots; i++) {
	                    // Remove one endpoint.
	                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;
	
	                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
	                    if (x_ < x) {   // Quick reject
	                        continue;
	                    }
	                    if (roots[i] < t) {
	                        w += y_ < y0 ? unit : -unit;
	                    }
	                    else {
	                        w += y2 < y_ ? unit : -unit;
	                    }
	                }
	                return w;
	            }
	            else {
	                // Remove one endpoint.
	                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;
	
	                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
	                if (x_ < x) {   // Quick reject
	                    return 0;
	                }
	                return y2 < y0 ? unit : -unit;
	            }
	        }
	    }
	
	    // TODO
	    // Arc 旋转
	    function windingArc(
	        cx, cy, r, startAngle, endAngle, anticlockwise, x, y
	    ) {
	        y -= cy;
	        if (y > r || y < -r) {
	            return 0;
	        }
	        var tmp = Math.sqrt(r * r - y * y);
	        roots[0] = -tmp;
	        roots[1] = tmp;
	
	        var diff = Math.abs(startAngle - endAngle);
	        if (diff < 1e-4) {
	            return 0;
	        }
	        if (diff % PI2 < 1e-4) {
	            // Is a circle
	            startAngle = 0;
	            endAngle = PI2;
	            var dir = anticlockwise ? 1 : -1;
	            if (x >= roots[0] + cx && x <= roots[1] + cx) {
	                return dir;
	            } else {
	                return 0;
	            }
	        }
	
	        if (anticlockwise) {
	            var tmp = startAngle;
	            startAngle = normalizeRadian(endAngle);
	            endAngle = normalizeRadian(tmp);
	        }
	        else {
	            startAngle = normalizeRadian(startAngle);
	            endAngle = normalizeRadian(endAngle);
	        }
	        if (startAngle > endAngle) {
	            endAngle += PI2;
	        }
	
	        var w = 0;
	        for (var i = 0; i < 2; i++) {
	            var x_ = roots[i];
	            if (x_ + cx > x) {
	                var angle = Math.atan2(y, x_);
	                var dir = anticlockwise ? 1 : -1;
	                if (angle < 0) {
	                    angle = PI2 + angle;
	                }
	                if (
	                    (angle >= startAngle && angle <= endAngle)
	                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)
	                ) {
	                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
	                        dir = -dir;
	                    }
	                    w += dir;
	                }
	            }
	        }
	        return w;
	    }
	
	    function containPath(data, lineWidth, isStroke, x, y) {
	        var w = 0;
	        var xi = 0;
	        var yi = 0;
	        var x0 = 0;
	        var y0 = 0;
	
	        for (var i = 0; i < data.length;) {
	            var cmd = data[i++];
	            // Begin a new subpath
	            if (cmd === CMD.M && i > 1) {
	                // Close previous subpath
	                if (!isStroke) {
	                    w += windingLine(xi, yi, x0, y0, x, y);
	                }
	                // 如果被任何一个 subpath 包含
	                // if (w !== 0) {
	                //     return true;
	                // }
	            }
	
	            if (i == 1) {
	                // 如果第一个命令是 L, C, Q
	                // 则 previous point 同绘制命令的第一个 point
	                //
	                // 第一个命令为 Arc 的情况下会在后面特殊处理
	                xi = data[i];
	                yi = data[i + 1];
	
	                x0 = xi;
	                y0 = yi;
	            }
	
	            switch (cmd) {
	                case CMD.M:
	                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	                    // 在 closePath 的时候使用
	                    x0 = data[i++];
	                    y0 = data[i++];
	                    xi = x0;
	                    yi = y0;
	                    break;
	                case CMD.L:
	                    if (isStroke) {
	                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
	                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.C:
	                    if (isStroke) {
	                        if (cubic.containStroke(xi, yi,
	                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingCubic(
	                            xi, yi,
	                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            x, y
	                        ) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.Q:
	                    if (isStroke) {
	                        if (quadratic.containStroke(xi, yi,
	                            data[i++], data[i++], data[i], data[i + 1],
	                            lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingQuadratic(
	                            xi, yi,
	                            data[i++], data[i++], data[i], data[i + 1],
	                            x, y
	                        ) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.A:
	                    // TODO Arc 判断的开销比较大
	                    var cx = data[i++];
	                    var cy = data[i++];
	                    var rx = data[i++];
	                    var ry = data[i++];
	                    var theta = data[i++];
	                    var dTheta = data[i++];
	                    // TODO Arc 旋转
	                    var psi = data[i++];
	                    var anticlockwise = 1 - data[i++];
	                    var x1 = Math.cos(theta) * rx + cx;
	                    var y1 = Math.sin(theta) * ry + cy;
	                    // 不是直接使用 arc 命令
	                    if (i > 1) {
	                        w += windingLine(xi, yi, x1, y1, x, y);
	                    }
	                    else {
	                        // 第一个命令起点还未定义
	                        x0 = x1;
	                        y0 = y1;
	                    }
	                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
	                    var _x = (x - cx) * ry / rx + cx;
	                    if (isStroke) {
	                        if (arc.containStroke(
	                            cx, cy, ry, theta, theta + dTheta, anticlockwise,
	                            lineWidth, _x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingArc(
	                            cx, cy, ry, theta, theta + dTheta, anticlockwise,
	                            _x, y
	                        );
	                    }
	                    xi = Math.cos(theta + dTheta) * rx + cx;
	                    yi = Math.sin(theta + dTheta) * ry + cy;
	                    break;
	                case CMD.R:
	                    x0 = xi = data[i++];
	                    y0 = yi = data[i++];
	                    var width = data[i++];
	                    var height = data[i++];
	                    var x1 = x0 + width;
	                    var y1 = y0 + height;
	                    if (isStroke) {
	                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)
	                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)
	                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)
	                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)
	                        ) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // FIXME Clockwise ?
	                        w += windingLine(x1, y0, x1, y1, x, y);
	                        w += windingLine(x0, y1, x0, y0, x, y);
	                    }
	                    break;
	                case CMD.Z:
	                    if (isStroke) {
	                        if (containStroke(
	                            xi, yi, x0, y0, lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // Close a subpath
	                        w += windingLine(xi, yi, x0, y0, x, y);
	                        // 如果被任何一个 subpath 包含
	                        // FIXME subpaths may overlap
	                        // if (w !== 0) {
	                        //     return true;
	                        // }
	                    }
	                    xi = x0;
	                    yi = y0;
	                    break;
	            }
	        }
	        if (!isStroke && !isAroundEqual(yi, y0)) {
	            w += windingLine(xi, yi, x0, y0, x, y) || 0;
	        }
	        return w !== 0;
	    }
	
	    module.exports = {
	        contain: function (pathData, x, y) {
	            return containPath(pathData, 0, false, x, y);
	        },
	
	        containStroke: function (pathData, lineWidth, x, y) {
	            return containPath(pathData, lineWidth, true, x, y);
	        }
	    };


/***/ },
/* 30 */
/***/ function(module, exports) {

	
	    module.exports = {
	        /**
	         * 线段包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            var _a = 0;
	            var _b = x0;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l)
	                || (y < y0 - _l && y < y1 - _l)
	                || (x > x0 + _l && x > x1 + _l)
	                || (x < x0 - _l && x < x1 - _l)
	            ) {
	                return false;
	            }
	
	            if (x0 !== x1) {
	                _a = (y0 - y1) / (x0 - x1);
	                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;
	            }
	            else {
	                return Math.abs(x - x0) <= _l / 2;
	            }
	            var tmp = _a * x - y + _b;
	            var _s = tmp * tmp / (_a * _a + 1);
	            return _s <= _l / 2 * _l / 2;
	        }
	    };


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var curve = __webpack_require__(27);
	
	    module.exports = {
	        /**
	         * 三次贝塞尔曲线描边包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  x2
	         * @param  {number}  y2
	         * @param  {number}  x3
	         * @param  {number}  y3
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)
	                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)
	                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)
	                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)
	            ) {
	                return false;
	            }
	            var d = curve.cubicProjectPoint(
	                x0, y0, x1, y1, x2, y2, x3, y3,
	                x, y, null
	            );
	            return d <= _l / 2;
	        }
	    };


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var curve = __webpack_require__(27);
	
	    module.exports = {
	        /**
	         * 二次贝塞尔曲线描边包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  x2
	         * @param  {number}  y2
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l && y > y2 + _l)
	                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)
	                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)
	                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)
	            ) {
	                return false;
	            }
	            var d = curve.quadraticProjectPoint(
	                x0, y0, x1, y1, x2, y2,
	                x, y, null
	            );
	            return d <= _l / 2;
	        }
	    };


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var normalizeRadian = __webpack_require__(34).normalizeRadian;
	    var PI2 = Math.PI * 2;
	
	    module.exports = {
	        /**
	         * 圆弧描边包含判断
	         * @param  {number}  cx
	         * @param  {number}  cy
	         * @param  {number}  r
	         * @param  {number}  startAngle
	         * @param  {number}  endAngle
	         * @param  {boolean}  anticlockwise
	         * @param  {number} lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {Boolean}
	         */
	        containStroke: function (
	            cx, cy, r, startAngle, endAngle, anticlockwise,
	            lineWidth, x, y
	        ) {
	
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	
	            x -= cx;
	            y -= cy;
	            var d = Math.sqrt(x * x + y * y);
	
	            if ((d - _l > r) || (d + _l < r)) {
	                return false;
	            }
	            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
	                // Is a circle
	                return true;
	            }
	            if (anticlockwise) {
	                var tmp = startAngle;
	                startAngle = normalizeRadian(endAngle);
	                endAngle = normalizeRadian(tmp);
	            } else {
	                startAngle = normalizeRadian(startAngle);
	                endAngle = normalizeRadian(endAngle);
	            }
	            if (startAngle > endAngle) {
	                endAngle += PI2;
	            }
	
	            var angle = Math.atan2(y, x);
	            if (angle < 0) {
	                angle += PI2;
	            }
	            return (angle >= startAngle && angle <= endAngle)
	                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);
	        }
	    };


/***/ },
/* 34 */
/***/ function(module, exports) {

	
	
	    var PI2 = Math.PI * 2;
	    module.exports = {
	        normalizeRadian: function(angle) {
	            angle %= PI2;
	            if (angle < 0) {
	                angle += PI2;
	            }
	            return angle;
	        }
	    };


/***/ },
/* 35 */
/***/ function(module, exports) {

	
	    module.exports = function windingLine(x0, y0, x1, y1, x, y) {
	        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
	            return 0;
	        }
	        // Ignore horizontal line
	        if (y1 === y0) {
	            return 0;
	        }
	        var dir = y1 < y0 ? 1 : -1;
	        var t = (y - y0) / (y1 - y0);
	
	        // Avoid winding error when intersection point is the connect point of two line of polygon
	        if (t === 1 || t === 0) {
	            dir = y1 < y0 ? 0.5 : -0.5;
	        }
	
	        var x_ = t * (x1 - x0) + x0;
	
	        return x_ > x ? dir : 0;
	    };


/***/ },
/* 36 */
/***/ function(module, exports) {

	
	
	    var Pattern = function (image, repeat) {
	        this.image = image;
	        this.repeat = repeat;
	
	        // Can be cloned
	        this.type = 'pattern';
	    };
	
	    Pattern.prototype.getCanvasPattern = function (ctx) {
	
	        return this._canvasPattern
	            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));
	    };
	
	    module.exports = Pattern;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var CMD = __webpack_require__(26).CMD;
	    var vec2 = __webpack_require__(14);
	    var v2ApplyTransform = vec2.applyTransform;
	
	    var points = [[], [], []];
	    var mathSqrt = Math.sqrt;
	    var mathAtan2 = Math.atan2;
	    function transformPath(path, m) {
	        var data = path.data;
	        var cmd;
	        var nPoint;
	        var i;
	        var j;
	        var k;
	        var p;
	
	        var M = CMD.M;
	        var C = CMD.C;
	        var L = CMD.L;
	        var R = CMD.R;
	        var A = CMD.A;
	        var Q = CMD.Q;
	
	        for (i = 0, j = 0; i < data.length;) {
	            cmd = data[i++];
	            j = i;
	            nPoint = 0;
	
	            switch (cmd) {
	                case M:
	                    nPoint = 1;
	                    break;
	                case L:
	                    nPoint = 1;
	                    break;
	                case C:
	                    nPoint = 3;
	                    break;
	                case Q:
	                    nPoint = 2;
	                    break;
	                case A:
	                    var x = m[4];
	                    var y = m[5];
	                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
	                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
	                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);
	                    // cx
	                    data[i++] += x;
	                    // cy
	                    data[i++] += y;
	                    // Scale rx and ry
	                    // FIXME Assume psi is 0 here
	                    data[i++] *= sx;
	                    data[i++] *= sy;
	
	                    // Start angle
	                    data[i++] += angle;
	                    // end angle
	                    data[i++] += angle;
	                    // FIXME psi
	                    i += 2;
	                    j = i;
	                    break;
	                case R:
	                    // x0, y0
	                    p[0] = data[i++];
	                    p[1] = data[i++];
	                    v2ApplyTransform(p, p, m);
	                    data[j++] = p[0];
	                    data[j++] = p[1];
	                    // x1, y1
	                    p[0] += data[i++];
	                    p[1] += data[i++];
	                    v2ApplyTransform(p, p, m);
	                    data[j++] = p[0];
	                    data[j++] = p[1];
	            }
	
	            for (k = 0; k < nPoint; k++) {
	                var p = points[k];
	                p[0] = data[i++];
	                p[1] = data[i++];
	
	                v2ApplyTransform(p, p, m);
	                // Write back
	                data[j++] = p[0];
	                data[j++] = p[1];
	            }
	        }
	    }
	
	    module.exports = transformPath;


/***/ },
/* 38 */
/***/ function(module, exports) {

	
	
	    /**
	     * @param {Array.<Object>} colorStops
	     */
	    var Gradient = function (colorStops) {
	
	        this.colorStops = colorStops || [];
	    };
	
	    Gradient.prototype = {
	
	        constructor: Gradient,
	
	        addColorStop: function (offset, color) {
	            this.colorStops.push({
	
	                offset: offset,
	
	                color: color
	            });
	        }
	    };
	
	    module.exports = Gradient;


/***/ },
/* 39 */
/***/ function(module, exports) {

	// TODO Draggable for group
	// FIXME Draggable on element which has parent rotation or scale
	
	    function Draggable() {
	
	        this.on('mousedown', this._dragStart, this);
	        this.on('mousemove', this._drag, this);
	        this.on('mouseup', this._dragEnd, this);
	        this.on('globalout', this._dragEnd, this);
	        // this._dropTarget = null;
	        // this._draggingTarget = null;
	
	        // this._x = 0;
	        // this._y = 0;
	    }
	
	    Draggable.prototype = {
	
	        constructor: Draggable,
	
	        _dragStart: function (e) {
	            var draggingTarget = e.target;
	            if (draggingTarget && draggingTarget.draggable) {
	                this._draggingTarget = draggingTarget;
	                draggingTarget.dragging = true;
	                this._x = e.offsetX;
	                this._y = e.offsetY;
	
	                this.dispatchToElement(draggingTarget, 'dragstart', e.event);
	            }
	        },
	
	        _drag: function (e) {
	            var draggingTarget = this._draggingTarget;
	            if (draggingTarget) {
	
	                var x = e.offsetX;
	                var y = e.offsetY;
	
	                var dx = x - this._x;
	                var dy = y - this._y;
	                this._x = x;
	                this._y = y;
	
	                draggingTarget.drift(dx, dy, e);
	                this.dispatchToElement(draggingTarget, 'drag', e.event);
	
	                var dropTarget = this.findHover(x, y, draggingTarget);
	                var lastDropTarget = this._dropTarget;
	                this._dropTarget = dropTarget;
	
	                if (draggingTarget !== dropTarget) {
	                    if (lastDropTarget && dropTarget !== lastDropTarget) {
	                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);
	                    }
	                    if (dropTarget && dropTarget !== lastDropTarget) {
	                        this.dispatchToElement(dropTarget, 'dragenter', e.event);
	                    }
	                }
	            }
	        },
	
	        _dragEnd: function (e) {
	            var draggingTarget = this._draggingTarget;
	
	            if (draggingTarget) {
	                draggingTarget.dragging = false;
	            }
	
	            this.dispatchToElement(draggingTarget, 'dragend', e.event);
	
	            if (this._dropTarget) {
	                this.dispatchToElement(this._dropTarget, 'drop', e.event);
	            }
	
	            this._draggingTarget = null;
	            this._dropTarget = null;
	        }
	
	    };
	
	    module.exports = Draggable;


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
	 * @module zrender/graphic/Group
	 * @example
	 *     var Group = require('zrender/lib/container/Group');
	 *     var Circle = require('zrender/lib/graphic/shape/Circle');
	 *     var g = new Group();
	 *     g.position[0] = 100;
	 *     g.position[1] = 100;
	 *     g.add(new Circle({
	 *         style: {
	 *             x: 100,
	 *             y: 100,
	 *             r: 20,
	 *         }
	 *     }));
	 *     zr.add(g);
	 */
	
	
	    var zrUtil = __webpack_require__(4);
	    var Element = __webpack_require__(9);
	    var BoundingRect = __webpack_require__(25);
	
	    /**
	     * @alias module:zrender/graphic/Group
	     * @constructor
	     * @extends module:zrender/mixin/Transformable
	     * @extends module:zrender/mixin/Eventful
	     */
	    var Group = function (opts) {
	
	        opts = opts || {};
	
	        Element.call(this, opts);
	
	        for (var key in opts) {
	            if (opts.hasOwnProperty(key)) {
	                this[key] = opts[key];
	            }
	        }
	
	        this._children = [];
	
	        this.__storage = null;
	
	        this.__dirty = true;
	    };
	
	    Group.prototype = {
	
	        constructor: Group,
	
	        isGroup: true,
	
	        /**
	         * @type {string}
	         */
	        type: 'group',
	
	        /**
	         * 所有子孙元素是否响应鼠标事件
	         * @name module:/zrender/container/Group#silent
	         * @type {boolean}
	         * @default false
	         */
	        silent: false,
	
	        /**
	         * @return {Array.<module:zrender/Element>}
	         */
	        children: function () {
	            return this._children.slice();
	        },
	
	        /**
	         * 获取指定 index 的儿子节点
	         * @param  {number} idx
	         * @return {module:zrender/Element}
	         */
	        childAt: function (idx) {
	            return this._children[idx];
	        },
	
	        /**
	         * 获取指定名字的儿子节点
	         * @param  {string} name
	         * @return {module:zrender/Element}
	         */
	        childOfName: function (name) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                if (children[i].name === name) {
	                    return children[i];
	                }
	             }
	        },
	
	        /**
	         * @return {number}
	         */
	        childCount: function () {
	            return this._children.length;
	        },
	
	        /**
	         * 添加子节点到最后
	         * @param {module:zrender/Element} child
	         */
	        add: function (child) {
	            if (child && child !== this && child.parent !== this) {
	
	                this._children.push(child);
	
	                this._doAdd(child);
	            }
	
	            return this;
	        },
	
	        /**
	         * 添加子节点在 nextSibling 之前
	         * @param {module:zrender/Element} child
	         * @param {module:zrender/Element} nextSibling
	         */
	        addBefore: function (child, nextSibling) {
	            if (child && child !== this && child.parent !== this
	                && nextSibling && nextSibling.parent === this) {
	
	                var children = this._children;
	                var idx = children.indexOf(nextSibling);
	
	                if (idx >= 0) {
	                    children.splice(idx, 0, child);
	                    this._doAdd(child);
	                }
	            }
	
	            return this;
	        },
	
	        _doAdd: function (child) {
	            if (child.parent) {
	                child.parent.remove(child);
	            }
	
	            child.parent = this;
	
	            var storage = this.__storage;
	            var zr = this.__zr;
	            if (storage && storage !== child.__storage) {
	
	                storage.addToMap(child);
	
	                if (child instanceof Group) {
	                    child.addChildrenToStorage(storage);
	                }
	            }
	
	            zr && zr.refresh();
	        },
	
	        /**
	         * 移除子节点
	         * @param {module:zrender/Element} child
	         */
	        remove: function (child) {
	            var zr = this.__zr;
	            var storage = this.__storage;
	            var children = this._children;
	
	            var idx = zrUtil.indexOf(children, child);
	            if (idx < 0) {
	                return this;
	            }
	            children.splice(idx, 1);
	
	            child.parent = null;
	
	            if (storage) {
	
	                storage.delFromMap(child.id);
	
	                if (child instanceof Group) {
	                    child.delChildrenFromStorage(storage);
	                }
	            }
	
	            zr && zr.refresh();
	
	            return this;
	        },
	
	        /**
	         * 移除所有子节点
	         */
	        removeAll: function () {
	            var children = this._children;
	            var storage = this.__storage;
	            var child;
	            var i;
	            for (i = 0; i < children.length; i++) {
	                child = children[i];
	                if (storage) {
	                    storage.delFromMap(child.id);
	                    if (child instanceof Group) {
	                        child.delChildrenFromStorage(storage);
	                    }
	                }
	                child.parent = null;
	            }
	            children.length = 0;
	
	            return this;
	        },
	
	        /**
	         * 遍历所有子节点
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        eachChild: function (cb, context) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                cb.call(context, child, i);
	            }
	            return this;
	        },
	
	        /**
	         * 深度优先遍历所有子孙节点
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                cb.call(context, child);
	
	                if (child.type === 'group') {
	                    child.traverse(cb, context);
	                }
	            }
	            return this;
	        },
	
	        addChildrenToStorage: function (storage) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                storage.addToMap(child);
	                if (child instanceof Group) {
	                    child.addChildrenToStorage(storage);
	                }
	            }
	        },
	
	        delChildrenFromStorage: function (storage) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                storage.delFromMap(child.id);
	                if (child instanceof Group) {
	                    child.delChildrenFromStorage(storage);
	                }
	            }
	        },
	
	        dirty: function () {
	            this.__dirty = true;
	            this.__zr && this.__zr.refresh();
	            return this;
	        },
	
	        /**
	         * @return {module:zrender/core/BoundingRect}
	         */
	        getBoundingRect: function (includeChildren) {
	            // TODO Caching
	            var rect = null;
	            var tmpRect = new BoundingRect(0, 0, 0, 0);
	            var children = includeChildren || this._children;
	            var tmpMat = [];
	
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                if (child.ignore || child.invisible) {
	                    continue;
	                }
	
	                var childRect = child.getBoundingRect();
	                var transform = child.getLocalTransform(tmpMat);
	                // TODO
	                // The boundingRect cacluated by transforming original
	                // rect may be bigger than the actual bundingRect when rotation
	                // is used. (Consider a circle rotated aginst its center, where
	                // the actual boundingRect should be the same as that not be
	                // rotated.) But we can not find better approach to calculate
	                // actual boundingRect yet, considering performance.
	                if (transform) {
	                    tmpRect.copy(childRect);
	                    tmpRect.applyTransform(transform);
	                    rect = rect || tmpRect.clone();
	                    rect.union(tmpRect);
	                }
	                else {
	                    rect = rect || childRect.clone();
	                    rect.union(childRect);
	                }
	            }
	            return rect || tmpRect;
	        }
	    };
	
	    zrUtil.inherits(Group, Element);
	
	    module.exports = Group;


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Image element
	 * @module zrender/graphic/Image
	 */
	
	
	
	    var Displayable = __webpack_require__(7);
	    var BoundingRect = __webpack_require__(25);
	    var zrUtil = __webpack_require__(4);
	
	    var LRU = __webpack_require__(20);
	    var globalImageCache = new LRU(50);
	    /**
	     * @alias zrender/graphic/Image
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    function ZImage(opts) {
	        Displayable.call(this, opts);
	    }
	
	    ZImage.prototype = {
	
	        constructor: ZImage,
	
	        type: 'image',
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var src = style.image;
	            var image;
	
	            // Must bind each time
	            style.bind(ctx, this, prevEl);
	            // style.image is a url string
	            if (typeof src === 'string') {
	                image = this._image;
	            }
	            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas
	            else {
	                image = src;
	            }
	            // FIXME Case create many images with src
	            if (!image && src) {
	                // Try get from global image cache
	                var cachedImgObj = globalImageCache.get(src);
	                if (!cachedImgObj) {
	                    // Create a new image
	                    image = new Image();
	                    image.onload = function () {
	                        image.onload = null;
	                        for (var i = 0; i < cachedImgObj.pending.length; i++) {
	                            cachedImgObj.pending[i].dirty();
	                        }
	                    };
	                    cachedImgObj = {
	                        image: image,
	                        pending: [this]
	                    };
	                    image.src = src;
	                    globalImageCache.put(src, cachedImgObj);
	                    this._image = image;
	                    return;
	                }
	                else {
	                    image = cachedImgObj.image;
	                    this._image = image;
	                    // Image is not complete finish, add to pending list
	                    if (!image.width || !image.height) {
	                        cachedImgObj.pending.push(this);
	                        return;
	                    }
	                }
	            }
	
	            if (image) {
	                // 图片已经加载完成
	                // if (image.nodeName.toUpperCase() == 'IMG') {
	                //     if (!image.complete) {
	                //         return;
	                //     }
	                // }
	                // Else is canvas
	
	                var x = style.x || 0;
	                var y = style.y || 0;
	                // 图片加载失败
	                if (!image.width || !image.height) {
	                    return;
	                }
	                var width = style.width;
	                var height = style.height;
	                var aspect = image.width / image.height;
	                if (width == null && height != null) {
	                    // Keep image/height ratio
	                    width = height * aspect;
	                }
	                else if (height == null && width != null) {
	                    height = width / aspect;
	                }
	                else if (width == null && height == null) {
	                    width = image.width;
	                    height = image.height;
	                }
	
	                // 设置transform
	                this.setTransform(ctx);
	
	                if (style.sWidth && style.sHeight) {
	                    var sx = style.sx || 0;
	                    var sy = style.sy || 0;
	                    ctx.drawImage(
	                        image,
	                        sx, sy, style.sWidth, style.sHeight,
	                        x, y, width, height
	                    );
	                }
	                else if (style.sx && style.sy) {
	                    var sx = style.sx;
	                    var sy = style.sy;
	                    var sWidth = width - sx;
	                    var sHeight = height - sy;
	                    ctx.drawImage(
	                        image,
	                        sx, sy, sWidth, sHeight,
	                        x, y, width, height
	                    );
	                }
	                else {
	                    ctx.drawImage(image, x, y, width, height);
	                }
	
	                this.restoreTransform(ctx);
	
	                // Draw rect text
	                if (style.text != null) {
	                    this.drawRectText(ctx, this.getBoundingRect());
	                }
	
	            }
	        },
	
	        getBoundingRect: function () {
	            var style = this.style;
	            if (! this._rect) {
	                this._rect = new BoundingRect(
	                    style.x || 0, style.y || 0, style.width || 0, style.height || 0
	                );
	            }
	            return this._rect;
	        }
	    };
	
	    zrUtil.inherits(ZImage, Displayable);
	
	    module.exports = ZImage;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Text element
	 * @module zrender/graphic/Text
	 *
	 * TODO Wrapping
	 *
	 * Text not support gradient
	 */
	
	
	
	    var Displayable = __webpack_require__(7);
	    var zrUtil = __webpack_require__(4);
	    var textContain = __webpack_require__(24);
	
	    /**
	     * @alias zrender/graphic/Text
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    var Text = function (opts) {
	        Displayable.call(this, opts);
	    };
	
	    Text.prototype = {
	
	        constructor: Text,
	
	        type: 'text',
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var x = style.x || 0;
	            var y = style.y || 0;
	            // Convert to string
	            var text = style.text;
	
	            // Convert to string
	            text != null && (text += '');
	
	            // Always bind style
	            style.bind(ctx, this, prevEl);
	
	            if (text) {
	
	                this.setTransform(ctx);
	
	                var textBaseline;
	                var textAlign = style.textAlign;
	                var font = style.textFont || style.font;
	                if (style.textVerticalAlign) {
	                    var rect = textContain.getBoundingRect(
	                        text, font, style.textAlign, 'top'
	                    );
	                    // Ignore textBaseline
	                    textBaseline = 'middle';
	                    switch (style.textVerticalAlign) {
	                        case 'middle':
	                            y -= rect.height / 2 - rect.lineHeight / 2;
	                            break;
	                        case 'bottom':
	                            y -= rect.height - rect.lineHeight / 2;
	                            break;
	                        default:
	                            y += rect.lineHeight / 2;
	                    }
	                }
	                else {
	                    textBaseline = style.textBaseline;
	                }
	
	                // TODO Invalid font
	                ctx.font = font || '12px sans-serif';
	                ctx.textAlign = textAlign || 'left';
	                // Use canvas default left textAlign. Giving invalid value will cause state not change
	                if (ctx.textAlign !== textAlign) {
	                    ctx.textAlign = 'left';
	                }
	                // FIXME in text contain default is top
	                ctx.textBaseline = textBaseline || 'alphabetic';
	                // Use canvas default alphabetic baseline
	                if (ctx.textBaseline !== textBaseline) {
	                    ctx.textBaseline = 'alphabetic';
	                }
	
	                var lineHeight = textContain.measureText('国', ctx.font).width;
	
	                var textLines = text.split('\n');
	                for (var i = 0; i < textLines.length; i++) {
	                    // Fill after stroke so the outline will not cover the main part.
	                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);
	                    style.hasFill() && ctx.fillText(textLines[i], x, y);
	                    y += lineHeight;
	                }
	
	                this.restoreTransform(ctx);
	            }
	        },
	
	        getBoundingRect: function () {
	            var style = this.style;
	            if (!this._rect) {
	                var textVerticalAlign = style.textVerticalAlign;
	                var rect = textContain.getBoundingRect(
	                    style.text + '', style.textFont || style.font, style.textAlign,
	                    textVerticalAlign ? 'top' : style.textBaseline
	                );
	                switch (textVerticalAlign) {
	                    case 'middle':
	                        rect.y -= rect.height / 2;
	                        break;
	                    case 'bottom':
	                        rect.y -= rect.height;
	                        break;
	                }
	                rect.x += style.x || 0;
	                rect.y += style.y || 0;
	                if (style.hasStroke()) {
	                    var w = style.lineWidth;
	                    rect.x -= w / 2;
	                    rect.y -= w / 2;
	                    rect.width += w;
	                    rect.height += w;
	                }
	                this._rect = rect;
	            }
	
	            return this._rect;
	        }
	    };
	
	    zrUtil.inherits(Text, Displayable);
	
	    module.exports = Text;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 圆形
	 * @module zrender/shape/Circle
	 */
	
	
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'circle',
	
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0
	        },
	
	
	        buildPath : function (ctx, shape, inBundle) {
	            // Better stroking in ShapeBundle
	            // Always do it may have performence issue ( fill may be 2x more cost)
	            if (inBundle) {
	                ctx.moveTo(shape.cx + shape.r, shape.cy);
	            }
	            // Better stroking in ShapeBundle
	            // ctx.moveTo(shape.cx + shape.r, shape.cy);
	            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
	        }
	    });
	


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 扇形
	 * @module zrender/graphic/shape/Sector
	 */
	
	
	
	    var env = __webpack_require__(45);
	    var Path = __webpack_require__(6);
	
	    var shadowTemp = [
	        ['shadowBlur', 0],
	        ['shadowColor', '#000'],
	        ['shadowOffsetX', 0],
	        ['shadowOffsetY', 0]
	    ];
	
	    module.exports = Path.extend({
	
	        type: 'sector',
	
	        shape: {
	
	            cx: 0,
	
	            cy: 0,
	
	            r0: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'
	            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),
	            // where exception "unexpected call to method or property access"
	            // might be thrown when calling ctx.fill after a path whose area size
	            // is zero is drawn and ctx.clip() is called and shadowBlur is set.
	            // (e.g.,
	            //  ctx.moveTo(10, 10);
	            //  ctx.lineTo(20, 10);
	            //  ctx.closePath();
	            //  ctx.clip();
	            //  ctx.shadowBlur = 10;
	            //  ...
	            //  ctx.fill();
	            // )
	            ? function () {
	                var clipPaths = this.__clipPaths;
	                var style = this.style;
	                var modified;
	
	                if (clipPaths) {
	                    for (var i = 0; i < clipPaths.length; i++) {
	                        var shape = clipPaths[i] && clipPaths[i].shape;
	                        if (shape && shape.startAngle === shape.endAngle) {
	                            for (var j = 0; j < shadowTemp.length; j++) {
	                                shadowTemp[j][2] = style[shadowTemp[j][0]];
	                                style[shadowTemp[j][0]] = shadowTemp[j][1];
	                            }
	                            modified = true;
	                            break;
	                        }
	                    }
	                }
	
	                Path.prototype.brush.apply(this, arguments);
	
	                if (modified) {
	                    for (var j = 0; j < shadowTemp.length; j++) {
	                        style[shadowTemp[j][0]] = shadowTemp[j][2];
	                    }
	                }
	            }
	            : Path.prototype.brush,
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r0 = Math.max(shape.r0 || 0, 0);
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
	
	            ctx.lineTo(unitX * r + x, unitY * r + y);
	
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	
	            ctx.lineTo(
	                Math.cos(endAngle) * r0 + x,
	                Math.sin(endAngle) * r0 + y
	            );
	
	            if (r0 !== 0) {
	                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
	            }
	
	            ctx.closePath();
	        }
	    });
	


/***/ },
/* 45 */
/***/ function(module, exports) {

	/**
	 * echarts设备环境识别
	 *
	 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
	 * @author firede[firede@firede.us]
	 * @desc thanks zepto.
	 */
	
	    var env = {};
	    if (typeof navigator === 'undefined') {
	        // In node
	        env = {
	            browser: {},
	            os: {},
	            node: true,
	            // Assume canvas is supported
	            canvasSupported: true
	        };
	    }
	    else {
	        env = detect(navigator.userAgent);
	    }
	
	    module.exports = env;
	
	    // Zepto.js
	    // (c) 2010-2013 Thomas Fuchs
	    // Zepto.js may be freely distributed under the MIT license.
	
	    function detect(ua) {
	        var os = {};
	        var browser = {};
	        // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
	        // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
	        // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	        // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	        // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
	        // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
	        // var touchpad = webos && ua.match(/TouchPad/);
	        // var kindle = ua.match(/Kindle\/([\d.]+)/);
	        // var silk = ua.match(/Silk\/([\d._]+)/);
	        // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
	        // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
	        // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
	        // var playbook = ua.match(/PlayBook/);
	        // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
	        var firefox = ua.match(/Firefox\/([\d.]+)/);
	        // var safari = webkit && ua.match(/Mobile\//) && !chrome;
	        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
	        var ie = ua.match(/MSIE\s([\d.]+)/)
	            // IE 11 Trident/7.0; rv:11.0
	            || ua.match(/Trident\/.+?rv:(([\d.]+))/);
	        var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+
	
	        var weChat = (/micromessenger/i).test(ua);
	
	        // Todo: clean this up with a better OS/browser seperation:
	        // - discern (more) between multiple browsers on android
	        // - decide if kindle fire in silk mode is android or not
	        // - Firefox on Android doesn't specify the Android version
	        // - possibly devide in os, device and browser hashes
	
	        // if (browser.webkit = !!webkit) browser.version = webkit[1];
	
	        // if (android) os.android = true, os.version = android[2];
	        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
	        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
	        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
	        // if (webos) os.webos = true, os.version = webos[2];
	        // if (touchpad) os.touchpad = true;
	        // if (blackberry) os.blackberry = true, os.version = blackberry[2];
	        // if (bb10) os.bb10 = true, os.version = bb10[2];
	        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
	        // if (playbook) browser.playbook = true;
	        // if (kindle) os.kindle = true, os.version = kindle[1];
	        // if (silk) browser.silk = true, browser.version = silk[1];
	        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
	        // if (chrome) browser.chrome = true, browser.version = chrome[1];
	        if (firefox) {
	            browser.firefox = true;
	            browser.version = firefox[1];
	        }
	        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
	        // if (webview) browser.webview = true;
	
	        if (ie) {
	            browser.ie = true;
	            browser.version = ie[1];
	        }
	
	        if (edge) {
	            browser.edge = true;
	            browser.version = edge[1];
	        }
	
	        // It is difficult to detect WeChat in Win Phone precisely, because ua can
	        // not be set on win phone. So we do not consider Win Phone.
	        if (weChat) {
	            browser.weChat = true;
	        }
	
	        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
	        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
	        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
	        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
	        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));
	
	        return {
	            browser: browser,
	            os: os,
	            node: false,
	            // 原生canvas支持，改极端点了
	            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
	            canvasSupported : document.createElement('canvas').getContext ? true : false,
	            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
	            // works on most browsers
	            // IE10/11 does not support touch event, and MS Edge supports them but not by
	            // default, so we dont check navigator.maxTouchPoints for them here.
	            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
	            // <http://caniuse.com/#search=pointer%20event>.
	            pointerEventsSupported: 'onpointerdown' in window
	                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer
	                // events currently. So we dont use that on other browsers unless tested sufficiently.
	                // Although IE 10 supports pointer event, it use old style and is different from the
	                // standard. So we exclude that. (IE 10 is hardly used on touch device)
	                && (browser.edge || (browser.ie && browser.version >= 11))
	        };
	    }


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 圆环
	 * @module zrender/graphic/shape/Ring
	 */
	
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'ring',
	
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0,
	            r0: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.cx;
	            var y = shape.cy;
	            var PI2 = Math.PI * 2;
	            ctx.moveTo(x + shape.r, y);
	            ctx.arc(x, y, shape.r, 0, PI2, false);
	            ctx.moveTo(x + shape.r0, y);
	            ctx.arc(x, y, shape.r0, 0, PI2, true);
	        }
	    });
	


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 多边形
	 * @module zrender/shape/Polygon
	 */
	
	
	    var polyHelper = __webpack_require__(48);
	
	    module.exports = __webpack_require__(6).extend({
	        
	        type: 'polygon',
	
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, true);
	        }
	    });


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var smoothSpline = __webpack_require__(49);
	    var smoothBezier = __webpack_require__(50);
	
	    module.exports = {
	        buildPath: function (ctx, shape, closePath) {
	            var points = shape.points;
	            var smooth = shape.smooth;
	            if (points && points.length >= 2) {
	                if (smooth && smooth !== 'spline') {
	                    var controlPoints = smoothBezier(
	                        points, smooth, closePath, shape.smoothConstraint
	                    );
	
	                    ctx.moveTo(points[0][0], points[0][1]);
	                    var len = points.length;
	                    for (var i = 0; i < (closePath ? len : len - 1); i++) {
	                        var cp1 = controlPoints[i * 2];
	                        var cp2 = controlPoints[i * 2 + 1];
	                        var p = points[(i + 1) % len];
	                        ctx.bezierCurveTo(
	                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
	                        );
	                    }
	                }
	                else {
	                    if (smooth === 'spline') {
	                        points = smoothSpline(points, closePath);
	                    }
	
	                    ctx.moveTo(points[0][0], points[0][1]);
	                    for (var i = 1, l = points.length; i < l; i++) {
	                        ctx.lineTo(points[i][0], points[i][1]);
	                    }
	                }
	
	                closePath && ctx.closePath();
	            }
	        }
	    };


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Catmull-Rom spline 插值折线
	 * @module zrender/shape/util/smoothSpline
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	    var vec2 = __webpack_require__(14);
	
	    /**
	     * @inner
	     */
	    function interpolate(p0, p1, p2, p3, t, t2, t3) {
	        var v0 = (p2 - p0) * 0.5;
	        var v1 = (p3 - p1) * 0.5;
	        return (2 * (p1 - p2) + v0 + v1) * t3
	                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
	                + v0 * t + p1;
	    }
	
	    /**
	     * @alias module:zrender/shape/util/smoothSpline
	     * @param {Array} points 线段顶点数组
	     * @param {boolean} isLoop
	     * @return {Array}
	     */
	    module.exports = function (points, isLoop) {
	        var len = points.length;
	        var ret = [];
	
	        var distance = 0;
	        for (var i = 1; i < len; i++) {
	            distance += vec2.distance(points[i - 1], points[i]);
	        }
	
	        var segs = distance / 2;
	        segs = segs < len ? len : segs;
	        for (var i = 0; i < segs; i++) {
	            var pos = i / (segs - 1) * (isLoop ? len : len - 1);
	            var idx = Math.floor(pos);
	
	            var w = pos - idx;
	
	            var p0;
	            var p1 = points[idx % len];
	            var p2;
	            var p3;
	            if (!isLoop) {
	                p0 = points[idx === 0 ? idx : idx - 1];
	                p2 = points[idx > len - 2 ? len - 1 : idx + 1];
	                p3 = points[idx > len - 3 ? len - 1 : idx + 2];
	            }
	            else {
	                p0 = points[(idx - 1 + len) % len];
	                p2 = points[(idx + 1) % len];
	                p3 = points[(idx + 2) % len];
	            }
	
	            var w2 = w * w;
	            var w3 = w * w2;
	
	            ret.push([
	                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),
	                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)
	            ]);
	        }
	        return ret;
	    };
	


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 贝塞尔平滑曲线
	 * @module zrender/shape/util/smoothBezier
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	
	    var vec2 = __webpack_require__(14);
	    var v2Min = vec2.min;
	    var v2Max = vec2.max;
	    var v2Scale = vec2.scale;
	    var v2Distance = vec2.distance;
	    var v2Add = vec2.add;
	
	    /**
	     * 贝塞尔平滑曲线
	     * @alias module:zrender/shape/util/smoothBezier
	     * @param {Array} points 线段顶点数组
	     * @param {number} smooth 平滑等级, 0-1
	     * @param {boolean} isLoop
	     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
	     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
	     *                           整个折线的包围盒做一个并集用来约束控制点。
	     * @param {Array} 计算出来的控制点数组
	     */
	    module.exports = function (points, smooth, isLoop, constraint) {
	        var cps = [];
	
	        var v = [];
	        var v1 = [];
	        var v2 = [];
	        var prevPoint;
	        var nextPoint;
	
	        var min, max;
	        if (constraint) {
	            min = [Infinity, Infinity];
	            max = [-Infinity, -Infinity];
	            for (var i = 0, len = points.length; i < len; i++) {
	                v2Min(min, min, points[i]);
	                v2Max(max, max, points[i]);
	            }
	            // 与指定的包围盒做并集
	            v2Min(min, min, constraint[0]);
	            v2Max(max, max, constraint[1]);
	        }
	
	        for (var i = 0, len = points.length; i < len; i++) {
	            var point = points[i];
	
	            if (isLoop) {
	                prevPoint = points[i ? i - 1 : len - 1];
	                nextPoint = points[(i + 1) % len];
	            }
	            else {
	                if (i === 0 || i === len - 1) {
	                    cps.push(vec2.clone(points[i]));
	                    continue;
	                }
	                else {
	                    prevPoint = points[i - 1];
	                    nextPoint = points[i + 1];
	                }
	            }
	
	            vec2.sub(v, nextPoint, prevPoint);
	
	            // use degree to scale the handle length
	            v2Scale(v, v, smooth);
	
	            var d0 = v2Distance(point, prevPoint);
	            var d1 = v2Distance(point, nextPoint);
	            var sum = d0 + d1;
	            if (sum !== 0) {
	                d0 /= sum;
	                d1 /= sum;
	            }
	
	            v2Scale(v1, v, -d0);
	            v2Scale(v2, v, d1);
	            var cp0 = v2Add([], point, v1);
	            var cp1 = v2Add([], point, v2);
	            if (constraint) {
	                v2Max(cp0, cp0, min);
	                v2Min(cp0, cp0, max);
	                v2Max(cp1, cp1, min);
	                v2Min(cp1, cp1, max);
	            }
	            cps.push(cp0);
	            cps.push(cp1);
	        }
	
	        if (isLoop) {
	            cps.push(cps.shift());
	        }
	
	        return cps;
	    };
	


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module zrender/graphic/shape/Polyline
	 */
	
	
	    var polyHelper = __webpack_require__(48);
	
	    module.exports = __webpack_require__(6).extend({
	        
	        type: 'polyline',
	
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        style: {
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, false);
	        }
	    });


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 矩形
	 * @module zrender/graphic/shape/Rect
	 */
	
	
	    var roundRectHelper = __webpack_require__(53);
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'rect',
	
	        shape: {
	            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
	            // r缩写为1         相当于 [1, 1, 1, 1]
	            // r缩写为[1]       相当于 [1, 1, 1, 1]
	            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
	            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
	            r: 0,
	
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var width = shape.width;
	            var height = shape.height;
	            if (!shape.r) {
	                ctx.rect(x, y, width, height);
	            }
	            else {
	                roundRectHelper.buildPath(ctx, shape);
	            }
	            ctx.closePath();
	            return;
	        }
	    });
	


/***/ },
/* 53 */
/***/ function(module, exports) {

	
	
	    module.exports = {
	        buildPath: function (ctx, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var width = shape.width;
	            var height = shape.height;
	            var r = shape.r;
	            var r1;
	            var r2;
	            var r3;
	            var r4;
	
	            // Convert width and height to positive for better borderRadius
	            if (width < 0) {
	                x = x + width;
	                width = -width;
	            }
	            if (height < 0) {
	                y = y + height;
	                height = -height;
	            }
	
	            if (typeof r === 'number') {
	                r1 = r2 = r3 = r4 = r;
	            }
	            else if (r instanceof Array) {
	                if (r.length === 1) {
	                    r1 = r2 = r3 = r4 = r[0];
	                }
	                else if (r.length === 2) {
	                    r1 = r3 = r[0];
	                    r2 = r4 = r[1];
	                }
	                else if (r.length === 3) {
	                    r1 = r[0];
	                    r2 = r4 = r[1];
	                    r3 = r[2];
	                }
	                else {
	                    r1 = r[0];
	                    r2 = r[1];
	                    r3 = r[2];
	                    r4 = r[3];
	                }
	            }
	            else {
	                r1 = r2 = r3 = r4 = 0;
	            }
	
	            var total;
	            if (r1 + r2 > width) {
	                total = r1 + r2;
	                r1 *= width / total;
	                r2 *= width / total;
	            }
	            if (r3 + r4 > width) {
	                total = r3 + r4;
	                r3 *= width / total;
	                r4 *= width / total;
	            }
	            if (r2 + r3 > height) {
	                total = r2 + r3;
	                r2 *= height / total;
	                r3 *= height / total;
	            }
	            if (r1 + r4 > height) {
	                total = r1 + r4;
	                r1 *= height / total;
	                r4 *= height / total;
	            }
	            ctx.moveTo(x + r1, y);
	            ctx.lineTo(x + width - r2, y);
	            r2 !== 0 && ctx.quadraticCurveTo(
	                x + width, y, x + width, y + r2
	            );
	            ctx.lineTo(x + width, y + height - r3);
	            r3 !== 0 && ctx.quadraticCurveTo(
	                x + width, y + height, x + width - r3, y + height
	            );
	            ctx.lineTo(x + r4, y + height);
	            r4 !== 0 && ctx.quadraticCurveTo(
	                x, y + height, x, y + height - r4
	            );
	            ctx.lineTo(x, y + r1);
	            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
	        }
	    };


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 直线
	 * @module zrender/graphic/shape/Line
	 */
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'line',
	
	        shape: {
	            // Start point
	            x1: 0,
	            y1: 0,
	            // End point
	            x2: 0,
	            y2: 0,
	
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var percent = shape.percent;
	
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (percent < 1) {
	                x2 = x1 * (1 - percent) + x2 * percent;
	                y2 = y1 * (1 - percent) + y2 * percent;
	            }
	            ctx.lineTo(x2, y2);
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} percent
	         * @return {Array.<number>}
	         */
	        pointAt: function (p) {
	            var shape = this.shape;
	            return [
	                shape.x1 * (1 - p) + shape.x2 * p,
	                shape.y1 * (1 - p) + shape.y2 * p
	            ];
	        }
	    });
	


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 贝塞尔曲线
	 * @module zrender/shape/BezierCurve
	 */
	
	
	    var curveTool = __webpack_require__(27);
	    var vec2 = __webpack_require__(14);
	    var quadraticSubdivide = curveTool.quadraticSubdivide;
	    var cubicSubdivide = curveTool.cubicSubdivide;
	    var quadraticAt = curveTool.quadraticAt;
	    var cubicAt = curveTool.cubicAt;
	    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;
	    var cubicDerivativeAt = curveTool.cubicDerivativeAt;
	
	    var out = [];
	
	    function someVectorAt(shape, t, isTangent) {
	        var cpx2 = shape.cpx2;
	        var cpy2 = shape.cpy2;
	        if (cpx2 === null || cpy2 === null) {
	            return [
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
	            ];
	        }
	        else {
	            return [
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
	            ];
	        }
	    }
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'bezier-curve',
	
	        shape: {
	            x1: 0,
	            y1: 0,
	            x2: 0,
	            y2: 0,
	            cpx1: 0,
	            cpy1: 0,
	            // cpx2: 0,
	            // cpy2: 0
	
	            // Curve show percent, for animating
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var cpx1 = shape.cpx1;
	            var cpy1 = shape.cpy1;
	            var cpx2 = shape.cpx2;
	            var cpy2 = shape.cpy2;
	            var percent = shape.percent;
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (cpx2 == null || cpy2 == null) {
	                if (percent < 1) {
	                    quadraticSubdivide(
	                        x1, cpx1, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    x2 = out[2];
	                    quadraticSubdivide(
	                        y1, cpy1, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    y2 = out[2];
	                }
	
	                ctx.quadraticCurveTo(
	                    cpx1, cpy1,
	                    x2, y2
	                );
	            }
	            else {
	                if (percent < 1) {
	                    cubicSubdivide(
	                        x1, cpx1, cpx2, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    cpx2 = out[2];
	                    x2 = out[3];
	                    cubicSubdivide(
	                        y1, cpy1, cpy2, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    cpy2 = out[2];
	                    y2 = out[3];
	                }
	                ctx.bezierCurveTo(
	                    cpx1, cpy1,
	                    cpx2, cpy2,
	                    x2, y2
	                );
	            }
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        pointAt: function (t) {
	            return someVectorAt(this.shape, t, false);
	        },
	
	        /**
	         * Get tangent at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        tangentAt: function (t) {
	            var p = someVectorAt(this.shape, t, true);
	            return vec2.normalize(p, p);
	        }
	    });
	


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 圆弧
	 * @module zrender/graphic/shape/Arc
	 */
	 
	
	    module.exports = __webpack_require__(6).extend({
	
	        type: 'arc',
	
	        shape: {
	
	            cx: 0,
	
	            cy: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        style: {
	
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r + x, unitY * r + y);
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	        }
	    });


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var Gradient = __webpack_require__(38);
	
	    /**
	     * x, y, x2, y2 are all percent from 0 to 1
	     * @param {number} [x=0]
	     * @param {number} [y=0]
	     * @param {number} [x2=1]
	     * @param {number} [y2=0]
	     * @param {Array.<Object>} colorStops
	     * @param {boolean} [globalCoord=false]
	     */
	    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
	        this.x = x == null ? 0 : x;
	
	        this.y = y == null ? 0 : y;
	
	        this.x2 = x2 == null ? 1 : x2;
	
	        this.y2 = y2 == null ? 0 : y2;
	
	        // Can be cloned
	        this.type = 'linear';
	
	        // If use global coord
	        this.global = globalCoord || false;
	
	        Gradient.call(this, colorStops);
	    };
	
	    LinearGradient.prototype = {
	
	        constructor: LinearGradient
	    };
	
	    zrUtil.inherits(LinearGradient, Gradient);
	
	    module.exports = LinearGradient;


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var Gradient = __webpack_require__(38);
	
	    /**
	     * x, y, r are all percent from 0 to 1
	     * @param {number} [x=0.5]
	     * @param {number} [y=0.5]
	     * @param {number} [r=0.5]
	     * @param {Array.<Object>} [colorStops]
	     * @param {boolean} [globalCoord=false]
	     */
	    var RadialGradient = function (x, y, r, colorStops, globalCoord) {
	        this.x = x == null ? 0.5 : x;
	
	        this.y = y == null ? 0.5 : y;
	
	        this.r = r == null ? 0.5 : r;
	
	        // Can be cloned
	        this.type = 'radial';
	
	        // If use global coord
	        this.global = globalCoord || false;
	
	        Gradient.call(this, colorStops);
	    };
	
	    RadialGradient.prototype = {
	
	        constructor: RadialGradient
	    };
	
	    zrUtil.inherits(RadialGradient, Gradient);
	
	    module.exports = RadialGradient;


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(4);
	
	    var apiList = [
	        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',
	        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'
	    ];
	
	    function ExtensionAPI(instance) {
	        zrUtil.each(apiList, function (name) {
	            this[name] = zrUtil.bind(instance[name], instance);
	        }, this);
	    }
	
	    module.exports = ExtensionAPI;
	


/***/ },
/* 60 */
/***/ function(module, exports) {

	
	
	    /**
	      * Creates an instance of Point
	      *
	      *
	      * @constructor
	      * @this {Point}
	      * @param {Number} x The x coordinate of point.
	      * @param {Number} y The y coordinate of point.
	      * Note: Even if it is named Point this class should be named Dot as Dot is closer
	      * then Point from math perspective.
	      **/
	    function Point(x, y){
	        /**The x coordinate of point*/
	        this.x = x;
	        
	        /**The y coordinate of point*/
	        this.y = y;
	        
	
	    }
	
	    /**Creates a {Point} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Point} a newly constructed Point
	     **/
	    Point.load = function(o){
	        var newPoint = new Point(Number(o.x), Number(o.y));
	        return newPoint;
	    };
	
	
	    /**Creates an array of points from an array of {JSONObject}s
	     *@param {Array} v - the array of JSONObjects
	     *@return an {Array} of {Point}s
	     **/
	    Point.loadArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(Point.load(v[i]));
	        }
	        return newPoints;
	    };
	
	
	    /**Clones an array of points
	     *@param {Array} v - the array of {Point}s
	     *@return an {Array} of {Point}s
	     **/
	    Point.cloneArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(v[i].clone());
	        }
	        return newPoints;
	    };
	
	    Point.prototype = {
	        constructor : Point,
	        
	        transform:function(matrix){
	            var oldX = this.x;
	            var oldY = this.y;
	            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];
	            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];
	        },
	        
	        /**Tests if this point is similar to other point
	         *@param {Point} anotherPoint - the other point
	         **/
	        equals:function(anotherPoint){
	            if(! (anotherPoint instanceof Point) ){
	                return false;
	            }
	            return (this.x == anotherPoint.x)
	            && (this.y == anotherPoint.y)
	        },
	
	        /**Clone current Point
	         **/
	        clone: function(){
	            var newPoint = new Point(this.x, this.y);
	            return newPoint;
	        },
	
	        /**Tests to see if a point (x, y) is within a range of current Point
	         *@param {Numeric} x - the x coordinate of tested point
	         *@param {Numeric} y - the x coordinate of tested point
	         *@param {Numeric} radius - the radius of the vicinity
	         **/
	        near:function(x, y, radius){
	            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));
	
	            return (distance <= radius);
	        },
	
	        contains: function(x,y){
	            return this.x == x && this.y == y;
	        },
	
	        toString:function(){
	            return '[' + this.x + ',' + this.y + ']';
	        },
	
	        getPoints:function(){
	            return [this];
	        }
	    };
	    module.exports = Point;
	    

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * ZRender, a high performance 2d drawing library.
	 *
	 * Copyright (c) 2013, Baidu Inc.
	 * All rights reserved.
	 *
	 * LICENSE
	 * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	 */
	// Global defines
	
	    var guid = __webpack_require__(10);
	    var env = __webpack_require__(45);
	    var zrUtil = __webpack_require__(4);
	
	    var Handler = __webpack_require__(62);
	    var Storage = __webpack_require__(63);
	    var Animation = __webpack_require__(65);
	    var HandlerProxy = __webpack_require__(68);
	
	    var useVML = !env.canvasSupported;
	
	    var painterCtors = {
	        canvas: __webpack_require__(70)
	    };
	
	    var instances = {};    // ZRender实例map索引
	
	    var zrender = {};
	
	    /**
	     * @type {string}
	     */
	    zrender.version = '3.4.1';
	
	    /**
	     * Initializing a zrender instance
	     * @param {HTMLElement} dom
	     * @param {Object} opts
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	     * @param {number} [opts.devicePixelRatio]
	     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
	     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
	     * @return {module:zrender/ZRender}
	     */
	    zrender.init = function(dom, opts) {
	        var zr = new ZRender(guid(), dom, opts);
	        instances[zr.id] = zr;
	        return zr;
	    };
	
	    /**
	     * Dispose zrender instance
	     * @param {module:zrender/ZRender} zr
	     */
	    zrender.dispose = function (zr) {
	        if (zr) {
	            zr.dispose();
	        }
	        else {
	            for (var key in instances) {
	                if (instances.hasOwnProperty(key)) {
	                    instances[key].dispose();
	                }
	            }
	            instances = {};
	        }
	
	        return zrender;
	    };
	
	    /**
	     * Get zrender instance by id
	     * @param {string} id zrender instance id
	     * @return {module:zrender/ZRender}
	     */
	    zrender.getInstance = function (id) {
	        return instances[id];
	    };
	
	    zrender.registerPainter = function (name, Ctor) {
	        painterCtors[name] = Ctor;
	    };
	
	    function delInstance(id) {
	        delete instances[id];
	    }
	
	    /**
	     * @module zrender/ZRender
	     */
	    /**
	     * @constructor
	     * @alias module:zrender/ZRender
	     * @param {string} id
	     * @param {HTMLDomElement} dom
	     * @param {Object} opts
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	     * @param {number} [opts.devicePixelRatio]
	     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
	     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
	     */
	    var ZRender = function(id, dom, opts) {
	
	        opts = opts || {};
	
	        /**
	         * @type {HTMLDomElement}
	         */
	        this.dom = dom;
	
	        /**
	         * @type {string}
	         */
	        this.id = id;
	
	        var self = this;
	        var storage = new Storage();
	
	        var rendererType = opts.renderer;
	        // TODO WebGL
	        if (useVML) {
	            if (!painterCtors.vml) {
	                throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
	            }
	            rendererType = 'vml';
	        }
	        else if (!rendererType || !painterCtors[rendererType]) {
	            rendererType = 'canvas';
	        }
	        var painter = new painterCtors[rendererType](dom, storage, opts);
	
	        this.storage = storage;
	        this.painter = painter;
	
	        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;
	        this.handler = new Handler(storage, painter, handerProxy, painter.root);
	
	        /**
	         * @type {module:zrender/animation/Animation}
	         */
	        this.animation = new Animation({
	            stage: {
	                update: zrUtil.bind(this.flush, this)
	            }
	        });
	        this.animation.start();
	
	        /**
	         * @type {boolean}
	         * @private
	         */
	        this._needsRefresh;
	
	        // 修改 storage.delFromMap, 每次删除元素之前删除动画
	        // FIXME 有点ugly
	        var oldDelFromMap = storage.delFromMap;
	        var oldAddToMap = storage.addToMap;
	
	        storage.delFromMap = function (elId) {
	            var el = storage.get(elId);
	
	            oldDelFromMap.call(storage, elId);
	
	            el && el.removeSelfFromZr(self);
	        };
	
	        storage.addToMap = function (el) {
	            oldAddToMap.call(storage, el);
	
	            el.addSelfToZr(self);
	        };
	    };
	
	    ZRender.prototype = {
	
	        constructor: ZRender,
	        /**
	         * 获取实例唯一标识
	         * @return {string}
	         */
	        getId: function () {
	            return this.id;
	        },
	
	        /**
	         * 添加元素
	         * @param  {module:zrender/Element} el
	         */
	        add: function (el) {
	            this.storage.addRoot(el);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * 删除元素
	         * @param  {module:zrender/Element} el
	         */
	        remove: function (el) {
	            this.storage.delRoot(el);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Change configuration of layer
	         * @param {string} zLevel
	         * @param {Object} config
	         * @param {string} [config.clearColor=0] Clear color
	         * @param {string} [config.motionBlur=false] If enable motion blur
	         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
	        */
	        configLayer: function (zLevel, config) {
	            this.painter.configLayer(zLevel, config);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Repaint the canvas immediately
	         */
	        refreshImmediately: function () {
	            // Clear needsRefresh ahead to avoid something wrong happens in refresh
	            // Or it will cause zrender refreshes again and again.
	            this._needsRefresh = false;
	            this.painter.refresh();
	            /**
	             * Avoid trigger zr.refresh in Element#beforeUpdate hook
	             */
	            this._needsRefresh = false;
	        },
	
	        /**
	         * Mark and repaint the canvas in the next frame of browser
	         */
	        refresh: function() {
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Perform all refresh
	         */
	        flush: function () {
	            if (this._needsRefresh) {
	                this.refreshImmediately();
	            }
	            if (this._needsRefreshHover) {
	                this.refreshHoverImmediately();
	            }
	        },
	
	        /**
	         * Add element to hover layer
	         * @param  {module:zrender/Element} el
	         * @param {Object} style
	         */
	        addHover: function (el, style) {
	            if (this.painter.addHover) {
	                this.painter.addHover(el, style);
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Add element from hover layer
	         * @param  {module:zrender/Element} el
	         */
	        removeHover: function (el) {
	            if (this.painter.removeHover) {
	                this.painter.removeHover(el);
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Clear all hover elements in hover layer
	         * @param  {module:zrender/Element} el
	         */
	        clearHover: function () {
	            if (this.painter.clearHover) {
	                this.painter.clearHover();
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Refresh hover in next frame
	         */
	        refreshHover: function () {
	            this._needsRefreshHover = true;
	        },
	
	        /**
	         * Refresh hover immediately
	         */
	        refreshHoverImmediately: function () {
	            this._needsRefreshHover = false;
	            this.painter.refreshHover && this.painter.refreshHover();
	        },
	
	        /**
	         * Resize the canvas.
	         * Should be invoked when container size is changed
	         * @param {Object} [opts]
	         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
	         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
	         */
	        resize: function(opts) {
	            opts = opts || {};
	            this.painter.resize(opts.width, opts.height);
	            this.handler.resize();
	        },
	
	        /**
	         * Stop and clear all animation immediately
	         */
	        clearAnimation: function () {
	            this.animation.clear();
	        },
	
	        /**
	         * Get container width
	         */
	        getWidth: function() {
	            return this.painter.getWidth();
	        },
	
	        /**
	         * Get container height
	         */
	        getHeight: function() {
	            return this.painter.getHeight();
	        },
	
	        /**
	         * Export the canvas as Base64 URL
	         * @param {string} type
	         * @param {string} [backgroundColor='#fff']
	         * @return {string} Base64 URL
	         */
	        // toDataURL: function(type, backgroundColor) {
	        //     return this.painter.getRenderedCanvas({
	        //         backgroundColor: backgroundColor
	        //     }).toDataURL(type);
	        // },
	
	        /**
	         * Converting a path to image.
	         * It has much better performance of drawing image rather than drawing a vector path.
	         * @param {module:zrender/graphic/Path} e
	         * @param {number} width
	         * @param {number} height
	         */
	        pathToImage: function(e, dpr) {
	            return this.painter.pathToImage(e, dpr);
	        },
	
	        /**
	         * Set default cursor
	         * @param {string} [cursorStyle='default'] 例如 crosshair
	         */
	        setCursorStyle: function (cursorStyle) {
	            this.handler.setCursorStyle(cursorStyle);
	        },
	
	        /**
	         * Bind event
	         *
	         * @param {string} eventName Event name
	         * @param {Function} eventHandler Handler function
	         * @param {Object} [context] Context object
	         */
	        on: function(eventName, eventHandler, context) {
	            this.handler.on(eventName, eventHandler, context);
	        },
	
	        /**
	         * Unbind event
	         * @param {string} eventName Event name
	         * @param {Function} [eventHandler] Handler function
	         */
	        off: function(eventName, eventHandler) {
	            this.handler.off(eventName, eventHandler);
	        },
	
	        /**
	         * Trigger event manually
	         *
	         * @param {string} eventName Event name
	         * @param {event=} event Event object
	         */
	        trigger: function (eventName, event) {
	            this.handler.trigger(eventName, event);
	        },
	
	
	        /**
	         * Clear all objects and the canvas.
	         */
	        clear: function () {
	            this.storage.delRoot();
	            this.painter.clear();
	        },
	
	        /**
	         * Dispose self.
	         */
	        dispose: function () {
	            this.animation.stop();
	
	            this.clear();
	            this.storage.dispose();
	            this.painter.dispose();
	            this.handler.dispose();
	
	            this.animation =
	            this.storage =
	            this.painter =
	            this.handler = null;
	
	            delInstance(this.id);
	        }
	    };
	
	    module.exports = zrender;
	


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Handler
	 * @module zrender/Handler
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (shenyi.914@gmail.com)
	 */
	
	
	    var util = __webpack_require__(4);
	    var Draggable = __webpack_require__(39);
	
	    var Eventful = __webpack_require__(11);
	
	    function makeEventPacket(eveType, target, event) {
	        return {
	            type: eveType,
	            event: event,
	            target: target,
	            cancelBubble: false,
	            offsetX: event.zrX,
	            offsetY: event.zrY,
	            gestureEvent: event.gestureEvent,
	            pinchX: event.pinchX,
	            pinchY: event.pinchY,
	            pinchScale: event.pinchScale,
	            wheelDelta: event.zrDelta,
	            zrByTouch: event.zrByTouch
	        };
	    }
	
	    function EmptyProxy () {}
	    EmptyProxy.prototype.dispose = function () {};
	
	    var handlerNames = [
	        'click', 'dblclick', 'mousewheel', 'mouseout',
	        'mouseup', 'mousedown', 'mousemove', 'contextmenu'
	    ];
	    /**
	     * @alias module:zrender/Handler
	     * @constructor
	     * @extends module:zrender/mixin/Eventful
	     * @param {module:zrender/Storage} storage Storage instance.
	     * @param {module:zrender/Painter} painter Painter instance.
	     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
	     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
	     */
	    var Handler = function(storage, painter, proxy, painterRoot) {
	        Eventful.call(this);
	
	        this.storage = storage;
	
	        this.painter = painter;
	
	        this.painterRoot = painterRoot;
	
	        proxy = proxy || new EmptyProxy();
	
	        /**
	         * Proxy of event. can be Dom, WebGLSurface, etc.
	         */
	        this.proxy = proxy;
	
	        // Attach handler
	        proxy.handler = this;
	
	        /**
	         * @private
	         * @type {boolean}
	         */
	        this._hovered;
	
	        /**
	         * @private
	         * @type {Date}
	         */
	        this._lastTouchMoment;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._lastX;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._lastY;
	
	
	        Draggable.call(this);
	
	        util.each(handlerNames, function (name) {
	            proxy.on && proxy.on(name, this[name], this);
	        }, this);
	    };
	
	    Handler.prototype = {
	
	        constructor: Handler,
	
	        mousemove: function (event) {
	            var x = event.zrX;
	            var y = event.zrY;
	
	            var hovered = this.findHover(x, y, null);
	            var lastHovered = this._hovered;
	            var proxy = this.proxy;
	
	            this._hovered = hovered;
	
	            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');
	
	            // Mouse out on previous hovered element
	            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {
	                this.dispatchToElement(lastHovered, 'mouseout', event);
	            }
	
	            // Mouse moving on one element
	            this.dispatchToElement(hovered, 'mousemove', event);
	
	            // Mouse over on a new element
	            if (hovered && hovered !== lastHovered) {
	                this.dispatchToElement(hovered, 'mouseover', event);
	            }
	        },
	
	        mouseout: function (event) {
	            this.dispatchToElement(this._hovered, 'mouseout', event);
	
	            // There might be some doms created by upper layer application
	            // at the same level of painter.getViewportRoot() (e.g., tooltip
	            // dom created by echarts), where 'globalout' event should not
	            // be triggered when mouse enters these doms. (But 'mouseout'
	            // should be triggered at the original hovered element as usual).
	            var element = event.toElement || event.relatedTarget;
	            var innerDom;
	            do {
	                element = element && element.parentNode;
	            }
	            while (element && element.nodeType != 9 && !(
	                innerDom = element === this.painterRoot
	            ));
	
	            !innerDom && this.trigger('globalout', {event: event});
	        },
	
	        /**
	         * Resize
	         */
	        resize: function (event) {
	            this._hovered = null;
	        },
	
	        /**
	         * Dispatch event
	         * @param {string} eventName
	         * @param {event=} eventArgs
	         */
	        dispatch: function (eventName, eventArgs) {
	            var handler = this[eventName];
	            handler && handler.call(this, eventArgs);
	        },
	
	        /**
	         * Dispose
	         */
	        dispose: function () {
	
	            this.proxy.dispose();
	
	            this.storage =
	            this.proxy =
	            this.painter = null;
	        },
	
	        /**
	         * 设置默认的cursor style
	         * @param {string} [cursorStyle='default'] 例如 crosshair
	         */
	        setCursorStyle: function (cursorStyle) {
	            var proxy = this.proxy;
	            proxy.setCursor && proxy.setCursor(cursorStyle);
	        },
	
	        /**
	         * 事件分发代理
	         *
	         * @private
	         * @param {Object} targetEl 目标图形元素
	         * @param {string} eventName 事件名称
	         * @param {Object} event 事件对象
	         */
	        dispatchToElement: function (targetEl, eventName, event) {
	            var eventHandler = 'on' + eventName;
	            var eventPacket = makeEventPacket(eventName, targetEl, event);
	
	            var el = targetEl;
	
	            while (el) {
	                el[eventHandler]
	                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
	
	                el.trigger(eventName, eventPacket);
	
	                el = el.parent;
	
	                if (eventPacket.cancelBubble) {
	                    break;
	                }
	            }
	
	            if (!eventPacket.cancelBubble) {
	                // 冒泡到顶级 zrender 对象
	                this.trigger(eventName, eventPacket);
	                // 分发事件到用户自定义层
	                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在
	                this.painter && this.painter.eachOtherLayer(function (layer) {
	                    if (typeof(layer[eventHandler]) == 'function') {
	                        layer[eventHandler].call(layer, eventPacket);
	                    }
	                    if (layer.trigger) {
	                        layer.trigger(eventName, eventPacket);
	                    }
	                });
	            }
	        },
	
	        /**
	         * @private
	         * @param {number} x
	         * @param {number} y
	         * @param {module:zrender/graphic/Displayable} exclude
	         * @method
	         */
	        findHover: function(x, y, exclude) {
	            var list = this.storage.getDisplayList();
	            for (var i = list.length - 1; i >= 0 ; i--) {
	                if (!list[i].silent
	                 && list[i] !== exclude
	                 // getDisplayList may include ignored item in VML mode
	                 && !list[i].ignore
	                 && isHover(list[i], x, y)) {
	                    return list[i];
	                }
	            }
	        }
	    };
	
	    // Common handlers
	    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
	        Handler.prototype[name] = function (event) {
	            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
	            var hovered = this.findHover(event.zrX, event.zrY, null);
	
	            if (name === 'mousedown') {
	                this._downel = hovered;
	                // In case click triggered before mouseup
	                this._upel = hovered;
	            }
	            else if (name === 'mosueup') {
	                this._upel = hovered;
	            }
	            else if (name === 'click') {
	                if (this._downel !== this._upel) {
	                    return;
	                }
	            }
	
	            this.dispatchToElement(hovered, name, event);
	        };
	    });
	
	    function isHover(displayable, x, y) {
	        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
	            var el = displayable;
	            while (el) {
	                // If ancestor is silent or clipped by ancestor
	                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {
	                    return false;
	                }
	                el = el.parent;
	            }
	            return true;
	        }
	
	        return false;
	    }
	
	    util.mixin(Handler, Eventful);
	    util.mixin(Handler, Draggable);
	
	    module.exports = Handler;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Storage内容仓库模块
	 * @module zrender/Storage
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 * @author errorrik (errorrik@gmail.com)
	 * @author pissang (https://github.com/pissang/)
	 */
	
	
	    var util = __webpack_require__(4);
	    var env = __webpack_require__(45);
	
	    var Group = __webpack_require__(40);
	
	    // Use timsort because in most case elements are partially sorted
	    // https://jsfiddle.net/pissang/jr4x7mdm/8/
	    var timsort = __webpack_require__(64);
	
	    function shapeCompareFunc(a, b) {
	        if (a.zlevel === b.zlevel) {
	            if (a.z === b.z) {
	                // if (a.z2 === b.z2) {
	                //     // FIXME Slow has renderidx compare
	                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
	                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
	                //     return a.__renderidx - b.__renderidx;
	                // }
	                return a.z2 - b.z2;
	            }
	            return a.z - b.z;
	        }
	        return a.zlevel - b.zlevel;
	    }
	    /**
	     * 内容仓库 (M)
	     * @alias module:zrender/Storage
	     * @constructor
	     */
	    var Storage = function () {
	        // 所有常规形状，id索引的map
	        this._elements = {};
	
	        this._roots = [];
	
	        this._displayList = [];
	
	        this._displayListLen = 0;
	    };
	
	    Storage.prototype = {
	
	        constructor: Storage,
	
	        /**
	         * @param  {Function} cb
	         *
	         */
	        traverse: function (cb, context) {
	            for (var i = 0; i < this._roots.length; i++) {
	                this._roots[i].traverse(cb, context);
	            }
	        },
	
	        /**
	         * 返回所有图形的绘制队列
	         * @param {boolean} [update=false] 是否在返回前更新该数组
	         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
	         *
	         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
	         * @return {Array.<module:zrender/graphic/Displayable>}
	         */
	        getDisplayList: function (update, includeIgnore) {
	            includeIgnore = includeIgnore || false;
	            if (update) {
	                this.updateDisplayList(includeIgnore);
	            }
	            return this._displayList;
	        },
	
	        /**
	         * 更新图形的绘制队列。
	         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
	         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
	         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
	         */
	        updateDisplayList: function (includeIgnore) {
	            this._displayListLen = 0;
	            var roots = this._roots;
	            var displayList = this._displayList;
	            for (var i = 0, len = roots.length; i < len; i++) {
	                this._updateAndAddDisplayable(roots[i], null, includeIgnore);
	            }
	            displayList.length = this._displayListLen;
	
	            // for (var i = 0, len = displayList.length; i < len; i++) {
	            //     displayList[i].__renderidx = i;
	            // }
	
	            // displayList.sort(shapeCompareFunc);
	            env.canvasSupported && timsort(displayList, shapeCompareFunc);
	        },
	
	        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
	
	            if (el.ignore && !includeIgnore) {
	                return;
	            }
	
	            el.beforeUpdate();
	
	            if (el.__dirty) {
	
	                el.update();
	
	            }
	
	            el.afterUpdate();
	
	            var userSetClipPath = el.clipPath;
	            if (userSetClipPath) {
	
	                // FIXME 效率影响
	                if (clipPaths) {
	                    clipPaths = clipPaths.slice();
	                }
	                else {
	                    clipPaths = [];
	                }
	
	                var currentClipPath = userSetClipPath;
	                var parentClipPath = el;
	                // Recursively add clip path
	                while (currentClipPath) {
	                    // clipPath 的变换是基于使用这个 clipPath 的元素
	                    currentClipPath.parent = parentClipPath;
	                    currentClipPath.updateTransform();
	
	                    clipPaths.push(currentClipPath);
	
	                    parentClipPath = currentClipPath;
	                    currentClipPath = currentClipPath.clipPath;
	                }
	            }
	
	            if (el.isGroup) {
	                var children = el._children;
	
	                for (var i = 0; i < children.length; i++) {
	                    var child = children[i];
	
	                    // Force to mark as dirty if group is dirty
	                    // FIXME __dirtyPath ?
	                    if (el.__dirty) {
	                        child.__dirty = true;
	                    }
	
	                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
	                }
	
	                // Mark group clean here
	                el.__dirty = false;
	
	            }
	            else {
	                el.__clipPaths = clipPaths;
	
	                this._displayList[this._displayListLen++] = el;
	            }
	        },
	
	        /**
	         * 添加图形(Shape)或者组(Group)到根节点
	         * @param {module:zrender/Element} el
	         */
	        addRoot: function (el) {
	            // Element has been added
	            if (this._elements[el.id]) {
	                return;
	            }
	
	            if (el instanceof Group) {
	                el.addChildrenToStorage(this);
	            }
	
	            this.addToMap(el);
	            this._roots.push(el);
	        },
	
	        /**
	         * 删除指定的图形(Shape)或者组(Group)
	         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage
	         */
	        delRoot: function (elId) {
	            if (elId == null) {
	                // 不指定elId清空
	                for (var i = 0; i < this._roots.length; i++) {
	                    var root = this._roots[i];
	                    if (root instanceof Group) {
	                        root.delChildrenFromStorage(this);
	                    }
	                }
	
	                this._elements = {};
	                this._roots = [];
	                this._displayList = [];
	                this._displayListLen = 0;
	
	                return;
	            }
	
	            if (elId instanceof Array) {
	                for (var i = 0, l = elId.length; i < l; i++) {
	                    this.delRoot(elId[i]);
	                }
	                return;
	            }
	
	            var el;
	            if (typeof(elId) == 'string') {
	                el = this._elements[elId];
	            }
	            else {
	                el = elId;
	            }
	
	            var idx = util.indexOf(this._roots, el);
	            if (idx >= 0) {
	                this.delFromMap(el.id);
	                this._roots.splice(idx, 1);
	                if (el instanceof Group) {
	                    el.delChildrenFromStorage(this);
	                }
	            }
	        },
	
	        addToMap: function (el) {
	            if (el instanceof Group) {
	                el.__storage = this;
	            }
	            el.dirty(false);
	
	            this._elements[el.id] = el;
	
	            return this;
	        },
	
	        get: function (elId) {
	            return this._elements[elId];
	        },
	
	        delFromMap: function (elId) {
	            var elements = this._elements;
	            var el = elements[elId];
	            if (el) {
	                delete elements[elId];
	                if (el instanceof Group) {
	                    el.__storage = null;
	                }
	            }
	
	            return this;
	        },
	
	        /**
	         * 清空并且释放Storage
	         */
	        dispose: function () {
	            this._elements =
	            this._renderList =
	            this._roots = null;
	        },
	
	        displayableSortFunc: shapeCompareFunc
	    };
	
	    module.exports = Storage;
	


/***/ },
/* 64 */
/***/ function(module, exports) {

	// https://github.com/mziccard/node-timsort
	
	    var DEFAULT_MIN_MERGE = 32;
	
	    var DEFAULT_MIN_GALLOPING = 7;
	
	    var DEFAULT_TMP_STORAGE_LENGTH = 256;
	
	    function minRunLength(n) {
	        var r = 0;
	
	        while (n >= DEFAULT_MIN_MERGE) {
	            r |= n & 1;
	            n >>= 1;
	        }
	
	        return n + r;
	    }
	
	    function makeAscendingRun(array, lo, hi, compare) {
	        var runHi = lo + 1;
	
	        if (runHi === hi) {
	            return 1;
	        }
	
	        if (compare(array[runHi++], array[lo]) < 0) {
	            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
	                runHi++;
	            }
	
	            reverseRun(array, lo, runHi);
	        }
	        else {
	            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
	                runHi++;
	            }
	        }
	
	        return runHi - lo;
	    }
	
	    function reverseRun(array, lo, hi) {
	        hi--;
	
	        while (lo < hi) {
	            var t = array[lo];
	            array[lo++] = array[hi];
	            array[hi--] = t;
	        }
	    }
	
	    function binaryInsertionSort(array, lo, hi, start, compare) {
	        if (start === lo) {
	            start++;
	        }
	
	        for (; start < hi; start++) {
	            var pivot = array[start];
	
	            var left = lo;
	            var right = start;
	            var mid;
	
	            while (left < right) {
	                mid = left + right >>> 1;
	
	                if (compare(pivot, array[mid]) < 0) {
	                    right = mid;
	                }
	                else {
	                    left = mid + 1;
	                }
	            }
	
	            var n = start - left;
	
	            switch (n) {
	                case 3:
	                    array[left + 3] = array[left + 2];
	
	                case 2:
	                    array[left + 2] = array[left + 1];
	
	                case 1:
	                    array[left + 1] = array[left];
	                    break;
	                default:
	                    while (n > 0) {
	                        array[left + n] = array[left + n - 1];
	                        n--;
	                    }
	            }
	
	            array[left] = pivot;
	        }
	    }
	
	    function gallopLeft(value, array, start, length, hint, compare) {
	        var lastOffset = 0;
	        var maxOffset = 0;
	        var offset = 1;
	
	        if (compare(value, array[start + hint]) > 0) {
	            maxOffset = length - hint;
	
	            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            lastOffset += hint;
	            offset += hint;
	        }
	        else {
	            maxOffset = hint + 1;
	            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            var tmp = lastOffset;
	            lastOffset = hint - offset;
	            offset = hint - tmp;
	        }
	
	        lastOffset++;
	        while (lastOffset < offset) {
	            var m = lastOffset + (offset - lastOffset >>> 1);
	
	            if (compare(value, array[start + m]) > 0) {
	                lastOffset = m + 1;
	            }
	            else {
	                offset = m;
	            }
	        }
	        return offset;
	    }
	
	    function gallopRight(value, array, start, length, hint, compare) {
	        var lastOffset = 0;
	        var maxOffset = 0;
	        var offset = 1;
	
	        if (compare(value, array[start + hint]) < 0) {
	            maxOffset = hint + 1;
	
	            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            var tmp = lastOffset;
	            lastOffset = hint - offset;
	            offset = hint - tmp;
	        }
	        else {
	            maxOffset = length - hint;
	
	            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            lastOffset += hint;
	            offset += hint;
	        }
	
	        lastOffset++;
	
	        while (lastOffset < offset) {
	            var m = lastOffset + (offset - lastOffset >>> 1);
	
	            if (compare(value, array[start + m]) < 0) {
	                offset = m;
	            }
	            else {
	                lastOffset = m + 1;
	            }
	        }
	
	        return offset;
	    }
	
	    function TimSort(array, compare) {
	        var minGallop = DEFAULT_MIN_GALLOPING;
	        var length = 0;
	        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
	        var stackLength = 0;
	        var runStart;
	        var runLength;
	        var stackSize = 0;
	
	        length = array.length;
	
	        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
	            tmpStorageLength = length >>> 1;
	        }
	
	        var tmp = [];
	
	        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
	
	        runStart = [];
	        runLength = [];
	
	        function pushRun(_runStart, _runLength) {
	            runStart[stackSize] = _runStart;
	            runLength[stackSize] = _runLength;
	            stackSize += 1;
	        }
	
	        function mergeRuns() {
	            while (stackSize > 1) {
	                var n = stackSize - 2;
	
	                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
	                    if (runLength[n - 1] < runLength[n + 1]) {
	                        n--;
	                    }
	                }
	                else if (runLength[n] > runLength[n + 1]) {
	                    break;
	                }
	                mergeAt(n);
	            }
	        }
	
	        function forceMergeRuns() {
	            while (stackSize > 1) {
	                var n = stackSize - 2;
	
	                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
	                    n--;
	                }
	
	                mergeAt(n);
	            }
	        }
	
	        function mergeAt(i) {
	            var start1 = runStart[i];
	            var length1 = runLength[i];
	            var start2 = runStart[i + 1];
	            var length2 = runLength[i + 1];
	
	            runLength[i] = length1 + length2;
	
	            if (i === stackSize - 3) {
	                runStart[i + 1] = runStart[i + 2];
	                runLength[i + 1] = runLength[i + 2];
	            }
	
	            stackSize--;
	
	            var k = gallopRight(array[start2], array, start1, length1, 0, compare);
	            start1 += k;
	            length1 -= k;
	
	            if (length1 === 0) {
	                return;
	            }
	
	            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
	
	            if (length2 === 0) {
	                return;
	            }
	
	            if (length1 <= length2) {
	                mergeLow(start1, length1, start2, length2);
	            }
	            else {
	                mergeHigh(start1, length1, start2, length2);
	            }
	        }
	
	        function mergeLow(start1, length1, start2, length2) {
	            var i = 0;
	
	            for (i = 0; i < length1; i++) {
	                tmp[i] = array[start1 + i];
	            }
	
	            var cursor1 = 0;
	            var cursor2 = start2;
	            var dest = start1;
	
	            array[dest++] = array[cursor2++];
	
	            if (--length2 === 0) {
	                for (i = 0; i < length1; i++) {
	                    array[dest + i] = tmp[cursor1 + i];
	                }
	                return;
	            }
	
	            if (length1 === 1) {
	                for (i = 0; i < length2; i++) {
	                    array[dest + i] = array[cursor2 + i];
	                }
	                array[dest + length2] = tmp[cursor1];
	                return;
	            }
	
	            var _minGallop = minGallop;
	            var count1, count2, exit;
	
	            while (1) {
	                count1 = 0;
	                count2 = 0;
	                exit = false;
	
	                do {
	                    if (compare(array[cursor2], tmp[cursor1]) < 0) {
	                        array[dest++] = array[cursor2++];
	                        count2++;
	                        count1 = 0;
	
	                        if (--length2 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    else {
	                        array[dest++] = tmp[cursor1++];
	                        count1++;
	                        count2 = 0;
	                        if (--length1 === 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                } while ((count1 | count2) < _minGallop);
	
	                if (exit) {
	                    break;
	                }
	
	                do {
	                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
	
	                    if (count1 !== 0) {
	                        for (i = 0; i < count1; i++) {
	                            array[dest + i] = tmp[cursor1 + i];
	                        }
	
	                        dest += count1;
	                        cursor1 += count1;
	                        length1 -= count1;
	                        if (length1 <= 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest++] = array[cursor2++];
	
	                    if (--length2 === 0) {
	                        exit = true;
	                        break;
	                    }
	
	                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
	
	                    if (count2 !== 0) {
	                        for (i = 0; i < count2; i++) {
	                            array[dest + i] = array[cursor2 + i];
	                        }
	
	                        dest += count2;
	                        cursor2 += count2;
	                        length2 -= count2;
	
	                        if (length2 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    array[dest++] = tmp[cursor1++];
	
	                    if (--length1 === 1) {
	                        exit = true;
	                        break;
	                    }
	
	                    _minGallop--;
	                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	                if (exit) {
	                    break;
	                }
	
	                if (_minGallop < 0) {
	                    _minGallop = 0;
	                }
	
	                _minGallop += 2;
	            }
	
	            minGallop = _minGallop;
	
	            minGallop < 1 && (minGallop = 1);
	
	            if (length1 === 1) {
	                for (i = 0; i < length2; i++) {
	                    array[dest + i] = array[cursor2 + i];
	                }
	                array[dest + length2] = tmp[cursor1];
	            }
	            else if (length1 === 0) {
	                throw new Error();
	                // throw new Error('mergeLow preconditions were not respected');
	            }
	            else {
	                for (i = 0; i < length1; i++) {
	                    array[dest + i] = tmp[cursor1 + i];
	                }
	            }
	        }
	
	        function mergeHigh (start1, length1, start2, length2) {
	            var i = 0;
	
	            for (i = 0; i < length2; i++) {
	                tmp[i] = array[start2 + i];
	            }
	
	            var cursor1 = start1 + length1 - 1;
	            var cursor2 = length2 - 1;
	            var dest = start2 + length2 - 1;
	            var customCursor = 0;
	            var customDest = 0;
	
	            array[dest--] = array[cursor1--];
	
	            if (--length1 === 0) {
	                customCursor = dest - (length2 - 1);
	
	                for (i = 0; i < length2; i++) {
	                    array[customCursor + i] = tmp[i];
	                }
	
	                return;
	            }
	
	            if (length2 === 1) {
	                dest -= length1;
	                cursor1 -= length1;
	                customDest = dest + 1;
	                customCursor = cursor1 + 1;
	
	                for (i = length1 - 1; i >= 0; i--) {
	                    array[customDest + i] = array[customCursor + i];
	                }
	
	                array[dest] = tmp[cursor2];
	                return;
	            }
	
	            var _minGallop = minGallop;
	
	            while (true) {
	                var count1 = 0;
	                var count2 = 0;
	                var exit = false;
	
	                do {
	                    if (compare(tmp[cursor2], array[cursor1]) < 0) {
	                        array[dest--] = array[cursor1--];
	                        count1++;
	                        count2 = 0;
	                        if (--length1 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    else {
	                        array[dest--] = tmp[cursor2--];
	                        count2++;
	                        count1 = 0;
	                        if (--length2 === 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                } while ((count1 | count2) < _minGallop);
	
	                if (exit) {
	                    break;
	                }
	
	                do {
	                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
	
	                    if (count1 !== 0) {
	                        dest -= count1;
	                        cursor1 -= count1;
	                        length1 -= count1;
	                        customDest = dest + 1;
	                        customCursor = cursor1 + 1;
	
	                        for (i = count1 - 1; i >= 0; i--) {
	                            array[customDest + i] = array[customCursor + i];
	                        }
	
	                        if (length1 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest--] = tmp[cursor2--];
	
	                    if (--length2 === 1) {
	                        exit = true;
	                        break;
	                    }
	
	                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
	
	                    if (count2 !== 0) {
	                        dest -= count2;
	                        cursor2 -= count2;
	                        length2 -= count2;
	                        customDest = dest + 1;
	                        customCursor = cursor2 + 1;
	
	                        for (i = 0; i < count2; i++) {
	                            array[customDest + i] = tmp[customCursor + i];
	                        }
	
	                        if (length2 <= 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest--] = array[cursor1--];
	
	                    if (--length1 === 0) {
	                        exit = true;
	                        break;
	                    }
	
	                    _minGallop--;
	                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	                if (exit) {
	                    break;
	                }
	
	                if (_minGallop < 0) {
	                    _minGallop = 0;
	                }
	
	                _minGallop += 2;
	            }
	
	            minGallop = _minGallop;
	
	            if (minGallop < 1) {
	                minGallop = 1;
	            }
	
	            if (length2 === 1) {
	                dest -= length1;
	                cursor1 -= length1;
	                customDest = dest + 1;
	                customCursor = cursor1 + 1;
	
	                for (i = length1 - 1; i >= 0; i--) {
	                    array[customDest + i] = array[customCursor + i];
	                }
	
	                array[dest] = tmp[cursor2];
	            }
	            else if (length2 === 0) {
	                throw new Error();
	                // throw new Error('mergeHigh preconditions were not respected');
	            }
	            else {
	                customCursor = dest - (length2 - 1);
	                for (i = 0; i < length2; i++) {
	                    array[customCursor + i] = tmp[i];
	                }
	            }
	        }
	
	        this.mergeRuns = mergeRuns;
	        this.forceMergeRuns = forceMergeRuns;
	        this.pushRun = pushRun;
	    }
	
	    function sort(array, compare, lo, hi) {
	        if (!lo) {
	            lo = 0;
	        }
	        if (!hi) {
	            hi = array.length;
	        }
	
	        var remaining = hi - lo;
	
	        if (remaining < 2) {
	            return;
	        }
	
	        var runLength = 0;
	
	        if (remaining < DEFAULT_MIN_MERGE) {
	            runLength = makeAscendingRun(array, lo, hi, compare);
	            binaryInsertionSort(array, lo, hi, lo + runLength, compare);
	            return;
	        }
	
	        var ts = new TimSort(array, compare);
	
	        var minRun = minRunLength(remaining);
	
	        do {
	            runLength = makeAscendingRun(array, lo, hi, compare);
	            if (runLength < minRun) {
	                var force = remaining;
	                if (force > minRun) {
	                    force = minRun;
	                }
	
	                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
	                runLength = force;
	            }
	
	            ts.pushRun(lo, runLength);
	            ts.mergeRuns();
	
	            remaining -= runLength;
	            lo += runLength;
	        } while (remaining !== 0);
	
	        ts.forceMergeRuns();
	    }
	
	    module.exports = sort;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 动画主类, 调度和管理所有动画控制器
	 *
	 * @module zrender/animation/Animation
	 * @author pissang(https://github.com/pissang)
	 */
	// TODO Additive animation
	// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
	// https://developer.apple.com/videos/wwdc2014/#236
	
	
	    var util = __webpack_require__(4);
	    var Dispatcher = __webpack_require__(66).Dispatcher;
	
	    var requestAnimationFrame = __webpack_require__(67);
	
	    var Animator = __webpack_require__(16);
	    /**
	     * @typedef {Object} IZRenderStage
	     * @property {Function} update
	     */
	
	    /**
	     * @alias module:zrender/animation/Animation
	     * @constructor
	     * @param {Object} [options]
	     * @param {Function} [options.onframe]
	     * @param {IZRenderStage} [options.stage]
	     * @example
	     *     var animation = new Animation();
	     *     var obj = {
	     *         x: 100,
	     *         y: 100
	     *     };
	     *     animation.animate(node.position)
	     *         .when(1000, {
	     *             x: 500,
	     *             y: 500
	     *         })
	     *         .when(2000, {
	     *             x: 100,
	     *             y: 100
	     *         })
	     *         .start('spline');
	     */
	    var Animation = function (options) {
	
	        options = options || {};
	
	        this.stage = options.stage || {};
	
	        this.onframe = options.onframe || function() {};
	
	        // private properties
	        this._clips = [];
	
	        this._running = false;
	
	        this._time;
	
	        this._pausedTime;
	
	        this._pauseStart;
	
	        this._paused = false;
	
	        Dispatcher.call(this);
	    };
	
	    Animation.prototype = {
	
	        constructor: Animation,
	        /**
	         * 添加 clip
	         * @param {module:zrender/animation/Clip} clip
	         */
	        addClip: function (clip) {
	            this._clips.push(clip);
	        },
	        /**
	         * 添加 animator
	         * @param {module:zrender/animation/Animator} animator
	         */
	        addAnimator: function (animator) {
	            animator.animation = this;
	            var clips = animator.getClips();
	            for (var i = 0; i < clips.length; i++) {
	                this.addClip(clips[i]);
	            }
	        },
	        /**
	         * 删除动画片段
	         * @param {module:zrender/animation/Clip} clip
	         */
	        removeClip: function(clip) {
	            var idx = util.indexOf(this._clips, clip);
	            if (idx >= 0) {
	                this._clips.splice(idx, 1);
	            }
	        },
	
	        /**
	         * 删除动画片段
	         * @param {module:zrender/animation/Animator} animator
	         */
	        removeAnimator: function (animator) {
	            var clips = animator.getClips();
	            for (var i = 0; i < clips.length; i++) {
	                this.removeClip(clips[i]);
	            }
	            animator.animation = null;
	        },
	
	        _update: function() {
	
	            var time = new Date().getTime() - this._pausedTime;
	            var delta = time - this._time;
	            var clips = this._clips;
	            var len = clips.length;
	
	            var deferredEvents = [];
	            var deferredClips = [];
	            for (var i = 0; i < len; i++) {
	                var clip = clips[i];
	                var e = clip.step(time, delta);
	                // Throw out the events need to be called after
	                // stage.update, like destroy
	                if (e) {
	                    deferredEvents.push(e);
	                    deferredClips.push(clip);
	                }
	            }
	
	            // Remove the finished clip
	            for (var i = 0; i < len;) {
	                if (clips[i]._needsRemove) {
	                    clips[i] = clips[len - 1];
	                    clips.pop();
	                    len--;
	                }
	                else {
	                    i++;
	                }
	            }
	
	            len = deferredEvents.length;
	            for (var i = 0; i < len; i++) {
	                deferredClips[i].fire(deferredEvents[i]);
	            }
	
	            this._time = time;
	
	            this.onframe(delta);
	
	            this.trigger('frame', delta);
	
	            if (this.stage.update) {
	                this.stage.update();
	            }
	        },
	
	        _startLoop: function () {
	            var self = this;
	
	            this._running = true;
	
	            function step() {
	                if (self._running) {
	
	                    requestAnimationFrame(step);
	
	                    !self._paused && self._update();
	                }
	            }
	
	            requestAnimationFrame(step);
	        },
	
	        /**
	         * 开始运行动画
	         */
	        start: function () {
	
	            this._time = new Date().getTime();
	            this._pausedTime = 0;
	
	            this._startLoop();
	        },
	        /**
	         * 停止运行动画
	         */
	        stop: function () {
	            this._running = false;
	        },
	
	        /**
	         * Pause
	         */
	        pause: function () {
	            if (!this._paused) {
	                this._pauseStart = new Date().getTime();
	                this._paused = true;
	            }
	        },
	
	        /**
	         * Resume
	         */
	        resume: function () {
	            if (this._paused) {
	                this._pausedTime += (new Date().getTime()) - this._pauseStart;
	                this._paused = false;
	            }
	        },
	
	        /**
	         * 清除所有动画片段
	         */
	        clear: function () {
	            this._clips = [];
	        },
	        /**
	         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
	         * @param  {Object} target
	         * @param  {Object} options
	         * @param  {boolean} [options.loop=false] 是否循环播放动画
	         * @param  {Function} [options.getter=null]
	         *         如果指定getter函数，会通过getter函数取属性值
	         * @param  {Function} [options.setter=null]
	         *         如果指定setter函数，会通过setter函数设置属性值
	         * @return {module:zrender/animation/Animation~Animator}
	         */
	        // TODO Gap
	        animate: function (target, options) {
	            options = options || {};
	
	            var animator = new Animator(
	                target,
	                options.loop,
	                options.getter,
	                options.setter
	            );
	
	            this.addAnimator(animator);
	
	            return animator;
	        }
	    };
	
	    util.mixin(Animation, Dispatcher);
	
	    module.exports = Animation;
	


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 事件辅助类
	 * @module zrender/core/event
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	
	
	    var Eventful = __webpack_require__(11);
	    var env = __webpack_require__(45);
	
	    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;
	
	    function getBoundingClientRect(el) {
	        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
	        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};
	    }
	
	    // `calculate` is optional, default false
	    function clientToLocal(el, e, out, calculate) {
	        out = out || {};
	
	        // According to the W3C Working Draft, offsetX and offsetY should be relative
	        // to the padding edge of the target element. The only browser using this convention
	        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
	        // not support the properties.
	        // (see http://www.jacklmoore.com/notes/mouse-position/)
	        // In zr painter.dom, padding edge equals to border edge.
	
	        // FIXME
	        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and
	        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y
	        // is too complex. So css-transfrom dont support in this case temporarily.
	        if (calculate || !env.canvasSupported) {
	            defaultGetZrXY(el, e, out);
	        }
	        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
	        // ancestor element, so we should make sure el is positioned (e.g., not position:static).
	        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add
	        // zoom-factor, overflow / opacity layers, transforms ...)
	        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
	        // <https://bugs.jquery.com/ticket/8523#comment:14>
	        // BTW3, In ff, offsetX/offsetY is always 0.
	        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
	            out.zrX = e.layerX;
	            out.zrY = e.layerY;
	        }
	        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)
	        else if (e.offsetX != null) {
	            out.zrX = e.offsetX;
	            out.zrY = e.offsetY;
	        }
	        // For some other device, e.g., IOS safari.
	        else {
	            defaultGetZrXY(el, e, out);
	        }
	
	        return out;
	    }
	
	    function defaultGetZrXY(el, e, out) {
	        // This well-known method below does not support css transform.
	        var box = getBoundingClientRect(el);
	        out.zrX = e.clientX - box.left;
	        out.zrY = e.clientY - box.top;
	    }
	
	    /**
	     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.
	     * `calculate` is optional, default false.
	     */
	    function normalizeEvent(el, e, calculate) {
	
	        e = e || window.event;
	
	        if (e.zrX != null) {
	            return e;
	        }
	
	        var eventType = e.type;
	        var isTouch = eventType && eventType.indexOf('touch') >= 0;
	
	        if (!isTouch) {
	            clientToLocal(el, e, e, calculate);
	            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
	        }
	        else {
	            var touch = eventType != 'touchend'
	                ? e.targetTouches[0]
	                : e.changedTouches[0];
	            touch && clientToLocal(el, touch, e, calculate);
	        }
	
	        return e;
	    }
	
	    function addEventListener(el, name, handler) {
	        if (isDomLevel2) {
	            el.addEventListener(name, handler);
	        }
	        else {
	            el.attachEvent('on' + name, handler);
	        }
	    }
	
	    function removeEventListener(el, name, handler) {
	        if (isDomLevel2) {
	            el.removeEventListener(name, handler);
	        }
	        else {
	            el.detachEvent('on' + name, handler);
	        }
	    }
	
	    /**
	     * preventDefault and stopPropagation.
	     * Notice: do not do that in zrender. Upper application
	     * do that if necessary.
	     *
	     * @memberOf module:zrender/core/event
	     * @method
	     * @param {Event} e : event对象
	     */
	    var stop = isDomLevel2
	        ? function (e) {
	            e.preventDefault();
	            e.stopPropagation();
	            e.cancelBubble = true;
	        }
	        : function (e) {
	            e.returnValue = false;
	            e.cancelBubble = true;
	        };
	
	    module.exports = {
	        clientToLocal: clientToLocal,
	        normalizeEvent: normalizeEvent,
	        addEventListener: addEventListener,
	        removeEventListener: removeEventListener,
	
	        stop: stop,
	        // 做向上兼容
	        Dispatcher: Eventful
	    };
	


/***/ },
/* 67 */
/***/ function(module, exports) {

	
	
	    module.exports = (typeof window !== 'undefined' &&
	                                    (window.requestAnimationFrame
	                                    || window.msRequestAnimationFrame
	                                    || window.mozRequestAnimationFrame
	                                    || window.webkitRequestAnimationFrame))
	                                || function (func) {
	                                    setTimeout(func, 16);
	                                };
	


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var eventTool = __webpack_require__(66);
	    var zrUtil = __webpack_require__(4);
	    var Eventful = __webpack_require__(11);
	    var env = __webpack_require__(45);
	    var GestureMgr = __webpack_require__(69);
	
	    var addEventListener = eventTool.addEventListener;
	    var removeEventListener = eventTool.removeEventListener;
	    var normalizeEvent = eventTool.normalizeEvent;
	
	    var TOUCH_CLICK_DELAY = 300;
	
	    var mouseHandlerNames = [
	        'click', 'dblclick', 'mousewheel', 'mouseout',
	        'mouseup', 'mousedown', 'mousemove', 'contextmenu'
	    ];
	
	    var touchHandlerNames = [
	        'touchstart', 'touchend', 'touchmove'
	    ];
	
	    var pointerEventNames = {
	        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1
	    };
	
	    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {
	        var nm = name.replace('mouse', 'pointer');
	        return pointerEventNames[nm] ? nm : name;
	    });
	
	    function eventNameFix(name) {
	        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;
	    }
	
	    function processGesture(proxy, event, stage) {
	        var gestureMgr = proxy._gestureMgr;
	
	        stage === 'start' && gestureMgr.clear();
	
	        var gestureInfo = gestureMgr.recognize(
	            event,
	            proxy.handler.findHover(event.zrX, event.zrY, null),
	            proxy.dom
	        );
	
	        stage === 'end' && gestureMgr.clear();
	
	        // Do not do any preventDefault here. Upper application do that if necessary.
	        if (gestureInfo) {
	            var type = gestureInfo.type;
	            event.gestureEvent = type;
	
	            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);
	        }
	    }
	
	    // function onMSGestureChange(proxy, event) {
	    //     if (event.translationX || event.translationY) {
	    //         // mousemove is carried by MSGesture to reduce the sensitivity.
	    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);
	    //     }
	    //     if (event.scale !== 1) {
	    //         event.pinchX = event.offsetX;
	    //         event.pinchY = event.offsetY;
	    //         event.pinchScale = event.scale;
	    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);
	    //     }
	    // }
	
	    /**
	     * Prevent mouse event from being dispatched after Touch Events action
	     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
	     * 1. Mobile browsers dispatch mouse events 300ms after touchend.
	     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
	     * Result: Blocking Mouse Events for 700ms.
	     */
	    function setTouchTimer(instance) {
	        instance._touching = true;
	        clearTimeout(instance._touchTimer);
	        instance._touchTimer = setTimeout(function () {
	            instance._touching = false;
	        }, 700);
	    }
	
	
	    var domHandlers = {
	        /**
	         * Mouse move handler
	         * @inner
	         * @param {Event} event
	         */
	        mousemove: function (event) {
	            event = normalizeEvent(this.dom, event);
	
	            this.trigger('mousemove', event);
	        },
	
	        /**
	         * Mouse out handler
	         * @inner
	         * @param {Event} event
	         */
	        mouseout: function (event) {
	            event = normalizeEvent(this.dom, event);
	
	            var element = event.toElement || event.relatedTarget;
	            if (element != this.dom) {
	                while (element && element.nodeType != 9) {
	                    // 忽略包含在root中的dom引起的mouseOut
	                    if (element === this.dom) {
	                        return;
	                    }
	
	                    element = element.parentNode;
	                }
	            }
	
	            this.trigger('mouseout', event);
	        },
	
	        /**
	         * Touch开始响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchstart: function (event) {
	            // Default mouse behaviour should not be disabled here.
	            // For example, page may needs to be slided.
	            event = normalizeEvent(this.dom, event);
	
	            // Mark touch, which is useful in distinguish touch and
	            // mouse event in upper applicatoin.
	            event.zrByTouch = true;
	
	            this._lastTouchMoment = new Date();
	
	            processGesture(this, event, 'start');
	
	            // In touch device, trigger `mousemove`(`mouseover`) should
	            // be triggered, and must before `mousedown` triggered.
	            domHandlers.mousemove.call(this, event);
	
	            domHandlers.mousedown.call(this, event);
	
	            setTouchTimer(this);
	        },
	
	        /**
	         * Touch移动响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchmove: function (event) {
	
	            event = normalizeEvent(this.dom, event);
	
	            // Mark touch, which is useful in distinguish touch and
	            // mouse event in upper applicatoin.
	            event.zrByTouch = true;
	
	            processGesture(this, event, 'change');
	
	            // Mouse move should always be triggered no matter whether
	            // there is gestrue event, because mouse move and pinch may
	            // be used at the same time.
	            domHandlers.mousemove.call(this, event);
	
	            setTouchTimer(this);
	        },
	
	        /**
	         * Touch结束响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchend: function (event) {
	
	            event = normalizeEvent(this.dom, event);
	
	            // Mark touch, which is useful in distinguish touch and
	            // mouse event in upper applicatoin.
	            event.zrByTouch = true;
	
	            processGesture(this, event, 'end');
	
	            domHandlers.mouseup.call(this, event);
	
	            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
	            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,
	            // we can conveniently implement "hover style" in both PC and touch device just
	            // by listening to `mouseover` to add "hover style" and listening to `mouseout`
	            // to remove "hover style" on an element, without any additional code for
	            // compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
	            // style" will remain for user view)
	
	            // click event should always be triggered no matter whether
	            // there is gestrue event. System click can not be prevented.
	            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
	                domHandlers.click.call(this, event);
	            }
	
	            setTouchTimer(this);
	        },
	
	        pointerdown: function (event) {
	            domHandlers.mousedown.call(this, event);
	
	            // if (useMSGuesture(this, event)) {
	            //     this._msGesture.addPointer(event.pointerId);
	            // }
	        },
	
	        pointermove: function (event) {
	            // FIXME
	            // pointermove is so sensitive that it always triggered when
	            // tap(click) on touch screen, which affect some judgement in
	            // upper application. So, we dont support mousemove on MS touch
	            // device yet.
	            if (!isPointerFromTouch(event)) {
	                domHandlers.mousemove.call(this, event);
	            }
	        },
	
	        pointerup: function (event) {
	            domHandlers.mouseup.call(this, event);
	        },
	
	        pointerout: function (event) {
	            // pointerout will be triggered when tap on touch screen
	            // (IE11+/Edge on MS Surface) after click event triggered,
	            // which is inconsistent with the mousout behavior we defined
	            // in touchend. So we unify them.
	            // (check domHandlers.touchend for detailed explanation)
	            if (!isPointerFromTouch(event)) {
	                domHandlers.mouseout.call(this, event);
	            }
	        }
	    };
	
	    function isPointerFromTouch(event) {
	        var pointerType = event.pointerType;
	        return pointerType === 'pen' || pointerType === 'touch';
	    }
	
	    // function useMSGuesture(handlerProxy, event) {
	    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;
	    // }
	
	    // Common handlers
	    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
	        domHandlers[name] = function (event) {
	            event = normalizeEvent(this.dom, event);
	            this.trigger(name, event);
	        };
	    });
	
	    /**
	     * 为控制类实例初始化dom 事件处理函数
	     *
	     * @inner
	     * @param {module:zrender/Handler} instance 控制类实例
	     */
	    function initDomHandler(instance) {
	        zrUtil.each(touchHandlerNames, function (name) {
	            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	        });
	
	        zrUtil.each(pointerHandlerNames, function (name) {
	            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	        });
	
	        zrUtil.each(mouseHandlerNames, function (name) {
	            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
	        });
	
	        function makeMouseHandler(fn, instance) {
	            return function () {
	                if (instance._touching) {
	                    return;
	                }
	                return fn.apply(instance, arguments);
	            };
	        }
	    }
	
	
	    function HandlerDomProxy(dom) {
	        Eventful.call(this);
	
	        this.dom = dom;
	
	        /**
	         * @private
	         * @type {boolean}
	         */
	        this._touching = false;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._touchTimer;
	
	        /**
	         * @private
	         * @type {module:zrender/core/GestureMgr}
	         */
	        this._gestureMgr = new GestureMgr();
	
	        this._handlers = {};
	
	        initDomHandler(this);
	
	        if (env.pointerEventsSupported) { // Only IE11+/Edge
	            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),
	            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event
	            // at the same time.
	            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on
	            // screen, which do not occurs in pointer event.
	            // So we use pointer event to both detect touch gesture and mouse behavior.
	            mountHandlers(pointerHandlerNames, this);
	
	            // FIXME
	            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,
	            // which does not prevent defuault behavior occasionally (which may cause view port
	            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.
	            // So we have to not to use MSGesture and not to support touchmove and pinch on MS
	            // touch screen. And we only support click behavior on MS touch screen now.
	
	            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.
	            // We dont support touch on IE on win7.
	            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>
	            // if (typeof MSGesture === 'function') {
	            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line
	            //     dom.addEventListener('MSGestureChange', onMSGestureChange);
	            // }
	        }
	        else {
	            if (env.touchEventsSupported) {
	                mountHandlers(touchHandlerNames, this);
	                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
	                // addEventListener(root, 'mouseout', this._mouseoutHandler);
	            }
	
	            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface
	            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
	            // mouse event can not be handle in those devices.
	            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent
	            // mouseevent after touch event triggered, see `setTouchTimer`.
	            mountHandlers(mouseHandlerNames, this);
	        }
	
	        function mountHandlers(handlerNames, instance) {
	            zrUtil.each(handlerNames, function (name) {
	                addEventListener(dom, eventNameFix(name), instance._handlers[name]);
	            }, instance);
	        }
	    }
	
	    var handlerDomProxyProto = HandlerDomProxy.prototype;
	    handlerDomProxyProto.dispose = function () {
	        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);
	
	        for (var i = 0; i < handlerNames.length; i++) {
	            var name = handlerNames[i];
	            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
	        }
	    };
	
	    handlerDomProxyProto.setCursor = function (cursorStyle) {
	        this.dom.style.cursor = cursorStyle || 'default';
	    };
	
	    zrUtil.mixin(HandlerDomProxy, Eventful);
	
	    module.exports = HandlerDomProxy;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Only implements needed gestures for mobile.
	 */
	
	
	    var eventUtil = __webpack_require__(66);
	
	    var GestureMgr = function () {
	
	        /**
	         * @private
	         * @type {Array.<Object>}
	         */
	        this._track = [];
	    };
	
	    GestureMgr.prototype = {
	
	        constructor: GestureMgr,
	
	        recognize: function (event, target, root) {
	            this._doTrack(event, target, root);
	            return this._recognize(event);
	        },
	
	        clear: function () {
	            this._track.length = 0;
	            return this;
	        },
	
	        _doTrack: function (event, target, root) {
	            var touches = event.touches;
	
	            if (!touches) {
	                return;
	            }
	
	            var trackItem = {
	                points: [],
	                touches: [],
	                target: target,
	                event: event
	            };
	
	            for (var i = 0, len = touches.length; i < len; i++) {
	                var touch = touches[i];
	                var pos = eventUtil.clientToLocal(root, touch, {});
	                trackItem.points.push([pos.zrX, pos.zrY]);
	                trackItem.touches.push(touch);
	            }
	
	            this._track.push(trackItem);
	        },
	
	        _recognize: function (event) {
	            for (var eventName in recognizers) {
	                if (recognizers.hasOwnProperty(eventName)) {
	                    var gestureInfo = recognizers[eventName](this._track, event);
	                    if (gestureInfo) {
	                        return gestureInfo;
	                    }
	                }
	            }
	        }
	    };
	
	    function dist(pointPair) {
	        var dx = pointPair[1][0] - pointPair[0][0];
	        var dy = pointPair[1][1] - pointPair[0][1];
	
	        return Math.sqrt(dx * dx + dy * dy);
	    }
	
	    function center(pointPair) {
	        return [
	            (pointPair[0][0] + pointPair[1][0]) / 2,
	            (pointPair[0][1] + pointPair[1][1]) / 2
	        ];
	    }
	
	    var recognizers = {
	
	        pinch: function (track, event) {
	            var trackLen = track.length;
	
	            if (!trackLen) {
	                return;
	            }
	
	            var pinchEnd = (track[trackLen - 1] || {}).points;
	            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
	
	            if (pinchPre
	                && pinchPre.length > 1
	                && pinchEnd
	                && pinchEnd.length > 1
	            ) {
	                var pinchScale = dist(pinchEnd) / dist(pinchPre);
	                !isFinite(pinchScale) && (pinchScale = 1);
	
	                event.pinchScale = pinchScale;
	
	                var pinchCenter = center(pinchEnd);
	                event.pinchX = pinchCenter[0];
	                event.pinchY = pinchCenter[1];
	
	                return {
	                    type: 'pinch',
	                    target: track[0].target,
	                    event: event
	                };
	            }
	        }
	
	        // Only pinch currently.
	    };
	
	    module.exports = GestureMgr;
	


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Default canvas painter
	 * @module zrender/Painter
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	 
	
	    var config = __webpack_require__(22);
	    var util = __webpack_require__(4);
	    var log = __webpack_require__(21);
	    var BoundingRect = __webpack_require__(25);
	    var timsort = __webpack_require__(64);
	
	    var Layer = __webpack_require__(71);
	
	    var requestAnimationFrame = __webpack_require__(67);
	
	    // PENDIGN
	    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.
	    //
	    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.
	    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;
	
	    function parseInt10(val) {
	        return parseInt(val, 10);
	    }
	
	    function isLayerValid(layer) {
	        if (!layer) {
	            return false;
	        }
	
	        if (layer.__builtin__) {
	            return true;
	        }
	
	        if (typeof(layer.resize) !== 'function'
	            || typeof(layer.refresh) !== 'function'
	        ) {
	            return false;
	        }
	
	        return true;
	    }
	
	    function preProcessLayer(layer) {
	        layer.__unusedCount++;
	    }
	
	    function postProcessLayer(layer) {
	        if (layer.__unusedCount == 1) {
	            layer.clear();
	        }
	    }
	
	    var tmpRect = new BoundingRect(0, 0, 0, 0);
	    var viewRect = new BoundingRect(0, 0, 0, 0);
	    function isDisplayableCulled(el, width, height) {
	        tmpRect.copy(el.getBoundingRect());
	        if (el.transform) {
	            tmpRect.applyTransform(el.transform);
	        }
	        viewRect.width = width;
	        viewRect.height = height;
	        return !tmpRect.intersect(viewRect);
	    }
	
	    function isClipPathChanged(clipPaths, prevClipPaths) {
	        if (clipPaths == prevClipPaths) { // Can both be null or undefined
	            return false;
	        }
	
	        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {
	            return true;
	        }
	        for (var i = 0; i < clipPaths.length; i++) {
	            if (clipPaths[i] !== prevClipPaths[i]) {
	                return true;
	            }
	        }
	    }
	
	    function doClip(clipPaths, ctx) {
	        for (var i = 0; i < clipPaths.length; i++) {
	            var clipPath = clipPaths[i];
	            var path = clipPath.path;
	
	            clipPath.setTransform(ctx);
	            path.beginPath(ctx);
	            clipPath.buildPath(path, clipPath.shape);
	            ctx.clip();
	            // Transform back
	            clipPath.restoreTransform(ctx);
	        }
	    }
	
	    function createRoot(width, height) {
	        var domRoot = document.createElement('div');
	
	        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
	        domRoot.style.cssText = [
	            'position:relative',
	            'overflow:hidden',
	            'width:' + width + 'px',
	            'height:' + height + 'px',
	            'padding:0',
	            'margin:0',
	            'border-width:0'
	        ].join(';') + ';';
	
	        return domRoot;
	    }
	
	    /**
	     * @alias module:zrender/Painter
	     * @constructor
	     * @param {HTMLElement} root 绘图容器
	     * @param {module:zrender/Storage} storage
	     * @param {Ojbect} opts
	     */
	    var Painter = function (root, storage, opts) {
	        // In node environment using node-canvas
	        var singleCanvas = !root.nodeName // In node ?
	            || root.nodeName.toUpperCase() === 'CANVAS';
	
	        this._opts = opts = util.extend({}, opts || {});
	
	        /**
	         * @type {number}
	         */
	        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;
	        /**
	         * @type {boolean}
	         * @private
	         */
	        this._singleCanvas = singleCanvas;
	        /**
	         * 绘图容器
	         * @type {HTMLElement}
	         */
	        this.root = root;
	
	        var rootStyle = root.style;
	
	        if (rootStyle) {
	            rootStyle['-webkit-tap-highlight-color'] = 'transparent';
	            rootStyle['-webkit-user-select'] =
	            rootStyle['user-select'] =
	            rootStyle['-webkit-touch-callout'] = 'none';
	
	            root.innerHTML = '';
	        }
	
	        /**
	         * @type {module:zrender/Storage}
	         */
	        this.storage = storage;
	
	        /**
	         * @type {Array.<number>}
	         * @private
	         */
	        var zlevelList = this._zlevelList = [];
	
	        /**
	         * @type {Object.<string, module:zrender/Layer>}
	         * @private
	         */
	        var layers = this._layers = {};
	
	        /**
	         * @type {Object.<string, Object>}
	         * @type {private}
	         */
	        this._layerConfig = {};
	
	        if (!singleCanvas) {
	            this._width = this._getSize(0);
	            this._height = this._getSize(1);
	
	            var domRoot = this._domRoot = createRoot(
	                this._width, this._height
	            );
	            root.appendChild(domRoot);
	        }
	        else {
	            if (opts.width != null) {
	                root.width = opts.width;
	            }
	            if (opts.height != null) {
	                root.height = opts.height;
	            }
	            // Use canvas width and height directly
	            var width = root.width;
	            var height = root.height;
	            this._width = width;
	            this._height = height;
	
	            // Create layer if only one given canvas
	            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height
	            var mainLayer = new Layer(root, this, 1);
	            mainLayer.initContext();
	            // FIXME Use canvas width and height
	            // mainLayer.resize(width, height);
	            layers[0] = mainLayer;
	            zlevelList.push(0);
	
	            this._domRoot = root;
	        }
	
	        // Layers for progressive rendering
	        this._progressiveLayers = [];
	
	        /**
	         * @type {module:zrender/Layer}
	         * @private
	         */
	        this._hoverlayer;
	
	        this._hoverElements = [];
	    };
	
	    Painter.prototype = {
	
	        constructor: Painter,
	
	        /**
	         * If painter use a single canvas
	         * @return {boolean}
	         */
	        isSingleCanvas: function () {
	            return this._singleCanvas;
	        },
	        /**
	         * @return {HTMLDivElement}
	         */
	        getViewportRoot: function () {
	            return this._domRoot;
	        },
	
	        /**
	         * 刷新
	         * @param {boolean} [paintAll=false] 强制绘制所有displayable
	         */
	        refresh: function (paintAll) {
	
	            var list = this.storage.getDisplayList(true);
	
	            var zlevelList = this._zlevelList;
	
	            this._paintList(list, paintAll);
	
	            // Paint custum layers
	            for (var i = 0; i < zlevelList.length; i++) {
	                var z = zlevelList[i];
	                var layer = this._layers[z];
	                if (!layer.__builtin__ && layer.refresh) {
	                    layer.refresh();
	                }
	            }
	
	            this.refreshHover();
	
	            if (this._progressiveLayers.length) {
	                this._startProgessive();
	            }
	
	            return this;
	        },
	
	        addHover: function (el, hoverStyle) {
	            if (el.__hoverMir) {
	                return;
	            }
	            var elMirror = new el.constructor({
	                style: el.style,
	                shape: el.shape
	            });
	            elMirror.__from = el;
	            el.__hoverMir = elMirror;
	            elMirror.setStyle(hoverStyle);
	            this._hoverElements.push(elMirror);
	        },
	
	        removeHover: function (el) {
	            var elMirror = el.__hoverMir;
	            var hoverElements = this._hoverElements;
	            var idx = util.indexOf(hoverElements, elMirror);
	            if (idx >= 0) {
	                hoverElements.splice(idx, 1);
	            }
	            el.__hoverMir = null;
	        },
	
	        clearHover: function (el) {
	            var hoverElements = this._hoverElements;
	            for (var i = 0; i < hoverElements.length; i++) {
	                var from = hoverElements[i].__from;
	                if (from) {
	                    from.__hoverMir = null;
	                }
	            }
	            hoverElements.length = 0;
	        },
	
	        refreshHover: function () {
	            var hoverElements = this._hoverElements;
	            var len = hoverElements.length;
	            var hoverLayer = this._hoverlayer;
	            hoverLayer && hoverLayer.clear();
	
	            if (!len) {
	                return;
	            }
	            timsort(hoverElements, this.storage.displayableSortFunc);
	
	            // Use a extream large zlevel
	            // FIXME?
	            if (!hoverLayer) {
	                hoverLayer = this._hoverlayer = this.getLayer(1e5);
	            }
	
	            var scope = {};
	            hoverLayer.ctx.save();
	            for (var i = 0; i < len;) {
	                var el = hoverElements[i];
	                var originalEl = el.__from;
	                // Original el is removed
	                // PENDING
	                if (!(originalEl && originalEl.__zr)) {
	                    hoverElements.splice(i, 1);
	                    originalEl.__hoverMir = null;
	                    len--;
	                    continue;
	                }
	                i++;
	
	                // Use transform
	                // FIXME style and shape ?
	                if (!originalEl.invisible) {
	                    el.transform = originalEl.transform;
	                    el.invTransform = originalEl.invTransform;
	                    el.__clipPaths = originalEl.__clipPaths;
	                    // el.
	                    this._doPaintEl(el, hoverLayer, true, scope);
	                }
	            }
	            hoverLayer.ctx.restore();
	        },
	
	        _startProgessive: function () {
	            var self = this;
	
	            if (!self._furtherProgressive) {
	                return;
	            }
	
	            // Use a token to stop progress steps triggered by
	            // previous zr.refresh calling.
	            var token = self._progressiveToken = +new Date();
	
	            self._progress++;
	            requestAnimationFrame(step);
	
	            function step() {
	                // In case refreshed or disposed
	                if (token === self._progressiveToken && self.storage) {
	
	                    self._doPaintList(self.storage.getDisplayList());
	
	                    if (self._furtherProgressive) {
	                        self._progress++;
	                        requestAnimationFrame(step);
	                    }
	                    else {
	                        self._progressiveToken = -1;
	                    }
	                }
	            }
	        },
	
	        _clearProgressive: function () {
	            this._progressiveToken = -1;
	            this._progress = 0;
	            util.each(this._progressiveLayers, function (layer) {
	                layer.__dirty && layer.clear();
	            });
	        },
	
	        _paintList: function (list, paintAll) {
	
	            if (paintAll == null) {
	                paintAll = false;
	            }
	
	            this._updateLayerStatus(list);
	
	            this._clearProgressive();
	
	            this.eachBuiltinLayer(preProcessLayer);
	
	            this._doPaintList(list, paintAll);
	
	            this.eachBuiltinLayer(postProcessLayer);
	        },
	
	        _doPaintList: function (list, paintAll) {
	            var currentLayer;
	            var currentZLevel;
	            var ctx;
	
	            // var invTransform = [];
	            var scope;
	
	            var progressiveLayerIdx = 0;
	            var currentProgressiveLayer;
	
	            var width = this._width;
	            var height = this._height;
	            var layerProgress;
	            var frame = this._progress;
	            function flushProgressiveLayer(layer) {
	                var dpr = ctx.dpr || 1;
	                ctx.save();
	                ctx.globalAlpha = 1;
	                ctx.shadowBlur = 0;
	                // Avoid layer don't clear in next progressive frame
	                currentLayer.__dirty = true;
	                ctx.setTransform(1, 0, 0, 1, 0, 0);
	                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);
	                ctx.restore();
	            }
	
	            for (var i = 0, l = list.length; i < l; i++) {
	                var el = list[i];
	                var elZLevel = this._singleCanvas ? 0 : el.zlevel;
	
	                var elFrame = el.__frame;
	
	                // Flush at current context
	                // PENDING
	                if (elFrame < 0 && currentProgressiveLayer) {
	                    flushProgressiveLayer(currentProgressiveLayer);
	                    currentProgressiveLayer = null;
	                }
	
	                // Change draw layer
	                if (currentZLevel !== elZLevel) {
	                    if (ctx) {
	                        ctx.restore();
	                    }
	
	                    // Reset scope
	                    scope = {};
	
	                    // Only 0 zlevel if only has one canvas
	                    currentZLevel = elZLevel;
	                    currentLayer = this.getLayer(currentZLevel);
	
	                    if (!currentLayer.__builtin__) {
	                        log(
	                            'ZLevel ' + currentZLevel
	                            + ' has been used by unkown layer ' + currentLayer.id
	                        );
	                    }
	
	                    ctx = currentLayer.ctx;
	                    ctx.save();
	
	                    // Reset the count
	                    currentLayer.__unusedCount = 0;
	
	                    if (currentLayer.__dirty || paintAll) {
	                        currentLayer.clear();
	                    }
	                }
	
	                if (!(currentLayer.__dirty || paintAll)) {
	                    continue;
	                }
	
	                if (elFrame >= 0) {
	                    // Progressive layer changed
	                    if (!currentProgressiveLayer) {
	                        currentProgressiveLayer = this._progressiveLayers[
	                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)
	                        ];
	
	                        currentProgressiveLayer.ctx.save();
	                        currentProgressiveLayer.renderScope = {};
	
	                        if (currentProgressiveLayer
	                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)
	                        ) {
	                            // flushProgressiveLayer(currentProgressiveLayer);
	                            // Quick jump all progressive elements
	                            // All progressive element are not dirty, jump over and flush directly
	                            i = currentProgressiveLayer.__nextIdxNotProg - 1;
	                            // currentProgressiveLayer = null;
	                            continue;
	                        }
	
	                        layerProgress = currentProgressiveLayer.__progress;
	
	                        if (!currentProgressiveLayer.__dirty) {
	                            // Keep rendering
	                            frame = layerProgress;
	                        }
	
	                        currentProgressiveLayer.__progress = frame + 1;
	                    }
	
	                    if (elFrame === frame) {
	                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
	                    }
	                }
	                else {
	                    this._doPaintEl(el, currentLayer, paintAll, scope);
	                }
	
	                el.__dirty = false;
	            }
	
	            if (currentProgressiveLayer) {
	                flushProgressiveLayer(currentProgressiveLayer);
	            }
	
	            // Restore the lastLayer ctx
	            ctx && ctx.restore();
	            // If still has clipping state
	            // if (scope.prevElClipPaths) {
	            //     ctx.restore();
	            // }
	
	            this._furtherProgressive = false;
	            util.each(this._progressiveLayers, function (layer) {
	                if (layer.__maxProgress >= layer.__progress) {
	                    this._furtherProgressive = true;
	                }
	            }, this);
	        },
	
	        _doPaintEl: function (el, currentLayer, forcePaint, scope) {
	            var ctx = currentLayer.ctx;
	            var m = el.transform;
	            if (
	                (currentLayer.__dirty || forcePaint)
	                // Ignore invisible element
	                && !el.invisible
	                // Ignore transparent element
	                && el.style.opacity !== 0
	                // Ignore scale 0 element, in some environment like node-canvas
	                // Draw a scale 0 element can cause all following draw wrong
	                // And setTransform with scale 0 will cause set back transform failed.
	                && !(m && !m[0] && !m[3])
	                // Ignore culled element
	                && !(el.culling && isDisplayableCulled(el, this._width, this._height))
	            ) {
	
	                var clipPaths = el.__clipPaths;
	
	                // Optimize when clipping on group with several elements
	                if (scope.prevClipLayer !== currentLayer
	                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)
	                ) {
	                    // If has previous clipping state, restore from it
	                    if (scope.prevElClipPaths) {
	                        scope.prevClipLayer.ctx.restore();
	                        scope.prevClipLayer = scope.prevElClipPaths = null;
	
	                        // Reset prevEl since context has been restored
	                        scope.prevEl = null;
	                    }
	                    // New clipping state
	                    if (clipPaths) {
	                        ctx.save();
	                        doClip(clipPaths, ctx);
	                        scope.prevClipLayer = currentLayer;
	                        scope.prevElClipPaths = clipPaths;
	                    }
	                }
	                el.beforeBrush && el.beforeBrush(ctx);
	
	                el.brush(ctx, scope.prevEl || null);
	                scope.prevEl = el;
	
	                el.afterBrush && el.afterBrush(ctx);
	            }
	        },
	
	        /**
	         * 获取 zlevel 所在层，如果不存在则会创建一个新的层
	         * @param {number} zlevel
	         * @return {module:zrender/Layer}
	         */
	        getLayer: function (zlevel) {
	            if (this._singleCanvas) {
	                return this._layers[0];
	            }
	
	            var layer = this._layers[zlevel];
	            if (!layer) {
	                // Create a new layer
	                layer = new Layer('zr_' + zlevel, this, this.dpr);
	                layer.__builtin__ = true;
	
	                if (this._layerConfig[zlevel]) {
	                    util.merge(layer, this._layerConfig[zlevel], true);
	                }
	
	                this.insertLayer(zlevel, layer);
	
	                // Context is created after dom inserted to document
	                // Or excanvas will get 0px clientWidth and clientHeight
	                layer.initContext();
	            }
	
	            return layer;
	        },
	
	        insertLayer: function (zlevel, layer) {
	
	            var layersMap = this._layers;
	            var zlevelList = this._zlevelList;
	            var len = zlevelList.length;
	            var prevLayer = null;
	            var i = -1;
	            var domRoot = this._domRoot;
	
	            if (layersMap[zlevel]) {
	                log('ZLevel ' + zlevel + ' has been used already');
	                return;
	            }
	            // Check if is a valid layer
	            if (!isLayerValid(layer)) {
	                log('Layer of zlevel ' + zlevel + ' is not valid');
	                return;
	            }
	
	            if (len > 0 && zlevel > zlevelList[0]) {
	                for (i = 0; i < len - 1; i++) {
	                    if (
	                        zlevelList[i] < zlevel
	                        && zlevelList[i + 1] > zlevel
	                    ) {
	                        break;
	                    }
	                }
	                prevLayer = layersMap[zlevelList[i]];
	            }
	            zlevelList.splice(i + 1, 0, zlevel);
	
	            layersMap[zlevel] = layer;
	
	            // Vitual layer will not directly show on the screen.
	            // (It can be a WebGL layer and assigned to a ZImage element)
	            // But it still under management of zrender.
	            if (!layer.virtual) {
	                if (prevLayer) {
	                    var prevDom = prevLayer.dom;
	                    if (prevDom.nextSibling) {
	                        domRoot.insertBefore(
	                            layer.dom,
	                            prevDom.nextSibling
	                        );
	                    }
	                    else {
	                        domRoot.appendChild(layer.dom);
	                    }
	                }
	                else {
	                    if (domRoot.firstChild) {
	                        domRoot.insertBefore(layer.dom, domRoot.firstChild);
	                    }
	                    else {
	                        domRoot.appendChild(layer.dom);
	                    }
	                }
	            }
	        },
	
	        // Iterate each layer
	        eachLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                cb.call(context, this._layers[z], z);
	            }
	        },
	
	        // Iterate each buildin layer
	        eachBuiltinLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var layer;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                layer = this._layers[z];
	                if (layer.__builtin__) {
	                    cb.call(context, layer, z);
	                }
	            }
	        },
	
	        // Iterate each other layer except buildin layer
	        eachOtherLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var layer;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                layer = this._layers[z];
	                if (!layer.__builtin__) {
	                    cb.call(context, layer, z);
	                }
	            }
	        },
	
	        /**
	         * 获取所有已创建的层
	         * @param {Array.<module:zrender/Layer>} [prevLayer]
	         */
	        getLayers: function () {
	            return this._layers;
	        },
	
	        _updateLayerStatus: function (list) {
	
	            var layers = this._layers;
	            var progressiveLayers = this._progressiveLayers;
	
	            var elCountsLastFrame = {};
	            var progressiveElCountsLastFrame = {};
	
	            this.eachBuiltinLayer(function (layer, z) {
	                elCountsLastFrame[z] = layer.elCount;
	                layer.elCount = 0;
	                layer.__dirty = false;
	            });
	
	            util.each(progressiveLayers, function (layer, idx) {
	                progressiveElCountsLastFrame[idx] = layer.elCount;
	                layer.elCount = 0;
	                layer.__dirty = false;
	            });
	
	            var progressiveLayerCount = 0;
	            var currentProgressiveLayer;
	            var lastProgressiveKey;
	            var frameCount = 0;
	            for (var i = 0, l = list.length; i < l; i++) {
	                var el = list[i];
	                var zlevel = this._singleCanvas ? 0 : el.zlevel;
	                var layer = layers[zlevel];
	                var elProgress = el.progressive;
	                if (layer) {
	                    layer.elCount++;
	                    layer.__dirty = layer.__dirty || el.__dirty;
	                }
	
	                /////// Update progressive
	                if (elProgress >= 0) {
	                    // Fix wrong progressive sequence problem.
	                    if (lastProgressiveKey !== elProgress) {
	                        lastProgressiveKey = elProgress;
	                        frameCount++;
	                    }
	                    var elFrame = el.__frame = frameCount - 1;
	                    if (!currentProgressiveLayer) {
	                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
	                        currentProgressiveLayer = progressiveLayers[idx];
	                        if (!currentProgressiveLayer) {
	                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(
	                                'progressive', this, this.dpr
	                            );
	                            currentProgressiveLayer.initContext();
	                        }
	                        currentProgressiveLayer.__maxProgress = 0;
	                    }
	                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
	                    currentProgressiveLayer.elCount++;
	
	                    currentProgressiveLayer.__maxProgress = Math.max(
	                        currentProgressiveLayer.__maxProgress, elFrame
	                    );
	
	                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
	                        // Should keep rendering this  layer because progressive rendering is not finished yet
	                        layer.__dirty = true;
	                    }
	                }
	                else {
	                    el.__frame = -1;
	
	                    if (currentProgressiveLayer) {
	                        currentProgressiveLayer.__nextIdxNotProg = i;
	                        progressiveLayerCount++;
	                        currentProgressiveLayer = null;
	                    }
	                }
	            }
	
	            if (currentProgressiveLayer) {
	                progressiveLayerCount++;
	                currentProgressiveLayer.__nextIdxNotProg = i;
	            }
	
	            // 层中的元素数量有发生变化
	            this.eachBuiltinLayer(function (layer, z) {
	                if (elCountsLastFrame[z] !== layer.elCount) {
	                    layer.__dirty = true;
	                }
	            });
	
	            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
	            util.each(progressiveLayers, function (layer, idx) {
	                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
	                    el.__dirty = true;
	                }
	                if (layer.__dirty) {
	                    layer.__progress = 0;
	                }
	            });
	        },
	
	        /**
	         * 清除hover层外所有内容
	         */
	        clear: function () {
	            this.eachBuiltinLayer(this._clearLayer);
	            return this;
	        },
	
	        _clearLayer: function (layer) {
	            layer.clear();
	        },
	
	        /**
	         * 修改指定zlevel的绘制参数
	         *
	         * @param {string} zlevel
	         * @param {Object} config 配置对象
	         * @param {string} [config.clearColor=0] 每次清空画布的颜色
	         * @param {string} [config.motionBlur=false] 是否开启动态模糊
	         * @param {number} [config.lastFrameAlpha=0.7]
	         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	         */
	        configLayer: function (zlevel, config) {
	            if (config) {
	                var layerConfig = this._layerConfig;
	                if (!layerConfig[zlevel]) {
	                    layerConfig[zlevel] = config;
	                }
	                else {
	                    util.merge(layerConfig[zlevel], config, true);
	                }
	
	                var layer = this._layers[zlevel];
	
	                if (layer) {
	                    util.merge(layer, layerConfig[zlevel], true);
	                }
	            }
	        },
	
	        /**
	         * 删除指定层
	         * @param {number} zlevel 层所在的zlevel
	         */
	        delLayer: function (zlevel) {
	            var layers = this._layers;
	            var zlevelList = this._zlevelList;
	            var layer = layers[zlevel];
	            if (!layer) {
	                return;
	            }
	            layer.dom.parentNode.removeChild(layer.dom);
	            delete layers[zlevel];
	
	            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
	        },
	
	        /**
	         * 区域大小变化后重绘
	         */
	        resize: function (width, height) {
	            var domRoot = this._domRoot;
	            // FIXME Why ?
	            domRoot.style.display = 'none';
	
	            // Save input w/h
	            var opts = this._opts;
	            width != null && (opts.width = width);
	            height != null && (opts.height = height);
	
	            width = this._getSize(0);
	            height = this._getSize(1);
	
	            domRoot.style.display = '';
	
	            // 优化没有实际改变的resize
	            if (this._width != width || height != this._height) {
	                domRoot.style.width = width + 'px';
	                domRoot.style.height = height + 'px';
	
	                for (var id in this._layers) {
	                    if (this._layers.hasOwnProperty(id)) {
	                        this._layers[id].resize(width, height);
	                    }
	                }
	                util.each(this._progressiveLayers, function (layer) {
	                    layer.resize(width, height);
	                });
	
	                this.refresh(true);
	            }
	
	            this._width = width;
	            this._height = height;
	
	            return this;
	        },
	
	        /**
	         * 清除单独的一个层
	         * @param {number} zlevel
	         */
	        clearLayer: function (zlevel) {
	            var layer = this._layers[zlevel];
	            if (layer) {
	                layer.clear();
	            }
	        },
	
	        /**
	         * 释放
	         */
	        dispose: function () {
	            this.root.innerHTML = '';
	
	            this.root =
	            this.storage =
	
	            this._domRoot =
	            this._layers = null;
	        },
	
	        /**
	         * Get canvas which has all thing rendered
	         * @param {Object} opts
	         * @param {string} [opts.backgroundColor]
	         */
	        getRenderedCanvas: function (opts) {
	            opts = opts || {};
	            if (this._singleCanvas) {
	                return this._layers[0].dom;
	            }
	
	            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
	            imageLayer.initContext();
	
	            imageLayer.clearColor = opts.backgroundColor;
	            imageLayer.clear();
	
	            var displayList = this.storage.getDisplayList(true);
	
	            var scope = {};
	            for (var i = 0; i < displayList.length; i++) {
	                var el = displayList[i];
	                this._doPaintEl(el, imageLayer, true, scope);
	            }
	
	            return imageLayer.dom;
	        },
	        /**
	         * 获取绘图区域宽度
	         */
	        getWidth: function () {
	            return this._width;
	        },
	
	        /**
	         * 获取绘图区域高度
	         */
	        getHeight: function () {
	            return this._height;
	        },
	
	        _getSize: function (whIdx) {
	            var opts = this._opts;
	            var wh = ['width', 'height'][whIdx];
	            var cwh = ['clientWidth', 'clientHeight'][whIdx];
	            var plt = ['paddingLeft', 'paddingTop'][whIdx];
	            var prb = ['paddingRight', 'paddingBottom'][whIdx];
	
	            if (opts[wh] != null && opts[wh] !== 'auto') {
	                return parseFloat(opts[wh]);
	            }
	
	            var root = this.root;
	            var stl = document.defaultView.getComputedStyle(root);
	
	            return (
	                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))
	                - (parseInt10(stl[plt]) || 0)
	                - (parseInt10(stl[prb]) || 0)
	            ) | 0;
	        },
	
	        pathToImage: function (path, dpr) {
	            dpr = dpr || this.dpr;
	
	            var canvas = document.createElement('canvas');
	            var ctx = canvas.getContext('2d');
	            var rect = path.getBoundingRect();
	            var style = path.style;
	            var shadowBlurSize = style.shadowBlur;
	            var shadowOffsetX = style.shadowOffsetX;
	            var shadowOffsetY = style.shadowOffsetY;
	            var lineWidth = style.hasStroke() ? style.lineWidth : 0;
	
	            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
	            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
	            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
	            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
	            var width = rect.width + leftMargin + rightMargin;
	            var height = rect.height + topMargin + bottomMargin;
	
	            canvas.width = width * dpr;
	            canvas.height = height * dpr;
	
	            ctx.scale(dpr, dpr);
	            ctx.clearRect(0, 0, width, height);
	            ctx.dpr = dpr;
	
	            var pathTransform = {
	                position: path.position,
	                rotation: path.rotation,
	                scale: path.scale
	            };
	            path.position = [leftMargin - rect.x, topMargin - rect.y];
	            path.rotation = 0;
	            path.scale = [1, 1];
	            path.updateTransform();
	            if (path) {
	                path.brush(ctx);
	            }
	
	            var ImageShape = __webpack_require__(41);
	            var imgShape = new ImageShape({
	                style: {
	                    x: 0,
	                    y: 0,
	                    image: canvas
	                }
	            });
	
	            if (pathTransform.position != null) {
	                imgShape.position = path.position = pathTransform.position;
	            }
	
	            if (pathTransform.rotation != null) {
	                imgShape.rotation = path.rotation = pathTransform.rotation;
	            }
	
	            if (pathTransform.scale != null) {
	                imgShape.scale = path.scale = pathTransform.scale;
	            }
	
	            return imgShape;
	        }
	    };
	
	    module.exports = Painter;
	


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module zrender/Layer
	 * @author pissang(https://www.github.com/pissang)
	 */
	
	
	    var util = __webpack_require__(4);
	    var config = __webpack_require__(22);
	    var Style = __webpack_require__(8);
	    var Pattern = __webpack_require__(36);
	
	    function returnFalse() {
	        return false;
	    }
	
	    /**
	     * 创建dom
	     *
	     * @inner
	     * @param {string} id dom id 待用
	     * @param {string} type dom type，such as canvas, div etc.
	     * @param {Painter} painter painter instance
	     * @param {number} number
	     */
	    function createDom(id, type, painter, dpr) {
	        var newDom = document.createElement(type);
	        var width = painter.getWidth();
	        var height = painter.getHeight();
	
	        var newDomStyle = newDom.style;
	        // 没append呢，请原谅我这样写，清晰~
	        newDomStyle.position = 'absolute';
	        newDomStyle.left = 0;
	        newDomStyle.top = 0;
	        newDomStyle.width = width + 'px';
	        newDomStyle.height = height + 'px';
	        newDom.width = width * dpr;
	        newDom.height = height * dpr;
	
	        // id不作为索引用，避免可能造成的重名，定义为私有属性
	        newDom.setAttribute('data-zr-dom-id', id);
	        return newDom;
	    }
	
	    /**
	     * @alias module:zrender/Layer
	     * @constructor
	     * @extends module:zrender/mixin/Transformable
	     * @param {string} id
	     * @param {module:zrender/Painter} painter
	     * @param {number} [dpr]
	     */
	    var Layer = function(id, painter, dpr) {
	        var dom;
	        dpr = dpr || config.devicePixelRatio;
	        if (typeof id === 'string') {
	            dom = createDom(id, 'canvas', painter, dpr);
	        }
	        // Not using isDom because in node it will return false
	        else if (util.isObject(id)) {
	            dom = id;
	            id = dom.id;
	        }
	        this.id = id;
	        this.dom = dom;
	
	        var domStyle = dom.style;
	        if (domStyle) { // Not in node
	            dom.onselectstart = returnFalse; // 避免页面选中的尴尬
	            domStyle['-webkit-user-select'] = 'none';
	            domStyle['user-select'] = 'none';
	            domStyle['-webkit-touch-callout'] = 'none';
	            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
	            domStyle['padding'] = 0;
	            domStyle['margin'] = 0;
	            domStyle['border-width'] = 0;
	        }
	
	        this.domBack = null;
	        this.ctxBack = null;
	
	        this.painter = painter;
	
	        this.config = null;
	
	        // Configs
	        /**
	         * 每次清空画布的颜色
	         * @type {string}
	         * @default 0
	         */
	        this.clearColor = 0;
	        /**
	         * 是否开启动态模糊
	         * @type {boolean}
	         * @default false
	         */
	        this.motionBlur = false;
	        /**
	         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	         * @type {number}
	         * @default 0.7
	         */
	        this.lastFrameAlpha = 0.7;
	
	        /**
	         * Layer dpr
	         * @type {number}
	         */
	        this.dpr = dpr;
	    };
	
	    Layer.prototype = {
	
	        constructor: Layer,
	
	        elCount: 0,
	
	        __dirty: true,
	
	        initContext: function () {
	            this.ctx = this.dom.getContext('2d');
	
	            this.ctx.dpr = this.dpr;
	        },
	
	        createBackBuffer: function () {
	            var dpr = this.dpr;
	
	            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);
	            this.ctxBack = this.domBack.getContext('2d');
	
	            if (dpr != 1) {
	                this.ctxBack.scale(dpr, dpr);
	            }
	        },
	
	        /**
	         * @param  {number} width
	         * @param  {number} height
	         */
	        resize: function (width, height) {
	            var dpr = this.dpr;
	
	            var dom = this.dom;
	            var domStyle = dom.style;
	            var domBack = this.domBack;
	
	            domStyle.width = width + 'px';
	            domStyle.height = height + 'px';
	
	            dom.width = width * dpr;
	            dom.height = height * dpr;
	
	            if (domBack) {
	                domBack.width = width * dpr;
	                domBack.height = height * dpr;
	
	                if (dpr != 1) {
	                    this.ctxBack.scale(dpr, dpr);
	                }
	            }
	        },
	
	        /**
	         * 清空该层画布
	         * @param {boolean} clearAll Clear all with out motion blur
	         */
	        clear: function (clearAll) {
	            var dom = this.dom;
	            var ctx = this.ctx;
	            var width = dom.width;
	            var height = dom.height;
	
	            var clearColor = this.clearColor;
	            var haveMotionBLur = this.motionBlur && !clearAll;
	            var lastFrameAlpha = this.lastFrameAlpha;
	
	            var dpr = this.dpr;
	
	            if (haveMotionBLur) {
	                if (!this.domBack) {
	                    this.createBackBuffer();
	                }
	
	                this.ctxBack.globalCompositeOperation = 'copy';
	                this.ctxBack.drawImage(
	                    dom, 0, 0,
	                    width / dpr,
	                    height / dpr
	                );
	            }
	
	            ctx.clearRect(0, 0, width, height);
	            if (clearColor) {
	                var clearColorGradientOrPattern;
	                // Gradient
	                if (clearColor.colorStops) {
	                    // Cache canvas gradient
	                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
	                        x: 0,
	                        y: 0,
	                        width: width,
	                        height: height
	                    });
	
	                    clearColor.__canvasGradient = clearColorGradientOrPattern;
	                }
	                // Pattern
	                else if (clearColor.image) {
	                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
	                }
	                ctx.save();
	                ctx.fillStyle = clearColorGradientOrPattern || clearColor;
	                ctx.fillRect(0, 0, width, height);
	                ctx.restore();
	            }
	
	            if (haveMotionBLur) {
	                var domBack = this.domBack;
	                ctx.save();
	                ctx.globalAlpha = lastFrameAlpha;
	                ctx.drawImage(domBack, 0, 0, width, height);
	                ctx.restore();
	            }
	        }
	    };
	
	    module.exports = Layer;


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var util = __webpack_require__(73);
	    var BPMNNode = __webpack_require__(75);
	    var BPMNModel = __webpack_require__(78);
	    var StartEventNode = __webpack_require__(80);
	    var EndEventNode = __webpack_require__(82);
	    var UserTaskNode = __webpack_require__(83);
	    var ManualTaskNode = __webpack_require__(85);
	    var ScriptTaskNode = __webpack_require__(86);
	    var MailTaskNode = __webpack_require__(87);
	    var CatchTimerEventNode = __webpack_require__(88);
	    var CatchSignalEventNode = __webpack_require__(89);
	    var ThrowSignalEventNode = __webpack_require__(90);
	    var InclusiveGatewayNode = __webpack_require__(91);
	    var ExclusiveGatewayNode = __webpack_require__(93);
	    var ParallelGatewayNode = __webpack_require__(94);
	    var SubPrcessNode = __webpack_require__(95);
	    var Bpmn = __webpack_require__(101);
	    /**
	     * 根据结点数组 导出JSON格式的数据
	     *
	     * @param {Array} nodes 结点数组
	     * @param {String} bpmnModel bpmn的model
	     * @param {Array} connectors 所有连线
	     * @return {JSON} JSON格式的数据
	     */
	    function toJson(bpmnModel, nodes, connectors) {
	        var jsonArr = [];
	        for(var i = 0; i < nodes.length;i++){
	            var node = nodes[i];
	            //去掉子流程里面的节点
	            if (node.parent && Bpmn.isSubProcess(node.parent)) {
	                continue;
	            }
	            if( node && node.toJSON) {
	                jsonArr.push(node.toJSON());
	            }
	        }
	        //增加线
	        for(var j = 0; j < connectors.length;j++){
	            var connector = connectors[j];
	            //去掉子流程里面的线段
	            if (connector.parent && Bpmn.isSubProcess(connector.parent)) {
	                continue;
	            }
	            if( connector && connector.toJSON) {
	                jsonArr.push(connector.toJSON());
	            }
	        }
	        bpmnModel.set("childShapes", jsonArr);
	
	
	        return bpmnModel.option;
	    }
	
	    /**
	     * 根据 JSON 生成节点
	     * @param  {[type]} fishTopoBpmn [description]
	     * @param  {[type]} json         [description]
	     * @return {[type]}              [description]
	     */
	    function fromJson(fishTopoBpmn, json) {
	        // 1.清空画布
	        fishTopoBpmn.clear(true);
	
	        // 2.先创建节点  遍历形状 获取模型
	        var bpmnModel = new BPMNModel(json);
	
	        fishTopoBpmn.model = bpmnModel;
	
	        var bpmnWidth = bpmnModel.get("properties.width");
	        var bpmnHeight = bpmnModel.get("properties.height");
	        if (bpmnWidth > 0 && bpmnHeight > 0) {
	            fishTopoBpmn.resize(bpmnWidth,bpmnHeight);
	        }
	
	        var childShapes = bpmnModel.get("childShapes");
	        var connectors = [];
	        for (var i = 0; i < childShapes.length; i++) {
	            var shape = childShapes[i];
	            var type = shape.stencil.type;
	
	
	            if (type === Bpmn.SEQUENCE_FLOW) {
	                connectors.push(shape);
	            } else {
	                var model = new BPMNModel(shape);
	                var createdNode = fishTopoBpmn.addNodeByModel(model,false,true);
	
	                 if (type === Bpmn.SUB_PROCESS) {
	                    var subNode = model.get("childShapes");
	                    for (var j = 0; j < subNode.length; j++) {
	
	                        var subModel = new BPMNModel(subNode[j]);
	                        if(Bpmn.isFlowModel(subModel)) {
	                            fishTopoBpmn.addConnectorByModel(subModel, createdNode);
	                        } else {
	                            var superUpperLeft = model.get("bounds.upperLeft");
	                            var subUpperLeft = subModel.get("bounds.upperLeft");
	                            subModel.set("bounds.upperLeft", { x: subUpperLeft.x + superUpperLeft.x, y: subUpperLeft.y + superUpperLeft.y });
	                            fishTopoBpmn.addNodeByModel(subModel,true,true);
	                        }
	
	                    }
	                 }
	            }
	        }
	
	        // 3. 再创建线
	        for(var k = 0, len = connectors.length; k < len; k++) {
	            var modelLine = new BPMNModel(connectors[k]); // shape
	            fishTopoBpmn.addConnectorByModel(modelLine);
	        }
	
	        // 4.创建事件插槽
	        for (var m = 0; m < childShapes.length; m++) {
	            if (childShapes[m].properties.slotEvent) {
	                for(var n = 0;n < childShapes[m].properties.slotEvent.length; n++){
	                    findNodeById(fishTopoBpmn,childShapes[m].resourceId).slotEvent.push(findNodeById(fishTopoBpmn,childShapes[m].properties.slotEvent[n]))
	                }
	            }
	
	        }
	
	    }
	
	    /**
	     * 根据id在fishTopoBpmn中查找
	     * @param  {[type]} fishTopoBpmn  [description]
	     * @param  {[type]} nodeId [description]
	     * @return {[type]}        [description]
	     */
	    function findNodeById(fishTopoBpmn, nodeId) {
	        var node;
	        for (var i = fishTopoBpmn.allNodes.length - 1; i >= 0; i--) {
	            if (fishTopoBpmn.allNodes[i].model.get("resourceId") == nodeId) {
	                node = fishTopoBpmn.allNodes[i];
	            }
	        }
	        return node;
	    }
	
	
	
	    function registerBPMNNode () {
	        BPMNNode.registerClass(StartEventNode, "StartNoneEvent");
	        BPMNNode.registerClass(EndEventNode, "EndNoneEvent");
	        BPMNNode.registerClass(UserTaskNode, "UserTask");
	        BPMNNode.registerClass(ManualTaskNode, "ManualTask");
	        BPMNNode.registerClass(ScriptTaskNode, "ScriptTask");
	        BPMNNode.registerClass(MailTaskNode, "MailTask");
	        BPMNNode.registerClass(CatchTimerEventNode, "CatchTimerEvent");
	        BPMNNode.registerClass(CatchSignalEventNode, "CatchSignalEvent");
	        BPMNNode.registerClass(ThrowSignalEventNode, "ThrowSignalEvent");
	        BPMNNode.registerClass(InclusiveGatewayNode, "InclusiveGateway");
	        BPMNNode.registerClass(ExclusiveGatewayNode, "ExclusiveGateway");
	        BPMNNode.registerClass(ParallelGatewayNode, "ParallelGateway");
	        BPMNNode.registerClass(SubPrcessNode, "SubProcess");
	    }
	
	
	    function isHover(node, x, y) {
	        var cx , cy;
	        if(node.parent){
	            if(node.parent.model.get("stencil.type") == "SubProcess"){
	                cx = x - node.parent.getRect().boundingRect.x;
	                cy = y - node.parent.getRect().boundingRect.y;
	                return node.rectContain(cx, cy)
	            }
	        }else{
	            return node.rectContain(x, y);
	        }
	
	     }
	
	    function findHover(list, x, y, excludes) {
	        for (var i = list.length - 1; i >= 0 ; i--) {
	            if (isExclude(excludes,list[i]) //list[i] !== exclude
	             // getDisplayList may include ignored item in VML mode
	             && !list[i].ignore
	             && isHover(list[i], x, y)) {
	                return list[i];
	            }
	        }
	    }
	
	
	    function isExclude(excludes, node) {
	        return zrUtil.indexOf(excludes,node) == -1;
	     }
	
	
	
	
	    var BpmnUtil = {
	        toJson: toJson,
	        fromJson: fromJson,
	        registerBPMNNode: registerBPMNNode,
	        findHover: findHover
	    };
	    module.exports = BpmnUtil;
	


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 工具方法类
	 * @author wang.xiaohu
	 */
	
	    var Point = __webpack_require__(60);
	    var Line = __webpack_require__(74);
	    var graphic = __webpack_require__(3);
	    var BoundingRect = __webpack_require__(25);
	    var zrUtil = __webpack_require__(4);
	    /**
	     * 构造类继承关系
	     *
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
	    function inherits(clazz, baseClazz) {
	        var clazzPrototype = clazz.prototype;
	
	        function F() {}
	        F.prototype = baseClazz.prototype;
	        clazz.prototype = new F();
	
	        for (var prop in clazzPrototype) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	        clazz.prototype.constructor = clazz;
	        clazz.superClass = baseClazz;
	    }
	
	    function getUUID() {
	        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),
	            uuid = new Array(36),
	            rnd = 0,
	            r;
	        for (var i = 0; i < 36; i++) {
	            if (i == 8 || i == 13 || i == 18 || i == 23) {
	                uuid[i] = '-';
	            } else if (i == 14) {
	                uuid[i] = '4';
	            } else {
	                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
	                r = rnd & 0xf;
	                rnd = rnd >> 4;
	                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
	            }
	        }
	        return "sid-" + uuid.join('');
	    }
	
	
	    /**
	     * 计算两点之间的距离
	     *@param {Point} p1 - first {Point}
	     *@param {Point} p2 - second {Point}
	     *@return {Number} - the distance between those 2 points. It is always positive.
	     **/
	    function distance(p1, p2) {
	        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
	    }
	
	    /**
	     * 返回一条折线 最长的两个点
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    function getMaxLineLength(points) {
	        var m = distance(points[0], points[1]);
	        var result = [points[0], points[1]];
	        for (var i = 1; i < points.length - 1; i++) {
	
	            if (m < distance(points[i], points[i + 1])) {
	                m = distance(points[i], points[i + 1])
	                result = [points[i], points[i + 1]];
	            }
	        }
	
	        return result;
	    }
	
	    /**Returns the length of a Polyline that would be created with a set of points
	     *@param {Array} v - an {Array} of {Points}
	     *@return {Number} - a positive number equal with total length*/
	    function getPolylineLength(v) {
	        var l = 0;
	        for (var i = 0; i < v.length - 1; i++) {
	            l += distance(v[i], v[i + 1]);
	        }
	
	        return l;
	    }
	
	
	    /**Returns the max of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the maximum number from the vector or NaN if vector is empty
	     **/
	    function max(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m < v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	
	    /**Returns the min of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the minimum number from the vector or NaN if vector is empty
	     *@author alex@scriptoid.com
	     **/
	    function min(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m > v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	    /**
	     * 判断 点数组 是否正交直线路径
	     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function orthogonalPath(v) {
	        if (v.length <= 1) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 1; i++) {
	            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	
	
	    /**
	     *Test to see if 2 {Line}s intersects. They are considered finite segments
	     *and not the infinite lines from geometry
	     *@param {Line} l1 - fist line/segment
	     *@param {Line} l2 - last line/segment
	     *@return {Boolean} true - if the lines intersect or false if not
	     **/
	    function lineIntersectsLine(l1, l2) {
	        // check for two vertical lines
	        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {
	            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,
	                // then check segment bounds for overlapping
	                l1.contains(l2.startPoint.x, l2.startPoint.y) ||
	                l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                // lines are paralel
	                false;
	        }
	        // if one line is vertical, and another line is not vertical
	        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {
	            // let assume l2 is vertical, otherwise exchange them
	            if (l1.startPoint.x == l1.endPoint.x) {
	                var l = l1;
	                l1 = l2;
	                l2 = l;
	            }
	            // finding intersection of 'infinite' lines
	            // equation of the first line is y = ax + b, second: x = c
	            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b = l1.startPoint.y - a * l1.startPoint.x;
	            var x0 = l2.startPoint.x;
	            var y0 = a * x0 + b;
	            return l1.contains(x0, y0) && l2.contains(x0, y0);
	        }
	
	        // check normal case - both lines are not vertical
	        else {
	            //line equation is : y = a*x + b, b = y - a * x
	            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;
	
	            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);
	            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;
	
	            if (a1 == a2) { //paralel lines
	                return b1 == b2 ?
	                    // for coincide lines, check for segment bounds overlapping
	                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                    // not coincide paralel lines have no chance to intersect
	                    false;
	            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment
	
	                /*
	                 * if one of the lines are vertical, then x0 is equal to their x,
	                 * otherwise:
	                 * y1 = a1 * x + b1
	                 * y2 = a2 * x + b2
	                 * => x0 = (b2 - b1) / (a1 - a2)
	                 * => y0 = a1 * x0 + b1
	                 **/
	                x0 = (b2 - b1) / (a1 - a2);
	                y0 = a1 * x0 + b1;
	                return l1.contains(x0, y0) && l2.contains(x0, y0);
	            }
	        }
	    }
	
	    /**
	     *
	     *Tests if a a polyline defined by a set of points intersects a rectangle
	     *@param {Array} points - and {Array} of {Point}s
	     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)
	     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false
	     *
	     *@return true - if line intersects the rectangle, false - if not
	     **/
	    function polylineIntersectsRectangle(points, bounds, closedPolyline) {
	
	
	        //get the 4 lines/segments represented by the bounds
	        var lines = [];
	        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));
	        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));
	        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));
	        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));
	
	        for (var k = 0; k < points.length - 1; k++) {
	            //create a line out of each 2 consecutive points
	            var tempLine = new Line(points[k], points[k + 1]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var i = 0; i < lines.length; i++) {
	                if (lineIntersectsLine(tempLine, lines[i])) {
	                    return true;
	                }
	            }
	        }
	
	        //check the closed figure - that is last point connected to the first
	        if (closedPolyline) {
	            //create a line out of each 2 consecutive points
	            var tempLine1 = new Line(points[points.length - 1], points[0]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var j = 0; j < lines.length; j++) {
	                if (lineIntersectsLine(tempLine1, lines[j])) {
	                    return true;
	                }
	            }
	        }
	
	        return false;
	    }
	
	    /**
	     * 计算路径的分数
	     * Score a ortogonal path made out of Points
	     *Iterates over a set of points (minimum 3)
	     *For each 3 points (i, i+1, i+2) :
	     *  - if the 3rd one is after the 2nd on the same line we add +1
	     *  - if the 3rd is up or down related to the 2nd we do not do anything +0
	     *  - if the 3rd goes back we imediatelly return -1
	     *@param {Array} v - an array of {Point}s
	     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine
	     *  The bigger the number the smooth the path is
	     **/
	    function scorePath(v) {
	        if (v.length <= 2) {
	            return -1;
	        }
	
	        var score = 0;
	        for (var i = 1; i < v.length - 1; i++) {
	            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else { //not on same vertical nor horizontal
	                score--;
	            }
	        }
	
	        return score;
	    }
	
	    /**
	     * 返回数字符号（+ -)
	     * Returns the sign of a number
	     *@param {Number} x - the number
	     *@returns {Number}
	     *@see <a href="http://en.wikipedia.org/wiki/Sign_function">http://en.wikipedia.org/wiki/Sign_function</a>
	     **/
	    function signum(x) {
	        if (x > 0)
	            return 1;
	        else if (x < 0)
	            return -1;
	        else
	            return 0;
	    }
	
	    /**
	     * 判断 点数组 是不是有效路径（没有回路）
	     *Tests if a vector of points is a valid path (not going back)
	     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function forwardPath(v) {
	        if (v.length <= 2) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 2; i++) {
	            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            }
	        }
	
	        return true;
	    }
	
	    /**
	     * 将[x:0,y:0]转化为[0, 0]  给zrender使用
	     * @param  {[type]} points [description]
	     * @param  {[type]} isRevert [description]
	     * @return {[type]}        [description]
	     */
	    function traslatePoints(points, isRevert) {
	        var newPoints = [];
	        if (isRevert) {
	            for (var i = 0; i < points.length; i++) {
	                var point = points[i];
	                newPoints.push(new Point(point[0], point[1]));
	            }
	            return newPoints;
	        } else {
	            for (var j = 0; j < points.length; j++) {
	                var point1 = points[j];
	                newPoints.push([point1.x, point1.y]);
	            }
	            return newPoints;
	        }
	
	
	    }
	
	    function rotationMatrix(angle) {
	        var mReturn = [
	            [Math.cos(angle), -Math.sin(angle), 0],
	            [Math.sin(angle), Math.cos(angle), 0],
	            [0, 0, 1]
	        ];
	        return mReturn;
	    }
	
	    function translationMatrix(dx, dy) {
	        return [
	            [1, 0, dx],
	            [0, 1, dy],
	            [0, 0, 1]
	        ];
	    }
	
	    function scaleMatrix(sx, sy) {
	        if (sy == null) {
	            sy = sx;
	        }
	        return [
	            [sx, 0, 0],
	            [0, sy, 0],
	            [0, 0, 1]
	        ];
	    }
	
	    /** It will return the end point of a line on a given angle (clockwise).
	     * @param {Point} startPoint - the start of the line
	     * @param {Number} length - the length of the line
	     * @param {Number} angle - the angle of the line in radians
	     * @return {Point} - the endPoint of the line
	     */
	    function getEndPoint(startPoint, length, angle) {
	        var endPoint = startPoint.clone();
	        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));
	        endPoint.y -= length;
	        endPoint.transform(rotationMatrix(angle));
	        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));
	        return endPoint;
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getConnectorPoints(node) {
	        return {
	            left: new Point(node.x, node.y + node.height / 2), //矩形 左中的位置
	            top: new Point(node.x + node.width / 2, node.y), //矩形 上中的位置
	            right: new Point(node.x + node.width, node.y + node.height / 2), //矩形 右中的位置
	            bottom: new Point(node.x + node.width / 2, node.y + node.height), //矩形 下中的位置
	            center: new Point(node.x + node.width / 2, node.y + node.height / 2) //中间位置
	
	        };
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getSoltPoints(node) {
	        return [
	            //top
	            [Math.round(node.getRect().width / 3 /10)*10, 0 ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],
	            //right
	            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],
	            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],
	            //bottom
	            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],
	            //left
	            [0, Math.round(node.getRect().height / 3 /10)*10 ],
	            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]
	
	        ]
	    }
	
	    /**
	     * 计算 p1 p2两点所连接的直线的角度
	     * @param  {[type]} p1 [description]
	     * @param  {[type]} p2 [description]
	     * @return {[type]}    [description]
	     */
	    function tangentRotation(p1, p2) {
	        return -Math.PI / 2 - Math.atan2(
	            p2.y - p1.y, p2.x - p1.x
	        );
	    }
	
	    /**
	     * 判断3点是否在一条直线上
	     * Tests if 3 points are coliniar with matrix determinants.
	     * If the determinat of matrix
	     * /         \
	     * | x1 y1 1 |
	     * | x2 y2 1 |
	     * | x3 y3 1 |
	     * \         /
	     * is zero it means that the points are colinear
	     *@param {Point} p1 - first point
	     *@param {Point} p2 - second point
	     *@param {Point} p3 - third point
	     * @param {Number} precission
	     *@return {Boolean} - true if coliniar and false if not
	     *@author Alex
	     *@see http://en.wikipedia.org/wiki/Determinant
	     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html
	     **/
	    function collinearity(p1, p2, p3, precission) {
	        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);
	
	        if (precission) {
	            return Math.abs(determinant) <= precission;
	        } else {
	            return determinant === 0;
	        }
	    }
	
	
	    /**
	     * 四舍五入 保存decimals的小数
	     **/
	    function enhancedRound(number, decimals) {
	        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	    }
	
	    /**
	     * 获取两点之间的长度
	     **/
	    function getLength(startPoint, endPoint) {
	        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));
	    }
	
	    /**
	     * 获取角度
	     * @param  {[type]} centerPoint  [description]
	     * @param  {[type]} outsidePoint [description]
	     * @param  {[type]} round        [description]
	     * @return {[type]}              [description]
	     */
	    function getAngle(centerPoint, outsidePoint, round) {
	        centerPoint.x = enhancedRound(centerPoint.x, 5);
	        centerPoint.y = enhancedRound(centerPoint.y, 5);
	        outsidePoint.x = enhancedRound(outsidePoint.x, 5);
	        outsidePoint.y = enhancedRound(outsidePoint.y, 5);
	        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));
	        angle = -angle;
	
	        //endAngle+=90;
	        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {
	            angle += Math.PI * 2;
	        }
	        while (angle >= Math.PI * 2) {
	            angle -= Math.PI * 2;
	        }
	        if (isNaN(angle)) { //Nan
	            angle = 0; //we are at center point;
	        }
	        if (round) {
	            angle = Math.round(angle / round) * round
	        }
	        return angle;
	    }
	
	    function getRect(node) {
	        var boundingRect = node.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];
	        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];
	        points[2] = [boundingRect.width / 2, boundingRect.height / 2];
	        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];
	        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];
	
	        var boundRect, cx, cy;
	        if (node instanceof graphic.Circle) {
	            //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半
	            boundRect = new BoundingRect(Number(node.position[0]) - Number(boundingRect.width / 2),
	                Number(node.position[1]) - Number(boundingRect.height / 2),
	                Number(boundingRect.width), Number(boundingRect.height));
	            cx = Number(node.position[0]);
	            cy = Number(node.position[1]);
	        } else {
	            boundRect = new BoundingRect(Number(node.position[0]),
	                Number(node.position[1]),
	                Number(boundingRect.width), Number(boundingRect.height));
	            cx = Number(node.position[0]) + Number(boundingRect.width) / 2;
	            cy = Number(node.position[1]) + Number(boundingRect.height) / 2;
	        }
	        return {
	            x: Number(cx),
	            y: Number(cy),
	            width: Number(boundingRect.width),
	            height: Number(boundingRect.height),
	            points: points,
	            boundingRect: boundRect
	        };
	    }
	
	    var StackedMap = {
	        createNew: function() {
	            var stack = [];
	
	            return {
	                add: function(key, value) {
	                    var arrKey = this.get(key);
	                    arrKey.push(value)
	
	                },
	                get: function(key) {
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            return stack[i].value;
	                        }
	                    }
	                    //如果没有找到的话，则创建一个新的数组
	                    var value = [];
	                    stack.push({ key: key, value: value });
	                    return value;
	                },
	                keys: function() {
	                    var keys = [];
	                    for (var i = 0; i < stack.length; i++) {
	                        keys.push(stack[i].key);
	                    }
	                    return keys;
	                },
	                top: function() {
	                    return stack[stack.length - 1];
	                },
	                remove: function(key) {
	                    var idx = -1;
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            idx = i;
	                            break;
	                        }
	                    }
	                    return stack.splice(idx, 1)[0];
	                },
	                removeItem: function(key, item) {
	                    var arrKey = this.get(key);
	                    var index = zrUtil.indexOf(arrKey, item);
	                    arrKey.splice(index, 1);
	
	                },
	                removeTop: function() {
	                    return stack.splice(stack.length - 1, 1)[0];
	                },
	                length: function() {
	                    return stack.length;
	                },
	                clear: function() {
	                    stack.splice(0, stack.length);
	                }
	            };
	        }
	    };
	
	    function randomColor() {
	        var arrHex = ["0", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d"],
	            strHex = "#",
	            index;
	        for (var i = 0; i < 6; i++) {
	            index = Math.round(Math.random() * 15);
	            strHex += arrHex[index];
	        }
	        return strHex;
	    }
	
	    function isUndefined(obj) {
	        return obj === void 0;
	    }
	
	    function collinearReduction (v) {
	        var r = [];
	
	        if(v.length < 3){
	            return Point.cloneArray(v);
	        }
	
	        r.push( v[0].clone() );
	        for(var i=1; i < v.length-1; i++){
	            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )
	            {
	                continue;
	            }
	            else{
	                r.push( v[i].clone() );
	            }
	        }
	        r.push( v[v.length-1].clone() );
	
	        return r;
	    }
	
	    // By default, Underscore uses ERB-style template delimiters, change the
	    // following template settings to use alternative delimiters.
	    var templateSettings = {
	        evaluate: /<%([\s\S]+?)%>/g,
	        interpolate: /<%=([\s\S]+?)%>/g,
	        escape: /<%-([\s\S]+?)%>/g
	    };
	
	    // When customizing `templateSettings`, if you don't want to define an
	    // interpolation, evaluation or escaping regex, we need one that is
	    // guaranteed not to match.
	    var noMatch = /(.)^/;
	
	    // Certain characters need to be escaped so that they can be put into a
	    // string literal.
	    var escapes = {
	        "'": "'",
	        '\\': '\\',
	        '\r': 'r',
	        '\n': 'n',
	        '\u2028': 'u2028',
	        '\u2029': 'u2029'
	    };
	
	    var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
	
	    var escapeChar = function(match) {
	        return '\\' + escapes[match];
	    };
	
	    // JavaScript micro-templating, similar to John Resig's implementation.
	    // Underscore templating handles arbitrary delimiters, preserves whitespace,
	    // and correctly escapes quotes within interpolated code.
	    // NB: `oldSettings` only exists for backwards compatibility.
	    function template(text, settings, oldSettings) {
	        if (!settings && oldSettings) settings = oldSettings;
	        settings = settings || {};
	        settings = zrUtil.defaults(settings, templateSettings, true);
	
	        // Combine delimiters into one regular expression via alternation.
	        var matcher = RegExp([
	            (settings.escape || noMatch).source,
	            (settings.interpolate || noMatch).source,
	            (settings.evaluate || noMatch).source
	        ].join('|') + '|$', 'g');
	
	        // Compile the template source, escaping string literals appropriately.
	        var index = 0;
	        var source = "__p+='";
	        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	            source += text.slice(index, offset).replace(escaper, escapeChar);
	            index = offset + match.length;
	
	            if (escape) {
	                source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	            } else if (interpolate) {
	                source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	            } else if (evaluate) {
	                source += "';\n" + evaluate + "\n__p+='";
	            }
	
	            // Adobe VMs need the match returned to produce the correct offest.
	            return match;
	        });
	        source += "';\n";
	
	        // If a variable is not specified, place data values in local scope.
	        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
	
	        source = "var __t,__p='',__j=Array.prototype.join," +
	            "print=function(){__p+=__j.call(arguments,'');};\n" +
	            source + 'return __p;\n';
	
	        try {
	            var render = new Function(settings.variable || 'obj', source);
	        } catch (e) {
	            e.source = source;
	            throw e;
	        }
	
	        var template = function(data) {
	            return render.call(this, data);
	        };
	
	        // Provide the compiled source as a convenience for precompilation.
	        var argument = settings.variable || 'obj';
	        template.source = 'function(' + argument + '){\n' + source + '}';
	
	        return template;
	    }
	
	    function isEmpty(obj) {
	        if (obj == null) return true;
	        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;
	    }
	
	    module.exports = {
	        inherits: inherits,
	        getUUID: getUUID,
	        distance: distance,
	        getPolylineLength: getPolylineLength,
	        max: max,
	        min: min,
	        isEmpty: isEmpty,
	        orthogonalPath: orthogonalPath,
	        polylineIntersectsRectangle: polylineIntersectsRectangle,
	        scorePath: scorePath,
	        forwardPath: forwardPath,
	        traslatePoints: traslatePoints,
	        getEndPoint: getEndPoint,
	        getConnectorPoints: getConnectorPoints,
	        tangentRotation: tangentRotation,
	        collinearity: collinearity,
	        translationMatrix: translationMatrix,
	        scaleMatrix: scaleMatrix,
	        round: enhancedRound,
	        getLength: getLength,
	        getAngle: getAngle,
	        getRect: getRect,
	        StackedMap: StackedMap,
	        getMaxLineLength: getMaxLineLength,
	        randomColor: randomColor,
	        template: template,
	        isUndefined: isUndefined,
	        getSoltPoints:getSoltPoints,
	        collinearReduction: collinearReduction
	    };
	


/***/ },
/* 74 */
/***/ function(module, exports) {

	
	
	    /**
	      * Creates an instance of a Line. A Line is actually a segment and not a pure
	      * geometrical Line
	      *
	      * @constructor
	      * @this {Line}
	      * @param {Point} startPoint - starting point of the line
	      * @param {Point} endPoint - the ending point of the line
	      **/
	    function Line(startPoint, endPoint){
	        /**Starting {@link Point} of the line*/
	        this.startPoint = startPoint;
	
	        /**Ending {@link Point} of the line*/
	        this.endPoint = endPoint;
	
	        /**Serialization type*/
	        this.oType = 'Line'; //object type used for JSON deserialization
	    }
	
	    /**Creates a {Line} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Line} a newly constructed Line
	     **/
	    Line.load = function(o){
	        var newLine = new Line(
	            Point.load(o.startPoint),
	            Point.load(o.endPoint)
	        );
	
	        return newLine;
	    };
	
	    Line.prototype = {
	        contructor: Line,
	
	
	
	        clone:function(){
	            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());
	            return ret;
	        },
	
	        equals:function(anotherLine){
	            if(!anotherLine instanceof Line){
	                return false;
	            }
	            return this.startPoint.equals(anotherLine.startPoint)
	            && this.endPoint.equals(anotherLine.endPoint)
	        },
	
	        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)
	         * Algorithm: Compute line's equation and see if (x, y) verifies it.
	         * @param {Number} x - the X coordinates
	         * @param {Number} y - the Y coordinates
	         **/
	        contains: function(x, y){
	            // if the point is inside rectangle bounds of the segment
	            if (Math.min(this.startPoint.x, this.endPoint.x) <= x
	                && x <= Math.max(this.startPoint.x, this.endPoint.x)
	                && Math.min(this.startPoint.y, this.endPoint.y) <= y
	                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {
	
	                // check for vertical line
	                if (this.startPoint.x == this.endPoint.x) {
	                    return x == this.startPoint.x;
	                } else { // usual (not vertical) line can be represented as y = a * x + b
	                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);
	                    var b = this.startPoint.y - a * this.startPoint.x;
	                    return y == a * x + b;
	                }
	            } else {
	                return false;
	            }
	        },
	
	        /*
	         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)
	         *@param {Number} x - the x coordinates
	         *@param {Number} y - the y coordinates
	         *@param {Number} radius - the radius to search for
	         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	         *@see "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	         **/
	        near:function(x,y,radius){
	
	            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle
	                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)
	                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))
	                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;
	            }
	
	            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle
	                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)
	                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))
	                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;
	            }
	
	
	            var startX = Math.min(this.endPoint.x,this.startPoint.x);
	            var startY = Math.min(this.endPoint.y,this.startPoint.y);
	            var endX = Math.max(this.endPoint.x,this.startPoint.x);
	            var endY = Math.max(this.endPoint.y,this.startPoint.y);
	
	            /*We will compute the distance from point to the line
	             * by using the algorithm from
	             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	             * */
	
	            //First we need to find a,b,c of the line equation ax + by + c = 0
	            var a = this.endPoint.y - this.startPoint.y;
	            var b = this.startPoint.x - this.endPoint.x;
	            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);
	
	            //Secondly we get the distance "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );
	
	            //Thirdly we get coordinates of closest line's point to target point
	            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates
	            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	
	            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment
	                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment
	
	            return  r;
	
	        },
	
	        /**we need to create a new array each time, or we will affect the actual shape*/
	        getPoints:function(){
	            var points = [];
	            points.push(this.startPoint);
	            points.push(this.endPoint);
	            return points;
	        },
	
	        /**Return the {Point} corresponding the t certain t value
	         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/
	        getPoint: function(t){
	            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;
	            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;
	
	            return new Point(Xp, Yp);
	        },
	
	        // /**
	        //  * Returns the middle of the line
	        //  * @return {Point} the middle point
	        //  * */
	        // getMiddle : function(){
	        //     return Util.getMiddle(this.startPoint, this.endPoint);
	        // },
	
	
	        // getLength : function(){
	        //     return Util.getLength(this.startPoint, this.endPoint);
	        // },
	
	        // /**
	        //  *Get bounds for this line
	        //  *@author Alex Gheorghiu <alex@scriptoid.com>
	        //  **/
	        // getBounds:function(){
	        //     return Util.getBounds(this.getPoints());
	        // },
	
	        /**String representation*/
	        toString:function(){
	            return 'line(' + this.startPoint + ',' + this.endPoint + ')';
	        }
	    };
	    module.exports = Line;
	
	


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * BPMN节点类  所有的BPMN形状都继承与它，用户自定义节点可以继承它并注册即可使用
	 * @class fish.topo.FishTopoBpmn.BPMNNode
	 */
	
	
		var Node = __webpack_require__(76);
		var zrUtil = __webpack_require__(4);
		var graphic = __webpack_require__(3);
		var clazzUtil = __webpack_require__(77);
		//创建Node类 所有形状都继承Node
		function BPMNNode(model, api) {
			Node.call(this);
			this.model = model;
			this.options =
			{
				outline: {
					enable: true, // 是否有外框
					radius: true, // 是否圆角
					initVisible: false
				},
				text: {
					color: '#000000', // 文本颜色
					lineHeight: 24 // 文本行高
				}
			};
			this.bpmnInfo = {type: -1, name:"BPMNDiagram", displayName:"Task" };    //节点信息
			var resourceId = model.get("resourceId");
			if(resourceId && resourceId != "") {
				this.resourceId = resourceId;
			}
	
	        //判断是否有operationNode
	        var prop = model.get("properties");
	        if (prop.operationIcons) {
	            this.operationIcons = prop.operationIcons;
	        }
			this.initEvent(api);
		}
	
	    BPMNNode.prototype.initEvent = function(api) {
	        var that = this;
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'
	
	
	        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	            that.on(eveName, function (e) {
		            var params = {};
		            params.event = e;
		            params.type = eveName;
		            params.target = that;
		            api.trigger(eveName, params);
	            }, this);
	        });
	    };
	
	    /**
	     * 获取当前节点的包围和 相关参数
	     * @returns {{x:Number, y:Number, width:Number, height:Number, points:Array, boundingRect:Object}}
	     * @returns {Number} return.x 当前节点的中心点x值
	     * @returns {Number} return.y 当前节点的中心点y值
	     * @returns {Number} return.width 当前节点的宽度
	     * @returns {Number} return.height 当前节点的高度
	     * @returns {Array} return.points 当前节点的包围和 [左上角坐标，右上角坐标，右下角坐标，右下角坐标] 用于节点选中时包围虚线框
	     * @returns {Object} return.boundingRect 当前节点的包围矩形
	     */
	    BPMNNode.prototype.getRect = function() {
	    };
	
	    /**
	     * 返回当前节点的包围矩形
	     * @return {Object} 当前节点的包围矩形  一般不包括下面的文字
	     */
	    BPMNNode.prototype.getBoundingRect = function() {
	    };
	
	    /**
	     * 设置图元的位置
	     * @param {Number} x x坐标
	     * @param {Number} y y坐标
	     */
	    BPMNNode.prototype.setPosition  = function(x, y) {
	    };
	
	    /**
	     * @private
	     * 查看当前节点是否 包括x ,y 坐标
	     * @param  {number} x x坐标
	     * @param  {number} y y坐标
	     * @return {Boolean}   是否在范围内
	     */
	    BPMNNode.prototype.rectContain = function(x, y) {
	    	var rect = this.getRect();
	        return rect.boundingRect.contain(x,y);
	    };
	
	    /**
	     * 返回json对象
	     * @return {String} json对象
	     */
		BPMNNode.prototype.toJSON = function() {
			this.model.set("resourceId", this.resourceId);
			this.model.set("properties.type", this.bpmnInfo.type);
			this.model.set("stencil.type", this.bpmnInfo.name);  //stencil.id
	
	        if (this.slotEvent && this.slotEvent.length > 0) {
	            var arrSlotEvent = [];
	            for (var i = this.slotEvent.length - 1; i >= 0; i--) {
	                arrSlotEvent.push(this.slotEvent[i].resourceId)
	            }
	            this.model.set("properties.slotEvent", arrSlotEvent);
	        }
	        this.model.set("properties.type", this.bpmnInfo.type);
	
	        var rect = this.getRect().boundingRect;
	        this.model.set("bounds.upperLeft.x", parseInt(rect.x));
	        this.model.set("bounds.upperLeft.y", parseInt(rect.y));
	        this.model.set("bounds.lowerRight.x", parseInt(rect.x + rect.width));
	        this.model.set("bounds.lowerRight.y", parseInt(rect.y + rect.height));
			return this.model.option;
		};
	
		/**
	     * @private
	     * 根据属性设置模型数据
	     * @param {Object} option 模型数据
	     */
	    BPMNNode.prototype.setModel = function(option) {
	        var that = this;
	        var originText = this.model.get("properties.name");
	        this.model.mergeOption(option);
	        if(originText != option.properties.name) {
	            var title = this.childOfName("Title");
	            var nameByteLength = option.properties.name.length;
	            var showName;
	            if(nameByteLength > 64){
	                showName = option.properties.name.substr(0,64)+'..';
	                if(this.alarm){
	                    this.alarm.isShow = true;
	                }
	            }else{
	                showName = option.properties.name;
	                if(this.alarm){
	                    this.alarm.isShow = false;
	                }
	
	            }
	            title.attr("style",{text:showName});
	            that.refreshText(that);
	            var name = option.properties.name;
	            var text = this.alarm.childOfName("Text");
	            text.attr("style",{text:name});
	            var groupWidth = text.getBoundingRect().width+4;
	            var groupHeight = text.getBoundingRect().height+8;
	            var points = [
	                [0,0],
	                [groupWidth,0],
	                [groupWidth,groupHeight],
	                [groupWidth-3,groupHeight],
	                [groupWidth-6,groupHeight+3],
	                [groupWidth-9,groupHeight],
	                [0,groupHeight],
	                [0,0]
	            ];
	            var Polyline = this.alarm.childOfName("Polyline");
	            Polyline.attr("shape",{points:points});
	            var groupPosition = [this.position[0]+this.getBoundingRect().width-(this.alarm.getBoundingRect().width-6),this.position[1]-this.alarm.getBoundingRect().height-3];
	            this.alarm.attr("position",groupPosition);
	        }
	    };
	
	
		zrUtil.inherits(BPMNNode,Node);
	
	    /**
	     * 注册BPMN节点的类，只有注册过后，才能在BPMN编辑器中添加
	     * @method registerClass
	     * @param {Object} Clazz 继承了BPMNNode的实现类
	     * @param {String} componentType 注册类的名称
	     *
	     * **使用范例**：
	     *
	     *     @example
	     *     BPMNNode.registerClass(CustomNode, "CustomNode");
	     */
		clazzUtil.enableClassManagement(BPMNNode, {
	        registerWhenExtend: true
	    });
		module.exports = BPMNNode;
	
	
	


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	
	    var graphic = __webpack_require__(3);
	    var util = __webpack_require__(73)
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    function Node() {
	        this.resourceId = util.getUUID(); // 生成节点ID
	        graphic.Group.call(this);
	    }
	
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.render = function() {};
	
	    /**
	     * 由父类实现
	     * @param  {[type]} json [description]
	     * @return {[type]}      [description]
	     */
	    Node.prototype.getRect = function(json) {};
	
	    /**
	     * drawText
	     * @description 画一个文本
	     * @param {string} name
	     * @param {string} color
	     */
	    Node.prototype.drawText = function(name,color) {
	        var textName = this.bpmnInfo.name;
	        if(name != null){
	            textName = name;
	        }
	        var text = new graphic.Text({
	            style: {
	                text: textName,
	                color: color ? color : this.options.text.color,
	                textFont: '12px Microsoft YaHei'
	            },
	            zlevel: 20
	        });
	        //文字绘制的位置  
	        //x = 中心点.x - 起始位置.x - 文字宽度的一半
	        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	        //y = 中心点.y - 起始位置.y + 节点高度的一半 + 偏移值（6）
	        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;
	        text.attr("style", { x: x, y: y });
	        return {
	            text: text,
	            rect: text.getBoundingRect()
	        };
	    };
	    /**
	     * refreshText
	     * @description 刷新文本
	     */
	    Node.prototype.refreshText = function() {
	        var text = this.childOfName("Title");
	        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;
	        text.attr("style", { x: x, y: y });
	    };
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.toJSON = function() {};
	
	    graphic.Util.inherits(Node, graphic.Group);
	    module.exports = Node;
	


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var zrUtil = __webpack_require__(4);
	
	    var clazz = {};
	
	    var TYPE_DELIMITER = '.';
	    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';
	    /**
	     * @public
	     */
	    var parseClassType = clazz.parseClassType = function (componentType) {
	        var ret = {main: '', sub: ''};
	        if (componentType) {
	            componentType = componentType.split(TYPE_DELIMITER);
	            ret.main = componentType[0] || '';
	            ret.sub = componentType[1] || '';
	        }
	        return ret;
	    };
	    /**
	     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数
	     */
	    clazz.enableClassExtend = function (RootClass, preConstruct) {
	        RootClass.extend = function (proto) {
	            var ExtendedClass = function () {
	                preConstruct && preConstruct.apply(this, arguments);
	                RootClass.apply(this, arguments);
	            };
	
	            zrUtil.extend(ExtendedClass.prototype, proto);
	
	            ExtendedClass.extend = this.extend;
	            ExtendedClass.superCall = superCall;
	            ExtendedClass.superApply = superApply;
	            zrUtil.inherits(ExtendedClass, this);
	            ExtendedClass.superClass = this;
	
	            return ExtendedClass;
	        };
	    };
	
	    // superCall should have class info, which can not be fetch from 'this'.
	    // Consider this case:
	    // class A has method f,
	    // class B inherits class A, overrides method f, f call superApply('f'),
	    // class C inherits class B, do not overrides method f,
	    // then when method of class C is called, dead loop occured.
	    function superCall(context, methodName) {
	        var args = zrUtil.slice(arguments, 2);
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    function superApply(context, methodName, args) {
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    /**
	     * @param {Object} entity
	     * @param {Object} options
	     * @param {boolean} [options.registerWhenExtend]
	     * @public
	     */
	    clazz.enableClassManagement = function (entity, options) {
	        options = options || {};
	
	        /**
	         * Component model classes
	         * key: componentType,
	         * value:
	         *     componentClass, when componentType is 'xxx'
	         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
	         * @type {Object}
	         */
	        var storage = {};
	
	        entity.registerClass = function (Clazz, componentType) {
	            if (componentType) {
	                componentType = parseClassType(componentType);
	
	                if (!componentType.sub) {
	                    if (storage[componentType.main]) {
	                        //已经注册过了，直接返回
	                        return;
	                    }
	                    storage[componentType.main] = Clazz;
	                }
	                else if (componentType.sub !== IS_CONTAINER) {
	                    var container = makeContainer(componentType);
	                    container[componentType.sub] = Clazz;
	                }
	            }
	            return Clazz;
	        };
	
	        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {
	            var Clazz = storage[componentTypeMain];
	
	            if (Clazz && Clazz[IS_CONTAINER]) {
	                Clazz = subType ? Clazz[subType] : null;
	            }
	
	            if (throwWhenNotFound && !Clazz) {
	                throw new Error(
	                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'
	                );
	            }
	
	            return Clazz;
	        };
	
	        entity.getClassesByMainType = function (componentType) {
	            componentType = parseClassType(componentType);
	
	            var result = [];
	            var obj = storage[componentType.main];
	
	            if (obj && obj[IS_CONTAINER]) {
	                zrUtil.each(obj, function (o, type) {
	                    type !== IS_CONTAINER && result.push(o);
	                });
	            }
	            else {
	                result.push(obj);
	            }
	
	            return result;
	        };
	
	        entity.hasClass = function (componentType) {
	            // Just consider componentType.main.
	            componentType = parseClassType(componentType);
	            return !!storage[componentType.main];
	        };
	
	        /**
	         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
	         */
	        entity.getAllClassMainTypes = function () {
	            var types = [];
	            zrUtil.each(storage, function (obj, type) {
	                types.push(type);
	            });
	            return types;
	        };
	
	        /**
	         * If a main type is container and has sub types
	         * @param  {string}  componentType
	         * @return {boolean}
	         */
	        entity.hasSubTypes = function (componentType) {
	            componentType = parseClassType(componentType);
	            var obj = storage[componentType.main];
	            return obj && obj[IS_CONTAINER];
	        };
	
	        entity.parseClassType = parseClassType;
	
	        function makeContainer(componentType) {
	            var container = storage[componentType.main];
	            if (!container || !container[IS_CONTAINER]) {
	                container = storage[componentType.main] = {};
	                container[IS_CONTAINER] = true;
	            }
	            return container;
	        }
	
	        if (options.registerWhenExtend) {
	            var originalExtend = entity.extend;
	            if (originalExtend) {
	                entity.extend = function (proto) {
	                    var ExtendedClass = originalExtend.call(this, proto);
	                    return entity.registerClass(ExtendedClass, proto.type);
	                };
	            }
	        }
	
	        return entity;
	    };
	
	    module.exports = clazz;
	


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * BPMN model
	 *
	 */
	
	
	    var Model = __webpack_require__(79);
	    var BPMNModel = Model.extend({
	
	        type: 'BPMN',
	        /**
	         * @type {Object}
	         * @protected
	         */
	        defaultOption: {
	            resourceId: "",  //资源ID
	
	            properties: {
	                type: -1,  //类型
	                name: null, //名称
	                notes: "",  //备注
	                //no: ""
	                extProperties: {}  //扩展属性
	            },
	
	            stencil: {type: "BPMNDiagram"},
	
	            childShapes: [],    //子形状
	
	            outgoing: [],  // 下一个要连接的形状
	
	            bounds: {
	                upperLeft: {x:0, y:0},  //左上角坐标
	                lowerRight: {x:0, y:0} //右下角坐标
	            }
	        }
	    });
	    module.exports = BPMNModel;
	
	


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 节点等的模型
	 * 里面存的数据用来处理序列化和反序列化
	 * @class fish.topo.model
	 */
	
	
	    var zrUtil = __webpack_require__(4);
	    var clazzUtil = __webpack_require__(77);
	
	    function Model(option, parentModel,  extraOpt) {
	        this.parentModel = parentModel;
	        this.option = option;
	
	        // Simple optimization
	        if (this.init) {
	            if (arguments.length <= 3) {
	                this.init(option, parentModel,  extraOpt);
	            }
	            else {
	                this.init.apply(this, arguments);
	            }
	        }
	    }
	
	    Model.prototype = {
	
	        constructor: Model,
	
	        /**
	         * Model 的初始化函数
	         * @private
	         * @param {Object} option
	         */
	        init: function (option) {
	            zrUtil.merge(option, this.getDefaultOption());
	        },
	
	        getDefaultOption: function () {
	            if (!this.hasOwnProperty('__defaultOption')) {
	                var optList = [];
	                var Class = this.constructor;
	                while (Class) {
	                    var opt = Class.prototype.defaultOption;
	                    opt && optList.push(opt);
	                    Class = Class.superClass;
	                }
	
	                var defaultOption = {};
	                for (var i = optList.length - 1; i >= 0; i--) {
	                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);
	                }
	                this.__defaultOption = defaultOption;
	            }
	            return this.__defaultOption;
	        },
	
	        /**
	         * @private
	         */
	        mergeOption: function (option) {
	            zrUtil.merge(this.option, option, true);
	        },
	
	        /**
	         * 获取model的某个属性的值
	         * @param {string} path model中的属性
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.get("options.text");
	         */
	        get: function (path, ignoreParent) {
	            if (!path) {
	                return this.option;
	            }
	
	            if (typeof path === 'string') {
	                path = path.split('.');
	            }
	
	            var obj = this.option;
	            var parentModel = this.parentModel;
	            for (var i = 0; i < path.length; i++) {
	                // obj could be number/string/... (like 0)
	                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;
	                if (obj == null) {
	                    break;
	                }
	            }
	            if (obj == null && parentModel && !ignoreParent) {
	                obj = parentModel.get(path);
	            }
	            return obj;
	        },
	
	        /**
	         * 设置model的某个属性的值
	         * @param {string} path model中的属性
	         * @param {String} value 所需要设置的值
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.set("options.text","例子");
	         */
	        set: function (path, value) {
	            var obj = this.option;
	
	            if (path.indexOf(".") == -1) {
	                obj[path] = value;
	            } else {
	                var fieldArray  = path.split('.');
	                var n = fieldArray.length;
	                var currentRef = obj;
	                var fieldName;
	
	                for (var i = 0; i < n - 1; i++) {
	                    fieldName = fieldArray[i];
	                    if(currentRef[fieldName] == null) {
	                        currentRef[fieldName] = {};
	                    }
	                    currentRef = currentRef[fieldName];
	                }
	                fieldName = fieldArray[n-1];
	                currentRef[fieldName] = value;
	            }
	        },
	
	        /**
	         * @private
	         */
	        getShallow: function (key, ignoreParent) {
	            var option = this.option;
	            var val = option && option[key];
	            var parentModel = this.parentModel;
	            if (val == null && parentModel && !ignoreParent) {
	                val = parentModel.getShallow(key);
	            }
	            return val;
	        },
	
	        /**
	         * @private
	         */
	        getModel: function (path, parentModel) {
	            var obj = this.get(path, true);
	            var thisParentModel = this.parentModel;
	            var model = new Model(
	                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))
	            );
	            return model;
	        },
	
	        /**
	         *清空model的option
	         * @private
	         */
	        isEmpty: function () {
	            return this.option == null;
	        },
	
	        restoreData: function () {},
	
	        /**
	         * @private
	         */
	        clone: function () {
	            var Ctor = this.constructor;
	            return new Ctor(zrUtil.clone(this.option));
	        }
	    };
	
	    // Enable Model.extend.
	    clazzUtil.enableClassExtend(Model);
	
	    module.exports = Model;
	


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	
		var EventNode = __webpack_require__(81);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <circle id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6Dbg_frame" cx="15" cy="15" r="15" stroke="" fill="#7ED321"></circle>
	 *    <path d="M11.25,8.25 L11.25,22.5 L22.5,15.375 L11.25,8.25 Z" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6Dpath1" fill="#FFFFFF"></path>
	 * </g>
	 */
	
		function StartEventNode(model, api) {
			EventNode.call(this, model, api);
	        this.startIcon = 'M11.25,8.25 L11.25,22.5 L22.5,15.375 L11.25,8.25 Z';
	        this.itemSize = 20;
			this.bpmnInfo = {type: 29, name:"StartNoneEvent" };    //节点信息
	
	        this.render(model);
	
		}
	
	    StartEventNode.prototype.render = function(model) {
	        this.removeAll();
	        this.model = model;
	        var circle = new graphic.Circle({
	                shape: {
	                    cx: 0,
	                    cy: 0,
	                    r: this.itemSize
	                },
	                style: {
	                    fill: '#7ED321'
	                },
	                z:2
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var itemSize = this.itemSize;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        this.add(graphic.makePath(this.startIcon, {style: {fill: '#FFFFFF'},z:2}, rect,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+itemSize , model.get("bounds.upperLeft.y")+itemSize];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
	
		zrUtil.inherits(StartEventNode, EventNode);
		module.exports = StartEventNode;
	


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	
	    var BPMNNode = __webpack_require__(75);
	    var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(25);
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    //
	    function EventNode(model,api) {
	        BPMNNode.call(this, model, api);
	        this.bpmnInfo = {type: -1, name:"EventNode" };    //节点信息
	        this.model = model;
	
	    }
	
	    EventNode.prototype.render = function() {
	
	    };
	
	
	    EventNode.prototype.getRect = function() {
	        // body...
	        var boundingRect = this.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	
	        //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半
	        var boundRect = new BoundingRect(this.position[0] - boundingRect.width/2 ,
	                                         this.position[1] - boundingRect.height/2,
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0],
	            y: this.position[1],
	            width: boundingRect.width/2,
	            height: boundingRect.height/2,
	            points: points,
	            boundingRect: boundRect
	        };
	
	    };
	    EventNode.prototype.setPosition = function(pX,pY) {
	        // body...
	        this.attr('position',[pX,pY]);
	    };
	
	    EventNode.prototype.getBoundingRect = function() {
	        var circle = this.childOfName("Circle");
	        return circle.getBoundingRect();
	    };
	
	
	    zrUtil.inherits(EventNode,BPMNNode);
	    module.exports = EventNode;
	


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	
		var EventNode = __webpack_require__(81);
		var zrUtil = __webpack_require__(4);
	    var util = __webpack_require__(73);
	    var graphic = __webpack_require__(3);
	
	/**
	<g pointer-events="fill" id="sid-39EF045E-66B5-449D-B300-5CBCE4D6698E" title="Intermediate signal catching event">
	  <circle id="sid-39EF045E-66B5-449D-B300-5CBCE4D6698Ebg_frame" cx="15" cy="15" r="15" fill="#D0011B"></circle>
	  <rect id="sid-39EF045E-66B5-449D-B300-5CBCE4D6698Ebg_rect" fill="#FFFFFF" x="9" y="9" width="12" height="12"></rect>
	</g>
	 */
	
		function EndEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.bpmnType = "EndNoneEvent";
	        this.itemSize = 20;
	        this.rectSize = 12;
			this.bpmnInfo = {type: 31, name:"EndNoneEvent" };    //节点信息
	        this.render(model);
		}
	
	    EndEventNode.prototype.render = function(model) {
	        this.model = model;
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize
	            },
	            style: {
	                fill: '#D0011B'
	            },
	            z:2
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var rect = new graphic.Rect({
	            shape: {
	                x: -this.rectSize/2,
	                y: -this.rectSize/2,
	                width: this.rectSize,
	                height: this.rectSize
	            },
	            style: {
	                fill: '#FFFFFF'
	            },
	            z:2
	        });
	        this.add(rect);
	        var itemSize = this.itemSize*2;
	        this.position = [model.get("bounds.upperLeft.x")+itemSize/2 , model.get("bounds.upperLeft.y")+itemSize/2];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(EndEventNode, EventNode);
		module.exports = EndEventNode;
	


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	
		var TaskNode = __webpack_require__(84);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	/**
	 *
	 * <g pointer-events="fill" minimumSize="85 55" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6D" title="User task">
	 *   <rect id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6Dtext_frame" anchors="bottom top right left" x="1.000000059837755" y="1.0162024924" width="72" height="22.000000000000004" rx="7" ry="7" stroke="none" stroke-width="0" fill="none">
	 *   </rect>
	 *   <rect id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6Dbg_frame" resize="vertical horizontal" x="5.98377549e-8" y="0.0162024924" width="85" height="55" rx="7" ry="7" stroke="#bbbbbb" stroke-width="1" fill="#f9f9f9">
	 *   </rect>
	 *   <rect xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6Darea_state" anchors="bottom" x="5.98377549e-8" y="45.0162024924" width="85" height="10" rx="10" ry="10" resize="horizontal" stroke="none" stroke-width="0" fill="none" style="">
	 *   </rect>
	 *   <text xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" font-size="12" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6Dtext_name" x="52" y="35" align="middle center" fittoelem="text_frame" stroke="#373e48" stroke-width="0pt" letter-spacing="-0.01px" transform="rotate(0 52 35)" oryx:fontSize="12" text-anchor="middle">
	 *       <tspan x="52" y="35" dy="5">Task
	 *       </tspan>
	 *   </text>
	 *   <g id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6DuserTask" transform="translate(5.000000, 5.000000)" fill="#4990E2">
	 *       <path anchors="top left" d=" M4.689754749837755 0.7547497214000001  C3.124908639837755 1.5094994424 2.536902989837755 2.8359404524 3.0388532998377547 5.3878194723999995  C3.540803599837755 7.9396985024 4.256854379837756 7.9729218124 4.689754749837755 8.9207625924  C5.122655119837755 9.868603372399999 4.8340548898377556 10.6706224924 3.8239538798377546 11.1080874924  C2.813852879837755 11.5455524924 1.1967550949999999e-7 12.8579473924 5.98377549e-8 13.5870556924  C0 14.3161639924 1.226551289837755 14.2432530924 2.3088023698377547 14.2432530924  C3.391053449837755 14.2432530924 9.090909149837755 14.2432530924 9.090909149837755 14.2432530924  L9.163059219837754 0.5237704804000001  C9.163059219837754 0.5237704804000001 6.254600859837756 0 4.689754749837755 0.7547497214000001  z" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6DPath-14">
	 *       </path>
	 *       <path anchors="top left" d=" M9.595959659837757 0.7547497214000001  C11.160805759837753 1.5094994424 11.576517859837754 2.7466546824 11.074567559837757 5.298533702399999  C10.572617259837756 7.8504127324 10.028860059837754 7.9729218124 9.595959659837757 8.9207625924  C9.163059279837753 9.868603372399999 9.451659519837754 10.6706224924 10.461760559837757 11.1080874924  C11.471861559837755 11.5455524924 14.285714259837755 12.8579473924 14.285714359837757 13.5870556924  C14.285714359837757 14.3161639924 13.059163159837755 14.2432530924 11.976912059837755 14.2432530924  C10.894660959837754 14.2432530924 6.349206409837755 14.2432530924 6.349206409837755 14.2432530924  L6.152061969837755 0.4299262694  C6.152061969837755 0.4299262694 8.031113549837755 0 9.595959659837757 0.7547497214000001  z" id="sid-8A1CDA21-9CD0-48EC-B49D-64474EEDEF6DPath-14-Copy">
	 *       </path>
	 *   </g>
	 * </g>
	 */
	
	    function UserTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "M765.573741 718.489888c-14.999622-112.659873-119.671567-196.438974-237.776452-196.438974-118.912273 0-220.514299 85.277222-238.20317 198.770066-11.840676 76.071559 54.585199 71.326489 54.585199 71.326489l360.734878 0C704.913173 792.148491 776.608052 801.364387 765.573741 718.489888zM690.249195 365.718379c0 89.911776-72.889077 162.810063-162.79676 162.810063-89.908706 0-162.797783-72.898287-162.797783-162.810063 0-89.916892 72.889077-162.80597 162.797783-162.80597C617.360118 202.912409 690.249195 275.801487 690.249195 365.718379z";
	        this.bpmnInfo = {type: 0, name:"UserTask" };    //节点信息
	        this.render(model);
	    }
	
	    UserTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#f9f9f9',
	                stroke: '#bbbbbb'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconRect = {x:5, y: 5, width: 15, height:15};
	        var pathIcon = graphic.makePath(this.iconPath, {style: {fill: '#4990E2'},z:2}, iconRect);
	        this.add(pathIcon);
	       // this.add(graphic.makePath(this.iconPath2, {style: {fill: '#4990E2'}}, rect,"center"));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
	
	
		zrUtil.inherits(UserTaskNode,TaskNode);
		module.exports = UserTaskNode;
	


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	
		var BPMNNode = __webpack_require__(75);
		var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(25);
		//创建Node类 所有形状都继承Node
		//
		function TaskNode(model, api) {
	
			BPMNNode.call(this, model, api);
			this.bpmnInfo = {type: -1, name:"TaskNode" };    //节点信息
	        this.model = model;
	        this.slot = [];
	        this.slotEvent = [];
	        this.isCanSlot = true;  //用于控制本节点是否可以被插槽
		}
	
	    TaskNode.prototype.render = function() {
	
	    };
	
	    TaskNode.prototype.getRect = function() {
	        var boundingRect = this.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	
	        var boundRect = new BoundingRect(this.position[0] ,
	                                         this.position[1],
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0]+boundingRect.width/2,
	            y: this.position[1]+boundingRect.height/2,
	            width: boundingRect.width,
	            height: boundingRect.height,
	            points: points,
	            boundingRect: boundRect
	        };
	    };
	
	    TaskNode.prototype.getBoundingRect = function() {
	        var rect = this.childOfName("Rect");
	        return rect.getBoundingRect();
	    };
	
	    TaskNode.prototype.setPosition = function(pX,pY) {
	        var boundingRect = this.getBoundingRect();
	        this.attr('position',[pX-boundingRect.width/2,pY-boundingRect.height/2]);
	
	    };
	
		zrUtil.inherits(TaskNode,BPMNNode);
		module.exports = TaskNode;
	


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	//ManualTask节点
	
		var TaskNode = __webpack_require__(84);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	/**
	 *
	 *  <g pointer-events="fill" minimumSize="82 42" id="sid-A9545224-4CAE-450D-893D-12CFA7E68825" title="Manual task">
	 *     <rect id="sid-A9545224-4CAE-450D-893D-12CFA7E68825text_frame" anchors="bottom top right left" x="1" y="1" width="74" height="39" rx="10" ry="10" stroke="none" stroke-width="0" fill="none"></rect>
	 *     <rect id="sid-A9545224-4CAE-450D-893D-12CFA7E68825bg_frame" resize="vertical horizontal" x="0" y="0" width="80" height="40" rx="10" ry="10" stroke="#bbbbbb" stroke-width="1" fill="#f9f9f9"></rect>
	 *     <rect xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" id="sid-A9545224-4CAE-450D-893D-12CFA7E68825area_state" anchors="bottom" x="0" y="30" width="80" height="10" rx="10" ry="10" resize="horizontal" stroke="none" stroke-width="0" fill="none" style=""></rect>
	 *     <text xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" font-size="12" id="sid-A9545224-4CAE-450D-893D-12CFA7E68825text_name" x="43" y="24" align="middle center" fittoelem="text_frame" stroke="#373e48" stroke-width="0pt" letter-spacing="-0.01px" transform="rotate(0 43 24)" oryx:fontSize="12" text-anchor="middle"><tspan x="43" y="24" dy="5">Task</tspan></text>
	 *     <g id="sid-A9545224-4CAE-450D-893D-12CFA7E68825manualTask" transform="translate(3,1) scale(0.8)">
	 *     <path anchors="top left" style="fill:#d1b575;stroke=none" d="m 17,9.3290326 c -0.0069,0.5512461 -0.455166,1.0455894 -0.940778,1.0376604 l -5.792746,0 c 0.0053,0.119381 0.0026,0.237107 0.0061,0.355965 l 5.154918,0 c 0.482032,-0.0096 0.925529,0.49051 0.919525,1.037574 -0.0078,0.537128 -0.446283,1.017531 -0.919521,1.007683 l -5.245273,0 c -0.01507,0.104484 -0.03389,0.204081 -0.05316,0.301591 l 2.630175,0 c 0.454137,-0.0096 0.872112,0.461754 0.866386,0.977186 C 13.619526,14.554106 13.206293,15.009498 12.75924,15 L 3.7753054,15 C 3.6045812,15 3.433552,14.94423 3.2916363,14.837136 c -0.00174,0 -0.00436,0 -0.00609,0 C 1.7212035,14.367801 0.99998255,11.458641 1,11.458641 L 1,7.4588393 c 0,0 0.6623144,-1.316333 1.8390583,-2.0872584 1.1767614,-0.7711868 6.8053358,-2.40497 7.2587847,-2.8052901 0.453484,-0.40032 1.660213,1.4859942 0.04775,2.4010487 C 8.5332315,5.882394 8.507351,5.7996113 8.4370292,5.7936859 l 6.3569748,-0.00871 c 0.497046,-0.00958 0.952273,0.5097676 0.94612,1.0738232 -0.0053,0.556126 -0.456176,1.0566566 -0.94612,1.0496854 l -4.72435,0 c 0.01307,0.1149374 0.0244,0.2281319 0.03721,0.3498661 l 5.952195,0 c 0.494517,-0.00871 0.947906,0.5066305 0.940795,1.0679848 z" id="sid-A9545224-4CAE-450D-893D-12CFA7E68825_sid-A9545224-4CAE-450D-893D-12CFA7E68825_17"></path>
	 *     </g>
	 * </g>
	 */
	    function ManualTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "m 17,9.3290326 c -0.0069,0.5512461 -0.455166,1.0455894 -0.940778,1.0376604 l -5.792746,0 c 0.0053,0.119381 0.0026,0.237107 0.0061,0.355965 l 5.154918,0 c 0.482032,-0.0096 0.925529,0.49051 0.919525,1.037574 -0.0078,0.537128 -0.446283,1.017531 -0.919521,1.007683 l -5.245273,0 c -0.01507,0.104484 -0.03389,0.204081 -0.05316,0.301591 l 2.630175,0 c 0.454137,-0.0096 0.872112,0.461754 0.866386,0.977186 C 13.619526,14.554106 13.206293,15.009498 12.75924,15 L 3.7753054,15 C 3.6045812,15 3.433552,14.94423 3.2916363,14.837136 c -0.00174,0 -0.00436,0 -0.00609,0 C 1.7212035,14.367801 0.99998255,11.458641 1,11.458641 L 1,7.4588393 c 0,0 0.6623144,-1.316333 1.8390583,-2.0872584 1.1767614,-0.7711868 6.8053358,-2.40497 7.2587847,-2.8052901 0.453484,-0.40032 1.660213,1.4859942 0.04775,2.4010487 C 8.5332315,5.882394 8.507351,5.7996113 8.4370292,5.7936859 l 6.3569748,-0.00871 c 0.497046,-0.00958 0.952273,0.5097676 0.94612,1.0738232 -0.0053,0.556126 -0.456176,1.0566566 -0.94612,1.0496854 l -4.72435,0 c 0.01307,0.1149374 0.0244,0.2281319 0.03721,0.3498661 l 5.952195,0 c 0.494517,-0.00871 0.947906,0.5066305 0.940795,1.0679848 z";
	      //  this.iconPath2 = "M9.595959659837757 0.7547497214000001  C11.160805759837753 1.5094994424 11.576517859837754 2.7466546824 11.074567559837757 5.298533702399999  C10.572617259837756 7.8504127324 10.028860059837754 7.9729218124 9.595959659837757 8.9207625924  C9.163059279837753 9.868603372399999 9.451659519837754 10.6706224924 10.461760559837757 11.1080874924  C11.471861559837755 11.5455524924 14.285714259837755 12.8579473924 14.285714359837757 13.5870556924  C14.285714359837757 14.3161639924 13.059163159837755 14.2432530924 11.976912059837755 14.2432530924  C10.894660959837754 14.2432530924 6.349206409837755 14.2432530924 6.349206409837755 14.2432530924  L6.152061969837755 0.4299262694  C6.152061969837755 0.4299262694 8.031113549837755 0 9.595959659837757 0.7547497214000001  z";
	        this.bpmnInfo = {type: 4, name:"ManualTask" };    //节点信息
	        this.render(model);
	    }
	
	    ManualTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#f9f9f9',
	                stroke: '#bbbbbb'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconrect = {x:5, y: 5, width: 15, height:15};
	        this.add(graphic.makePath(this.iconPath, {style: {fill: '#d1b575'},z:2}, iconrect));
	
	       // this.add(graphic.makePath(this.iconPath2, {style: {fill: '#4990E2'}}, rect,"center"));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ManualTaskNode,TaskNode);
		module.exports = ManualTaskNode;
	


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	//ScriptTask节点
	
		var TaskNode = __webpack_require__(84);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	/**
	 *
	 *  <g pointer-events="fill" minimumSize="82 42" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5D" title="Script task">
	 *     <rect id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dtext_frame" anchors="bottom top right left" x="1" y="1" width="74" height="39" rx="10" ry="10" stroke="none" stroke-width="0" fill="none"></rect>
	 *     <rect id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dbg_frame" resize="vertical horizontal" x="0" y="0" width="80" height="40" rx="10" ry="10" stroke="#bbbbbb" stroke-width="1" fill="#f9f9f9"></rect>
	 *     <rect xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Darea_state" anchors="bottom" x="0" y="30" width="80" height="10" rx="10" ry="10" resize="horizontal" stroke="none" stroke-width="0" fill="none" style=""></rect>
	 *     <text xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" font-size="12" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dtext_name" x="43" y="24" align="middle center" fittoelem="text_frame" stroke="#373e48" stroke-width="0pt" letter-spacing="-0.01px" transform="rotate(0 43 24)" oryx:fontSize="12" text-anchor="middle"><tspan x="43" y="24" dy="5">Task</tspan></text>
	 *     <g id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5DscriptTask" transform="translate(2,2) scale(0.8)">
	 *     <path anchors="top left" d="m 5,2 0,0.094 c 0.23706,0.064 0.53189,0.1645 0.8125,0.375 0.5582,0.4186 1.05109,1.228 1.15625,2.5312 l 8.03125,0 1,0 1,0 c 0,-3 -2,-3 -2,-3 l -10,0 z M 4,3 4,13 2,13 c 0,3 2,3 2,3 l 9,0 c 0,0 2,0 2,-3 L 15,6 6,6 6,5.5 C 6,4.1111 5.5595,3.529 5.1875,3.25 4.8155,2.971 4.5,3 4.5,3 L 4,3 z" style="fill:#72a7d0;stroke:none" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5D_sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5D_17"></path>
	 *     </g>
	 * </g>
	 */
	    function ScriptTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "m 5,2 0,0.094 c 0.23706,0.064 0.53189,0.1645 0.8125,0.375 0.5582,0.4186 1.05109,1.228 1.15625,2.5312 l 8.03125,0 1,0 1,0 c 0,-3 -2,-3 -2,-3 l -10,0 z M 4,3 4,13 2,13 c 0,3 2,3 2,3 l 9,0 c 0,0 2,0 2,-3 L 15,6 6,6 6,5.5 C 6,4.1111 5.5595,3.529 5.1875,3.25 4.8155,2.971 4.5,3 4.5,3 L 4,3 z";
	      //  this.iconPath2 = "M9.595959659837757 0.7547497214000001  C11.160805759837753 1.5094994424 11.576517859837754 2.7466546824 11.074567559837757 5.298533702399999  C10.572617259837756 7.8504127324 10.028860059837754 7.9729218124 9.595959659837757 8.9207625924  C9.163059279837753 9.868603372399999 9.451659519837754 10.6706224924 10.461760559837757 11.1080874924  C11.471861559837755 11.5455524924 14.285714259837755 12.8579473924 14.285714359837757 13.5870556924  C14.285714359837757 14.3161639924 13.059163159837755 14.2432530924 11.976912059837755 14.2432530924  C10.894660959837754 14.2432530924 6.349206409837755 14.2432530924 6.349206409837755 14.2432530924  L6.152061969837755 0.4299262694  C6.152061969837755 0.4299262694 8.031113549837755 0 9.595959659837757 0.7547497214000001  z";
	        this.bpmnInfo = {type: 7, name:"ScriptTask" };    //节点信息
	        this.render(model);
	    }
	
	    ScriptTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#f9f9f9',
	                stroke: '#bbbbbb'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconrect = {x:5, y: 5, width: 15, height:15};
	        this.add(graphic.makePath(this.iconPath, {style: {fill: '#72a7d0'},z:2}, iconrect));
	
	       // this.add(graphic.makePath(this.iconPath2, {style: {fill: '#4990E2'}}, rect,"center"));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ScriptTaskNode,TaskNode);
		module.exports = ScriptTaskNode;
	


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	//MailTask节点
	
		var TaskNode = __webpack_require__(84);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	/**
	 *
	 *  <g pointer-events="fill" minimumSize="82 42" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5D" title="Script task">
	 *     <rect id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dtext_frame" anchors="bottom top right left" x="1" y="1" width="74" height="39" rx="10" ry="10" stroke="none" stroke-width="0" fill="none"></rect>
	 *     <rect id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dbg_frame" resize="vertical horizontal" x="0" y="0" width="80" height="40" rx="10" ry="10" stroke="#bbbbbb" stroke-width="1" fill="#f9f9f9"></rect>
	 *     <rect xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Darea_state" anchors="bottom" x="0" y="30" width="80" height="10" rx="10" ry="10" resize="horizontal" stroke="none" stroke-width="0" fill="none" style=""></rect>
	 *     <text xmlns:oryx="http://www.b3mn.org/oryx" xmlns="http://www.w3.org/2000/svg" font-size="12" id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5Dtext_name" x="43" y="24" align="middle center" fittoelem="text_frame" stroke="#373e48" stroke-width="0pt" letter-spacing="-0.01px" transform="rotate(0 43 24)" oryx:fontSize="12" text-anchor="middle"><tspan x="43" y="24" dy="5">Task</tspan></text>
	 *     <g id="sid-B83DFA9E-0066-4032-A9E8-A7FF19C1AB5DscriptTask" transform="translate(2,2) scale(0.8)">
	 *        <path anchors="top left" d="M0.332638936,1.17391304 L8.98125126,6.65217391" id="sid-09B97C5E-BEA8-40A2-9F22-3064A2745DBELine" stroke="#FFFFFF" stroke-linecap="square"></path>
	 *        <path anchors="top left" d="M17.5500302,1.17391304 L8.90141792,6.65217391" id="sid-09B97C5E-BEA8-40A2-9F22-3064A2745DBELine-Copy-4" stroke="#FFFFFF" stroke-linecap="square"></path>
	 *	   </g>
	 * </g>
	 */
	    function MailTaskNode(model,api) {
	        TaskNode.call(this,model, api);
	        this.rectSize = {width:100, height:60};
	        this.iconPath = "M49.013,51.003c1.847,1.303,7.414,5.174,16.702,11.61S82.118,74.005,87.061,77.48c0.543,0.381,1.697,1.209,3.462,2.485c1.765,1.277,3.232,2.31,4.399,3.097c1.168,0.787,2.58,1.67,4.237,2.647c1.657,0.977,3.219,1.711,4.685,2.198c1.467,0.49,2.825,0.733,4.074,0.733H108h0.082c1.249,0,2.607-0.243,4.074-0.733c1.466-0.487,3.029-1.222,4.685-2.198c1.656-0.978,3.068-1.86,4.236-2.647s2.634-1.82,4.399-3.097s2.92-2.104,3.463-2.485c4.996-3.476,17.707-12.302,38.129-26.479c3.965-2.769,7.277-6.11,9.939-10.021C179.67,37.071,181,32.97,181,28.679c0-3.585-1.291-6.654-3.871-9.207c-2.58-2.553-5.636-3.829-9.165-3.829H48.035c-4.182,0-7.4,1.412-9.654,4.236C36.127,22.704,35,26.235,35,30.471c0,3.422,1.494,7.13,4.481,11.122S45.646,48.722,49.013,51.003z M172.852,59.72c-17.814,12.057-31.34,21.427-40.572,28.108c-3.096,2.281-5.608,4.061-7.537,5.336c-1.928,1.277-4.494,2.58-7.699,3.911c-3.204,1.331-6.191,1.996-8.961,1.996H108h-0.082c-2.77,0-5.758-0.665-8.962-1.996s-5.771-2.634-7.699-3.911c-1.928-1.275-4.44-3.055-7.536-5.336c-7.333-5.377-20.83-14.747-40.492-28.108c-3.096-2.063-5.839-4.427-8.229-7.088v64.688c0,3.586,1.276,6.654,3.829,9.207c2.553,2.554,5.622,3.83,9.207,3.83h119.929c3.584,0,6.653-1.276,9.206-3.83c2.554-2.554,3.829-5.621,3.829-9.207V52.632C178.664,55.238,175.949,57.602,172.852,59.72z";
	      //  this.iconPath2 = "M9.595959659837757 0.7547497214000001  C11.160805759837753 1.5094994424 11.576517859837754 2.7466546824 11.074567559837757 5.298533702399999  C10.572617259837756 7.8504127324 10.028860059837754 7.9729218124 9.595959659837757 8.9207625924  C9.163059279837753 9.868603372399999 9.451659519837754 10.6706224924 10.461760559837757 11.1080874924  C11.471861559837755 11.5455524924 14.285714259837755 12.8579473924 14.285714359837757 13.5870556924  C14.285714359837757 14.3161639924 13.059163159837755 14.2432530924 11.976912059837755 14.2432530924  C10.894660959837754 14.2432530924 6.349206409837755 14.2432530924 6.349206409837755 14.2432530924  L6.152061969837755 0.4299262694  C6.152061969837755 0.4299262694 8.031113549837755 0 9.595959659837757 0.7547497214000001  z";
	        this.bpmnInfo = {type: 8, name:"MailTask" };    //节点信息
	        this.render(model);
	    }
	
	    MailTaskNode.prototype.render = function(model) {
	        var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#f9f9f9',
	                stroke: '#bbbbbb'
	            },
	            z:2
	        });
	        rect.name = "Rect";
	        this.add(rect);
	
	        var iconrect = {x:5, y: 5, width: 20, height:15};
	        this.add(graphic.makePath(this.iconPath, {style: {fill: '#72a7d0'},z:2}, iconrect));
	
	       // this.add(graphic.makePath(this.iconPath2, {style: {fill: '#4990E2'}}, rect,"center"));
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(MailTaskNode,TaskNode);
		module.exports = MailTaskNode;
	


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	//边界事件---捕获定时器事件节点
	
		var EventNode = __webpack_require__(81);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bbg_frame" cx="16" cy="16" r="15" stroke="#585858" fill="#ffffff" stroke-width="1" style="stroke-dasharray: 5.5, 3"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe2_non_interrupting" cx="16" cy="16" r="12" stroke="#585858" fill="none" stroke-width="1" style="stroke-dasharray: 4.5, 3"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe" cx="16" cy="16" r="15" stroke="#585858" fill="none" stroke-width="1"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe2" cx="16" cy="16" r="12" stroke="#585858" fill="none" stroke-width="1"></circle>
	 *    <path id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bpath1" transform="translate(6,6)" d="M 10 0 C 4.4771525 0 0 4.4771525 0 10 C 0 15.522847 4.4771525 20 10 20 C 15.522847 20 20 15.522847 20 10 C 20 4.4771525 15.522847 1.1842379e-15 10 0 z M 9.09375 1.03125 C 9.2292164 1.0174926 9.362825 1.0389311 9.5 1.03125 L 9.5 3.5 L 10.5 3.5 L 10.5 1.03125 C 15.063526 1.2867831 18.713217 4.9364738 18.96875 9.5 L 16.5 9.5 L 16.5 10.5 L 18.96875 10.5 C 18.713217 15.063526 15.063526 18.713217 10.5 18.96875 L 10.5 16.5 L 9.5 16.5 L 9.5 18.96875 C 4.9364738 18.713217 1.2867831 15.063526 1.03125 10.5 L 3.5 10.5 L 3.5 9.5 L 1.03125 9.5 C 1.279102 5.0736488 4.7225326 1.4751713 9.09375 1.03125 z M 9.5 5 L 9.5 8.0625 C 8.6373007 8.2844627 8 9.0680195 8 10 C 8 11.104569 8.8954305 12 10 12 C 10.931981 12 11.715537 11.362699 11.9375 10.5 L 14 10.5 L 14 9.5 L 11.9375 9.5 C 11.756642 8.7970599 11.20294 8.2433585 10.5 8.0625 L 10.5 5 L 9.5 5 z " fill="#585858" stroke="none"></path>
	 * </g>
	 */
	
		function CatchTimerEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.startIcon = 'M 10 0 C 4.4771525 0 0 4.4771525 0 10 C 0 15.522847 4.4771525 20 10 20 C 15.522847 20 20 15.522847 20 10 C 20 4.4771525 15.522847 1.1842379e-15 10 0 z M 9.09375 1.03125 C 9.2292164 1.0174926 9.362825 1.0389311 9.5 1.03125 L 9.5 3.5 L 10.5 3.5 L 10.5 1.03125 C 15.063526 1.2867831 18.713217 4.9364738 18.96875 9.5 L 16.5 9.5 L 16.5 10.5 L 18.96875 10.5 C 18.713217 15.063526 15.063526 18.713217 10.5 18.96875 L 10.5 16.5 L 9.5 16.5 L 9.5 18.96875 C 4.9364738 18.713217 1.2867831 15.063526 1.03125 10.5 L 3.5 10.5 L 3.5 9.5 L 1.03125 9.5 C 1.279102 5.0736488 4.7225326 1.4751713 9.09375 1.03125 z M 9.5 5 L 9.5 8.0625 C 8.6373007 8.2844627 8 9.0680195 8 10 C 8 11.104569 8.8954305 12 10 12 C 10.931981 12 11.715537 11.362699 11.9375 10.5 L 14 10.5 L 14 9.5 L 11.9375 9.5 C 11.756642 8.7970599 11.20294 8.2433585 10.5 8.0625 L 10.5 5 L 9.5 5 z';
	        this.itemSize = 10;
			this.bpmnInfo = {type: 43, name:"CatchTimerEvent" };    //节点信息
	        this.render(model);
		}
	
	    CatchTimerEventNode.prototype.render = function(model) {
	
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-0.5
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#585858'
	            },
	            z:2
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-3
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#585858'
	            },
	            z:2
	        });
	        this.add(circle1);
	
	        var itemSize = this.itemSize+6;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        this.add(graphic.makePath(this.startIcon, {style: {stroke:'#585858'},z:2}, rect,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+this.itemSize , model.get("bounds.upperLeft.y")+this.itemSize];
	
	    };
	
		zrUtil.inherits(CatchTimerEventNode, EventNode);
		module.exports = CatchTimerEventNode;
	


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	//边界事件---捕获信号量事件
	
		var EventNode = __webpack_require__(81);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bbg_frame" cx="16" cy="16" r="15" stroke="#585858" fill="#ffffff" stroke-width="1" style="stroke-dasharray: 5.5, 3"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe2_non_interrupting" cx="16" cy="16" r="12" stroke="#585858" fill="none" stroke-width="1" style="stroke-dasharray: 4.5, 3"></circle>
	 *    <path id="sid-3CC33924-73F3-4D13-A2A9-0242530680DEsignalCatching" stroke="#585858" d=" M7.7124971 20.247342  L22.333334 20.247342  L15.022915000000001 7.575951200000001  L7.7124971 20.247342  z" style="fill:none;stroke-width:1.4;stroke-miterlimit:4;stroke-dasharray:none"></path>
	 * </g>
	 */
	
		function CatchSignalEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.startIcon = 'M7.7124971 20.247342  L22.333334 20.247342  L15.022915000000001 7.575951200000001  L7.7124971 20.247342  z';
	        this.itemSize = 10;
			this.bpmnInfo = {type: 72, name:"CatchSignalEvent" };    //节点信息
	        this.render(model);
		}
	
	    CatchSignalEventNode.prototype.render = function(model) {
	
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-0.5
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#585858'
	            },
	            z:2
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-3
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#585858'
	            },
	            z:2
	        });
	        this.add(circle1);
	
	        var itemSize = this.itemSize+6;
	        var rect = {x:-itemSize/2, y: -itemSize/2-3, width: itemSize, height:itemSize};
	        this.add(graphic.makePath(this.startIcon, {style: {stroke:'#585858',fill:'#ffffff'},z:2}, rect,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+this.itemSize , model.get("bounds.upperLeft.y")+this.itemSize];
	
	    };
	
		zrUtil.inherits(CatchSignalEventNode, EventNode);
		module.exports = CatchSignalEventNode;
	


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	//边界事件---ThrowSignalEvent节点
	
		var EventNode = __webpack_require__(81);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bbg_frame" cx="16" cy="16" r="15" stroke="#585858" fill="#ffffff" stroke-width="1" style="stroke-dasharray: 5.5, 3"></circle>
	 *    <circle id="sid-F8DFBDAD-2852-4A9A-84E9-A65943A0962Bframe2_non_interrupting" cx="16" cy="16" r="12" stroke="#585858" fill="none" stroke-width="1" style="stroke-dasharray: 4.5, 3"></circle>
	 *    <path id="sid-3CC33924-73F3-4D13-A2A9-0242530680DEsignalCatching" stroke="#585858" d=" M7.7124971 20.247342  L22.333334 20.247342  L15.022915000000001 7.575951200000001  L7.7124971 20.247342  z" style="fill:none;stroke-width:1.4;stroke-miterlimit:4;stroke-dasharray:none"></path>
	 * </g>
	 */
	
		function ThrowSignalEventNode(model, api) {
			EventNode.call(this,model, api);
	        this.startIcon = 'M7.7124971 20.247342  L22.333334 20.247342  L15.022915000000001 7.575951200000001  L7.7124971 20.247342  z';
	        this.itemSize = 10;
			this.bpmnInfo = {type: 75, name:"ThrowSignalEvent" };    //节点信息
	        this.render(model);
		}
	
	    ThrowSignalEventNode.prototype.render = function(model) {
	
	        var circle = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-0.5
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#585858'
	            },
	            z:2
	        });
	        circle.name = "Circle";
	        this.add(circle);
	        var circle1 = new graphic.Circle({
	            shape: {
	                cx: 0,
	                cy: 0,
	                r: this.itemSize-3
	            },
	            style: {
	                fill: '#ffffff',
	                stroke:'#585858'
	            },
	            z:2
	        });
	        this.add(circle1);
	
	        var itemSize = this.itemSize+6;
	        var rect = {x:-itemSize/2, y: -itemSize/2-3, width: itemSize, height:itemSize};
	        this.add(graphic.makePath(this.startIcon, {style: {stroke:'#585858',fill:'#000000'},z:2}, rect,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+this.itemSize , model.get("bounds.upperLeft.y")+this.itemSize];
	
	    };
	
		zrUtil.inherits(ThrowSignalEventNode, EventNode);
		module.exports = ThrowSignalEventNode;
	


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	//InclusiveGateWay节点
	
		var GatewayNode = __webpack_require__(92);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <path d=" M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z" id="sid-6D0E93DA-0E0B-47F0-AF85-3F3230367651Rectangle-1" fill="#F6A623"></path>
	 *    <path d=" M19.851221564 27.782256064000002  C24.231410964 27.782256064000002 27.782256064000002 24.231410964 27.782256064000002 19.851221564  C27.782256064000002 15.471032163999999 24.231410964 11.920187063999999 19.851221564 11.920187063999999  C15.471032163999999 11.920187063999999 11.920187063999999 15.471032163999999 11.920187063999999 19.851221564  C11.920187063999999 24.231410964 15.471032163999999 27.782256064000002 19.851221564 27.782256064000002  z" id="sid-6D0E93DA-0E0B-47F0-AF85-3F3230367651Oval-4" fill="#FFFFFF"></path>
	 * </g>
	 */
	
		function InclusiveGatewayNode(model, api) {
			GatewayNode.call(this, model, api);
	        this.startIcon = 'M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z';
	        this.nextIcon = 'M19.851221564 27.782256064000002  C24.231410964 27.782256064000002 27.782256064000002 24.231410964 27.782256064000002 19.851221564  C27.782256064000002 15.471032163999999 24.231410964 11.920187063999999 19.851221564 11.920187063999999  C15.471032163999999 11.920187063999999 11.920187063999999 15.471032163999999 11.920187063999999 19.851221564  C11.920187063999999 24.231410964 15.471032163999999 27.782256064000002 19.851221564 27.782256064000002  z';
	        this.itemSize = 20;
			this.bpmnInfo = {type: 20, name:"InclusiveGateway" };    //节点信息
	        this.render(model);
		}
	
	    InclusiveGatewayNode.prototype.render = function(model) {
	        var itemSize = this.itemSize*2;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        var path = graphic.makePath(this.startIcon, {style: {fill: '#F6A623'},z:2}, rect,"center");
	        path.name = 'Path';
	        this.add(path);
	        var itemSize1 = this.itemSize;
	        var rect1 = {x:-itemSize1/2, y: -itemSize1/2, width: itemSize1, height:itemSize1};
	        this.add(graphic.makePath(this.nextIcon, {style: {fill: '#FFFFFF'},z:2}, rect1,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+itemSize1 , model.get("bounds.upperLeft.y")+itemSize1];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(InclusiveGatewayNode, GatewayNode);
		module.exports = InclusiveGatewayNode;
	


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	//所有GateWay节点的基类
	
	    var BPMNNode = __webpack_require__(75);
	    var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(25);
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    //
	    function GatewayNode(model, api) {
	        BPMNNode.call(this, model, api);
	        this.bpmnInfo = {type: -1, name:"GatewayNode" };    //节点信息
	        this.model = model;
	    }
	
	    GatewayNode.prototype.render = function() {
	
	    };
	
	    GatewayNode.prototype.getRect = function() {
	        var boundingRect = this.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	        var boundRect = new BoundingRect(this.position[0] - boundingRect.width/2 ,
	                                         this.position[1] - boundingRect.height/2,
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0],
	            y: this.position[1],
	            width: boundingRect.width/2,
	            height: boundingRect.height/2,
	            points: points,
	            boundingRect: boundRect
	        };
	
	    };
	    GatewayNode.prototype.setPosition = function(pX,pY) {
	        // body...
	        this.attr('position',[pX,pY]);
	    };
	    GatewayNode.prototype.getBoundingRect = function() {
	        var path = this.childOfName("Path");
	        return path.getBoundingRect();
	    };
	
	    zrUtil.inherits(GatewayNode,BPMNNode);
	    module.exports = GatewayNode;
	


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	//ExclusiveGateWay节点
	
		var GatewayNode = __webpack_require__(92);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <path d=" M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z" id="sid-6D0E93DA-0E0B-47F0-AF85-3F3230367651Rectangle-1" fill="#F6A623"></path>
	 *    <path d=" M8.275862069 11.965517269000001  L1.499999999 11.965517269000001  L0 11.965517269000001  L0 8.965517239  L1.499999999 8.965517239  L8.275862069 8.965517239  L8.275862069 1.499999999  L8.275862069 0  L11.275862069 0  L11.275862069 1.499999999  L11.275862069 8.965517239  L18.741379269 8.965517239  L20.241379269 8.965517239  L20.241379269 11.965517269000001  L18.741379269 11.965517269000001  L11.275862069 11.965517269000001  L11.275862069 18.741379269  L11.275862069 20.241379269  L8.275862069 20.241379269  L8.275862069 18.741379269  L8.275862069 11.965517269000001  z" id="sid-1B88D2DF-A08F-4837-91F2-91F67ACAB29ALine-Copy"></path>
	 * </g>
	 */
	
		function ExclusiveGatewayNode(model, api) {
			GatewayNode.call(this, model, api);
	        this.startIcon = 'M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z';
	        this.nextIcon = 'M19.904129064000003 17.676993964000005  L24.997457864000005 12.583664864000003  L26.058118064000006 11.523004664000002  L28.179438464 13.644324964000003  L27.118778264 14.704985164000002  L22.025449364000004 19.798314364  L27.118778264 24.891643464000005  L28.179438464 25.952303664000006  L26.058118064000006 28.073623964000003  L24.997457864000005 27.012963764000006  L19.904129064000003 21.919634764  L14.810800164000003 27.012963764000006  L13.750140064000002 28.073623964000003  L11.628819664000003 25.952303664000006  L12.689479764000003 24.891643464000005  L17.782808764000002 19.798314364  L12.689479764000003 14.704985164000002  L11.628819664000003 13.644324964000003  L13.750140064000002 11.523004664000002  L14.810800164000003 12.583664864000003  L19.904129064000003 17.676993964000005  z';
	        this.itemSize = 20;
			this.bpmnInfo = {type: 17, name:"ExclusiveGateway" };    //节点信息
	        this.render(model);
		}
	
	    ExclusiveGatewayNode.prototype.render = function(model) {
	        var itemSize = this.itemSize*2;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        var path = graphic.makePath(this.startIcon, {style: {fill: '#F6A623'},z:2}, rect,"center");
	        path.name = 'Path';
	        this.add(path);
	        var itemSize1 = this.itemSize;
	        var rect1 = {x:-itemSize1/2, y: -itemSize1/2, width: itemSize1, height:itemSize1};
	        this.add(graphic.makePath(this.nextIcon, {style: {fill: '#FFFFFF'},z:2}, rect1,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+itemSize1 , model.get("bounds.upperLeft.y")+itemSize1];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ExclusiveGatewayNode, GatewayNode);
		module.exports = ExclusiveGatewayNode;
	


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	//ParallelGateWay节点
	
		var GatewayNode = __webpack_require__(92);
		var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	
	/**
	 * <g pointer-events="fill" id="sid-FF0ADFC0-D3EC-4237-AD16-A36273D1FE6D" title="Start event">
	 *    <path d=" M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z" id="sid-6D0E93DA-0E0B-47F0-AF85-3F3230367651Rectangle-1" fill="#F6A623"></path>
	 *    <path d=" M19.904129064000003 17.676993964000005  L24.997457864000005 12.583664864000003  L26.058118064000006 11.523004664000002  L28.179438464 13.644324964000003  L27.118778264 14.704985164000002  L22.025449364000004 19.798314364  L27.118778264 24.891643464000005  L28.179438464 25.952303664000006  L26.058118064000006 28.073623964000003  L24.997457864000005 27.012963764000006  L19.904129064000003 21.919634764  L14.810800164000003 27.012963764000006  L13.750140064000002 28.073623964000003  L11.628819664000003 25.952303664000006  L12.689479764000003 24.891643464000005  L17.782808764000002 19.798314364  L12.689479764000003 14.704985164000002  L11.628819664000003 13.644324964000003  L13.750140064000002 11.523004664000002  L14.810800164000003 12.583664864000003  L19.904129064000003 17.676993964000005  z" id="sid-8FCD6C01-B973-4C9C-A90B-3D2ADFC75217Line" fill="#FFFFFF"></path>
	 * </g>
	 */
	
		function ParallelGatewayNode(model, api) {
			GatewayNode.call(this, model, api);
	        this.startIcon = 'M0 19.506393964  L19.506393964 0  L39.012787964 19.506393964  L19.506393964 39.012787964  L0 19.506393964  L0 19.506393964  z';
	        this.nextIcon = 'M8.275862069 11.965517269000001  L1.499999999 11.965517269000001  L0 11.965517269000001  L0 8.965517239  L1.499999999 8.965517239  L8.275862069 8.965517239  L8.275862069 1.499999999  L8.275862069 0  L11.275862069 0  L11.275862069 1.499999999  L11.275862069 8.965517239  L18.741379269 8.965517239  L20.241379269 8.965517239  L20.241379269 11.965517269000001  L18.741379269 11.965517269000001  L11.275862069 11.965517269000001  L11.275862069 18.741379269  L11.275862069 20.241379269  L8.275862069 20.241379269  L8.275862069 18.741379269  L8.275862069 11.965517269000001  z';
	        this.itemSize = 20;
			this.bpmnInfo = {type: 20, name:"ParallelGateway" };    //节点信息
	        this.render(model);
		}
	
	    ParallelGatewayNode.prototype.render = function(model) {
	        var itemSize = this.itemSize*2;
	        var rect = {x:-itemSize/2, y: -itemSize/2, width: itemSize, height:itemSize};
	        var path = graphic.makePath(this.startIcon, {style: {fill: '#F6A623'},z:2}, rect,"center");
	        path.name = 'Path';
	        this.add(path);
	        var itemSize1 = this.itemSize;
	        var rect1 = {x:-itemSize1/2, y: -itemSize1/2, width: itemSize1, height:itemSize1};
	        this.add(graphic.makePath(this.nextIcon, {style: {fill: '#FFFFFF'},z:2}, rect1,"center"));
	        this.position = [model.get("bounds.upperLeft.x")+itemSize1 , model.get("bounds.upperLeft.y")+itemSize1];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
		zrUtil.inherits(ParallelGatewayNode, GatewayNode);
		module.exports = ParallelGatewayNode;
	


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	//子流程
	
		var BPMNNode = __webpack_require__(75);
		var zrUtil = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(25);
	    var graphic = __webpack_require__(3);
	    var Connector = __webpack_require__(96);
		//创建Node类 所有形状都继承Node
		//
		function SubProcessNode(model, api) {
	
			BPMNNode.call(this, model, api);
			this.bpmnInfo = {type: -1, name:"SubProcess" };    //节点信息
	        this.model = model;
	        this.slot = [];
	        this.slotEvent = [];
	        this.isCanSlot = true;
	        var width,height;
	        width = model.get("bounds.lowerRight.x")-model.get("bounds.upperLeft.x");
	        height = model.get("bounds.lowerRight.y")-model.get("bounds.upperLeft.y");
	        if(!width || width <= 0){
	            width = 160;
	        }
	        if(!height || height <= 0){
	            height = 100;
	        }
	
	        this.rectSize = {width:width, height:height};
	        this.render(model);
		}
	
	
	    SubProcessNode.prototype.initEvent = function(api) {
	        var that = this;
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'
	
	
	        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {
	            that.on(eveName, function (e) {
	                var params = {};
	                params.event = e;
	                var current = e.target;
	                if (current.parent &&  current.parent instanceof Connector) {
	                    return;
	                }
	                params.type = eveName;
	                params.target = that;
	                api.trigger(eveName, params);
	            }, this);
	        });
	    };
	
	
	    SubProcessNode.prototype.render = function(model) {
	    	var rect = new graphic.Rect({
	            shape: {
	                x: 0.5,
	                y: 0.5,
	                width: this.rectSize.width-1,
	                height: this.rectSize.height-1,
	                r: 7
	            },
	            style: {
	
	                fill: '#f9f9f9',
	                stroke: '#bbbbbb'
	            },
	            z:0
	        });
	        rect.name = "Rect";
	        this.add(rect);
	        this.position =  [model.get("bounds.upperLeft.x"), model.get("bounds.upperLeft.y")];
	        var title = this.drawText(model.get("properties.name"));
	        title.text.name = "Title";
	        this.add(title.text);
	    };
	
	
	    SubProcessNode.prototype.getRect = function() {
	        // body...
	        var boundingRect = this.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] =[-boundingRect.width/2,-boundingRect.height/2];
	        points[1] =[boundingRect.width/2,-boundingRect.height/2];
	        points[2] =[boundingRect.width/2,boundingRect.height/2];
	        points[3] =[-boundingRect.width/2,boundingRect.height/2];
	        points[4] =[-boundingRect.width/2,-boundingRect.height/2];
	
	        var boundRect = new BoundingRect(this.position[0] ,
	                                         this.position[1],
	                                         boundingRect.width, boundingRect.height);
	        return {
	            x: this.position[0]+boundingRect.width/2,
	            y: this.position[1]+boundingRect.height/2,
	            width: boundingRect.width,
	            height: boundingRect.height,
	            points: points,
	            boundingRect: boundRect
	        };
	    };
	
	    SubProcessNode.prototype.setPosition = function(pX,pY) {
	        // body...
	        var boundingRect = this.getBoundingRect();
	        this.attr('position',[pX-boundingRect.width/2,pY-boundingRect.height/2]);
	
	    };
	
	
	    SubProcessNode.prototype.refresh = function(opt) {
	        var rect = this.childOfName("Rect");
	        rect.setShape(opt.shape);
	        this.attr('position',opt.position);
	        this.refreshText();
	    };
	
	
	
	    SubProcessNode.prototype.getBoundingRect = function() {
	        var rect = this.childOfName("Rect");
	        return rect.getBoundingRect();
	    };
	
	    /**
	     * 根据属性设置模型数据
	     * @param {[type]} option [description]
	     */
	    SubProcessNode.prototype.setModel = function(option) {
	        var that = this;
	        var originText = this.model.get("properties.name");
	        this.model.mergeOption(option);
	        if(originText != option.properties.name) {
	            var title = this.childOfName("Title");
	            var nameByteLength = option.properties.name.length;
	            var showName;
	            if(nameByteLength > 64){
	                showName = option.properties.name.substr(0,64)+'..';
	                this.alarm.isShow = true;
	            }else{
	                showName = option.properties.name;
	                this.alarm.isShow = false;
	            }
	            title.attr("style",{text:showName});
	            that.refreshText(that);
	            var name = option.properties.name;
	            var text = this.alarm.childOfName("Text");
	            text.attr("style",{text:name});
	            var groupWidth = text.getBoundingRect().width+4;
	            var groupHeight = text.getBoundingRect().height+8;
	            var points = [
	                [0,0],
	                [groupWidth,0],
	                [groupWidth,groupHeight],
	                [groupWidth-3,groupHeight],
	                [groupWidth-6,groupHeight+3],
	                [groupWidth-9,groupHeight],
	                [0,groupHeight],
	                [0,0]
	            ];
	            var Polyline = this.alarm.childOfName("Polyline");
	            Polyline.attr("shape",{points:points});
	            var groupPosition = [this.position[0]+this.getBoundingRect().width-(this.alarm.getBoundingRect().width-6),this.position[1]-this.alarm.getBoundingRect().height-3];
	            this.alarm.attr("position",groupPosition);
	        }
	    };
	
	
	    SubProcessNode.prototype.toJSON = function() {
	        this.model.set("resourceId", this.resourceId);
	        this.model.set("properties.type", this.bpmnInfo.type);
	        this.model.set("stencil.type", this.bpmnInfo.name);  //stencil.id
	        if (this.slotEvent && this.slotEvent.length > 0) {
	            var arrSlotEvent = [];
	            for (var i = this.slotEvent.length - 1; i >= 0; i--) {
	                arrSlotEvent.push(this.slotEvent[i].resourceId)
	            }
	            this.model.set("properties.slotEvent", arrSlotEvent);
	        }
	            // var rect = this.getRect();
	            // this.model.set("bounds.upperLeft.x", rect.x);
	            // this.model.set("bounds.upperLeft.y", rect.y);
	            // this.model.set("bounds.lowerRight.x", rect.x + rect.boundingRect.width);
	            // this.model.set("bounds.lowerRight.y", rect.y + rect.boundingRect.height);
	
	        var rect = this.getRect().boundingRect;
	        this.model.set("bounds.upperLeft.x", rect.x);
	        this.model.set("bounds.upperLeft.y", rect.y);
	        this.model.set("bounds.lowerRight.x", rect.x + rect.width);
	        this.model.set("bounds.lowerRight.y", rect.y + rect.height);
	
	
	
	        // 加入子流程的 节点
	        var arrChildSahpes = [];
	        this.eachChild(function(child){
	            if (child instanceof BPMNNode) {
	                arrChildSahpes.push(child.toJSON());
	            }
	
	            if (child instanceof Connector) {
	                arrChildSahpes.push(child.toJSON());
	            }
	        });
	
	
	
	        this.model.set("childShapes", arrChildSahpes);
	        return this.model.option;
	    };
	
		zrUtil.inherits(SubProcessNode,BPMNNode);
		module.exports = SubProcessNode;
	


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 连接线
	 * @author wang.xiaohu
	 */
	
	    var Util = __webpack_require__(73);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var Node = __webpack_require__(76);
	    var symbolUtil = __webpack_require__(97);
	    var Handle = __webpack_require__(98);
	    var EffectLine = __webpack_require__(99);
	    var ConnectionPoint = __webpack_require__(100);
	    var Point = __webpack_require__(60);
	    /**
	     * 构造函数
	     * @param {[type]} options [description]
	     */
	    function Connector(options) {
	        Node.call(this);
	        if (options.model && options.model.option && options.model.option.resourceId) {
	            this.resourceId = options.model.option.resourceId;
	        } else {
	            this.resourceId = Util.getUUID(); // 生成节点ID
	        }
	        var defaultOptions = {
	            symbol: { type: "arrow", size: 10, color: "#000000" }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	            style: { lineWidth: 1, stroke: "#000000", lineType: Connector.TYPE_STRAIGHT }, //样式
	            hoverStyle: { lineWidth: 2, stroke: "lime" }, //移上去的样式
	            arrowHoverStyle: { fill: "lime" },
	            shape: { points: null, smooth: false, smoothConstraint: null }, //形状
	            position: [0, 0],
	            isEdit: true, //是否可编辑
	            text: {
	                text: "",
	                color: '#000000', // 文本颜色
	                textFont: '12px Microsoft YaHei'
	            },
	            z: 0
	        }
	        var opt = options || {};
	        this.options = zrUtil.merge(defaultOptions, opt, true);
	        this.model = options.model;
	        this.handles = [];
	        this.connectionPoints = [];
	        this.conPointsGroup = null;
	        this.startNode = null;
	        this.endNode = null;
	        this.autoChangePosition = false
	        this.line = null;
	        this.groupCurve = new graphic.Group();
	        this.icons = []; // 用于存储线段上面的操作图标
	        this.render();
	    }
	
	    Connector.TYPE_STRAIGHT = 'straight';
	
	    Connector.TYPE_JAGGED = 'jagged';
	
	    Connector.TYPE_CURVE = 'curve';
	
	    Connector.RADIUS = 3;
	
	    Connector.START_NODE = "startNode";
	
	    Connector.END_NODE = "endNode";
	
	    Connector.LEFT = "left";
	
	    Connector.RIGHT = "right";
	
	    Connector.TOP = "top";
	
	    Connector.BOTTOM = "bottom";
	
	    Connector.BOTTOM = "bottom";
	
	    Connector.SEPERATOR = "-";
	    /**
	     * 重新画线，如果传空则根据turningPoints 重新画线
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    Connector.prototype.refresh = function(points) {
	        if (points) {
	            this.turningPoints = points;
	        }
	        //将[x:0,y:0]转化为[0, 0]  给zrender使用
	        var points = Util.traslatePoints(this.turningPoints);
	
	        if ((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {
	            this.modifyCurve(this.turningPoints);
	        } else {
	            this.line.attr('shape', { points: points });
	        }
	
	        var lineText = this.childOfName('lineText');
	        //开始没有创建文本，后来传进来text了，需要先创建文本
	        if (!lineText && this.options.text.text) {
	            var text = this.drawText("lineText", this.options.text.text, 0, 0);
	            this.add(text.text);
	            lineText = this.childOfName('lineText');
	        }
	        if (lineText) {
	            lineText.setStyle("text", this.options.text.text);
	
	            var textPoint = this.getTextPostion(this.options.text);
	
	            // if (this.options.style.lineType == Connector.TYPE_STRAIGHT ) {
	            //     lineText.attr('rotation', this.getTextRotation(textPoint));
	            // }
	
	            lineText.attr("position", textPoint);
	        }
	        var symbolTo = this.childOfName('toSymbol');
	        if (symbolTo) {
	            if (this.options.effect && this.options.effect.show) {
	                new EffectLine(symbolTo, this.options, this.groupCurve, this.polyLine);
	            } else {
	                symbolTo.attr('position', points[points.length - 1]);
	                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]));
	            }
	        }
	    };
	    /**
	     * 渲染
	     * @return {[type]} [description]
	     */
	    Connector.prototype.render = function() {
	        var that = this;
	        //1.创建箭头
	        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle
	        if (symbolTo) {
	            this.add(symbolTo);
	        }
	
	        //2.创建线
	        this.curveLine = new graphic.BezierCurve({
	            position: this.options.position,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.groupCurve.add(this.curveLine);
	        this.add(this.groupCurve);
	
	        this.polyLine = new graphic.Polyline({
	            position: this.options.position,
	            shape: this.options.shape,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.add(this.polyLine);
	
	        if ((this.options.style.lineType == Connector.TYPE_CURVE)) {
	            this.line = this.groupCurve;
	            this.createHoverStyle(this.curveLine);
	            this.polyLine.hide();
	        } else {
	            this.line = this.polyLine;
	            this.createHoverStyle(this.polyLine);
	            this.curveLine.hide();
	        }
	
	        //3.侦听线事件
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click']; //'click', 'dblclick', 'mouseover', 'mouseout'
	        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	            this.line.on(eveName, zrUtil.bind(function(e) {
	                e.cancelBubble = true;
	                var params = {};
	                params.event = e;
	                params.type = "Connector:" + eveName;
	                params.target = that;
	                this.trigger(params.type, params);
	                if (this.options.isEdit == false) {
	                    return; }
	
	                if (this.options.isEdit && this.connectionPoints.length < 1 && this.turningPoints.length >= 2) {
	                    this.createAllconnectionPoint()
	                }
	                if (this.handles.length < 1) {
	                    this.shapeSetHandle();
	                }
	            }, this));
	        }, this);
	
	        //3.创建调整线的连接点
	        if (this.options.isEdit) {
	            this.conPointsGroup = new graphic.Group();
	            this.add(this.conPointsGroup);
	        }
	
	        //4.创建线上文本
	        if (this.options.text.text && this.options.text.text != "") {
	            var text = this.drawText("lineText", this.options.text.text, 0, 0);
	            this.add(text.text);
	        }
	
	
	    };
	
	    //设置style
	    Connector.prototype.setStyle = function(options) {
	        if (options.color) {
	            if (this.options.style.lineType == Connector.TYPE_CURVE) {
	                this.groupCurve.eachChild(function(curve) {
	                    curve.attr("style", { stroke: options.color });
	                    graphic.setNormalStyle(curve, { stroke: options.color });
	                });
	            } else {
	                this.polyLine.attr("style", { stroke: options.color });
	                graphic.setNormalStyle(this.polyLine, { stroke: options.color });
	            }
	            var symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) {
	                symbolTo.attr("style", { fill: options.color });
	                graphic.setNormalStyle(symbolTo, { fill: options.color });
	            }
	            this.options.style.stroke = options.color;
	            this.model.set("options.style.stroke", options.color);
	            this.model.set("options.symbol.color", options.color);
	            this.options.symbol.color = options.color;
	        }
	
	        if (options.text) {
	            var lineText = this.childOfName('lineText');
	            //开始没有创建文本，后来传进来text了，需要先创建文本
	            if (!lineText && options.text.text) {
	                var text = this.drawText("lineText", options.text.text, 0, 0);
	                this.add(text.text);
	                lineText = this.childOfName('lineText');
	            }
	
	            if (options.text.text || options.text.text == "") {
	                lineText.setStyle("text", options.text.text);
	                this.options.text.text = options.text.text;
	            }
	            var textPoint = this.getTextPostion(options.text);
	            lineText.attr("position", textPoint);
	            if (options.text.textPos) {
	                this.options.text.textPos = options.text.textPos;
	            } else {
	                this.options.text.textPos = 'center';
	            }
	            if (options.text.color) {
	                lineText.attr("style", {
	                    fill: options.text.color
	                });
	                this.options.text.color = options.text.color;
	            }
	            this.model.set("options.text", options.text);
	        }
	
	        if (options.symbol) {
	            if (options.symbol.type) {
	                this.options.symbol.type = options.symbol.type;
	                this.model.set("options.symbol.type", options.symbol.type);
	            }
	            if (options.symbol.size) {
	                this.options.symbol.size = options.symbol.size;
	                this.model.set("options.symbol.size", options.symbol.size);
	            }
	            if (options.symbol.color) {
	                this.options.symbol.color = options.symbol.color;
	                this.model.set("options.symbol.color", options.symbol.color);
	            }
	            if (options.symbol.z) {
	                this.options.symbol.z = options.symbol.z;
	                this.model.set("options.symbol.z", options.symbol.z);
	            };
	
	            var symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) {
	                this.remove(symbolTo);
	            }
	            var symbol = this.createSymbol("toSymbol", this.model.get("options"))
	            if (symbol) {
	                this.add(symbol);
	            }
	            this.refresh();
	        }
	
	    };
	
	    /**
	     * 获取线段的位置
	     * @param  {Object} text {text:'', color:'', textPos:''}
	     * @return {Object}      {x,y}
	     */
	    Connector.prototype.getTextPostion = function(text) {
	        var textPostion = [];
	        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	        if (text && text.textPos) {
	            if (text.textPos == 'start') {
	                var xOffset = text.xOffset || 0;
	                textPostion = [this.turningPoints[0].x + xOffset, this.turningPoints[0].y];
	            } else if (text.textPos == 'end') {
	                var points = Util.getMaxLineLength([this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]]);
	                var angle = Util.getAngle(points[0], points[1]);
	                var length = Util.distance(points[0], points[1]) - textWidth;
	                var newPoint = Util.getEndPoint(points[0], length, angle);
	                textPostion = [newPoint.x, newPoint.y];
	            } else {
	                textPostion = this.middle(text);
	            }
	        } else {
	            var position = this.middle(text);
	            textPostion = [position[0] - textWidth / 2, position[1]];
	        }
	
	        return textPostion;
	    };
	
	    /**
	     * 获取线段的旋转角度
	     * @param  {Object} textPostion {x,y}
	     * @return {Number}             角度值
	     */
	    Connector.prototype.getTextRotation = function(textPostion) {
	        //计算出极坐标的角度
	        var points = Util.getMaxLineLength(this.turningPoints);
	        var angle = -Math.atan2(points[1].y - textPostion[1], points[1].x - textPostion[0]); //,Math.PI/2
	        return angle;
	    };
	
	    Connector.prototype.createHoverStyle = function(el) {
	        if (this.options.hoverStyle) {
	            graphic.setElementHoverStl(el, this.options.hoverStyle);
	
	            var symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) { graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle); }
	
	            el.on('mouseover', zrUtil.bind(function() {
	                    graphic.doEnterHover(el);
	                    if (symbolTo) { graphic.doEnterHover(symbolTo); }
	
	                    this.groupCurve.eachChild(function(line) {
	                        graphic.doEnterHover(line);
	                    });
	                }, this))
	                .on('mouseout', zrUtil.bind(function() {
	                    graphic.doLeaveHover(el);
	                    if (symbolTo) { graphic.doLeaveHover(symbolTo); }
	                    this.groupCurve.eachChild(function(line) {
	                        graphic.doLeaveHover(line);
	                    });
	                }, this));
	        }
	    };
	    /**
	     * 创建Node的连接点
	     * @private
	     *
	     * @return {[type]} [description]
	     */
	    Connector.prototype.createAllconnectionPoint = function() {
	        var sRect = this.startNode.getRect ? this.startNode.getRect().boundingRect : Util.getRect(this.startNode).boundingRect;
	
	        var eRect = this.endNode.getRect ? this.endNode.getRect().boundingRect : Util.getRect(this.endNode).boundingRect;
	
	        var sConnectorPoint = Util.getConnectorPoints(sRect);
	        var eConnectorPoint = Util.getConnectorPoints(eRect);
	
	        this.connectionPointCreate(this.startNode, sConnectorPoint.left, Connector.START_NODE + Connector.SEPERATOR + Connector.LEFT);
	        this.connectionPointCreate(this.startNode, sConnectorPoint.right, Connector.START_NODE + Connector.SEPERATOR + Connector.RIGHT);
	        this.connectionPointCreate(this.startNode, sConnectorPoint.top, Connector.START_NODE + Connector.SEPERATOR + Connector.TOP);
	        this.connectionPointCreate(this.startNode, sConnectorPoint.bottom, Connector.START_NODE + Connector.SEPERATOR + Connector.BOTTOM);
	
	        this.connectionPointCreate(this.endNode, eConnectorPoint.left, Connector.END_NODE + Connector.SEPERATOR + Connector.LEFT);
	        this.connectionPointCreate(this.endNode, eConnectorPoint.right, Connector.END_NODE + Connector.SEPERATOR + Connector.RIGHT);
	        this.connectionPointCreate(this.endNode, eConnectorPoint.top, Connector.END_NODE + Connector.SEPERATOR + Connector.TOP);
	        this.connectionPointCreate(this.endNode, eConnectorPoint.bottom, Connector.END_NODE + Connector.SEPERATOR + Connector.BOTTOM);
	
	
	        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);
	
	        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length - 1].clone(), ConnectionPoint.TYPE_CONNECTOR);
	    };
	
	    /**
	     * 创建连接点
	     * @private
	     * @param  {[type]} shape [description]
	     * @param  {[type]} point [description]
	     * @param  {[type]} type  [description]
	     * @return {[type]}       [description]
	     */
	    Connector.prototype.connectionPointCreate = function(shape, point, type) {
	        var conPoint = new ConnectionPoint(this, point, type, this.options);
	        this.conPointsGroup.add(conPoint.shape);
	    };
	
	    /**
	     * 清空控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.clearHandles = function() {
	        for (var i = 0; i < this.handles.length; i++) {
	            this.remove(this.handles[i].handleShape);
	        }
	        this.handles = [];
	        if (this.conPointsGroup) {
	            this.conPointsGroup.removeAll();
	        }
	    };
	
	    /**
	     * 创建拆线 线断的控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.shapeSetHandle = function() {
	        for (var i = 1; i < this.turningPoints.length - 2; i++) {
	            var h;
	            var x, y;
	            //是否在一条线上
	            var isCollineaityFirst = Util.collinearity(this.turningPoints[i - 1], this.turningPoints[i], this.turningPoints[i + 1]);
	            var isCollineaitySecond = Util.collinearity(this.turningPoints[i], this.turningPoints[i + 1], this.turningPoints[i + 2]);
	            if ((!isCollineaityFirst && (!isCollineaitySecond || this.turningPoints[i + 1].equals(this.turningPoints[i + 2]))) || ((!isCollineaityFirst || this.turningPoints[i - 1].equals(this.turningPoints[i])) && !isCollineaitySecond)) {
	
	                if (this.turningPoints[i].x === this.turningPoints[i + 1].x) { //same vertical
	                    x = this.turningPoints[i].x;
	                    y = (this.turningPoints[i].y + this.turningPoints[i + 1].y) / 2;
	
	                    h = new Handle('h', x, y, this);
	
	
	                } else if (this.turningPoints[i].y === this.turningPoints[i + 1].y) { // same horizontal
	                    x = (this.turningPoints[i].x + this.turningPoints[i + 1].x) / 2;
	                    y = this.turningPoints[i].y;
	                    h = new Handle('v', x, y, this);
	                }
	                if (h) {
	                    this.add(h.handleShape);
	                    this.handles.push(h);
	                }
	
	            }
	        }
	    };
	
	
	    /**
	     * 创建箭头
	     * @param  {[type]} name       [description]
	     * @param  {[type]} options [description]
	     * @return {[type]}            [description]
	     */
	    Connector.prototype.createSymbol = function(name, options) {
	        var symbolType = options.symbol.type;
	        var symbolSize = options.symbol.size;
	        if (symbolType === 'none') {
	            return;
	        }
	
	        if (!zrUtil.isArray(symbolSize)) {
	            symbolSize = [symbolSize, symbolSize];
	        }
	
	        var symbolZIndex = options.z;
	
	        if (options.symbol.z) { symbolZIndex = options.symbol.z };
	
	        var symbolPath = symbolUtil.createSymbol(
	            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,
	            symbolSize[0], symbolSize[1], options.symbol.color, symbolZIndex
	        );
	        symbolPath.name = name;
	
	        return symbolPath;
	    };
	
	    /**
	     * 绘制线段上的文本
	     * @param  {[type]} content [description]
	     * @param  {[type]} name [description]
	     * @param  {[type]} x       [description]
	     * @param  {[type]} y       [description]
	     * @param  {[type]} color   [description]
	     * @return {[type]}         [description]
	     */
	    Connector.prototype.drawText = function(name, content, x, y, color) {
	        var text = new graphic.Text({
	            style: {
	                text: content,
	                x: x,
	                y: y,
	                fill: color ? color : this.options.text.color,
	                textFont: this.options.text.textFont
	            },
	            zlevel: 20
	        });
	        text.name = name;
	        return {
	            text: text,
	            rect: text.getBoundingRect()
	        };
	    };
	
	    /**
	     * 获取线段的中间值
	     * @return {[type]} text
	     */
	    Connector.prototype.middle = function(text) {
	
	        if (this.options.style.lineType == Connector.TYPE_STRAIGHT) {
	            var points = Util.getMaxLineLength(this.turningPoints);
	            //如果是求线段上的文字的中间值
	            // if(text) {
	            //     //取出字的长度，计算角度，
	            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	            //     var angle = Util.getAngle(points[0],points[1]);
	            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;
	            //     var newPoint = Util.getEndPoint(points[0], length, angle);
	            //     return [newPoint.x, newPoint.y];
	            // } else {
	            //     var middleX = (points[0].x + points[1].x)/2;
	            //     var middleY = (points[0].y + points[1].y) /2;
	            //     return [middleX, middleY];
	            // }
	            var middleX = (points[0].x + points[1].x) / 2;
	            var middleY = (points[0].y + points[1].y) / 2;
	            return [middleX, middleY];
	        } else if (this.options.style.lineType == Connector.TYPE_JAGGED) {
	
	            //find total distance
	            var distance = this.getLength();
	
	            //find between what turning points the half distance is
	            var index = -1;
	            var ellapsedDistance = 0;
	            for (var i = 0; i < this.turningPoints.length - 1; i++) {
	                index = i;
	                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);
	                if (ellapsedDistance + segment < distance / 2) {
	                    ellapsedDistance += segment;
	                } else {
	                    break;
	                }
	            }
	
	            //we have the middle distance somewhere between i(ndex) and i(ndex)+1
	            if (index != -1) {
	                var missingDistance = distance / 2 - ellapsedDistance;
	                if (Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3)) { //vertical segment (same x)
	                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];
	                } else if (Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3)) { //horizontal segment (same y)
	                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];
	                } else {
	                    console.error("Connector:middle() - this should never happen " + this.turningPoints[index] + " " + this.turningPoints[index + 1] + " nr of points " + this.turningPoints.length);
	                }
	
	            }
	        } else if (this.options.style.lineType == Connector.TYPE_CURVE) {
	            var t = 0.5;
	            var l = this.getLength();
	
	            var walked = 0;
	            for (var j = 0; j < this.turningPoints.length - 1; j++) {
	                if (walked + Util.distance(this.turningPoints[j], this.turningPoints[j + 1]) > l * t) {
	                    break;
	                }
	
	                walked += Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);
	            }
	
	            var rest = l * t - walked;
	            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);
	
	            //find the position/ration of the middle of Polyline on current segment
	            var segmentPercent = rest / currentSegmentLength;
	
	            var Xp = segmentPercent * (this.turningPoints[j + 1].x - this.turningPoints[j].x) + this.turningPoints[j].x;
	            var Yp = segmentPercent * (this.turningPoints[j + 1].y - this.turningPoints[j].y) + this.turningPoints[j].y;
	
	            return [Xp, Yp];
	
	        }
	
	        return null;
	    };
	
	    /**
	     * find total distance
	     * @return {Number} [description]
	     */
	    Connector.prototype.getLength = function() {
	        //find total distance
	        var distance = 0;
	        for (var i = 0; i < this.turningPoints.length - 1; i++) {
	            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);
	        }
	        return distance;
	    };
	
	    /**
	     * 转JSON对象
	     * @return {[type]} [description]
	     */
	    Connector.prototype.toJSON = function() {
	
	        this.model.set("resourceId", this.resourceId);
	        this.model.set("properties.type", 14);
	
	        this.model.set("bounds.upperLeft.x", this.position[0]);
	        this.model.set("bounds.upperLeft.y", this.position[1]);
	        this.model.set("bounds.lowerRight.x", parseInt(this.position[0] + this.getBoundingRect().width));
	        this.model.set("bounds.lowerRight.y", parseInt(this.position[1] + this.getBoundingRect().height));
	        this.model.set("style.sPos", this.sPos);
	        this.model.set("style.ePos", this.ePos);
	        this.model.set("dockers", this.turningPoints);
	        return this.model.option;
	    };
	
	    /**
	     * refreshModel
	     * @return {[type]} [description]
	     */
	    Connector.prototype.refreshModel = function() {
	        this.model.set("options.dockers", this.turningPoints);
	        var icons = [];
	        for (var i = 0; i < this.icons.length; i++) {
	            var iconNode = this.icons[i];
	            var option = [iconNode.key, {
	                icon: iconNode.style.image,
	                width: iconNode.style.width,
	                height: iconNode.style.height
	            }];
	            icons.push(option);
	        }
	        this.model.set("icons", icons);
	    };
	
	    /**
	     * 调整曲线的形状
	     * @param  {array} points 点数组
	     * @return {void}
	     */
	    Connector.prototype.modifyCurve = function(points) {
	        var sol = this.getCurvePoint(points);
	
	        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段
	        var willDelCurves = [];
	        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve; j++) {
	            willDelCurves.push(this.groupCurve.childAt(j));
	        }
	        zrUtil.each(willDelCurves, function(curve) {
	            this.groupCurve.remove(curve);
	        }, this);
	        // 2. 遍历曲线   如果存在则直接设置形状，否则创建
	        for (var i = 0; i < sol.length; i++) {
	            var line = this.groupCurve.childAt(i);
	            if (line) {
	                line.attr('shape', sol[i]);
	            } else {
	                var cure = new graphic.BezierCurve({
	                    position: this.options.position,
	                    style: this.options.style,
	                    shape: sol[i],
	                    z: this.options.z
	                });
	                this.groupCurve.add(cure);
	                this.createHoverStyle(cure);
	            }
	        }
	    };
	
	
	    /**
	     * 根据传入的点数组计算曲线的点
	     * @param  {array} P 点数组
	     * @return {object}        曲线的点数组
	     */
	    Connector.prototype.getCurvePoint = function(P) {
	        var n = P.length;
	        var sol = [];
	        if (n === 3) {
	            sol.push({
	                x1: P[0].x,
	                y1: P[0].y,
	                cpx1: P[1].x,
	                cpy1: P[1].y,
	                x2: P[2].x,
	                y2: P[2].y
	            });
	            return sol;
	        } else if (n === 4) {
	            sol.push({
	                x1: P[0].x,
	                y1: P[0].y,
	                cpx1: P[1].x,
	                cpy1: P[1].y,
	                cpx2: P[2].x,
	                cpy2: P[2].y,
	                x2: P[3].x,
	                y2: P[3].y
	            });
	            return sol;
	        }
	
	        /**Computes factorial
	         * @param {Number} k the number
	         * */
	        function fact(k) {
	            if (k === 0 || k === 1) {
	                return 1;
	            } else {
	                return k * fact(k - 1);
	            }
	        }
	
	        /**Computes Bernstain*/
	        function B(i, n, u) {
	            return fact(n) / (fact(i) * fact(n - i)) * Math.pow(u, i) * Math.pow(1 - u, n - i);
	        }
	
	        /**Computes the sum between two point
	         *@param p1 - {Point}
	         *@param p2 - {Point}
	         *@return {Point} the sum of initial points
	         **/
	        function sum(p1, p2) {
	            return new Point(p1.x + p2.x, p1.y + p2.y);
	        }
	
	        /**Computes the difference between first {Point} and second {Point}
	         *@param p1 - {Point}
	         *@param p2 - {Point}
	         *@return {Point} the sum of initial points
	         **/
	        function minus(p1, p2) {
	            return new Point(p1.x - p2.x, p1.y - p2.y);
	        }
	
	        /**Computes the division of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function divide(p, nr) {
	            if (nr == 0) {
	                throw "Division by zero not allowed (yet :) " + this.callee;
	            }
	            return new Point(p.x / nr, p.y / nr);
	        }
	
	        /**Computes the multiplication of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function multiply(p, nr) {
	            return new Point(p.x * nr, p.y * nr);
	        }
	
	
	
	
	        /*
	         *I do not get why first 4 must be 0 and last 3 of same value.....
	         *but otherwise we will get division by zero
	         */
	        var k = [0, 0, 0];
	
	        var j;
	        for (j = 0; j <= n - 3; j++) {
	            k.push(j);
	        }
	
	        k.push(n - 3, n - 3);
	
	
	
	        for (i = 1; i <= n - 3; i++) {
	            //q1 - compute start point
	            var q1 = divide(sum(multiply(P[i], k[i + 4] - k[i + 2]), multiply(P[i + 1], k[i + 2] - k[i + 1])), k[i + 4] - k[i + 1]);
	
	            //q0 - compute 1st controll point
	            var q_01 = (k[i + 3] - k[i + 2]) / (k[i + 3] - k[i + 1]);
	            var q_02 = divide(sum(multiply(P[i - 1], k[i + 3] - k[i + 2]), multiply(P[i], k[i + 2] - k[i])), k[i + 3] - k[i]);
	            var q_03 = multiply(q1, (k[i + 2] - k[i + 1]) / (k[i + 3] - k[i + 1]));
	            var q0 = sum(multiply(q_02, q_01), q_03);
	
	            //q2 - compute 2nd controll point
	            var q2 = divide(sum(multiply(P[i], k[i + 4] - k[i + 3]), multiply(P[i + 1], k[i + 3] - k[i + 1])), k[i + 4] - k[i + 1]);
	
	            //q3 - compute end point
	            var q_31 = (k[i + 3] - k[i + 2]) / (k[i + 4] - k[i + 2]);
	            var q_32 = divide(sum(multiply(P[i + 1], k[i + 5] - k[i + 3]), multiply(P[i + 2], k[i + 3] - k[i + 2])), k[i + 5] - k[i + 2]);
	            var q_33 = multiply(q2, (k[i + 4] - k[i + 3]) / (k[i + 4] - k[i + 2]));
	            var q3 = sum(multiply(q_32, q_31), q_33);
	
	            //store solution
	            //
	            sol.push({
	                x1: q0.x,
	                y1: q0.y,
	                cpx1: q1.x,
	                cpy1: q1.y,
	                cpx2: q2.x,
	                cpy2: q2.y,
	                x2: q3.x,
	                y2: q3.y
	            });
	        }
	
	        return sol;
	    };
	
	
	    Util.inherits(Connector, Node);
	
	    module.exports = Connector;
	
	


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// Symbol factory
	
	
	    var graphic = __webpack_require__(3);
	    var BoundingRect = __webpack_require__(25);
	    /**
	     * Triangle shape
	     * @inner
	     */
	    var Triangle = graphic.extendShape({
	        type: 'triangle',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy + height);
	            path.lineTo(cx - width, cy + height);
	            path.closePath();
	        }
	    });
	    /**
	     * Diamond shape
	     * @inner
	     */
	    var Diamond = graphic.extendShape({
	        type: 'diamond',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy);
	            path.lineTo(cx, cy + height);
	            path.lineTo(cx - width, cy);
	            path.closePath();
	        }
	    });
	
	    /**
	     * Pin shape
	     * @inner
	     */
	    var Pin = graphic.extendShape({
	        type: 'pin',
	        shape: {
	            // x, y on the cusp
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (path, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var w = shape.width / 5 * 3;
	            // Height must be larger than width
	            var h = Math.max(w, shape.height);
	            var r = w / 2;
	
	            // Dist on y with tangent point and circle center
	            var dy = r * r / (h - r);
	            var cy = y - h + r + dy;
	            var angle = Math.asin(dy / r);
	            // Dist on x with tangent point and circle center
	            var dx = Math.cos(angle) * r;
	
	            var tanX = Math.sin(angle);
	            var tanY = Math.cos(angle);
	
	            path.arc(
	                x, cy, r,
	                Math.PI - angle,
	                Math.PI * 2 + angle
	            );
	
	            var cpLen = r * 0.6;
	            var cpLen2 = r * 0.7;
	            path.bezierCurveTo(
	                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,
	                x, y - cpLen2,
	                x, y
	            );
	            path.bezierCurveTo(
	                x, y - cpLen2,
	                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,
	                x - dx, cy + dy
	            );
	            path.closePath();
	        }
	    });
	
	    /**
	     * Arrow shape
	     * @inner
	     */
	    var Arrow = graphic.extendShape({
	
	        type: 'arrow',
	
	        shape: {
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var height = shape.height;
	            var width = shape.width;
	            var x = shape.x;
	            var y = shape.y;
	            var dx = width / 3 * 2;
	            ctx.moveTo(x, y);
	            ctx.lineTo(x + dx, y + height);
	            ctx.lineTo(x, y + height / 4 * 3);
	            ctx.lineTo(x - dx, y + height);
	            ctx.lineTo(x, y);
	            ctx.closePath();
	        }
	    });
	
	    /**
	     * Map of path contructors
	     * @type {Object.<string, module:zrender/graphic/Path>}
	     */
	    var symbolCtors = {
	        line: graphic.Line,
	
	        rect: graphic.Rect,
	
	        roundRect: graphic.Rect,
	
	        square: graphic.Rect,
	
	        circle: graphic.Circle,
	
	        diamond: Diamond,
	
	        pin: Pin,
	
	        arrow: Arrow,
	
	        triangle: Triangle
	    };
	
	    var symbolShapeMakers = {
	
	        line: function (x, y, w, h, shape) {
	            // FIXME
	            shape.x1 = x;
	            shape.y1 = y + h / 2;
	            shape.x2 = x + w;
	            shape.y2 = y + h / 2;
	        },
	
	        rect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        roundRect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	            shape.r = Math.min(w, h) / 4;
	        },
	
	        square: function (x, y, w, h, shape) {
	            var size = Math.min(w, h);
	            shape.x = x;
	            shape.y = y;
	            shape.width = size;
	            shape.height = size;
	        },
	
	        circle: function (x, y, w, h, shape) {
	            // Put circle in the center of square
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.r = Math.min(w, h) / 2;
	        },
	
	        diamond: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        pin: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        arrow: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        triangle: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        }
	    };
	
	    var symbolBuildProxies = {};
	    for (var name in symbolCtors) {
	        symbolBuildProxies[name] = new symbolCtors[name]();
	    }
	
	    var Symbol = graphic.extendShape({
	
	        type: 'symbol',
	
	        shape: {
	            symbolType: '',
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        beforeBrush: function () {
	            var style = this.style;
	            var shape = this.shape;
	            // FIXME
	            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {
	                style.textPosition = ['50%', '40%'];
	                style.textAlign = 'center';
	                style.textVerticalAlign = 'middle';
	            }
	        },
	
	        buildPath: function (ctx, shape) {
	            var symbolType = shape.symbolType;
	            var proxySymbol = symbolBuildProxies[symbolType];
	            if (shape.symbolType !== 'none') {
	                if (!proxySymbol) {
	                    // Default rect
	                    symbolType = 'rect';
	                    proxySymbol = symbolBuildProxies[symbolType];
	                }
	                symbolShapeMakers[symbolType](
	                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape
	                );
	                proxySymbol.buildPath(ctx, proxySymbol.shape);
	            }
	        }
	    });
	
	    // Provide setColor helper method to avoid determine if set the fill or stroke outside
	    var symbolPathSetColor = function (color) {
	        if (this.type !== 'image') {
	            var symbolStyle = this.style;
	            var symbolShape = this.shape;
	            if (symbolShape && symbolShape.symbolType === 'line') {
	                symbolStyle.stroke = color;
	            }
	            else if (this.__isEmptyBrush) {
	                symbolStyle.stroke = color;
	                symbolStyle.fill = '#fff';
	            }
	            else {
	                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?
	                symbolStyle.fill && (symbolStyle.fill = color);
	                symbolStyle.stroke && (symbolStyle.stroke = color);
	            }
	            this.dirty();
	        }
	    };
	
	    var symbolUtil = {
	        /**
	         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
	         * @param {string} symbolType
	         * @param {number} x
	         * @param {number} y
	         * @param {number} w
	         * @param {number} h
	         * @param {number} z
	         * @param {string} color
	         */
	        createSymbol: function (symbolType, x, y, w, h, color, z) {
	            var isEmpty = symbolType.indexOf('empty') === 0;
	            if (isEmpty) {
	                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
	            }
	            var symbolPath;
	
	            if (symbolType.indexOf('image://') === 0) {
	                symbolPath = new graphic.Image({
	                    style: {
	                        image: symbolType.slice(8),
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	            else if (symbolType.indexOf('path://') === 0) {
	                symbolPath = graphic.makePath(symbolType.slice(7), {z: z}, new BoundingRect(x, y, w, h));
	            }
	            else {
	                symbolPath = new Symbol({
	                    shape: {
	                        symbolType: symbolType,
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	
	            symbolPath.__isEmptyBrush = isEmpty;
	
	            symbolPath.setColor = symbolPathSetColor;
	
	            symbolPath.setColor(color);
	
	            return symbolPath;
	        }
	    };
	
	    module.exports = symbolUtil;
	


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 画句柄
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(3);
	    var Util = __webpack_require__(73);
	    function Handle(type, x, y, connector){
	        this.type = type;
	
	        this.x = x;
	
	        this.y = y;
	
	        this.visible = true;
	
	        this.connector = connector;
	
	        this.handleShape = new graphic.Circle({
	            shape: {
	                cx: x,
	                cy: y,
	                r: Handle.RADIUS
	            },
	
	            style: {
	                fill: "rgb(0,255,0)",
	                stroke:"rgb(0,0,0)"
	            },
	            z : connector.options.z + 2,  //节点Z为1 线段为0;
	            draggable:true
	        });
	
	        var that = this;
	        this.handleShape.on("drag", function(e) {
	            that.actionConnector(e.offsetX,e.offsetY);
	        });
	       // return this.circle;
	    }
	
	    Handle.RADIUS = 4;
	
	    Handle.prototype = {
	
	        constructor : Handle,
	
	        equals : function(anotherHandle){
	            if(!anotherHandle instanceof Handle){
	                return false;
	            }
	
	            return this.type == anotherHandle.type
	            && this.x == anotherHandle.x
	            && this.y == anotherHandle.y
	            && this.visible == anotherHandle.visible;
	        },
	
	        /**
	         * 移动句柄
	         * @param  {[type]} newX [description]
	         * @param  {[type]} newY [description]
	         * @return {[type]}      [description]
	         */
	        actionConnector: function(newX, newY){
	            switch(this.type){
	                case 'v':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y
	                            && this.connector.turningPoints[i].y == this.y
	                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x
	                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)
	                        {
	                            index = i;
	                        }
	                    }
	                    var deltaY = newY - this.y;
	                    var translationMatrix = Util.translationMatrix(0, deltaY);
	
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	                    this.y = newY;  //将句柄新的位置赋值给y
	
	                    break;
	
	                case 'h':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x
	                            && this.connector.turningPoints[i].x == this.x
	                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y
	                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)
	                            {
	                            index = i;
	                        }
	                    }
	                    var deltaX = newX-this.x;
	                    var translationMatrix = Util.translationMatrix(deltaX, 0);
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	                    this.x = newX; //将句柄新的位置赋值给x
	
	                    break;
	            }
	           //. this.shape.updateMiddleText();
	        }
	    };
	    module.exports = Handle;
	
	
	


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 连线动态效果
	 * @author miao.cunzhi
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var vec2 = __webpack_require__(14);
	    var curveUtil = __webpack_require__(27);
	    var symbolUtil = __webpack_require__(97);
	
	    function EffectLine(symbol, options, groupCurve, polyLine) {
	        this._lastFrame = 0;
	        this._lastFramePercent = 0;
	        this.symbol = symbol;
	        this.groupCurve = groupCurve;
	        this.initSymbol(options, polyLine);
	    }
	    var EffectLineProto = EffectLine.prototype;
	
	    EffectLineProto.initSymbol = function(options, polyLine) {
	        var that = this;
	        this.symbol.z2 = 100;
	        this.symbol.culling = true;
	        var period = options.effect.period * 1000;
	        this.symbol.__t = 0;
	        this.symbol.stopAnimation();
	        if ((options.style.lineType == "curve")) {
	            if (this.groupCurve) {
	                var i = 0;
	                period = period / this.groupCurve._children.length;
	                this.groupCurveAnimate(this.groupCurve._children[0], i, period);
	            }
	
	        } else {
	            this.symbol.animate('', true)
	                .when(period, {
	                    __t: 1
	                })
	                .delay(0)
	                .during(function() {
	                    that.updateSymbolPositionPolyline();
	                })
	                .start();
	            this.setAnimationPointsPolyline(polyLine.shape.points);
	        }
	
	    };
	
	    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {
	        var that = this;
	        if (curveLine == undefined) {
	            curveLine = this.groupCurve._children[0];
	            i = 0;
	        }
	        var points;
	        var pos = curveLine.shape;
	        points = [
	            [pos.x1, pos.y1],
	            [pos.x2, pos.y2],
	            [pos.cpx1, pos.cpy1],
	            [pos.cpx2, pos.cpy2]
	        ];
	        this.setAnimationPointsBezierCurve(points);
	        this.symbol.animate('')
	            .when(period, {
	                __t: 1
	            })
	            .delay(0)
	            .during(function() {
	                that.updateSymbolPositionBezierCurve();
	            })
	            .done(function() {
	                that.symbol.__t = 0;
	                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);
	            })
	            .start();
	
	    };
	
	
	    EffectLineProto.setAnimationPointsBezierCurve = function(points) {
	        this.symbol.__p1 = points[0];
	        this.symbol.__p2 = points[1];
	        this.symbol.__cp1 = points[2] || [
	            (points[0][0] + points[1][0]) / 2,
	            (points[0][1] + points[1][1]) / 2
	        ];
	        this.symbol.__cp2 = points[3];
	    };
	
	    EffectLineProto.updateSymbolPositionBezierCurve = function() {
	        var p1 = this.symbol.__p1;
	        var p2 = this.symbol.__p2;
	        var cp1 = this.symbol.__cp1;
	        var cp2 = this.symbol.__cp2;
	        var t = this.symbol.__t;
	        var pos = this.symbol.position;
	        var tx, ty;
	        if (cp2[0] != undefined) {
	            var cubicAt = curveUtil.cubicAt;
	            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;
	            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);
	            // Tangent
	            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);
	        } else {
	            var quadraticAt = curveUtil.quadraticAt;
	            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;
	            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);
	            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);
	            // Tangent
	            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);
	            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);
	        }
	        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
	
	        this.symbol.ignore = false;
	    };
	
	    EffectLineProto.setAnimationPointsPolyline = function(points) {
	        this._points = points;
	        var accLenArr = [0];
	        var len = 0;
	        for (var i = 1; i < points.length; i++) {
	            var p1 = points[i - 1];
	            var p2 = points[i];
	            len += vec2.dist(p1, p2);
	            accLenArr.push(len);
	        }
	        if (len === 0) {
	            return;
	        }
	
	        for (var j = 0; j < accLenArr.length; j++) {
	            accLenArr[j] /= len;
	        }
	        this._offsets = accLenArr;
	        this._length = len;
	        this.symbol._lastFrame = 0;
	        this.symbol.__lastFramePercent = 0;
	    };
	
	    EffectLineProto.updateSymbolPositionPolyline = function() {
	        var t = this.symbol.__t;
	        var points = this._points;
	        var offsets = this._offsets;
	        var len = points.length;
	
	        if (!offsets) {
	            // Has length 0
	            return;
	        }
	
	        var lastFrame = this._lastFrame;
	        var frame;
	
	        if (t < this._lastFramePercent) {
	            // Start from the next frame
	            // PENDING start from lastFrame ?
	            var start = Math.min(lastFrame + 1, len - 1);
	            for (frame = start; frame >= 0; frame--) {
	                if (offsets[frame] <= t) {
	                    break;
	                }
	            }
	            // PENDING really need to do this ?
	            frame = Math.min(frame, len - 2);
	        } else {
	            for (var frame = lastFrame; frame < len; frame++) {
	                if (offsets[frame] > t) {
	                    break;
	                }
	            }
	            frame = Math.min(frame - 1, len - 2);
	        }
	        vec2.lerp(
	            this.symbol.position, points[frame], points[frame + 1],
	            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])
	        );
	
	        this._lastFrame = frame;
	        this._lastFramePercent = t;
	        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);
	        this.symbol.rotation = angle - Math.PI / 2;
	        this.symbol.ignore = false;
	    };
	    module.exports = EffectLine;
	


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 控制点
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(3);
	    var Util = __webpack_require__(73);
	    function ConnectionPoint(connector, point, type, options){
	        this.connector = connector;
	
	        this.point = point.clone();
	
	        this.type = type;
	
	        this.color = ConnectionPoint.NORMAL_COLOR;
	
	        this.oType = 'ConnectionPoint';
	
	        this.shape = new graphic.Circle({
	            shape: {
	                cx: this.point.x,
	                cy: this.point.y,
	                r: ConnectionPoint.RADIUS
	            },
	
	            style: {
	                fill: this.color,
	                stroke:'#000000'
	            },
	            z : options.z + 2  //节点Z为1 线段为0;
	        });
	        this.shape.type =  this.type;
	
	        this.shape.connector = connector;
	        //return this.circle;
	    }
	
	    ConnectionPoint.NORMAL_COLOR = "#FFFF33"; //yellow.
	
	    ConnectionPoint.OVER_COLOR = "#FF9900"; //orange
	
	    ConnectionPoint.CONNECTED_COLOR = "#ff0000"; //red
	
	    ConnectionPoint.RADIUS = 4;
	
	    ConnectionPoint.TYPE_FIGURE = 'figure';
	
	    ConnectionPoint.TYPE_CONNECTOR = 'connector';
	
	    ConnectionPoint.prototype = {
	
	        constructor : ConnectionPoint,
	
	        equals : function(anotherConnectionPoint){
	            return this.point.equals(anotherConnectionPoint.point)
	            && this.connector == anotherConnectionPoint.connector
	            && this.type == anotherConnectionPoint.type
	            && this.color == anotherConnectionPoint.color
	            && this.radius == anotherConnectionPoint.radius;
	        }
	
	
	    };
	    module.exports = ConnectionPoint;
	
	
	


/***/ },
/* 101 */
/***/ function(module, exports) {

	/**
	 * BPMN静态方法类
	 * @class fish.topo.FishTopoBpmn.Bpmn
	 */
	
		var Bpmn = {
			BPMN_TYPE:"stencil.type",
			BPMN_SCRIPT_TASK: "ScriptTask",
			BPMN_EVENT_SUB_PROCESS: "SubProcessTask",
			BPMN_TASK:"Task",
			TEMPLATE: "BPMNDiagram",
			RESOURCE_ID: "resourceId",
			SEQUENCE_FLOW: "SequenceFlow",
			SUB_PROCESS: "SubProcess",
			USER_DATA: "properties.userData",
	
			START_EVENT: "StartNoneEvent",
			END_EVENT: "EndNoneEvent",
			USER_TASK: "UserTask",
			MANUAL_TASK: "ManualTask",
			SCRIPT_TASK: "ScriptTask",
			MAIL_TASK: "MailTask",
			CATCH_TIMER_EVENT: "CatchTimerEvent",
			CATCH_SIGNAL_EVENT: "CatchSignalEvent",
			THROW_SIGNAL_EVENT: "ThrowSignalEvent",
			INCLUSIVE_GATEWAY: "InclusiveGateway",
			EXCLUSIVE_GATEWAY: "ExclusiveGateway",
			PARALLEL_GATEWAY: "ParallelGateway",
	
			/**
			 * 判断节点是否 BPMN模板 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isTemplate: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype === Bpmn.TEMPLATE;
			},
	
			/**
			 * 判断节点是否 Activity 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isActivity: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return (bpmntype.indexOf("Task") != -1);
			},
	
			/**
			 * 判断节点是否 子流程 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isSubProcess: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return  bpmntype == Bpmn.SUB_PROCESS
			},
	
			/**
			 * 判断节点是否 网关 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isGateway: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype.indexOf("Gateway") != -1;
			},
	
			/**
			 * 判断节点是否 线段 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isFlow: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype === Bpmn.SEQUENCE_FLOW;
			},
	
			/**
			 * @private
			 * 判断模型是否 线段 类型
			 * @param  {Object}  model 需要判断类型的模型
			 * @return {Boolean}      是 否
			 */
			isFlowModel: function(model) {
				var bpmntype = model.get(Bpmn.BPMN_TYPE);
				return bpmntype === Bpmn.SEQUENCE_FLOW;
			},
	
			/**
			 * 判断节点是否 事件 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isEvent: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype.indexOf("Event") != -1;
			},
	
			/**
			 * 判断节点是否 插糟事件 类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Boolean}      是 否
			 */
			isSlotEvent: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype == Bpmn.CATCH_TIMER_EVENT || bpmntype == Bpmn.CATCH_SIGNAL_EVENT || bpmntype == Bpmn.THROW_SIGNAL_EVENT;
			},
	
			/**
			 * 获取当前节点的类型
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {String}      节点的类型
			 */
			getType: function(node) {
				var bpmntype = node.model.get(Bpmn.BPMN_TYPE);
				return bpmntype;
			},
	
			/**
			 * 返回当前节点的样式选项
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Object}      样式对象
			 */
			getStyle: function(node) {
				return node.model.option.style;
			},
	
			/**
			 * 返回当前节点的属性选项
			 * @param  {Object}  node 需要判断类型的节点
			 * @return  {Object}      属性对象
			 */
			getProp: function(node) {
				return node.model.option.properties;
			},
	
			/**
			 * 获取用户自定义的数据
			 * @param  {Object}  node 需要判断类型的节点
			 * @return {Object}   用户自定义的数据
			 */
			getUserData: function(node) {
				var model = node.model;
				return model.get(Bpmn.USER_DATA);
			},
	
			/**
			 * 设置用户的自定义数据
			 * @param  {Object}  node 需要判断类型的节点
			 * @param {Object} userData 用户的自定义数据
			 */
			setUserData: function(node, userData) {
				var model = node.model;
				model.set(Bpmn.USER_DATA, userData);
			}
		};
	
		module.exports = Bpmn;
	


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 选中节点后，出现的操作框及按钮
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var util = __webpack_require__(73);
	    var Bpmn = __webpack_require__(101);
	    var OperationNode = __webpack_require__(103);
	
	    function BpmnOperationNode(node, zr, forbidEdit) {
	        OperationNode.call(this, node, zr, forbidEdit);
	    }
	
	    BpmnOperationNode.prototype.renderOther = function() {
	        if (Bpmn.isSubProcess(this.node)) {
	            //左上角放大箭头
	            var leftTopArrow = { x: 0, y: 0, width: 10, height: 10 };
	            var leftTopArrowPath = 'M0 100 L0 0 L100 0 L100 20 L20 20 L20 100 z';
	            this.leftTop = graphic.makePath(leftTopArrowPath, { style: { fill: '#000000' } }, leftTopArrow);
	            this.leftTop.attr("cursor", "nw-resize");
	            this.leftTop.isSelfComputePos = true;  // 自己计算位置
	            //右下角放大箭头
	            var rightBottomArrow = { x: 0, y: 0, width: 10, height: 10 };
	            var rightBottomArrowPath = 'M0 100 L100 100 L100 0 L80 0 L80 80 L0 80 z';
	            this.rightBottom = graphic.makePath(rightBottomArrowPath, { style: { fill: '#000000' } }, rightBottomArrow);
	            this.rightBottom.attr("cursor", "se-resize");
	            this.rightBottom.isSelfComputePos = true;  // 自己计算位置
	
	            this.add(this.rightBottom);
	            this.add(this.leftTop);
	        }
	    };
	
	    BpmnOperationNode.prototype.refreshPositionOther = function(node,nodeRect) {
	        if (!this.forbidEdit) {
	            if (Bpmn.isSubProcess(this.node)) {
	                var that = this;
	                var startX, startY;
	                var pixel = 20;
	                //矩形最小长和宽
	                var widthMin = 100;
	                var heightMin = 60;
	                var leftTopPosition, nowleftTopPosition = [],
	                    startSlotPoints, startPosition;
	                this.leftTop.on('mousedown', function(e) {
	                    startSlotPoints = util.getSoltPoints(node);
	                    startPosition = zrUtil.clone(node.position);
	                    leftTopPosition = nodeRect.points[0];
	                    startX = e.event.clientX;
	                    startY = e.event.clientY;
	                    leftScaleDrag(e);
	                });
	
	                function leftScaleDrag(e) {
	                    var leftArrow = function(e) { leftArrowDrag(e); };
	
	                    function leftArrowDrag(e) {
	                        //2个圆间距太小时,不在拖动
	                        if (that.rightBottom.position[0] - that.leftTop.position[0] < (widthMin + 10)) {
	                            if (that.rightBottom.position[1] - that.leftTop.position[1] < (heightMin + 10)) {
	                                that.leftTop.position[0] = that.rightBottom.position[0] - (widthMin + 10);
	                                that.leftTop.position[1] = that.rightBottom.position[1] - (heightMin + 10);
	                            } else {
	                                that.leftTop.position[0] = that.rightBottom.position[0] - (widthMin + 10);
	                                scaleRect(that.leftTop, e);
	                            }
	                        } else {
	                            if (that.rightBottom.position[1] - that.leftTop.position[1] < (heightMin)) {
	                                that.leftTop.position[1] = that.rightBottom.position[1] - (heightMin + 10);
	                                scaleRect(that.leftTop, e);
	                            } else {
	                                scaleRect(that.leftTop, e);
	                            }
	                        }
	
	                        function scaleRect(dom, e) {
	                            var domPosition = [];
	                            for (var n = 0; n <= Math.abs(parseInt((e.event.clientX - startX) / pixel)); n++) {
	                                if (e.event.clientX - startX <= 0) {
	                                    nowleftTopPosition[0] = leftTopPosition[0] - pixel * (n);
	                                    domPosition[0] = nowleftTopPosition[0] - 10;
	                                } else {
	                                    if (!nowleftTopPosition[0]) {
	                                        nowleftTopPosition[0] = leftTopPosition[0];
	                                    }
	                                    if (nodeRect.points[2][0] - nowleftTopPosition[0] > widthMin) {
	                                        nowleftTopPosition[0] = leftTopPosition[0] + pixel * (n);
	                                        domPosition[0] = nowleftTopPosition[0] - 10;
	                                    } else {
	                                        domPosition[0] = that.rightBottom.position[0] - widthMin;
	                                    }
	                                }
	                            }
	                            for (var m = 0; m <= Math.abs(parseInt((e.event.clientY - startY) / pixel)); m++) {
	                                if (e.event.clientY - startY <= 0) {
	                                    nowleftTopPosition[1] = leftTopPosition[1] - pixel * (m);
	                                    domPosition[1] = nowleftTopPosition[1] - 10;
	                                } else {
	                                    if (!nowleftTopPosition[1]) {
	                                        nowleftTopPosition[1] = leftTopPosition[1];
	                                    }
	                                    if (nodeRect.points[2][1] - nowleftTopPosition[1] > heightMin) {
	                                        nowleftTopPosition[1] = leftTopPosition[1] + pixel * (m);
	                                        domPosition[1] = nowleftTopPosition[1] - 10;
	                                    } else {
	                                        domPosition[1] = that.rightBottom.position[1] - heightMin;
	
	                                    }
	                                }
	                            }
	                            dom.attr("position", domPosition);
	                            var points = [];
	                            points[0] = [nowleftTopPosition[0], nowleftTopPosition[1]];
	                            points[1] = [nodeRect.points[1][0], nowleftTopPosition[1]];
	                            points[2] = nodeRect.points[2];
	                            points[3] = [nowleftTopPosition[0], nodeRect.points[3][1] ];
	                            points[4] = [nowleftTopPosition[0], nowleftTopPosition[1]];
	                            var params = {};
	                            params.type = "OperationNode:scaleDragLeft";
	                            params.points = points;
	                            that.trigger(params.type, params);
	                        }
	                    }
	                    that.zr.on('mousemove', leftArrow);
	                    var leftEnd = function(e) { leftDragEnd(e) };
	
	                    function leftDragEnd(e) {
	                        that.zr.off('mousemove', leftArrow);
	                        that.zr.off("mouseup", leftEnd);
	                        var params = {};
	                        params.event = e;
	                        params.arrowName = "left";
	                        params.type = "OperationNode:scaleDragEnd";
	                        params.startSlotPoints = startSlotPoints;
	                        params.startPosition = startPosition;
	                        that.trigger(params.type, params);
	                    }
	                    that.zr.on("mouseup", leftEnd);
	                }
	
	                var rightBottomPosition, nowrightBottomPosition = [];
	                this.rightBottom.on('mousedown', function(e) {
	                    startSlotPoints = util.getSoltPoints(node);
	                    startPosition = zrUtil.clone(node.position);
	                    rightBottomPosition = nodeRect.points[2];
	                    startX = e.event.clientX;
	                    startY = e.event.clientY;
	                    rightScaleDrag(e);
	                });
	
	                function rightScaleDrag(e) {
	                    var rightArrow = function(e) { rightArrowDrag(e); };
	
	                    function rightArrowDrag(e) {
	                        //2个圆间距太小时,不在拖动
	                        if (that.rightBottom.position[0] - that.leftTop.position[0] < (widthMin + 10)) {
	                            if (that.rightBottom.position[1] - that.leftTop.position[1] < (heightMin + 10)) {
	                                that.rightBottom.position[0] = that.leftTop.position[0] + (widthMin + 10);
	                                that.rightBottom.position[1] = that.leftTop.position[1] + (heightMin + 10);
	                            } else {
	                                that.rightBottom.position[0] = that.leftTop.position[0] + widthMin;
	                                scaleRect(that.rightBottom, e);
	                            }
	                        } else {
	                            if (that.rightBottom.position[1] - that.leftTop.position[1] < (heightMin)) {
	                                that.rightBottom.position[1] = that.leftTop.position[1] + heightMin;
	                                scaleRect(that.rightBottom, e);
	                            } else {
	                                scaleRect(that.rightBottom, e);
	                            }
	                        }
	
	                        function scaleRect(dom, e) {
	                            var domPosition = [];
	                            for (var n = 0; n <= Math.abs(parseInt((e.event.clientX - startX) / pixel)); n++) {
	                                if (e.event.clientX - startX > 0) {
	                                    nowrightBottomPosition[0] = rightBottomPosition[0] + pixel * (n);
	                                    domPosition[0] = nowrightBottomPosition[0];
	                                } else {
	                                    if (!nowrightBottomPosition[0]) {
	                                        nowrightBottomPosition[0] = rightBottomPosition[0];
	                                    }
	                                    if (nowrightBottomPosition[0] - nodeRect.points[0][0] > widthMin) {
	                                        nowrightBottomPosition[0] = rightBottomPosition[0] - pixel * (n);
	                                        domPosition[0] = nowrightBottomPosition[0];
	                                    } else {
	                                        domPosition[0] = that.leftTop.position[0] + widthMin;
	                                    }
	                                }
	                            }
	                            for (var m = 0; m <= Math.abs(parseInt((e.event.clientY - startY) / pixel)); m++) {
	                                if (e.event.clientY - startY > 0) {
	                                    nowrightBottomPosition[1] = rightBottomPosition[1] + pixel * (m);
	                                    domPosition[1] = nowrightBottomPosition[1];
	                                } else {
	                                    if (!nowrightBottomPosition[1]) {
	                                        nowrightBottomPosition[1] = rightBottomPosition[1];
	                                    }
	                                    if (nowrightBottomPosition[1] - nodeRect.points[0][1] > heightMin) {
	                                        nowrightBottomPosition[1] = rightBottomPosition[1] - pixel * (m);
	                                        domPosition[1] = nowrightBottomPosition[1];
	
	                                    } else {
	                                        domPosition[1] = that.leftTop.position[1] + heightMin;
	                                    }
	                                }
	                            }
	                            dom.attr("position", domPosition);
	
	                            var points = [];
	                            points[0] = nodeRect.points[0];
	                            points[1] = [nowrightBottomPosition[0], nodeRect.points[1][1]];
	                            points[2] = [nowrightBottomPosition[0], nowrightBottomPosition[1]];
	                            points[3] = [nodeRect.points[3][0], nowrightBottomPosition[1]];
	                            points[4] = nodeRect.points[0];
	                            var params = {};
	                            params.type = "OperationNode:scaleDragRight";
	                            params.points = points;
	                            that.trigger(params.type, params);
	                        }
	                    }
	                    that.zr.on('mousemove', rightArrow);
	                    var rightEnd = function(e) { rightDragEnd(e) };
	
	                    function rightDragEnd(e) {
	                        that.zr.off('mousemove', rightArrow);
	                        that.zr.off("mouseup", rightEnd);
	                        var params = {};
	                        params.event = e;
	                        params.arrowName = "right";
	                        params.type = "OperationNode:scaleDragEnd";
	                        params.startSlotPoints = startSlotPoints;
	                        params.startPosition = startPosition;
	                        that.trigger(params.type, params);
	                    }
	                    that.zr.on("mouseup", rightEnd);
	                }
	                this.leftTop.attr("position", [nodeRect.points[0][0] - 10, nodeRect.points[0][1] - 10]);
	                this.rightBottom.attr("position", [nodeRect.points[2][0], nodeRect.points[2][1]]);
	            }
	        }
	
	
	        // 计算整个的位置
	        if (node.parent) {
	            if (Bpmn.isSubProcess(node.parent)) { //if(node.parent.model.get("stencil.type") == "SubProcess"){
	                this.attr("position", [nodeRect.x + node.parent.position[0], nodeRect.y + node.parent.position[1]])
	            }
	        } else {
	            this.attr("position", [nodeRect.x, nodeRect.y])
	        }
	
	    };
	
	    BpmnOperationNode.ARROW_DRAGEND = "OperationNode:dragendArrow";
	    BpmnOperationNode.ARROW_DRAG = "OperationNode:dragArrow";
	    BpmnOperationNode.ARROW_DRAGSTART = "OperationNode:dragstartArrow";
	    BpmnOperationNode.DELETE_CLICK = "OperationNode:deleteClick";
	
	    zrUtil.inherits(BpmnOperationNode, OperationNode);
	
	
	    module.exports = BpmnOperationNode;
	


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 选中节点后，出现的操作框及按钮
	 * @author wang.xiaohu
	 */
	
	    var Node = __webpack_require__(76);
	    var zrUtil = __webpack_require__(4);
	    var graphic = __webpack_require__(3);
	    var Connector = __webpack_require__(96);
	    var env = __webpack_require__(45);
	
	    function OperationNode(node, zr, forbidEdit) {
	        Node.call(this);
	        this.node = node;
	        this.zr = zr;
	        this.forbidEdit = forbidEdit; //
	        this.render();
	    }
	
	    //事件
	    OperationNode.ARROW_DRAGEND = "OperationNode:dragendArrow";
	    OperationNode.ARROW_DRAG = "OperationNode:dragArrow";
	    OperationNode.ARROW_DRAGSTART = "OperationNode:dragstartArrow";
	    OperationNode.DELETE_CLICK = "OperationNode:deleteClick";
	
	    if(!env.canvasSupported) {
	        //内置操作图标的图像
	        OperationNode.opicons = {
	            STRAIGHT: 'M13.961,2.309c-0.051-0.122-0.148-0.22-0.27-0.27L13.5,2h-5C8.224,2,8,2.224,8,2.5S8.224,3,8.5,3h3.793L2.146,13.146c-0.195,0.195-0.195,0.512,0,0.707s0.512,0.195,0.707,0L13,3.707V7.5C13,7.776,13.225,8,13.5,8S14,7.776,14,7.5v-5L13.961,2.309z',
	            JAGGED: 'M96.046,13.604H84.213c-1.104,0-2,0.896-2,2v42.188H38.314v-10.77c0-0.715-0.381-1.375-1-1.732c-0.619-0.357-1.382-0.355-2,0L2.954,63.977c-0.619,0.357-1,1.018-1,1.732s0.381,1.375,1,1.732l32.36,18.687c0.309,0.179,0.655,0.268,1,0.268s0.69-0.089,1-0.268c0.619-0.357,1-1.018,1-1.732V73.625h57.732c1.104,0,2-0.896,2-2V15.604C98.046,14.5,97.151,13.604,96.046,13.604z',
	            CURVE: 'M510.536,268.098c13.541,0,27.078-5.207,37.347-15.6c20.379-20.625,20.18-53.866-0.445-74.245L414.167,46.57c-9.905-9.786-23.325-15.244-37.215-15.154c-13.923,0.083-27.244,5.695-37.03,15.599l-129.912,131.48c-20.379,20.625-20.18,53.866,0.445,74.245c20.625,20.379,53.866,20.18,74.245-0.445l40.618-41.108c0.021,0.464,0.029,0.927,0.062,1.394c4.178,59.008,4.668,119.832,16.633,177.931c23.937,116.232,103.705,191.961,191.489,264.024c47.292,38.823,79.66,94.122,98.601,151.673c9.765,29.669,14.714,77.115,17.215,107.157c2.261,27.161,25.08,47.978,52.333,47.709l1.061-0.01c30.228-0.298,53.81-26.211,51.306-56.336c-2.921-35.15-8.858-89.828-20.925-127.49c-16.283-50.821-40.016-99.463-74.766-140.245c-33.993-39.892-75.456-72.403-113.338-108.373c-47.091-44.713-84.977-95.161-98.006-159.719c-10.541-52.231-12.789-105.215-16.461-158.562l43.118,42.604C483.87,263.053,497.205,268.098,510.536,268.098z',
	            DEL: 'M73.641,45.957l-0.021,0.252c0,0.032,0.021,0.06,0.021,0.088c0,0.065-0.022,0.126-0.026,0.191l-2.685,54.878H70.91c-0.231,4.304-5.166,10.81-31.748,10.81c-26.58,0-31.509-6.506-31.746-10.81H7.41L4.731,46.488c-0.009-0.06-0.028-0.126-0.028-0.191c0-0.032,0.01-0.06,0.01-0.088l-0.01-0.252h0.028c0.099-0.466,0.364-0.919,0.784-1.353c3.439,3.477,17.191,4.051,33.646,4.051s30.221-0.574,33.642-4.051c0.426,0.434,0.711,0.887,0.784,1.353H73.641z M78.335,25.102v6.407c0,1.316-1.34,2.567-3.715,3.696c-6.266,2.936-19.777,4.975-35.459,4.975c-15.666,0-29.189-2.039-35.442-4.975C1.33,34.075,0,32.825,0,31.509v-6.407c0-3.374,8.681-6.286,21.359-7.724V3.929c0-2.16,1.768-3.929,3.93-3.929h26.314c2.164,0,3.938,1.773,3.938,3.938v13.296C68.98,18.606,78.333,21.611,78.335,25.102z M48.416,11.395c0-2.348-0.321-4.27-0.715-4.27c-0.393,0-2.641,0-4.979,0h-8.545c-2.352,0-4.592,0-4.989,0c-0.388,0-0.714,1.922-0.714,4.27v5.367l1.083-0.065c3.067-0.173,6.286-0.27,9.595-0.271c3.202,0,6.292,0.098,9.264,0.252V11.395z'
	        };
	    }else{
	        OperationNode.opicons = {
	            STRAIGHT: 'data:image/png;base64,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',
	            JAGGED: 'data:image/png;base64,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',
	            CURVE: 'data:image/png;base64,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',
	            DEL: 'M73.641,45.957l-0.021,0.252c0,0.032,0.021,0.06,0.021,0.088c0,0.065-0.022,0.126-0.026,0.191l-2.685,54.878H70.91c-0.231,4.304-5.166,10.81-31.748,10.81c-26.58,0-31.509-6.506-31.746-10.81H7.41L4.731,46.488c-0.009-0.06-0.028-0.126-0.028-0.191c0-0.032,0.01-0.06,0.01-0.088l-0.01-0.252h0.028c0.099-0.466,0.364-0.919,0.784-1.353c3.439,3.477,17.191,4.051,33.646,4.051s30.221-0.574,33.642-4.051c0.426,0.434,0.711,0.887,0.784,1.353H73.641z M78.335,25.102v6.407c0,1.316-1.34,2.567-3.715,3.696c-6.266,2.936-19.777,4.975-35.459,4.975c-15.666,0-29.189-2.039-35.442-4.975C1.33,34.075,0,32.825,0,31.509v-6.407c0-3.374,8.681-6.286,21.359-7.724V3.929c0-2.16,1.768-3.929,3.93-3.929h26.314c2.164,0,3.938,1.773,3.938,3.938v13.296C68.98,18.606,78.333,21.611,78.335,25.102z M48.416,11.395c0-2.348-0.321-4.27-0.715-4.27c-0.393,0-2.641,0-4.979,0h-8.545c-2.352,0-4.592,0-4.989,0c-0.388,0-0.714,1.922-0.714,4.27v5.367l1.083-0.065c3.067-0.173,6.286-0.27,9.595-0.271c3.202,0,6.292,0.098,9.264,0.252V11.395z'
	        };
	    }
	
	
	
	
	    OperationNode.prototype.render = function() {
	        this.renderBase();
	        if (!this.forbidEdit) {
	            this.renderOther();
	        }
	
	    };
	
	    OperationNode.prototype.renderBase = function() {
	        this.createOperation();
	    };
	
	    OperationNode.prototype.createOperation = function() {
	        var me = this;
	        this.virtualRect = new graphic.Polyline({ style: { lineDash: [2] } });
	        this.virtualRect.isSelfComputePos = true;  // 自己计算位置
	        this.add(this.virtualRect);
	
	
	
	        if (this.node.operationIcons) {
	            zrUtil.each(this.node.operationIcons, function(item) {
	                //检查是否是内置图标
	                var opIconInstance = null;
	                if (OperationNode.opicons[item.name + ""]) {
	
	                    if (this.forbidEdit) {
	                        return;
	                    }
	                    if (item.name == "DEL") {
	                        //垃圾桶
	                        var rect1 = { x: 0, y: 0, width: 10, height: 15 };
	                        opIconInstance = graphic.makePath(OperationNode.opicons[item.name + ""], { style: { fill: '#000000' },z:me.node.z+1 }, rect1);
	                        if(item.callback){
	                            opIconInstance.on("click", function(e) {
	                                e.data = item;
	                                e.node = me.node;  // 将所附的节点也传递出去
	                                if (item.callback) {
	                                    item.callback(e);
	                                }
	                            });
	                        }else{
	                            opIconInstance.on("click", function(e) {
	                                var params = {};
	                                params.event = e;
	                                params.target = this;
	                                params.type = OperationNode.DELETE_CLICK;
	                                me.trigger(params.type, params);
	                            });
	                        }
	
	
	                    } else {
	                        if(!env.canvasSupported){
	                            var rect = { x: 0, y: 0, width: 15, height: 15 };
	                            opIconInstance = graphic.makePath(OperationNode.opicons[item.name + ""], { style: { fill: '#000000' },draggable:true,z:me.node.z+1,lineType: Connector["TYPE_" + item.name] }, rect);
	                        }else{
	                            var imageUrl = document.createElement('img');
	                            imageUrl.src = OperationNode.opicons[item.name + ""];
	                            opIconInstance = new graphic.Image({
	                                style: {
	                                    image:imageUrl,
	                                    cursor: 'default',
	                                    width:15,
	                                    height:15
	                                },
	                                draggable: true,
	                                z: me.node.z+1, //zIndex 置于最高
	                                lineType: Connector["TYPE_" + item.name] //区分不同的线段
	                            });
	                        }
	
	                        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];
	                        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	                            opIconInstance.on(eveName, function(e) {
	                                var params = {};
	                                params.event = e;
	                                params.data = item.options
	                                params.type = "OperationNode:" + eveName + "Arrow";
	                                me.trigger(params.type, params);
	                            });
	                        });
	                    }
	
	                } else {
	                    //用户自定义的图标放在这里，用户传进来的图标只能响应click事件，其它事件暂不支持
	                    opIconInstance = new graphic.Image({
	                        style: {
	                            image: item.iconPath,
	                            width: item.width || 15,
	                            height: item.height || 15
	                        },
	                        z:me.node.z+1 //zIndex 置于最高
	                    });
	                    opIconInstance.on("click", function(e) {
	                        e.data = item;
	                        e.node = me.node;  // 将所附的节点也传递出去
	                        if (item.callback) {
	                            item.callback(e);
	                        }
	
	                        //todo 用户自定图标click事件是否要派发到外面
	                    });
	                }
	                opIconInstance.name = item.name;
	                me.add(opIconInstance);
	            });
	        }
	    };
	
	    OperationNode.prototype.refreshPostion = function(node,nodeRect) {
	        var me = this;
	        var i = 0;
	        var rbPoint = nodeRect.points[2]; //取右下角坐标
	        //1.定位虚框
	        this.virtualRect.setShape({ points: nodeRect.points });
	        //2.定位每个小图标
	        this.eachChild(function(nodeItem) {
	            if (!nodeItem.isSelfComputePos) {
	                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离
	                nodeItem.attr("position", [rbPoint[0] + 8 + (i++ * 20), rbPoint[1] - 10]);
	            }
	        });
	
	        this.refreshPositionOther(node,nodeRect);
	    };
	
	    OperationNode.prototype.renderOther = function() {
	        //留给扩展使用
	    };
	    OperationNode.prototype.refreshPositionOther = function(node,nodeRect) {
	        //留给扩展使用
	        //3.定位整个operationNode
	        if (node.parent && node.parent.isBg && node.parent.isBg == true) {
	            this.attr("position", [nodeRect.x, nodeRect.y])
	        } else {
	            this.attr("position", [nodeRect.x + node.parent.position[0]+node.shape.x, nodeRect.y + node.parent.position[1]+node.shape.y])
	        }
	    };
	    zrUtil.inherits(OperationNode, Node);
	    module.exports = OperationNode;
	


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * bpmn连线管理类
	 * @author wang.xiaohu
	 */
	
	    var zrUtil = __webpack_require__(4);
	    var ConnectionManager = __webpack_require__(105);
	    var BPMNModel = __webpack_require__(78);
	    var Connector = __webpack_require__(96);
	    var Point = __webpack_require__(60);
	
	    function BpmnConnectionManager() {
	        ConnectionManager.call(this);
	        this.stencilType = "SequenceFlow";
	    }
	    /**
	     * 创建连线
	     * @param  {[type]} startNode [开始节点]
	     * @param  {[type]} endNode   [结束节点]
	     * @param  {[type]} type      [类型]
	     * @param {[type]} [api] [description]
	     * @return {[type]}           [返回连线]
	     */
	    BpmnConnectionManager.prototype.connectorCreate = function(startNode, endNode, type, api) {
	        var model = new BPMNModel({});
	        model.set("style.lineType", type);
	        model.set("stencil.type", this.stencilType);
	
	        return this.connectorCreateByOptions(startNode, endNode, { model: model, isEdit: true, style: { lineType: type } }, api);
	    }
	
	
	    /**
	     * 根据opetions.model 反序列化线
	     * @param  {[type]} startNode [description]
	     * @param  {[type]} endNode   [description]
	     * @param  {[type]} options   [description]
	     * @param  {[type]} api       [description]
	     * @return {[type]}           [description]
	     */
	    BpmnConnectionManager.prototype.connectorCreateByOptions = function(startNode, endNode, options, api) {
	        var that = this;
	        var model = options.model;
	        model.option.text = {
	            text: model.option.properties.name
	        }
	        options.text = {
	            text: model.option.properties.name
	        }
	        var connector = new Connector(options);
	        connector.startNode = startNode;
	        connector.endNode = endNode;
	
	        this.connectors.push(connector);
	
	        //判断一下sPos,ePos
	        connector.sPos = model.get("style.sPos");
	        connector.ePos = model.get("style.ePos");
	
	        //判断一下 model里有没有dockers，如果有则调用构造point数组  或者调用refreshConnector计算如何画线
	        var dockers = model.get("dockers");
	        if (dockers && dockers.length >= 2) {
	            var points = Point.loadArray(dockers);
	            connector.refresh(points);
	        } else {
	            this.refreshConnector(connector, true);
	        }
	
	        connector.conPointsGroup.on("click", function(e) {
	            var arrSplit = e.target.type.split(Connector.SEPERATOR);
	            var connector = e.target.connector;
	            if (arrSplit[0] === Connector.START_NODE) {
	                connector.sPos = arrSplit[1];
	            } else if (arrSplit[0] === Connector.END_NODE) {
	                connector.ePos = arrSplit[1];
	            }
	            that.refreshConnector(connector, true);
	
	            var params = {};
	            params.event = e;
	            params.type = "conPointsGroup:click";
	            params.lineNode = that.selConnector;
	            api.trigger(params.type, params);
	        });
	
	
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];
	        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	            connector.on("Connector:" + eveName, function(e) {
	                var selected = e.target;
	
	                if (that.selConnector !== selected) {
	                    that.selConnector && that.refreshConnector(that.selConnector);
	                    that.selConnector = selected;
	                }
	
	                var params = {};
	                params.event = e;
	                params.type = eveName;
	                params.target = that.selConnector;
	                api.trigger(params.type, params);
	            });
	        });
	        if (!options.isFromModel) {
	            //1.设置起始节点的outgoing数组 为线段的ID
	            var startNodeOutgoing = startNode.model.get("outgoing");
	            startNodeOutgoing.push(connector.resourceId);
	            //2.设置线段的outgoing数组 为结束节点的ID
	            var connectorOutgoing = connector.model.get("outgoing");
	            connectorOutgoing.push(endNode.resourceId);
	        }
	
	
	        return connector;
	    }
	
	    /**
	     * 设置线段的模型数据  (类型 文字)
	     * @param {[type]} connector [description]
	     * @param {[type]} option    [description]
	     */
	    BpmnConnectionManager.prototype.setModel = function(connector, option) {
	            var originLineType = connector.model.get("style.lineType");
	            var originName = connector.options.text.text;
	            connector.options.text.text = option.properties.name;
	            connector.model.mergeOption(option);
	            //文字不一致时
	            if (originName != option.properties.name) {
	                this.refreshConnector(connector, true);
	            }
	        }
	        /**
	         * 刷新连接线
	         * @param  {[type]} node [description]
	         * @return {[type]}      [description]
	         */
	    BpmnConnectionManager.prototype.refreshLineByNode = function(node) {
	        for (var i = 0, len = this.connectors.length; i < len; i++) {
	            if (this.connectors[i].startNode == node || this.connectors[i].endNode == node) {
	                this.refreshConnector(this.connectors[i], true);
	            }
	        }
	    }
	
	    zrUtil.inherits(BpmnConnectionManager, ConnectionManager);
	
	    module.exports = BpmnConnectionManager;
	


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 连线管理类
	 * @author wang.xiaohu
	 */
	
	    var Node = __webpack_require__(76);
	    var Util = __webpack_require__(73);
	    var graphic = __webpack_require__(3);
	    var Point = __webpack_require__(60);
	    var Connector = __webpack_require__(96);
	    var Log = __webpack_require__(106);
	    var zrUtil = __webpack_require__(4);
	
	    function ConnectionManager() {
	        this.connectors = []; //当前画布所有的线段
	        this.selConnector = null; //当前选中的线段
	        this.tempConnector = null; //临时线段
	    }
	
	    /**
	     * 设置线的不可编辑
	     * @param  {[type]} forbidEdit [description]
	     * @return {[type]}            [description]
	     */
	    ConnectionManager.prototype.connectorForbidEdit = function(forbidEdit) {
	        for (var i = 0; i < this.connectors.length; i++) {
	            this.connectors[i].options.isEdit = !forbidEdit;
	        }
	    }
	
	
	    /**
	     * 清空连接线
	     * @return {[type]} [description]
	     */
	    ConnectionManager.prototype.clearSelectCon = function() {
	            if (this.selConnector != null) {
	                this.refreshConnector(this.selConnector);
	            }
	        }
	        /**
	         * 删除连接线
	         * @return {[type]} [description]
	         */
	    ConnectionManager.prototype.deleteSelectCon = function(node, _zr) {
	            var deleteLine = [];
	            for (var i = 0; i < this.connectors.length; i++) {
	                if (this.connectors[i].startNode == node || this.connectors[i].endNode == node) {
	                    //1.将线 所联的startNode的outgoing数据删除
	                    var startNodeOutgoing = this.connectors[i].startNode.model.get("outgoing");
	                    index = zrUtil.indexOf(startNodeOutgoing, this.connectors[i].resourceId);
	                    if (index != -1) {
	                        startNodeOutgoing.splice(index, 1);
	                    }
	                    //2.从_zr上删除
	                    _zr.remove(this.connectors[i]);
	                    this.connectors.splice(i, 1);
	                    i--;
	                    this.selConnector = null;
	                }
	            }
	        }
	        /**
	         * 删除选定的线
	         * @return {[type]} [description]
	         */
	    ConnectionManager.prototype.deleteLine = function(_zr) {
	        //1.将线 所联的startNode的outgoing数据删除
	        var startNodeOutgoing = this.selConnector.startNode.model.get("outgoing");
	        index = zrUtil.indexOf(startNodeOutgoing, this.selConnector.resourceId);
	        if (index != -1) {
	            startNodeOutgoing.splice(index, 1);
	        }
	
	        if (this.connectorMap) {
	            var key = this.getTwoNodeId(this.selConnector.startNode, this.selConnector.endNode);
	            this.connectorMap.removeItem(key, this.selConnector);
	        }
	
	        //2.从_zr上删除
	        _zr.remove(this.selConnector);
	
	
	        //3.从线数据中删除
	        var index = zrUtil.indexOf(this.connectors, this.selConnector);
	        if (index != -1) {
	            this.connectors.splice(index, 1);
	        }
	        this.selConnector = null;
	    }
	
	    /**
	     * 重新画线
	     * @param  {[type]} connector          [description]
	     * @param  {[type]} force
	     * @return {[type]}                    [description]
	     */
	    ConnectionManager.prototype.refreshConnector = function(connector, force) {
	        // 只有需要强制刷新  或者 连线为空（<2)时 才进行重新计算重绘
	        if (force || (!connector.turningPoints) || (connector.turningPoints.length < 2)) {
	            if (connector.model && connector.model.get("style.lineType")) { connector.options.style.lineType = connector.model.get("style.lineType"); }
	            var arrStartEndPoint = this.getStartEndPoint(connector);
	            var escapeDistance = null;
	            if (connector.options.position && connector.options.position.escapeDistance) {
	                escapeDistance = connector.options.position.escapeDistance;
	            }
	            var solutions = this.connector2Points(connector.options.style.lineType, arrStartEndPoint[0], arrStartEndPoint[1],
	                arrStartEndPoint[2], arrStartEndPoint[3], escapeDistance); // TYPE_STRAIGHT TYPE_JAGGED
	
	            connector.refresh(solutions[0][2]);
	        }
	
	        connector.clearHandles(); //清空handle
	    }
	
	
	    ConnectionManager.prototype.getStartEndPoint = function(connector) {
	        var startNode = connector.startNode;
	        var endNode = connector.endNode;
	
	        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode).boundingRect;
	        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(sRect.y) + Number(sRect.height)];
	
	        var eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode).boundingRect;
	        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(eRect.y) + Number(eRect.height)];
	
	
	        var sConnectorPoint = Util.getConnectorPoints(sRect);
	        var eConnectorPoint = Util.getConnectorPoints(eRect);
	
	        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	        if (!connector.sPos || !connector.ePos) {
	            if (sRect.x < eRect.x) {
	                connector.sPos = "right";
	                connector.ePos = "left";
	            } else {
	                connector.sPos = "left";
	                connector.ePos = "right";
	            }
	        }
	        var startPoint = this.calcPointExpression(connector.sPos, sConnectorPoint);
	        var endPoint = this.calcPointExpression(connector.ePos, eConnectorPoint);
	        return [startPoint, endPoint, sBounds, eBounds];
	    }
	
	    ConnectionManager.prototype.calcPointExpression = function(pos, point) {
	        var variable = {
	            top: point.top.x,
	            left: point.left.y,
	            right: point.right.y,
	            bottom: point.bottom.x,
	            center: point.center.x
	        };
	
	        var expression = "<% print(" + pos + ") %>";
	        var val = parseInt(Util.template(expression)(variable));
	        if (pos.indexOf("top") != -1) {
	            return new Point(val, point.top.y);
	        } else if (pos.indexOf("left") != -1) {
	            return new Point(point.left.x, val);
	        } else if (pos.indexOf("right") != -1) {
	            return new Point(point.right.x, val);
	        } else if (pos.indexOf("bottom") != -1) {
	            return new Point(val, point.bottom.y);
	        } else if (pos.indexOf("center") != -1) {
	            return new Point(val, point.bottom.y);
	        } else {
	            throw new Error("pos参数错误");
	        }
	    }
	
	    /**
	     * 创建或修改临时线
	     * @param  {[type]} startNode             [description]
	     * @param  {[type]} rEndPoint             [description]
	     * @param  {[type]} lineType [description]
	     * @return {[type]}                       [description]
	     */
	    ConnectionManager.prototype.manageTempConnector = function(startNode, rEndPoint, lineType) {
	
	        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode).boundingRect;
	
	        var sBounds = [sRect.x, sRect.y, sRect.x + sRect.width, sRect.y + sRect.height];
	        var sConnectorPoint = Util.getConnectorPoints(sRect);
	
	        if (!this.tempConnector) {
	            this.tempConnector = new Connector({ isEdit: false, style: { lineType: lineType } });
	        }
	
	        var connector = this.tempConnector;
	        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	        if (sRect.x < rEndPoint.x) {
	            connector.sPos = "right";
	            connector.ePos = "left";
	        } else {
	            connector.sPos = "left";
	            connector.ePos = "right";
	        }
	
	        connector.options.style.lineType = lineType;
	        var solutions = this.connector2Points(lineType, sConnectorPoint[connector.sPos], rEndPoint,
	            sBounds, null); // TYPE_STRAIGHT TYPE_JAGGED
	
	        connector.refresh(solutions[0][2]);
	        return connector;
	    }
	
	    /**
	     * 删除临时线
	     * @param  {[type]} zr             [description]
	     */
	    ConnectionManager.prototype.removeTempConnector = function(zr) {
	        if (this.tempConnector) {
	            zr.remove(this.tempConnector);
	            this.tempConnector = null;
	        }
	    }
	
	
	    /**
	     * 算出 两个节点 指定两个点如何联线
	     * @param  {[type]} type       [description]
	     * @param  {[type]} startPoint [description]
	     * @param  {[type]} endPoint   [description]
	     * @param  {[type]} sBounds    [description]
	     * @param  {[type]} eBounds    [description]
	     * @return {[type]}            [description]
	     */
	    ConnectionManager.prototype.connector2Points = function(type, startPoint, endPoint, sBounds, eBounds, escapeDistance) {
	        var figureEscapeDistance = [30, 30];
	        if (escapeDistance) {
	            if (!zrUtil.isArray(escapeDistance)) {
	                figureEscapeDistance = [escapeDistance, escapeDistance];
	            } else {
	                figureEscapeDistance = escapeDistance;
	            }
	        }
	
	        Log.group("connectionManager: connector2Points");
	
	
	        Log.info("ConnectionManager: connector2Points (" + type + ", " + startPoint + ", " + endPoint + ", " + sBounds + ", " + eBounds + ')');
	        var solutions = [];
	
	
	
	        switch (type) {
	            case Connector.TYPE_STRAIGHT: //直线
	                var points = [startPoint.clone(), endPoint.clone()];
	                solutions.push(['straight', 'straight', points]);
	                break;
	
	            case Connector.TYPE_CURVE: //曲线
	
	            case Connector.TYPE_JAGGED: //折线
	                var startExitPoint = null;
	                var endExitPoint = null;
	
	                //find start exit point  寻找开始出口
	                if (sBounds != null) {
	                    var potentialExits = [];
	
	                    potentialExits.push(new Point(startPoint.x, sBounds[1] - figureEscapeDistance[0])); //north 北
	                    potentialExits.push(new Point(sBounds[2] + figureEscapeDistance[0], startPoint.y)); //east  东
	                    potentialExits.push(new Point(startPoint.x, sBounds[3] + figureEscapeDistance[0])); //south  南
	                    potentialExits.push(new Point(sBounds[0] - figureEscapeDistance[0], startPoint.y)); //west  西
	
	                    //pick closest exit point  寻找与 startPoint 最靠近的出口点
	                    startExitPoint = potentialExits[0];
	                    for (var i = 1; i < potentialExits.length; i++) {
	                        if (Util.distance(startPoint, potentialExits[i]) < Util.distance(startPoint, startExitPoint)) {
	                            startExitPoint = potentialExits[i];
	                        }
	                    }
	                }
	
	
	                //find end exit point  寻找结束出口
	                if (eBounds != null) {
	                    var potentialExits = [];
	
	                    potentialExits.push(new Point(endPoint.x, eBounds[1] - figureEscapeDistance[1])); //north
	                    potentialExits.push(new Point(eBounds[2] + figureEscapeDistance[1], endPoint.y)); //east
	                    potentialExits.push(new Point(endPoint.x, eBounds[3] + figureEscapeDistance[1])); //south
	                    potentialExits.push(new Point(eBounds[0] - figureEscapeDistance[1], endPoint.y)); //west
	
	                    //pick closest exit point  寻找与 endPoint 最靠近的出口点
	                    endExitPoint = potentialExits[0];
	                    for (var i = 1; i < potentialExits.length; i++) {
	                        if (Util.distance(endPoint, potentialExits[i]) < Util.distance(endPoint, endExitPoint)) {
	                            endExitPoint = potentialExits[i];
	                        }
	                    }
	                }
	
	                //Basic solution 最基本的解决方案   为其他解决方案做准备
	                var s = [startPoint];
	                var gapIndex = 0; //the index of the gap (where do we need to insert new points) DO NOT CHANGE IT
	                if (startExitPoint) {
	                    s.push(startExitPoint);
	                    gapIndex = 1;
	                }
	                if (endExitPoint) {
	                    s.push(endExitPoint);
	                }
	                s.push(endPoint);
	
	
	
	                //SO - no additional points     S0 解决方案 不添加任何点  基本不会被采用
	                var s0 = Point.cloneArray(s);
	                solutions.push(['s0', 's0', s0]);
	
	
	
	                //S1   S1 解决方案  只有一个折点
	                var s1 = Point.cloneArray(s);
	
	                //first variant   第一个变体 s1 s1_1方案  折线点在 startExitPoint的X 与 endExitPoint的 Y位置
	                var s1_1 = Point.cloneArray(s1);
	                s1_1.splice(gapIndex + 1, 0, new Point(s1_1[gapIndex].x, s1_1[gapIndex + 1].y));
	                solutions.push(['s1', 's1_1', s1_1]);
	
	                //second variant  第二变体 s1 s1-2方案  折线点在 endExitPoint的X 与  startExitPoint的Y位置
	                var s1_2 = Point.cloneArray(s1);
	                s1_2.splice(gapIndex + 1, 0, new Point(s1_2[gapIndex + 1].x, s1_2[gapIndex].y));
	                solutions.push(['s1', 's1_2', s1_2]);
	
	
	                //S2  S2 解决方案  添加两个折点
	
	                //Variant I   s2_1方案
	                var s2_1 = Point.cloneArray(s);
	                var s2_1_1 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex].y);
	                var s2_1_2 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex + 1].y);
	                s2_1.splice(gapIndex + 1, 0, s2_1_1, s2_1_2);
	                solutions.push(['s2', 's2_1', s2_1]);
	
	
	                //Variant II  s2_1方案  1折线点 x: startExitPoint的X 位置 y: startExitPoint的y+endExitPoint的y/2
	                //1折线点 x:endExitPoint的x  y:startExitPoint的y+endExitPoint的y/2
	                var s2_2 = Point.cloneArray(s);
	                var s2_2_1 = new Point(s2_2[gapIndex].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);
	                var s2_2_2 = new Point(s2_2[gapIndex + 1].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);
	                s2_2.splice(gapIndex + 1, 0, s2_2_1, s2_2_2);
	                solutions.push(['s2', 's2_2', s2_2]);
	
	
	                //Variant III
	                var s2_3 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move right so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var eastExits = [s2_3[gapIndex].x + 20, s2_3[gapIndex + 1].x + 20]; //add points X coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    eastExits.push(sBounds[2] + 20);
	                }
	
	                if (eBounds) {
	                    eastExits.push(eBounds[2] + 20);
	                }
	
	                var eastExit = Util.max(eastExits);
	                var s2_3_1 = new Point(eastExit, s2_3[gapIndex].y);
	                var s2_3_2 = new Point(eastExit, s2_3[gapIndex + 1].y);
	                s2_3.splice(gapIndex + 1, 0, s2_3_1, s2_3_2);
	                solutions.push(['s2', 's2_3', s2_3]);
	
	
	                //Variant IV  s2_4方案
	                var s2_4 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move up so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var northExits = [s2_4[gapIndex].y - 20, s2_4[gapIndex + 1].y - 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    northExits.push(sBounds[1] - 20);
	                }
	
	                if (eBounds) {
	                    northExits.push(eBounds[1] - 20);
	                }
	
	                var northExit = Util.min(northExits);
	                var s2_4_1 = new Point(s2_4[gapIndex].x, northExit);
	                var s2_4_2 = new Point(s2_4[gapIndex + 1].x, northExit);
	                s2_4.splice(gapIndex + 1, 0, s2_4_1, s2_4_2);
	                solutions.push(['s2', 's2_4', s2_4]);
	
	
	                //Variant V
	                var s2_5 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move left so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var westExits = [s2_5[gapIndex].x - 20, s2_5[gapIndex + 1].x - 20]; //add points x coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    westExits.push(sBounds[0] - 20);
	                }
	
	                if (eBounds) {
	                    westExits.push(eBounds[0] - 20);
	                }
	
	                var westExit = Util.min(westExits);
	                var s2_5_1 = new Point(westExit, s2_5[gapIndex].y);
	                var s2_5_2 = new Point(westExit, s2_5[gapIndex + 1].y);
	                s2_5.splice(gapIndex + 1, 0, s2_5_1, s2_5_2);
	                solutions.push(['s2', 's2_5', s2_5]);
	
	
	                //Variant VI
	                var s2_6 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move down so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var southExits = [s2_6[gapIndex].y + 20, s2_6[gapIndex + 1].y + 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    southExits.push(sBounds[3] + 20);
	                }
	
	                if (eBounds) {
	                    southExits.push(eBounds[3] + 20);
	                }
	
	                var southExit = Util.max(southExits);
	                var s2_6_1 = new Point(s2_6[gapIndex].x, southExit);
	                var s2_6_2 = new Point(s2_6[gapIndex + 1].x, southExit);
	                s2_6.splice(gapIndex + 1, 0, s2_6_1, s2_6_2);
	                solutions.push(['s2', 's2_6', s2_6]);
	
	
	
	                //FILTER solutions
	
	                /*Algorithm
	                 * 0. solutions are ordered from minimmun nr of points to maximum >:)
	                 * 1. remove all solutions that are not orthogonal (mainly s0 solution)
	                 * 2. remove all solutions that go backward (we will not need them ever)
	                 * 3. remove all solutions with intersections
	                 * 4. pick first class of solutions with same nr of points (ex: 2)
	                 * 5. pick the first solution with 90 degree angles (less turnarounds)
	                 * (not interesteted) sort by length :p
	                 */
	
	                //1. filter non ortogonal solutions 删除不是正交直线的方案
	                if (true) {
	                    Log.info("Filter orthogonal solutions. Initial number of solutions = " + solutions.length);
	                    var orthogonalSolution = [];
	                    for (var l = 0; l < solutions.length; l++) {
	                        var solution = solutions[l][2];
	                        if (Util.orthogonalPath(solution)) {
	                            orthogonalSolution.push(solutions[l]);
	                        }
	                    }
	                    solutions = orthogonalSolution;
	                    Log.info("\n\tOrthogonalSolutions = " + solutions.length);
	                }
	
	                //2. filter backward solutions  过滤 倒退的方案
	                if (true) {
	                    //do not allow start and end points to coincide - ignore them
	                    if (startPoint.equals(endPoint)) {
	                        Log.info("Start and end point coincide...skip backward solution. I think we will just fall on s0 :)");
	                    } else {
	                        Log.info("Filter backward solutions. Initial number of solutions = " + solutions.length);
	                        var forwardSolutions = [];
	                        var temp = '';
	                        for (var l = 0; l < solutions.length; l++) {
	                            var solution = solutions[l][2];
	                            if (Util.forwardPath(solution)) {
	                                forwardSolutions.push(solutions[l]);
	                            } else {
	                                temp = temp + "\n\t" + solution;
	                            }
	                        }
	                        solutions = forwardSolutions;
	                        Log.info("\n\t ForwardSolutions = " + solutions.length);
	                        if (solutions.length == 0) {
	                            Log.info("Discarded solutions: " + temp);
	                        }
	                    }
	                }
	
	
	                //3. Filter non intersecting solutions  去除没有交集()的方案
	                if (true) {
	                    Log.info("Filter non intersecting solutions. Initial number of solutions = " + solutions.length);
	                    var nonIntersectionSolutions = []
	                    for (var l = 0; l < solutions.length; l++) {
	                        var solution = solutions[l][2];
	                        //Log.info("Solution id= " + solutions[l][1] + ' nr points = ' + solution.length + ", points = " + solution);
	                        var intersect = false;
	
	                        var innerLines = solution.slice(); //just a shallow copy
	
	                        /*If any bounds just trim the solution. So we avoid the strange case when a connection
	                         *startes from a point on a figure and ends inside of the same figure, but not on a connection point*/
	                        if (eBounds || sBounds) {
	                            //i0nnerLines = innerLines.slice(0, innerLines.length - 1);
	                            innerLines = innerLines.slice(1, innerLines.length - 1);
	                            //Log.info("\t eBounds present,innerLines nr. points = " + innerLines.length + ", points = " + innerLines);
	                        }
	
	
	
	                        //now test for intersection
	                        if (sBounds) {
	                            intersect = intersect || Util.polylineIntersectsRectangle(innerLines, sBounds);
	                        }
	                        if (eBounds) {
	                            intersect = intersect || Util.polylineIntersectsRectangle(innerLines, eBounds);
	                        }
	
	                        if (!intersect) {
	                            nonIntersectionSolutions.push(solutions[l]);
	                        }
	                    }
	
	                    //If all solutions intersect than this is destiny  :) and just ignore the intersection filter
	                    if (nonIntersectionSolutions.length != 0) {
	                        //reasign to solutions
	                        solutions = nonIntersectionSolutions;
	                    }
	
	                    Log.info("\n\t nonIntersectionSolutions = " + solutions.length);
	                }
	
	
	                //4. get first class of solutions with same nr of points 选择与第一个方案点数一样多的方案（因为第一个方案点数最少）
	                if (true) {
	                    Log.info("Get first class of solutions with same nr of points");
	                    if (solutions.length == 0) {
	                        Log.info("This is not possible");
	                    }
	
	                    var firstSolution = solutions[0][2]; //pick first solution
	                    var nrOfPoints = firstSolution.length;
	                    var sameNrPointsSolution = [];
	
	                    for (var l = 0; l < solutions.length; l++) {
	                        var solution = solutions[l][2];
	                        if (solution.length == nrOfPoints) {
	                            sameNrPointsSolution.push(solutions[l]);
	                        }
	                    }
	
	                    solutions = sameNrPointsSolution;
	                }
	
	
	
	
	                /*5.  计算路径分数 ，取最分数高的
	                 Pick the first solution with 90 degree angles (less turnarounds)
	                 *in case we have more than one solution in our class
	                 */
	                if (true) {
	                    Log.info("pick the first solution with 90 degree angles (less turnarounds)");
	                    var solIndex = 0;
	                    for (var l = 0; l < solutions.length; l++) {
	                        var solution = solutions[l][2];
	                        if (Util.scorePath(solutions[solIndex][2]) < Util.scorePath(solutions[l][2])) {
	                            solIndex = l;
	                        }
	                    }
	                    solutions = [solutions[solIndex]];
	                }
	
	
	                break;
	        }
	
	        //SMOOTHING curve
	        if (type === Connector.TYPE_CURVE) {
	            this.smoothCurve(solutions);
	        }
	        //END SMOOTHING curve
	
	        Log.groupEnd();
	
	        return solutions;
	    }
	
	    ConnectionManager.prototype.smoothCurve = function(solutions) {
	        var option = 3;
	
	        switch (option) {
	            case 0:
	                //do nothing
	                break;
	
	            case 1: //add intermediate points
	                //Add the middle point for start and end segment so that we "force" the
	                //curve to both come "perpendicular" on bounds and also make the curve
	                //"flee" more from bounds (on exit)
	                for (var s = 0; s < solutions.length; s++) {
	                    var solTurningPoints = solutions[s][2];
	
	                    //first segment
	                    var a1 = solTurningPoints[0];
	                    var a2 = solTurningPoints[1];
	                    var startMiddlePoint = Util.getMiddle(a1, a2);
	                    solTurningPoints.splice(1, 0, startMiddlePoint);
	
	                    //last segment
	                    var a3 = solTurningPoints[solTurningPoints.length - 2];
	                    var a4 = solTurningPoints[solTurningPoints.length - 1];
	                    var endMiddlePoint = Util.getMiddle(a3, a4);
	                    solTurningPoints.splice(solTurningPoints.length - 1, 0, endMiddlePoint);
	                }
	                break;
	
	            case 2: //remove points
	                for (var s = 0; s < solutions.length; s++) {
	                    var solType = solutions[s][0];
	                    if (solType == 's1' || solType == 's2') {
	                        var solTurningPoints = solutions[s][2];
	                        solTurningPoints.splice(1, 1);
	                        solTurningPoints.splice(solTurningPoints.length - 2, 1);
	                    }
	                }
	                break;
	
	            case 3:
	                /*remove colinear point for s1 as it seems that more colinear points do not look good
	                 * on organic solutions >:D*/
	                for (var s = 0; s < solutions.length; s++) {
	                    var solType = solutions[s][0];
	                    if (solType == 's1') {
	                        var solTurningPoints = solutions[s][2];
	                        var reducedSolution = Util.collinearReduction(solTurningPoints);
	                        solutions[s][2] = reducedSolution;
	                    }
	                }
	                break;
	        } //end switch
	
	    }
	
	    module.exports = ConnectionManager;
	


/***/ },
/* 106 */
/***/ function(module, exports) {

	/**
	 * 日志类
	 * @author wang.xiaohu
	 */
	
	
	    var Log  = {
	        LOG_LEVEL_NONE  : 0,
	
	        LOG_LEVEL_DEBUG : 1,
	
	        LOG_LEVEL_INFO : 2,
	
	        LOG_LEVEL_ERROR : 3,
	
	        level : this.LOG_LEVEL_ERROR,
	        
	        /**
	        * The less important of all messages
	        * @param {String} message - the message to be logged
	        **/
	        debug: function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_DEBUG){
	                    
	                    //in FF is debug
	                    if(typeof console.debug == 'function'){
	                        console.debug(message);
	                    }
	                    else{//TODO: in IE is log
	    //                    console.info(message);
	                    }
	                }
	            }
	        },
	
	
	        /**
	        * The commonly used log message
	        * @param {String} message - the message to be logged
	        **/
	        info : function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_INFO){
	                    console.info(message);
	                }
	            }
	        },
	
	        /**
	        * The worse kind of message. Usually a crash
	        * @param {String} message - the message to be logged
	        **/
	        error : function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_ERROR){
	                    console.error(message);
	                }
	            }
	        },
	
	        /**
	         *Start grouping the log messages
	         *@param {String} title - the title of the group
	         *@see <a href="http://getfirebug.com/logging">http://getfirebug.com/logging</a>
	         **/
	        group : function(title){
	            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info
	                if(typeof console !== 'undefined'){           
	                    /**If we do not test for group() function you will get an error in Opera
	                     *as Opera has it's own console...which does not have a group() function*/
	                    if(typeof console.group === 'function'){
	                        console.group(title);
	                    }
	                }
	            }
	        },
	
	        /**Ends current message grouping*/
	        groupEnd : function(){
	            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info
	                if(typeof console !== 'undefined'){
	                    /**If we do not test for groupEnd() function you will get an error in Opera
	                     *as Opera has it's own console...which does not have a group() function*/
	                    if(typeof console.groupEnd === 'function'){
	                        console.groupEnd();
	                    }
	                }
	            }
	        }
	
	    };
	
	    //Log.level = Log.LOG_LEVEL_DEBUG; 
	    Log.level = Log.LOG_LEVEL_ERROR; 
	    //Log.level = Log.LOG_LEVEL_ERROR;
	    //Log.level = Log.LOG_LEVEL_NONE;
	    module.exports = Log;
	    


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 连线操作类
	 * @author miao.cunzhi
	 */
	
	    var Node = __webpack_require__(76);
	    var Util = __webpack_require__(73);
	    var graphic = __webpack_require__(3);
	    var Point = __webpack_require__(60);
	    var zrUtil = __webpack_require__(4);
	
	    function LineOperationManager(connectionManager) {
	        this.lineOperations = [],
	            this.isEdit = true;
	        this.connectionManager = connectionManager;
	    }
	
	    LineOperationManager.prototype.creatOperation = function(key, obj, api) {
	        var lineOperation = new graphic.Image({
	            style: {
	                image: obj.icon,
	                width: obj.width || 15,
	                height: obj.height || 15
	            }
	        });
	        lineOperation.key = key;
	        lineOperation.operation = true;
	        lineOperation.hide();
	        obj.lineNode.icons.push(lineOperation);
	        this.lineOperations.push(lineOperation);
	
	        //小图标 点击事件  如果有回调则调用回调，否则派发事件
	        lineOperation.on("click", function(e) {
	            if (obj.callback) {
	                obj.callback(obj.lineNode);
	            } else {
	                var params = {};
	                params.event = e;
	                params.type = "click";
	                params.elementType = "LineOperationIcon";
	                api.trigger(params.type, params);
	            }
	
	        });
	        return lineOperation;
	    }
	
	    /**
	     * 计算小图标的位置，并显示
	     * @param  {[type]} connector [description]
	     * @return {[type]}           [description]
	     */
	    LineOperationManager.prototype.bindOperation = function(connector) {
	        if (this.isEdit == false) {
	            return;
	        }
	        var pointPosition = connector.middle();
	        var length = [];
	        for (var j = 0; j < connector.icons.length; j++) {
	            length.push(connector.icons[j].style.width);
	        }
	        var totalLength = 0;
	        for (var m = 0; m < connector.icons.length; m++) {
	            totalLength += length[m] + 10;
	        }
	        for (var i = 0; i < connector.icons.length; i++) {
	            var connectorPosition = 0;
	            for (var k = 0; k < i; k++) {
	                connectorPosition += length[k] + 10;
	            }
	            connector.icons[i].attr("position", [pointPosition[0] + connectorPosition - totalLength / 2, pointPosition[1] + 5]);
	            connector.icons[i].show();
	        }
	    }
	
	    LineOperationManager.prototype.hideAllLineOperation = function() {
	        for (var li = 0; li < this.lineOperations.length; li++) {
	            var icon = this.lineOperations[li];
	            icon.hide();
	        }
	    }
	
	    LineOperationManager.prototype.addIcon = function(key, obj, zr, api) {
	        //判断是小图标否存在 ，存在则直接返回
	        if (obj.lineNode.icons) {
	            for (var i = 0; i < obj.lineNode.icons.length; i++) {
	                if (obj.lineNode.icons[i].key == key) {
	                    this.bindOperation(obj.lineNode);
	                    return;
	                }
	            }
	        }
	
	        var lineOperation = this.creatOperation(key, obj, api);
	        zr.add(lineOperation);
	        this.bindOperation(obj.lineNode);
	        return lineOperation;
	    }
	
	    LineOperationManager.prototype.deleteIconObj = function(parentZr, lineNode) {
	        return {
	            icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAOBAMAAADpk+DfAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAtUExURQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGgKD4AAAAPdFJOUwDH/g+agESj4Y6zUiRnh7lnwbkAAABLSURBVAjXY2BgYDZgAIEnnkCa7a5cYGwCwwklIOhhMBEEgmIGnlAgOMDAprhQUGgDA5vWdJciXJRGR0dTAgPzQ0FBSaBpzMbGBgwAIoUW3sQ2EdkAAAAASUVORK5CYII=",
	            width: 12,
	            height: 14,
	            lineNode: lineNode,
	            callback: function(e) {
	                for (var i = 0; i < lineNode.icons.length; i++) {
	                    parentZr.remove(lineNode.icons[i])
	                }
	                this.connectionManager.deleteLine(parentZr);
	                this.hideAllLineOperation();
	                e.cancelBubble = true;
	            }.bind(this)
	        }
	    }
	
	    module.exports = LineOperationManager;
	


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 辅助线操作类
	 * @author miao.cunzhi
	 */
	
		var Node = __webpack_require__(76);
		var Util = __webpack_require__(73);
		var graphic = __webpack_require__(3);
	    var Point = __webpack_require__(60);
	    var zrUtil = __webpack_require__(4);
	
	    var Guidelines = {
	        virtualXLine:null,
	        virtualYLine:null,
	        createGuidelines:function(zr){
	            //创建x轴虚线
	            this.virtualXLine = new graphic.Line({
	                style: {
	                    lineDash: [5]
	                },
	                z: 3
	            });
	            //创建Y轴虚线
	            this.virtualYLine = new graphic.Line({
	                style: {
	                    lineDash: [5]
	                },
	                z: 3
	            });
	            zr.add(this.virtualXLine);
	            zr.add(this.virtualYLine);
	        },
	        judgeAlignment:function(nowRectPosition,domArray,maxWidth,maxHeight){
	            var that = this;
	            //循环判断水平对齐
	            for (var j = 0, len = domArray.length; j < len; j++) {
	                if (nowRectPosition[1] == domArray[j].position[1]) {
	                    that.virtualXLine.attr('position', [0, nowRectPosition[1]]);
	                    that.virtualXLine.attr("shape", {
	                        x2: maxWidth
	                    });
	
	                    break;
	                } else {
	                    that.virtualXLine.attr("shape", {
	                        x2: 0
	                    });
	                }
	            }
	            //循环判断垂直对齐
	            for (var m = 0, len1 = domArray.length; m < len1; m++) {
	                if (nowRectPosition[0] == domArray[m].position[0]) {
	                    that.virtualYLine.attr('position', [nowRectPosition[0], 0]);
	                    that.virtualYLine.attr("shape", {
	                        y2: maxHeight
	                    });
	                    break;
	                } else {
	                    that.virtualYLine.attr("shape", {
	                        y2: 0
	                    });
	                }
	            }
	        }
	    };
	
		module.exports = Guidelines;
	


/***/ },
/* 109 */
/***/ function(module, exports) {

	
	    //polyfill bind
	    if (!Function.prototype.bind) {
	        Function.prototype.bind = function(oThis) {
	            if (typeof this !== "function") {
	                // closest thing possible to the ECMAScript 5 internal IsCallable function
	                throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
	            }
	
	            var aArgs = Array.prototype.slice.call(arguments, 1),
	                fToBind = this,
	                fNOP = function() {},
	                fBound = function() {
	                    return fToBind.apply(this instanceof fNOP && oThis ? this : oThis || window,
	                        aArgs.concat(Array.prototype.slice.call(arguments)));
	                };
	
	            fNOP.prototype = this.prototype;
	            fBound.prototype = new fNOP();
	
	            return fBound;
	        };
	    }
	
	    //polyfill remove
	    if (!('remove' in Element.prototype)) {
	        Element.prototype.remove = function() {
	            if (this.parentNode) {
	                this.parentNode.removeChild(this);
	            }
	        };
	    }
	


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	
	    __webpack_require__(111);
	    __webpack_require__(61).registerPainter('vml', __webpack_require__(113));


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	// http://www.w3.org/TR/NOTE-VML
	// TODO Use proxy like svg instead of overwrite brush methods
	
	
	if (!__webpack_require__(45).canvasSupported) {
	    var vec2 = __webpack_require__(14);
	    var BoundingRect = __webpack_require__(25);
	    var CMD = __webpack_require__(26).CMD;
	    var colorTool = __webpack_require__(19);
	    var textContain = __webpack_require__(24);
	    var RectText = __webpack_require__(23);
	    var Displayable = __webpack_require__(7);
	    var ZImage = __webpack_require__(41);
	    var Text = __webpack_require__(42);
	    var Path = __webpack_require__(6);
	
	    var Gradient = __webpack_require__(38);
	
	    var vmlCore = __webpack_require__(112);
	
	    var round = Math.round;
	    var sqrt = Math.sqrt;
	    var abs = Math.abs;
	    var cos = Math.cos;
	    var sin = Math.sin;
	    var mathMax = Math.max;
	
	    var applyTransform = vec2.applyTransform;
	
	    var comma = ',';
	    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';
	
	    var Z = 21600;
	    var Z2 = Z / 2;
	
	    var ZLEVEL_BASE = 100000;
	    var Z_BASE = 1000;
	
	    var initRootElStyle = function (el) {
	        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';
	        el.coordsize = Z + ','  + Z;
	        el.coordorigin = '0,0';
	    };
	
	    var encodeHtmlAttribute = function (s) {
	        return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
	    };
	
	    var rgb2Str = function (r, g, b) {
	        return 'rgb(' + [r, g, b].join(',') + ')';
	    };
	
	    var append = function (parent, child) {
	        if (child && parent && child.parentNode !== parent) {
	            parent.appendChild(child);
	        }
	    };
	
	    var remove = function (parent, child) {
	        if (child && parent && child.parentNode === parent) {
	            parent.removeChild(child);
	        }
	    };
	
	    var getZIndex = function (zlevel, z, z2) {
	        // z 的取值范围为 [0, 1000]
	        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
	    };
	
	    var parsePercent = function (value, maxValue) {
	        if (typeof value === 'string') {
	            if (value.lastIndexOf('%') >= 0) {
	                return parseFloat(value) / 100 * maxValue;
	            }
	            return parseFloat(value);
	        }
	        return value;
	    };
	
	    /***************************************************
	     * PATH
	     **************************************************/
	
	    var setColorAndOpacity = function (el, color, opacity) {
	        var colorArr = colorTool.parse(color);
	        opacity = +opacity;
	        if (isNaN(opacity)) {
	            opacity = 1;
	        }
	        if (colorArr) {
	            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
	            el.opacity = opacity * colorArr[3];
	        }
	    };
	
	    var getColorAndAlpha = function (color) {
	        var colorArr = colorTool.parse(color);
	        return [
	            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),
	            colorArr[3]
	        ];
	    };
	
	    var updateFillNode = function (el, style, zrEl) {
	        // TODO pattern
	        var fill = style.fill;
	        if (fill != null) {
	            // Modified from excanvas
	            if (fill instanceof Gradient) {
	                var gradientType;
	                var angle = 0;
	                var focus = [0, 0];
	                // additional offset
	                var shift = 0;
	                // scale factor for offset
	                var expansion = 1;
	                var rect = zrEl.getBoundingRect();
	                var rectWidth = rect.width;
	                var rectHeight = rect.height;
	                if (fill.type === 'linear') {
	                    gradientType = 'gradient';
	                    var transform = zrEl.transform;
	                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];
	                    if (transform) {
	                        applyTransform(p0, p0, transform);
	                        applyTransform(p1, p1, transform);
	                    }
	                    var dx = p1[0] - p0[0];
	                    var dy = p1[1] - p0[1];
	                    angle = Math.atan2(dx, dy) * 180 / Math.PI;
	                    // The angle should be a non-negative number.
	                    if (angle < 0) {
	                        angle += 360;
	                    }
	
	                    // Very small angles produce an unexpected result because they are
	                    // converted to a scientific notation string.
	                    if (angle < 1e-6) {
	                        angle = 0;
	                    }
	                }
	                else {
	                    gradientType = 'gradientradial';
	                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	                    var transform = zrEl.transform;
	                    var scale = zrEl.scale;
	                    var width = rectWidth;
	                    var height = rectHeight;
	                    focus = [
	                        // Percent in bounding rect
	                        (p0[0] - rect.x) / width,
	                        (p0[1] - rect.y) / height
	                    ];
	                    if (transform) {
	                        applyTransform(p0, p0, transform);
	                    }
	
	                    width /= scale[0] * Z;
	                    height /= scale[1] * Z;
	                    var dimension = mathMax(width, height);
	                    shift = 2 * 0 / dimension;
	                    expansion = 2 * fill.r / dimension - shift;
	                }
	
	                // We need to sort the color stops in ascending order by offset,
	                // otherwise IE won't interpret it correctly.
	                var stops = fill.colorStops.slice();
	                stops.sort(function(cs1, cs2) {
	                    return cs1.offset - cs2.offset;
	                });
	
	                var length = stops.length;
	                // Color and alpha list of first and last stop
	                var colorAndAlphaList = [];
	                var colors = [];
	                for (var i = 0; i < length; i++) {
	                    var stop = stops[i];
	                    var colorAndAlpha = getColorAndAlpha(stop.color);
	                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);
	                    if (i === 0 || i === length - 1) {
	                        colorAndAlphaList.push(colorAndAlpha);
	                    }
	                }
	
	                if (length >= 2) {
	                    var color1 = colorAndAlphaList[0][0];
	                    var color2 = colorAndAlphaList[1][0];
	                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;
	                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;
	
	                    el.type = gradientType;
	                    el.method = 'none';
	                    el.focus = '100%';
	                    el.angle = angle;
	                    el.color = color1;
	                    el.color2 = color2;
	                    el.colors = colors.join(',');
	                    // When colors attribute is used, the meanings of opacity and o:opacity2
	                    // are reversed.
	                    el.opacity = opacity2;
	                    // FIXME g_o_:opacity ?
	                    el.opacity2 = opacity1;
	                }
	                if (gradientType === 'radial') {
	                    el.focusposition = focus.join(',');
	                }
	            }
	            else {
	                // FIXME Change from Gradient fill to color fill
	                setColorAndOpacity(el, fill, style.opacity);
	            }
	        }
	    };
	
	    var updateStrokeNode = function (el, style) {
	        // if (style.lineJoin != null) {
	        //     el.joinstyle = style.lineJoin;
	        // }
	        // if (style.miterLimit != null) {
	        //     el.miterlimit = style.miterLimit * Z;
	        // }
	        // if (style.lineCap != null) {
	        //     el.endcap = style.lineCap;
	        // }
	        if (style.lineDash != null) {
	            el.dashstyle = style.lineDash.join(' ');
	        }
	        if (style.stroke != null && !(style.stroke instanceof Gradient)) {
	            setColorAndOpacity(el, style.stroke, style.opacity);
	        }
	    };
	
	    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {
	        var isFill = type == 'fill';
	        var el = vmlEl.getElementsByTagName(type)[0];
	        // Stroke must have lineWidth
	        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {
	            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';
	            // FIXME Remove before updating, or set `colors` will throw error
	            if (style[type] instanceof Gradient) {
	                remove(vmlEl, el);
	            }
	            if (!el) {
	                el = vmlCore.createNode(type);
	            }
	
	            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
	            append(vmlEl, el);
	        }
	        else {
	            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';
	            remove(vmlEl, el);
	        }
	    };
	
	    var points = [[], [], []];
	    var pathDataToString = function (data, m) {
	        var M = CMD.M;
	        var C = CMD.C;
	        var L = CMD.L;
	        var A = CMD.A;
	        var Q = CMD.Q;
	
	        var str = [];
	        var nPoint;
	        var cmdStr;
	        var cmd;
	        var i;
	        var xi;
	        var yi;
	        for (i = 0; i < data.length;) {
	            cmd = data[i++];
	            cmdStr = '';
	            nPoint = 0;
	            switch (cmd) {
	                case M:
	                    cmdStr = ' m ';
	                    nPoint = 1;
	                    xi = data[i++];
	                    yi = data[i++];
	                    points[0][0] = xi;
	                    points[0][1] = yi;
	                    break;
	                case L:
	                    cmdStr = ' l ';
	                    nPoint = 1;
	                    xi = data[i++];
	                    yi = data[i++];
	                    points[0][0] = xi;
	                    points[0][1] = yi;
	                    break;
	                case Q:
	                case C:
	                    cmdStr = ' c ';
	                    nPoint = 3;
	                    var x1 = data[i++];
	                    var y1 = data[i++];
	                    var x2 = data[i++];
	                    var y2 = data[i++];
	                    var x3;
	                    var y3;
	                    if (cmd === Q) {
	                        // Convert quadratic to cubic using degree elevation
	                        x3 = x2;
	                        y3 = y2;
	                        x2 = (x2 + 2 * x1) / 3;
	                        y2 = (y2 + 2 * y1) / 3;
	                        x1 = (xi + 2 * x1) / 3;
	                        y1 = (yi + 2 * y1) / 3;
	                    }
	                    else {
	                        x3 = data[i++];
	                        y3 = data[i++];
	                    }
	                    points[0][0] = x1;
	                    points[0][1] = y1;
	                    points[1][0] = x2;
	                    points[1][1] = y2;
	                    points[2][0] = x3;
	                    points[2][1] = y3;
	
	                    xi = x3;
	                    yi = y3;
	                    break;
	                case A:
	                    var x = 0;
	                    var y = 0;
	                    var sx = 1;
	                    var sy = 1;
	                    var angle = 0;
	                    if (m) {
	                        // Extract SRT from matrix
	                        x = m[4];
	                        y = m[5];
	                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);
	                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);
	                        angle = Math.atan2(-m[1] / sy, m[0] / sx);
	                    }
	
	                    var cx = data[i++];
	                    var cy = data[i++];
	                    var rx = data[i++];
	                    var ry = data[i++];
	                    var startAngle = data[i++] + angle;
	                    var endAngle = data[i++] + startAngle + angle;
	                    // FIXME
	                    // var psi = data[i++];
	                    i++;
	                    var clockwise = data[i++];
	
	                    var x0 = cx + cos(startAngle) * rx;
	                    var y0 = cy + sin(startAngle) * ry;
	
	                    var x1 = cx + cos(endAngle) * rx;
	                    var y1 = cy + sin(endAngle) * ry;
	
	                    var type = clockwise ? ' wa ' : ' at ';
	                    if (Math.abs(x0 - x1) < 1e-4) {
	                        // IE won't render arches drawn counter clockwise if x0 == x1.
	                        if (Math.abs(endAngle - startAngle) > 1e-2) {
	                            // Offset x0 by 1/80 of a pixel. Use something
	                            // that can be represented in binary
	                            if (clockwise) {
	                                x0 += 270 / Z;
	                            }
	                        }
	                        else {
	                            // Avoid case draw full circle
	                            if (Math.abs(y0 - cy) < 1e-4) {
	                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {
	                                    y1 -= 270 / Z;
	                                }
	                                else {
	                                    y1 += 270 / Z;
	                                }
	                            }
	                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {
	                                x1 += 270 / Z;
	                            }
	                            else {
	                                x1 -= 270 / Z;
	                            }
	                        }
	                    }
	                    str.push(
	                        type,
	                        round(((cx - rx) * sx + x) * Z - Z2), comma,
	                        round(((cy - ry) * sy + y) * Z - Z2), comma,
	                        round(((cx + rx) * sx + x) * Z - Z2), comma,
	                        round(((cy + ry) * sy + y) * Z - Z2), comma,
	                        round((x0 * sx + x) * Z - Z2), comma,
	                        round((y0 * sy + y) * Z - Z2), comma,
	                        round((x1 * sx + x) * Z - Z2), comma,
	                        round((y1 * sy + y) * Z - Z2)
	                    );
	
	                    xi = x1;
	                    yi = y1;
	                    break;
	                case CMD.R:
	                    var p0 = points[0];
	                    var p1 = points[1];
	                    // x0, y0
	                    p0[0] = data[i++];
	                    p0[1] = data[i++];
	                    // x1, y1
	                    p1[0] = p0[0] + data[i++];
	                    p1[1] = p0[1] + data[i++];
	
	                    if (m) {
	                        applyTransform(p0, p0, m);
	                        applyTransform(p1, p1, m);
	                    }
	
	                    p0[0] = round(p0[0] * Z - Z2);
	                    p1[0] = round(p1[0] * Z - Z2);
	                    p0[1] = round(p0[1] * Z - Z2);
	                    p1[1] = round(p1[1] * Z - Z2);
	                    str.push(
	                        // x0, y0
	                        ' m ', p0[0], comma, p0[1],
	                        // x1, y0
	                        ' l ', p1[0], comma, p0[1],
	                        // x1, y1
	                        ' l ', p1[0], comma, p1[1],
	                        // x0, y1
	                        ' l ', p0[0], comma, p1[1]
	                    );
	                    break;
	                case CMD.Z:
	                    // FIXME Update xi, yi
	                    str.push(' x ');
	            }
	
	            if (nPoint > 0) {
	                str.push(cmdStr);
	                for (var k = 0; k < nPoint; k++) {
	                    var p = points[k];
	
	                    m && applyTransform(p, p, m);
	                    // 不 round 会非常慢
	                    str.push(
	                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),
	                        k < nPoint - 1 ? comma : ''
	                    );
	                }
	            }
	        }
	
	        return str.join('');
	    };
	
	    // Rewrite the original path method
	    Path.prototype.brushVML = function (vmlRoot) {
	        var style = this.style;
	
	        var vmlEl = this._vmlEl;
	        if (!vmlEl) {
	            vmlEl = vmlCore.createNode('shape');
	            initRootElStyle(vmlEl);
	
	            this._vmlEl = vmlEl;
	        }
	
	        updateFillAndStroke(vmlEl, 'fill', style, this);
	        updateFillAndStroke(vmlEl, 'stroke', style, this);
	
	        var m = this.transform;
	        var needTransform = m != null;
	        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];
	        if (strokeEl) {
	            var lineWidth = style.lineWidth;
	            // Get the line scale.
	            // Determinant of this.m_ means how much the area is enlarged by the
	            // transformation. So its square root can be used as a scale factor
	            // for width.
	            if (needTransform && !style.strokeNoScale) {
	                var det = m[0] * m[3] - m[1] * m[2];
	                lineWidth *= sqrt(abs(det));
	            }
	            strokeEl.weight = lineWidth + 'px';
	        }
	
	        var path = this.path;
	        if (this.__dirtyPath) {
	            path.beginPath();
	            this.buildPath(path, this.shape);
	            path.toStatic();
	            this.__dirtyPath = false;
	        }
	
	        vmlEl.path = pathDataToString(path.data, this.transform);
	
	        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
	
	        // Append to root
	        append(vmlRoot, vmlEl);
	
	        // Text
	        if (style.text != null) {
	            this.drawRectText(vmlRoot, this.getBoundingRect());
	        }
	        else {
	            this.removeRectText(vmlRoot);
	        }
	    };
	
	    Path.prototype.onRemove = function (vmlRoot) {
	        remove(vmlRoot, this._vmlEl);
	        this.removeRectText(vmlRoot);
	    };
	
	    Path.prototype.onAdd = function (vmlRoot) {
	        append(vmlRoot, this._vmlEl);
	        this.appendRectText(vmlRoot);
	    };
	
	    /***************************************************
	     * IMAGE
	     **************************************************/
	    var isImage = function (img) {
	        // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错
	        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';
	        // return img instanceof Image;
	    };
	
	    // Rewrite the original path method
	    ZImage.prototype.brushVML = function (vmlRoot) {
	        var style = this.style;
	        var image = style.image;
	
	        // Image original width, height
	        var ow;
	        var oh;
	
	        if (isImage(image)) {
	            var src = image.src;
	            if (src === this._imageSrc) {
	                ow = this._imageWidth;
	                oh = this._imageHeight;
	            }
	            else {
	                var imageRuntimeStyle = image.runtimeStyle;
	                var oldRuntimeWidth = imageRuntimeStyle.width;
	                var oldRuntimeHeight = imageRuntimeStyle.height;
	                imageRuntimeStyle.width = 'auto';
	                imageRuntimeStyle.height = 'auto';
	
	                // get the original size
	                ow = image.width;
	                oh = image.height;
	
	                // and remove overides
	                imageRuntimeStyle.width = oldRuntimeWidth;
	                imageRuntimeStyle.height = oldRuntimeHeight;
	
	                // Caching image original width, height and src
	                this._imageSrc = src;
	                this._imageWidth = ow;
	                this._imageHeight = oh;
	            }
	            image = src;
	        }
	        else {
	            if (image === this._imageSrc) {
	                ow = this._imageWidth;
	                oh = this._imageHeight;
	            }
	        }
	        if (!image) {
	            return;
	        }
	
	        var x = style.x || 0;
	        var y = style.y || 0;
	
	        var dw = style.width;
	        var dh = style.height;
	
	        var sw = style.sWidth;
	        var sh = style.sHeight;
	        var sx = style.sx || 0;
	        var sy = style.sy || 0;
	
	        var hasCrop = sw && sh;
	
	        var vmlEl = this._vmlEl;
	        if (!vmlEl) {
	            // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。
	            // vmlEl = vmlCore.createNode('group');
	            vmlEl = vmlCore.doc.createElement('div');
	            initRootElStyle(vmlEl);
	
	            this._vmlEl = vmlEl;
	        }
	
	        var vmlElStyle = vmlEl.style;
	        var hasRotation = false;
	        var m;
	        var scaleX = 1;
	        var scaleY = 1;
	        if (this.transform) {
	            m = this.transform;
	            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
	            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
	
	            hasRotation = m[1] || m[2];
	        }
	        if (hasRotation) {
	            // If filters are necessary (rotation exists), create them
	            // filters are bog-slow, so only create them if abbsolutely necessary
	            // The following check doesn't account for skews (which don't exist
	            // in the canvas spec (yet) anyway.
	            // From excanvas
	            var p0 = [x, y];
	            var p1 = [x + dw, y];
	            var p2 = [x, y + dh];
	            var p3 = [x + dw, y + dh];
	            applyTransform(p0, p0, m);
	            applyTransform(p1, p1, m);
	            applyTransform(p2, p2, m);
	            applyTransform(p3, p3, m);
	
	            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
	            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
	
	            var transformFilter = [];
	            transformFilter.push('M11=', m[0] / scaleX, comma,
	                        'M12=', m[2] / scaleY, comma,
	                        'M21=', m[1] / scaleX, comma,
	                        'M22=', m[3] / scaleY, comma,
	                        'Dx=', round(x * scaleX + m[4]), comma,
	                        'Dy=', round(y * scaleY + m[5]));
	
	            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';
	            // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用
	            vmlElStyle.filter = imageTransformPrefix + '.Matrix('
	                + transformFilter.join('') + ', SizingMethod=clip)';
	
	        }
	        else {
	            if (m) {
	                x = x * scaleX + m[4];
	                y = y * scaleY + m[5];
	            }
	            vmlElStyle.filter = '';
	            vmlElStyle.left = round(x) + 'px';
	            vmlElStyle.top = round(y) + 'px';
	        }
	
	        var imageEl = this._imageEl;
	        var cropEl = this._cropEl;
	
	        if (!imageEl) {
	            imageEl = vmlCore.doc.createElement('div');
	            this._imageEl = imageEl;
	        }
	        var imageELStyle = imageEl.style;
	        if (hasCrop) {
	            // Needs know image original width and height
	            if (! (ow && oh)) {
	                var tmpImage = new Image();
	                var self = this;
	                tmpImage.onload = function () {
	                    tmpImage.onload = null;
	                    ow = tmpImage.width;
	                    oh = tmpImage.height;
	                    // Adjust image width and height to fit the ratio destinationSize / sourceSize
	                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
	
	                    // Caching image original width, height and src
	                    self._imageWidth = ow;
	                    self._imageHeight = oh;
	                    self._imageSrc = image;
	                };
	                tmpImage.src = image;
	            }
	            else {
	                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
	            }
	
	            if (! cropEl) {
	                cropEl = vmlCore.doc.createElement('div');
	                cropEl.style.overflow = 'hidden';
	                this._cropEl = cropEl;
	            }
	            var cropElStyle = cropEl.style;
	            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
	            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
	            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='
	                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';
	
	            if (! cropEl.parentNode) {
	                vmlEl.appendChild(cropEl);
	            }
	            if (imageEl.parentNode != cropEl) {
	                cropEl.appendChild(imageEl);
	            }
	        }
	        else {
	            imageELStyle.width = round(scaleX * dw) + 'px';
	            imageELStyle.height = round(scaleY * dh) + 'px';
	
	            vmlEl.appendChild(imageEl);
	
	            if (cropEl && cropEl.parentNode) {
	                vmlEl.removeChild(cropEl);
	                this._cropEl = null;
	            }
	        }
	
	        var filterStr = '';
	        var alpha = style.opacity;
	        if (alpha < 1) {
	            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';
	        }
	        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';
	
	        imageELStyle.filter = filterStr;
	
	        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
	
	        // Append to root
	        append(vmlRoot, vmlEl);
	
	        // Text
	        if (style.text != null) {
	            this.drawRectText(vmlRoot, this.getBoundingRect());
	        }
	    };
	
	    ZImage.prototype.onRemove = function (vmlRoot) {
	        remove(vmlRoot, this._vmlEl);
	
	        this._vmlEl = null;
	        this._cropEl = null;
	        this._imageEl = null;
	
	        this.removeRectText(vmlRoot);
	    };
	
	    ZImage.prototype.onAdd = function (vmlRoot) {
	        append(vmlRoot, this._vmlEl);
	        this.appendRectText(vmlRoot);
	    };
	
	
	    /***************************************************
	     * TEXT
	     **************************************************/
	
	    var DEFAULT_STYLE_NORMAL = 'normal';
	
	    var fontStyleCache = {};
	    var fontStyleCacheCount = 0;
	    var MAX_FONT_CACHE_SIZE = 100;
	    var fontEl = document.createElement('div');
	
	    var getFontStyle = function (fontString) {
	        var fontStyle = fontStyleCache[fontString];
	        if (!fontStyle) {
	            // Clear cache
	            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
	                fontStyleCacheCount = 0;
	                fontStyleCache = {};
	            }
	
	            var style = fontEl.style;
	            var fontFamily;
	            try {
	                style.font = fontString;
	                fontFamily = style.fontFamily.split(',')[0];
	            }
	            catch (e) {
	            }
	
	            fontStyle = {
	                style: style.fontStyle || DEFAULT_STYLE_NORMAL,
	                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
	                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
	                size: parseFloat(style.fontSize || 12) | 0,
	                family: fontFamily || 'Microsoft YaHei'
	            };
	
	            fontStyleCache[fontString] = fontStyle;
	            fontStyleCacheCount++;
	        }
	        return fontStyle;
	    };
	
	    var textMeasureEl;
	    // Overwrite measure text method
	    textContain.measureText = function (text, textFont) {
	        var doc = vmlCore.doc;
	        if (!textMeasureEl) {
	            textMeasureEl = doc.createElement('div');
	            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'
	                + 'padding:0;margin:0;border:none;white-space:pre;';
	            vmlCore.doc.body.appendChild(textMeasureEl);
	        }
	
	        try {
	            textMeasureEl.style.font = textFont;
	        } catch (ex) {
	            // Ignore failures to set to invalid font.
	        }
	        textMeasureEl.innerHTML = '';
	        // Don't use innerHTML or innerText because they allow markup/whitespace.
	        textMeasureEl.appendChild(doc.createTextNode(text));
	        return {
	            width: textMeasureEl.offsetWidth
	        };
	    };
	
	    var tmpRect = new BoundingRect();
	
	    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {
	
	        var style = this.style;
	        var text = style.text;
	        // Convert to string
	        text != null && (text += '');
	        if (!text) {
	            return;
	        }
	
	        var x;
	        var y;
	        var align = style.textAlign;
	        var fontStyle = getFontStyle(style.textFont);
	        // FIXME encodeHtmlAttribute ?
	        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '
	            + fontStyle.size + 'px "' + fontStyle.family + '"';
	
	        var baseline = style.textBaseline;
	        var verticalAlign = style.textVerticalAlign;
	
	        textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);
	
	        // Transform rect to view space
	        var m = this.transform;
	        // Ignore transform for text in other element
	        if (m && !fromTextEl) {
	            tmpRect.copy(rect);
	            tmpRect.applyTransform(m);
	            rect = tmpRect;
	        }
	
	        if (!fromTextEl) {
	            var textPosition = style.textPosition;
	            var distance = style.textDistance;
	            // Text position represented by coord
	            if (textPosition instanceof Array) {
	                x = rect.x + parsePercent(textPosition[0], rect.width);
	                y = rect.y + parsePercent(textPosition[1], rect.height);
	
	                align = align || 'left';
	                baseline = baseline || 'top';
	            }
	            else {
	                var res = textContain.adjustTextPositionOnRect(
	                    textPosition, rect, textRect, distance
	                );
	                x = res.x;
	                y = res.y;
	
	                // Default align and baseline when has textPosition
	                align = align || res.textAlign;
	                baseline = baseline || res.textBaseline;
	            }
	        }
	        else {
	            x = rect.x;
	            y = rect.y;
	        }
	        if (verticalAlign) {
	            switch (verticalAlign) {
	                case 'middle':
	                    y -= textRect.height / 2;
	                    break;
	                case 'bottom':
	                    y -= textRect.height;
	                    break;
	                // 'top'
	            }
	            // Ignore baseline
	            baseline = 'top';
	        }
	
	        var fontSize = fontStyle.size;
	        // 1.75 is an arbitrary number, as there is no info about the text baseline
	        switch (baseline) {
	            case 'hanging':
	            case 'top':
	                y += fontSize / 1.75;
	                break;
	            case 'middle':
	                break;
	            default:
	            // case null:
	            // case 'alphabetic':
	            // case 'ideographic':
	            // case 'bottom':
	                y -= fontSize / 2.25;
	                break;
	        }
	        switch (align) {
	            case 'left':
	                break;
	            case 'center':
	                x -= textRect.width / 2;
	                break;
	            case 'right':
	                x -= textRect.width;
	                break;
	            // case 'end':
	                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';
	                // break;
	            // case 'start':
	                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';
	                // break;
	            // default:
	            //     align = 'left';
	        }
	
	        var createNode = vmlCore.createNode;
	
	        var textVmlEl = this._textVmlEl;
	        var pathEl;
	        var textPathEl;
	        var skewEl;
	        if (!textVmlEl) {
	            textVmlEl = createNode('line');
	            pathEl = createNode('path');
	            textPathEl = createNode('textpath');
	            skewEl = createNode('skew');
	
	            // FIXME Why here is not cammel case
	            // Align 'center' seems wrong
	            textPathEl.style['v-text-align'] = 'left';
	
	            initRootElStyle(textVmlEl);
	
	            pathEl.textpathok = true;
	            textPathEl.on = true;
	
	            textVmlEl.from = '0 0';
	            textVmlEl.to = '1000 0.05';
	
	            append(textVmlEl, skewEl);
	            append(textVmlEl, pathEl);
	            append(textVmlEl, textPathEl);
	
	            this._textVmlEl = textVmlEl;
	        }
	        else {
	            // 这里是在前面 appendChild 保证顺序的前提下
	            skewEl = textVmlEl.firstChild;
	            pathEl = skewEl.nextSibling;
	            textPathEl = pathEl.nextSibling;
	        }
	
	        var coords = [x, y];
	        var textVmlElStyle = textVmlEl.style;
	        // Ignore transform for text in other element
	        if (m && fromTextEl) {
	            applyTransform(coords, coords, m);
	
	            skewEl.on = true;
	
	            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +
	            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';
	
	            // Text position
	            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);
	            // Left top point as origin
	            skewEl.origin = '0 0';
	
	            textVmlElStyle.left = '0px';
	            textVmlElStyle.top = '0px';
	        }
	        else {
	            skewEl.on = false;
	            textVmlElStyle.left = round(x) + 'px';
	            textVmlElStyle.top = round(y) + 'px';
	        }
	
	        textPathEl.string = encodeHtmlAttribute(text);
	        // TODO
	        try {
	            textPathEl.style.font = font;
	        }
	        // Error font format
	        catch (e) {}
	
	        updateFillAndStroke(textVmlEl, 'fill', {
	            fill: fromTextEl ? style.fill : style.textFill,
	            opacity: style.opacity
	        }, this);
	        updateFillAndStroke(textVmlEl, 'stroke', {
	            stroke: fromTextEl ? style.stroke : style.textStroke,
	            opacity: style.opacity,
	            lineDash: style.lineDash
	        }, this);
	
	        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
	
	        // Attached to root
	        append(vmlRoot, textVmlEl);
	    };
	
	    var removeRectText = function (vmlRoot) {
	        remove(vmlRoot, this._textVmlEl);
	        this._textVmlEl = null;
	    };
	
	    var appendRectText = function (vmlRoot) {
	        append(vmlRoot, this._textVmlEl);
	    };
	
	    var list = [RectText, Displayable, ZImage, Path, Text];
	
	    // In case Displayable has been mixed in RectText
	    for (var i = 0; i < list.length; i++) {
	        var proto = list[i].prototype;
	        proto.drawRectText = drawRectText;
	        proto.removeRectText = removeRectText;
	        proto.appendRectText = appendRectText;
	    }
	
	    Text.prototype.brushVML = function (vmlRoot) {
	        var style = this.style;
	        if (style.text != null) {
	            this.drawRectText(vmlRoot, {
	                x: style.x || 0, y: style.y || 0,
	                width: 0, height: 0
	            }, this.getBoundingRect(), true);
	        }
	        else {
	            this.removeRectText(vmlRoot);
	        }
	    };
	
	    Text.prototype.onRemove = function (vmlRoot) {
	        this.removeRectText(vmlRoot);
	    };
	
	    Text.prototype.onAdd = function (vmlRoot) {
	        this.appendRectText(vmlRoot);
	    };
	}


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	
	
	if (!__webpack_require__(45).canvasSupported) {
	    var urn = 'urn:schemas-microsoft-com:vml';
	
	    var createNode;
	    var win = window;
	    var doc = win.document;
	
	    var vmlInited = false;
	
	    try {
	        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);
	        createNode = function (tagName) {
	            return doc.createElement('<zrvml:' + tagName + ' class="zrvml">');
	        };
	    }
	    catch (e) {
	        createNode = function (tagName) {
	            return doc.createElement('<' + tagName + ' xmlns="' + urn + '" class="zrvml">');
	        };
	    }
	
	    // From raphael
	    var initVML = function () {
	        if (vmlInited) {
	            return;
	        }
	        vmlInited = true;
	
	        var styleSheets = doc.styleSheets;
	        if (styleSheets.length < 31) {
	            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');
	        }
	        else {
	            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
	            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');
	        }
	    };
	
	    // Not useing return to avoid error when converting to CommonJS module
	    module.exports = {
	        doc: doc,
	        initVML: initVML,
	        createNode: createNode
	    };
	}


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * VML Painter.
	 *
	 * @module zrender/vml/Painter
	 */
	
	
	
	    var zrLog = __webpack_require__(21);
	    var vmlCore = __webpack_require__(112);
	
	    function parseInt10(val) {
	        return parseInt(val, 10);
	    }
	
	    /**
	     * @alias module:zrender/vml/Painter
	     */
	    function VMLPainter(root, storage) {
	
	        vmlCore.initVML();
	
	        this.root = root;
	
	        this.storage = storage;
	
	        var vmlViewport = document.createElement('div');
	
	        var vmlRoot = document.createElement('div');
	
	        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';
	
	        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';
	
	        root.appendChild(vmlViewport);
	
	        this._vmlRoot = vmlRoot;
	        this._vmlViewport = vmlViewport;
	
	        this.resize();
	
	        // Modify storage
	        var oldDelFromMap = storage.delFromMap;
	        var oldAddToMap = storage.addToMap;
	        storage.delFromMap = function (elId) {
	            var el = storage.get(elId);
	
	            oldDelFromMap.call(storage, elId);
	
	            if (el) {
	                el.onRemove && el.onRemove(vmlRoot);
	            }
	        };
	
	        storage.addToMap = function (el) {
	            // Displayable already has a vml node
	            el.onAdd && el.onAdd(vmlRoot);
	
	            oldAddToMap.call(storage, el);
	        };
	
	        this._firstPaint = true;
	    }
	
	    VMLPainter.prototype = {
	
	        constructor: VMLPainter,
	
	        /**
	         * @return {HTMLDivElement}
	         */
	        getViewportRoot: function () {
	            return this._vmlViewport;
	        },
	
	        /**
	         * 刷新
	         */
	        refresh: function () {
	
	            var list = this.storage.getDisplayList(true, true);
	
	            this._paintList(list);
	        },
	
	        _paintList: function (list) {
	            var vmlRoot = this._vmlRoot;
	            for (var i = 0; i < list.length; i++) {
	                var el = list[i];
	                if (el.invisible || el.ignore) {
	                    if (!el.__alreadyNotVisible) {
	                        el.onRemove(vmlRoot);
	                    }
	                    // Set as already invisible
	                    el.__alreadyNotVisible = true;
	                }
	                else {
	                    if (el.__alreadyNotVisible) {
	                        el.onAdd(vmlRoot);
	                    }
	                    el.__alreadyNotVisible = false;
	                    if (el.__dirty) {
	                        el.beforeBrush && el.beforeBrush();
	                        (el.brushVML || el.brush).call(el, vmlRoot);
	                        el.afterBrush && el.afterBrush();
	                    }
	                }
	                el.__dirty = false;
	            }
	
	            if (this._firstPaint) {
	                // Detached from document at first time
	                // to avoid page refreshing too many times
	
	                // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变
	                this._vmlViewport.appendChild(vmlRoot);
	                this._firstPaint = false;
	            }
	        },
	
	        resize: function (width, height) {
	            var width = width == null ? this._getWidth() : width;
	            var height = height == null ? this._getHeight() : height;
	
	            if (this._width != width || this._height != height) {
	                this._width = width;
	                this._height = height;
	
	                var vmlViewportStyle = this._vmlViewport.style;
	                vmlViewportStyle.width = width + 'px';
	                vmlViewportStyle.height = height + 'px';
	            }
	        },
	
	        dispose: function () {
	            this.root.innerHTML = '';
	
	            this._vmlRoot =
	            this._vmlViewport =
	            this.storage = null;
	        },
	
	        getWidth: function () {
	            return this._width;
	        },
	
	        getHeight: function () {
	            return this._height;
	        },
	
	        clear: function () {
	            if (this._vmlViewport) {
	                this.root.removeChild(this._vmlViewport);
	            }
	        },
	
	        _getWidth: function () {
	            var root = this.root;
	            var stl = root.currentStyle;
	
	            return ((root.clientWidth || parseInt10(stl.width))
	                    - parseInt10(stl.paddingLeft)
	                    - parseInt10(stl.paddingRight)) | 0;
	        },
	
	        _getHeight: function () {
	            var root = this.root;
	            var stl = root.currentStyle;
	
	            return ((root.clientHeight || parseInt10(stl.height))
	                    - parseInt10(stl.paddingTop)
	                    - parseInt10(stl.paddingBottom)) | 0;
	        }
	    };
	
	    // Not supported methods
	    function createMethodNotSupport(method) {
	        return function () {
	            zrLog('In IE8.0 VML mode painter not support method "' + method + '"');
	        };
	    }
	
	    var notSupportedMethods = [
	        'getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers',
	        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'
	    ];
	
	    for (var i = 0; i < notSupportedMethods.length; i++) {
	        var name = notSupportedMethods[i];
	        VMLPainter.prototype[name] = createMethodNotSupport(name);
	    }
	
	    module.exports = VMLPainter;


/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAwNzY2ZDAxNjgyYjdkOTY4ZjUwNyIsIndlYnBhY2s6Ly8vLi9pbmRleC5icG1uLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvRmlzaFRvcG9CcG1uLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1N0eWxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL0V2ZW50ZnVsLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS92ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vZWFzaW5nLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdG9vbC9jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvTFJVLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL21peGluL1JlY3RUZXh0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi90ZXh0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvY3VydmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2Jib3guanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL2xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL2N1YmljLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9xdWFkcmF0aWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL2FyYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vd2luZGluZ0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdHRlcm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi90b29sL3RyYW5zZm9ybVBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2Vudi5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3BvbHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhTcGxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhCZXppZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcm91bmRSZWN0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9FeHRlbnNpb25BcGkuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Qb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3pyZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9IYW5kbGVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvU3RvcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdGltc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2V2ZW50LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2RvbS9IYW5kbGVyUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9QYWludGVyLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9CcG1uVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9MaW5lU3RydWN0LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9CUE1OTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9jbGF6ei5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL21vZGVsL0JQTU5Nb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL01vZGVsLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9TdGFydEV2ZW50Tm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZXZlbnQvRXZlbnROb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9FbmRFdmVudE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL3Rhc2svVXNlclRhc2tOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL1Rhc2tOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL01hbnVhbFRhc2tOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL1NjcmlwdFRhc2tOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL01haWxUYXNrTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZXZlbnQvYm91bmRhcnlldmVudC9DYXRjaFRpbWVyRXZlbnROb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L0NhdGNoU2lnbmFsRXZlbnROb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L1Rocm93U2lnbmFsRXZlbnROb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9nYXRld2F5L0luY2x1c2l2ZUdhdGV3YXlOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9nYXRld2F5L0dhdGV3YXlOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9nYXRld2F5L0V4Y2x1c2l2ZUdhdGV3YXlOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9nYXRld2F5L1BhcmFsbGVsR2F0ZXdheU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL1N1YlByb2Nlc3NOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvSGFuZGxlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0VmZmVjdExpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdGlvblBvaW50LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvQnBtbi5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvQnBtbk9wZXJhdGlvbk5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL09wZXJhdGlvbk5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9tYW5hZ2VyL0JwbW5Db25uZWN0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvQ29ubmVjdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Mb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL0xpbmVPcGVyYXRpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9HdWlkZWxpbmVzLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi92bWwvdm1sLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdm1sL2dyYXBoaWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi92bWwvY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3ZtbC9QYWludGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSw0QkFBNEI7QUFDM0MsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2paQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHlEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDLG9CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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b0JBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzUUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7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QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7Ozs7Ozs7QUM1U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQ3ZQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsNEJBQTRCO0FBQy9DLG9CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsNEJBQTRCO0FBQy9DLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLDRCQUE0QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDM0pBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNC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QUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0Is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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9CLHVCQUF1QjtBQUMzQyxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDbkpBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixpQkFBaUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixTQUFTO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2h3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLGVBQWU7QUFDL0IsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7QUMzaEJBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLGNBQWM7QUFDN0IsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxlQUFlO0FBQzlCLGdCQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxlQUFlO0FBQzlCLGdCQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLGVBQWU7QUFDOUIsZ0JBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLGVBQWU7QUFDOUIsZ0JBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDcE9BOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsWUFBWTtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsWUFBWTtBQUMzQztBQUNBOztBQUVBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDOVlBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdkNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDcENBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLFFBQVE7QUFDNUIscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsaUNBQWlDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdDQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7Ozs7Ozs7QUM3Qkw7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW1DLHNCQUFzQjtBQUN6RDtBQUNBO0FBQ0EsNENBQTJDLHVCQUF1QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW1DLHVCQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOzs7Ozs7OztBQy9HTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QjtBQUN2QixtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWdELElBQUk7QUFDcEQsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0EsK0NBQThDOztBQUU5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7Ozs7Ozs7QUMxQkw7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE1BQUs7Ozs7Ozs7OztBQ3JCTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW1DLGlDQUFpQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsUUFBUTtBQUN2QixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsU0FBUztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsVUFBVTtBQUNqQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTRDLFNBQVM7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ25HQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE1BQUs7Ozs7Ozs7QUM1Qkw7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7Ozs7Ozs7OztBQ3RDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7Ozs7OztBQ3pETDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsdUJBQXVCO0FBQzNDLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1C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QUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDdFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0EsZUFBYztBQUNkLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBOztBQUVBLHlEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQ0FBK0IscUJBQXFCO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLHdCQUF3QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBOzs7Ozs7OztBQ3BSQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFjLFlBQVk7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXVCLGFBQWE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NB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LHFCQUFvQixTQUFTO0FBQzdCO0FBQ0EscUJBQW9CLFNBQVM7QUFDN0I7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7QUM1UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5RUFBd0U7QUFDeEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE1BQU07QUFDekI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUN6WEE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWlELFNBQVM7QUFDMUQ7QUFDQSxrRUFBaUU7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzREFBcUQ7QUFDckQsc0RBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdEQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLE9BQU87O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsWUFBWTtBQUMzQixnQkFBZSx1QkFBdUI7QUFDdEMsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEwQyxZQUFZOztBQUV0RDtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEIsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSw0QkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTRDLE9BQU87QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsWUFBWTtBQUMvQjtBQUNBOztBQUVBOzs7O0FBSUEsb0JBQW1CLFlBQVk7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOzs7Ozs7Ozs7QUMxeUJBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIs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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBK0IsWUFBWTtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQTZELGFBQWEsT0FBTztBQUNqRiw4QkFBNkIsU0FBUyxZQUFZLGdCQUFnQjtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUMzaENBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkRBQTBELGdCQUFnQixrQkFBa0IsWUFBWSxhQUFhOztBQUVySCxvREFBbUQsT0FBTyxNQUFNOztBQUVoRTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsNEJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJmaXNoVG9wb0JwbW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJmaXNoVG9wb0JwbW5cIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZmlzaFRvcG9CcG1uXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uXG4gKiovIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCAwNzY2ZDAxNjgyYjdkOTY4ZjUwN1xuICoqLyIsIi8qKlxyXG4gKiBFeHBvcnQgZmlzaFRvcG8gYXMgQ29tbW9uSlMgbW9kdWxlXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9GaXNoVG9wb0JwbW4uanMnKTtcclxuLy/lhbzlrrlJRTgg5byV5YWlVk1MIOWmguaenOS4jemcgOimgeWFvOWuuUlFOOivt+WIoOmZpFxyXG5yZXF1aXJlKCd6cmVuZGVyL2xpYi92bWwvdm1sJyk7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vaW5kZXguYnBtbi5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiBCUE1O5a+56LGhXHJcbiAqIEBjbGFzcyBmaXNoLnRvcG8uRmlzaFRvcG9CcG1uXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBjbGlja1xyXG4gKiDoioLngrnmiJbogIXnur/mrrXnmoRjbGlja+S6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2IGV2ZW50LnRhcmdldOS4uuebruagh+WvueixoSBldmVudC50YXJnZXQubW9kZWzkuLrnm67moIflr7nosaHnmoTkuJrliqHmlbDmja5cclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgdGhpcy5maXNoVG9wb0JwbW4ub24oXCJjbGlja1wiLGZ1bmN0aW9uKGUpIHtcclxuICogICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xyXG4gKiAgICAgICAgICBpZihGaXNoVG9wb0JwbW4uQnBtbi5pc0Zsb3codGFyZ2V0KSkgeyAvL+WIpOaWreexu+Wei1xyXG4gKiAgICAgICAgICAgICAgdmFyIGxpbmVOb2RlID0gZS50YXJnZXQ7XHJcbiAqICAgICAgICAgICAgICB0aGF0LmZpc2hUb3BvQnBtbi5iaW5kTGluZURlbGV0ZShsaW5lTm9kZSk7IC8v57uZ57q/5q615aKe5Yqg5Yig6Zmk5Zu+5qCHXHJcbiAqICAgICAgICAgICAgICAvL3RvZG9cclxuICogICAgICAgICAgfVxyXG4gKiAgICAgIH1cclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGRibGNsaWNrXHJcbiAqIOiKgueCueaIluiAhee6v+auteeahOWPjOWHu+S6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2IGV2ZW50LnRhcmdldOS4uuebruagh+WvueixoSBldmVudC50YXJnZXQubW9kZWzkuLrnm67moIflr7nosaHnmoTkuJrliqHmlbDmja5cclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgICAgIC8v5Y+M5Ye75by55Ye66IqC54K55a+55bqU55qEanNvblxyXG4gKiAgICAgICAgICB0aGlzLmZpc2hUb3BvQnBtbi5vbihcImRibGNsaWNrXCIsZnVuY3Rpb24oZSkge1xyXG4gKiAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xyXG4gKlxyXG4gKiAgICAgICAgICAgICAgaWYoRmlzaFRvcG9CcG1uLkJwbW4uaXNGbG93KHRhcmdldCkpIHtcclxuICogICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImRibGNsaWNrIGxpbmVcIik7XHJcbiAqICAgICAgICAgICAgICB9XHJcbiAqICAgICAgICAgICAgICBlbHNle1xyXG4gKiAgICAgICAgICAgICAgICAgIHZhciBqc29uID0gbm9kZU1vZGVsLm9wdGlvbjtcclxuICogICAgICAgICAgICAgICAgICBmaXNoLnBvcHVwVmlldyh7XHJcbiAqICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJ2aWV3cy9kaWFsb2cvRXhwb3J0SnNvbkRsZy5qc1wiLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICB2aWV3T3B0aW9uOnticG1uSnNvbjpKU09OLnN0cmluZ2lmeShqc29uLG51bGwsNCl9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24ocG9wdXAsdmlldykge1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJPS1wiKTtcclxuICogICAgICAgICAgICAgICAgICAgICAgfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKG1zZykge1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJyZXR1cm4gdmFsdWU6IFwiICsgbXNnKTtcclxuICogICAgICAgICAgICAgICAgICAgICAgfVxyXG4gKiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gKiAgICAgICAgICAgICAgfVxyXG4gKiAgICAgICAgICB9KTtcclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGNyZWF0ZVxyXG4gKiDoioLngrnkuI7nur/mrrXliJvlu7rlrozmr5XnmoTkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tiBldmVudC50YXJnZXTkuLrnm67moIflr7nosaEgZXZlbnQudGFyZ2V0Lm1vZGVs5Li655uu5qCH5a+56LGh55qE5Lia5Yqh5pWw5o2uXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICAgICB0aGlzLmZpc2hUb3BvQnBtbi5vbihcImNyZWF0ZVwiLCBmdW5jdGlvbihlKSB7XHJcbiAqICAgICAgICAgICAgICBpZihGaXNoVG9wb0JwbW4uQnBtbi5pc0Zsb3coZS50YXJnZXQpKSB7XHJcbiAqICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBlLnRhcmdldDtcclxuICogICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIui/nue6v+WIm+W7uuWujOavle+8jOS7jlwiICsgbGluZS5zdGFydE5vZGUubW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpICsgXCIg6IezIFwiICsgbGluZS5lbmROb2RlLm1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSk7XHJcbiAqICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gKiAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gZS50YXJnZXQ7XHJcbiAqICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLoioLngrnvvJpcIiArIG5vZGUubW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpICsgXCIg5Yib5bu65a6M5q+VXCIpO1xyXG4gKiAgICAgICAgICAgICAgfVxyXG4gKiAgICAgICAgICB9KTtcclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGRlbGV0ZVxyXG4gKiDoioLngrnkuI7nur/mrrXliKDpmaTlrozmr5XnmoTkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tiBldmVudC50YXJnZXTkuLrnm67moIflr7nosaEgZXZlbnQudGFyZ2V0Lm1vZGVs5Li655uu5qCH5a+56LGh55qE5Lia5Yqh5pWw5o2uXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICAgICAvL+iKgueCueWIoOmZpOWujOavleS6i+S7tlxyXG4gKiAgICAgICAgICB0aGlzLmZpc2hUb3BvQnBtbi5vbihcImRlbGV0ZVwiLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLliKDpmaTnmoTmmK/vvJpcIiArIGV2ZW50LnRhcmdldCk7XHJcbiAqICAgICAgICAgIH0pO1xyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgRXh0ZW5zaW9uQVBJID0gcmVxdWlyZSgnLi9FeHRlbnNpb25BcGknKTtcclxuICAgIHZhciBQb2ludCA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvUG9pbnQuanNcIik7XHJcbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bCcpO1xyXG4gICAgdmFyIHpyZW5kZXIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi96cmVuZGVyJyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanMnKTtcclxuICAgIHZhciBCcG1uVXRpbCA9IHJlcXVpcmUoXCIuL0JwbW5VdGlsLmpzXCIpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgQlBNTk1vZGVsID0gcmVxdWlyZShcIi4vbW9kZWwvQlBNTk1vZGVsLmpzXCIpO1xyXG4gICAgdmFyIEJQTU5Ob2RlID0gcmVxdWlyZShcIi4vbm9kZS9CUE1OTm9kZS5qc1wiKTtcclxuICAgIHZhciBPcGVyYXRpb25Ob2RlID0gcmVxdWlyZShcIi4vbm9kZS9CcG1uT3BlcmF0aW9uTm9kZS5qc1wiKTtcclxuICAgIHZhciBCcG1uQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9tYW5hZ2VyL0JwbW5Db25uZWN0aW9uTWFuYWdlci5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICB2YXIgTGluZU9wZXJhdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvTGluZU9wZXJhdGlvbk1hbmFnZXIuanNcIik7XHJcbiAgICB2YXIgR3VpZGVsaW5lcyA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9HdWlkZWxpbmVzLmpzXCIpO1xyXG4gICAgdmFyIEJwbW4gPSByZXF1aXJlKFwiLi9CcG1uLmpzXCIpO1xyXG4gICAgcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9wb2x5ZmlsbC5qc1wiKTtcclxuICAgIGZ1bmN0aW9uIEZpc2hUb3BvQnBtbihkb20sIG9wdHMpIHtcclxuICAgICAgICB0aGlzLmlkO1xyXG4gICAgICAgIHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgdGhpcy5fZG9tID0gZG9tO1xyXG4gICAgICAgIHRoaXMuX3pyID0genJlbmRlci5pbml0KGRvbSwge1xyXG4gICAgICAgICAgICByZW5kZXJlcjogb3B0cy5yZW5kZXJlciB8fCAnY2FudmFzJyxcclxuICAgICAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogb3B0cy5kZXZpY2VQaXhlbFJhdGlvXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hbGxOb2RlcyA9IFtdOyAvL+WtmOaUvuaJgOacieiKgueCuVxyXG4gICAgICAgIHRoaXMuc3ViUHJvY2Vzc05vZGUgPSBbXTsgIC8v5a2Y5pS+5a2Q6IqC54K5XHJcbiAgICAgICAgdGhpcy5kb21BcnJheSA9IFtdOyAvL+WtmOaUvuiKgueCueeahOS9jee9ruS/oeaBr++8jOaLluWKqOeahOaXtuWAmeeUqOWIsFxyXG4gICAgICAgIHRoaXMub3ZlcmxhcEFycmF5ID0gW107IC8vIOWtmOaUvuiKgueCueeahOS9jee9ruS/oeaBr++8jOWIpOaWremHjeWPoOeUqOWIsO+8jOmZpOWOu+S6huWtkOa1geeoi+mHjOmdoueahOiKgueCuVxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWROb2RlID0gbnVsbDsgIC8v6YCJ5Lit55qE6IqC54K5XHJcbiAgICAgICAgdGhpcy5pc05vZGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJlY3Q7ICAvLyDlr7npvZDnur/lkoznp7vliqjmoYboioLngrlcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGU7XHJcbiAgICAgICAgdGhpcy5zdGVwID0gMDsvL+WJjei/m+WQjumAgOiuoeatpeaVsFxyXG4gICAgICAgIHRoaXMuc3RlcEpzb24gPSBbXTsvL+WtmOaUvuavj+atpeeahGpzb25cclxuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xyXG4gICAgICAgIHRoaXMuX2FwaSA9IG5ldyBFeHRlbnNpb25BUEkodGhpcyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7Qm9vbGVhbn0gZm9yYmlkRWRpdCDmmK/lkKbnpoHnlKjnvJbovpHlip/og71cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZvcmJpZEVkaXQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IEJwbW5Db25uZWN0aW9uTWFuYWdlcigpO1xyXG4gICAgICAgIHRoaXMubGluZU9wZXJhdGlvbk1hbmFnZXIgPSBuZXcgTGluZU9wZXJhdGlvbk1hbmFnZXIodGhpcy5jb25uZWN0aW9uTWFuYWdlcik7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG5ldyBCUE1OTW9kZWwoe30pO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KEJwbW4uUkVTT1VSQ0VfSUQsIHV0aWwuZ2V0VVVJRCgpKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChCcG1uLkJQTU5fVFlQRSwgQnBtbi5URU1QTEFURSk7XHJcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcclxuICAgICAgICBCcG1uVXRpbC5yZWdpc3RlckJQTU5Ob2RlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZpc2hUb3BvUHJvdG8gPSBGaXNoVG9wb0JwbW4ucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+WIGZpc2hUb3BvIOWunuS+i+WuueWZqOeahCBkb20g6IqC54K5XHJcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5nZXREb20gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZG9tO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZ2V0WnIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fenI7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5YgZmlzaFRvcG8g5a6e5L6L5a655Zmo55qE5a695bqm44CCXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZ2V0V2lkdGggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fenIuZ2V0V2lkdGgoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5YgZmlzaFRvcG8g5a6e5L6L5a655Zmo55qE6auY5bqm44CCXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pyLmdldEhlaWdodCgpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlvZPliY3lrp7kvovmmK/lkKblt7Lnu4/ooqvph4rmlL7jgIJcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uaXNEaXNwb3NlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwb3NlIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5fenIuZGlzcG9zZSgpO1xyXG5cclxuICAgICAgICBpbnN0YW5jZXNbdGhpcy5pZF0gPSBudWxsO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDosIPmlbTlsLrlr7ggIOWcqOeql+WPo+Wkp+Wwj+WPkeeUn+aUueWPmOaXtumcgOimgeaJi+W3peiwg+eUqFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIOWuveW6plxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCDpq5jluqZcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgJCh0aGlzLmdldERvbSgpKS5jc3MoXCJ3aWR0aFwiLCB3aWR0aCk7XHJcbiAgICAgICAgJCh0aGlzLmdldERvbSgpKS5jc3MoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl96ci5yZXNpemUoKTtcclxuICAgICAgICB0aGlzLl96ci5yZW1vdmUodGhpcy5ncm91cCk7XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgdGhpcy5ncmlkTGluZSgwLjIpO1xyXG4gICAgICAgIHRoaXMuX3pyLmFkZCh0aGlzLmdyb3VwKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIEBwcml2YXRlIOWIneWni+WMliAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5pbml0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0cy5zaG93R3JpZExpbmUgPT0gdHJ1ZSB8fCBvcHRzLnNob3dHcmlkTGluZSA9PSBcInRydWVcIikge1xyXG4gICAgICAgICAgICB0aGlzLmdyaWRMaW5lKDAuMik7XHJcbiAgICAgICAgICAgIHRoaXMuX3pyLmFkZCh0aGlzLmdyb3VwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vbW91c2V1cCDkvJrlnKjlkITkuKpub2Rl5oiW57q/55qE54K55Ye75LqL5Lu25LmL5YmN5omn6KGMICDlnKjpgInkuK3oioLngrnmiJbnur/liY0g5YWI5riF56m66YCJ5Lit5pWI5p6cXHJcbiAgICAgICAgdGhpcy5fenIub24oXCJtb3VzZXVwXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3BlcmF0aW9uTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fenIucmVtb3ZlKHRoaXMub3BlcmF0aW9uTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGUudGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuY29ubmVjdG9yIGluc3RhbmNlb2YgQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jbGVhclNlbGVjdENvbigpO1xyXG4gICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUub3BlcmF0aW9uICYmIHNoYXBlLm9wZXJhdGlvbiA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlci5oaWRlQWxsTGluZU9wZXJhdGlvbigpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgLy/mtL7lj5HkuI3mmK/oioLngrnmiJbnur8g55qE55S75biD54K55Ye75LqL5Lu2XHJcbiAgICAgICAgdGhpcy5fenIub24oXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBlLnRhcmdldDtcclxuICAgICAgICAgICAgLy/ngrnlh7vnmoTnur9cclxuICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLnBhcmVudCAmJiBzaGFwZS5wYXJlbnQucmVzb3VyY2VJZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJjbGlja1wiO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcGkudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vbignY29uUG9pbnRzR3JvdXA6Y2xpY2snLCBmdW5jdGlvbihhcmd1bWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmJpbmRPcGVyYXRpb24oYXJndW1lbnQubGluZU5vZGUpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7kvKDov4fmnaXnmoTlgLwgIOiuvue9ruiKgueCueaooeWei1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNoYXBlICDoioLngrnmiJbnur9cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb24g5qih5Z6L5pWw5o2uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGgg5a695bqmKOS7heeUqOS6juiwg+aVtOeUu+W4g+Wkp+WwjylcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQg6auY5bqmKOS7heeUqOS6juiwg+aVtOeUu+W4g+Wkp+WwjylcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5zZXRTaGFwZU1vZGVsID0gZnVuY3Rpb24oc2hhcGUsIG9wdGlvbiwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGlmIChCcG1uLmlzVGVtcGxhdGUoc2hhcGUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwubWVyZ2VPcHRpb24ob3B0aW9uKTtcclxuICAgICAgICAgICAgaWYgKHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoQnBtbi5pc0Zsb3coc2hhcGUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc2V0TW9kZWwoc2hhcGUsIG9wdGlvbik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2hhcGUuc2V0TW9kZWwob3B0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5riF56m65b2T5YmN5a6e5L6L77yM5Lya56e76Zmk5a6e5L6L5Lit5omA5pyJ55qE6IqC54K55LiO57q/XHJcbiAgICAgKiBAbWV0aG9kIGNsZWFyXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY2xlYXIgPSBmdW5jdGlvbihpc05vQ291bnQpIHtcclxuICAgICAgICB0aGlzLmFsbE5vZGVzID0gW107XHJcblxyXG4gICAgICAgIHRoaXMuc3ViUHJvY2Vzc05vZGUgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5kb21BcnJheSA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLm92ZXJsYXBBcnJheSA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGVkTm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZWN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl96ci5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX3pyLmFkZCh0aGlzLmdyb3VwKTsgLy8g55S7572R5qC857q/ICDku6PnoIHmlL7ov5nmr5TovoPmgbblv4Mg5ZCO6Z2i5pS5XHJcbiAgICAgICAgaWYgKGlzTm9Db3VudCAhPSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572u5piv5ZCm5pi+56S6572R57uc57q/XHJcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpc0ZvcmJpZGRlbiDmmK/lkKbmmL7npLrnvZHnu5znur9cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5mb3JiaWRHcmlkTGluZSA9IGZ1bmN0aW9uKGlzRm9yYmlkZGVuKSB7XHJcbiAgICAgICAgaWYgKGlzRm9yYmlkZGVuID09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fenIucmVtb3ZlKHRoaXMuZ3JvdXApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3pyLnJlbW92ZSh0aGlzLmdyb3VwKTtcclxuICAgICAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JpZExpbmUoMC4yKTtcclxuICAgICAgICAgICAgdGhpcy5fenIuYWRkKHRoaXMuZ3JvdXApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlr7zlh7pqc29uXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IGpzb27lrZfnrKbkuLJcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by50b0pzb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gQnBtblV0aWwudG9Kc29uKHRoaXMubW9kZWwsIHRoaXMuYWxsTm9kZXMsIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5a+85YWlanNvblxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBqc29uIGpzb27moLzlvI/nmoTlrZfnrKbkuLJcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5mcm9tSnNvbiA9IGZ1bmN0aW9uKGpzb24pIHtcclxuICAgICAgICBCcG1uVXRpbC5mcm9tSnNvbih0aGlzLCBqc29uKTtcclxuICAgIH07XHJcblxyXG4gICAgLy/og4zmma/nvZHmoLznur9cclxuICAgIGZpc2hUb3BvUHJvdG8uZ3JpZExpbmUgPSBmdW5jdGlvbihvcGFjaXR5KSB7XHJcbiAgICAgICAgdmFyIHBpeGVsID0gdGhpcy5vcHRzLmdyaWRMaW5lU3BhY2luZztcclxuICAgICAgICB2YXIgd2lkdGhMZW4gPSBwYXJzZUludCh0aGlzLmdldFdpZHRoKCkgLyBwaXhlbCk7XHJcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPD0gd2lkdGhMZW47IHgrKykge1xyXG4gICAgICAgICAgICB2YXIgbGluZVggPSBuZXcgZ3JhcGhpYy5MaW5lKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDE6IHggKiBwaXhlbCxcclxuICAgICAgICAgICAgICAgICAgICB5MTogMCxcclxuICAgICAgICAgICAgICAgICAgICB4MjogeCAqIHBpeGVsLFxyXG4gICAgICAgICAgICAgICAgICAgIHkyOiB0aGlzLmdldEhlaWdodCgpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lRGFzaDogWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB6OiAwLFxyXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChsaW5lWCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaGVpZ2h0TGVuID0gcGFyc2VJbnQodGhpcy5nZXRIZWlnaHQoKSAvIHBpeGVsLCBwaXhlbCk7XHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPD0gaGVpZ2h0TGVuOyB5KyspIHtcclxuICAgICAgICAgICAgdmFyIGxpbmVZID0gbmV3IGdyYXBoaWMuTGluZSh7XHJcbiAgICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHgxOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHkxOiB5ICogcGl4ZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgeDI6IHRoaXMuZ2V0V2lkdGgoKSxcclxuICAgICAgICAgICAgICAgICAgICB5MjogeSAqIHBpeGVsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lRGFzaDogWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB6OiAwLFxyXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChsaW5lWSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDpgJrov4fnlYzpnaLmi5bliqgg5aKe5Yqg6IqC54K5XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaXRlbVR5cGUg5Yib5bu66IqC54K555qE57G75Z6L77yI5bey5pyJ6aKE5a6a5LmJ57G75Z6L5YyF5ousU3RhcnROb25lRXZlbnTjgIFFbmROb25lRXZlbnTjgIFVc2VyVGFza+OAgU1hbnVhbFRhc2vjgIFTY3JpcHRUYXNr44CBTWFpbFRhc2vjgIFDYXRjaFRpbWVyRXZlbnTjgIFDYXRjaFNpZ25hbEV2ZW5044CBVGhyb3dTaWduYWxFdmVudOOAgUluY2x1c2l2ZUdhdGV3YXnjgIFFeGNsdXNpdmVHYXRld2F544CBUGFyYWxsZWxHYXRld2F544CBU3ViUHJvY2Vzc++8iVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggICAgICAgIOiKgueCueWIm+W7uueahHjlnZDmoIdcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgICAgICDoioLngrnliJvlu7rnmoR55Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyDpgInpoblcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5uYW1lXSDoioLngrnkuIvpnaLmmL7npLrlkI3np7BcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm9wZXJhdGlvbkljb25zXSDorr7nva7pgInkuK3oioLngrnml7Yg5pi+56S655qE5pON5L2c5bCP5Zu+5qCH77yMIOm7mOiupOaPkOS+m+S6hiDliKDpmaTjgIHnm7Tnur/jgIHmipjnur/jgIHmm7Lnur8056eN5Zu+5qCH77yM5Lmf5Y+v5Lul6Ieq5a6a5Zu+5qCHIGVnLlxyXG4gICAgICogPHByZT5cclxuICAgICAqICAgICAgICAgIG9wZXJhdGlvbkljb25zOiBbeyBuYW1lOiAnREVMJyB9LFxyXG4gICAgICogICAgICAgICAgICAgIHsgbmFtZTogJ1NUUkFJR0hUJyB9LFxyXG4gICAgICogICAgICAgICAgICAgIHsgbmFtZTogJ0pBR0dFRCcgfSxcclxuICAgICAqICAgICAgICAgICAgICB7IG5hbWU6ICdDVVJWRScgfSxcclxuICAgICAqICAgICAgICAgICAgICB7XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiY3VzdG9tMVwiLFxyXG4gICAgICogICAgICAgICAgICAgICAgICBpY29uUGF0aDogXCJpbWcvaG9zdC5wbmdcIixcclxuICAgICAqICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKGUpIHsgYWxlcnQoZS5kYXRhLm5hbWUgKyBcIiBjbGlja2VkXCIpIH0gIC8vZS5ub2Rl5piv5b2T5YmN55qE6IqC54K5XHJcbiAgICAgKiAgICAgICAgICAgICAgfVxyXG4gICAgICogICAgICAgICAgXVxyXG4gICAgICogPC9wcmU+XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlckRhdGEg55So5oi35Lyg6YCS55qE5Lia5Yqh5pWw5o2uXHJcbiAgICAgKlxyXG4gICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICpcclxuICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICAgZmlzaFRvcG8uYWRkTm9kZShpdGVtVHlwZSwgeCwgeSwge1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgbmFtZTogaXRlbVR5cGUsICAgLy/oioLngrnnmoTlkI3np7BcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbkljb25zOlt7bmFtZTonREVMJ30seyBuYW1lOiAnU1RSQUlHSFQnIH0se25hbWU6J0pBR0dFRCd9LHsgbmFtZTogJ0NVUlZFJyB9XSxcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIC8vIOWinuWKoOiKgueCueaTjeS9nOWbvuaghyDkuIrpnaLliIbliKvmmK9cIuWIoOmZpOOAgeebtOe6v+OAgeaKmOe6v+OAgeabsue6v1wi77yMXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAvLyDkuZ/lj6/ku6Xlop7liqDoh6rlrprlm77moIcg5aaCe25hbWU6IFwiY3VzdG9tMVwiLCBpY29uUGF0aDogXCJpbWcvaG9zdC5wbmdcIiwgY2FsbGJhY2s6IGZ1bmN0aW9uKGUpIHsgYWxlcnQoZS5kYXRhLm5hbWUgKyBcIiBjbGlja2VkXCIpIH19IC8vZS5ub2Rl5piv5b2T5YmN55qE6IqC54K5XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICB1c2VyRGF0YTp7YnVzaW5lc3NEYXRhOifmiJHmmK/kuJrliqHmlbDmja4s6YCa6L+HQnBtbi5nZXRVc2VyRGF0YeWPr+iOt+WPlid9XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAvLyDlop7liqDoioLngrnnmoToh6rlrprkuYnkuJrliqHvvIzlj6/ku6XpgJrov4dCcG1uLmdldFVzZXJEYXRhKG5vZGUp6I635Y+WXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZE5vZGUgPSBmdW5jdGlvbihpdGVtVHlwZSwgeCwgeSwgb3B0aW9ucykge1xyXG5cclxuICAgICAgICAvL+WIpOaWreaYr+WQpuWcqOiMg+WbtOWGhVxyXG4gICAgICAgIGlmICh4ID49IDAgJiYgeSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IG5ldyBCUE1OTW9kZWwoe30pO1xyXG4gICAgICAgICAgICBtb2RlbC5zZXQoQnBtbi5CUE1OX1RZUEUsIGl0ZW1UeXBlKTtcclxuICAgICAgICAgICAgbW9kZWwuc2V0KFwiYm91bmRzLnVwcGVyTGVmdFwiLCB7eDogeCwgeTogeX0pO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgbW9kZWwuc2V0KFwicHJvcGVydGllc1wiLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUJ5TW9kZWwobW9kZWwsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7mqKHlnovlop7liqDoioLngrlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSDliJvlu7rlrozmiJDnmoToioLngrlcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5hZGROb2RlQnlNb2RlbCA9IGZ1bmN0aW9uKG1vZGVsLCBpc0Zyb21EcmFnLCBpc05vQ291bnQpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIFNoYXBlID0gQlBNTk5vZGUuZ2V0Q2xhc3MobW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKSk7XHJcbiAgICAgICAgdmFyIG1lc0FycmF5O1xyXG4gICAgICAgIGlmIChTaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyBTaGFwZShtb2RlbCwgdGhpcy5fYXBpKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3ViUHJvY2Vzc05vZGUubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3pyLmFkZChub2RlKTtcclxuICAgICAgICAgICAgICAgIG1lc0FycmF5ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbbm9kZS5nZXRSZWN0KCkueCwgbm9kZS5nZXRSZWN0KCkueV0sXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG5vZGUuZ2V0UmVjdCgpLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogbm9kZS5nZXRSZWN0KCkuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFCcG1uLmlzU2xvdEV2ZW50KG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdmVybGFwQXJyYXkucHVzaChtZXNBcnJheSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fenIuYWRkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbWVzQXJyYXkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFtub2RlLmdldFJlY3QoKS54LCBub2RlLmdldFJlY3QoKS55XSxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbm9kZS5nZXRSZWN0KCkud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmdldFJlY3QoKS5oZWlnaHRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoIUJwbW4uaXNTbG90RXZlbnQobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm92ZXJsYXBBcnJheS5wdXNoKG1lc0FycmF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0Zyb21EcmFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8xLuWIpOaWreaJgOacieeahOWtkOiKgueCuVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJQcm9jZXNzTm9kZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLzIu5aaC5p6c6IqC54K55ouW5pS+5ZyoIOWtkOiKgueCueS4rVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJQcm9jZXNzTm9kZVtpXS5yZWN0Q29udGFpbihub2RlLmdldFJlY3QoKS54LCBub2RlLmdldFJlY3QoKS55KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8yLjHph43mlrDorqHnrpfoioLngrnlnKgg5a2Q6IqC54K55Lit55qE5L2N572uICDlubbliqDlhaXliLDlrZDoioLngrlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cE5vZGVQb3NpdGlvblggPSB0aGlzLnN1YlByb2Nlc3NOb2RlW2ldLmdldFJlY3QoKS53aWR0aCAvIDIgKyAobm9kZS5nZXRSZWN0KCkueCAtIHRoaXMuc3ViUHJvY2Vzc05vZGVbaV0uZ2V0UmVjdCgpLngpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwTm9kZVBvc2l0aW9uWSA9IHRoaXMuc3ViUHJvY2Vzc05vZGVbaV0uZ2V0UmVjdCgpLmhlaWdodCAvIDIgKyAobm9kZS5nZXRSZWN0KCkueSAtIHRoaXMuc3ViUHJvY2Vzc05vZGVbaV0uZ2V0UmVjdCgpLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRQb3NpdGlvbihncm91cE5vZGVQb3NpdGlvblgsIGdyb3VwTm9kZVBvc2l0aW9uWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YlByb2Nlc3NOb2RlW2ldLmFkZChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vMi4y5LuOenLkuK3liKDpmaRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3pyLnJlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vMi4z5LuOIOiKgueCueS9jee9riDkv6Hmga/mlbDnu4TkuK3liKDpmaTmraToioLngrlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhhdC5vdmVybGFwQXJyYXkubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PSB0aGF0Lm92ZXJsYXBBcnJheVtqXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm92ZXJsYXBBcnJheS5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vMi7lpoLmnpzmmK/lrZDoioLngrkg5YiZ5Yqg5YWl5Yiw5a2Q6IqC54K55pWw57uE5LitXHJcbiAgICAgICAgICAgIGlmIChCcG1uLmlzU3ViUHJvY2Vzcyhub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdWJQcm9jZXNzTm9kZS5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWxsTm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICAgICAgLy/mlL7lhaXoioLngrnkvY3nva7kv6Hmga8g55So5LqO5ouW5ou9XHJcbiAgICAgICAgICAgIHRoaXMuZG9tQXJyYXkucHVzaChtZXNBcnJheSk7XHJcblxyXG4gICAgICAgICAgICAvL+S+puWQrOiKgueCueeahOS6i+S7tiDlubbmiorkuovku7bnu5nlj5bmtojmjokg6Ziy5q2iIOWmguaenOeItuaYr+WtkOiKgueCueS+puWQrOWIsFxyXG4gICAgICAgICAgICBub2RlLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5mb3JiaWRFZGl0ID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm5ld0RyYWcodGhpcywgZS5ldmVudC5jbGllbnRYLCBlLmV2ZW50LmNsaWVudFkpO1xyXG4gICAgICAgICAgICAgICAgLy/lpoLmnpzpgInmi6nnmoTmmK/kuovku7boioLngrnvvIzliJnkuLrlhbbku5Z0YXNr57uR5a6a5o+S5qe9XHJcbiAgICAgICAgICAgICAgICBpZiAoQnBtbi5pc1Nsb3RFdmVudCh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYmluZEV2ZW50Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbm9kZS5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhhdC5ub2RlQ2xpY2tIYW5kbGVyKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8v5re75YqgdGlwXHJcbiAgICAgICAgICAgIGlmIChCcG1uLmlzQWN0aXZpdHkobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuY3JlYXRUaXAobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG5vZGUub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGFybSAmJiB0aGlzLmFsYXJtLmlzU2hvdyA9PSB0cnVlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxhcm0uc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxhcm0uZWFjaENoaWxkKGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAvL+agueaNruWtl+WGheWuueabtOaUuXRpcOWkluahhueahOWkp+Wwj1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5hbGFybS5jaGlsZE9mTmFtZShcIlRleHRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwV2lkdGggPSB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLndpZHRoICsgNDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBIZWlnaHQgPSB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCArIDg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgWzAsIDBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbZ3JvdXBXaWR0aCwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLCBncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtncm91cFdpZHRoIC8gMiAtIDMsIGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW2dyb3VwV2lkdGggLyAyLCBncm91cEhlaWdodCArIDNdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbZ3JvdXBXaWR0aCAvIDIgKyAzLCBncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFswLCBncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFswLCAwXVxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIFBvbHlsaW5lID0gdGhpcy5hbGFybS5jaGlsZE9mTmFtZShcIlBvbHlsaW5lXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIFBvbHlsaW5lLmF0dHIoXCJzaGFwZVwiLCB7cG9pbnRzOiBwb2ludHN9KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvbiA9IFtub2RlLnBvc2l0aW9uWzBdICsgbm9kZS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAtIHRoaXMuYWxhcm0uZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLyAyLCBub2RlLnBvc2l0aW9uWzFdIC0gdGhpcy5hbGFybS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLSAzXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsYXJtLmF0dHIoXCJwb3NpdGlvblwiLCBncm91cFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG5vZGUub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFsYXJtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGFybS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGFybS5lYWNoQ2hpbGQoZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckNyZWF0ZUV2ZW50KG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoaXNOb0NvdW50ICE9IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2ubmFtZeiOt+WPluiKgueCuVxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIOWcqOWIm+W7uuiKgueCueS4rSAgbmFtZeWxnuaAp+iuvue9rueahOWAvFxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgIG5hbWXlr7nlupTnmoToioLngrlcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5jaGlsZE9mTmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICB2YXIgYXJyUmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbE5vZGVzW2ldLm1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSA9PSBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJSZXN1bHQucHVzaCh0aGlzLmFsbE5vZGVzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJyUmVzdWx0Lmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyclJlc3VsdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyUmVzdWx0WzBdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmn6Xmib7lnLrmma/kuK3nmoTlr7nosaEgICDkvovlpoI6IHjlnZDmoIflpKfkuo4xMDDnmoToioLngrkgZmluZEVsZW1lbnRzKGZ1bmN0aW9uKGUpeyByZXR1cm4gZS5wb3NpdGlvblswXSA+IDEwMDsgfSk7XHJcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2IgICAgICDlm57osIPlh73mlbBcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gICBjb250ZXh0IOWbnuiwg+WHveaVsOaJp+ihjOeahOS4iuS4i+aWh1xyXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICDov5Tlm57mn6Xmib7liLDnmoTlr7nosaFcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5maW5kRWxlbWVudHMgPSBmdW5jdGlvbihjYiwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBjaGlsZHJlbk5vZGUgPSB0aGlzLmFsbE5vZGVzO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbkxpbmUgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvcnM7XHJcbiAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5Ob2RlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuTm9kZVtpXTtcclxuICAgICAgICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgY2hpbGQsIGkpKSB7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZHJlbkxpbmUubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkTGluZSA9IGNoaWxkcmVuTGluZVtqXTtcclxuICAgICAgICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgY2hpbGRMaW5lLCBqKSkge1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2goY2hpbGRMaW5lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiDmoLnmja7mqKHlnovlop7liqDnur9cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5hZGRDb25uZWN0b3JCeU1vZGVsID0gZnVuY3Rpb24obW9kZWwsIHBhcmVudFpyKSB7XHJcbiAgICAgICAgLy/mib7lh7ogc3RhcnROb2RlIOS4jiBlbmROb2RlXHJcbiAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IG51bGwsXHJcbiAgICAgICAgICAgIGVuZE5vZGUgPSBudWxsO1xyXG4gICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuYWxsTm9kZXMsIGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgLy9zdGFydE5vZGU6IOS7jmFsbE5vZGXkuK3mib7lh7pvdXRnb2luZ+S4uiDnur/nmoRpZOeahOi1t+Wni+iKgueCuVxyXG4gICAgICAgICAgICB2YXIgbm9kZU91dGdvaW5nID0gbm9kZS5tb2RlbC5nZXQoXCJvdXRnb2luZ1wiKTtcclxuICAgICAgICAgICAgaWYgKG5vZGVPdXRnb2luZy5pbmRleE9mKG1vZGVsLmdldChcInJlc291cmNlSWRcIikpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnROb2RlID0gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2VuZE5vZGUgOiDku45hbGxOb2Rl5Lit5om+5Ye6IGlkIOS4uue6v+eahG91dGdvaW5n55qE57uT5p2f6IqC54K5XHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3JPdXRnb2luZyA9IG1vZGVsLmdldChcIm91dGdvaW5nXCIpO1xyXG4gICAgICAgICAgICBpZiAoY29ubmVjdG9yT3V0Z29pbmcuaW5kZXhPZihub2RlLnJlc291cmNlSWQpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgZW5kTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoc3RhcnROb2RlICYmIGVuZE5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9yQ3JlYXRlQnlPcHRpb25zKHN0YXJ0Tm9kZSwgZW5kTm9kZSwge21vZGVsOiBtb2RlbCxpc0Zyb21Nb2RlbDp0cnVlfSwgdGhpcy5fYXBpKTtcclxuICAgICAgICAgICAgaWYgKHBhcmVudFpyKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRaci5hZGQoY29ubmVjdG9yKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl96ci5hZGQoY29ubmVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25uZWN0b3Iub24oXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RvckZvcmJpZEVkaXQodGhhdC5mb3JiaWRFZGl0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGluZU9wZXJhdGlvbk1hbmFnZXIuaXNFZGl0ID0gIXRoaXMuZm9yYmlkRWRpdDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNOb2RlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rov57nur/nmoTlsI/lm77moIfmk43kvZxcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkg5bCP5Zu+5qCH55qE5ZCN56ewXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIOWwj+Wbvuagh+eahOebuOWFs+WPguaVsFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMg5bCP5Zu+5qCH6YCJ6aG5XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaWNvbl0g5bCP5Zu+5qCH6Lev5b6EXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGluZU5vZGVdIOe6v+auteWunuS+i1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdIOeCueWHu+WQjueahOWbnuiwg1xyXG4gICAgICpcclxuICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgIGZpc2hUb3BvQnBtbi5hZGRJY29uKFwiaWNvbjFcIix7ICAvL+e6v+S4iuWbvuagh+eahOWQjeensFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIGljb246XCJicG1uMi4wL2ljb25zL2FjdGl2aXR5L2xpc3QvbWFpbC5zZW5kLnBuZ1wiLCAvL+e6v+S4iuWbvuagh+eahOi3r+W+hFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBsaW5lTm9kZTpsaW5lTm9kZSwgIC8v57q/XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOmZ1bmN0aW9uKGxpbmVOb2RlKXsgIC8v5Zue6LCDXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoSlNPTi5zdHJpbmdpZnkobGluZU5vZGUpKVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgICAgICAgICAgfSk7KlxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZEljb24gPSBmdW5jdGlvbihrZXksIG9iaikge1xyXG4gICAgICAgIHRoaXMubGluZU9wZXJhdGlvbk1hbmFnZXIuYWRkSWNvbihrZXksIG9iaiwgdGhpcy5fenIsIHRoaXMuX2FwaSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66L+e57q/55qE6buY6K6k5Yig6Zmk5pON5L2cXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGxpbmVOb2RlIOe6v1xyXG4gICAgICpcclxuICAgICAqICAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICBmaXNoVG9wb0JwbW4uYmluZExpbmVEZWxldGUobGluZU5vZGUpO1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmJpbmRMaW5lRGVsZXRlID0gZnVuY3Rpb24obGluZU5vZGUpIHtcclxuICAgICAgICB2YXIgcGFyZW50WnIgPSB0aGlzLl96cjs7XHJcbiAgICAgICAgaWYgKGxpbmVOb2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICBwYXJlbnRaciA9IGxpbmVOb2RlLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/liJvlu7rliKDpmaRcclxuICAgICAgICB2YXIgbGluZU9wZXJhdGlvbiA9IHRoaXMubGluZU9wZXJhdGlvbk1hbmFnZXIuYWRkSWNvbihcImRlbGV0ZVwiLCB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmRlbGV0ZUljb25PYmoocGFyZW50WnIsIGxpbmVOb2RlKSwgcGFyZW50WnIsIHRoaXMuX2FwaSk7XHJcbiAgICAgICAgaWYgKGxpbmVPcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgbGluZU9wZXJhdGlvbi5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckRlbGV0ZUV2ZW50KGxpbmVOb2RlKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog6L+U5ZueIOi/nuWQkeivpeiKgueCueeahOiKgueCueaVsOe7hO+8mm5vZGVBcnJheVswXSAg5Lul5Y+K6K+l6IqC54K56L+e5ZCR55qE6IqC54K55pWw57uEIG5vZGVBcnJheVswXVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNoZWNrTGluZU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0QXJyYXkgPSBbXSxcclxuICAgICAgICAgICAgZW5kQXJyYXkgPSBbXTtcclxuICAgICAgICB2YXIgbGluZUFycmF5ID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGxpbmVBcnJheVtpXS5zdGFydE5vZGUgPT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgZW5kQXJyYXkucHVzaChsaW5lQXJyYXlbaV0uZW5kTm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbkVuZCA9IGxpbmVBcnJheS5sZW5ndGg7IGogPCBsZW5FbmQ7IGorKykge1xyXG4gICAgICAgICAgICBpZiAobGluZUFycmF5W2pdLmVuZE5vZGUgPT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRBcnJheS5wdXNoKGxpbmVBcnJheVtqXS5zdGFydE5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbc3RhcnRBcnJheSwgZW5kQXJyYXldO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOWIneWni+WMliDmk43kvZznmoTomZrnur/moYZcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5pbml0T3BlcmF0aW9uTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlID0gbmV3IE9wZXJhdGlvbk5vZGUobm9kZSwgdGhhdC5fenIsIHRoaXMuZm9yYmlkRWRpdCk7XHJcbiAgICAgICAgLy8g5L6m5ZCsIOeureWktCDmi5bmi73lvIDlp4vkuovku7ZcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHU1RBUlQsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBlLmV2ZW50Lm9mZnNldFg7XHJcbiAgICAgICAgICAgIHZhciB5ID0gZS5ldmVudC5vZmZzZXRZO1xyXG4gICAgICAgICAgICAvL+aLluaLveW8gOWni+WFiOaKiiDnrq3lpLTlm77moIcg57uZ6ZqQ6JePXHJcbiAgICAgICAgICAgIHZhciBhcnJvdyA9IGUuZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICBhcnJvdy5oaWRlKCk7XHJcbiAgICAgICAgICAgIHZhciByRW5kUG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XHJcbiAgICAgICAgICAgIGlmICh0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3ModGhhdC5zZWxlY3RlZE5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YlByb2Nlc3NOb2RlID0gdGhhdC5zZWxlY3RlZE5vZGUucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgckVuZFBvaW50ID0gbmV3IFBvaW50KHggLSBzdWJQcm9jZXNzTm9kZS5wb3NpdGlvblswXSwgeSAtIHN1YlByb2Nlc3NOb2RlLnBvc2l0aW9uWzFdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IHRoYXQuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlVGVtcENvbm5lY3Rvcih0aGF0LnNlbGVjdGVkTm9kZSwgckVuZFBvaW50LCBhcnJvdy5saW5lVHlwZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3ModGhhdC5zZWxlY3RlZE5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RlZE5vZGUucGFyZW50LmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fenIuYWRkKGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8g5L6m5ZCsIOeureWktCDmi5bmi73kuovku7ZcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gZS5ldmVudC5vZmZzZXRYO1xyXG4gICAgICAgICAgICB2YXIgeSA9IGUuZXZlbnQub2Zmc2V0WTtcclxuICAgICAgICAgICAgdmFyIHJFbmRQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcclxuICAgICAgICAgICAgdmFyIGFycm93ID0gZS5ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgIGlmICh0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3ModGhhdC5zZWxlY3RlZE5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YlByb2Nlc3NOb2RlID0gdGhhdC5zZWxlY3RlZE5vZGUucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgckVuZFBvaW50ID0gbmV3IFBvaW50KHggLSBzdWJQcm9jZXNzTm9kZS5wb3NpdGlvblswXSwgeSAtIHN1YlByb2Nlc3NOb2RlLnBvc2l0aW9uWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLm1hbmFnZVRlbXBDb25uZWN0b3IodGhhdC5zZWxlY3RlZE5vZGUsIHJFbmRQb2ludCwgYXJyb3cubGluZVR5cGUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvL+S+puWQrCDnrq3lpLQg5ouW5ou957uT5p2f5LqL5Lu2IOeUu+e6v1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZS5vbihPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUdFTkQsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBlLmV2ZW50Lm9mZnNldFg7XHJcbiAgICAgICAgICAgIHZhciB5ID0gZS5ldmVudC5vZmZzZXRZO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgIC8v5ouW5ou957uT5p2f5YWI5oqKIOeureWktOWbvuaghyDnu5nmmL7npLpcclxuICAgICAgICAgICAgdmFyIGFycm93ID0gZS5ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgIGFycm93LnNob3coKTtcclxuXHJcbiAgICAgICAgICAgIC8vMS7lpoLmnpzmmK/lrZDoioLngrkg5YaFIOiKgueCueaLluaLvSDliJkg5aKe5Yqg5o6S6Zmk5a2Q6IqC54K555qE5Y+C5pWwXHJcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKEJwbW4uaXNTdWJQcm9jZXNzKG5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8v5Yig6Zmk5Li05pe257q/XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5yZW1vdmVUZW1wQ29ubmVjdG9yKG5vZGUucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gQnBtblV0aWwuZmluZEhvdmVyKHRoYXQuYWxsTm9kZXMsIHgsIHksIHRoYXQuc3ViUHJvY2Vzc05vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IEJwbW5VdGlsLmZpbmRIb3Zlcih0aGF0LmFsbE5vZGVzLCB4LCB5KTtcclxuICAgICAgICAgICAgICAgIC8v5Yig6Zmk5Li05pe257q/XHJcbiAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlbW92ZVRlbXBDb25uZWN0b3IodGhhdC5fenIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vMi7lpoLmnpzmib7liLDnm67moIfnu5Pngrkg5YiZ55S757q/XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXROb2RlICYmICh0aGF0LnNlbGVjdGVkTm9kZSAhPSB0YXJnZXROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fY3JlYXRlQ29ubmVjdG9yQnlOb2Rlcyh0aGF0LnNlbGVjdGVkTm9kZSwgdGFyZ2V0Tm9kZSwgYXJyb3cubGluZVR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzaGFwZVJlY3QgPSB0aGF0LnNlbGVjdGVkTm9kZS5nZXRSZWN0KCk7XHJcbiAgICAgICAgICAgIHRoYXQub3BlcmF0aW9uTm9kZS5yZW5kZXIobm9kZSwgdGhhdC5fenIsIHNoYXBlUmVjdCk7XHJcbiAgICAgICAgICAgIHRoYXQuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvL+WIoOmZpOaMiemSrueCueWHu+S6i+S7tlxyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZS5vbihcIk9wZXJhdGlvbk5vZGU6ZGVsZXRlQ2xpY2tcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoYXQuX3RyaWdnZXJEZWxldGVFdmVudCh0aGF0LnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgIHRoYXQucmVtb3ZlTm9kZSh0aGF0LnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgIHRoYXQuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvL+aUvuWkp+e8qeWwj+aLluWKqOi/h+eoi1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZS5vbihcIk9wZXJhdGlvbk5vZGU6c2NhbGVEcmFnTGVmdFwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbFJlY3Quc2V0U2hhcGUoe3BvaW50czogZS5wb2ludHN9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oXCJPcGVyYXRpb25Ob2RlOnNjYWxlRHJhZ1JpZ2h0XCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsUmVjdC5zZXRTaGFwZSh7cG9pbnRzOiBlLnBvaW50c30pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8v5pS+5aSn57yp5bCP5ouW5Yqo57uT5p2fXHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlLm9uKFwiT3BlcmF0aW9uTm9kZTpzY2FsZURyYWdFbmRcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAvLzEu6L+b6KGM6IqC54K55aSn5bCP55qE6K6+572u77yM5bm257u05oqk5L2N572u5L+h5oGv5pWw57uEXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpcnR1YWxSZWN0LnNoYXBlLnBvaW50cyB8fCB0aGlzLnZpcnR1YWxSZWN0LnNoYXBlLnBvaW50cyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLnZpcnR1YWxSZWN0LnNoYXBlLnBvaW50c1sxXVswXSAtIHRoaXMudmlydHVhbFJlY3Quc2hhcGUucG9pbnRzWzBdWzBdIC0gMTtcclxuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLnZpcnR1YWxSZWN0LnNoYXBlLnBvaW50c1syXVsxXSAtIHRoaXMudmlydHVhbFJlY3Quc2hhcGUucG9pbnRzWzFdWzFdIC0gMTtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmIChlLmFycm93TmFtZSA9PSBcImxlZnRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gW3RoYXQuc2VsZWN0ZWROb2RlLnBvc2l0aW9uWzBdIC0gKHdpZHRoICsgMSAtIHRoYXQuc2VsZWN0ZWROb2RlLmdldFJlY3QoKS53aWR0aCksIHRoYXQuc2VsZWN0ZWROb2RlLnBvc2l0aW9uWzFdIC0gKGhlaWdodCArIDEgLSB0aGF0LnNlbGVjdGVkTm9kZS5nZXRSZWN0KCkuaGVpZ2h0KV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5hcnJvd05hbWUgPT0gXCJyaWdodFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBbdGhhdC5zZWxlY3RlZE5vZGUucG9zaXRpb25bMF0sIHRoYXQuc2VsZWN0ZWROb2RlLnBvc2l0aW9uWzFdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0ZWROb2RlLnJlZnJlc2goe3NoYXBlOiB7d2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodH19KTtcclxuICAgICAgICAgICAgICAgIHZhciBpc0NoYW5nZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0ICsgMSA8IHRoYXQuc2VsZWN0ZWROb2RlLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0ZWROb2RlLnJlZnJlc2goe3NoYXBlOiB7aGVpZ2h0OiB0aGF0LnNlbGVjdGVkTm9kZS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHR9fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNDaGFuZ2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCArIDEgPCB0aGF0LnNlbGVjdGVkTm9kZS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0ZWROb2RlLnJlZnJlc2goe3NoYXBlOiB7d2lkdGg6IHRoYXQuc2VsZWN0ZWROb2RlLmdldEJvdW5kaW5nUmVjdCgpLndpZHRofX0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQ2hhbmdlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGFuZ2UgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0ZWROb2RlLnJlZnJlc2goe3Bvc2l0aW9uOiBwb3NpdGlvbn0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCB0aGF0LmRvbUFycmF5Lmxlbmd0aDsgbSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0ZWROb2RlLmlkID09IHRoYXQuZG9tQXJyYXlbbV0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5kb21BcnJheVttXS5wb3NpdGlvbiA9IFtwb3NpdGlvblswXSArICh3aWR0aCArIDEpIC8gMiwgcG9zaXRpb25bMV0gKyAoaGVpZ2h0ICsgMSkgLyAyXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm5vZGVDbGlja0hhbmRsZXIodGhhdC5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0aGF0Lm92ZXJsYXBBcnJheS5sZW5ndGg7IG4rKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnNlbGVjdGVkTm9kZS5pZCA9PSB0aGF0Lm92ZXJsYXBBcnJheVtuXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm92ZXJsYXBBcnJheVtuXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0aGF0LnNlbGVjdGVkTm9kZS5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbdGhhdC5zZWxlY3RlZE5vZGUuZ2V0UmVjdCgpLngsIHRoYXQuc2VsZWN0ZWROb2RlLmdldFJlY3QoKS55XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGF0LnNlbGVjdGVkTm9kZS5nZXRSZWN0KCkud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoYXQuc2VsZWN0ZWROb2RlLmdldFJlY3QoKS5oZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8yLuWIt+aWsOe6v1xyXG4gICAgICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKHRoYXQuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICAgdmFyIGVuZFNsb3RQb2ludHMgPSB1dGlsLmdldFNvbHRQb2ludHModGhhdC5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgICBpZiAodGhhdC5zZWxlY3RlZE5vZGUuc2xvdEV2ZW50ICYmIHRoYXQuc2VsZWN0ZWROb2RlLnNsb3RFdmVudC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXQuc2VsZWN0ZWROb2RlLnNsb3RFdmVudC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbG90Tm9kZSA9IHRoYXQuc2VsZWN0ZWROb2RlLnNsb3RFdmVudFtpXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGUuc3RhcnRTbG90UG9pbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnNlbGVjdGVkTm9kZS5zbG90RXZlbnRbaV0ucG9zaXRpb25bMF0gLSBlLnN0YXJ0UG9zaXRpb25bMF0gPT0gZS5zdGFydFNsb3RQb2ludHNbal1bMF0gJiYgdGhhdC5zZWxlY3RlZE5vZGUuc2xvdEV2ZW50W2ldLnBvc2l0aW9uWzFdIC0gZS5zdGFydFBvc2l0aW9uWzFdID09IGUuc3RhcnRTbG90UG9pbnRzW2pdWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbGVjdGVkTm9kZS5zbG90RXZlbnRbaV0uYXR0cihcInBvc2l0aW9uXCIsIFtlbmRTbG90UG9pbnRzW2pdWzBdICsgdGhhdC5zZWxlY3RlZE5vZGUucG9zaXRpb25bMF0sIGVuZFNsb3RQb2ludHNbal1bMV0gKyB0aGF0LnNlbGVjdGVkTm9kZS5wb3NpdGlvblsxXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZSh0aGF0LnNlbGVjdGVkTm9kZS5zbG90RXZlbnRbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoYXQuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl96ci5hZGQodGhpcy5vcGVyYXRpb25Ob2RlKTtcclxuXHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOenu+mZpOWcuuaZr+S4reeahOafkOS4quiKgueCuVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzZWxlY3RlZE5vZGUg5b6F5Yig6Zmk55qE6IqC54K5XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8ucmVtb3ZlTm9kZSA9IGZ1bmN0aW9uKHNlbGVjdGVkTm9kZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAvLzEu5aaC5p6c5piv5a2Q6IqC54K5IOWGhSDoioLngrkgIOWImSDosIPnlKjlrZDoioLngrnnmoTliKDpmaRcclxuICAgICAgICB2YXIgcGFyZW50WnI7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkTm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50WnIgPSBzZWxlY3RlZE5vZGUucGFyZW50O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBhcmVudFpyID0gdGhhdC5fenI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmVudFpyLnJlbW92ZShzZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgIC8vMi7ku45hbGxOb2Rlc+aVsOe7hOS4reWIoOmZpFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdC5hbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlLmlkID09IHRoYXQuYWxsTm9kZXNbaV0uaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuYWxsTm9kZXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhhdC5kb21BcnJheS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlLmlkID09IHRoYXQuZG9tQXJyYXlbal0uaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuZG9tQXJyYXkuc3BsaWNlKGosIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhhdC5vdmVybGFwQXJyYXkubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZS5pZCA9PSB0aGF0Lm92ZXJsYXBBcnJheVtrXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5vdmVybGFwQXJyYXkuc3BsaWNlKGssIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vMy7lsIbmraToioLngrnkuqTogZTnmoTnur/kuZ/liKDpmaRcclxuICAgICAgICB0aGF0LmNvbm5lY3Rpb25NYW5hZ2VyLmRlbGV0ZVNlbGVjdENvbihzZWxlY3RlZE5vZGUsIHBhcmVudFpyKTtcclxuICAgICAgICAvL+WmguaenOWIoOmZpOiKgueCueaYr3Rhc2voioLngrnvvIzpnIDopoHlsIbkvp3pmYTlroPnmoTkuovku7boioLngrnliKDpmaRcclxuICAgICAgICBpZiAoQnBtbi5pc0FjdGl2aXR5KHNlbGVjdGVkTm9kZSkgfHwgQnBtbi5pc1N1YlByb2Nlc3Moc2VsZWN0ZWROb2RlKSkge1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlLnNsb3RFdmVudCAmJiBzZWxlY3RlZE5vZGUuc2xvdEV2ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgc2VsZWN0ZWROb2RlLnNsb3RFdmVudC5sZW5ndGg7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGUuc2xvdEV2ZW50W21dLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQnBtbi5pc1N1YlByb2Nlc3Moc2VsZWN0ZWROb2RlLnNsb3RFdmVudFttXS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE5vZGUuc2xvdEV2ZW50W21dLnBhcmVudC5yZW1vdmUoc2VsZWN0ZWROb2RlLnNsb3RFdmVudFttXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll96ci5yZW1vdmUoc2VsZWN0ZWROb2RlLnNsb3RFdmVudFttXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdGhhdC5hbGxOb2Rlcy5sZW5ndGg7IG4rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlLnNsb3RFdmVudFttXS5pZCA9PSB0aGF0LmFsbE5vZGVzW25dLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFsbE5vZGVzLnNwbGljZShuLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHRoYXQuZG9tQXJyYXkubGVuZ3RoOyBhKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZS5zbG90RXZlbnRbbV0uaWQgPT0gdGhhdC5kb21BcnJheVthXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5kb21BcnJheS5zcGxpY2UoYSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy80LuWmguaenOWIoOmZpOeahOaYr+S6i+S7tuiKgueCue+8jOmcgOimgeWwhue7keWumuWug+eahHRhc2voioLngrnnmoTmoIfor4bliKDpmaRcclxuICAgICAgICBpZiAoQnBtbi5pc1Nsb3RFdmVudChzZWxlY3RlZE5vZGUpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgdGhhdC5hbGxOb2Rlcy5sZW5ndGg7IGIrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuYWxsTm9kZXNbYl0uaXNDYW5TbG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuYWxsTm9kZXNbYl0uc2xvdEV2ZW50ICYmIHRoYXQuYWxsTm9kZXNbYl0uc2xvdEV2ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB0aGF0LmFsbE5vZGVzW2JdLnNsb3RFdmVudC5sZW5ndGg7IGMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZS5pZCA9PSB0aGF0LmFsbE5vZGVzW2JdLnNsb3RFdmVudFtjXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWxsTm9kZXNbYl0uc2xvdEV2ZW50LnNwbGljZShjLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0ZXBDb3VudGVyKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uX2NyZWF0ZUNvbm5lY3RvckJ5Tm9kZXMgPSBmdW5jdGlvbihzdGFydE5vZGUsIGVuZE5vZGUsIGxpbmVUeXBlKSB7XHJcbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9yQ3JlYXRlKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgbGluZVR5cGUsIHRoaXMuX2FwaSk7XHJcbiAgICAgICAgaWYgKHN0YXJ0Tm9kZS5wYXJlbnQgJiYgZW5kTm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgZW5kTm9kZS5wYXJlbnQuYWRkKGNvbm5lY3Rvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fenIuYWRkKGNvbm5lY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbm5lY3Rvci5vbihcIm1vdXNlZG93blwiLCB6clV0aWwuYmluZChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JGb3JiaWRFZGl0KHRoaXMuZm9yYmlkRWRpdCk7XHJcbiAgICAgICAgICAgIHRoaXMubGluZU9wZXJhdGlvbk1hbmFnZXIuaXNFZGl0ID0gIXRoaXMuZm9yYmlkRWRpdDtcclxuICAgICAgICAgICAgdGhpcy5pc05vZGUgPSBmYWxzZTtcclxuICAgICAgICB9LCB0aGlzKSk7XHJcblxyXG4gICAgICAgIHRoaXMuX3RyaWdnZXJDcmVhdGVFdmVudChjb25uZWN0b3IpO1xyXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XHJcbiAgICB9O1xyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uX3RyaWdnZXJEZWxldGVFdmVudCA9IGZ1bmN0aW9uKHRhcmdldCkge1xyXG4gICAgICAgIHZhciBldmVudFBhcmFtcyA9IHt9O1xyXG4gICAgICAgIGV2ZW50UGFyYW1zLnR5cGUgPSBcImRlbGV0ZVwiO1xyXG4gICAgICAgIGV2ZW50UGFyYW1zLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLl9hcGkudHJpZ2dlcihldmVudFBhcmFtcy50eXBlLCBldmVudFBhcmFtcyk7XHJcbiAgICB9O1xyXG4gICAgZmlzaFRvcG9Qcm90by5fdHJpZ2dlckNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24odGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50UGFyYW1zID0ge307XHJcbiAgICAgICAgZXZlbnRQYXJhbXMudHlwZSA9IFwiY3JlYXRlXCI7XHJcbiAgICAgICAgZXZlbnRQYXJhbXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuX2FwaS50cmlnZ2VyKGV2ZW50UGFyYW1zLnR5cGUsIGV2ZW50UGFyYW1zKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog6byg5qCH54K55LiLIOWwhuaTjeS9nOahhiDnp7vliLDlr7nlupTnmoToioLngrnkuIpcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbm9kZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLm5vZGVDbGlja0hhbmRsZXIgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGUgPSBub2RlO1xyXG4gICAgICAgIHZhciBzaGFwZVJlY3QgPSBub2RlLmdldFJlY3QoKTtcclxuICAgICAgICBpZiAoIXRoaXMub3BlcmF0aW9uTm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRPcGVyYXRpb25Ob2RlKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuZm9yYmlkRWRpdCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlY3QuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCJyZ2JhKDAsIDAsIDAsIDEpXCJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUucmVmcmVzaFBvc3Rpb24obm9kZSwgc2hhcGVSZWN0KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJ3lp4vljJbomZrmoYblr7npvZDnur9cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNoYXBlTGlzdCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uaW5pdFZpcnR1YWxMaW5lID0gZnVuY3Rpb24oc2hhcGVMaXN0KSB7XHJcbiAgICAgICAgR3VpZGVsaW5lcy5jcmVhdGVHdWlkZWxpbmVzKHRoaXMuX3pyKTtcclxuICAgICAgICB0aGlzLnJlY3QgPSBuZXcgZ3JhcGhpYy5Qb2x5bGluZSh7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBbc2hhcGVMaXN0LngsIHNoYXBlTGlzdC55XSxcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHBvaW50czogc2hhcGVMaXN0LnBvaW50c1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgbGluZURhc2g6IFsyXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OiAzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fenIuYWRkKHRoaXMucmVjdCk7XHJcbiAgICB9O1xyXG4gICAgLy/nu5Hlrprkuovku7boioLngrlcclxuICAgIGZpc2hUb3BvUHJvdG8uYmluZEV2ZW50Tm9kZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vbW91c2Vkb3du55qE5pe25YCZ5Li65q+P5LiqdGFza+WIm+W7uuaPkuanvVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hbGxOb2Rlc1tpXS5pc0NhblNsb3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRTbG90KHRoaXMuYWxsTm9kZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vbW91c2V1cOeahOaXtuWAmeWIoOmZpOaPkuanvVxyXG4gICAgICAgIHRoaXMuX3pyLm9uKFwibW91c2V1cFwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxOb2Rlc1tpXS5pc0NhblNsb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxOb2Rlc1tpXS5zbG90ICYmIHRoaXMuYWxsTm9kZXNbaV0uc2xvdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgdGhpcy5hbGxOb2Rlc1tpXS5zbG90Lmxlbmd0aDsgbSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFsbE5vZGVzW2ldLnJlbW92ZSh0aGlzLmFsbE5vZGVzW2ldLnNsb3RbbV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNyZWF0U2xvdCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAvL+e7mXRhc2vliJvlu7o45Liq5o+S5qe9XHJcbiAgICAgICAgbm9kZS5zbG90ID0gW107XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdXRpbC5nZXRTb2x0UG9pbnRzKG5vZGUpO1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XHJcbiAgICAgICAgICAgIHZhciBDaXJjbGUgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uW2pdLFxyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgICAgICByOiAxMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJ3JnYmEoMCwwLDAsMC42KScsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbm9kZS5zbG90LnB1c2goQ2lyY2xlKTtcclxuICAgICAgICAgICAgbm9kZS5hZGQoQ2lyY2xlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIG1vdXNlZG93buWQjiDlvIDlp4vmi5bliqhcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5uZXdEcmFnID0gZnVuY3Rpb24oZG9tLCBzWCwgc1kpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhhdC5zZWxlY3RlZE5vZGUgPSBkb207XHJcbiAgICAgICAgdGhhdC5pc05vZGUgPSB0cnVlO1xyXG4gICAgICAgIHZhciBwaXhlbCA9IHRoaXMub3B0cy5ncmlkTGluZVNwYWNpbmc7XHJcbiAgICAgICAgdmFyIHNoYXBlTGlzdCA9IGRvbS5nZXRSZWN0KCk7XHJcbiAgICAgICAgdmFyIGRvbUFycmF5ID0gdGhhdC5kb21BcnJheTtcclxuICAgICAgICAvL3pyZW5kZXLkuI3mlK/mjIHplK7nm5jkuovku7bvvIzlj6rog73kvqblkKxib2R55YWD57Sg5LiK55qE5LqGXHJcbiAgICAgICAgJCgnYm9keScpLm9uZSgna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIGV2ID0gZSB8fCB3aW5kb3cuZXZlbnQ7XHJcbiAgICAgICAgICAgIC8v5Yik5patIGRlbGV0ZeaMiemUrlxyXG4gICAgICAgICAgICBpZiAoZXYua2V5Y29kZSA9PSA0NiB8fCBldi5jaGFyQ29kZSA9PSA0NiB8fCBldi53aGljaCA9PSA0Nikge1xyXG4gICAgICAgICAgICAgICAgLy8xLuWmguaenOaYr+iKgueCuSznp7vpmaTkuovku7Ys6L+b6KGM5Yig6ZmkICDlpoLmnpzmmK/lrZDoioLngrkg6YCa6L+HcGFyZW505Yig6ZmkXHJcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5pc05vZGUgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0ZWROb2RlLm9mZigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnNlbGVjdGVkTm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJwbW4uaXNTdWJQcm9jZXNzKHRoYXQuc2VsZWN0ZWROb2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0ZWROb2RlLnBhcmVudC5yZW1vdmUodGhhdC5zZWxlY3RlZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fenIucmVtb3ZlKHRoYXQuc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8yLuWIoOmZpOe7tOaKpOeahOiKgueCueaVsOe7hFxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdC5hbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5zZWxlY3RlZE5vZGUuaWQgPT0gdGhhdC5hbGxOb2Rlc1tpXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hbGxOb2Rlcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21BcnJheS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5zZWxlY3RlZE5vZGUuaWQgPT0gZG9tQXJyYXlbal0uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbUFycmF5LnNwbGljZShqLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoYXQub3ZlcmxhcEFycmF5Lmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnNlbGVjdGVkTm9kZS5pZCA9PSB0aGF0Lm92ZXJsYXBBcnJheVtrXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5vdmVybGFwQXJyYXkuc3BsaWNlKGssIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vMy7np7vljrvmk43kvZzmoYZcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5vcGVyYXRpb25Ob2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3pyLnJlbW92ZSh0aGF0Lm9wZXJhdGlvbk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm9wZXJhdGlvbk5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLzMu5Yig6Zmk5a+55bqU55qE57q/XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5kZWxldGVTZWxlY3RDb24odGhhdC5zZWxlY3RlZE5vZGUsIHRoYXQuX3pyKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8v5ZCm5YiZ55u05o6l5Yig6Zmk57q/XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5kZWxldGVMaW5lKHRoYXQuX3pyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvL+WIneWni+WMliDlr7npvZDnur9cclxuICAgICAgICB2YXIgc3RhcnRYLCBzdGFydFksIHJlY3RQb3NpdGlvblgsIHJlY3RQb3NpdGlvblk7XHJcbiAgICAgICAgc3RhcnRYID0gc1g7XHJcbiAgICAgICAgc3RhcnRZID0gc1k7XHJcbiAgICAgICAgaWYgKGRvbS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKEJwbW4uaXNTdWJQcm9jZXNzKGRvbS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZWN0UG9zaXRpb25YID0gc2hhcGVMaXN0LnggKyBkb20ucGFyZW50LnBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICAgcmVjdFBvc2l0aW9uWSA9IHNoYXBlTGlzdC55ICsgZG9tLnBhcmVudC5wb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlY3RQb3NpdGlvblggPSBzaGFwZUxpc3QueDtcclxuICAgICAgICAgICAgcmVjdFBvc2l0aW9uWSA9IHNoYXBlTGlzdC55O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoYXQucmVjdCkge1xyXG4gICAgICAgICAgICB0aGF0LmluaXRWaXJ0dWFsTGluZShzaGFwZUxpc3QpO1xyXG4gICAgICAgICAgICB0aGF0LnJlY3QuYXR0cihcInBvc2l0aW9uXCIsIFtyZWN0UG9zaXRpb25YLCByZWN0UG9zaXRpb25ZXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhhdC5yZWN0LmF0dHIoXCJwb3NpdGlvblwiLCBbcmVjdFBvc2l0aW9uWCwgcmVjdFBvc2l0aW9uWV0pO1xyXG4gICAgICAgICAgICB0aGF0LnJlY3Quc2V0U2hhcGUoe3BvaW50czogc2hhcGVMaXN0LnBvaW50c30pO1xyXG4gICAgICAgICAgICB0aGF0LnJlY3Quc2hvdygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG5vd1JlY3RQb3NpdGlvbiA9IFtyZWN0UG9zaXRpb25YLCByZWN0UG9zaXRpb25ZXTtcclxuICAgICAgICB2YXIgaXNMYXAgPSAwO1xyXG4gICAgICAgIHZhciBpc01vdmUgPSAwO1xyXG4gICAgICAgIHZhciBtb3ZlRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIG1vdmVEcmFnKGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHVwRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGVuZERyYWcoZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl96ci5vbignbW91c2Vtb3ZlJywgbW92ZUZ1bmN0aW9uKTtcclxuXHJcbiAgICAgICAgLy/lvIDlp4vnp7vliqhcclxuICAgICAgICBmdW5jdGlvbiBtb3ZlRHJhZyhlKSB7XHJcbiAgICAgICAgICAgIC8v5LulMTDkuKrlg4/ntKDkuLrljZXkvY3ov5vooYznp7vliqhcclxuICAgICAgICAgICAgdmFyIG1heFJlY3RQb3NpdGlvbiA9IFt0aGF0LmdldFdpZHRoKCkgLSAodGhhdC5yZWN0LnNoYXBlLnBvaW50c1sxXVswXSAtIHRoYXQucmVjdC5zaGFwZS5wb2ludHNbMF1bMF0pIC8gMiwgdGhhdC5nZXRIZWlnaHQoKSAtICh0aGF0LnJlY3Quc2hhcGUucG9pbnRzWzJdWzFdIC0gdGhhdC5yZWN0LnNoYXBlLnBvaW50c1sxXVsxXSkgLyAyXTtcclxuICAgICAgICAgICAgdmFyIG1pblJlY3RQb3NpdGlvbiA9IFsodGhhdC5yZWN0LnNoYXBlLnBvaW50c1sxXVswXSAtIHRoYXQucmVjdC5zaGFwZS5wb2ludHNbMF1bMF0pIC8gMiwgKHRoYXQucmVjdC5zaGFwZS5wb2ludHNbMl1bMV0gLSB0aGF0LnJlY3Quc2hhcGUucG9pbnRzWzFdWzFdKSAvIDJdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IE1hdGguYWJzKHBhcnNlSW50KChlLmV2ZW50LmNsaWVudFggLSBzdGFydFgpIC8gcGl4ZWwpKTsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICBpc01vdmUgPSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuZXZlbnQuY2xpZW50WCAtIHN0YXJ0WCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBub3dSZWN0UG9zaXRpb25bMF0gPSByZWN0UG9zaXRpb25YIC0gcGl4ZWwgKiAobik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vd1JlY3RQb3NpdGlvblswXSA9IHJlY3RQb3NpdGlvblggKyBwaXhlbCAqIChuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChub3dSZWN0UG9zaXRpb25bMF0gPCBtaW5SZWN0UG9zaXRpb25bMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBub3dSZWN0UG9zaXRpb25bMF0gPSBtaW5SZWN0UG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobm93UmVjdFBvc2l0aW9uWzBdID4gbWF4UmVjdFBvc2l0aW9uWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm93UmVjdFBvc2l0aW9uWzBdID0gbWF4UmVjdFBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgTWF0aC5hYnMocGFyc2VJbnQoKGUuZXZlbnQuY2xpZW50WSAtIHN0YXJ0WSkgLyBwaXhlbCkpOyBtKyspIHtcclxuICAgICAgICAgICAgICAgIGlzTW92ZSA9IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5ldmVudC5jbGllbnRZIC0gc3RhcnRZIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vd1JlY3RQb3NpdGlvblsxXSA9IHJlY3RQb3NpdGlvblkgLSBwaXhlbCAqIChtKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm93UmVjdFBvc2l0aW9uWzFdID0gcmVjdFBvc2l0aW9uWSArIHBpeGVsICogKG0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vd1JlY3RQb3NpdGlvblsxXSA8IG1pblJlY3RQb3NpdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vd1JlY3RQb3NpdGlvblsxXSA9IG1pblJlY3RQb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChub3dSZWN0UG9zaXRpb25bMV0gPiBtYXhSZWN0UG9zaXRpb25bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBub3dSZWN0UG9zaXRpb25bMV0gPSBtYXhSZWN0UG9zaXRpb25bMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhhdC5yZWN0LmF0dHIoJ3Bvc2l0aW9uJywgbm93UmVjdFBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIEd1aWRlbGluZXMuanVkZ2VBbGlnbm1lbnQobm93UmVjdFBvc2l0aW9uLCBkb21BcnJheSwgdGhhdC5nZXRXaWR0aCgpLCB0aGF0LmdldEhlaWdodCgpKTtcclxuICAgICAgICAgICAgLy8g5aaC5p6c5aSE5LqO5a2Q6IqC54K55YaF6YOoICDliJnkuI3lhYHorrjmi5bliLDlpJbpnaIg6Jma5qGG5qCH57qiXHJcbiAgICAgICAgICAgIGlmIChkb20ucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyWCA9IE1hdGguYWJzKG5vd1JlY3RQb3NpdGlvblswXSAtIGRvbS5wYXJlbnQuZ2V0UmVjdCgpLngpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoWCA9IE1hdGguYWJzKGRvbS5nZXRSZWN0KCkud2lkdGggLyAyIC0gZG9tLnBhcmVudC5nZXRSZWN0KCkud2lkdGggLyAyKTtcclxuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJZID0gTWF0aC5hYnMobm93UmVjdFBvc2l0aW9uWzFdIC0gZG9tLnBhcmVudC5nZXRSZWN0KCkueSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0WSA9IE1hdGguYWJzKGRvbS5nZXRSZWN0KCkuaGVpZ2h0IC8gMiAtIGRvbS5wYXJlbnQuZ2V0UmVjdCgpLmhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNlbnRlclggPiAod2lkdGhYIC0gcGl4ZWwpIHx8IGNlbnRlclkgPiAoaGVpZ2h0WSAtIHBpeGVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEZhbHNlKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVzdWx0U3VjY2VzcygpIHtcclxuICAgICAgICAgICAgICAgIGlzTGFwID0gMDtcclxuICAgICAgICAgICAgICAgIHRoYXQucmVjdC5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogXCJyZ2JhKDAsIDAsIDAsIDEpXCJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZXN1bHRGYWxzZSgpIHtcclxuICAgICAgICAgICAgICAgIGlzTGFwID0gMTtcclxuICAgICAgICAgICAgICAgIHRoYXQucmVjdC5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogXCJyZ2JhKDI1NSwgMCwgMCwgMSlcIlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8v5Yik5pat5piv5ZCm5pyJ6YeN5Y+gICDmjpLpmaTljrvkuoblrZDmtYHnqIvph4zpnaLnmoToioLngrlcclxuICAgICAgICAgICAgaWYgKCFkb20ucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMCwgbGVuID0gdGhhdC5vdmVybGFwQXJyYXkubGVuZ3RoOyBsIDwgbGVuOyBsKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdERvbSA9IHRoYXQub3ZlcmxhcEFycmF5W2xdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAvL+S4juaLluaLveiKgueCueS4jeebuOetiVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0RG9tLmlkICE9IHRoYXQucmVjdC5pZCAmJiByZWN0RG9tLmlkICE9IGRvbS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGVMaXN0LndpZHRoID4gcmVjdERvbS53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vL+enu+WKqOeahOS9jee9riDlh4/ljrvlvZPliY3oioLngrnnmoTkvY3nva4g5bCP5LqO5ouW5ou96IqC54K56auY5bqm5Y+K5a695bqm5LiA5Y2K77yMIOWImeaciemHjeWPoCDmoIfnuqJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFwZUxpc3QuaGVpZ2h0ID4gcmVjdERvbS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobm93UmVjdFBvc2l0aW9uWzBdIC0gKHJlY3REb20ucG9zaXRpb25bMF0pKSA8IHNoYXBlTGlzdC53aWR0aCAvIDIgJiYgTWF0aC5hYnMobm93UmVjdFBvc2l0aW9uWzFdIC0gKHJlY3REb20ucG9zaXRpb25bMV0pKSA8IHNoYXBlTGlzdC5oZWlnaHQgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEZhbHNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhub3dSZWN0UG9zaXRpb25bMF0gLSAocmVjdERvbS5wb3NpdGlvblswXSkpIDwgc2hhcGVMaXN0LndpZHRoIC8gMiAmJiBNYXRoLmFicyhub3dSZWN0UG9zaXRpb25bMV0gLSAocmVjdERvbS5wb3NpdGlvblsxXSkpIDwgcmVjdERvbS5oZWlnaHQgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEZhbHNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlTGlzdC5oZWlnaHQgPiByZWN0RG9tLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhub3dSZWN0UG9zaXRpb25bMF0gLSAocmVjdERvbS5wb3NpdGlvblswXSkpIDwgcmVjdERvbS53aWR0aCAvIDIgJiYgTWF0aC5hYnMobm93UmVjdFBvc2l0aW9uWzFdIC0gKHJlY3REb20ucG9zaXRpb25bMV0pKSA8IHNoYXBlTGlzdC5oZWlnaHQgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEZhbHNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhub3dSZWN0UG9zaXRpb25bMF0gLSAocmVjdERvbS5wb3NpdGlvblswXSkpIDwgKHJlY3REb20ud2lkdGggLyAyKSAmJiBNYXRoLmFicyhub3dSZWN0UG9zaXRpb25bMV0gLSAocmVjdERvbS5wb3NpdGlvblsxXSkpIDwgKHJlY3REb20uaGVpZ2h0IC8gMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0RmFsc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8v5Yik5pat5LqL5Lu26IqC54K55piv5ZCm5Y+v5Lul5L6d6ZmE77yM5Y+v5Lul5L6d6ZmE5pi+56S657u/5qGGXHJcbiAgICAgICAgICAgIGlmIChCcG1uLmlzU2xvdEV2ZW50KGRvbSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdC5hbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmFsbE5vZGVzW2ldLmlzQ2FuU2xvdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5hbGxOb2Rlc1tpXS5zbG90ICYmIHRoYXQuYWxsTm9kZXNbaV0uc2xvdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IHRoYXQuYWxsTm9kZXNbaV0uc2xvdC5sZW5ndGg7IGErKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90UG9zaXRpb24gPSBbdGhhdC5hbGxOb2Rlc1tpXS5zbG90W2FdLnBvc2l0aW9uWzBdICsgdGhhdC5hbGxOb2Rlc1tpXS5wb3NpdGlvblswXSwgdGhhdC5hbGxOb2Rlc1tpXS5zbG90W2FdLnBvc2l0aW9uWzFdICsgdGhhdC5hbGxOb2Rlc1tpXS5wb3NpdGlvblsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vd1JlY3RQb3NpdGlvblswXSA9PSBzbG90UG9zaXRpb25bMF0gJiYgbm93UmVjdFBvc2l0aW9uWzFdID09IHNsb3RQb3NpdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnJlY3QuYXR0cihcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogXCJyZ2JhKDAsIDI1NSwgMCwgMSlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZW5kRHJhZygpIHtcclxuICAgICAgICAgICAgdGhhdC5fenIub2ZmKCdtb3VzZW1vdmUnLCBtb3ZlRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICB0aGF0Ll96ci5vZmYoJ21vdXNldXAnLCB1cEZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgdGhhdC5fenIub2ZmKCdnbG9iYWxvdXQnLCB1cEZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKGRvbS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGRvbS5wYXJlbnQub2ZmKFwiZ2xvYmFsb3V0XCIsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoYXQucmVjdC5oaWRlKCk7XHJcbiAgICAgICAgICAgIEd1aWRlbGluZXMudmlydHVhbFhMaW5lLmF0dHIoXCJzaGFwZVwiLCB7XHJcbiAgICAgICAgICAgICAgICB4MjogMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgR3VpZGVsaW5lcy52aXJ0dWFsWUxpbmUuYXR0cihcInNoYXBlXCIsIHtcclxuICAgICAgICAgICAgICAgIHkyOiAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaXNMYXAgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvbS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQnBtbi5pc1N1YlByb2Nlc3MoZG9tLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwTm9kZVBvc2l0aW9uWCA9IGRvbS5wYXJlbnQuZ2V0UmVjdCgpLndpZHRoIC8gMiArIChub3dSZWN0UG9zaXRpb25bMF0gLSBkb20ucGFyZW50LmdldFJlY3QoKS54KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwTm9kZVBvc2l0aW9uWSA9IGRvbS5wYXJlbnQuZ2V0UmVjdCgpLmhlaWdodCAvIDIgKyAobm93UmVjdFBvc2l0aW9uWzFdIC0gZG9tLnBhcmVudC5nZXRSZWN0KCkueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb20uc2xvdEV2ZW50ICYmIGRvbS5zbG90RXZlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBkb20uc2xvdEV2ZW50Lmxlbmd0aDsgbSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RFdmVudFBvc2l0aW9uID0gW2RvbS5zbG90RXZlbnRbbV0ucG9zaXRpb25bMF0gKyBncm91cE5vZGVQb3NpdGlvblggLSB6clV0aWwuY2xvbmUoZG9tLnBvc2l0aW9uWzBdKSAtIGRvbS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDIsIGRvbS5zbG90RXZlbnRbbV0ucG9zaXRpb25bMV0gKyBncm91cE5vZGVQb3NpdGlvblkgLSB6clV0aWwuY2xvbmUoZG9tLnBvc2l0aW9uWzFdKSAtIGRvbS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb20uc2xvdEV2ZW50W21dLmF0dHIoXCJwb3NpdGlvblwiLCBzbG90RXZlbnRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZShkb20uc2xvdEV2ZW50W21dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb20uc2V0UG9zaXRpb24oZ3JvdXBOb2RlUG9zaXRpb25YLCBncm91cE5vZGVQb3NpdGlvblkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbS5zbG90RXZlbnQgJiYgZG9tLnNsb3RFdmVudC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZG9tLnNsb3RFdmVudC5sZW5ndGg7IG4rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNsb3RFdmVudFBvc2l0aW9uID0gW2RvbS5zbG90RXZlbnRbbl0ucG9zaXRpb25bMF0gKyBub3dSZWN0UG9zaXRpb25bMF0gLSB6clV0aWwuY2xvbmUoZG9tLnBvc2l0aW9uWzBdKSAtIGRvbS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDIsIGRvbS5zbG90RXZlbnRbbl0ucG9zaXRpb25bMV0gKyBub3dSZWN0UG9zaXRpb25bMV0gLSB6clV0aWwuY2xvbmUoZG9tLnBvc2l0aW9uWzFdKSAtIGRvbS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5zbG90RXZlbnRbbl0uYXR0cihcInBvc2l0aW9uXCIsIHNsb3RFdmVudFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUoZG9tLnNsb3RFdmVudFtuXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldFBvc2l0aW9uKG5vd1JlY3RQb3NpdGlvblswXSwgbm93UmVjdFBvc2l0aW9uWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGlmIChkb20uYWxhcm0pIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICB2YXIgbmV3QWxhcm1Qb3NpdGlvbiA9IFtub3dSZWN0UG9zaXRpb25bMF0gLSBkb20uZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLyAyIC0gKGRvbS5hbGFybS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAtIDYpLCBub3dSZWN0UG9zaXRpb25bMV0gLSBkb20uZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC8gMiAtIGRvbS5hbGFybS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLSAzXTtcclxuICAgICAgICAgICAgICAgIC8vICAgICBkb20uYWxhcm0uYXR0cihcInBvc2l0aW9uXCIsIG5ld0FsYXJtUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgLy8gfTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgdGhhdC5kb21BcnJheS5sZW5ndGg7IGIrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb20uaWQgPT0gdGhhdC5kb21BcnJheVtiXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmRvbUFycmF5W2JdLnBvc2l0aW9uID0gW25vd1JlY3RQb3NpdGlvblswXSwgbm93UmVjdFBvc2l0aW9uWzFdXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoYXQub3ZlcmxhcEFycmF5Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbS5pZCA9PSB0aGF0Lm92ZXJsYXBBcnJheVtqXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm92ZXJsYXBBcnJheVtqXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBkb20uaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogW25vd1JlY3RQb3NpdGlvblswXSwgbm93UmVjdFBvc2l0aW9uWzFdXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkb20uZ2V0UmVjdCgpLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBkb20uZ2V0UmVjdCgpLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGlzTW92ZSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lm5vZGVDbGlja0hhbmRsZXIoZG9tKTtcclxuICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUoZG9tKTtcclxuICAgICAgICAgICAgICAgIHRoYXQuc3RlcENvdW50ZXIoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy/lsIbkuovku7boioLngrnkuI50YXNr6IqC54K557uR5a6a5oiW6Kej57uRXHJcbiAgICAgICAgICAgIGlmIChCcG1uLmlzU2xvdEV2ZW50KGRvbSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdC5hbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmFsbE5vZGVzW2ldLmlzQ2FuU2xvdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5hbGxOb2Rlc1tpXS5zbG90ICYmIHRoYXQuYWxsTm9kZXNbaV0uc2xvdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHRoYXQuYWxsTm9kZXNbaV0uc2xvdC5sZW5ndGg7IGMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90UG9zaXRpb24gPSBbdGhhdC5hbGxOb2Rlc1tpXS5zbG90W2NdLnBvc2l0aW9uWzBdICsgdGhhdC5hbGxOb2Rlc1tpXS5wb3NpdGlvblswXSwgdGhhdC5hbGxOb2Rlc1tpXS5zbG90W2NdLnBvc2l0aW9uWzFdICsgdGhhdC5hbGxOb2Rlc1tpXS5wb3NpdGlvblsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1JlY3RQb3NpdGlvbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb20ucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChCcG1uLmlzU3ViUHJvY2Vzcyhkb20ucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UmVjdFBvc2l0aW9uWzBdID0gZG9tLnBhcmVudC5nZXRSZWN0KCkud2lkdGggLyAyICsgKG5vd1JlY3RQb3NpdGlvblswXSAtIGRvbS5wYXJlbnQuZ2V0UmVjdCgpLngpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UmVjdFBvc2l0aW9uWzFdID0gZG9tLnBhcmVudC5nZXRSZWN0KCkuaGVpZ2h0IC8gMiArIChub3dSZWN0UG9zaXRpb25bMV0gLSBkb20ucGFyZW50LmdldFJlY3QoKS55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1JlY3RQb3NpdGlvbiA9IG5vd1JlY3RQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1JlY3RQb3NpdGlvblswXSA9PSBzbG90UG9zaXRpb25bMF0gJiYgbmV3UmVjdFBvc2l0aW9uWzFdID09IHNsb3RQb3NpdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFsbE5vZGVzW2ldLnNsb3RFdmVudC5wdXNoKGRvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhhdC5hbGxOb2Rlc1tpXS5zbG90RXZlbnQubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb20uaWQgPT0gdGhhdC5hbGxOb2Rlc1tpXS5zbG90RXZlbnRba10uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFsbE5vZGVzW2ldLnNsb3RFdmVudC5zcGxpY2UoaywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl96ci5vbihcIm1vdXNldXBcIiwgdXBGdW5jdGlvbik7XHJcbiAgICAgICAgdGhpcy5fenIub24oXCJnbG9iYWxvdXRcIiwgdXBGdW5jdGlvbik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5jcmVhdFRpcCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAvL+WIm+W7unRhc2vlhoXlrrnnmoTmj5DnpLpcclxuICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgIGdyb3VwLmlzU2hvdyA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBuYW1lID0gbm9kZS5tb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikgfHwgXCJcIjtcclxuICAgICAgICB2YXIgc2hvd05hbWU7XHJcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID4gNjQpIHtcclxuICAgICAgICAgICAgc2hvd05hbWUgPSBuYW1lLnN1YnN0cigwLCA2NCkgKyAnLi4nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNob3dOYW1lID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IHNob3dOYW1lLFxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6ICcxNnB4IE1pY3Jvc29mdCBZYUhlaScsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcIiMwMDAwMDBcIixcclxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogXCJ0b3BcIiAvL+WeguebtOWvuem9kFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogWzIsIDBdLFxyXG4gICAgICAgICAgICB6OiAyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGV4dC5uYW1lID0gXCJUZXh0XCI7XHJcbiAgICAgICAgZ3JvdXAuYWRkKHRleHQpO1xyXG4gICAgICAgIHZhciBQb2x5bGluZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZjlmOWY5JyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyNiYmJiYmInXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6IDFcclxuICAgICAgICB9KTtcclxuICAgICAgICBQb2x5bGluZS5uYW1lID0gXCJQb2x5bGluZVwiO1xyXG4gICAgICAgIGdyb3VwLmFkZChQb2x5bGluZSk7XHJcbiAgICAgICAgLy8gdmFyIGdyb3VwUG9zaXRpb24gPSBbbm9kZS5wb3NpdGlvblswXSAtIG5vZGUuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGgvMiAtIChncm91cC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAtIDYpLCBub2RlLnBvc2l0aW9uWzFdLSBub2RlLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAvIDIgLSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLSAzXTtcclxuICAgICAgICAvLyBncm91cC5hdHRyKFwicG9zaXRpb25cIiwgZ3JvdXBQb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5fenIuYWRkKGdyb3VwKTtcclxuICAgICAgICBub2RlLmFsYXJtID0gZ3JvdXA7XHJcbiAgICAgICAgZ3JvdXAuaGlkZSgpO1xyXG4gICAgICAgIGdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgICAgICBjaGlsZC5oaWRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uc3RlcENvdW50ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLnN0ZXBKc29uLnNwbGljZSh0aGlzLnN0ZXAsIHRoaXMuc3RlcEpzb24ubGVuZ3RoIC0gKHRoaXMuc3RlcCkpO1xyXG4gICAgICAgIHRoaXMuc3RlcCArPSAxO1xyXG4gICAgICAgIHZhciBqc29uID0gdGhpcy50b0pzb24oKTtcclxuICAgICAgICB0aGlzLnN0ZXBKc29uLnB1c2goSlNPTi5zdHJpbmdpZnkoanNvbikpO1xyXG4gICAgfTtcclxuICAgIC8vIGZpc2hUb3BvUHJvdG8uc3RlcEZvcndhcmQgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vICAgICBpZiAodGhpcy5zdGVwIDwgdGhpcy5zdGVwSnNvbi5sZW5ndGgpIHtcclxuICAgIC8vICAgICAgICAgdGhpcy5jbGVhcih0cnVlKTtcclxuICAgIC8vICAgICAgICAgdGhpcy5zdGVwICs9IDE7XHJcbiAgICAvLyAgICAgICAgIHZhciBqc29uID0gSlNPTi5wYXJzZSh0aGlzLnN0ZXBKc29uW3RoaXMuc3RlcCAtIDFdKTtcclxuICAgIC8vICAgICAgICAgdGhpcy5mcm9tSnNvbihqc29uKTtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyB9O1xyXG4gICAgLy8gZmlzaFRvcG9Qcm90by5zdGVwQmFjayA9IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gICAgIGlmICh0aGlzLnN0ZXAgPiAwKSB7XHJcbiAgICAvLyAgICAgICAgIHRoaXMuY2xlYXIodHJ1ZSk7XHJcbiAgICAvLyAgICAgICAgIHRoaXMuc3RlcCAtPSAxO1xyXG4gICAgLy8gICAgICAgICBpZiAodGhpcy5zdGVwIC0gMSA+PSAwKSB7XHJcbiAgICAvLyAgICAgICAgICAgICB2YXIganNvbiA9IEpTT04ucGFyc2UodGhpcy5zdGVwSnNvblt0aGlzLnN0ZXAgLSAxXSk7XHJcbiAgICAvLyAgICAgICAgICAgICB0aGlzLmZyb21Kc29uKGpzb24pO1xyXG4gICAgLy8gICAgICAgICB9XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gfTtcclxuXHJcblxyXG4gICAgenJVdGlsLm1peGluKEZpc2hUb3BvQnBtbiwgRXZlbnRmdWwpO1xyXG5cclxuICAgIC8vIC0tLS0tLS0tLeWvueWkluaatOmcsmZpc2hUb3BvQnBtbi0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgdmFyIGlkQmFzZSA9IG5ldyBEYXRlKCkgLSAwO1xyXG4gICAgdmFyIGluc3RhbmNlcyA9IHt9O1xyXG4gICAgdmFyIERPTV9BVFRSSUJVVEVfS0VZID0gJ19maXNoVG9wb0JwbW5faW5zdGFuY2VfJztcclxuXHJcbiAgICAvKipcclxuICAgICAqIGZpc2hUb3BvQnBtbuWFqOWxgOWvueixoe+8jOWmguaenOaYr2FtZOaWueW8j+WKoOi9ve+8jOWImeebtOaOpei/lOWbnlxyXG4gICAgICogQGNsYXNzIGZpc2hUb3BvQnBtblxyXG4gICAgICogQHNpbmdsZXRvblxyXG4gICAgICovXHJcbiAgICB2YXIgZmlzaFRvcG9CcG1uID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOeJiOacrOWPt1xyXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmVyc2lvbjogJzEuNy4wJyxcclxuICAgICAgICBkZXBlbmRlbmNpZXM6IHtcclxuICAgICAgICAgICAgenJlbmRlcjogJzMuMC40J1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJ3lp4vljJZkb23lhYPntKDkuLogYnBtbuWvueixoVxyXG4gICAgICogQG1lbWJlciBmaXNoVG9wb0JwbW5cclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbSAg5LiA5LiqZGl25YWD57SgXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAg5Lyg6YCS55qE6YCJ6aG55Y+C5pWwXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnIG9yICd2bWwnXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpbz0xXSByZXRpbmEg5bGP5bmV5LyY5YyWXHJcbiAgICAgKiBAcmV0dXJuIHtmaXNoLnRvcG8uRmlzaFRvcG9CcG1ufVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb0JwbW4uaW5pdCA9IGZ1bmN0aW9uKGRvbSwgb3B0cykge1xyXG4gICAgICAgIGlmICghZG9tKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5pdGlhbGl6ZSBmYWlsZWQ6IGludmFsaWQgZG9tLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XHJcbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgIHpyVXRpbC5kZWZhdWx0cyhvcHRzLCB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiYnBtblwiLFxyXG4gICAgICAgICAgICBzaG93R3JpZExpbmU6IHRydWUsXHJcbiAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW86IDEsXHJcbiAgICAgICAgICAgIGdyaWRMaW5lU3BhY2luZzogMTBcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIGZpc2hUb3BvQnBtbiA9IG5ldyBGaXNoVG9wb0JwbW4oZG9tLCBvcHRzKTtcclxuICAgICAgICBmaXNoVG9wb0JwbW4uaW5pdCgpO1xyXG5cclxuICAgICAgICBmaXNoVG9wb0JwbW4uaWQgPSAnZnRfJyArIGlkQmFzZSsrO1xyXG4gICAgICAgIGluc3RhbmNlc1tmaXNoVG9wb0JwbW4uaWRdID0gZmlzaFRvcG9CcG1uO1xyXG5cclxuICAgICAgICBkb20uc2V0QXR0cmlidXRlICYmIGRvbS5zZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVksIGZpc2hUb3BvQnBtbi5pZCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmaXNoVG9wb0JwbW47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPliBkb20g5a655Zmo5LiK55qE5a6e5L6L44CCXHJcbiAgICAgKiBAbWVtYmVyIGZpc2hUb3BvQnBtblxyXG4gICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGRvbSDkuIDkuKpkaXblhYPntKBcclxuICAgICAqIEByZXR1cm4ge2Zpc2gudG9wby5GaXNoVG9wb0JwbW59XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvQnBtbi5nZXRJbnN0YW5jZUJ5RG9tID0gZnVuY3Rpb24oZG9tKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGRvbS5nZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVkpO1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZXNba2V5XTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDplIDmr4Hlrp7kvovvvIzlrp7kvovplIDmr4HlkI7ml6Dms5Xlho3ooqvkvb/nlKjjgIJcclxuICAgICAqIEBtZW1iZXIgZmlzaFRvcG9CcG1uXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R8c3RyaW5nfSBjaGFydCBmaXNoVG9wb0JwbW7lrp7kvosg5oiWIGZpc2hUb3BvQnBtbueahGlkXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvQnBtbi5kaXNwb3NlID0gZnVuY3Rpb24oY2hhcnQpIHtcclxuICAgICAgICB2YXIgdG9wbztcclxuICAgICAgICBpZiAoenJVdGlsLmlzRG9tKGNoYXJ0KSkge1xyXG4gICAgICAgICAgICB0b3BvID0gZmlzaFRvcG9CcG1uLmdldEluc3RhbmNlQnlEb20oY2hhcnQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNoYXJ0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0b3BvID0gaW5zdGFuY2VzW2NoYXJ0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh0b3BvIGluc3RhbmNlb2YgZmlzaFRvcG9CcG1uKSAmJiAhdG9wby5pc0Rpc3Bvc2VkKCkpIHtcclxuICAgICAgICAgICAgdG9wby5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8v5pq06Zyy5Ye65Y6755qE57G7IOaWueS+v+eUqOaIt+aJqeWxleWbvuWFg1xyXG4gICAgZmlzaFRvcG9CcG1uLkJwbW4gPSBCcG1uO1xyXG4gICAgZmlzaFRvcG9CcG1uLkJQTU5Ob2RlID0gQlBNTk5vZGU7XHJcbiAgICBmaXNoVG9wb0JwbW4uZ3JhcGhpYyA9IGdyYXBoaWM7XHJcbiAgICBmaXNoVG9wb0JwbW4uQm91bmRpbmdSZWN0ID0gQm91bmRpbmdSZWN0O1xyXG5cclxuICAgIGZpc2hUb3BvQnBtbi51dGlsID0ge307XHJcbiAgICB6clV0aWwuZWFjaChbXHJcbiAgICAgICAgICAgICdtYXAnLCAnZWFjaCcsICdmaWx0ZXInLCAnaW5kZXhPZicsICdpbmhlcml0cycsXHJcbiAgICAgICAgICAgICdyZWR1Y2UnLCAnZmlsdGVyJywgJ2JpbmQnLCAnY3VycnknLCAnaXNBcnJheScsXHJcbiAgICAgICAgICAgICdpc1N0cmluZycsICdpc09iamVjdCcsICdpc0Z1bmN0aW9uJywgJ2V4dGVuZCdcclxuICAgICAgICBdLFxyXG4gICAgICAgIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgZmlzaFRvcG9CcG1uLnV0aWxbbmFtZV0gPSB6clV0aWxbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmlzaFRvcG9CcG1uO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvRmlzaFRvcG9CcG1uLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIHZhciBwYXRoVG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvcGF0aCcpO1xyXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcclxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoJyk7XHJcbiAgICB2YXIgY29sb3JUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvdG9vbC9jb2xvcicpO1xyXG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4Jyk7XHJcbiAgICB2YXIgdmVjdG9yID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcclxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQnKTtcclxuICAgIHZhciBEcmFnZ2FibGUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9taXhpbi9EcmFnZ2FibGUnKTtcclxuXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHt9O1xyXG4gICAgZ3JhcGhpYy5VdGlsID0genJVdGlsO1xyXG4gICAgZ3JhcGhpYy5Hcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cCcpO1xyXG5cclxuICAgIGdyYXBoaWMuSW1hZ2UgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5UZXh0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy50ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xyXG5cclxuICAgIGdyYXBoaWMuQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUnKTtcclxuXHJcbiAgICBncmFwaGljLlNlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5SaW5nID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Qb2x5Z29uID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Qb2x5bGluZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUnKTtcclxuXHJcbiAgICBncmFwaGljLlJlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QnKTtcclxuXHJcbiAgICBncmFwaGljLkxpbmUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUnKTtcclxuXHJcbiAgICBncmFwaGljLkJlemllckN1cnZlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZScpO1xyXG5cclxuICAgIGdyYXBoaWMuQXJjID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMnKTtcclxuXHJcbiAgICBncmFwaGljLkxpbmVhckdyYWRpZW50ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudCcpO1xyXG5cclxuICAgIGdyYXBoaWMuUmFkaWFsR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Cb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZW5kIHNoYXBlIHdpdGggcGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBncmFwaGljLmV4dGVuZFNoYXBlID0gZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gUGF0aC5leHRlbmQob3B0cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZW5kIHBhdGhcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5leHRlbmRQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGhUb29sLmV4dGVuZEZyb21TdHJpbmcocGF0aERhdGEsIG9wdHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIHBhdGggZWxlbWVudCBmcm9tIHBhdGggZGF0YSBzdHJpbmdcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoRGF0YVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IHJlY3RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGF5b3V0PWNvdmVyXSAnY2VudGVyJyBvciAnY292ZXInXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMubWFrZVBhdGggPSBmdW5jdGlvbiAocGF0aERhdGEsIG9wdHMsIHJlY3QsIGxheW91dCkge1xyXG4gICAgICAgIHZhciBwYXRoID0gcGF0aFRvb2wuY3JlYXRlRnJvbVN0cmluZyhwYXRoRGF0YSwgb3B0cyk7XHJcbiAgICAgICAgRHJhZ2dhYmxlLmNhbGwocGF0aCk7XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgaWYgKHJlY3QpIHtcclxuICAgICAgICAgICAgdmFyIGFzcGVjdCA9IGJvdW5kaW5nUmVjdC53aWR0aCAvIGJvdW5kaW5nUmVjdC5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAobGF5b3V0ID09PSAnY2VudGVyJykge1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IHJlY3QgdG8gY2VudGVyLCBrZWVwIHdpZHRoIC8gaGVpZ2h0IHJhdGlvLlxyXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gcmVjdC5oZWlnaHQgKiBhc3BlY3Q7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoIDw9IHJlY3Qud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjeCA9IHJlY3QueCArIHJlY3Qud2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN5ID0gcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlY3QueCA9IGN4IC0gd2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgcmVjdC55ID0gY3kgLSBoZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICAgICAgcmVjdC53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgcmVjdC5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplUGF0aChwYXRoLCByZWN0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHpyVXRpbC5pbmhlcml0cyhwYXRoLCBEcmFnZ2FibGUpO1xyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfTtcclxuXHJcbiAgICBncmFwaGljLm1lcmdlUGF0aCA9IHBhdGhUb29sLm1lcmdlUGF0aDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZSBhIHBhdGggdG8gZml0IHRoZSByZWN0XHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gcGF0aFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3RcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5yZXNpemVQYXRoID0gZnVuY3Rpb24gKHBhdGgsIHJlY3QpIHtcclxuICAgICAgICBpZiAoIXBhdGguYXBwbHlUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBhdGhSZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcclxuXHJcbiAgICAgICAgdmFyIG0gPSBwYXRoUmVjdC5jYWxjdWxhdGVUcmFuc2Zvcm0ocmVjdCk7XHJcblxyXG4gICAgICAgIHBhdGguYXBwbHlUcmFuc2Zvcm0obSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIGxpbmUgZm9yIGNhbnZhc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zaGFwZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueDFdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnkxXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54Ml1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueTJdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnN0eWxlXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zdHlsZS5saW5lV2lkdGhdXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE1vZGlmaWVkIHBhcmFtXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZUxpbmUgPSBmdW5jdGlvbiAocGFyYW0pIHtcclxuICAgICAgICB2YXIgc3ViUGl4ZWxPcHRpbWl6ZSA9IGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZTtcclxuICAgICAgICB2YXIgc2hhcGUgPSBwYXJhbS5zaGFwZTtcclxuICAgICAgICB2YXIgbGluZVdpZHRoID0gcGFyYW0uc3R5bGUubGluZVdpZHRoO1xyXG5cclxuICAgICAgICBpZiAocm91bmQoc2hhcGUueDEgKiAyKSA9PT0gcm91bmQoc2hhcGUueDIgKiAyKSkge1xyXG4gICAgICAgICAgICBzaGFwZS54MSA9IHNoYXBlLngyID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS54MSwgbGluZVdpZHRoLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJvdW5kKHNoYXBlLnkxICogMikgPT09IHJvdW5kKHNoYXBlLnkyICogMikpIHtcclxuICAgICAgICAgICAgc2hhcGUueTEgPSBzaGFwZS55MiA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueTEsIGxpbmVXaWR0aCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWIgcGl4ZWwgb3B0aW1pemUgcmVjdCBmb3IgY2FudmFzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnNoYXBlXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54XVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55XVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS53aWR0aF1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUuaGVpZ2h0XVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zdHlsZV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc3R5bGUubGluZVdpZHRoXVxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBNb2RpZmllZCBwYXJhbVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVSZWN0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgdmFyIHN1YlBpeGVsT3B0aW1pemUgPSBncmFwaGljLnN1YlBpeGVsT3B0aW1pemU7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gcGFyYW0uc2hhcGU7XHJcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHBhcmFtLnN0eWxlLmxpbmVXaWR0aDtcclxuICAgICAgICB2YXIgb3JpZ2luWCA9IHNoYXBlLng7XHJcbiAgICAgICAgdmFyIG9yaWdpblkgPSBzaGFwZS55O1xyXG4gICAgICAgIHZhciBvcmlnaW5XaWR0aCA9IHNoYXBlLndpZHRoO1xyXG4gICAgICAgIHZhciBvcmlnaW5IZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XHJcbiAgICAgICAgc2hhcGUueCA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueCwgbGluZVdpZHRoLCB0cnVlKTtcclxuICAgICAgICBzaGFwZS55ID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS55LCBsaW5lV2lkdGgsIHRydWUpO1xyXG4gICAgICAgIHNoYXBlLndpZHRoID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgIHN1YlBpeGVsT3B0aW1pemUob3JpZ2luWCArIG9yaWdpbldpZHRoLCBsaW5lV2lkdGgsIGZhbHNlKSAtIHNoYXBlLngsXHJcbiAgICAgICAgICAgIG9yaWdpbldpZHRoID09PSAwID8gMCA6IDFcclxuICAgICAgICApO1xyXG4gICAgICAgIHNoYXBlLmhlaWdodCA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICBzdWJQaXhlbE9wdGltaXplKG9yaWdpblkgKyBvcmlnaW5IZWlnaHQsIGxpbmVXaWR0aCwgZmFsc2UpIC0gc2hhcGUueSxcclxuICAgICAgICAgICAgb3JpZ2luSGVpZ2h0ID09PSAwID8gMCA6IDFcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBwYXJhbTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWIgcGl4ZWwgb3B0aW1pemUgZm9yIGNhbnZhc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBDb29yZGluYXRlLCBzdWNoIGFzIHgsIHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lV2lkdGggU2hvdWxkIGJlIG5vbm5lZ2F0aXZlIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBwb3NpdGl2ZU9yTmVnYXRpdmUgRGVmYXVsdCBmYWxzZSAobmVnYXRpdmUpLlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBPcHRpbWl6ZWQgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZSA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgbGluZVdpZHRoLCBwb3NpdGl2ZU9yTmVnYXRpdmUpIHtcclxuICAgICAgICAvLyBBc3N1cmUgdGhhdCAocG9zaXRpb24gKyBsaW5lV2lkdGggLyAyKSBpcyBuZWFyIGludGVnZXIgZWRnZSxcclxuICAgICAgICAvLyBvdGhlcndpc2UgbGluZSB3aWxsIGJlIGZ1enp5IGluIGNhbnZhcy5cclxuICAgICAgICB2YXIgZG91YmxlZFBvc2l0aW9uID0gcm91bmQocG9zaXRpb24gKiAyKTtcclxuICAgICAgICByZXR1cm4gKGRvdWJsZWRQb3NpdGlvbiArIHJvdW5kKGxpbmVXaWR0aCkpICUgMiA9PT0gMFxyXG4gICAgICAgICAgICA/IGRvdWJsZWRQb3NpdGlvbiAvIDJcclxuICAgICAgICAgICAgOiAoZG91YmxlZFBvc2l0aW9uICsgKHBvc2l0aXZlT3JOZWdhdGl2ZSA/IDEgOiAtMSkpIC8gMjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkb1NpbmdsZUVudGVySG92ZXIoZWwpIHtcclxuICAgICAgICBpZiAoZWwuX19pc0hvdmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVsLl9faG92ZXJTdGxEaXJ0eSkge1xyXG4gICAgICAgICAgICB2YXIgc3Ryb2tlID0gZWwuc3R5bGUuc3Ryb2tlO1xyXG4gICAgICAgICAgICB2YXIgZmlsbCA9IGVsLnN0eWxlLmZpbGw7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgaG92ZXJTdHlsZSBvbiBtb3VzZW92ZXJcclxuICAgICAgICAgICAgdmFyIGhvdmVyU3R5bGUgPSBlbC5fX2hvdmVyU3RsO1xyXG4gICAgICAgICAgICB2YXIgbGlmdCA9IGNvbG9yVG9vbC5saWZ0O1xyXG4gICAgICAgICAgICBob3ZlclN0eWxlLmZpbGwgPSBob3ZlclN0eWxlLmZpbGxcclxuICAgICAgICAgICAgICAgIHx8IChmaWxsICYmIChmaWxsIGluc3RhbmNlb2YgR3JhZGllbnQgPyBmaWxsIDogbGlmdChmaWxsLCAtMC4xKSkpO1xyXG4gICAgICAgICAgICBob3ZlclN0eWxlLnN0cm9rZSA9IGhvdmVyU3R5bGUuc3Ryb2tlXHJcbiAgICAgICAgICAgICAgICB8fCAoc3Ryb2tlICYmIChzdHJva2UgaW5zdGFuY2VvZiBHcmFkaWVudCA/IHN0cm9rZSA6IGxpZnQoc3Ryb2tlLCAtMC4xKSkpO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5vcm1hbFN0eWxlID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gaG92ZXJTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyU3R5bGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxTdHlsZVtuYW1lXSA9IGVsLnN0eWxlW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBlbC5fX25vcm1hbFN0bCA9IG5vcm1hbFN0eWxlO1xyXG5cclxuICAgICAgICAgICAgZWwuX19ob3ZlclN0bERpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsLnNldFN0eWxlKGVsLl9faG92ZXJTdGwpO1xyXG4gICAgICAgIGVsLnoyICs9IDE7XHJcblxyXG4gICAgICAgIGVsLl9faXNIb3ZlciA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZG9TaW5nbGVMZWF2ZUhvdmVyKGVsKSB7XHJcbiAgICAgICAgaWYgKCFlbC5fX2lzSG92ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG5vcm1hbFN0bCA9IGVsLl9fbm9ybWFsU3RsO1xyXG4gICAgICAgIG5vcm1hbFN0bCAmJiBlbC5zZXRTdHlsZShub3JtYWxTdGwpO1xyXG4gICAgICAgIGVsLnoyIC09IDE7XHJcblxyXG4gICAgICAgIGVsLl9faXNIb3ZlciA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRvRW50ZXJIb3ZlcihlbCkge1xyXG4gICAgICAgIGVsLnR5cGUgPT09ICdncm91cCdcclxuICAgICAgICAgICAgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9TaW5nbGVFbnRlckhvdmVyKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgOiBkb1NpbmdsZUVudGVySG92ZXIoZWwpO1xyXG4gICAgfVxyXG4gICAgZ3JhcGhpYy5kb0VudGVySG92ZXIgPSBkb0VudGVySG92ZXI7XHJcbiAgICBmdW5jdGlvbiBkb0xlYXZlSG92ZXIoZWwpIHtcclxuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXHJcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvU2luZ2xlTGVhdmVIb3ZlcihjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogZG9TaW5nbGVMZWF2ZUhvdmVyKGVsKTtcclxuICAgIH1cclxuICAgIGdyYXBoaWMuZG9MZWF2ZUhvdmVyID0gZG9MZWF2ZUhvdmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0bCkge1xyXG4gICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIHNlcGNpZmllZCBob3ZlclN0eWxlLCB0aGVuIHVzZSBpdCBpbnN0ZWFkIG9mIGdpdmVuIGhvdmVyU3R5bGVcclxuICAgICAgICAvLyBPZnRlbiB1c2VkIHdoZW4gaXRlbSBncm91cCBoYXMgYSBsYWJlbCBlbGVtZW50IGFuZCBpdCdzIGhvdmVyU3R5bGUgaXMgZGlmZmVyZW50XHJcbiAgICAgICAgZWwuX19ob3ZlclN0bCA9IGVsLmhvdmVyU3R5bGUgfHwgaG92ZXJTdGwgfHwge307XHJcbiAgICAgICAgZWwuX19ob3ZlclN0bERpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdyYXBoaWMuc2V0RWxlbWVudEhvdmVyU3RsID0gc2V0RWxlbWVudEhvdmVyU3RsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdmVyKCkge1xyXG4gICAgICAgIC8vIE9ubHkgaWYgZWxlbWVudCBpcyBub3QgaW4gZW1waGFzaXMgc3RhdHVzXHJcbiAgICAgICAgIXRoaXMuX19pc0VtcGhhc2lzICYmIGRvRW50ZXJIb3Zlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvbkVsZW1lbnRNb3VzZU91dCgpIHtcclxuICAgICAgICAvLyBPbmx5IGlmIGVsZW1lbnQgaXMgbm90IGluIGVtcGhhc2lzIHN0YXR1c1xyXG4gICAgICAgICF0aGlzLl9faXNFbXBoYXNpcyAmJiBkb0xlYXZlSG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZW50ZXJFbXBoYXNpcygpIHtcclxuICAgICAgICB0aGlzLl9faXNFbXBoYXNpcyA9IHRydWU7XHJcbiAgICAgICAgZG9FbnRlckhvdmVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGxlYXZlRW1waGFzaXMoKSB7XHJcbiAgICAgICAgdGhpcy5fX2lzRW1waGFzaXMgPSBmYWxzZTtcclxuICAgICAgICBkb0xlYXZlSG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgaG92ZXIgc3R5bGUgb2YgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtob3ZlclN0eWxlXVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnNldEhvdmVyU3R5bGUgPSBmdW5jdGlvbiAoZWwsIGhvdmVyU3R5bGUpIHtcclxuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXHJcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRIb3ZlclN0bChjaGlsZCwgaG92ZXJTdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0eWxlKTtcclxuICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgYm91bmQgaGFuZGxlcnNcclxuICAgICAgICBlbC5vbignbW91c2VvdmVyJywgb25FbGVtZW50TW91c2VPdmVyKVxyXG4gICAgICAgICAgLm9uKCdtb3VzZW91dCcsIG9uRWxlbWVudE1vdXNlT3V0KTtcclxuXHJcbiAgICAgICAgLy8gRW1waGFzaXMsIG5vcm1hbCBjYW4gYmUgdHJpZ2dlcmVkIG1hbnVhbGx5XHJcbiAgICAgICAgZWwub24oJ2VtcGhhc2lzJywgZW50ZXJFbXBoYXNpcylcclxuICAgICAgICAgIC5vbignbm9ybWFsJywgbGVhdmVFbXBoYXNpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChlbC5fX25vcm1hbFN0bCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5fX25vcm1hbFN0bC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLl9fbm9ybWFsU3RsW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGV4dCBvcHRpb24gaW4gdGhlIHN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBsYWJlbE1vZGVsXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHRTdHlsZSwgbGFiZWxNb2RlbCwgY29sb3IpIHtcclxuICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygncG9zaXRpb24nKSB8fCAnaW5zaWRlJztcclxuICAgICAgICB2YXIgbGFiZWxDb2xvciA9IGxhYmVsUG9zaXRpb24uaW5kZXhPZignaW5zaWRlJykgPj0gMCA/ICd3aGl0ZScgOiBjb2xvcjtcclxuICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBsYWJlbE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcclxuICAgICAgICB6clV0aWwuZXh0ZW5kKHRleHRTdHlsZSwge1xyXG4gICAgICAgICAgICB0ZXh0RGlzdGFuY2U6IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnZGlzdGFuY2UnKSB8fCA1LFxyXG4gICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxyXG4gICAgICAgICAgICB0ZXh0UG9zaXRpb246IGxhYmVsUG9zaXRpb24sXHJcbiAgICAgICAgICAgIHRleHRGaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSB8fCBsYWJlbENvbG9yXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGFuaW1hdGVPclNldFByb3BzKGlzVXBkYXRlLCBlbCwgcHJvcHMsIGFuaW1hdGFibGVNb2RlbCwgY2IpIHtcclxuICAgICAgICB2YXIgcG9zdGZpeCA9IGlzVXBkYXRlID8gJ1VwZGF0ZScgOiAnJztcclxuICAgICAgICB2YXIgZHVyYXRpb24gPSBhbmltYXRhYmxlTW9kZWxcclxuICAgICAgICAgICAgJiYgYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkR1cmF0aW9uJyArIHBvc3RmaXgpO1xyXG4gICAgICAgIHZhciBhbmltYXRpb25FYXNpbmcgPSBhbmltYXRhYmxlTW9kZWxcclxuICAgICAgICAgICAgJiYgYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkVhc2luZycgKyBwb3N0Zml4KTtcclxuXHJcbiAgICAgICAgYW5pbWF0YWJsZU1vZGVsICYmIGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb24nKVxyXG4gICAgICAgICAgICA/IGVsLmFuaW1hdGVUbyhwcm9wcywgZHVyYXRpb24sIGFuaW1hdGlvbkVhc2luZywgY2IpXHJcbiAgICAgICAgICAgIDogKGVsLmF0dHIocHJvcHMpLCBjYiAmJiBjYigpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy51cGRhdGVQcm9wcyA9IHpyVXRpbC5jdXJyeShhbmltYXRlT3JTZXRQcm9wcywgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0IGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5pbml0UHJvcHMgPSB6clV0aWwuY3VycnkoYW5pbWF0ZU9yU2V0UHJvcHMsIGZhbHNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0cmFuc2Zvcm0gbWF0cml4IG9mIHRhcmdldCAocGFyYW0gdGFyZ2V0KSxcclxuICAgICAqIGluIGNvb3JkaW5hdGUgb2YgaXRzIGFuY2VzdG9yIChwYXJhbSBhbmNlc3RvcilcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9IHRhcmdldFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfSBhbmNlc3RvclxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0YXJnZXQsIGFuY2VzdG9yKSB7XHJcbiAgICAgICAgdmFyIG1hdCA9IG1hdHJpeC5pZGVudGl0eShbXSk7XHJcblxyXG4gICAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBhbmNlc3Rvcikge1xyXG4gICAgICAgICAgICBtYXRyaXgubXVsKG1hdCwgdGFyZ2V0LmdldExvY2FsVHJhbnNmb3JtKCksIG1hdCk7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWF0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IHRyYW5zZm9ybSB0byBhbiB2ZXJ0ZXguXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZXJ0ZXggW3gsIHldXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxyXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFt4LCB5XVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKHZlcnRleCwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcclxuICAgICAgICBpZiAoaW52ZXJ0KSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IG1hdHJpeC5pbnZlcnQoW10sIHRyYW5zZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0oW10sIHZlcnRleCwgdHJhbnNmb3JtKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUcmFuc2Zvcm1lZCBkaXJlY3Rpb24uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMudHJhbnNmb3JtRGlyZWN0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcclxuXHJcbiAgICAgICAgLy8gUGljayBhIGJhc2UsIGVuc3VyZSB0aGF0IHRyYW5zZm9ybSByZXN1bHQgd2lsbCBub3QgYmUgKDAsIDApLlxyXG4gICAgICAgIHZhciBoQmFzZSA9ICh0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVswXSA9PT0gMClcclxuICAgICAgICAgICAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVswXSk7XHJcbiAgICAgICAgdmFyIHZCYXNlID0gKHRyYW5zZm9ybVs0XSA9PT0gMCB8fCB0cmFuc2Zvcm1bNV0gPT09IDAgfHwgdHJhbnNmb3JtWzJdID09PSAwKVxyXG4gICAgICAgICAgICA/IDEgOiBNYXRoLmFicygyICogdHJhbnNmb3JtWzRdIC8gdHJhbnNmb3JtWzJdKTtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRleCA9IFtcclxuICAgICAgICAgICAgZGlyZWN0aW9uID09PSAnbGVmdCcgPyAtaEJhc2UgOiBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyBoQmFzZSA6IDAsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3RvcCcgPyAtdkJhc2UgOiBkaXJlY3Rpb24gPT09ICdib3R0b20nID8gdkJhc2UgOiAwXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgdmVydGV4ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSh2ZXJ0ZXgsIHRyYW5zZm9ybSwgaW52ZXJ0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHZlcnRleFswXSkgPiBNYXRoLmFicyh2ZXJ0ZXhbMV0pXHJcbiAgICAgICAgICAgID8gKHZlcnRleFswXSA+IDAgPyAncmlnaHQnIDogJ2xlZnQnKVxyXG4gICAgICAgICAgICA6ICh2ZXJ0ZXhbMV0gPiAwID8gJ2JvdHRvbScgOiAndG9wJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gZ3JhcGhpYztcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL3V0aWxcbiAqL1xuXG5cbiAgICAvLyDnlKjkuo7lpITnkIZtZXJnZeaXtuaXoOazlemBjeWOhkRhdGXnrYnlr7nosaHnmoTpl67pophcbiAgICB2YXIgQlVJTFRJTl9PQkpFQ1QgPSB7XG4gICAgICAgICdbb2JqZWN0IEZ1bmN0aW9uXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IFJlZ0V4cF0nOiAxLFxuICAgICAgICAnW29iamVjdCBEYXRlXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IEVycm9yXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJzogMSxcbiAgICAgICAgLy8gRm9yIG5vZGUtY2FudmFzXG4gICAgICAgICdbb2JqZWN0IEltYWdlXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IENhbnZhc10nOiAxXG4gICAgfTtcblxuICAgIHZhciBUWVBFRF9BUlJBWSA9IHtcbiAgICAgICAgJ1tvYmplY3QgSW50OEFycmF5XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJzogMSxcbiAgICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJzogMSxcbiAgICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBJbnQzMkFycmF5XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJzogMVxuICAgIH07XG5cbiAgICB2YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gICAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG4gICAgdmFyIG5hdGl2ZUZvckVhY2ggPSBhcnJheVByb3RvLmZvckVhY2g7XG4gICAgdmFyIG5hdGl2ZUZpbHRlciA9IGFycmF5UHJvdG8uZmlsdGVyO1xuICAgIHZhciBuYXRpdmVTbGljZSA9IGFycmF5UHJvdG8uc2xpY2U7XG4gICAgdmFyIG5hdGl2ZU1hcCA9IGFycmF5UHJvdG8ubWFwO1xuICAgIHZhciBuYXRpdmVSZWR1Y2UgPSBhcnJheVByb3RvLnJlZHVjZTtcblxuICAgIC8qKlxuICAgICAqIFRob3NlIGRhdGEgdHlwZXMgY2FuIGJlIGNsb25lZDpcbiAgICAgKiAgICAgUGxhaW4gb2JqZWN0LCBBcnJheSwgVHlwZWRBcnJheSwgbnVtYmVyLCBzdHJpbmcsIG51bGwsIHVuZGVmaW5lZC5cbiAgICAgKiBUaG9zZSBkYXRhIHR5cGVzIHdpbGwgYmUgYXNzZ2luZWQgdXNpbmcgdGhlIG9yZ2luYWwgZGF0YTpcbiAgICAgKiAgICAgQlVJTFRJTl9PQkpFQ1RcbiAgICAgKiBJbnN0YW5jZSBvZiB1c2VyIGRlZmluZWQgY2xhc3Mgd2lsbCBiZSBjbG9uZWQgdG8gYSBwbGFpbiBvYmplY3QsIHdpdGhvdXRcbiAgICAgKiBwcm9wZXJ0aWVzIGluIHByb3RvdHlwZS5cbiAgICAgKiBPdGhlciBkYXRhIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQgKG5vdCBzdXJlIHdoYXQgd2lsbCBoYXBwZW4pLlxuICAgICAqXG4gICAgICogQ2F1dGlvbjogZG8gbm90IHN1cHBvcnQgY2xvbmUgRGF0ZSwgZm9yIHBlcmZvcm1hbmNlIGNvbnNpZGVyYXRpb24uXG4gICAgICogKFRoZXJlIG1pZ2h0IGJlIGEgbGFyZ2UgbnVtYmVyIG9mIGRhdGUgaW4gYHNlcmllcy5kYXRhYCkuXG4gICAgICogU28gZGF0ZSBzaG91bGQgbm90IGJlIG1vZGlmaWVkIGluIGFuZCBvdXQgb2YgZWNoYXJ0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlXG4gICAgICogQHJldHVybiB7Kn0gbmV3XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UgPT0gbnVsbCB8fCB0eXBlb2Ygc291cmNlICE9ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHNvdXJjZTtcbiAgICAgICAgdmFyIHR5cGVTdHIgPSBvYmpUb1N0cmluZy5jYWxsKHNvdXJjZSk7XG5cbiAgICAgICAgaWYgKHR5cGVTdHIgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNsb25lKHNvdXJjZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVFlQRURfQVJSQVlbdHlwZVN0cl0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZS5jb25zdHJ1Y3Rvci5mcm9tKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIUJVSUxUSU5fT0JKRUNUW3R5cGVTdHJdICYmICFpc1ByaW1pdGl2ZShzb3VyY2UpICYmICFpc0RvbShzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjbG9uZShzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3ZlcndyaXRlKSB7XG4gICAgICAgIC8vIFdlIHNob3VsZCBlc2NhcHNlIHRoYXQgc291cmNlIGlzIHN0cmluZ1xuICAgICAgICAvLyBhbmQgZW50ZXIgZm9yIC4uLiBpbiAuLi5cbiAgICAgICAgaWYgKCFpc09iamVjdChzb3VyY2UpIHx8ICFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3ZlcndyaXRlID8gY2xvbmUoc291cmNlKSA6IHRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRQcm9wID0gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZVByb3AgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChzb3VyY2VQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiBpc09iamVjdCh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNBcnJheShzb3VyY2VQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNBcnJheSh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNEb20oc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzRG9tKHRhcmdldFByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0J1aWx0SW5PYmplY3Qoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzQnVpbHRJbk9iamVjdCh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNQcmltaXRpdmUoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzUHJpbWl0aXZlKHRhcmdldFByb3ApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOmcgOimgemAkuW9kuimhueblu+8jOWwsemAkuW9kuiwg+eUqG1lcmdlXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlKHRhcmdldFByb3AsIHNvdXJjZVByb3AsIG92ZXJ3cml0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJ3cml0ZSB8fCAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWQpuWImeWPquWkhOeQhm92ZXJ3cml0ZeS4unRydWXvvIzmiJbogIXlnKjnm67moIflr7nosaHkuK3msqHmnInmraTlsZ7mgKfnmoTmg4XlhrVcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URe+8jOWcqCB0YXJnZXRba2V5XSDkuI3lrZjlnKjnmoTml7blgJnkuZ/mmK/nm7TmjqXopobnm5ZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzb3VyY2Vba2V5XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRBbmRTb3VyY2VzIFRoZSBmaXJzdCBpdGVtIGlzIHRhcmdldCwgYW5kIHRoZSByZXN0cyBhcmUgc291cmNlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHsqfSB0YXJnZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZUFsbCh0YXJnZXRBbmRTb3VyY2VzLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldEFuZFNvdXJjZXNbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0YXJnZXRBbmRTb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBtZXJnZShyZXN1bHQsIHRhcmdldEFuZFNvdXJjZXNbaV0sIG92ZXJ3cml0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVufSBbb3ZlcmxheT1mYWxzZV1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmYXVsdHModGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpXG4gICAgICAgICAgICAgICAgJiYgKG92ZXJsYXkgPyBzb3VyY2Vba2V5XSAhPSBudWxsIDogdGFyZ2V0W2tleV0gPT0gbnVsbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDYW52YXMoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9XG4gICAgLy8gRklYTUVcbiAgICB2YXIgX2N0eDtcbiAgICBmdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICAgICAgICBpZiAoIV9jdHgpIHtcbiAgICAgICAgICAgIC8vIFVzZSB1dGlsLmNyZWF0ZUNhbnZhcyBpbnN0ZWFkIG9mIGNyZWF0ZUNhbnZhc1xuICAgICAgICAgICAgLy8gYmVjYXVzZSBjcmVhdGVDYW52YXMgbWF5IGJlIG92ZXJ3cml0dGVuIGluIGRpZmZlcmVudCBlbnZpcm9ubWVudFxuICAgICAgICAgICAgX2N0eCA9IHV0aWwuY3JlYXRlQ2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2N0eDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmn6Xor6LmlbDnu4TkuK3lhYPntKDnmoRpbmRleFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChhcnJheS5pbmRleE9mKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaehOmAoOexu+e7p+aJv+WFs+ezu1xuICAgICAqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsYXp6IOa6kOexu1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VDbGF6eiDln7rnsbtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmhlcml0cyhjbGF6eiwgYmFzZUNsYXp6KSB7XG4gICAgICAgIHZhciBjbGF6elByb3RvdHlwZSA9IGNsYXp6LnByb3RvdHlwZTtcbiAgICAgICAgZnVuY3Rpb24gRigpIHt9XG4gICAgICAgIEYucHJvdG90eXBlID0gYmFzZUNsYXp6LnByb3RvdHlwZTtcbiAgICAgICAgY2xhenoucHJvdG90eXBlID0gbmV3IEYoKTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGNsYXp6UHJvdG90eXBlKSB7XG4gICAgICAgICAgICBjbGF6ei5wcm90b3R5cGVbcHJvcF0gPSBjbGF6elByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICBjbGF6ei5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjbGF6ejtcbiAgICAgICAgY2xhenouc3VwZXJDbGFzcyA9IGJhc2VDbGF6ejtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHRhcmdldFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBzb3JjZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcmxheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKHRhcmdldCwgc291cmNlLCBvdmVybGF5KSB7XG4gICAgICAgIHRhcmdldCA9ICdwcm90b3R5cGUnIGluIHRhcmdldCA/IHRhcmdldC5wcm90b3R5cGUgOiB0YXJnZXQ7XG4gICAgICAgIHNvdXJjZSA9ICdwcm90b3R5cGUnIGluIHNvdXJjZSA/IHNvdXJjZS5wcm90b3R5cGUgOiBzb3VyY2U7XG5cbiAgICAgICAgZGVmYXVsdHModGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl8VHlwZWRBcnJheX0gZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKGRhdGEpIHtcbiAgICAgICAgaWYgKCEgZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGF0YS5sZW5ndGggPT0gJ251bWJlcic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5pWw57uE5oiW5a+56LGh6YGN5Y6GXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZWFjaChvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLmZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IG5hdGl2ZUZvckVhY2gpIHtcbiAgICAgICAgICAgIG9iai5mb3JFYWNoKGNiLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5pWw57uE5pig5bCEXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAob2JqLCBjYiwgY29udGV4dCkge1xuICAgICAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5tYXAgJiYgb2JqLm1hcCA9PT0gbmF0aXZlTWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLm1hcChjYiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbWVtb11cbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShvYmosIGNiLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnJlZHVjZSAmJiBvYmoucmVkdWNlID09PSBuYXRpdmVSZWR1Y2UpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoucmVkdWNlKGNiLCBtZW1vLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gY2IuY2FsbChjb250ZXh0LCBtZW1vLCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaVsOe7hOi/h+a7pFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmouZmlsdGVyICYmIG9iai5maWx0ZXIgPT09IG5hdGl2ZUZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5maWx0ZXIoY2IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmpbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4Tpobnmn6Xmib5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmQob2JqLCBjYiwgY29udGV4dCkge1xuICAgICAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ialtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZChmdW5jLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQobmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jKSB7XG4gICAgICAgIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncy5jb25jYXQobmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgKCEhdmFsdWUgJiYgdHlwZSA9PSAnb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQnVpbHRJbk9iamVjdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISFCVUlMVElOX09CSkVDVFtvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRG9tKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAmJiB0eXBlb2YgdmFsdWUubm9kZVR5cGUgPT09ICdudW1iZXInXG4gICAgICAgICAgICAmJiB0eXBlb2YgdmFsdWUub3duZXJEb2N1bWVudCA9PT0gJ29iamVjdCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBpcyBleGFjdGx5IE5hTi4gTm90aWNlIGlzTmFOKCdhJykgcmV0dXJucyB0cnVlLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxTmFOKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdmFsdWUxIGlzIG5vdCBudWxsLCB0aGVuIHJldHVybiB2YWx1ZTEsIG90aGVyd2lzZSBqdWRnZXQgcmVzdCBvZiB2YWx1ZXMuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEByZXR1cm4geyp9IEZpbmFsIHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cmlldmUodmFsdWVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kSW5kZXhcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbGljZSgpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLmNhbGwuYXBwbHkobmF0aXZlU2xpY2UsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJpbWl0aXZlS2V5ID0gJ19fZWNfcHJpbWl0aXZlX18nO1xuICAgIC8qKlxuICAgICAqIFNldCBhbiBvYmplY3QgYXMgcHJpbWl0aXZlIHRvIGJlIGlnbm9yZWQgdHJhdmVyc2luZyBjaGlsZHJlbiBpbiBjbG9uZSBvciBtZXJnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEFzUHJpbWl0aXZlKG9iaikge1xuICAgICAgICBvYmpbcHJpbWl0aXZlS2V5XSA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQcmltaXRpdmUob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmpbcHJpbWl0aXZlS2V5XTtcbiAgICB9XG5cbiAgICB2YXIgdXRpbCA9IHtcbiAgICAgICAgaW5oZXJpdHM6IGluaGVyaXRzLFxuICAgICAgICBtaXhpbjogbWl4aW4sXG4gICAgICAgIGNsb25lOiBjbG9uZSxcbiAgICAgICAgbWVyZ2U6IG1lcmdlLFxuICAgICAgICBtZXJnZUFsbDogbWVyZ2VBbGwsXG4gICAgICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgICAgIGdldENvbnRleHQ6IGdldENvbnRleHQsXG4gICAgICAgIGNyZWF0ZUNhbnZhczogY3JlYXRlQ2FudmFzLFxuICAgICAgICBpbmRleE9mOiBpbmRleE9mLFxuICAgICAgICBzbGljZTogc2xpY2UsXG4gICAgICAgIGZpbmQ6IGZpbmQsXG4gICAgICAgIGlzQXJyYXlMaWtlOiBpc0FycmF5TGlrZSxcbiAgICAgICAgZWFjaDogZWFjaCxcbiAgICAgICAgbWFwOiBtYXAsXG4gICAgICAgIHJlZHVjZTogcmVkdWNlLFxuICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgYmluZDogYmluZCxcbiAgICAgICAgY3Vycnk6IGN1cnJ5LFxuICAgICAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgICAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgICAgIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgICAgICAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgICAgICAgaXNCdWlsdEluT2JqZWN0OiBpc0J1aWx0SW5PYmplY3QsXG4gICAgICAgIGlzRG9tOiBpc0RvbSxcbiAgICAgICAgZXFOYU46IGVxTmFOLFxuICAgICAgICByZXRyaWV2ZTogcmV0cmlldmUsXG4gICAgICAgIGFzc2VydDogYXNzZXJ0LFxuICAgICAgICBzZXRBc1ByaW1pdGl2ZTogc2V0QXNQcmltaXRpdmUsXG4gICAgICAgIG5vb3A6IGZ1bmN0aW9uICgpIHt9XG4gICAgfTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHV0aWw7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIFBhdGggPSByZXF1aXJlKCcuLi9ncmFwaGljL1BhdGgnKTtcbiAgICB2YXIgUGF0aFByb3h5ID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKTtcbiAgICB2YXIgdHJhbnNmb3JtUGF0aCA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtUGF0aCcpO1xuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCcuLi9jb3JlL21hdHJpeCcpO1xuXG4gICAgLy8gY29tbWFuZCBjaGFyc1xuICAgIHZhciBjYyA9IFtcbiAgICAgICAgJ20nLCAnTScsICdsJywgJ0wnLCAndicsICdWJywgJ2gnLCAnSCcsICd6JywgJ1onLFxuICAgICAgICAnYycsICdDJywgJ3EnLCAnUScsICd0JywgJ1QnLCAncycsICdTJywgJ2EnLCAnQSdcbiAgICBdO1xuXG4gICAgdmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBtYXRoU2luID0gTWF0aC5zaW47XG4gICAgdmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgUEkgPSBNYXRoLlBJO1xuXG4gICAgdmFyIHZNYWcgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodlswXSAqIHZbMF0gKyB2WzFdICogdlsxXSk7XG4gICAgfTtcbiAgICB2YXIgdlJhdGlvID0gZnVuY3Rpb24odSwgdikge1xuICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pIC8gKHZNYWcodSkgKiB2TWFnKHYpKTtcbiAgICB9O1xuICAgIHZhciB2QW5nbGUgPSBmdW5jdGlvbih1LCB2KSB7XG4gICAgICAgIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSlcbiAgICAgICAgICAgICAgICAqIE1hdGguYWNvcyh2UmF0aW8odSwgdikpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQXJjKHgxLCB5MSwgeDIsIHkyLCBmYSwgZnMsIHJ4LCByeSwgcHNpRGVnLCBjbWQsIHBhdGgpIHtcbiAgICAgICAgdmFyIHBzaSA9IHBzaURlZyAqIChQSSAvIDE4MC4wKTtcbiAgICAgICAgdmFyIHhwID0gbWF0aENvcyhwc2kpICogKHgxIC0geDIpIC8gMi4wXG4gICAgICAgICAgICAgICAgICsgbWF0aFNpbihwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuICAgICAgICB2YXIgeXAgPSAtMSAqIG1hdGhTaW4ocHNpKSAqICh4MSAtIHgyKSAvIDIuMFxuICAgICAgICAgICAgICAgICArIG1hdGhDb3MocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcblxuICAgICAgICB2YXIgbGFtYmRhID0gKHhwICogeHApIC8gKHJ4ICogcngpICsgKHlwICogeXApIC8gKHJ5ICogcnkpO1xuXG4gICAgICAgIGlmIChsYW1iZGEgPiAxKSB7XG4gICAgICAgICAgICByeCAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgICAgICAgICAgcnkgKj0gbWF0aFNxcnQobGFtYmRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmID0gKGZhID09PSBmcyA/IC0xIDogMSlcbiAgICAgICAgICAgICogbWF0aFNxcnQoKCgocnggKiByeCkgKiAocnkgKiByeSkpXG4gICAgICAgICAgICAgICAgICAgIC0gKChyeCAqIHJ4KSAqICh5cCAqIHlwKSlcbiAgICAgICAgICAgICAgICAgICAgLSAoKHJ5ICogcnkpICogKHhwICogeHApKSkgLyAoKHJ4ICogcngpICogKHlwICogeXApXG4gICAgICAgICAgICAgICAgICAgICsgKHJ5ICogcnkpICogKHhwICogeHApKVxuICAgICAgICAgICAgICAgICkgfHwgMDtcblxuICAgICAgICB2YXIgY3hwID0gZiAqIHJ4ICogeXAgLyByeTtcbiAgICAgICAgdmFyIGN5cCA9IGYgKiAtcnkgKiB4cCAvIHJ4O1xuXG4gICAgICAgIHZhciBjeCA9ICh4MSArIHgyKSAvIDIuMFxuICAgICAgICAgICAgICAgICArIG1hdGhDb3MocHNpKSAqIGN4cFxuICAgICAgICAgICAgICAgICAtIG1hdGhTaW4ocHNpKSAqIGN5cDtcbiAgICAgICAgdmFyIGN5ID0gKHkxICsgeTIpIC8gMi4wXG4gICAgICAgICAgICAgICAgKyBtYXRoU2luKHBzaSkgKiBjeHBcbiAgICAgICAgICAgICAgICArIG1hdGhDb3MocHNpKSAqIGN5cDtcblxuICAgICAgICB2YXIgdGhldGEgPSB2QW5nbGUoWyAxLCAwIF0sIFsgKHhwIC0gY3hwKSAvIHJ4LCAoeXAgLSBjeXApIC8gcnkgXSk7XG4gICAgICAgIHZhciB1ID0gWyAoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeSBdO1xuICAgICAgICB2YXIgdiA9IFsgKC0xICogeHAgLSBjeHApIC8gcngsICgtMSAqIHlwIC0gY3lwKSAvIHJ5IF07XG4gICAgICAgIHZhciBkVGhldGEgPSB2QW5nbGUodSwgdik7XG5cbiAgICAgICAgaWYgKHZSYXRpbyh1LCB2KSA8PSAtMSkge1xuICAgICAgICAgICAgZFRoZXRhID0gUEk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZSYXRpbyh1LCB2KSA+PSAxKSB7XG4gICAgICAgICAgICBkVGhldGEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcyA9PT0gMCAmJiBkVGhldGEgPiAwKSB7XG4gICAgICAgICAgICBkVGhldGEgPSBkVGhldGEgLSAyICogUEk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZzID09PSAxICYmIGRUaGV0YSA8IDApIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBQSTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoUHJveHlGcm9tU3RyaW5nKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb21tYW5kIHN0cmluZ1xuICAgICAgICB2YXIgY3MgPSBkYXRhLnJlcGxhY2UoLy0vZywgJyAtJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8gIC9nLCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZSgvIC9nLCAnLCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvLCwvZywgJywnKTtcblxuICAgICAgICB2YXIgbjtcbiAgICAgICAgLy8gY3JlYXRlIHBpcGVzIHNvIHRoYXQgd2UgY2FuIHNwbGl0IHRoZSBkYXRhXG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBjYy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgY3MgPSBjcy5yZXBsYWNlKG5ldyBSZWdFeHAoY2Nbbl0sICdnJyksICd8JyArIGNjW25dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhcnJheVxuICAgICAgICB2YXIgYXJyID0gY3Muc3BsaXQoJ3wnKTtcbiAgICAgICAgLy8gaW5pdCBjb250ZXh0IHBvaW50XG4gICAgICAgIHZhciBjcHggPSAwO1xuICAgICAgICB2YXIgY3B5ID0gMDtcblxuICAgICAgICB2YXIgcGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICAgICAgdmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG5cbiAgICAgICAgdmFyIHByZXZDbWQ7XG4gICAgICAgIGZvciAobiA9IDE7IG4gPCBhcnIubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBhcnJbbl07XG4gICAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoMCk7XG4gICAgICAgICAgICB2YXIgb2ZmID0gMDtcbiAgICAgICAgICAgIHZhciBwID0gc3RyLnNsaWNlKDEpLnJlcGxhY2UoL2UsLS9nLCAnZS0nKS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgdmFyIGNtZDtcblxuICAgICAgICAgICAgaWYgKHAubGVuZ3RoID4gMCAmJiBwWzBdID09PSAnJykge1xuICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFtpXSA9IHBhcnNlRmxvYXQocFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAob2ZmIDwgcC5sZW5ndGggJiYgIWlzTmFOKHBbb2ZmXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocFswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjdGxQdHg7XG4gICAgICAgICAgICAgICAgdmFyIGN0bFB0eTtcblxuICAgICAgICAgICAgICAgIHZhciByeDtcbiAgICAgICAgICAgICAgICB2YXIgcnk7XG4gICAgICAgICAgICAgICAgdmFyIHBzaTtcbiAgICAgICAgICAgICAgICB2YXIgZmE7XG4gICAgICAgICAgICAgICAgdmFyIGZzO1xuXG4gICAgICAgICAgICAgICAgdmFyIHgxID0gY3B4O1xuICAgICAgICAgICAgICAgIHZhciB5MSA9IGNweTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJ2wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdMJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtZCwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY21kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5DKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELkMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IGNweCArIHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBjcHkgKyBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHBbb2ZmKytdICsgY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBwW29mZisrXSArIGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuUSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcnggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IGNweCwgeTEgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2ksIGNtZCwgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICByeSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBmYSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMgPSBwW29mZisrXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2ksIGNtZCwgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGMgPT09ICd6JyB8fCBjID09PSAnWicpIHtcbiAgICAgICAgICAgICAgICBjbWQgPSBDTUQuWjtcbiAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldkNtZCA9IGNtZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGgudG9TdGF0aWMoKTtcblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICAvLyBUT0RPIE9wdGltaXplIGRvdWJsZSBtZW1vcnkgY29zdCBwcm9ibGVtXG4gICAgZnVuY3Rpb24gY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSB7XG4gICAgICAgIHZhciBwYXRoUHJveHkgPSBjcmVhdGVQYXRoUHJveHlGcm9tU3RyaW5nKHN0cik7XG4gICAgICAgIHZhciB0cmFuc2Zvcm07XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBvcHRzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICBwYXRoLnNldERhdGEocGF0aFByb3h5LmRhdGEpO1xuICAgICAgICAgICAgdHJhbnNmb3JtICYmIHRyYW5zZm9ybVBhdGgocGF0aCwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgIC8vIFN2ZyBhbmQgdm1sIHJlbmRlcmVyIGRvbid0IGhhdmUgY29udGV4dFxuICAgICAgICAgICAgdmFyIGN0eCA9IHBhdGguZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgIHBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBvcHRzLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtID0gbWF0cml4LmNyZWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0cml4Lm11bCh0cmFuc2Zvcm0sIG0sIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5KHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgZnJvbSBwYXRoIHN0cmluZyBkYXRhXG4gICAgICAgICAqIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBPdGhlciBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVGcm9tU3RyaW5nOiBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhdGgoY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIFBhdGggY2xhc3MgZnJvbSBwYXRoIHN0cmluZyBkYXRhXG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBPdGhlciBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBleHRlbmRGcm9tU3RyaW5nOiBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gUGF0aC5leHRlbmQoY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1lcmdlIG11bHRpcGxlIHBhdGhzXG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPIEFwcGx5IHRyYW5zZm9ybVxuICAgICAgICAvLyBUT0RPIHN0cm9rZSBkYXNoXG4gICAgICAgIC8vIFRPRE8gT3B0aW1pemUgZG91YmxlIG1lbW9yeSBjb3N0IHByb2JsZW1cbiAgICAgICAgbWVyZ2VQYXRoOiBmdW5jdGlvbiAocGF0aEVscywgb3B0cykge1xuICAgICAgICAgICAgdmFyIHBhdGhMaXN0ID0gW107XG4gICAgICAgICAgICB2YXIgbGVuID0gcGF0aEVscy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhFbCA9IHBhdGhFbHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhFbC5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhFbC5idWlsZFBhdGgocGF0aEVsLnBhdGgsIHBhdGhFbC5zaGFwZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGhMaXN0LnB1c2gocGF0aEVsLnBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGF0aEJ1bmRsZSA9IG5ldyBQYXRoKG9wdHMpO1xuICAgICAgICAgICAgcGF0aEJ1bmRsZS5idWlsZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHBhdGguYXBwZW5kUGF0aChwYXRoTGlzdCk7XG4gICAgICAgICAgICAgICAgLy8gU3ZnIGFuZCB2bWwgcmVuZGVyZXIgZG9uJ3QgaGF2ZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHBhdGguZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5yZWJ1aWxkUGF0aChjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBwYXRoQnVuZGxlO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogUGF0aCBlbGVtZW50XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9QYXRoXG4gKi9cblxuXG5cbiAgICB2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKCcuL0Rpc3BsYXlhYmxlJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBQYXRoUHJveHkgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpO1xuICAgIHZhciBwYXRoQ29udGFpbiA9IHJlcXVpcmUoJy4uL2NvbnRhaW4vcGF0aCcpO1xuXG4gICAgdmFyIFBhdHRlcm4gPSByZXF1aXJlKCcuL1BhdHRlcm4nKTtcbiAgICB2YXIgZ2V0Q2FudmFzUGF0dGVybiA9IFBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm47XG5cbiAgICB2YXIgYWJzID0gTWF0aC5hYnM7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGF0aChvcHRzKSB7XG4gICAgICAgIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhdGggPSBuZXcgUGF0aFByb3h5KCk7XG4gICAgfVxuXG4gICAgUGF0aC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFBhdGgsXG5cbiAgICAgICAgdHlwZTogJ3BhdGgnLFxuXG4gICAgICAgIF9fZGlydHlQYXRoOiB0cnVlLFxuXG4gICAgICAgIHN0cm9rZUNvbnRhaW5UaHJlc2hvbGQ6IDUsXG5cbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICAgICAgdmFyIGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpO1xuICAgICAgICAgICAgdmFyIGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCk7XG4gICAgICAgICAgICB2YXIgZmlsbCA9IHN0eWxlLmZpbGw7XG4gICAgICAgICAgICB2YXIgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgICAgICAgICAgdmFyIGhhc0ZpbGxHcmFkaWVudCA9IGhhc0ZpbGwgJiYgISEoZmlsbC5jb2xvclN0b3BzKTtcbiAgICAgICAgICAgIHZhciBoYXNTdHJva2VHcmFkaWVudCA9IGhhc1N0cm9rZSAmJiAhIShzdHJva2UuY29sb3JTdG9wcyk7XG4gICAgICAgICAgICB2YXIgaGFzRmlsbFBhdHRlcm4gPSBoYXNGaWxsICYmICEhKGZpbGwuaW1hZ2UpO1xuICAgICAgICAgICAgdmFyIGhhc1N0cm9rZVBhdHRlcm4gPSBoYXNTdHJva2UgJiYgISEoc3Ryb2tlLmltYWdlKTtcblxuICAgICAgICAgICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBncmFkaWVudCBiZWNhdXNlIGJvdW5kaW5nIHJlY3QgbWF5IGNoYW5nZWRcbiAgICAgICAgICAgICAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgZmlsbCwgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2VHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgc3Ryb2tlLCByZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGdyYWRpZW50IG9yIHBhdHRlcm5cbiAgICAgICAgICAgIGlmIChoYXNGaWxsR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HIElmIG1heSBoYXZlIGFmZmVjdCB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fZmlsbEdyYWRpZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzRmlsbFBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ2V0Q2FudmFzUGF0dGVybi5jYWxsKGZpbGwsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzU3Ryb2tlR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLl9zdHJva2VHcmFkaWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc1N0cm9rZVBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoc3Ryb2tlLCBjdHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGluZURhc2ggPSBzdHlsZS5saW5lRGFzaDtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IHN0eWxlLmxpbmVEYXNoT2Zmc2V0O1xuXG4gICAgICAgICAgICB2YXIgY3R4TGluZURhc2ggPSAhIWN0eC5zZXRMaW5lRGFzaDtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHBhdGggc3gsIHN5XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmdldEdsb2JhbFNjYWxlKCk7XG4gICAgICAgICAgICBwYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7XG5cbiAgICAgICAgICAgIC8vIFByb3h5IGNvbnRleHRcbiAgICAgICAgICAgIC8vIFJlYnVpbGQgcGF0aCBpbiBmb2xsb3dpbmcgMiBjYXNlc1xuICAgICAgICAgICAgLy8gMS4gUGF0aCBpcyBkaXJ0eVxuICAgICAgICAgICAgLy8gMi4gUGF0aCBuZWVkcyBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmVEYXNoIHN0cm9raW5nLlxuICAgICAgICAgICAgLy8gICAgSW4gdGhpcyBjYXNlLCBsaW5lRGFzaCBpbmZvcm1hdGlvbiB3aWxsIG5vdCBiZSBzYXZlZCBpbiBQYXRoUHJveHlcbiAgICAgICAgICAgIGlmICh0aGlzLl9fZGlydHlQYXRoIHx8IChcbiAgICAgICAgICAgICAgICBsaW5lRGFzaCAmJiAhY3R4TGluZURhc2ggJiYgaGFzU3Ryb2tlXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHRoaXMucGF0aC5iZWdpblBhdGgoY3R4KTtcblxuICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgbGluZSBkYXNoIGJlZm9yZSBidWlsZCBwYXRoXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVEYXNoICYmICFjdHhMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRMaW5lRGFzaE9mZnNldChsaW5lRGFzaE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgcGF0aCBkaXJ0eSBmbGFnXG4gICAgICAgICAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGF5IHBhdGggYnVpbGRpbmdcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhc0ZpbGwgJiYgcGF0aC5maWxsKGN0eCk7XG5cbiAgICAgICAgICAgIGlmIChsaW5lRGFzaCAmJiBjdHhMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChsaW5lRGFzaCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhc1N0cm9rZSAmJiBwYXRoLnN0cm9rZShjdHgpO1xuXG4gICAgICAgICAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGxpbmVEYXNoXG4gICAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICAgICAgLy8gRHJhdyByZWN0IHRleHRcbiAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBXaGVuIGJ1bmRsaW5nIHBhdGgsIHNvbWUgc2hhcGUgbWF5IGRlY2lkZSBpZiB1c2UgbW92ZVRvIHRvIGJlZ2luIGEgbmV3IHN1YnBhdGggb3IgY2xvc2VQYXRoXG4gICAgICAgIC8vIExpa2UgaW4gY2lyY2xlXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGVDZmcsIGluQnVuZGxlKSB7fSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5fcmVjdDtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgbmVlZHNVcGRhdGVSZWN0ID0gIXJlY3Q7XG4gICAgICAgICAgICBpZiAobmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuXG4gICAgICAgICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkcyB1cGRhdGUgcmVjdCB3aXRoIHN0cm9rZSBsaW5lV2lkdGggd2hlblxuICAgICAgICAgICAgICAgIC8vIDEuIEVsZW1lbnQgY2hhbmdlcyBzY2FsZSBvciBsaW5lV2lkdGhcbiAgICAgICAgICAgICAgICAvLyAyLiBTaGFwZSBpcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgdmFyIHJlY3RXaXRoU3Ryb2tlID0gdGhpcy5fcmVjdFdpdGhTdHJva2UgfHwgKHRoaXMuX3JlY3RXaXRoU3Ryb2tlID0gcmVjdC5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5IHx8IG5lZWRzVXBkYXRlUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS5jb3B5KHJlY3QpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBNdXN0IGFmdGVyIHVwZGF0ZVRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUEVORElORywgTWluIGxpbmUgd2lkdGggaXMgbmVlZGVkIHdoZW4gbGluZSBpcyBob3Jpem9udGFsIG9yIHZlcnRpY2FsXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhZGQgZXh0cmEgaG92ZXIgbGluZVdpZHRoIHdoZW4gdGhlcmUgYXJlIG5vIGZpbGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSBNYXRoLm1heCh3LCB0aGlzLnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQgfHwgNCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgbGluZSB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIHNjYWxlIGNhbid0IGJlIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2Uud2lkdGggKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLmhlaWdodCArPSB3IC8gbGluZVNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2UueCAtPSB3IC8gbGluZVNjYWxlIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnkgLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gcmVjdCB3aXRoIHN0cm9rZVxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0V2l0aFN0cm9rZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbFBvcyA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHggPSBsb2NhbFBvc1swXTtcbiAgICAgICAgICAgIHkgPSBsb2NhbFBvc1sxXTtcblxuICAgICAgICAgICAgaWYgKHJlY3QuY29udGFpbih4LCB5KSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMucGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVNjYWxlID0gc3R5bGUuc3Ryb2tlTm9TY2FsZSA/IHRoaXMuZ2V0TGluZVNjYWxlKCkgOiAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIHNjYWxlIGNhbid0IGJlIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhZGQgZXh0cmEgaG92ZXIgbGluZVdpZHRoIHdoZW4gdGhlcmUgYXJlIG5vIGZpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoID0gTWF0aC5tYXgobGluZVdpZHRoLCB0aGlzLnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhDb250YWluLmNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aERhdGEsIGxpbmVXaWR0aCAvIGxpbmVTY2FsZSwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhDb250YWluLmNvbnRhaW4ocGF0aERhdGEsIHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gZGlydHlQYXRoXG4gICAgICAgICAqL1xuICAgICAgICBkaXJ0eTogZnVuY3Rpb24gKGRpcnR5UGF0aCkge1xuICAgICAgICAgICAgaWYgKGRpcnR5UGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlydHlQYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgbWFyayBkaXJ0eSwgbm90IG1hcmsgY2xlYW5cbiAgICAgICAgICAgIGlmIChkaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZGlydHlQYXRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcblxuICAgICAgICAgICAgLy8gVXNlZCBhcyBhIGNsaXBwaW5nIHBhdGhcbiAgICAgICAgICAgIGlmICh0aGlzLl9fY2xpcFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19jbGlwVGFyZ2V0LmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWFzIGZvciBhbmltYXRlKCdzaGFwZScpXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0ZVNoYXBlOiBmdW5jdGlvbiAobG9vcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgnc2hhcGUnLCBsb29wKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBPdmVyd3JpdGUgYXR0cktWXG4gICAgICAgIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnc2hhcGUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBEaXNwbGF5YWJsZS5wcm90b3R5cGUuYXR0cktWLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIHNldFNoYXBlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgIC8vIFBhdGggZnJvbSBzdHJpbmcgbWF5IG5vdCBoYXZlIHNoYXBlXG4gICAgICAgICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZVtuYW1lXSA9IGtleVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGluZVNjYWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBsaW5lIHNjYWxlLlxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5hbnQgb2YgYG1gIG1lYW5zIGhvdyBtdWNoIHRoZSBhcmVhIGlzIGVubGFyZ2VkIGJ5IHRoZVxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgICAgICAgICAgLy8gZm9yIHdpZHRoLlxuICAgICAgICAgICAgcmV0dXJuIG0gJiYgYWJzKG1bMF0gLSAxKSA+IDFlLTEwICYmIGFicyhtWzNdIC0gMSkgPiAxZS0xMFxuICAgICAgICAgICAgICAgID8gTWF0aC5zcXJ0KGFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKSlcbiAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5omp5bGV5LiA5LiqIFBhdGggZWxlbWVudCwg5q+U5aaC5pif5b2i77yM5ZyG562J44CCXG4gICAgICogRXh0ZW5kIGEgcGF0aCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BzLnR5cGUgUGF0aCB0eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuaW5pdCBJbml0aWFsaXplXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuYnVpbGRQYXRoIE92ZXJ3cml0ZSBidWlsZFBhdGggbWV0aG9kXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5zdHlsZV0gRXh0ZW5kZWQgZGVmYXVsdCBzdHlsZSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnNoYXBlXSBFeHRlbmRlZCBkZWZhdWx0IHNoYXBlIGNvbmZpZ1xuICAgICAqL1xuICAgIFBhdGguZXh0ZW5kID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBTdWIgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgUGF0aC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgICAgICBpZiAoZGVmYXVsdHMuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRlbmQgZGVmYXVsdCBzdHlsZVxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuZXh0ZW5kRnJvbShkZWZhdWx0cy5zdHlsZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFeHRlbmQgZGVmYXVsdCBzaGFwZVxuICAgICAgICAgICAgdmFyIGRlZmF1bHRTaGFwZSA9IGRlZmF1bHRzLnNoYXBlO1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRTaGFwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSB0aGlzLnNoYXBlIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciB0aGlzU2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdFNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICEgdGhpc1NoYXBlLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBkZWZhdWx0U2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzU2hhcGVbbmFtZV0gPSBkZWZhdWx0U2hhcGVbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHRzLmluaXQgJiYgZGVmYXVsdHMuaW5pdC5jYWxsKHRoaXMsIG9wdHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHpyVXRpbC5pbmhlcml0cyhTdWIsIFBhdGgpO1xuXG4gICAgICAgIC8vIEZJWE1FIOS4jeiDvSBleHRlbmQgcG9zaXRpb24sIHJvdGF0aW9uIOetieW8leeUqOWvueixoVxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICAvLyBFeHRlbmRpbmcgcHJvdG90eXBlIHZhbHVlcyBhbmQgbWV0aG9kc1xuICAgICAgICAgICAgaWYgKG5hbWUgIT09ICdzdHlsZScgJiYgbmFtZSAhPT0gJ3NoYXBlJykge1xuICAgICAgICAgICAgICAgIFN1Yi5wcm90b3R5cGVbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBTdWI7XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhQYXRoLCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhdGg7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1BhdGguanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOWPr+e7mOWItueahOWbvuW9ouWfuuexu1xuICogQmFzZSBjbGFzcyBvZiBhbGwgZGlzcGxheWFibGUgZ3JhcGhpYyBvYmplY3RzXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICovXG5cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIFN0eWxlID0gcmVxdWlyZSgnLi9TdHlsZScpO1xuXG4gICAgdmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuLi9FbGVtZW50Jyk7XG4gICAgdmFyIFJlY3RUZXh0ID0gcmVxdWlyZSgnLi9taXhpbi9SZWN0VGV4dCcpO1xuICAgIC8vIHZhciBTdGF0ZWZ1bCA9IHJlcXVpcmUoJy4vbWl4aW4vU3RhdGVmdWwnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvbWl4aW4vUmVjdFRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEaXNwbGF5YWJsZShvcHRzKSB7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgRWxlbWVudC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIC8vIEV4dGVuZCBwcm9wZXJ0aWVzXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gb3B0cykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG9wdHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICAgICAgICBuYW1lICE9PSAnc3R5bGUnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gb3B0c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob3B0cy5zdHlsZSk7XG5cbiAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgICAgIC8vIFNoYXBlcyBmb3IgY2FzY2FkZSBjbGlwcGluZy5cbiAgICAgICAgdGhpcy5fX2NsaXBQYXRocyA9IFtdO1xuXG4gICAgICAgIC8vIEZJWE1FIFN0YXRlZnVsIG11c3QgYmUgbWl4aW5lZCBhZnRlciBzdHlsZSBpcyBzZXR0ZWRcbiAgICAgICAgLy8gU3RhdGVmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB9XG5cbiAgICBEaXNwbGF5YWJsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IERpc3BsYXlhYmxlLFxuXG4gICAgICAgIHR5cGU6ICdkaXNwbGF5YWJsZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXlhYmxlIOaYr+WQpuS4uuiEj++8jFBhaW50ZXIg5Lit5Lya5qC55o2u6K+l5qCH6K6w5Yik5pat5piv5ZCm6ZyA6KaB5piv5ZCm6ZyA6KaB6YeN5paw57uY5Yi2XG4gICAgICAgICAqIERpcnR5IGZsYWcuIEZyb20gd2hpY2ggcGFpbnRlciB3aWxsIGRldGVybWluZSBpZiB0aGlzIGRpc3BsYXlhYmxlIG9iamVjdCBuZWVkcyBicnVzaFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI19fZGlydHlcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfX2RpcnR5OiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlm77lvaLmmK/lkKblj6/op4HvvIzkuLp0cnVl5pe25LiN57uY5Yi25Zu+5b2i77yM5L2G5piv5LuN6IO96Kem5Y+R6byg5qCH5LqL5Lu2XG4gICAgICAgICAqIElmIGlnbm9yZSBkcmF3aW5nIG9mIHRoZSBkaXNwbGF5YWJsZSBvYmplY3QuIE1vdXNlIGV2ZW50IHdpbGwgc3RpbGwgYmUgdHJpZ2dlcmVkXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2ludmlzaWJsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGludmlzaWJsZTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgejogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjelxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB6MjogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogeuWxgmxldmVs77yM5Yaz5a6a57uY55S75Zyo5ZOq5bGCY2FudmFz5LitXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3psZXZlbFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB6bGV2ZWw6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuWPr+aLluaLvVxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNkcmFnZ2FibGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbmraPlnKjmi5bmi71cbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbnm7jlupTpvKDmoIfkuovku7ZcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjc2lsZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lsZW50OiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZW5hYmxlIGN1bGxpbmdcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBjdWxsaW5nOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW91c2UgY3Vyc29yIHdoZW4gaG92ZXJlZFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNjdXJzb3JcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBob3ZlciBhcmVhIGlzIGJvdW5kaW5nIHJlY3RcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjcmVjdEhvdmVyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICByZWN0SG92ZXI6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIGVsZW1lbnQgcHJvZ3Jlc3NpdmVseSB3aGVuIHRoZSB2YWx1ZSA+PSAwLFxuICAgICAgICAgKiB1c2VmdWxsIGZvciBsYXJnZSBkYXRhLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvZ3Jlc3NpdmU6IC0xLFxuXG4gICAgICAgIGJlZm9yZUJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcblxuICAgICAgICBhZnRlckJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i57uY5Yi25pa55rOVXG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzMkRSZW5kZXJpbmdDb250ZXh0fSBjdHhcbiAgICAgICAgICovXG4gICAgICAgIC8vIEludGVyZmFjZVxuICAgICAgICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5pyA5bCP5YyF5Zu055uSXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gSW50ZXJmYWNlXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIpOaWreWdkOaghyB4LCB5IOaYr+WQpuWcqOWbvuW9ouS4ilxuICAgICAgICAgKiBJZiBkaXNwbGF5YWJsZSBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjdENvbnRhaW4oeCwgeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yik5pat5Z2Q5qCHIHgsIHkg5piv5ZCm5Zyo5Zu+5b2i55qE5YyF5Zu055uS5LiKXG4gICAgICAgICAqIElmIGJvdW5kaW5nIHJlY3Qgb2YgZWxlbWVudCBjb250YWluIGNvb3JkIHgsIHlcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgcmVjdENvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgY29vcmQgPSB0aGlzLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCh4LCB5KTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0LmNvbnRhaW4oY29vcmRbMF0sIGNvb3JkWzFdKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5qCH6K6w5Zu+5b2i5YWD57Sg5Li66ISP77yM5bm25LiU5Zyo5LiL5LiA5bin6YeN57uYXG4gICAgICAgICAqIE1hcmsgZGlzcGxheWFibGUgZWxlbWVudCBkaXJ0eSBhbmQgcmVmcmVzaCBuZXh0IGZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICBkaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG5cbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlm77lvaLmmK/lkKbkvJrop6blj5Hkuovku7ZcbiAgICAgICAgICogSWYgZGlzcGxheWFibGUgb2JqZWN0IGJpbmRlZCBhbnkgZXZlbnRcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE8sIOmAmui/hyBiaW5kIOe7keWumueahOS6i+S7tlxuICAgICAgICAvLyBpc1NpbGVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAgICAgcmV0dXJuICEoXG4gICAgICAgIC8vICAgICAgICAgdGhpcy5ob3ZlcmFibGUgfHwgdGhpcy5kcmFnZ2FibGVcbiAgICAgICAgLy8gICAgICAgICB8fCB0aGlzLm9ubW91c2Vtb3ZlIHx8IHRoaXMub25tb3VzZW92ZXIgfHwgdGhpcy5vbm1vdXNlb3V0XG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlZG93biB8fCB0aGlzLm9ubW91c2V1cCB8fCB0aGlzLm9uY2xpY2tcbiAgICAgICAgLy8gICAgICAgICB8fCB0aGlzLm9uZHJhZ2VudGVyIHx8IHRoaXMub25kcmFnb3ZlciB8fCB0aGlzLm9uZHJhZ2xlYXZlXG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbmRyb3BcbiAgICAgICAgLy8gICAgICk7XG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc3R5bGUnKVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGVTdHlsZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoJ3N0eWxlJywgbG9vcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgIEVsZW1lbnQucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5zZXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBzZXRTdHlsZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIGdpdmVuIHN0eWxlIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9ialxuICAgICAgICAgKi9cbiAgICAgICAgdXNlU3R5bGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob2JqKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKERpc3BsYXlhYmxlLCBFbGVtZW50KTtcblxuICAgIHpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgUmVjdFRleHQpO1xuICAgIC8vIHpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgU3RhdGVmdWwpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEaXNwbGF5YWJsZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL1N0eWxlXG4gKi9cblxuXG4gICAgdmFyIFNUWUxFX0NPTU1PTl9QUk9QUyA9IFtcbiAgICAgICAgWydzaGFkb3dCbHVyJywgMF0sIFsnc2hhZG93T2Zmc2V0WCcsIDBdLCBbJ3NoYWRvd09mZnNldFknLCAwXSwgWydzaGFkb3dDb2xvcicsICcjMDAwJ10sXG4gICAgICAgIFsnbGluZUNhcCcsICdidXR0J10sIFsnbGluZUpvaW4nLCAnbWl0ZXInXSwgWydtaXRlckxpbWl0JywgMTBdXG4gICAgXTtcblxuICAgIC8vIHZhciBTSEFET1dfUFJPUFMgPSBTVFlMRV9DT01NT05fUFJPUFMuc2xpY2UoMCwgNCk7XG4gICAgLy8gdmFyIExJTkVfUFJPUFMgPSBTVFlMRV9DT01NT05fUFJPUFMuc2xpY2UoNCk7XG5cbiAgICB2YXIgU3R5bGUgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICB0aGlzLmV4dGVuZEZyb20ob3B0cyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxpbmVhckdyYWRpZW50KGN0eCwgb2JqLCByZWN0KSB7XG4gICAgICAgIC8vIHZhciBzaXplID1cbiAgICAgICAgdmFyIHggPSBvYmoueDtcbiAgICAgICAgdmFyIHgyID0gb2JqLngyO1xuICAgICAgICB2YXIgeSA9IG9iai55O1xuICAgICAgICB2YXIgeTIgPSBvYmoueTI7XG5cbiAgICAgICAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgICAgICAgICB4ID0geCAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgICAgICAgICB4MiA9IHgyICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICAgICAgICAgIHkgPSB5ICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgICAgICB5MiA9IHkyICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeDIsIHkyKTtcblxuICAgICAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmFkaWFsR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgdmFyIHggPSBvYmoueDtcbiAgICAgICAgdmFyIHkgPSBvYmoueTtcbiAgICAgICAgdmFyIHIgPSBvYmoucjtcbiAgICAgICAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgICAgICAgICB4ID0geCAqIHdpZHRoICsgcmVjdC54O1xuICAgICAgICAgICAgeSA9IHkgKiBoZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgICAgICByID0gciAqIG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4LCB5LCAwLCB4LCB5LCByKTtcblxuICAgICAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gICAgfVxuXG5cbiAgICBTdHlsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFN0eWxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsbDogJyMwMDAwMDAnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgc3Ryb2tlOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgb3BhY2l0eTogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgbGluZURhc2g6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsaW5lRGFzaE9mZnNldDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNoYWRvd0JsdXI6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBzaGFkb3dPZmZzZXRYOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2hhZG93T2Zmc2V0WTogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpbmVXaWR0aDogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc3Ryb2tlIGlnbm9yZSBzY2FsZVxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHN0cm9rZU5vU2NhbGU6IGZhbHNlLFxuXG4gICAgICAgIC8vIEJvdW5kaW5nIHJlY3QgdGV4dCBjb25maWd1cmF0aW9uXG4gICAgICAgIC8vIE5vdCBhZmZlY3RlZCBieSBlbGVtZW50IHRyYW5zZm9ybVxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0RmlsbDogJyMwMDAnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFN0cm9rZTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogJ2luc2lkZScsICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXG4gICAgICAgICAqIFt4LCB5XVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfEFycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAZGVmYXVsdCAnaW5zaWRlJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFBvc2l0aW9uOiAnaW5zaWRlJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogW3gsIHldXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRPZmZzZXQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0QmFzZWxpbmU6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0QWxpZ246IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dERpc3RhbmNlOiA1LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0U2hhZG93Qmx1cjogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFNoYWRvd09mZnNldFg6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRTaGFkb3dPZmZzZXRZOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cmFuc2Zvcm0gdGV4dFxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFRyYW5zZm9ybTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRleHQgcm90YXRlIGFyb3VuZCBwb3NpdGlvbiBvZiBQYXRoIG9yIEltYWdlXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnQgYW5kIHRleHRUcmFuc2Zvcm0gaXMgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0Um90YXRpb246IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBibGVuZDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDogZnVuY3Rpb24gKGN0eCwgZWwsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcztcbiAgICAgICAgICAgIHZhciBwcmV2U3R5bGUgPSBwcmV2RWwgJiYgcHJldkVsLnN0eWxlO1xuICAgICAgICAgICAgdmFyIGZpcnN0RHJhdyA9ICFwcmV2U3R5bGU7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU1RZTEVfQ09NTU9OX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBTVFlMRV9DT01NT05fUFJPUFNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlTmFtZSA9IHByb3BbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3REcmF3IHx8IHN0eWxlW3N0eWxlTmFtZV0gIT09IHByZXZTdHlsZVtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIEludmFsaWQgcHJvcGVydHkgdmFsdWUgd2lsbCBjYXVzZSBzdHlsZSBsZWFrIGZyb20gcHJldmlvdXMgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgY3R4W3N0eWxlTmFtZV0gPSBzdHlsZVtzdHlsZU5hbWVdIHx8IHByb3BbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGZpcnN0RHJhdyB8fCBzdHlsZS5maWxsICE9PSBwcmV2U3R5bGUuZmlsbCkpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuZmlsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZmlyc3REcmF3IHx8IHN0eWxlLnN0cm9rZSAhPT0gcHJldlN0eWxlLnN0cm9rZSkpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5zdHJva2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGZpcnN0RHJhdyB8fCBzdHlsZS5vcGFjaXR5ICE9PSBwcmV2U3R5bGUub3BhY2l0eSkpIHtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzdHlsZS5vcGFjaXR5ID09IG51bGwgPyAxIDogc3R5bGUub3BhY2l0eTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChmaXJzdERyYXcgfHwgc3R5bGUuYmxlbmQgIT09IHByZXZTdHlsZS5ibGVuZCkpIHtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gc3R5bGUuYmxlbmQgfHwgJ3NvdXJjZS1vdmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoIC8gKFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5zdHJva2VOb1NjYWxlICYmIGVsICYmIGVsLmdldExpbmVTY2FsZSkgPyBlbC5nZXRMaW5lU2NhbGUoKSA6IDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhhc0ZpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmaWxsID0gdGhpcy5maWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGwgIT0gbnVsbCAmJiBmaWxsICE9PSAnbm9uZSc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzU3Ryb2tlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3Ryb2tlID0gdGhpcy5zdHJva2U7XG4gICAgICAgICAgICByZXR1cm4gc3Ryb2tlICE9IG51bGwgJiYgc3Ryb2tlICE9PSAnbm9uZScgJiYgdGhpcy5saW5lV2lkdGggPiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRlbmQgZnJvbSBvdGhlciBzdHlsZVxuICAgICAgICAgKiBAcGFyYW0ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gb3RoZXJTdHlsZVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJ3cml0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZXh0ZW5kRnJvbTogZnVuY3Rpb24gKG90aGVyU3R5bGUsIG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgaWYgKG90aGVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG90aGVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyU3R5bGUuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChvdmVyd3JpdGUgfHwgISB0YXJnZXQuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gb3RoZXJTdHlsZVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQmF0Y2ggc2V0dGluZyBzdHlsZSB3aXRoIGEgZ2l2ZW4gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gb2JqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29ial1cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG9iaiwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXNbb2JqXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRGcm9tKG9iaiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb25lXG4gICAgICAgICAqIEByZXR1cm4ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdTdHlsZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgICBuZXdTdHlsZS5leHRlbmRGcm9tKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1N0eWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEdyYWRpZW50OiBmdW5jdGlvbiAoY3R4LCBvYmosIHJlY3QpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBvYmoudHlwZSA9PT0gJ3JhZGlhbCcgPyBjcmVhdGVSYWRpYWxHcmFkaWVudCA6IGNyZWF0ZUxpbmVhckdyYWRpZW50O1xuICAgICAgICAgICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gbWV0aG9kKGN0eCwgb2JqLCByZWN0KTtcbiAgICAgICAgICAgIHZhciBjb2xvclN0b3BzID0gb2JqLmNvbG9yU3RvcHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yU3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3AoXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yU3RvcHNbaV0ub2Zmc2V0LCBjb2xvclN0b3BzW2ldLmNvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW52YXNHcmFkaWVudDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3R5bGVQcm90byA9IFN0eWxlLnByb3RvdHlwZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IFNUWUxFX0NPTU1PTl9QUk9QU1tpXTtcbiAgICAgICAgaWYgKCEocHJvcFswXSBpbiBzdHlsZVByb3RvKSkge1xuICAgICAgICAgICAgc3R5bGVQcm90b1twcm9wWzBdXSA9IHByb3BbMV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm92aWRlIGZvciBvdGhlcnNcbiAgICBTdHlsZS5nZXRHcmFkaWVudCA9IHN0eWxlUHJvdG8uZ2V0R3JhZGllbnQ7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFN0eWxlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9TdHlsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL0VsZW1lbnRcbiAqL1xuXG5cbiAgICB2YXIgZ3VpZCA9IHJlcXVpcmUoJy4vY29yZS9ndWlkJyk7XG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi9taXhpbi9FdmVudGZ1bCcpO1xuICAgIHZhciBUcmFuc2Zvcm1hYmxlID0gcmVxdWlyZSgnLi9taXhpbi9UcmFuc2Zvcm1hYmxlJyk7XG4gICAgdmFyIEFuaW1hdGFibGUgPSByZXF1aXJlKCcuL21peGluL0FuaW1hdGFibGUnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9FbGVtZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL0FuaW1hdGFibGV9XG4gICAgICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9XG4gICAgICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsfVxuICAgICAqL1xuICAgIHZhciBFbGVtZW50ID0gZnVuY3Rpb24gKG9wdHMpIHtcblxuICAgICAgICBUcmFuc2Zvcm1hYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gICAgICAgIEV2ZW50ZnVsLmNhbGwodGhpcywgb3B0cyk7XG4gICAgICAgIEFuaW1hdGFibGUuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICog55S75biD5YWD57SgSURcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBvcHRzLmlkIHx8IGd1aWQoKTtcbiAgICB9O1xuXG4gICAgRWxlbWVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWFg+e0oOexu+Wei1xuICAgICAgICAgKiBFbGVtZW50IHR5cGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdlbGVtZW50JyxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5YWD57Sg5ZCN5a2XXG4gICAgICAgICAqIEVsZW1lbnQgbmFtZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgbmFtZTogJycsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFpSZW5kZXIg5a6e5L6L5a+56LGh77yM5Lya5ZyoIGVsZW1lbnQg5re75Yqg5YiwIHpyZW5kZXIg5a6e5L6L5Lit5ZCO6Ieq5Yqo6LWL5YC8XG4gICAgICAgICAqIFpSZW5kZXIgaW5zdGFuY2Ugd2lsbCBiZSBhc3NpZ25lZCB3aGVuIGVsZW1lbnQgaXMgYXNzb2NpYXRlZCB3aXRoIHpyZW5kZXJcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL0VsZW1lbnQjX196clxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAgICAgICAgICovXG4gICAgICAgIF9fenI6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWbvuW9ouaYr+WQpuW/veeVpe+8jOS4unRydWXml7blv73nlaXlm77lvaLnmoTnu5jliLbku6Xlj4rkuovku7bop6blj5FcbiAgICAgICAgICogSWYgaWdub3JlIGRyYXdpbmcgYW5kIGV2ZW50cyBvZiB0aGUgZWxlbWVudCBvYmplY3RcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL0VsZW1lbnQjaWdub3JlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaWdub3JlOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog55So5LqO6KOB5Ymq55qE6Lev5b6EKHNoYXBlKe+8jOaJgOaciSBHcm91cCDlhoXnmoTot6/lvoTlnKjnu5jliLbml7bpg73kvJrooqvov5nkuKrot6/lvoToo4HliapcbiAgICAgICAgICog6K+l6Lev5b6E5Lya57un5om/6KKr6KOB5YeP5a+56LGh55qE5Y+Y5o2iXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9XG4gICAgICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0LyNjbGlwcGluZy1yZWdpb25cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBjbGlwUGF0aDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRHJpZnQgZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR4IGR4IG9uIHRoZSBnbG9iYWwgc3BhY2VcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBkeSBkeSBvbiB0aGUgZ2xvYmFsIHNwYWNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmlmdDogZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICAgICAgICAgICAgICBkeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgICAgICAgICAgICAgZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgIG0gPSB0aGlzLnRyYW5zZm9ybSA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1bNF0gKz0gZHg7XG4gICAgICAgICAgICBtWzVdICs9IGR5O1xuXG4gICAgICAgICAgICB0aGlzLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvb2sgYmVmb3JlIHVwZGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvb2sgYWZ0ZXIgdXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBhZnRlclVwZGF0ZTogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgZWFjaCBmcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAncG9zaXRpb24nIHx8IGtleSA9PT0gJ3NjYWxlJyB8fCBrZXkgPT09ICdvcmlnaW4nKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29weSB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXNba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFswXSA9IHZhbHVlWzBdO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbMV0gPSB2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGlkZSB0aGUgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pZ25vcmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBrZXlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXR0cjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cktWKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoenJVdGlsLmlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJLVihuYW1lLCBrZXlbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBjbGlwUGF0aFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0Q2xpcFBhdGg6IGZ1bmN0aW9uIChjbGlwUGF0aCkge1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICAgICAgaWYgKHpyKSB7XG4gICAgICAgICAgICAgICAgY2xpcFBhdGguYWRkU2VsZlRvWnIoenIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgY2xpcCBwYXRoXG4gICAgICAgICAgICBpZiAodGhpcy5jbGlwUGF0aCAmJiB0aGlzLmNsaXBQYXRoICE9PSBjbGlwUGF0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2xpcFBhdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jbGlwUGF0aCA9IGNsaXBQYXRoO1xuICAgICAgICAgICAgY2xpcFBhdGguX196ciA9IHpyO1xuICAgICAgICAgICAgY2xpcFBhdGguX19jbGlwVGFyZ2V0ID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVDbGlwUGF0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aDtcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICAgICAgICAgIGlmIChjbGlwUGF0aC5fX3pyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoY2xpcFBhdGguX196cik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2xpcFBhdGguX196ciA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2xpcFBhdGguX19jbGlwVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBQYXRoID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgc2VsZiBmcm9tIHpyZW5kZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIE5vdCByZWN1cnNpdmVseSBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGVsZW1lbnQgYWRkZWQgdG8gc3RvcmFnZS5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgICAgICAgKi9cbiAgICAgICAgYWRkU2VsZlRvWnI6IGZ1bmN0aW9uICh6cikge1xuICAgICAgICAgICAgdGhpcy5fX3pyID0genI7XG4gICAgICAgICAgICAvLyDmt7vliqDliqjnlLtcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICAgICAgICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICAgICAgICogTm90IHJlY3Vyc2l2ZWx5IGJlY2F1c2UgaXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWxlbWVudCBhZGRlZCB0byBzdG9yYWdlLlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVTZWxmRnJvbVpyOiBmdW5jdGlvbiAoenIpIHtcbiAgICAgICAgICAgIHRoaXMuX196ciA9IG51bGw7XG4gICAgICAgICAgICAvLyDnp7vpmaTliqjnlLtcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICAgICAgICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB6ci5hbmltYXRpb24ucmVtb3ZlQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwUGF0aC5yZW1vdmVTZWxmRnJvbVpyKHpyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwubWl4aW4oRWxlbWVudCwgQW5pbWF0YWJsZSk7XG4gICAgenJVdGlsLm1peGluKEVsZW1lbnQsIFRyYW5zZm9ybWFibGUpO1xuICAgIHpyVXRpbC5taXhpbihFbGVtZW50LCBFdmVudGZ1bCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9FbGVtZW50LmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiB6cmVuZGVyOiDnlJ/miJDllK/kuIBpZFxuICpcbiAqIEBhdXRob3IgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgaWRTdGFydCA9IDB4MDkwNztcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaWRTdGFydCsrO1xuICAgIH07XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOS6i+S7tuaJqeWxlVxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cblxuICAgIHZhciBhcnJ5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgICAvKipcbiAgICAgKiDkuovku7bliIblj5HlmahcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgRXZlbnRmdWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuXyRoYW5kbGVycyA9IHt9O1xuICAgIH07XG5cbiAgICBFdmVudGZ1bC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEV2ZW50ZnVsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDljZXmrKHop6blj5Hnu5HlrprvvIx0cmlnZ2Vy5ZCO6ZSA5q+BXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDlk43lupTlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIG9uZTogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICAgICAgICAgIGlmICghaGFuZGxlciB8fCAhZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFfaFtldmVudF0pIHtcbiAgICAgICAgICAgICAgICBfaFtldmVudF0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaFtldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgaDogaGFuZGxlcixcbiAgICAgICAgICAgICAgICBvbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgY3R4OiBjb250ZXh0IHx8IHRoaXNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog57uR5a6a5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDkuovku7blpITnkIblh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICAgICAgICAgKi9cbiAgICAgICAgb246IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIgfHwgIWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghX2hbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgX2hbZXZlbnRdID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2hbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9oW2V2ZW50XVtpXS5oID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2hbZXZlbnRdLnB1c2goe1xuICAgICAgICAgICAgICAgIGg6IGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjdHg6IGNvbnRleHQgfHwgdGhpc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbnu5Hlrprkuobkuovku7ZcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSAgZXZlbnRcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGlzU2lsZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcbiAgICAgICAgICAgIHJldHVybiBfaFtldmVudF0gJiYgX2hbZXZlbnRdLmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6Kej57uR5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAgICAgKi9cbiAgICAgICAgb2ZmOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgICAgICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuXyRoYW5kbGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBfaFtldmVudF0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldWydoJ10gIT0gaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xpc3QucHVzaChfaFtldmVudF1baV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9oW2V2ZW50XSA9IG5ld0xpc3Q7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfaFtldmVudF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS6i+S7tuWIhuWPkVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fJGhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ0xlbiA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ0xlbiA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFycnlTbGljZS5jYWxsKGFyZ3MsIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gX2gubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBhZHZpc2UgZnJvbSBiYWNrYm9uZVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGFyZ0xlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXZlIG1vcmUgdGhhbiAyIGdpdmVuIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uYXBwbHkoX2hbaV1bJ2N0eCddLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaFtpXVsnb25lJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5bim5pyJY29udGV4dOeahOS6i+S7tuWIhuWPkSwg5pyA5ZCO5LiA5Liq5Y+C5pWw5piv5LqL5Lu25Zue6LCD55qEY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXJXaXRoQ29udGV4dDogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl8kaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnTGVuID4gNCkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSwgYXJncy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gX2gubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBhZHZpc2UgZnJvbSBiYWNrYm9uZVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGFyZ0xlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgsIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgsIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXZlIG1vcmUgdGhhbiAyIGdpdmVuIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uYXBwbHkoY3R4LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaFtpXVsnb25lJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyDlr7nosaHlj6/ku6XpgJrov4cgb254eHh4IOe7keWumuS6i+S7tlxuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmNsaWNrXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW92ZXJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3V0XG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW1vdmVcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNld2hlZWxcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlZG93blxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V1cFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ3N0YXJ0XG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnZW5kXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnZW50ZXJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdsZWF2ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ292ZXJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyb3BcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudGZ1bDtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDmj5Dkvpvlj5jmjaLmianlsZVcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgbWF0cml4ID0gcmVxdWlyZSgnLi4vY29yZS9tYXRyaXgnKTtcbiAgICB2YXIgdmVjdG9yID0gcmVxdWlyZSgnLi4vY29yZS92ZWN0b3InKTtcbiAgICB2YXIgbUlkZW50aXR5ID0gbWF0cml4LmlkZW50aXR5O1xuXG4gICAgdmFyIEVQU0lMT04gPSA1ZS01O1xuXG4gICAgZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBUcmFuc2Zvcm1hYmxlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBnaXZlbiBwb3NpdGlvbiwgcm90YXRpb24sIHNjYWxlXG4gICAgICAgIGlmICghb3B0cy5wb3NpdGlvbikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDlubPnp7tcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IFswLCAwXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gWzAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnJvdGF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5peL6L2sXG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0cy5zY2FsZSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDnvKnmlL5cbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IFsxLCAxXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gWzEsIDFdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDml4vovazlkoznvKnmlL7nmoTljp/ngrlcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWdpbiA9IHRoaXMub3JpZ2luIHx8IG51bGw7XG4gICAgfTtcblxuICAgIHZhciB0cmFuc2Zvcm1hYmxlUHJvdG8gPSBUcmFuc2Zvcm1hYmxlLnByb3RvdHlwZTtcbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIOWIpOaWreaYr+WQpumcgOimgeacieWdkOagh+WPmOaNolxuICAgICAqIOWmguaenOacieWdkOagh+WPmOaNoiwg5YiZ5LuOcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZeS7peWPiueItuiKgueCueeahHRyYW5zZm9ybeiuoeeul+WHuuiHqui6q+eahHRyYW5zZm9ybeefqemYtVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by5uZWVkTG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpc05vdEFyb3VuZFplcm8odGhpcy5yb3RhdGlvbilcbiAgICAgICAgICAgIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzBdKVxuICAgICAgICAgICAgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMucG9zaXRpb25bMV0pXG4gICAgICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVswXSAtIDEpXG4gICAgICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVsxXSAtIDEpO1xuICAgIH07XG5cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8udXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHZhciBwYXJlbnRIYXNUcmFuc2Zvcm0gPSBwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybTtcbiAgICAgICAgdmFyIG5lZWRMb2NhbFRyYW5zZm9ybSA9IHRoaXMubmVlZExvY2FsVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKCEobmVlZExvY2FsVHJhbnNmb3JtIHx8IHBhcmVudEhhc1RyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgIG0gJiYgbUlkZW50aXR5KG0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbSA9IG0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuXG4gICAgICAgIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0TG9jYWxUcmFuc2Zvcm0obSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtSWRlbnRpdHkobSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDlupTnlKjniLboioLngrnlj5jmjaJcbiAgICAgICAgaWYgKHBhcmVudEhhc1RyYW5zZm9ybSkge1xuICAgICAgICAgICAgaWYgKG5lZWRMb2NhbFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIG1hdHJpeC5tdWwobSwgcGFyZW50LnRyYW5zZm9ybSwgbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRyaXguY29weShtLCBwYXJlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyDkv53lrZjov5nkuKrlj5jmjaLnn6npmLVcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBtO1xuXG4gICAgICAgIHRoaXMuaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuICAgICAgICBtYXRyaXguaW52ZXJ0KHRoaXMuaW52VHJhbnNmb3JtLCBtKTtcbiAgICB9O1xuXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLmdldExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgbSA9IG0gfHwgW107XG4gICAgICAgIG1JZGVudGl0eShtKTtcblxuICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5vcmlnaW47XG5cbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgLy8gVHJhbnNsYXRlIHRvIG9yaWdpblxuICAgICAgICAgICAgbVs0XSAtPSBvcmlnaW5bMF07XG4gICAgICAgICAgICBtWzVdIC09IG9yaWdpblsxXTtcbiAgICAgICAgfVxuICAgICAgICBtYXRyaXguc2NhbGUobSwgbSwgc2NhbGUpO1xuICAgICAgICBpZiAocm90YXRpb24pIHtcbiAgICAgICAgICAgIG1hdHJpeC5yb3RhdGUobSwgbSwgcm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSBiYWNrIGZyb20gb3JpZ2luXG4gICAgICAgICAgICBtWzRdICs9IG9yaWdpblswXTtcbiAgICAgICAgICAgIG1bNV0gKz0gb3JpZ2luWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgbVs0XSArPSBwb3NpdGlvblswXTtcbiAgICAgICAgbVs1XSArPSBwb3NpdGlvblsxXTtcblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIOWwhuiHquW3seeahHRyYW5zZm9ybeW6lOeUqOWIsGNvbnRleHTkuIpcbiAgICAgKiBAcGFyYW0ge0NvbnRleHQyRH0gY3R4XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByICogbVswXSwgZHByICogbVsxXSwgZHByICogbVsyXSwgZHByICogbVszXSwgZHByICogbVs0XSwgZHByICogbVs1XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKGRwciwgMCwgMCwgZHByLCAwLCAwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8ucmVzdG9yZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybShkcHIsIDAsIDAsIGRwciwgMCwgMCk7XG4gICAgfVxuXG4gICAgdmFyIHRtcFRyYW5zZm9ybSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICog5YiG6KejYHRyYW5zZm9ybWDnn6npmLXliLBgcG9zaXRpb25gLCBgcm90YXRpb25gLCBgc2NhbGVgXG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLmRlY29tcG9zZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBHZXQgbG9jYWwgdHJhbnNmb3JtIGFuZCBkZWNvbXBvc2UgdGhlbSB0byBwb3NpdGlvbiwgc2NhbGUsIHJvdGF0aW9uXG4gICAgICAgICAgICBtYXRyaXgubXVsKHRtcFRyYW5zZm9ybSwgcGFyZW50LmludlRyYW5zZm9ybSwgbSk7XG4gICAgICAgICAgICBtID0gdG1wVHJhbnNmb3JtO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzeCA9IG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV07XG4gICAgICAgIHZhciBzeSA9IG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM107XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgIGlmIChpc05vdEFyb3VuZFplcm8oc3ggLSAxKSkge1xuICAgICAgICAgICAgc3ggPSBNYXRoLnNxcnQoc3gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05vdEFyb3VuZFplcm8oc3kgLSAxKSkge1xuICAgICAgICAgICAgc3kgPSBNYXRoLnNxcnQoc3kpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtWzBdIDwgMCkge1xuICAgICAgICAgICAgc3ggPSAtc3g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1bM10gPCAwKSB7XG4gICAgICAgICAgICBzeSA9IC1zeTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvblswXSA9IG1bNF07XG4gICAgICAgIHBvc2l0aW9uWzFdID0gbVs1XTtcbiAgICAgICAgc2NhbGVbMF0gPSBzeDtcbiAgICAgICAgc2NhbGVbMV0gPSBzeTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IE1hdGguYXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGdsb2JhbCBzY2FsZVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by5nZXRHbG9iYWxTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gWzEsIDFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzeCA9IE1hdGguc3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgICAgdmFyIHN5ID0gTWF0aC5zcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICBpZiAobVswXSA8IDApIHtcbiAgICAgICAgICAgIHN4ID0gLXN4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtWzNdIDwgMCkge1xuICAgICAgICAgICAgc3kgPSAtc3k7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzeCwgc3ldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICog5Y+Y5o2i5Z2Q5qCH5L2N572u5YiwIHNoYXBlIOeahOWxgOmDqOWdkOagh+epuumXtFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciB2MiA9IFt4LCB5XTtcbiAgICAgICAgdmFyIGludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtO1xuICAgICAgICBpZiAoaW52VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0odjIsIHYyLCBpbnZUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5Y+Y5o2i5bGA6YOo5Z2Q5qCH5L2N572u5Yiw5YWo5bGA5Z2Q5qCH56m66Ze0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtQ29vcmRUb0dsb2JhbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciB2MiA9IFt4LCB5XTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0odjIsIHYyLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MjtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm1hYmxlO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9taXhpbi9UcmFuc2Zvcm1hYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuICAgIHZhciBBcnJheUN0b3IgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IEFycmF5XG4gICAgICAgIDogRmxvYXQzMkFycmF5O1xuICAgIC8qKlxuICAgICAqIDN4MuefqemYteaTjeS9nOexu1xuICAgICAqIEBleHBvcnRzIHpyZW5kZXIvdG9vbC9tYXRyaXhcbiAgICAgKi9cbiAgICB2YXIgbWF0cml4ID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5Yib5bu65LiA5Liq5Y2V5L2N55+p6Zi1XG4gICAgICAgICAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoNik7XG4gICAgICAgICAgICBtYXRyaXguaWRlbnRpdHkob3V0KTtcblxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruefqemYteS4uuWNleS9jeefqemYtVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqL1xuICAgICAgICBpZGVudGl0eSA6IGZ1bmN0aW9uKG91dCkge1xuICAgICAgICAgICAgb3V0WzBdID0gMTtcbiAgICAgICAgICAgIG91dFsxXSA9IDA7XG4gICAgICAgICAgICBvdXRbMl0gPSAwO1xuICAgICAgICAgICAgb3V0WzNdID0gMTtcbiAgICAgICAgICAgIG91dFs0XSA9IDA7XG4gICAgICAgICAgICBvdXRbNV0gPSAwO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWkjeWItuefqemYtVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtXG4gICAgICAgICAqL1xuICAgICAgICBjb3B5OiBmdW5jdGlvbihvdXQsIG0pIHtcbiAgICAgICAgICAgIG91dFswXSA9IG1bMF07XG4gICAgICAgICAgICBvdXRbMV0gPSBtWzFdO1xuICAgICAgICAgICAgb3V0WzJdID0gbVsyXTtcbiAgICAgICAgICAgIG91dFszXSA9IG1bM107XG4gICAgICAgICAgICBvdXRbNF0gPSBtWzRdO1xuICAgICAgICAgICAgb3V0WzVdID0gbVs1XTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnn6npmLXnm7jkuZhcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbTFcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG0yXG4gICAgICAgICAqL1xuICAgICAgICBtdWwgOiBmdW5jdGlvbiAob3V0LCBtMSwgbTIpIHtcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIG1hdHJpeC5tdWwobSwgbTIsIG0pO1xuICAgICAgICAgICAgLy8gd2hlcmUgb3V0IGlzIHRoZSBzYW1lIGFzIG0yLlxuICAgICAgICAgICAgLy8gU28gdXNlIHRlbXAgdmFyaWFibGUgdG8gZXNjYXBlIGVycm9yLlxuICAgICAgICAgICAgdmFyIG91dDAgPSBtMVswXSAqIG0yWzBdICsgbTFbMl0gKiBtMlsxXTtcbiAgICAgICAgICAgIHZhciBvdXQxID0gbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV07XG4gICAgICAgICAgICB2YXIgb3V0MiA9IG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdO1xuICAgICAgICAgICAgdmFyIG91dDMgPSBtMVsxXSAqIG0yWzJdICsgbTFbM10gKiBtMlszXTtcbiAgICAgICAgICAgIHZhciBvdXQ0ID0gbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XTtcbiAgICAgICAgICAgIHZhciBvdXQ1ID0gbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XTtcbiAgICAgICAgICAgIG91dFswXSA9IG91dDA7XG4gICAgICAgICAgICBvdXRbMV0gPSBvdXQxO1xuICAgICAgICAgICAgb3V0WzJdID0gb3V0MjtcbiAgICAgICAgICAgIG91dFszXSA9IG91dDM7XG4gICAgICAgICAgICBvdXRbNF0gPSBvdXQ0O1xuICAgICAgICAgICAgb3V0WzVdID0gb3V0NTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlubPnp7vlj5jmjaJcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gdlxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNsYXRlIDogZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gYVsxXTtcbiAgICAgICAgICAgIG91dFsyXSA9IGFbMl07XG4gICAgICAgICAgICBvdXRbM10gPSBhWzNdO1xuICAgICAgICAgICAgb3V0WzRdID0gYVs0XSArIHZbMF07XG4gICAgICAgICAgICBvdXRbNV0gPSBhWzVdICsgdlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDml4vovazlj5jmjaJcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkXG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGUgOiBmdW5jdGlvbihvdXQsIGEsIHJhZCkge1xuICAgICAgICAgICAgdmFyIGFhID0gYVswXTtcbiAgICAgICAgICAgIHZhciBhYyA9IGFbMl07XG4gICAgICAgICAgICB2YXIgYXR4ID0gYVs0XTtcbiAgICAgICAgICAgIHZhciBhYiA9IGFbMV07XG4gICAgICAgICAgICB2YXIgYWQgPSBhWzNdO1xuICAgICAgICAgICAgdmFyIGF0eSA9IGFbNV07XG4gICAgICAgICAgICB2YXIgc3QgPSBNYXRoLnNpbihyYWQpO1xuICAgICAgICAgICAgdmFyIGN0ID0gTWF0aC5jb3MocmFkKTtcblxuICAgICAgICAgICAgb3V0WzBdID0gYWEgKiBjdCArIGFiICogc3Q7XG4gICAgICAgICAgICBvdXRbMV0gPSAtYWEgKiBzdCArIGFiICogY3Q7XG4gICAgICAgICAgICBvdXRbMl0gPSBhYyAqIGN0ICsgYWQgKiBzdDtcbiAgICAgICAgICAgIG91dFszXSA9IC1hYyAqIHN0ICsgY3QgKiBhZDtcbiAgICAgICAgICAgIG91dFs0XSA9IGN0ICogYXR4ICsgc3QgKiBhdHk7XG4gICAgICAgICAgICBvdXRbNV0gPSBjdCAqIGF0eSAtIHN0ICogYXR4O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe8qeaUvuWPmOaNolxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSB2XG4gICAgICAgICAqL1xuICAgICAgICBzY2FsZSA6IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgICAgICAgICAgdmFyIHZ4ID0gdlswXTtcbiAgICAgICAgICAgIHZhciB2eSA9IHZbMV07XG4gICAgICAgICAgICBvdXRbMF0gPSBhWzBdICogdng7XG4gICAgICAgICAgICBvdXRbMV0gPSBhWzFdICogdnk7XG4gICAgICAgICAgICBvdXRbMl0gPSBhWzJdICogdng7XG4gICAgICAgICAgICBvdXRbM10gPSBhWzNdICogdnk7XG4gICAgICAgICAgICBvdXRbNF0gPSBhWzRdICogdng7XG4gICAgICAgICAgICBvdXRbNV0gPSBhWzVdICogdnk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5rGC6YCG55+p6Zi1XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAgICAgICAgICovXG4gICAgICAgIGludmVydCA6IGZ1bmN0aW9uKG91dCwgYSkge1xuXG4gICAgICAgICAgICB2YXIgYWEgPSBhWzBdO1xuICAgICAgICAgICAgdmFyIGFjID0gYVsyXTtcbiAgICAgICAgICAgIHZhciBhdHggPSBhWzRdO1xuICAgICAgICAgICAgdmFyIGFiID0gYVsxXTtcbiAgICAgICAgICAgIHZhciBhZCA9IGFbM107XG4gICAgICAgICAgICB2YXIgYXR5ID0gYVs1XTtcblxuICAgICAgICAgICAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuICAgICAgICAgICAgaWYgKCFkZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgICAgICAgICAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gICAgICAgICAgICBvdXRbMV0gPSAtYWIgKiBkZXQ7XG4gICAgICAgICAgICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gICAgICAgICAgICBvdXRbM10gPSBhYSAqIGRldDtcbiAgICAgICAgICAgIG91dFs0XSA9IChhYyAqIGF0eSAtIGFkICogYXR4KSAqIGRldDtcbiAgICAgICAgICAgIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYXRyaXg7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuICAgIHZhciBBcnJheUN0b3IgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IEFycmF5XG4gICAgICAgIDogRmxvYXQzMkFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gVmVjdG9yMlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIOS6jOe7tOWQkemHj+exu1xuICAgICAqIEBleHBvcnRzIHpyZW5kZXIvdG9vbC92ZWN0b3JcbiAgICAgKi9cbiAgICB2YXIgdmVjdG9yID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5Yib5bu65LiA5Liq5ZCR6YePXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDIpO1xuICAgICAgICAgICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0WzBdID0geDtcbiAgICAgICAgICAgIG91dFsxXSA9IHk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlpI3liLblkJHph4/mlbDmja5cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb3B5OiBmdW5jdGlvbiAob3V0LCB2KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2WzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWFi+mahuS4gOS4quWQkemHj1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICAgICAgICovXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoMik7XG4gICAgICAgICAgICBvdXRbMF0gPSB2WzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruWQkemHj+eahOS4pOS4qumhuVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfSDnu5PmnpxcbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgICAgICAgICAgb3V0WzBdID0gYTtcbiAgICAgICAgICAgIG91dFsxXSA9IGI7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/nm7jliqBcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gKyB2MlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdICsgdjJbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/nvKnmlL7lkI7nm7jliqBcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gICAgICAgICAqL1xuICAgICAgICBzY2FsZUFuZEFkZDogZnVuY3Rpb24gKG91dCwgdjEsIHYyLCBhKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSArIHYyWzBdICogYTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdICsgdjJbMV0gKiBhO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP55u45YePXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgc3ViOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdIC0gdjJbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSAtIHYyWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP6ZW/5bqmXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsZW46IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMubGVuU3F1YXJlKHYpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP6ZW/5bqm5bmz5pa5XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsZW5TcXVhcmU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdlswXSAqIHZbMF0gKyB2WzFdICogdlsxXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP5LmY5rOVXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdICogdjJbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSAqIHYyWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP6Zmk5rOVXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgZGl2OiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdIC8gdjJbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSAvIHYyWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP54K55LmYXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBkb3Q6IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgICAgIHJldHVybiB2MVswXSAqIHYyWzBdICsgdjFbMV0gKiB2MlsxXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP57yp5pS+XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc1xuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uIChvdXQsIHYsIHMpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHZbMF0gKiBzO1xuICAgICAgICAgICAgb3V0WzFdID0gdlsxXSAqIHM7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/lvZLkuIDljJZcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqL1xuICAgICAgICBub3JtYWxpemU6IGZ1bmN0aW9uIChvdXQsIHYpIHtcbiAgICAgICAgICAgIHZhciBkID0gdmVjdG9yLmxlbih2KTtcbiAgICAgICAgICAgIGlmIChkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgb3V0WzBdID0gMDtcbiAgICAgICAgICAgICAgICBvdXRbMV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0WzBdID0gdlswXSAvIGQ7XG4gICAgICAgICAgICAgICAgb3V0WzFdID0gdlsxXSAvIGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorqHnrpflkJHph4/pl7Tot53nprtcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGRpc3RhbmNlOiBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgICh2MVswXSAtIHYyWzBdKSAqICh2MVswXSAtIHYyWzBdKVxuICAgICAgICAgICAgICAgICsgKHYxWzFdIC0gdjJbMV0pICogKHYxWzFdIC0gdjJbMV0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/ot53nprvlubPmlrlcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGRpc3RhbmNlU3F1YXJlOiBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgICAgICByZXR1cm4gKHYxWzBdIC0gdjJbMF0pICogKHYxWzBdIC0gdjJbMF0pXG4gICAgICAgICAgICAgICAgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaxgui0n+WQkemHj1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICovXG4gICAgICAgIG5lZ2F0ZTogZnVuY3Rpb24gKG91dCwgdikge1xuICAgICAgICAgICAgb3V0WzBdID0gLXZbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSAtdlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaPkuWAvOS4pOS4queCuVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRcbiAgICAgICAgICovXG4gICAgICAgIGxlcnA6IGZ1bmN0aW9uIChvdXQsIHYxLCB2MiwgdCkge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gKyB0ICogKHYyWzBdIC0gdjFbMF0pO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gKyB0ICogKHYyWzFdIC0gdjFbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog55+p6Zi15bem5LmY5ZCR6YePXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG1cbiAgICAgICAgICovXG4gICAgICAgIGFwcGx5VHJhbnNmb3JtOiBmdW5jdGlvbiAob3V0LCB2LCBtKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHZbMF07XG4gICAgICAgICAgICB2YXIgeSA9IHZbMV07XG4gICAgICAgICAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgICAgICAgICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaxguS4pOS4quWQkemHj+acgOWwj+WAvFxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIG1pbjogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBNYXRoLm1pbih2MVswXSwgdjJbMF0pO1xuICAgICAgICAgICAgb3V0WzFdID0gTWF0aC5taW4odjFbMV0sIHYyWzFdKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmsYLkuKTkuKrlkJHph4/mnIDlpKflgLxcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBtYXg6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gTWF0aC5tYXgodjFbMF0sIHYyWzBdKTtcbiAgICAgICAgICAgIG91dFsxXSA9IE1hdGgubWF4KHYxWzFdLCB2MlsxXSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZlY3Rvci5sZW5ndGggPSB2ZWN0b3IubGVuO1xuICAgIHZlY3Rvci5sZW5ndGhTcXVhcmUgPSB2ZWN0b3IubGVuU3F1YXJlO1xuICAgIHZlY3Rvci5kaXN0ID0gdmVjdG9yLmRpc3RhbmNlO1xuICAgIHZlY3Rvci5kaXN0U3F1YXJlID0gdmVjdG9yLmRpc3RhbmNlU3F1YXJlO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB2ZWN0b3I7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL0FuaW1hdGFibGVcbiAqL1xuXG5cbiAgICB2YXIgQW5pbWF0b3IgPSByZXF1aXJlKCcuLi9hbmltYXRpb24vQW5pbWF0b3InKTtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBpc1N0cmluZyA9IHV0aWwuaXNTdHJpbmc7XG4gICAgdmFyIGlzRnVuY3Rpb24gPSB1dGlsLmlzRnVuY3Rpb247XG4gICAgdmFyIGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdDtcbiAgICB2YXIgbG9nID0gcmVxdWlyZSgnLi4vY29yZS9sb2cnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1ZTp6cmVuZGVyL21peGluL0FuaW1hdGFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0YWJsZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3I+fVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0b3JzID0gW107XG4gICAgfTtcblxuICAgIEFuaW1hdGFibGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBBbmltYXRhYmxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliqjnlLtcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGgg6ZyA6KaB5re75Yqg5Yqo55S755qE5bGe5oCn6I635Y+W6Lev5b6E77yM5Y+v5Lul6YCa6L+HYS5iLmPmnaXojrflj5bmt7HlsYLnmoTlsZ7mgKdcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbbG9vcF0g5Yqo55S75piv5ZCm5b6q546vXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICogQGV4YW1wbGU6XG4gICAgICAgICAqICAgICBlbC5hbmltYXRlKCdzdHlsZScsIGZhbHNlKVxuICAgICAgICAgKiAgICAgICAgIC53aGVuKDEwMDAsIHt4OiAxMH0gKVxuICAgICAgICAgKiAgICAgICAgIC5kb25lKGZ1bmN0aW9uKCl7IC8vIEFuaW1hdGlvbiBkb25lIH0pXG4gICAgICAgICAqICAgICAgICAgLnN0YXJ0KClcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIChwYXRoLCBsb29wKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGFuaW1hdGluZ1NoYXBlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aFNwbGl0dGVkID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gZWw7XG4gICAgICAgICAgICAgICAgLy8gSWYgYW5pbWF0aW5nIHNoYXBlXG4gICAgICAgICAgICAgICAgYW5pbWF0aW5nU2hhcGUgPSBwYXRoU3BsaXR0ZWRbMF0gPT09ICdzaGFwZSc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoU3BsaXR0ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IHByb3BbcGF0aFNwbGl0dGVkW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBlbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBsb2coXG4gICAgICAgICAgICAgICAgICAgICdQcm9wZXJ0eSBcIidcbiAgICAgICAgICAgICAgICAgICAgKyBwYXRoXG4gICAgICAgICAgICAgICAgICAgICsgJ1wiIGlzIG5vdCBleGlzdGVkIGluIGVsZW1lbnQgJ1xuICAgICAgICAgICAgICAgICAgICArIGVsLmlkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSBlbC5hbmltYXRvcnM7XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcih0YXJnZXQsIGxvb3ApO1xuXG4gICAgICAgICAgICBhbmltYXRvci5kdXJpbmcoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGVsLmRpcnR5KGFuaW1hdGluZ1NoYXBlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgQW5pbWF0b3Igd2lsbCBub3QgYmUgcmVtb3ZlZCBpZiB1c2UgYEFuaW1hdG9yI3N0b3BgIHRvIHN0b3AgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgYW5pbWF0b3JzLnNwbGljZSh1dGlsLmluZGV4T2YoYW5pbWF0b3JzLCBhbmltYXRvciksIDEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGFuaW1hdG9ycy5wdXNoKGFuaW1hdG9yKTtcblxuICAgICAgICAgICAgLy8gSWYgYW5pbWF0ZSBhZnRlciBhZGRlZCB0byB0aGUgenJlbmRlclxuICAgICAgICAgICAgaWYgKHpyKSB7XG4gICAgICAgICAgICAgICAgenIuYW5pbWF0aW9uLmFkZEFuaW1hdG9yKGFuaW1hdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdG9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLliqjnlLtcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcEFuaW1hdGlvbjogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRvcnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yc1tpXS5zdG9wKGZvcndhcmRUb0xhc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5pbWF0b3JzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT01MDBdIFRpbWUgaW4gbXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtlYXNpbmc9J2xpbmVhciddXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgICAgICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICAgICAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICAgICAgICogIH0sIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICAgICAgICAgKlxuICAgICAgICAgKiAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zLCB3aXRoIGN1YmljT3V0IGVhc2luZ1xuICAgICAgICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICAgICAgICogICAgICBzaGFwZToge1xuICAgICAgICAgKiAgICAgICAgICB3aWR0aDogNTAwXG4gICAgICAgICAqICAgICAgfSxcbiAgICAgICAgICogICAgICBzdHlsZToge1xuICAgICAgICAgKiAgICAgICAgICBmaWxsOiAncmVkJ1xuICAgICAgICAgKiAgICAgIH1cbiAgICAgICAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICAgICAgICogIH0sIDEwMCwgMTAwLCAnY3ViaWNPdXQnLCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcbiAgICAgICAgICovXG4gICAgICAgICAvLyBUT0RPIFJldHVybiBhbmltYXRpb24ga2V5XG4gICAgICAgIGFuaW1hdGVUbzogZnVuY3Rpb24gKHRhcmdldCwgdGltZSwgZGVsYXksIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGVhc2luZywgY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgICAgICAgICAgIGVhc2luZyA9IGRlbGF5O1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGRlbGF5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVhc2luZykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgICAgICBlYXNpbmcgPSAnbGluZWFyJztcbiAgICAgICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZGVsYXk7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgY2FsbGJhY2spXG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRpbWUpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB0aW1lO1xuICAgICAgICAgICAgICAgIHRpbWUgPSA1MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0KVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcCBhbGwgcHJldmlvdXMgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlVG9TaGFsbG93KCcnLCB0aGlzLCB0YXJnZXQsIHRpbWUsIGRlbGF5LCBlYXNpbmcsIGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgLy8gQW5pbWF0b3JzIG1heSBiZSByZW1vdmVkIGltbWVkaWF0ZWx5IGFmdGVyIHN0YXJ0XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIGFuaW1hdGVcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycy5zbGljZSgpO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gYW5pbWF0b3JzLmxlbmd0aDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBObyBhbmltYXRvcnMuIFRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgYmVmb3JlIGFuaW1hdG9yc1tpXS5zdGFydCgpLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSAnZG9uZScgbWF5IGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IGlmIG5vIG5lZWQgdG8gYW5pbWF0ZS5cbiAgICAgICAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgYWZ0ZXIgYWxsIGFuaW1hdG9ycyBjcmVhdGVkXG4gICAgICAgICAgICAvLyBJbmNhc2UgYW55IGFuaW1hdG9yIGlzIGRvbmUgaW1tZWRpYXRlbHkgd2hlbiBhbGwgYW5pbWF0aW9uIHByb3BlcnRpZXMgYXJlIG5vdCBjaGFuZ2VkXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yc1tpXVxuICAgICAgICAgICAgICAgICAgICAuZG9uZShkb25lKVxuICAgICAgICAgICAgICAgICAgICAuc3RhcnQoZWFzaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGg9JydcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZT10aGlzXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgICAgICAgKiAgZWwuX2FuaW1hdGVUb1NoYWxsb3coe1xuICAgICAgICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgICAgICAgKiAgfSlcbiAgICAgICAgICpcbiAgICAgICAgICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtc1xuICAgICAgICAgKiAgZWwuX2FuaW1hdGVUb1NoYWxsb3coe1xuICAgICAgICAgKiAgICAgIHNoYXBlOiB7XG4gICAgICAgICAqICAgICAgICAgIHdpZHRoOiA1MDBcbiAgICAgICAgICogICAgICB9LFxuICAgICAgICAgKiAgICAgIHN0eWxlOiB7XG4gICAgICAgICAqICAgICAgICAgIGZpbGw6ICdyZWQnXG4gICAgICAgICAqICAgICAgfVxuICAgICAgICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgICAgICAgKiAgfSwgMTAwLCAxMDApXG4gICAgICAgICAqL1xuICAgICAgICBfYW5pbWF0ZVRvU2hhbGxvdzogZnVuY3Rpb24gKHBhdGgsIHNvdXJjZSwgdGFyZ2V0LCB0aW1lLCBkZWxheSkge1xuICAgICAgICAgICAgdmFyIG9ialNoYWxsb3cgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eUNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh0YXJnZXRbbmFtZV0pICYmICF1dGlsLmlzQXJyYXlMaWtlKHRhcmdldFtuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVUb1NoYWxsb3coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA/IHBhdGggKyAnLicgKyBuYW1lIDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VbbmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpTaGFsbG93W25hbWVdID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dHIgZGlyZWN0bHkgaWYgbm90IGhhcyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSwgaWYgc29tZSBwcm9wZXJ0eSBub3QgbmVlZGVkIGZvciBlbGVtZW50ID9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHIobmFtZSwgdGFyZ2V0W25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgIC8vIFNoYXBlIG9yIHN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW3BhdGhdID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1twYXRoXVtuYW1lXSA9IHRhcmdldFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cihwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZShwYXRoLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgLndoZW4odGltZSA9PSBudWxsID8gNTAwIDogdGltZSwgb2JqU2hhbGxvdylcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KGRlbGF5IHx8IDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGFibGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2FuaW1hdGlvbi9BbmltYXRvclxuICovXG5cblxuICAgIHZhciBDbGlwID0gcmVxdWlyZSgnLi9DbGlwJyk7XG4gICAgdmFyIGNvbG9yID0gcmVxdWlyZSgnLi4vdG9vbC9jb2xvcicpO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIGlzQXJyYXlMaWtlID0gdXRpbC5pc0FycmF5TGlrZTtcblxuICAgIHZhciBhcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgZnVuY3Rpb24gZGVmYXVsdEdldHRlcih0YXJnZXQsIGtleSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFNldHRlcih0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihwMCwgcDEsIHBlcmNlbnQpIHtcbiAgICAgICAgcmV0dXJuIChwMSAtIHAwKSAqIHBlcmNlbnQgKyBwMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHAwXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZVN0cmluZyhwMCwgcDEsIHBlcmNlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBlcmNlbnQgPiAwLjUgPyBwMSA6IHAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlQXJyYXkocDAsIHAxLCBwZXJjZW50LCBvdXQsIGFyckRpbSkge1xuICAgICAgICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyRGltID09IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSBpbnRlcnBvbGF0ZU51bWJlcihwMFtpXSwgcDFbaV0sIHBlcmNlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxlbjIgPSBwMFswXS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0W2ldW2pdID0gaW50ZXJwb2xhdGVOdW1iZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBwMFtpXVtqXSwgcDFbaV1bal0sIHBlcmNlbnRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhcnIwIGlzIHNvdXJjZSBhcnJheSwgYXJyMSBpcyB0YXJnZXQgYXJyYXkuXG4gICAgLy8gRG8gc29tZSBwcmVwcm9jZXNzIHRvIGF2b2lkIGVycm9yIGhhcHBlbmVkIHdoZW4gaW50ZXJwb2xhdGluZyBmcm9tIGFycjAgdG8gYXJyMVxuICAgIGZ1bmN0aW9uIGZpbGxBcnIoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gICAgICAgIHZhciBhcnIwTGVuID0gYXJyMC5sZW5ndGg7XG4gICAgICAgIHZhciBhcnIxTGVuID0gYXJyMS5sZW5ndGg7XG4gICAgICAgIGlmIChhcnIwTGVuICE9PSBhcnIxTGVuKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSBOb3Qgd29yayBmb3IgVHlwZWRBcnJheVxuICAgICAgICAgICAgdmFyIGlzUHJldmlvdXNMYXJnZXIgPSBhcnIwTGVuID4gYXJyMUxlbjtcbiAgICAgICAgICAgIGlmIChpc1ByZXZpb3VzTGFyZ2VyKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3V0IHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgICAgIGFycjAubGVuZ3RoID0gYXJyMUxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZpbGwgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGFycjBMZW47IGkgPCBhcnIxTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyMC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyRGltID09PSAxID8gYXJyMVtpXSA6IGFycmF5U2xpY2UuY2FsbChhcnIxW2ldKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGluZyBOYU4gdmFsdWVcbiAgICAgICAgdmFyIGxlbjIgPSBhcnIwWzBdICYmIGFycjBbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycjAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYXJyMFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyMFtpXSA9IGFycjFbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGFycjBbaV1bal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIwW2ldW2pdID0gYXJyMVtpXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnIwXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFycjFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheVNhbWUoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gICAgICAgIGlmIChhcnIwID09PSBhcnIxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gYXJyMC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gIT09IGFycjEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyckRpbSA9PT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnIwW2ldICE9PSBhcnIxW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGVuMiA9IGFycjBbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnIwW2ldW2pdICE9PSBhcnIxW2ldW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2F0bXVsbCBSb20gaW50ZXJwb2xhdGUgYXJyYXlcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0M1xuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICBwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzLCBvdXQsIGFyckRpbVxuICAgICkge1xuICAgICAgICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyRGltID09IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUoXG4gICAgICAgICAgICAgICAgICAgIHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0LCB0MiwgdDNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxlbjIgPSBwMFswXS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0W2ldW2pdID0gY2F0bXVsbFJvbUludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcDBbaV1bal0sIHAxW2ldW2pdLCBwMltpXVtqXSwgcDNbaV1bal0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0LCB0MiwgdDNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBudW1iZXJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMpIHtcbiAgICAgICAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICAgICAgICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gICAgICAgIHJldHVybiAoMiAqIChwMSAtIHAyKSArIHYwICsgdjEpICogdDNcbiAgICAgICAgICAgICAgICArICgtMyAqIChwMSAtIHAyKSAtIDIgKiB2MCAtIHYxKSAqIHQyXG4gICAgICAgICAgICAgICAgKyB2MCAqIHQgKyBwMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWVbMF0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goYXJyYXlTbGljZS5jYWxsKHZhbHVlW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhcnJheVNsaWNlLmNhbGwodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJnYmEyU3RyaW5nKHJnYmEpIHtcbiAgICAgICAgcmdiYVswXSA9IE1hdGguZmxvb3IocmdiYVswXSk7XG4gICAgICAgIHJnYmFbMV0gPSBNYXRoLmZsb29yKHJnYmFbMV0pO1xuICAgICAgICByZ2JhWzJdID0gTWF0aC5mbG9vcihyZ2JhWzJdKTtcblxuICAgICAgICByZXR1cm4gJ3JnYmEoJyArIHJnYmEuam9pbignLCcpICsgJyknO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRyYWNrQ2xpcCAoYW5pbWF0b3IsIGVhc2luZywgb25lVHJhY2tEb25lLCBrZXlmcmFtZXMsIHByb3BOYW1lKSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBhbmltYXRvci5fZ2V0dGVyO1xuICAgICAgICB2YXIgc2V0dGVyID0gYW5pbWF0b3IuX3NldHRlcjtcbiAgICAgICAgdmFyIHVzZVNwbGluZSA9IGVhc2luZyA9PT0gJ3NwbGluZSc7XG5cbiAgICAgICAgdmFyIHRyYWNrTGVuID0ga2V5ZnJhbWVzLmxlbmd0aDtcbiAgICAgICAgaWYgKCF0cmFja0xlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEd1ZXNzIGRhdGEgdHlwZVxuICAgICAgICB2YXIgZmlyc3RWYWwgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gICAgICAgIHZhciBpc1ZhbHVlQXJyYXkgPSBpc0FycmF5TGlrZShmaXJzdFZhbCk7XG4gICAgICAgIHZhciBpc1ZhbHVlQ29sb3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIGlzVmFsdWVTdHJpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBGb3IgdmVydGljZXMgbW9ycGhpbmdcbiAgICAgICAgdmFyIGFyckRpbSA9IChcbiAgICAgICAgICAgICAgICBpc1ZhbHVlQXJyYXlcbiAgICAgICAgICAgICAgICAmJiBpc0FycmF5TGlrZShmaXJzdFZhbFswXSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgID8gMiA6IDE7XG4gICAgICAgIHZhciB0cmFja01heFRpbWU7XG4gICAgICAgIC8vIFNvcnQga2V5ZnJhbWUgYXMgYXNjZW5kaW5nXG4gICAgICAgIGtleWZyYW1lcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyYWNrTWF4VGltZSA9IGtleWZyYW1lc1t0cmFja0xlbiAtIDFdLnRpbWU7XG4gICAgICAgIC8vIFBlcmNlbnRzIG9mIGVhY2gga2V5ZnJhbWVcbiAgICAgICAgdmFyIGtmUGVyY2VudHMgPSBbXTtcbiAgICAgICAgLy8gVmFsdWUgb2YgZWFjaCBrZXlmcmFtZVxuICAgICAgICB2YXIga2ZWYWx1ZXMgPSBbXTtcbiAgICAgICAgdmFyIHByZXZWYWx1ZSA9IGtleWZyYW1lc1swXS52YWx1ZTtcbiAgICAgICAgdmFyIGlzQWxsVmFsdWVFcXVhbCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW47IGkrKykge1xuICAgICAgICAgICAga2ZQZXJjZW50cy5wdXNoKGtleWZyYW1lc1tpXS50aW1lIC8gdHJhY2tNYXhUaW1lKTtcbiAgICAgICAgICAgIC8vIEFzc3VtZSB2YWx1ZSBpcyBhIGNvbG9yIHdoZW4gaXQgaXMgYSBzdHJpbmdcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGtleWZyYW1lc1tpXS52YWx1ZTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdmFsdWUgaXMgZXF1YWwsIGRlZXAgY2hlY2sgaWYgdmFsdWUgaXMgYXJyYXlcbiAgICAgICAgICAgIGlmICghKChpc1ZhbHVlQXJyYXkgJiYgaXNBcnJheVNhbWUodmFsdWUsIHByZXZWYWx1ZSwgYXJyRGltKSlcbiAgICAgICAgICAgICAgICB8fCAoIWlzVmFsdWVBcnJheSAmJiB2YWx1ZSA9PT0gcHJldlZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICBpc0FsbFZhbHVlRXF1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAvLyBUcnkgY29udmVydGluZyBhIHN0cmluZyB0byBhIGNvbG9yIGFycmF5XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yQXJyYXkgPSBjb2xvci5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb2xvckFycmF5O1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbHVlQ29sb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWx1ZVN0cmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2ZWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQWxsVmFsdWVFcXVhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IGtmVmFsdWVzW3RyYWNrTGVuIC0gMV07XG4gICAgICAgIC8vIFBvbHlmaWxsIGFycmF5IGFuZCBOYU4gdmFsdWVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja0xlbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgICAgICAgICAgIGZpbGxBcnIoa2ZWYWx1ZXNbaV0sIGxhc3RWYWx1ZSwgYXJyRGltKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihrZlZhbHVlc1tpXSkgJiYgIWlzTmFOKGxhc3RWYWx1ZSkgJiYgIWlzVmFsdWVTdHJpbmcgJiYgIWlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBrZlZhbHVlc1tpXSA9IGxhc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNWYWx1ZUFycmF5ICYmIGZpbGxBcnIoZ2V0dGVyKGFuaW1hdG9yLl90YXJnZXQsIHByb3BOYW1lKSwgbGFzdFZhbHVlLCBhcnJEaW0pO1xuXG4gICAgICAgIC8vIENhY2hlIHRoZSBrZXkgb2YgbGFzdCBmcmFtZSB0byBzcGVlZCB1cCB3aGVuXG4gICAgICAgIC8vIGFuaW1hdGlvbiBwbGF5YmFjayBpcyBzZXF1ZW5jeVxuICAgICAgICB2YXIgbGFzdEZyYW1lID0gMDtcbiAgICAgICAgdmFyIGxhc3RGcmFtZVBlcmNlbnQgPSAwO1xuICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgIHZhciB3O1xuICAgICAgICB2YXIgcDA7XG4gICAgICAgIHZhciBwMTtcbiAgICAgICAgdmFyIHAyO1xuICAgICAgICB2YXIgcDM7XG5cbiAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgdmFyIHJnYmEgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb25mcmFtZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHJhbmdlIGtleWZyYW1lc1xuICAgICAgICAgICAgLy8ga2YxLS0tLS1rZjItLS0tLS0tLS1jdXJyZW50LS0tLS0tLS1rZjNcbiAgICAgICAgICAgIC8vIGZpbmQga2YyIGFuZCBrZjMgYW5kIGRvIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIHZhciBmcmFtZTtcbiAgICAgICAgICAgIC8vIEluIHRoZSBlYXNpbmcgZnVuY3Rpb24gbGlrZSBlbGFzdGljT3V0LCBwZXJjZW50IG1heSBsZXNzIHRoYW4gMFxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgZnJhbWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGVyY2VudCA8IGxhc3RGcmFtZVBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBmcm9tIG5leHQga2V5XG4gICAgICAgICAgICAgICAgLy8gUEVORElORyBzdGFydCBmcm9tIGxhc3RGcmFtZSA/XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1pbihsYXN0RnJhbWUgKyAxLCB0cmFja0xlbiAtIDEpO1xuICAgICAgICAgICAgICAgIGZvciAoZnJhbWUgPSBzdGFydDsgZnJhbWUgPj0gMDsgZnJhbWUtLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2ZQZXJjZW50c1tmcmFtZV0gPD0gcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUEVORElORyByZWFsbHkgbmVlZCB0byBkbyB0aGlzID9cbiAgICAgICAgICAgICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lLCB0cmFja0xlbiAtIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChmcmFtZSA9IGxhc3RGcmFtZTsgZnJhbWUgPCB0cmFja0xlbjsgZnJhbWUrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2ZQZXJjZW50c1tmcmFtZV0gPiBwZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lIC0gMSwgdHJhY2tMZW4gLSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RGcmFtZSA9IGZyYW1lO1xuICAgICAgICAgICAgbGFzdEZyYW1lUGVyY2VudCA9IHBlcmNlbnQ7XG5cbiAgICAgICAgICAgIHZhciByYW5nZSA9IChrZlBlcmNlbnRzW2ZyYW1lICsgMV0gLSBrZlBlcmNlbnRzW2ZyYW1lXSk7XG4gICAgICAgICAgICBpZiAocmFuZ2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3ID0gKHBlcmNlbnQgLSBrZlBlcmNlbnRzW2ZyYW1lXSkgLyByYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1c2VTcGxpbmUpIHtcbiAgICAgICAgICAgICAgICBwMSA9IGtmVmFsdWVzW2ZyYW1lXTtcbiAgICAgICAgICAgICAgICBwMCA9IGtmVmFsdWVzW2ZyYW1lID09PSAwID8gZnJhbWUgOiBmcmFtZSAtIDFdO1xuICAgICAgICAgICAgICAgIHAyID0ga2ZWYWx1ZXNbZnJhbWUgPiB0cmFja0xlbiAtIDIgPyB0cmFja0xlbiAtIDEgOiBmcmFtZSArIDFdO1xuICAgICAgICAgICAgICAgIHAzID0ga2ZWYWx1ZXNbZnJhbWUgPiB0cmFja0xlbiAtIDMgPyB0cmFja0xlbiAtIDEgOiBmcmFtZSArIDJdO1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICBwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldHRlcih0YXJnZXQsIHByb3BOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyckRpbVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJnYmEsIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJnYmEyU3RyaW5nKHJnYmEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmluZyBpcyBzdGVwKDAuNSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVN0cmluZyhwMSwgcDIsIHcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHdcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgIGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldHRlcih0YXJnZXQsIHByb3BOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyckRpbVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZ2JhLCAxXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmcgaXMgc3RlcCgwLjUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaW50ZXJwb2xhdGVOdW1iZXIoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXR0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjbGlwID0gbmV3IENsaXAoe1xuICAgICAgICAgICAgdGFyZ2V0OiBhbmltYXRvci5fdGFyZ2V0LFxuICAgICAgICAgICAgbGlmZTogdHJhY2tNYXhUaW1lLFxuICAgICAgICAgICAgbG9vcDogYW5pbWF0b3IuX2xvb3AsXG4gICAgICAgICAgICBkZWxheTogYW5pbWF0b3IuX2RlbGF5LFxuICAgICAgICAgICAgb25mcmFtZTogb25mcmFtZSxcbiAgICAgICAgICAgIG9uZGVzdHJveTogb25lVHJhY2tEb25lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlYXNpbmcgJiYgZWFzaW5nICE9PSAnc3BsaW5lJykge1xuICAgICAgICAgICAgY2xpcC5lYXNpbmcgPSBlYXNpbmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xpcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlclxuICAgICAqL1xuICAgIHZhciBBbmltYXRvciA9IGZ1bmN0aW9uKHRhcmdldCwgbG9vcCwgZ2V0dGVyLCBzZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5fdHJhY2tzID0ge307XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcblxuICAgICAgICB0aGlzLl9sb29wID0gbG9vcCB8fCBmYWxzZTtcblxuICAgICAgICB0aGlzLl9nZXR0ZXIgPSBnZXR0ZXIgfHwgZGVmYXVsdEdldHRlcjtcbiAgICAgICAgdGhpcy5fc2V0dGVyID0gc2V0dGVyIHx8IGRlZmF1bHRTZXR0ZXI7XG5cbiAgICAgICAgdGhpcy5fY2xpcENvdW50ID0gMDtcblxuICAgICAgICB0aGlzLl9kZWxheSA9IDA7XG5cbiAgICAgICAgdGhpcy5fZG9uZUxpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9vbmZyYW1lTGlzdCA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2NsaXBMaXN0ID0gW107XG4gICAgfTtcblxuICAgIEFuaW1hdG9yLnByb3RvdHlwZSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruWKqOeUu+WFs+mUruW4p1xuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRpbWUg5YWz6ZSu5bin5pe26Ze077yM5Y2V5L2N5pivbXNcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBwcm9wcyDlhbPplK7luKfnmoTlsZ7mgKflgLzvvIxrZXktdmFsdWXooajnpLpcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgd2hlbjogZnVuY3Rpb24odGltZSAvKiBtcyAqLywgcHJvcHMpIHtcbiAgICAgICAgICAgIHZhciB0cmFja3MgPSB0aGlzLl90cmFja3M7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghdHJhY2tzW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdID0gW107XG4gICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0dGVyKHRoaXMuX3RhcmdldCwgcHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8genJMb2coJ0ludmFsaWQgcHJvcGVydHkgJyArIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRpbWUgaXMgMFxuICAgICAgICAgICAgICAgICAgICAvLyAgVGhlbiBwcm9wcyBpcyBnaXZlbiBpbml0aWFsaXplIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gIEluaXRpYWxpemUgdmFsdWUgZnJvbSBjdXJyZW50IHByb3AgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrc1twcm9wTmFtZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2xvbmVWYWx1ZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYWNrc1twcm9wTmFtZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9wc1twcm9wTmFtZV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5Yqo55S75q+P5LiA5bin55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkdXJpbmc6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fb25mcmFtZUxpc3QucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsaXBMaXN0W2ldLnBhdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsaXBMaXN0W2ldLnJlc3VtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNQYXVzZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuX3BhdXNlZDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZG9uZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDbGVhciBhbGwgdHJhY2tzXG4gICAgICAgICAgICB0aGlzLl90cmFja3MgPSB7fTtcbiAgICAgICAgICAgIC8vIENsZWFyIGFsbCBjbGlwc1xuICAgICAgICAgICAgdGhpcy5fY2xpcExpc3QubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgdmFyIGRvbmVMaXN0ID0gdGhpcy5fZG9uZUxpc3Q7XG4gICAgICAgICAgICB2YXIgbGVuID0gZG9uZUxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGRvbmVMaXN0W2ldLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvIDlp4vmiafooYzliqjnlLtcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfEZ1bmN0aW9ufSBlYXNpbmdcbiAgICAgICAgICogICAgICAgICDliqjnlLvnvJPliqjlh73mlbDvvIzor6bop4F7QGxpbmsgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZ31cbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uIChlYXNpbmcpIHtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNsaXBDb3VudCA9IDA7XG5cbiAgICAgICAgICAgIHZhciBvbmVUcmFja0RvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjbGlwQ291bnQtLTtcbiAgICAgICAgICAgICAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kb25lQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgbGFzdENsaXA7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0aGlzLl90cmFja3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3RyYWNrcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjbGlwID0gY3JlYXRlVHJhY2tDbGlwKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLCBlYXNpbmcsIG9uZVRyYWNrRG9uZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhY2tzW3Byb3BOYW1lXSwgcHJvcE5hbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsaXBMaXN0LnB1c2goY2xpcCk7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBDb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHN0YXJ0IGFmdGVyIGFkZGVkIHRvIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmFkZENsaXAoY2xpcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsYXN0Q2xpcCA9IGNsaXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgZHVyaW5nIGNhbGxiYWNrIG9uIHRoZSBsYXN0IGNsaXBcbiAgICAgICAgICAgIGlmIChsYXN0Q2xpcCkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRPbkZyYW1lID0gbGFzdENsaXAub25mcmFtZTtcbiAgICAgICAgICAgICAgICBsYXN0Q2xpcC5vbmZyYW1lID0gZnVuY3Rpb24gKHRhcmdldCwgcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRPbkZyYW1lKHRhcmdldCwgcGVyY2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl9vbmZyYW1lTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25mcmFtZUxpc3RbaV0odGFyZ2V0LCBwZXJjZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2xpcENvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9uZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWBnOatouWKqOeUu1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcndhcmRUb0xhc3QgSWYgbW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoZm9yd2FyZFRvTGFzdCkge1xuICAgICAgICAgICAgdmFyIGNsaXBMaXN0ID0gdGhpcy5fY2xpcExpc3Q7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb247XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsaXAgPSBjbGlwTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZFRvTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICAgICAgICAgICAgICAgICAgY2xpcC5vbmZyYW1lKHRoaXMuX3RhcmdldCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucmVtb3ZlQ2xpcChjbGlwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsaXBMaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7liqjnlLvlu7bov5/lvIDlp4vnmoTml7bpl7RcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWNleS9jW1zXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIGRlbGF5OiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVsYXkgPSB0aW1lO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDliqjnlLvnu5PmnZ/nmoTlm57osINcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIGRvbmU6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb25lTGlzdC5wdXNoKGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXA+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2xpcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGlwTGlzdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFuaW1hdG9yO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICog5Yqo55S75Li75o6n5Yi25ZmoXG4gKiBAY29uZmlnIHRhcmdldCDliqjnlLvlr7nosaHvvIzlj6/ku6XmmK/mlbDnu4TvvIzlpoLmnpzmmK/mlbDnu4TnmoTor53kvJrmibnph4/liIblj5FvbmZyYW1l562J5LqL5Lu2XG4gKiBAY29uZmlnIGxpZmUoMTAwMCkg5Yqo55S75pe26ZW/XG4gKiBAY29uZmlnIGRlbGF5KDApIOWKqOeUu+W7tui/n+aXtumXtFxuICogQGNvbmZpZyBsb29wKHRydWUpXG4gKiBAY29uZmlnIGdhcCgwKSDlvqrnjq/nmoTpl7TpmpTml7bpl7RcbiAqIEBjb25maWcgb25mcmFtZVxuICogQGNvbmZpZyBlYXNpbmcob3B0aW9uYWwpXG4gKiBAY29uZmlnIG9uZGVzdHJveShvcHRpb25hbClcbiAqIEBjb25maWcgb25yZXN0YXJ0KG9wdGlvbmFsKVxuICpcbiAqIFRPRE8gcGF1c2VcbiAqL1xuXG5cbiAgICB2YXIgZWFzaW5nRnVuY3MgPSByZXF1aXJlKCcuL2Vhc2luZycpO1xuXG4gICAgZnVuY3Rpb24gQ2xpcChvcHRpb25zKSB7XG5cbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG5cbiAgICAgICAgLy8g55Sf5ZG95ZGo5pyfXG4gICAgICAgIHRoaXMuX2xpZmUgPSBvcHRpb25zLmxpZmUgfHwgMTAwMDtcbiAgICAgICAgLy8g5bu25pe2XG4gICAgICAgIHRoaXMuX2RlbGF5ID0gb3B0aW9ucy5kZWxheSB8fCAwO1xuICAgICAgICAvLyDlvIDlp4vml7bpl7RcbiAgICAgICAgLy8gdGhpcy5fc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyB0aGlzLl9kZWxheTsvLyDljZXkvY3mr6vnp5JcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyDmmK/lkKblvqrnjq9cbiAgICAgICAgdGhpcy5sb29wID0gb3B0aW9ucy5sb29wID09IG51bGwgPyBmYWxzZSA6IG9wdGlvbnMubG9vcDtcblxuICAgICAgICB0aGlzLmdhcCA9IG9wdGlvbnMuZ2FwIHx8IDA7XG5cbiAgICAgICAgdGhpcy5lYXNpbmcgPSBvcHRpb25zLmVhc2luZyB8fCAnTGluZWFyJztcblxuICAgICAgICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWU7XG4gICAgICAgIHRoaXMub25kZXN0cm95ID0gb3B0aW9ucy5vbmRlc3Ryb3k7XG4gICAgICAgIHRoaXMub25yZXN0YXJ0ID0gb3B0aW9ucy5vbnJlc3RhcnQ7XG5cbiAgICAgICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIENsaXAucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBDbGlwLFxuXG4gICAgICAgIHN0ZXA6IGZ1bmN0aW9uIChnbG9iYWxUaW1lLCBkZWx0YVRpbWUpIHtcbiAgICAgICAgICAgIC8vIFNldCBzdGFydFRpbWUgb24gZmlyc3Qgc3RlcCwgb3IgX3N0YXJ0VGltZSBtYXkgaGFzIG1pbGxlc2Vjb25kcyBkaWZmZXJlbnQgYmV0d2VlbiBjbGlwc1xuICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IGdsb2JhbFRpbWUgKyB0aGlzLl9kZWxheTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZWRUaW1lICs9IGRlbHRhVGltZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gKGdsb2JhbFRpbWUgLSB0aGlzLl9zdGFydFRpbWUgLSB0aGlzLl9wYXVzZWRUaW1lKSAvIHRoaXMuX2xpZmU7XG5cbiAgICAgICAgICAgIC8vIOi/mOayoeW8gOWni1xuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwZXJjZW50ID0gTWF0aC5taW4ocGVyY2VudCwgMSk7XG5cbiAgICAgICAgICAgIHZhciBlYXNpbmcgPSB0aGlzLmVhc2luZztcbiAgICAgICAgICAgIHZhciBlYXNpbmdGdW5jID0gdHlwZW9mIGVhc2luZyA9PSAnc3RyaW5nJyA/IGVhc2luZ0Z1bmNzW2Vhc2luZ10gOiBlYXNpbmc7XG4gICAgICAgICAgICB2YXIgc2NoZWR1bGUgPSB0eXBlb2YgZWFzaW5nRnVuYyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gZWFzaW5nRnVuYyhwZXJjZW50KVxuICAgICAgICAgICAgICAgIDogcGVyY2VudDtcblxuICAgICAgICAgICAgdGhpcy5maXJlKCdmcmFtZScsIHNjaGVkdWxlKTtcblxuICAgICAgICAgICAgLy8g57uT5p2fXG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9vcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RhcnQgKGdsb2JhbFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyDph43mlrDlvIDlp4vlkajmnJ9cbiAgICAgICAgICAgICAgICAgICAgLy8g5oqb5Ye66ICM5LiN5piv55u05o6l6LCD55So5LqL5Lu255u05YiwIHN0YWdlLnVwZGF0ZSDlkI7lho3nu5/kuIDosIPnlKjov5nkupvkuovku7ZcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyZXN0YXJ0JztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyDliqjnlLvlrozmiJDlsIbov5nkuKrmjqfliLblmajmoIfor4bkuLrlvoXliKDpmaRcbiAgICAgICAgICAgICAgICAvLyDlnKhBbmltYXRpb24udXBkYXRl5Lit6L+b6KGM5om56YeP5Yig6ZmkXG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNSZW1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZGVzdHJveSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RhcnQ6IGZ1bmN0aW9uIChnbG9iYWxUaW1lKSB7XG4gICAgICAgICAgICB2YXIgcmVtYWluZGVyID0gKGdsb2JhbFRpbWUgLSB0aGlzLl9zdGFydFRpbWUgLSB0aGlzLl9wYXVzZWRUaW1lKSAlIHRoaXMuX2xpZmU7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lIC0gcmVtYWluZGVyICsgdGhpcy5nYXA7XG4gICAgICAgICAgICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcblxuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZW1vdmUgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaXJlOiBmdW5jdGlvbiAoZXZlbnRUeXBlLCBhcmcpIHtcbiAgICAgICAgICAgIGV2ZW50VHlwZSA9ICdvbicgKyBldmVudFR5cGU7XG4gICAgICAgICAgICBpZiAodGhpc1tldmVudFR5cGVdKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tldmVudFR5cGVdKHRoaXMuX3RhcmdldCwgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQ2xpcDtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanNcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDnvJPliqjku6PnoIHmnaXoh6ogaHR0cHM6Ly9naXRodWIuY29tL3NvbGUvdHdlZW4uanMvYmxvYi9tYXN0ZXIvc3JjL1R3ZWVuLmpzXG4gKiBAc2VlIGh0dHA6Ly9zb2xlLmdpdGh1Yi5pby90d2Vlbi5qcy9leGFtcGxlcy8wM19ncmFwaHMuaHRtbFxuICogQGV4cG9ydHMgenJlbmRlci9hbmltYXRpb24vZWFzaW5nXG4gKi9cblxuICAgIHZhciBlYXNpbmcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBsaW5lYXI6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhZHJhdGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqIGs7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFkcmF0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqICgyIC0gayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFkcmF0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5LiJ5qyh5pa555qE57yT5Yqo77yIdF4z77yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjdWJpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrICogaztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGN1YmljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGN1YmljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWbm+asoeaWueeahOe8k+WKqO+8iHReNO+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhcnRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrICogayAqIGs7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFydGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSAoLS1rICogayAqIGsgKiBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YXJ0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKChrIC09IDIpICogayAqIGsgKiBrIC0gMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5LqU5qyh5pa555qE57yT5Yqo77yIdF4177yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWludGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqIGsgKiBrICogayAqIGs7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWludGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIC0tayAqIGsgKiBrICogayAqIGsgKyAxO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVpbnRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5q2j5bym5puy57q/55qE57yT5Yqo77yIc2luKHQp77yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBzaW51c29pZGFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIE1hdGguY29zKGsgKiBNYXRoLlBJIC8gMik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBzaW51c29pZGFsT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc2luKGsgKiBNYXRoLlBJIC8gMik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBzaW51c29pZGFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOaMh+aVsOabsue6v+eahOe8k+WKqO+8iDJedO+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZXhwb25lbnRpYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrID09PSAwID8gMCA6IE1hdGgucG93KDEwMjQsIGsgLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGV4cG9uZW50aWFsT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgPT09IDEgPyAxIDogMSAtIE1hdGgucG93KDIsIC0xMCAqIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZXhwb25lbnRpYWxJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAoayAtIDEpKSArIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWchuW9ouabsue6v+eahOe8k+WKqO+8iHNxcnQoMS10XjIp77yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjaXJjdWxhckluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIGsgKiBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGNpcmN1bGFyT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCgxIC0gKC0tayAqIGspKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGNpcmN1bGFySW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBrICogaykgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoayAtPSAyKSAqIGspICsgMSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5Yib5bu657G75Ly85LqO5by557Cn5Zyo5YGc5q2i5YmN5p2l5Zue5oyv6I2h55qE5Yqo55S7XG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBlbGFzdGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcztcbiAgICAgICAgICAgIHZhciBhID0gMC4xO1xuICAgICAgICAgICAgdmFyIHAgPSAwLjQ7XG4gICAgICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgICAgICAgICAgIGEgPSAxOyBzID0gcCAvIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0oYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZWxhc3RpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzO1xuICAgICAgICAgICAgdmFyIGEgPSAwLjE7XG4gICAgICAgICAgICB2YXIgcCA9IDAuNDtcbiAgICAgICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICAgICAgICAgICAgYSA9IDE7IHMgPSBwIC8gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGEgKiBNYXRoLnBvdygyLCAtMTAgKiBrKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGVsYXN0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzO1xuICAgICAgICAgICAgdmFyIGEgPSAwLjE7XG4gICAgICAgICAgICB2YXIgcCA9IDAuNDtcbiAgICAgICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICAgICAgICAgICAgYSA9IDE7IHMgPSBwIC8gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpXG4gICAgICAgICAgICAgICAgICAgICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIChrIC09IDEpKVxuICAgICAgICAgICAgICAgICAgICAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5Zyo5p+Q5LiA5Yqo55S75byA5aeL5rK/5oyH56S655qE6Lev5b6E6L+b6KGM5Yqo55S75aSE55CG5YmN56iN56iN5pS25Zue6K+l5Yqo55S755qE56e75YqoXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBiYWNrSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJhY2tPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gLS1rICogayAqICgocyArIDEpICogayArIHMpICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJhY2tJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1OCAqIDEuNTI1O1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiAoayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqICgocyArIDEpICogayArIHMpICsgMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5Yib5bu65by56Lez5pWI5p6cXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBib3VuY2VJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gZWFzaW5nLmJvdW5jZU91dCgxIC0gayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBib3VuY2VPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoayA8ICgxIC8gMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrIDwgKDIgLyAyLjc1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAoMS41IC8gMi43NSkpICogayArIDAuNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrIDwgKDIuNSAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgyLjI1IC8gMi43NSkpICogayArIDAuOTM3NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAoMi42MjUgLyAyLjc1KSkgKiBrICsgMC45ODQzNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBib3VuY2VJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrIDwgMC41KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVhc2luZy5ib3VuY2VJbihrICogMikgKiAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZU91dChrICogMiAtIDEpICogMC41ICsgMC41O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZWFzaW5nO1xuXG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvdG9vbC9jb2xvclxuICovXG5cblxuICAgIHZhciBMUlUgPSByZXF1aXJlKCcuLi9jb3JlL0xSVScpO1xuXG4gICAgdmFyIGtDU1NDb2xvclRhYmxlID0ge1xuICAgICAgICAndHJhbnNwYXJlbnQnOiBbMCwwLDAsMF0sICdhbGljZWJsdWUnOiBbMjQwLDI0OCwyNTUsMV0sXG4gICAgICAgICdhbnRpcXVld2hpdGUnOiBbMjUwLDIzNSwyMTUsMV0sICdhcXVhJzogWzAsMjU1LDI1NSwxXSxcbiAgICAgICAgJ2FxdWFtYXJpbmUnOiBbMTI3LDI1NSwyMTIsMV0sICdhenVyZSc6IFsyNDAsMjU1LDI1NSwxXSxcbiAgICAgICAgJ2JlaWdlJzogWzI0NSwyNDUsMjIwLDFdLCAnYmlzcXVlJzogWzI1NSwyMjgsMTk2LDFdLFxuICAgICAgICAnYmxhY2snOiBbMCwwLDAsMV0sICdibGFuY2hlZGFsbW9uZCc6IFsyNTUsMjM1LDIwNSwxXSxcbiAgICAgICAgJ2JsdWUnOiBbMCwwLDI1NSwxXSwgJ2JsdWV2aW9sZXQnOiBbMTM4LDQzLDIyNiwxXSxcbiAgICAgICAgJ2Jyb3duJzogWzE2NSw0Miw0MiwxXSwgJ2J1cmx5d29vZCc6IFsyMjIsMTg0LDEzNSwxXSxcbiAgICAgICAgJ2NhZGV0Ymx1ZSc6IFs5NSwxNTgsMTYwLDFdLCAnY2hhcnRyZXVzZSc6IFsxMjcsMjU1LDAsMV0sXG4gICAgICAgICdjaG9jb2xhdGUnOiBbMjEwLDEwNSwzMCwxXSwgJ2NvcmFsJzogWzI1NSwxMjcsODAsMV0sXG4gICAgICAgICdjb3JuZmxvd2VyYmx1ZSc6IFsxMDAsMTQ5LDIzNywxXSwgJ2Nvcm5zaWxrJzogWzI1NSwyNDgsMjIwLDFdLFxuICAgICAgICAnY3JpbXNvbic6IFsyMjAsMjAsNjAsMV0sICdjeWFuJzogWzAsMjU1LDI1NSwxXSxcbiAgICAgICAgJ2RhcmtibHVlJzogWzAsMCwxMzksMV0sICdkYXJrY3lhbic6IFswLDEzOSwxMzksMV0sXG4gICAgICAgICdkYXJrZ29sZGVucm9kJzogWzE4NCwxMzQsMTEsMV0sICdkYXJrZ3JheSc6IFsxNjksMTY5LDE2OSwxXSxcbiAgICAgICAgJ2RhcmtncmVlbic6IFswLDEwMCwwLDFdLCAnZGFya2dyZXknOiBbMTY5LDE2OSwxNjksMV0sXG4gICAgICAgICdkYXJra2hha2knOiBbMTg5LDE4MywxMDcsMV0sICdkYXJrbWFnZW50YSc6IFsxMzksMCwxMzksMV0sXG4gICAgICAgICdkYXJrb2xpdmVncmVlbic6IFs4NSwxMDcsNDcsMV0sICdkYXJrb3JhbmdlJzogWzI1NSwxNDAsMCwxXSxcbiAgICAgICAgJ2RhcmtvcmNoaWQnOiBbMTUzLDUwLDIwNCwxXSwgJ2RhcmtyZWQnOiBbMTM5LDAsMCwxXSxcbiAgICAgICAgJ2RhcmtzYWxtb24nOiBbMjMzLDE1MCwxMjIsMV0sICdkYXJrc2VhZ3JlZW4nOiBbMTQzLDE4OCwxNDMsMV0sXG4gICAgICAgICdkYXJrc2xhdGVibHVlJzogWzcyLDYxLDEzOSwxXSwgJ2RhcmtzbGF0ZWdyYXknOiBbNDcsNzksNzksMV0sXG4gICAgICAgICdkYXJrc2xhdGVncmV5JzogWzQ3LDc5LDc5LDFdLCAnZGFya3R1cnF1b2lzZSc6IFswLDIwNiwyMDksMV0sXG4gICAgICAgICdkYXJrdmlvbGV0JzogWzE0OCwwLDIxMSwxXSwgJ2RlZXBwaW5rJzogWzI1NSwyMCwxNDcsMV0sXG4gICAgICAgICdkZWVwc2t5Ymx1ZSc6IFswLDE5MSwyNTUsMV0sICdkaW1ncmF5JzogWzEwNSwxMDUsMTA1LDFdLFxuICAgICAgICAnZGltZ3JleSc6IFsxMDUsMTA1LDEwNSwxXSwgJ2RvZGdlcmJsdWUnOiBbMzAsMTQ0LDI1NSwxXSxcbiAgICAgICAgJ2ZpcmVicmljayc6IFsxNzgsMzQsMzQsMV0sICdmbG9yYWx3aGl0ZSc6IFsyNTUsMjUwLDI0MCwxXSxcbiAgICAgICAgJ2ZvcmVzdGdyZWVuJzogWzM0LDEzOSwzNCwxXSwgJ2Z1Y2hzaWEnOiBbMjU1LDAsMjU1LDFdLFxuICAgICAgICAnZ2FpbnNib3JvJzogWzIyMCwyMjAsMjIwLDFdLCAnZ2hvc3R3aGl0ZSc6IFsyNDgsMjQ4LDI1NSwxXSxcbiAgICAgICAgJ2dvbGQnOiBbMjU1LDIxNSwwLDFdLCAnZ29sZGVucm9kJzogWzIxOCwxNjUsMzIsMV0sXG4gICAgICAgICdncmF5JzogWzEyOCwxMjgsMTI4LDFdLCAnZ3JlZW4nOiBbMCwxMjgsMCwxXSxcbiAgICAgICAgJ2dyZWVueWVsbG93JzogWzE3MywyNTUsNDcsMV0sICdncmV5JzogWzEyOCwxMjgsMTI4LDFdLFxuICAgICAgICAnaG9uZXlkZXcnOiBbMjQwLDI1NSwyNDAsMV0sICdob3RwaW5rJzogWzI1NSwxMDUsMTgwLDFdLFxuICAgICAgICAnaW5kaWFucmVkJzogWzIwNSw5Miw5MiwxXSwgJ2luZGlnbyc6IFs3NSwwLDEzMCwxXSxcbiAgICAgICAgJ2l2b3J5JzogWzI1NSwyNTUsMjQwLDFdLCAna2hha2knOiBbMjQwLDIzMCwxNDAsMV0sXG4gICAgICAgICdsYXZlbmRlcic6IFsyMzAsMjMwLDI1MCwxXSwgJ2xhdmVuZGVyYmx1c2gnOiBbMjU1LDI0MCwyNDUsMV0sXG4gICAgICAgICdsYXduZ3JlZW4nOiBbMTI0LDI1MiwwLDFdLCAnbGVtb25jaGlmZm9uJzogWzI1NSwyNTAsMjA1LDFdLFxuICAgICAgICAnbGlnaHRibHVlJzogWzE3MywyMTYsMjMwLDFdLCAnbGlnaHRjb3JhbCc6IFsyNDAsMTI4LDEyOCwxXSxcbiAgICAgICAgJ2xpZ2h0Y3lhbic6IFsyMjQsMjU1LDI1NSwxXSwgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzogWzI1MCwyNTAsMjEwLDFdLFxuICAgICAgICAnbGlnaHRncmF5JzogWzIxMSwyMTEsMjExLDFdLCAnbGlnaHRncmVlbic6IFsxNDQsMjM4LDE0NCwxXSxcbiAgICAgICAgJ2xpZ2h0Z3JleSc6IFsyMTEsMjExLDIxMSwxXSwgJ2xpZ2h0cGluayc6IFsyNTUsMTgyLDE5MywxXSxcbiAgICAgICAgJ2xpZ2h0c2FsbW9uJzogWzI1NSwxNjAsMTIyLDFdLCAnbGlnaHRzZWFncmVlbic6IFszMiwxNzgsMTcwLDFdLFxuICAgICAgICAnbGlnaHRza3libHVlJzogWzEzNSwyMDYsMjUwLDFdLCAnbGlnaHRzbGF0ZWdyYXknOiBbMTE5LDEzNiwxNTMsMV0sXG4gICAgICAgICdsaWdodHNsYXRlZ3JleSc6IFsxMTksMTM2LDE1MywxXSwgJ2xpZ2h0c3RlZWxibHVlJzogWzE3NiwxOTYsMjIyLDFdLFxuICAgICAgICAnbGlnaHR5ZWxsb3cnOiBbMjU1LDI1NSwyMjQsMV0sICdsaW1lJzogWzAsMjU1LDAsMV0sXG4gICAgICAgICdsaW1lZ3JlZW4nOiBbNTAsMjA1LDUwLDFdLCAnbGluZW4nOiBbMjUwLDI0MCwyMzAsMV0sXG4gICAgICAgICdtYWdlbnRhJzogWzI1NSwwLDI1NSwxXSwgJ21hcm9vbic6IFsxMjgsMCwwLDFdLFxuICAgICAgICAnbWVkaXVtYXF1YW1hcmluZSc6IFsxMDIsMjA1LDE3MCwxXSwgJ21lZGl1bWJsdWUnOiBbMCwwLDIwNSwxXSxcbiAgICAgICAgJ21lZGl1bW9yY2hpZCc6IFsxODYsODUsMjExLDFdLCAnbWVkaXVtcHVycGxlJzogWzE0NywxMTIsMjE5LDFdLFxuICAgICAgICAnbWVkaXVtc2VhZ3JlZW4nOiBbNjAsMTc5LDExMywxXSwgJ21lZGl1bXNsYXRlYmx1ZSc6IFsxMjMsMTA0LDIzOCwxXSxcbiAgICAgICAgJ21lZGl1bXNwcmluZ2dyZWVuJzogWzAsMjUwLDE1NCwxXSwgJ21lZGl1bXR1cnF1b2lzZSc6IFs3MiwyMDksMjA0LDFdLFxuICAgICAgICAnbWVkaXVtdmlvbGV0cmVkJzogWzE5OSwyMSwxMzMsMV0sICdtaWRuaWdodGJsdWUnOiBbMjUsMjUsMTEyLDFdLFxuICAgICAgICAnbWludGNyZWFtJzogWzI0NSwyNTUsMjUwLDFdLCAnbWlzdHlyb3NlJzogWzI1NSwyMjgsMjI1LDFdLFxuICAgICAgICAnbW9jY2FzaW4nOiBbMjU1LDIyOCwxODEsMV0sICduYXZham93aGl0ZSc6IFsyNTUsMjIyLDE3MywxXSxcbiAgICAgICAgJ25hdnknOiBbMCwwLDEyOCwxXSwgJ29sZGxhY2UnOiBbMjUzLDI0NSwyMzAsMV0sXG4gICAgICAgICdvbGl2ZSc6IFsxMjgsMTI4LDAsMV0sICdvbGl2ZWRyYWInOiBbMTA3LDE0MiwzNSwxXSxcbiAgICAgICAgJ29yYW5nZSc6IFsyNTUsMTY1LDAsMV0sICdvcmFuZ2VyZWQnOiBbMjU1LDY5LDAsMV0sXG4gICAgICAgICdvcmNoaWQnOiBbMjE4LDExMiwyMTQsMV0sICdwYWxlZ29sZGVucm9kJzogWzIzOCwyMzIsMTcwLDFdLFxuICAgICAgICAncGFsZWdyZWVuJzogWzE1MiwyNTEsMTUyLDFdLCAncGFsZXR1cnF1b2lzZSc6IFsxNzUsMjM4LDIzOCwxXSxcbiAgICAgICAgJ3BhbGV2aW9sZXRyZWQnOiBbMjE5LDExMiwxNDcsMV0sICdwYXBheWF3aGlwJzogWzI1NSwyMzksMjEzLDFdLFxuICAgICAgICAncGVhY2hwdWZmJzogWzI1NSwyMTgsMTg1LDFdLCAncGVydSc6IFsyMDUsMTMzLDYzLDFdLFxuICAgICAgICAncGluayc6IFsyNTUsMTkyLDIwMywxXSwgJ3BsdW0nOiBbMjIxLDE2MCwyMjEsMV0sXG4gICAgICAgICdwb3dkZXJibHVlJzogWzE3NiwyMjQsMjMwLDFdLCAncHVycGxlJzogWzEyOCwwLDEyOCwxXSxcbiAgICAgICAgJ3JlZCc6IFsyNTUsMCwwLDFdLCAncm9zeWJyb3duJzogWzE4OCwxNDMsMTQzLDFdLFxuICAgICAgICAncm95YWxibHVlJzogWzY1LDEwNSwyMjUsMV0sICdzYWRkbGVicm93bic6IFsxMzksNjksMTksMV0sXG4gICAgICAgICdzYWxtb24nOiBbMjUwLDEyOCwxMTQsMV0sICdzYW5keWJyb3duJzogWzI0NCwxNjQsOTYsMV0sXG4gICAgICAgICdzZWFncmVlbic6IFs0NiwxMzksODcsMV0sICdzZWFzaGVsbCc6IFsyNTUsMjQ1LDIzOCwxXSxcbiAgICAgICAgJ3NpZW5uYSc6IFsxNjAsODIsNDUsMV0sICdzaWx2ZXInOiBbMTkyLDE5MiwxOTIsMV0sXG4gICAgICAgICdza3libHVlJzogWzEzNSwyMDYsMjM1LDFdLCAnc2xhdGVibHVlJzogWzEwNiw5MCwyMDUsMV0sXG4gICAgICAgICdzbGF0ZWdyYXknOiBbMTEyLDEyOCwxNDQsMV0sICdzbGF0ZWdyZXknOiBbMTEyLDEyOCwxNDQsMV0sXG4gICAgICAgICdzbm93JzogWzI1NSwyNTAsMjUwLDFdLCAnc3ByaW5nZ3JlZW4nOiBbMCwyNTUsMTI3LDFdLFxuICAgICAgICAnc3RlZWxibHVlJzogWzcwLDEzMCwxODAsMV0sICd0YW4nOiBbMjEwLDE4MCwxNDAsMV0sXG4gICAgICAgICd0ZWFsJzogWzAsMTI4LDEyOCwxXSwgJ3RoaXN0bGUnOiBbMjE2LDE5MSwyMTYsMV0sXG4gICAgICAgICd0b21hdG8nOiBbMjU1LDk5LDcxLDFdLCAndHVycXVvaXNlJzogWzY0LDIyNCwyMDgsMV0sXG4gICAgICAgICd2aW9sZXQnOiBbMjM4LDEzMCwyMzgsMV0sICd3aGVhdCc6IFsyNDUsMjIyLDE3OSwxXSxcbiAgICAgICAgJ3doaXRlJzogWzI1NSwyNTUsMjU1LDFdLCAnd2hpdGVzbW9rZSc6IFsyNDUsMjQ1LDI0NSwxXSxcbiAgICAgICAgJ3llbGxvdyc6IFsyNTUsMjU1LDAsMV0sICd5ZWxsb3dncmVlbic6IFsxNTQsMjA1LDUwLDFdXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNsYW1wQ3NzQnl0ZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMjU1LlxuICAgICAgICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICAgICAgICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xhbXBDc3NBbmdsZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMzYwLlxuICAgICAgICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICAgICAgICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDM2MCA/IDM2MCA6IGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xhbXBDc3NGbG9hdChmKSB7ICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLlxuICAgICAgICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNzc0ludChzdHIpIHsgIC8vIGludCBvciBwZXJjZW50YWdlLlxuICAgICAgICBpZiAoc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhbXBDc3NCeXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsYW1wQ3NzQnl0ZShwYXJzZUludChzdHIsIDEwKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDc3NGbG9hdChzdHIpIHsgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIGlmIChzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFtcENzc0Zsb2F0KHBhcnNlRmxvYXQoc3RyKSAvIDEwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjc3NIdWVUb1JnYihtMSwgbTIsIGgpIHtcbiAgICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgICAgICBoICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaCA+IDEpIHtcbiAgICAgICAgICAgIGggLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoICogNiA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoICogMiA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBtMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaCAqIDMgPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMi8zIC0gaCkgKiA2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsZXJwKGEsIGIsIHApIHtcbiAgICAgICAgcmV0dXJuIGEgKyAoYiAtIGEpICogcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRSZ2JhKG91dCwgciwgZywgYiwgYSkge1xuICAgICAgICBvdXRbMF0gPSByOyBvdXRbMV0gPSBnOyBvdXRbMl0gPSBiOyBvdXRbM10gPSBhO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5UmdiYShvdXQsIGEpIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTsgb3V0WzFdID0gYVsxXTsgb3V0WzJdID0gYVsyXTsgb3V0WzNdID0gYVszXTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgdmFyIGNvbG9yQ2FjaGUgPSBuZXcgTFJVKDIwKTtcbiAgICB2YXIgbGFzdFJlbW92ZWRBcnIgPSBudWxsO1xuICAgIGZ1bmN0aW9uIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpIHtcbiAgICAgICAgLy8gUmV1c2UgcmVtb3ZlZCBhcnJheVxuICAgICAgICBpZiAobGFzdFJlbW92ZWRBcnIpIHtcbiAgICAgICAgICAgIGNvcHlSZ2JhKGxhc3RSZW1vdmVkQXJyLCByZ2JhQXJyKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UmVtb3ZlZEFyciA9IGNvbG9yQ2FjaGUucHV0KGNvbG9yU3RyLCBsYXN0UmVtb3ZlZEFyciB8fCAocmdiYUFyci5zbGljZSgpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclN0clxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2UoY29sb3JTdHIsIHJnYmFBcnIpIHtcbiAgICAgICAgaWYgKCFjb2xvclN0cikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJnYmFBcnIgPSByZ2JhQXJyIHx8IFtdO1xuXG4gICAgICAgIHZhciBjYWNoZWQgPSBjb2xvckNhY2hlLmdldChjb2xvclN0cik7XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3B5UmdiYShyZ2JhQXJyLCBjYWNoZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29sb3JTdHIgbWF5IGJlIG5vdCBzdHJpbmdcbiAgICAgICAgY29sb3JTdHIgPSBjb2xvclN0ciArICcnO1xuICAgICAgICAvLyBSZW1vdmUgYWxsIHdoaXRlc3BhY2UsIG5vdCBjb21wbGlhbnQsIGJ1dCBzaG91bGQganVzdCBiZSBtb3JlIGFjY2VwdGluZy5cbiAgICAgICAgdmFyIHN0ciA9IGNvbG9yU3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLlxuICAgICAgICBpZiAoc3RyIGluIGtDU1NDb2xvclRhYmxlKSB7XG4gICAgICAgICAgICBjb3B5UmdiYShyZ2JhQXJyLCBrQ1NTQ29sb3JUYWJsZVtzdHJdKTtcbiAgICAgICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAjYWJjIGFuZCAjYWJjMTIzIHN5bnRheC5cbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgICAgICAgICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsXG4gICAgICAgICAgICAgICAgICAgICgoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLFxuICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSxcbiAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmKSB8ICgoaXYgJiAweGYpIDw8IDQpLFxuICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmdiYUFycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgICAgICAgICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmZmZmKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsXG4gICAgICAgICAgICAgICAgICAgIChpdiAmIDB4ZmYwMDAwKSA+PiAxNixcbiAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmZjAwKSA+PiA4LFxuICAgICAgICAgICAgICAgICAgICBpdiAmIDB4ZmYsXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKSwgZXAgPSBzdHIuaW5kZXhPZignKScpO1xuICAgICAgICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gc3RyLnN1YnN0cihvcCArIDEsIGVwIC0gKG9wICsgMSkpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSAxOyAgLy8gVG8gYWxsb3cgY2FzZSBmYWxsdGhyb3VnaC5cbiAgICAgICAgICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBwYXJzZUNzc0Zsb2F0KHBhcmFtcy5wb3AoKSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgICAgICAgICAgICBjYXNlICdyZ2InOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUNzc0ludChwYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VDc3NJbnQocGFyYW1zWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQ3NzSW50KHBhcmFtc1syXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgICAgICAgICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1szXSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgaHNsYTJyZ2JhKHBhcmFtcywgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmdiYUFycjtcbiAgICAgICAgICAgICAgICBjYXNlICdoc2wnOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoc2xhMnJnYmEocGFyYW1zLCByZ2JhQXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gICAgICovXG4gICAgZnVuY3Rpb24gaHNsYTJyZ2JhKGhzbGEsIHJnYmEpIHtcbiAgICAgICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KGhzbGFbMF0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwOyAgLy8gMCAuLiAxXG4gICAgICAgIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAgICAgICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIHZhciBzID0gcGFyc2VDc3NGbG9hdChoc2xhWzFdKTtcbiAgICAgICAgdmFyIGwgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMl0pO1xuICAgICAgICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcblxuICAgICAgICByZ2JhID0gcmdiYSB8fCBbXTtcbiAgICAgICAgc2V0UmdiYShyZ2JhLFxuICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCArIDEgLyAzKSAqIDI1NSksXG4gICAgICAgICAgICBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoKSAqIDI1NSksXG4gICAgICAgICAgICBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoIC0gMSAvIDMpICogMjU1KSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaHNsYS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIHJnYmFbM10gPSBoc2xhWzNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJnYmE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmdiYTJoc2xhKHJnYmEpIHtcbiAgICAgICAgaWYgKCFyZ2JhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSR0IgZnJvbSAwIHRvIDI1NVxuICAgICAgICB2YXIgUiA9IHJnYmFbMF0gLyAyNTU7XG4gICAgICAgIHZhciBHID0gcmdiYVsxXSAvIDI1NTtcbiAgICAgICAgdmFyIEIgPSByZ2JhWzJdIC8gMjU1O1xuXG4gICAgICAgIHZhciB2TWluID0gTWF0aC5taW4oUiwgRywgQik7IC8vIE1pbi4gdmFsdWUgb2YgUkdCXG4gICAgICAgIHZhciB2TWF4ID0gTWF0aC5tYXgoUiwgRywgQik7IC8vIE1heC4gdmFsdWUgb2YgUkdCXG4gICAgICAgIHZhciBkZWx0YSA9IHZNYXggLSB2TWluOyAvLyBEZWx0YSBSR0IgdmFsdWVcblxuICAgICAgICB2YXIgTCA9ICh2TWF4ICsgdk1pbikgLyAyO1xuICAgICAgICB2YXIgSDtcbiAgICAgICAgdmFyIFM7XG4gICAgICAgIC8vIEhTTCByZXN1bHRzIGZyb20gMCB0byAxXG4gICAgICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgICAgICAgSCA9IDA7XG4gICAgICAgICAgICBTID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChMIDwgMC41KSB7XG4gICAgICAgICAgICAgICAgUyA9IGRlbHRhIC8gKHZNYXggKyB2TWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIFMgPSBkZWx0YSAvICgyIC0gdk1heCAtIHZNaW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGVsdGFSID0gKCgodk1heCAtIFIpIC8gNikgKyAoZGVsdGEgLyAyKSkgLyBkZWx0YTtcbiAgICAgICAgICAgIHZhciBkZWx0YUcgPSAoKCh2TWF4IC0gRykgLyA2KSArIChkZWx0YSAvIDIpKSAvIGRlbHRhO1xuICAgICAgICAgICAgdmFyIGRlbHRhQiA9ICgoKHZNYXggLSBCKSAvIDYpICsgKGRlbHRhIC8gMikpIC8gZGVsdGE7XG5cbiAgICAgICAgICAgIGlmIChSID09PSB2TWF4KSB7XG4gICAgICAgICAgICAgICAgSCA9IGRlbHRhQiAtIGRlbHRhRztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEcgPT09IHZNYXgpIHtcbiAgICAgICAgICAgICAgICBIID0gKDEgLyAzKSArIGRlbHRhUiAtIGRlbHRhQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEIgPT09IHZNYXgpIHtcbiAgICAgICAgICAgICAgICBIID0gKDIgLyAzKSArIGRlbHRhRyAtIGRlbHRhUjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEggPCAwKSB7XG4gICAgICAgICAgICAgICAgSCArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoSCA+IDEpIHtcbiAgICAgICAgICAgICAgICBIIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHNsYSA9IFtIICogMzYwLCBTLCBMXTtcblxuICAgICAgICBpZiAocmdiYVszXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBoc2xhLnB1c2gocmdiYVszXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHNsYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaWZ0KGNvbG9yLCBsZXZlbCkge1xuICAgICAgICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG4gICAgICAgIGlmIChjb2xvckFycikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yQXJyW2ldID0gY29sb3JBcnJbaV0gKiAoMSAtIGxldmVsKSB8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2xvckFycltpXSA9ICgoMjU1IC0gY29sb3JBcnJbaV0pICogbGV2ZWwgKyBjb2xvckFycltpXSkgfCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoY29sb3JBcnIsIGNvbG9yQXJyLmxlbmd0aCA9PT0gNCA/ICdyZ2JhJyA6ICdyZ2InKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSGV4KGNvbG9yLCBsZXZlbCkge1xuICAgICAgICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG4gICAgICAgIGlmIChjb2xvckFycikge1xuICAgICAgICAgICAgcmV0dXJuICgoMSA8PCAyNCkgKyAoY29sb3JBcnJbMF0gPDwgMTYpICsgKGNvbG9yQXJyWzFdIDw8IDgpICsgKCtjb2xvckFyclsyXSkpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcCB2YWx1ZSB0byBjb2xvci4gRmFzdGVyIHRoYW4gbWFwVG9Db2xvciBtZXRob2RzIGJlY2F1c2UgY29sb3IgaXMgcmVwcmVzZW50ZWQgYnkgcmdiYSBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBub3JtYWxpemVkVmFsdWUgQSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBjb2xvcnMgTGlzdCBvZiByZ2JhIGNvbG9yIGFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW291dF0gTWFwcGVkIGdiYSBjb2xvciBhcnJheVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZhc3RNYXBUb0NvbG9yKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBvdXQpIHtcbiAgICAgICAgb3V0ID0gb3V0IHx8IFswLCAwLCAwLCAwXTtcbiAgICAgICAgaWYgKCEoY29sb3JzICYmIGNvbG9ycy5sZW5ndGgpXG4gICAgICAgICAgICB8fCAhKG5vcm1hbGl6ZWRWYWx1ZSA+PSAwICYmIG5vcm1hbGl6ZWRWYWx1ZSA8PSAxKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gbm9ybWFsaXplZFZhbHVlICogKGNvbG9ycy5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIGxlZnRJbmRleCA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgICB2YXIgcmlnaHRJbmRleCA9IE1hdGguY2VpbCh2YWx1ZSk7XG4gICAgICAgIHZhciBsZWZ0Q29sb3IgPSBjb2xvcnNbbGVmdEluZGV4XTtcbiAgICAgICAgdmFyIHJpZ2h0Q29sb3IgPSBjb2xvcnNbcmlnaHRJbmRleF07XG4gICAgICAgIHZhciBkdiA9IHZhbHVlIC0gbGVmdEluZGV4O1xuICAgICAgICBvdXRbMF0gPSBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMF0sIHJpZ2h0Q29sb3JbMF0sIGR2KSk7XG4gICAgICAgIG91dFsxXSA9IGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKTtcbiAgICAgICAgb3V0WzJdID0gY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzJdLCByaWdodENvbG9yWzJdLCBkdikpO1xuICAgICAgICBvdXRbM10gPSBjbGFtcENzc0Zsb2F0KGxlcnAobGVmdENvbG9yWzNdLCByaWdodENvbG9yWzNdLCBkdikpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9ycyBDb2xvciBsaXN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZ1bGxPdXRwdXQgRGVmYXVsdCBmYWxzZS5cbiAgICAgKiBAcmV0dXJuIHsoc3RyaW5nfE9iamVjdCl9IFJlc3VsdCBjb2xvci4gSWYgZnVsbE91dHB1dCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29sb3I6IC4uLiwgbGVmdEluZGV4OiAuLi4sIHJpZ2h0SW5kZXg6IC4uLiwgdmFsdWU6IC4uLn0sXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBUb0NvbG9yKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBmdWxsT3V0cHV0KSB7XG4gICAgICAgIGlmICghKGNvbG9ycyAmJiBjb2xvcnMubGVuZ3RoKVxuICAgICAgICAgICAgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgICAgIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgICAgICAgdmFyIGxlZnRDb2xvciA9IHBhcnNlKGNvbG9yc1tsZWZ0SW5kZXhdKTtcbiAgICAgICAgdmFyIHJpZ2h0Q29sb3IgPSBwYXJzZShjb2xvcnNbcmlnaHRJbmRleF0pO1xuICAgICAgICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcblxuICAgICAgICB2YXIgY29sb3IgPSBzdHJpbmdpZnkoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpLFxuICAgICAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKSxcbiAgICAgICAgICAgICAgICBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMl0sIHJpZ2h0Q29sb3JbMl0sIGR2KSksXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NGbG9hdChsZXJwKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdyZ2JhJ1xuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBmdWxsT3V0cHV0XG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgbGVmdEluZGV4OiBsZWZ0SW5kZXgsXG4gICAgICAgICAgICAgICAgcmlnaHRJbmRleDogcmlnaHRJbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogY29sb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBoIDAgfiAzNjAsIGlnbm9yZSB3aGVuIG51bGwuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBzIDAgfiAxLCBpZ25vcmUgd2hlbiBudWxsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbCAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vZGlmeUhTTChjb2xvciwgaCwgcywgbCkge1xuICAgICAgICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgIGNvbG9yID0gcmdiYTJoc2xhKGNvbG9yKTtcbiAgICAgICAgICAgIGggIT0gbnVsbCAmJiAoY29sb3JbMF0gPSBjbGFtcENzc0FuZ2xlKGgpKTtcbiAgICAgICAgICAgIHMgIT0gbnVsbCAmJiAoY29sb3JbMV0gPSBwYXJzZUNzc0Zsb2F0KHMpKTtcbiAgICAgICAgICAgIGwgIT0gbnVsbCAmJiAoY29sb3JbMl0gPSBwYXJzZUNzc0Zsb2F0KGwpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShoc2xhMnJnYmEoY29sb3IpLCAncmdiYScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBhbHBoYSAwIH4gMVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbW9kaWZ5QWxwaGEoY29sb3IsIGFscGhhKSB7XG4gICAgICAgIGNvbG9yID0gcGFyc2UoY29sb3IpO1xuXG4gICAgICAgIGlmIChjb2xvciAmJiBhbHBoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb2xvclszXSA9IGNsYW1wQ3NzRmxvYXQoYWxwaGEpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvciwgJ3JnYmEnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9ycyBDb2xvciBsaXN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICdyZ2JhJywgJ2hzdmEnLCAuLi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdCBjb2xvci4gKElmIGlucHV0IGlsbGVnYWwsIHJldHVybiB1bmRlZmluZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShhcnJDb2xvciwgdHlwZSkge1xuICAgICAgICBpZiAoIWFyckNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbG9yU3RyID0gYXJyQ29sb3JbMF0gKyAnLCcgKyBhcnJDb2xvclsxXSArICcsJyArIGFyckNvbG9yWzJdO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3JnYmEnIHx8IHR5cGUgPT09ICdoc3ZhJyB8fCB0eXBlID09PSAnaHNsYScpIHtcbiAgICAgICAgICAgIGNvbG9yU3RyICs9ICcsJyArIGFyckNvbG9yWzNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlICsgJygnICsgY29sb3JTdHIgKyAnKSc7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHBhcnNlOiBwYXJzZSxcbiAgICAgICAgbGlmdDogbGlmdCxcbiAgICAgICAgdG9IZXg6IHRvSGV4LFxuICAgICAgICBmYXN0TWFwVG9Db2xvcjogZmFzdE1hcFRvQ29sb3IsXG4gICAgICAgIG1hcFRvQ29sb3I6IG1hcFRvQ29sb3IsXG4gICAgICAgIG1vZGlmeUhTTDogbW9kaWZ5SFNMLFxuICAgICAgICBtb2RpZnlBbHBoYTogbW9kaWZ5QWxwaGEsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5XG4gICAgfTtcblxuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFNpbXBsZSBMUlUgY2FjaGUgdXNlIGRvdWJseSBsaW5rZWQgbGlzdFxuLy8gQG1vZHVsZSB6cmVuZGVyL2NvcmUvTFJVXG5cblxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBkb3VibGUgbGlua2VkIGxpc3QuIENvbXBhcmVkIHdpdGggYXJyYXksIGl0IGhhcyBPKDEpIHJlbW92ZSBvcGVyYXRpb24uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIExpbmtlZExpc3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICB9O1xuXG4gICAgdmFyIGxpbmtlZExpc3RQcm90byA9IExpbmtlZExpc3QucHJvdG90eXBlO1xuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5ldyB2YWx1ZSBhdCB0aGUgdGFpbFxuICAgICAqIEBwYXJhbSAge30gdmFsXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLmluc2VydCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gbmV3IEVudHJ5KHZhbCk7XG4gICAgICAgIHRoaXMuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluc2VydCBhbiBlbnRyeSBhdCB0aGUgdGFpbFxuICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fSBlbnRyeVxuICAgICAqL1xuICAgIGxpbmtlZExpc3RQcm90by5pbnNlcnRFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoIXRoaXMuaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gZW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O1xuICAgICAgICAgICAgZW50cnkucHJldiA9IHRoaXMudGFpbDtcbiAgICAgICAgICAgIGVudHJ5Lm5leHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGVuKys7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBlbnRyeS5cbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAgICAgKi9cbiAgICBsaW5rZWRMaXN0UHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHZhciBwcmV2ID0gZW50cnkucHJldjtcbiAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElzIGhlYWRcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIG5leHQucHJldiA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJcyB0YWlsXG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5Lm5leHQgPSBlbnRyeS5wcmV2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGVuLS07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaW5rZWRMaXN0UHJvdG8ubGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVuO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBsaXN0XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9sZW4gPSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge30gdmFsXG4gICAgICovXG4gICAgdmFyIEVudHJ5ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmV4dDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMUlUgQ2FjaGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9MUlVcbiAgICAgKi9cbiAgICB2YXIgTFJVID0gZnVuY3Rpb24gKG1heFNpemUpIHtcblxuICAgICAgICB0aGlzLl9saXN0ID0gbmV3IExpbmtlZExpc3QoKTtcblxuICAgICAgICB0aGlzLl9tYXAgPSB7fTtcblxuICAgICAgICB0aGlzLl9tYXhTaXplID0gbWF4U2l6ZSB8fCAxMDtcblxuICAgICAgICB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIExSVVByb3RvID0gTFJVLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtICB7fSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge30gUmVtb3ZlZCB2YWx1ZVxuICAgICAqL1xuICAgIExSVVByb3RvLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBudWxsO1xuICAgICAgICBpZiAobWFwW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuKCk7XG4gICAgICAgICAgICAvLyBSZXVzZSBsYXN0IHJlbW92ZWQgZW50cnlcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX2xhc3RSZW1vdmVkRW50cnk7XG5cbiAgICAgICAgICAgIGlmIChsZW4gPj0gdGhpcy5fbWF4U2l6ZSAmJiBsZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkXG4gICAgICAgICAgICAgICAgdmFyIGxlYXN0VXNlZEVudHJ5ID0gbGlzdC5oZWFkO1xuICAgICAgICAgICAgICAgIGxpc3QucmVtb3ZlKGxlYXN0VXNlZEVudHJ5KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFwW2xlYXN0VXNlZEVudHJ5LmtleV07XG5cbiAgICAgICAgICAgICAgICByZW1vdmVkID0gbGVhc3RVc2VkRW50cnkudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFJlbW92ZWRFbnRyeSA9IGxlYXN0VXNlZEVudHJ5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW50cnkgPSBuZXcgRW50cnkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW50cnkua2V5ID0ga2V5O1xuICAgICAgICAgICAgbGlzdC5pbnNlcnRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICBtYXBba2V5XSA9IGVudHJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gICAgICogQHJldHVybiB7fVxuICAgICAqL1xuICAgIExSVVByb3RvLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fbWFwW2tleV07XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgaWYgKGVudHJ5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFB1dCB0aGUgbGF0ZXN0IHVzZWQgZW50cnkgaW4gdGhlIHRhaWxcbiAgICAgICAgICAgIGlmIChlbnRyeSAhPT0gbGlzdC50YWlsKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5yZW1vdmUoZW50cnkpO1xuICAgICAgICAgICAgICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGNhY2hlXG4gICAgICovXG4gICAgTFJVUHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xpc3QuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbWFwID0ge307XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gTFJVO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS9MUlUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4gICAgICAgIHZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGV4cG9ydHMgenJlbmRlci90b29sL2xvZ1xuICAgICAgICAgKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAgICAgICAgICovXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmRlYnVnTW9kZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5kZWJ1Z01vZGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhcmd1bWVudHNba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5kZWJ1Z01vZGUgPiAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzW2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyogZm9yIGRlYnVnXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihtZXMpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3cm9uZy1tZXNzYWdlJykuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICAgICBtZXMgKyAnICcgKyAobmV3IERhdGUoKSAtIDApXG4gICAgICAgICAgICAgICAgKyAnPGJyLz4nXG4gICAgICAgICAgICAgICAgKyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd3JvbmctbWVzc2FnZScpLmlubmVySFRNTDtcbiAgICAgICAgfTtcbiAgICAgICAgKi9cbiAgICBcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvbG9nLmpzXG4gKiogbW9kdWxlIGlkID0gMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuICAgIHZhciBkcHIgPSAxO1xuICAgIC8vIElmIGluIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZHByID0gTWF0aC5tYXgod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNvbmZpZ+m7mOiupOmFjee9rumhuVxuICAgICAqIEBleHBvcnRzIHpyZW5kZXIvY29uZmlnXG4gICAgICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gICAgICovXG4gICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRlYnVn5pel5b+X6YCJ6aG577yaY2F0Y2hCcnVzaEV4Y2VwdGlvbuS4unRydWXkuIvmnInmlYhcbiAgICAgICAgICogMCA6IOS4jeeUn+aIkGRlYnVn5pWw5o2u77yM5Y+R5biD55SoXG4gICAgICAgICAqIDEgOiDlvILluLjmipvlh7rvvIzosIPor5XnlKhcbiAgICAgICAgICogMiA6IOaOp+WItuWPsOi+k+WHuu+8jOiwg+ivleeUqFxuICAgICAgICAgKi9cbiAgICAgICAgZGVidWdNb2RlOiAwLFxuXG4gICAgICAgIC8vIHJldGluYSDlsY/luZXkvJjljJZcbiAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogZHByXG4gICAgfTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbmZpZztcblxuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb25maWcuanNcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBNaXhpbiBmb3IgZHJhd2luZyB0ZXh0IGluIGEgZWxlbWVudCBib3VuZGluZyByZWN0XG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vUmVjdFRleHRcbiAqL1xuXG5cblxuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJy4uLy4uL2NvbnRhaW4vdGV4dCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuXG4gICAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KCk7XG5cbiAgICB2YXIgUmVjdFRleHQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlUGVyY2VudCh2YWx1ZSwgbWF4VmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sYXN0SW5kZXhPZignJScpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBtYXhWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgUmVjdFRleHQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBSZWN0VGV4dCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRHJhdyB0ZXh0IGluIGEgcmVjdCB3aXRoIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICAgICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dH0gY3R4XG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcmVjdCBEaXNwbGF5YWJsZSByZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGV4dFJlY3QgQWx0ZXJuYXRpdmUgcHJlY2FsY3VsYXRlZCB0ZXh0IGJvdW5kaW5nIHJlY3RcbiAgICAgICAgICovXG4gICAgICAgIGRyYXdSZWN0VGV4dDogZnVuY3Rpb24gKGN0eCwgcmVjdCwgdGV4dFJlY3QpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICAgICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcbiAgICAgICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgdmFyIHk7XG4gICAgICAgICAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHRleHRPZmZzZXQgPSBzdHlsZS50ZXh0T2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gc3R5bGUudGV4dERpc3RhbmNlO1xuICAgICAgICAgICAgdmFyIGFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgICAgICAgICAgdmFyIGZvbnQgPSBzdHlsZS50ZXh0Rm9udCB8fCBzdHlsZS5mb250O1xuICAgICAgICAgICAgdmFyIGJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbjtcblxuICAgICAgICAgICAgdGV4dFJlY3QgPSB0ZXh0UmVjdCB8fCB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgYWxpZ24sIGJhc2VsaW5lKTtcblxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHJlY3QgdG8gdmlldyBzcGFjZVxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgaWYgKCFzdHlsZS50ZXh0VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0bXBSZWN0LmNvcHkocmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHRtcFJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGV4dCBwb3NpdGlvbiByZXByZXNlbnRlZCBieSBjb29yZFxuICAgICAgICAgICAgaWYgKHRleHRQb3NpdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgLy8gUGVyY2VudFxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzBdLCByZWN0LndpZHRoKTtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblsxXSwgcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGFsaWduID0gYWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJhc2VsaW5lID0gYmFzZWxpbmUgfHwgJ3RvcCc7XG5cbiAgICAgICAgICAgICAgICBpZiAodmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSB0ZXh0UmVjdC5oZWlnaHQgLyAyIC0gdGV4dFJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gdGV4dFJlY3QuaGVpZ2h0IC0gdGV4dFJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gdGV4dFJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgYnNlbGluZSB0byBiZSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgYmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KFxuICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb24sIHJlY3QsIHRleHRSZWN0LCBkaXN0YW5jZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgeCA9IHJlcy54O1xuICAgICAgICAgICAgICAgIHkgPSByZXMueTtcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGFsaWduIGFuZCBiYXNlbGluZSB3aGVuIGhhcyB0ZXh0UG9zaXRpb25cbiAgICAgICAgICAgICAgICBhbGlnbiA9IGFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgYmFzZWxpbmUgPSBiYXNlbGluZSB8fCByZXMudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGV4dE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHggKz0gdGV4dE9mZnNldFswXTtcbiAgICAgICAgICAgICAgICB5ICs9IHRleHRPZmZzZXRbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgZGVmYXVsdCBsZWZ0IHRleHRBbGlnbi4gR2l2aW5nIGludmFsaWQgdmFsdWUgd2lsbCBjYXVzZSBzdGF0ZSBub3QgY2hhbmdlXG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gYWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyBkZWZhdWx0IGFscGhhYmV0aWMgYmFzZWxpbmVcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBiYXNlbGluZSB8fCAnYWxwaGFiZXRpYyc7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0RmlsbCA9IHN0eWxlLnRleHRGaWxsO1xuICAgICAgICAgICAgdmFyIHRleHRTdHJva2UgPSBzdHlsZS50ZXh0U3Ryb2tlO1xuICAgICAgICAgICAgdGV4dEZpbGwgJiYgKGN0eC5maWxsU3R5bGUgPSB0ZXh0RmlsbCk7XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlICYmIChjdHguc3Ryb2tlU3R5bGUgPSB0ZXh0U3Ryb2tlKTtcblxuICAgICAgICAgICAgLy8gVE9ETyBJbnZhbGlkIGZvbnRcbiAgICAgICAgICAgIGN0eC5mb250ID0gZm9udCB8fCAnMTJweCBzYW5zLXNlcmlmJztcblxuICAgICAgICAgICAgLy8gVGV4dCBzaGFkb3dcbiAgICAgICAgICAgIC8vIEFsd2F5cyBzZXQgc2hhZG93Qmx1ciBhbmQgc2hhZG93T2Zmc2V0IHRvIGF2b2lkIGxlYWsgZnJvbSBkaXNwbGF5YWJsZVxuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSBzdHlsZS50ZXh0U2hhZG93Qmx1cjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHN0eWxlLnRleHRTaGFkb3dDb2xvciB8fCAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WDtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gc3R5bGUudGV4dFNoYWRvd09mZnNldFk7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0TGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlLnRleHRSb3RhdGlvbikge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSAmJiBjdHgudHJhbnNsYXRlKHRyYW5zZm9ybVs0XSwgdHJhbnNmb3JtWzVdKTtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKHN0eWxlLnRleHRSb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtICYmIGN0eC50cmFuc2xhdGUoLXRyYW5zZm9ybVs0XSwgLXRyYW5zZm9ybVs1XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbGwgYWZ0ZXIgc3Ryb2tlIHNvIHRoZSBvdXRsaW5lIHdpbGwgbm90IGNvdmVyIHRoZSBtYWluIHBhcnQuXG4gICAgICAgICAgICAgICAgdGV4dFN0cm9rZSAmJiBjdHguc3Ryb2tlVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgIHRleHRGaWxsICYmIGN0eC5maWxsVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgIHkgKz0gdGV4dFJlY3QubGluZUhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJlY3RUZXh0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIHZhciB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICAgIHZhciB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPSAwO1xuICAgIHZhciBURVhUX0NBQ0hFX01BWCA9IDUwMDA7XG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciByZXRyaWV2ZSA9IHV0aWwucmV0cmlldmU7XG5cbiAgICBmdW5jdGlvbiBnZXRUZXh0V2lkdGgodGV4dCwgdGV4dEZvbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IHRleHQgKyAnOicgKyB0ZXh0Rm9udDtcbiAgICAgICAgaWYgKHRleHRXaWR0aENhY2hlW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0V2lkdGhDYWNoZVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRMaW5lcyA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1lYXN1cmVUZXh0IOWPr+S7peiiq+imhuebluS7peWFvOWuueS4jeaUr+aMgSBDYW52YXMg55qE546v5aKDXG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHRleHRDb250YWluLm1lYXN1cmVUZXh0KHRleHRMaW5lc1tpXSwgdGV4dEZvbnQpLndpZHRoLCB3aWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dFdpZHRoQ2FjaGVDb3VudGVyID4gVEVYVF9DQUNIRV9NQVgpIHtcbiAgICAgICAgICAgIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG4gICAgICAgICAgICB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRleHRXaWR0aENhY2hlQ291bnRlcisrO1xuICAgICAgICB0ZXh0V2lkdGhDYWNoZVtrZXldID0gd2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRleHRSZWN0KHRleHQsIHRleHRGb250LCB0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSkge1xuICAgICAgICB2YXIgdGV4dExpbmVMZW4gPSAoKHRleHQgfHwgJycpICsgJycpLnNwbGl0KCdcXG4nKS5sZW5ndGg7XG5cbiAgICAgICAgdmFyIHdpZHRoID0gZ2V0VGV4dFdpZHRoKHRleHQsIHRleHRGb250KTtcbiAgICAgICAgLy8gRklYTUUg6auY5bqm6K6h566X5q+U6L6D57KX5pq0XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gZ2V0VGV4dFdpZHRoKCflm70nLCB0ZXh0Rm9udCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0ZXh0TGluZUxlbiAqIGxpbmVIZWlnaHQ7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvLyBUZXh0IGhhcyBhIHNwZWNpYWwgbGluZSBoZWlnaHQgcHJvcGVydHlcbiAgICAgICAgcmVjdC5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcblxuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGNhc2UgJ2FscGhhYmV0aWMnOlxuICAgICAgICAgICAgICAgIHJlY3QueSAtPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICByZWN0LnkgLT0gbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdoYW5naW5nJzpcbiAgICAgICAgICAgIC8vIGNhc2UgJ3RvcCc6XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGSVhNRSBSaWdodCB0byBsZWZ0IGxhbmd1YWdlXG4gICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHJlY3QueCAtPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZWN0LnggLT0gcmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAvLyBjYXNlICdsZWZ0JzpcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIHRleHRSZWN0LCBkaXN0YW5jZSkge1xuXG4gICAgICAgIHZhciB4ID0gcmVjdC54O1xuICAgICAgICB2YXIgeSA9IHJlY3QueTtcblxuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG5cbiAgICAgICAgdmFyIHRleHRIZWlnaHQgPSB0ZXh0UmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyIC0gdGV4dEhlaWdodCAvIDI7XG5cbiAgICAgICAgdmFyIHRleHRBbGlnbiA9ICdsZWZ0JztcblxuICAgICAgICBzd2l0Y2ggKHRleHRQb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgeCAtPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IGRpc3RhbmNlICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSAtPSBkaXN0YW5jZSArIHRleHRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0ICsgZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGUnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZUxlZnQnOlxuICAgICAgICAgICAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVJpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVUb3AnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVCb3R0b20nOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gdGV4dEhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlVG9wTGVmdCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVRvcFJpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlQm90dG9tTGVmdCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCAtIHRleHRIZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZUJvdHRvbVJpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoZWlnaHQgLSB0ZXh0SGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3cgZWxsaXBzaXMgaWYgb3ZlcmZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRhaW5lcldpZHRoXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0Rm9udFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW2VsbGlwc2lzPScuLi4nXVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5tYXhJdGVyYXRpb25zPTNdXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5taW5DaGFyPTBdIElmIHRydW5jYXRlIHJlc3VsdCBhcmUgbGVzc1xuICAgICAqICAgICAgICAgICAgICAgICAgdGhlbiBtaW5DaGFyLCBlbGxpcHNpcyB3aWxsIG5vdCBzaG93LCB3aGljaCBpc1xuICAgICAqICAgICAgICAgICAgICAgICAgYmV0dGVyIGZvciB1c2VyIGhpbnQgaW4gc29tZSBjYXNlcy5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLnBsYWNlaG9sZGVyPScnXSBXaGVuIGFsbCB0cnVuY2F0ZWQsIHVzZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlVGV4dCh0ZXh0LCBjb250YWluZXJXaWR0aCwgdGV4dEZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGVsbGlwc2lzID0gcmV0cmlldmUoZWxsaXBzaXMsICcuLi4nKTtcbiAgICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSByZXRyaWV2ZShvcHRpb25zLm1heEl0ZXJhdGlvbnMsIDIpO1xuICAgICAgICB2YXIgbWluQ2hhciA9IHJldHJpZXZlKG9wdGlvbnMubWluQ2hhciwgMCk7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIE90aGVyIGxhbmd1YWdlcz9cbiAgICAgICAgdmFyIGNuQ2hhcldpZHRoID0gZ2V0VGV4dFdpZHRoKCflm70nLCB0ZXh0Rm9udCk7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIENvbnNpZGVyIHByb3BvcnRpb25hbCBmb250P1xuICAgICAgICB2YXIgYXNjQ2hhcldpZHRoID0gZ2V0VGV4dFdpZHRoKCdhJywgdGV4dEZvbnQpO1xuICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSByZXRyaWV2ZShvcHRpb25zLnBsYWNlaG9sZGVyLCAnJyk7XG5cbiAgICAgICAgLy8gRXhhbXBsZSAxOiBtaW5DaGFyOiAzLCB0ZXh0OiAnYXNkZnp4Y3YnLCB0cnVuY2F0ZSByZXN1bHQ6ICdhc2RmJywgYnV0IG5vdDogJ2EuLi4nLlxuICAgICAgICAvLyBFeGFtcGxlIDI6IG1pbkNoYXI6IDMsIHRleHQ6ICfnu7TluqYnLCB0cnVuY2F0ZSByZXN1bHQ6ICfnu7QnLCBidXQgbm90OiAnLi4uJy5cbiAgICAgICAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRhaW5lcldpZHRoID0gTWF0aC5tYXgoMCwgY29udGFpbmVyV2lkdGggLSAxKTsgLy8gUmVzZXJ2ZSBzb21lIGdhcC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5DaGFyICYmIGNvbnRlbnRXaWR0aCA+PSBhc2NDaGFyV2lkdGg7IGkrKykge1xuICAgICAgICAgICAgY29udGVudFdpZHRoIC09IGFzY0NoYXJXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGxpcHNpc1dpZHRoID0gZ2V0VGV4dFdpZHRoKGVsbGlwc2lzKTtcbiAgICAgICAgaWYgKGVsbGlwc2lzV2lkdGggPiBjb250ZW50V2lkdGgpIHtcbiAgICAgICAgICAgIGVsbGlwc2lzID0gJyc7XG4gICAgICAgICAgICBlbGxpcHNpc1dpZHRoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRlbnRXaWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gZWxsaXBzaXNXaWR0aDtcblxuICAgICAgICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZXh0TGluZSA9IHRleHRMaW5lc1tpXTtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBnZXRUZXh0V2lkdGgodGV4dExpbmUsIHRleHRGb250KTtcblxuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA8PSBjb250YWluZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDs7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPD0gY29udGVudFdpZHRoIHx8IGogPj0gbWF4SXRlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0TGluZSArPSBlbGxpcHNpcztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHN1Ykxlbmd0aCA9IGogPT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBlc3RpbWF0ZUxlbmd0aCh0ZXh0TGluZSwgY29udGVudFdpZHRoLCBhc2NDaGFyV2lkdGgsIGNuQ2hhcldpZHRoKVxuICAgICAgICAgICAgICAgICAgICA6IGxpbmVXaWR0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBNYXRoLmZsb29yKHRleHRMaW5lLmxlbmd0aCAqIGNvbnRlbnRXaWR0aCAvIGxpbmVXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xuXG4gICAgICAgICAgICAgICAgdGV4dExpbmUgPSB0ZXh0TGluZS5zdWJzdHIoMCwgc3ViTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSBnZXRUZXh0V2lkdGgodGV4dExpbmUsIHRleHRGb250KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRleHRMaW5lID09PSAnJykge1xuICAgICAgICAgICAgICAgIHRleHRMaW5lID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHRMaW5lc1tpXSA9IHRleHRMaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHRMaW5lcy5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc3RpbWF0ZUxlbmd0aCh0ZXh0LCBjb250ZW50V2lkdGgsIGFzY0NoYXJXaWR0aCwgY25DaGFyV2lkdGgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBmb3IgKHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDsgaSA8IGxlbiAmJiB3aWR0aCA8IGNvbnRlbnRXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB3aWR0aCArPSAoMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAxMjcpID8gYXNjQ2hhcldpZHRoIDogY25DaGFyV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgdmFyIHRleHRDb250YWluID0ge1xuXG4gICAgICAgIGdldFdpZHRoOiBnZXRUZXh0V2lkdGgsXG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBnZXRUZXh0UmVjdCxcblxuICAgICAgICBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3Q6IGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCxcblxuICAgICAgICB0cnVuY2F0ZVRleHQ6IHRydW5jYXRlVGV4dCxcblxuICAgICAgICBtZWFzdXJlVGV4dDogZnVuY3Rpb24gKHRleHQsIHRleHRGb250KSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdXRpbC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICBjdHguZm9udCA9IHRleHRGb250IHx8ICcxMnB4IHNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRleHRDb250YWluO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29udGFpbi90ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0XG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xuXG4gICAgdmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCb3VuZGluZ1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG4gICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgIHggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cblxuICAgIEJvdW5kaW5nUmVjdC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEJvdW5kaW5nUmVjdCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH0gb3RoZXJcbiAgICAgICAgICovXG4gICAgICAgIHVuaW9uOiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gbWF0aE1pbihvdGhlci54LCB0aGlzLngpO1xuICAgICAgICAgICAgdmFyIHkgPSBtYXRoTWluKG90aGVyLnksIHRoaXMueSk7XG5cbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBtYXRoTWF4KFxuICAgICAgICAgICAgICAgICAgICBvdGhlci54ICsgb3RoZXIud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCArIHRoaXMud2lkdGhcbiAgICAgICAgICAgICAgICApIC0geDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gbWF0aE1heChcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIueSArIG90aGVyLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ICsgdGhpcy5oZWlnaHRcbiAgICAgICAgICAgICAgICApIC0geTtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtXG4gICAgICAgICAqIEBtZXRob2RzXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseVRyYW5zZm9ybTogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsdCA9IFtdO1xuICAgICAgICAgICAgdmFyIHJiID0gW107XG4gICAgICAgICAgICB2YXIgbGIgPSBbXTtcbiAgICAgICAgICAgIHZhciBydCA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB1c2FnZSBsaWtlIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBlbC5nZXRCb3VuZGluZ1JlY3QoKS5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgLy8gQW5kIGVsZW1lbnQgaGFzIG5vIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGx0WzBdID0gbGJbMF0gPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgbHRbMV0gPSBydFsxXSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICByYlswXSA9IHJ0WzBdID0gdGhpcy54ICsgdGhpcy53aWR0aDtcbiAgICAgICAgICAgICAgICByYlsxXSA9IGxiWzFdID0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKGx0LCBsdCwgbSk7XG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShyYiwgcmIsIG0pO1xuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0obGIsIGxiLCBtKTtcbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHJ0LCBydCwgbSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnggPSBtYXRoTWluKGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSBtYXRoTWluKGx0WzFdLCByYlsxXSwgbGJbMV0sIHJ0WzFdKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4WCA9IG1hdGhNYXgobHRbMF0sIHJiWzBdLCBsYlswXSwgcnRbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBtYXhZID0gbWF0aE1heChsdFsxXSwgcmJbMV0sIGxiWzFdLCBydFsxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IG1heFggLSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBtYXhZIC0gdGhpcy55O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIG1hdHJpeCBvZiB0cmFuc2Zvcm1pbmcgZnJvbSBzZWxmIHRvIHRhcmdldCByZWN0XG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSBiXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgY2FsY3VsYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHN4ID0gYi53aWR0aCAvIGEud2lkdGg7XG4gICAgICAgICAgICB2YXIgc3kgPSBiLmhlaWdodCAvIGEuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgbSA9IG1hdHJpeC5jcmVhdGUoKTtcblxuICAgICAgICAgICAgLy8g55+p6Zi15Y+z5LmYXG4gICAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFstYS54LCAtYS55XSk7XG4gICAgICAgICAgICBtYXRyaXguc2NhbGUobSwgbSwgW3N4LCBzeV0pO1xuICAgICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbYi54LCBiLnldKTtcblxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7KG1vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fE9iamVjdCl9IGJcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGludGVyc2VjdDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoYiBpbnN0YW5jZW9mIEJvdW5kaW5nUmVjdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxpemUgbmVnYXRpdmUgd2lkdGgvaGVpZ2h0LlxuICAgICAgICAgICAgICAgIGIgPSBCb3VuZGluZ1JlY3QuY3JlYXRlKGIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXgwID0gYS54O1xuICAgICAgICAgICAgdmFyIGF4MSA9IGEueCArIGEud2lkdGg7XG4gICAgICAgICAgICB2YXIgYXkwID0gYS55O1xuICAgICAgICAgICAgdmFyIGF5MSA9IGEueSArIGEuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgYngwID0gYi54O1xuICAgICAgICAgICAgdmFyIGJ4MSA9IGIueCArIGIud2lkdGg7XG4gICAgICAgICAgICB2YXIgYnkwID0gYi55O1xuICAgICAgICAgICAgdmFyIGJ5MSA9IGIueSArIGIuaGVpZ2h0O1xuXG4gICAgICAgICAgICByZXR1cm4gISAoYXgxIDwgYngwIHx8IGJ4MSA8IGF4MCB8fCBheTEgPCBieTAgfHwgYnkxIDwgYXkwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHggPj0gcmVjdC54XG4gICAgICAgICAgICAgICAgJiYgeCA8PSAocmVjdC54ICsgcmVjdC53aWR0aClcbiAgICAgICAgICAgICAgICAmJiB5ID49IHJlY3QueVxuICAgICAgICAgICAgICAgICYmIHkgPD0gKHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29weSBmcm9tIGFub3RoZXIgcmVjdFxuICAgICAgICAgKi9cbiAgICAgICAgY29weTogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICB0aGlzLnggPSBvdGhlci54O1xuICAgICAgICAgICAgdGhpcy55ID0gb3RoZXIueTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBvdGhlci53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gb3RoZXIuaGVpZ2h0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBsYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxtb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gcmVjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LnhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVjdC55XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlY3Qud2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVjdC5oZWlnaHRcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgKi9cbiAgICBCb3VuZGluZ1JlY3QuY3JlYXRlID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCb3VuZGluZ1JlY3Q7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIFBhdGgg5Luj55CG77yM5Y+v5Lul5ZyoYGJ1aWxkUGF0aGDkuK3nlKjkuo7mm7/ku6NgY3R4YCwg5Lya5L+d5a2Y5q+P5LiqcGF0aOaTjeS9nOeahOWRveS7pOWIsHBhdGhDb21tYW5kc+WxnuaAp+S4rVxuICog5Y+v5Lul55So5LqOIGlzSW5zaWRlUGF0aCDliKTmlq3ku6Xlj4rojrflj5Zib3VuZGluZ1JlY3RcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAqIEBhdXRob3IgWWkgU2hlbiAoaHR0cDovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuIC8vIFRPRE8gZ2V0VG90YWxMZW5ndGgsIGdldFBvaW50QXRMZW5ndGhcblxuXG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpO1xuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcbiAgICB2YXIgYmJveCA9IHJlcXVpcmUoJy4vYmJveCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciBkcHIgPSByZXF1aXJlKCcuLi9jb25maWcnKS5kZXZpY2VQaXhlbFJhdGlvO1xuXG4gICAgdmFyIENNRCA9IHtcbiAgICAgICAgTTogMSxcbiAgICAgICAgTDogMixcbiAgICAgICAgQzogMyxcbiAgICAgICAgUTogNCxcbiAgICAgICAgQTogNSxcbiAgICAgICAgWjogNixcbiAgICAgICAgLy8gUmVjdFxuICAgICAgICBSOiA3XG4gICAgfTtcblxuICAgIHZhciBtaW4gPSBbXTtcbiAgICB2YXIgbWF4ID0gW107XG4gICAgdmFyIG1pbjIgPSBbXTtcbiAgICB2YXIgbWF4MiA9IFtdO1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICB2YXIgbWF0aENvcyA9IE1hdGguY29zO1xuICAgIHZhciBtYXRoU2luID0gTWF0aC5zaW47XG4gICAgdmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICB2YXIgaGFzVHlwZWRBcnJheSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgUGF0aFByb3h5ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXRoIGRhdGEuIFN0b3JlZCBhcyBmbGF0IGFycmF5XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2xlbiA9IDA7XG5cbiAgICAgICAgdGhpcy5fY3R4ID0gbnVsbDtcblxuICAgICAgICB0aGlzLl94aSA9IDA7XG4gICAgICAgIHRoaXMuX3lpID0gMDtcblxuICAgICAgICB0aGlzLl94MCA9IDA7XG4gICAgICAgIHRoaXMuX3kwID0gMDtcblxuICAgICAgICAvLyBVbml0IHgsIFVuaXQgeS4gUHJvdmlkZSBmb3IgYXZvaWRpbmcgZHJhd2luZyB0aGF0IHRvbyBzaG9ydCBsaW5lIHNlZ21lbnRcbiAgICAgICAgdGhpcy5fdXggPSAwO1xuICAgICAgICB0aGlzLl91eSA9IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOW/q+mAn+iuoeeul1BhdGjljIXlm7Tnm5LvvIjlubbkuI3mmK/mnIDlsI/ljIXlm7Tnm5LvvIlcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgUGF0aFByb3h5LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogUGF0aFByb3h5LFxuXG4gICAgICAgIF9saW5lRGFzaDogbnVsbCxcblxuICAgICAgICBfZGFzaE9mZnNldDogMCxcblxuICAgICAgICBfZGFzaElkeDogMCxcblxuICAgICAgICBfZGFzaFN1bTogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBzZXRTY2FsZTogZnVuY3Rpb24gKHN4LCBzeSkge1xuICAgICAgICAgICAgdGhpcy5fdXggPSBtYXRoQWJzKDEgLyBkcHIgLyBzeCkgfHwgMDtcbiAgICAgICAgICAgIHRoaXMuX3V5ID0gbWF0aEFicygxIC8gZHByIC8gc3kpIHx8IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N0eDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBiZWdpblBhdGg6IGZ1bmN0aW9uIChjdHgpIHtcblxuICAgICAgICAgICAgdGhpcy5fY3R4ID0gY3R4O1xuXG4gICAgICAgICAgICBjdHggJiYgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICBjdHggJiYgKHRoaXMuZHByID0gY3R4LmRwcik7XG5cbiAgICAgICAgICAgIC8vIFJlc2V0XG4gICAgICAgICAgICB0aGlzLl9sZW4gPSAwO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lRGFzaCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELk0sIHgsIHkpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5tb3ZlVG8oeCwgeSk7XG5cbiAgICAgICAgICAgIC8vIHgwLCB5MCwgeGksIHlpIOaYr+iusOW9leWcqCBfZGFzaGVkWFhYWFRvIOaWueazleS4reS9v+eUqFxuICAgICAgICAgICAgLy8geGksIHlpIOiusOW9leW9k+WJjeeCuSwgeDAsIHkwIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5Zue5Yiw6LW35aeL54K544CCXG4gICAgICAgICAgICAvLyDmnInlj6/og73lnKggYmVnaW5QYXRoIOS5i+WQjuebtOaOpeiwg+eUqCBsaW5lVG/vvIzov5nml7blgJkgeDAsIHkwIOmcgOimgVxuICAgICAgICAgICAgLy8g5ZyoIGxpbmVUbyDmlrnms5XkuK3orrDlvZXvvIzov5nph4zlhYjkuI3ogIPomZHov5nnp43mg4XlhrXvvIxkYXNoZWQgbGluZSDkuZ/lj6rlnKggSUUxMC0g5Lit5LiN5pSv5oyBXG4gICAgICAgICAgICB0aGlzLl94MCA9IHg7XG4gICAgICAgICAgICB0aGlzLl95MCA9IHk7XG5cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDtcbiAgICAgICAgICAgIHRoaXMuX3lpID0geTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBsaW5lVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgZXhjZWVkVW5pdCA9IG1hdGhBYnMoeCAtIHRoaXMuX3hpKSA+IHRoaXMuX3V4XG4gICAgICAgICAgICAgICAgfHwgbWF0aEFicyh5IC0gdGhpcy5feWkpID4gdGhpcy5fdXlcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBkcmF3IHRoZSBmaXJzdCBzZWdtZW50XG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fbGVuIDwgNTtcblxuICAgICAgICAgICAgdGhpcy5hZGREYXRhKENNRC5MLCB4LCB5KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCAmJiBleGNlZWRVbml0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNEYXNoKCkgPyB0aGlzLl9kYXNoZWRMaW5lVG8oeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9jdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4Y2VlZFVuaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl94aSA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy5feWkgPSB5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgzXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTNcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKENNRC5DLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZEJlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fY3R4LmJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl94aSA9IHgzO1xuICAgICAgICAgICAgdGhpcy5feWkgPSB5MztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELlEsIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZFF1YWRyYXRpY1RvKHgxLCB5MSwgeDIsIHkyKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2N0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDI7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHkyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gY3hcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjeVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBzdGFydEFuZ2xlXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gZW5kQW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gYW50aWNsb2Nrd2lzZVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGFyYzogZnVuY3Rpb24gKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShcbiAgICAgICAgICAgICAgICBDTUQuQSwgY3gsIGN5LCByLCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUsIDAsIGFudGljbG9ja3dpc2UgPyAwIDogMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHguYXJjKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpO1xuXG4gICAgICAgICAgICB0aGlzLl94aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogciArIGN4O1xuICAgICAgICAgICAgdGhpcy5feWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHIgKyBjeDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgYXJjVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3R4LmFyY1RvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgICAgICAgICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKENNRC5SLCB4LCB5LCB3LCBoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGNsb3NlUGF0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKENNRC5aKTtcblxuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICAgIHZhciB4MCA9IHRoaXMuX3gwO1xuICAgICAgICAgICAgdmFyIHkwID0gdGhpcy5feTA7XG4gICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNEYXNoKCkgJiYgdGhpcy5fZGFzaGVkTGluZVRvKHgwLCB5MCk7XG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl94aSA9IHgwO1xuICAgICAgICAgICAgdGhpcy5feWkgPSB5MDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250ZXh0IOS7juWklumDqOS8oOWFpe+8jOWboOS4uuacieWPr+iDveaYryByZWJ1aWxkUGF0aCDlrozkuYvlkI7lho0gZmlsbOOAglxuICAgICAgICAgKiBzdHJva2Ug5ZCM5qC3XG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBmaWxsOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBjdHggJiYgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIHRoaXMudG9TdGF0aWMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIHN0cm9rZTogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgY3R4ICYmIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIHRoaXMudG9TdGF0aWMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5b+F6aG75Zyo5YW25a6D57uY5Yi25ZG95Luk5YmN6LCD55SoXG4gICAgICAgICAqIE11c3QgYmUgaW52b2tlZCBiZWZvcmUgYWxsIG90aGVyIHBhdGggZHJhd2luZyBtZXRob2RzXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0TGluZURhc2g6IGZ1bmN0aW9uIChsaW5lRGFzaCkge1xuICAgICAgICAgICAgaWYgKGxpbmVEYXNoIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lRGFzaCA9IGxpbmVEYXNoO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGFzaElkeCA9IDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGluZURhc2hTdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZURhc2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZURhc2hTdW0gKz0gbGluZURhc2hbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Rhc2hTdW0gPSBsaW5lRGFzaFN1bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICAgICAgICogTXVzdCBiZSBpbnZva2VkIGJlZm9yZSBhbGwgb3RoZXIgcGF0aCBkcmF3aW5nIG1ldGhvZHNcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBzZXRMaW5lRGFzaE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgbGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnm7TmjqXorr7nva4gUGF0aCDmlbDmja5cbiAgICAgICAgICovXG4gICAgICAgIHNldERhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICAgICAgICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKCEgKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEubGVuZ3RoID09IGxlbikgJiYgaGFzVHlwZWRBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IGRhdGFbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2xlbiA9IGxlbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5a2Q6Lev5b6EXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl8QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5Pn0gcGF0aFxuICAgICAgICAgKi9cbiAgICAgICAgYXBwZW5kUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gW3BhdGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGFwcGVuZFNpemUgPSAwO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2xlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRTaXplICs9IHBhdGhbaV0ubGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzVHlwZWRBcnJheSAmJiAodGhpcy5kYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkob2Zmc2V0ICsgYXBwZW5kU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFwcGVuZFBhdGhEYXRhID0gcGF0aFtpXS5kYXRhO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYXBwZW5kUGF0aERhdGEubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhW29mZnNldCsrXSA9IGFwcGVuZFBhdGhEYXRhW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xlbiA9IG9mZnNldDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5aGr5YWFIFBhdGgg5pWw5o2u44CCXG4gICAgICAgICAqIOWwvemHj+WkjeeUqOiAjOS4jeeUs+aYjuaWsOeahOaVsOe7hOOAguWkp+mDqOWIhuWbvuW9oumHjee7mOeahOaMh+S7pOaVsOaNrumVv+W6pumDveaYr+S4jeWPmOeahOOAglxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRGF0YTogZnVuY3Rpb24gKGNtZCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGVuICsgYXJndW1lbnRzLmxlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8g5Zug5Li65LmL5YmN55qE5pWw57uE5bey57uP6L2s5o2i5oiQ6Z2Z5oCB55qEIEZsb2F0MzJBcnJheVxuICAgICAgICAgICAgICAgIC8vIOaJgOS7peS4jeWkn+eUqOaXtumcgOimgeaJqeWxleS4gOS4quaWsOeahOWKqOaAgeaVsOe7hFxuICAgICAgICAgICAgICAgIHRoaXMuX2V4cGFuZERhdGEoKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkYXRhW3RoaXMuX2xlbisrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fcHJldkNtZCA9IGNtZDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZXhwYW5kRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gT25seSBpZiBkYXRhIGlzIEZsb2F0MzJBcnJheVxuICAgICAgICAgICAgaWYgKCEodGhpcy5kYXRhIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0RhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG5lZWRzIGpzIGltcGxlbWVudGVkIGRhc2hlZCBsaW5lXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfbmVlZHNEYXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGluZURhc2g7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2Rhc2hlZExpbmVUbzogZnVuY3Rpb24gKHgxLCB5MSkge1xuICAgICAgICAgICAgdmFyIGRhc2hTdW0gPSB0aGlzLl9kYXNoU3VtO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2Rhc2hPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cbiAgICAgICAgICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgICAgICAgICAgdmFyIHkwID0gdGhpcy5feWk7XG4gICAgICAgICAgICB2YXIgZHggPSB4MSAtIHgwO1xuICAgICAgICAgICAgdmFyIGR5ID0geTEgLSB5MDtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgdmFyIHggPSB4MDtcbiAgICAgICAgICAgIHZhciB5ID0geTA7XG4gICAgICAgICAgICB2YXIgZGFzaDtcbiAgICAgICAgICAgIHZhciBuRGFzaCA9IGxpbmVEYXNoLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpZHg7XG4gICAgICAgICAgICBkeCAvPSBkaXN0O1xuICAgICAgICAgICAgZHkgLz0gZGlzdDtcblxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHBvc2l0aXZlIG9mZnNldFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGRhc2hTdW0gKyBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgJT0gZGFzaFN1bTtcbiAgICAgICAgICAgIHggLT0gb2Zmc2V0ICogZHg7XG4gICAgICAgICAgICB5IC09IG9mZnNldCAqIGR5O1xuXG4gICAgICAgICAgICB3aGlsZSAoKGR4ID4gMCAmJiB4IDw9IHgxKSB8fCAoZHggPCAwICYmIHggPj0geDEpXG4gICAgICAgICAgICB8fCAoZHggPT0gMCAmJiAoKGR5ID4gMCAmJiB5IDw9IHkxKSB8fCAoZHkgPCAwICYmIHkgPj0geTEpKSkpIHtcbiAgICAgICAgICAgICAgICBpZHggPSB0aGlzLl9kYXNoSWR4O1xuICAgICAgICAgICAgICAgIGRhc2ggPSBsaW5lRGFzaFtpZHhdO1xuICAgICAgICAgICAgICAgIHggKz0gZHggKiBkYXNoO1xuICAgICAgICAgICAgICAgIHkgKz0gZHkgKiBkYXNoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rhc2hJZHggPSAoaWR4ICsgMSkgJSBuRGFzaDtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHBvc2l0aXZlIG9mZnNldFxuICAgICAgICAgICAgICAgIGlmICgoZHggPiAwICYmIHggPCB4MCkgfHwgKGR4IDwgMCAmJiB4ID4geDApIHx8IChkeSA+IDAgJiYgeSA8IHkwKSB8fCAoZHkgPCAwICYmIHkgPiB5MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eFtpZHggJSAyID8gJ21vdmVUbycgOiAnbGluZVRvJ10oXG4gICAgICAgICAgICAgICAgICAgIGR4ID49IDAgPyBtYXRoTWluKHgsIHgxKSA6IG1hdGhNYXgoeCwgeDEpLFxuICAgICAgICAgICAgICAgICAgICBkeSA+PSAwID8gbWF0aE1pbih5LCB5MSkgOiBtYXRoTWF4KHksIHkxKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPZmZzZXQgZm9yIG5leHQgbGluZVRvXG4gICAgICAgICAgICBkeCA9IHggLSB4MTtcbiAgICAgICAgICAgIGR5ID0geSAtIHkxO1xuICAgICAgICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IC1tYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gTm90IGFjY3VyYXRlIGRhc2hlZCBsaW5lIHRvXG4gICAgICAgIF9kYXNoZWRCZXppZXJUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgICAgICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9kYXNoT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gdGhpcy5fbGluZURhc2g7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXG4gICAgICAgICAgICB2YXIgeDAgPSB0aGlzLl94aTtcbiAgICAgICAgICAgIHZhciB5MCA9IHRoaXMuX3lpO1xuICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICB2YXIgZHg7XG4gICAgICAgICAgICB2YXIgZHk7XG4gICAgICAgICAgICB2YXIgY3ViaWNBdCA9IGN1cnZlLmN1YmljQXQ7XG4gICAgICAgICAgICB2YXIgYmV6aWVyTGVuID0gMDtcbiAgICAgICAgICAgIHZhciBpZHggPSB0aGlzLl9kYXNoSWR4O1xuICAgICAgICAgICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuXG4gICAgICAgICAgICB2YXIgeDtcbiAgICAgICAgICAgIHZhciB5O1xuXG4gICAgICAgICAgICB2YXIgdG1wTGVuID0gMDtcblxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHBvc2l0aXZlIG9mZnNldFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGRhc2hTdW0gKyBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgJT0gZGFzaFN1bTtcbiAgICAgICAgICAgIC8vIEJlemllciBhcHByb3ggbGVuZ3RoXG4gICAgICAgICAgICBmb3IgKHQgPSAwOyB0IDwgMTsgdCArPSAwLjEpIHtcbiAgICAgICAgICAgICAgICBkeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQgKyAwLjEpXG4gICAgICAgICAgICAgICAgICAgIC0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICAgICAgZHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0ICsgMC4xKVxuICAgICAgICAgICAgICAgICAgICAtIGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuICAgICAgICAgICAgICAgIGJlemllckxlbiArPSBtYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbmQgaWR4IGFmdGVyIGFkZCBvZmZzZXRcbiAgICAgICAgICAgIGZvciAoOyBpZHggPCBuRGFzaDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICB0bXBMZW4gKz0gbGluZURhc2hbaWR4XTtcbiAgICAgICAgICAgICAgICBpZiAodG1wTGVuID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPSAodG1wTGVuIC0gb2Zmc2V0KSAvIGJlemllckxlbjtcblxuICAgICAgICAgICAgd2hpbGUgKHQgPD0gMSkge1xuXG4gICAgICAgICAgICAgICAgeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgICAgICAgICAgIHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcblxuICAgICAgICAgICAgICAgIC8vIFVzZSBsaW5lIHRvIGFwcHJveGltYXRlIGRhc2hlZCBiZXppZXJcbiAgICAgICAgICAgICAgICAvLyBCYWQgcmVzdWx0IGlmIGRhc2ggaXMgbG9uZ1xuICAgICAgICAgICAgICAgIGlkeCAlIDIgPyBjdHgubW92ZVRvKHgsIHkpXG4gICAgICAgICAgICAgICAgICAgIDogY3R4LmxpbmVUbyh4LCB5KTtcblxuICAgICAgICAgICAgICAgIHQgKz0gbGluZURhc2hbaWR4XSAvIGJlemllckxlbjtcblxuICAgICAgICAgICAgICAgIGlkeCA9IChpZHggKyAxKSAlIG5EYXNoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5pc2ggdGhlIGxhc3Qgc2VnbWVudCBhbmQgY2FsY3VsYXRlIHRoZSBuZXcgb2Zmc2V0XG4gICAgICAgICAgICAoaWR4ICUgMiAhPT0gMCkgJiYgY3R4LmxpbmVUbyh4MywgeTMpO1xuICAgICAgICAgICAgZHggPSB4MyAtIHg7XG4gICAgICAgICAgICBkeSA9IHkzIC0geTtcbiAgICAgICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAtbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kYXNoZWRRdWFkcmF0aWNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHF1YWRyYXRpYyB0byBjdWJpYyB1c2luZyBkZWdyZWUgZWxldmF0aW9uXG4gICAgICAgICAgICB2YXIgeDMgPSB4MjtcbiAgICAgICAgICAgIHZhciB5MyA9IHkyO1xuICAgICAgICAgICAgeDIgPSAoeDIgKyAyICogeDEpIC8gMztcbiAgICAgICAgICAgIHkyID0gKHkyICsgMiAqIHkxKSAvIDM7XG4gICAgICAgICAgICB4MSA9ICh0aGlzLl94aSArIDIgKiB4MSkgLyAzO1xuICAgICAgICAgICAgeTEgPSAodGhpcy5feWkgKyAyICogeTEpIC8gMztcblxuICAgICAgICAgICAgdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi9rOaIkOmdmeaAgeeahCBGbG9hdDMyQXJyYXkg5YeP5bCR5aCG5YaF5a2Y5Y2g55SoXG4gICAgICAgICAqIENvbnZlcnQgZHluYW1pYyBhcnJheSB0byBzdGF0aWMgRmxvYXQzMkFycmF5XG4gICAgICAgICAqL1xuICAgICAgICB0b1N0YXRpYzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZGF0YS5sZW5ndGggPSB0aGlzLl9sZW47XG4gICAgICAgICAgICAgICAgaWYgKGhhc1R5cGVkQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtaW5bMF0gPSBtaW5bMV0gPSBtaW4yWzBdID0gbWluMlsxXSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICBtYXhbMF0gPSBtYXhbMV0gPSBtYXgyWzBdID0gbWF4MlsxXSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIHZhciB4aSA9IDA7XG4gICAgICAgICAgICB2YXIgeWkgPSAwO1xuICAgICAgICAgICAgdmFyIHgwID0gMDtcbiAgICAgICAgICAgIHZhciB5MCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNtZCA9IGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgICAgICAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSB5aTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZVRvIOWRveS7pOmHjeaWsOWIm+W7uuS4gOS4quaWsOeahCBzdWJwYXRoLCDlubbkuJTmm7TmlrDmlrDnmoTotbfngrlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5L2/55SoXG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4yWzBdID0geDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4yWzFdID0geTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXgyWzBdID0geDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXgyWzFdID0geTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbUxpbmUoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21DdWJpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluMiwgbWF4MlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbVF1YWRyYXRpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4yLCBtYXgyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5BOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5Yik5pat55qE5byA6ZSA5q+U6L6D5aSnXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3kgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IGRhdGFbaSsrXSArIHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEFyYyDml4vovaxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwc2kgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW50aWNsb2Nrd2lzZSA9IDEgLSBkYXRhW2krK107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDnm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOi1t+eCuei/mOacquWumuS5iVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgwID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSBtYXRoU2luKHN0YXJ0QW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tQXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LCBjeSwgcngsIHJ5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnRpY2xvY2t3aXNlLCBtaW4yLCBtYXgyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgZnJvbUxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbUxpbmUoeDAsIHkwLCB4MCArIHdpZHRoLCB5MCArIGhlaWdodCwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVW5pb25cbiAgICAgICAgICAgICAgICB2ZWMyLm1pbihtaW4sIG1pbiwgbWluMik7XG4gICAgICAgICAgICAgICAgdmVjMi5tYXgobWF4LCBtYXgsIG1heDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBObyBkYXRhXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1pblswXSA9IG1pblsxXSA9IG1heFswXSA9IG1heFsxXSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KFxuICAgICAgICAgICAgICAgIG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVidWlsZCBwYXRoIGZyb20gY3VycmVudCBkYXRhXG4gICAgICAgICAqIFJlYnVpbGQgcGF0aCB3aWxsIG5vdCBjb25zaWRlciBqYXZhc2NyaXB0IGltcGxlbWVudGVkIGxpbmUgZGFzaC5cbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0fSBjdHhcbiAgICAgICAgICovXG4gICAgICAgIHJlYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIHZhciB4MCwgeTA7XG4gICAgICAgICAgICB2YXIgeGksIHlpO1xuICAgICAgICAgICAgdmFyIHgsIHk7XG4gICAgICAgICAgICB2YXIgdXggPSB0aGlzLl91eDtcbiAgICAgICAgICAgIHZhciB1eSA9IHRoaXMuX3V5O1xuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2xlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgICAgIHZhciBjbWQgPSBkW2krK107XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgICAgICAgICAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkW2ldO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRbaSArIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIHgwID0geGk7XG4gICAgICAgICAgICAgICAgICAgIHkwID0geWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHhpID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5aSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeGksIHlpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgZHJhdyB0b28gc21hbGwgc2VnIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRoQWJzKHggLSB4aSkgPiB1eCB8fCBtYXRoQWJzKHkgLSB5aSkgPiB1eSB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBkW2kgLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gZFtpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5BOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN4ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ5ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwc2kgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnMgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IChyeCA+IHJ5KSA/IHJ4IDogcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVYID0gKHJ4ID4gcnkpID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVZID0gKHJ4ID4gcnkpID8gcnkgLyByeCA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNFbGxpcHNlID0gTWF0aC5hYnMocnggLSByeSkgPiAxZS0zO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gdGhldGEgKyBkVGhldGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbGxpcHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUocHNpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKC1wc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhjeCwgY3ksIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSBtYXRoQ29zKHRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSBtYXRoU2luKHRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHhpID0gZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0geWkgPSBkW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBQYXRoUHJveHkuQ01EID0gQ01EO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXRoUHJveHk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL1BhdGhQcm94eS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOabsue6v+i+heWKqeaooeWdl1xuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciB2MkNyZWF0ZSA9IHZlYzIuY3JlYXRlO1xuICAgIHZhciB2MkRpc3RTcXVhcmUgPSB2ZWMyLmRpc3RTcXVhcmU7XG4gICAgdmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcbiAgICB2YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG5cbiAgICB2YXIgRVBTSUxPTiA9IDFlLTg7XG4gICAgdmFyIEVQU0lMT05fTlVNRVJJQyA9IDFlLTQ7XG5cbiAgICB2YXIgVEhSRUVfU1FSVCA9IG1hdGhTcXJ0KDMpO1xuICAgIHZhciBPTkVfVEhJUkQgPSAxIC8gMztcblxuICAgIC8vIOS4tOaXtuWPmOmHj1xuICAgIHZhciBfdjAgPSB2MkNyZWF0ZSgpO1xuICAgIHZhciBfdjEgPSB2MkNyZWF0ZSgpO1xuICAgIHZhciBfdjIgPSB2MkNyZWF0ZSgpO1xuICAgIC8vIHZhciBfdjMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgZnVuY3Rpb24gaXNBcm91bmRaZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gLUVQU0lMT04gJiYgdmFsIDwgRVBTSUxPTjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5YC8XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgICAgICAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIG9uZXQgKiBvbmV0ICogKG9uZXQgKiBwMCArIDMgKiB0ICogcDEpXG4gICAgICAgICAgICAgKyB0ICogdCAqICh0ICogcDMgKyAzICogb25ldCAqIHAyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTlr7zmlbDlgLxcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNEZXJpdmF0aXZlQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgICAgICAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIDMgKiAoXG4gICAgICAgICAgICAoKHAxIC0gcDApICogb25ldCArIDIgKiAocDIgLSBwMSkgKiB0KSAqIG9uZXRcbiAgICAgICAgICAgICsgKHAzIC0gcDIpICogdCAqIHRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTmlrnnqIvmoLnvvIzkvb/nlKjnm5vph5HlhazlvI9cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbFxuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICAgICAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5qC55pWw55uuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNSb290QXQocDAsIHAxLCBwMiwgcDMsIHZhbCwgcm9vdHMpIHtcbiAgICAgICAgLy8gRXZhbHVhdGUgcm9vdHMgb2YgY3ViaWMgZnVuY3Rpb25zXG4gICAgICAgIHZhciBhID0gcDMgKyAzICogKHAxIC0gcDIpIC0gcDA7XG4gICAgICAgIHZhciBiID0gMyAqIChwMiAtIHAxICogMiArIHAwKTtcbiAgICAgICAgdmFyIGMgPSAzICogKHAxICAtIHAwKTtcbiAgICAgICAgdmFyIGQgPSBwMCAtIHZhbDtcblxuICAgICAgICB2YXIgQSA9IGIgKiBiIC0gMyAqIGEgKiBjO1xuICAgICAgICB2YXIgQiA9IGIgKiBjIC0gOSAqIGEgKiBkO1xuICAgICAgICB2YXIgQyA9IGMgKiBjIC0gMyAqIGIgKiBkO1xuXG4gICAgICAgIHZhciBuID0gMDtcblxuICAgICAgICBpZiAoaXNBcm91bmRaZXJvKEEpICYmIGlzQXJvdW5kWmVybyhCKSkge1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhiKSkge1xuICAgICAgICAgICAgICAgIHJvb3RzWzBdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1jIC8gYjsgIC8vdDEsIHQyLCB0MywgYiBpcyBub3QgemVyb1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkaXNjID0gQiAqIEIgLSA0ICogQSAqIEM7XG5cbiAgICAgICAgICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgICAgICAgICAgICB2YXIgSyA9IEIgLyBBO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1iIC8gYSArIEs7ICAvLyB0MSwgYSBpcyBub3QgemVyb1xuICAgICAgICAgICAgICAgIHZhciB0MiA9IC1LIC8gMjsgIC8vIHQyLCB0M1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciBZMSA9IEEgKiBiICsgMS41ICogYSAqICgtQiArIGRpc2NTcXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgWTIgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgLSBkaXNjU3FydCk7XG4gICAgICAgICAgICAgICAgaWYgKFkxIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBZMSA9IC1tYXRoUG93KC1ZMSwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFkxID0gbWF0aFBvdyhZMSwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFkyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBZMiA9IC1tYXRoUG93KC1ZMiwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFkyID0gbWF0aFBvdyhZMiwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iIC0gKFkxICsgWTIpKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIFQgPSAoMiAqIEEgKiBiIC0gMyAqIGEgKiBCKSAvICgyICogbWF0aFNxcnQoQSAqIEEgKiBBKSk7XG4gICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gTWF0aC5hY29zKFQpIC8gMztcbiAgICAgICAgICAgICAgICB2YXIgQVNxcnQgPSBtYXRoU3FydChBKTtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gTWF0aC5jb3ModGhldGEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iIC0gMiAqIEFTcXJ0ICogdG1wKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iICsgQVNxcnQgKiAodG1wICsgVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcbiAgICAgICAgICAgICAgICB2YXIgdDMgPSAoLWIgKyBBU3FydCAqICh0bXAgLSBUSFJFRV9TUVJUICogTWF0aC5zaW4odGhldGEpKSkgLyAoMyAqIGEpO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQzID49IDAgJiYgdDMgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S4ieasoei0neWhnuWwlOaWueeoi+aegemZkOWAvOeahOS9jee9rlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBleHRyZW1hXG4gICAgICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmlbDnm65cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY0V4dHJlbWEocDAsIHAxLCBwMiwgcDMsIGV4dHJlbWEpIHtcbiAgICAgICAgdmFyIGIgPSA2ICogcDIgLSAxMiAqIHAxICsgNiAqIHAwO1xuICAgICAgICB2YXIgYSA9IDkgKiBwMSArIDMgKiBwMyAtIDMgKiBwMCAtIDkgKiBwMjtcbiAgICAgICAgdmFyIGMgPSAzICogcDEgLSAzICogcDA7XG5cbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgICAgICAgICBpZiAoaXNOb3RBcm91bmRaZXJvKGIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gLWMgLyBiO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9MSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgICAgIGV4dHJlbWFbMF0gPSAtYiAvICgyICogYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbWFbbisrXSA9IHQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnu4bliIbkuInmrKHotJ3loZ7lsJTmm7Lnur9cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNTdWJkaXZpZGUocDAsIHAxLCBwMiwgcDMsIHQsIG91dCkge1xuICAgICAgICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICAgICAgICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICAgICAgICB2YXIgcDIzID0gKHAzIC0gcDIpICogdCArIHAyO1xuXG4gICAgICAgIHZhciBwMDEyID0gKHAxMiAtIHAwMSkgKiB0ICsgcDAxO1xuICAgICAgICB2YXIgcDEyMyA9IChwMjMgLSBwMTIpICogdCArIHAxMjtcblxuICAgICAgICB2YXIgcDAxMjMgPSAocDEyMyAtIHAwMTIpICogdCArIHAwMTI7XG4gICAgICAgIC8vIFNlZzBcbiAgICAgICAgb3V0WzBdID0gcDA7XG4gICAgICAgIG91dFsxXSA9IHAwMTtcbiAgICAgICAgb3V0WzJdID0gcDAxMjtcbiAgICAgICAgb3V0WzNdID0gcDAxMjM7XG4gICAgICAgIC8vIFNlZzFcbiAgICAgICAgb3V0WzRdID0gcDAxMjM7XG4gICAgICAgIG91dFs1XSA9IHAxMjM7XG4gICAgICAgIG91dFs2XSA9IHAyMztcbiAgICAgICAgb3V0WzddID0gcDM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5oqV5bCE54K55Yiw5LiJ5qyh6LSd5aGe5bCU5puy57q/5LiK77yM6L+U5Zue5oqV5bCE6Led56a744CCXG4gICAgICog5oqV5bCE54K55pyJ5Y+v6IO95Lya5pyJ5LiA5Liq5oiW6ICF5aSa5Liq77yM6L+Z6YeM5Y+q6L+U5Zue5YW25Lit6Led56a75pyA55+t55qE5LiA5Liq44CCXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIOaKleWwhOeCuVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY1Byb2plY3RQb2ludChcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLFxuICAgICAgICB4LCB5LCBvdXRcbiAgICApIHtcbiAgICAgICAgLy8gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNwcm9qZWN0aW9uc1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgdmFyIGludGVydmFsID0gMC4wMDU7XG4gICAgICAgIHZhciBkID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBwcmV2O1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgdmFyIGQxO1xuICAgICAgICB2YXIgZDI7XG5cbiAgICAgICAgX3YwWzBdID0geDtcbiAgICAgICAgX3YwWzFdID0geTtcblxuICAgICAgICAvLyDlhYjnspfnlaXkvLDorqHkuIDkuIvlj6/og73nmoTmnIDlsI/ot53nprvnmoQgdCDlgLxcbiAgICAgICAgLy8gUEVORElOR1xuICAgICAgICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgICAgICAgICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgX3QpO1xuICAgICAgICAgICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgX3QpO1xuICAgICAgICAgICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuICAgICAgICAgICAgaWYgKGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBfdDtcbiAgICAgICAgICAgICAgICBkID0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZCA9IEluZmluaXR5O1xuXG4gICAgICAgIC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgICAgICAgICAgbmV4dCA9IHQgKyBpbnRlcnZhbDtcbiAgICAgICAgICAgIC8vIHQgLSBpbnRlcnZhbFxuICAgICAgICAgICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgcHJldik7XG4gICAgICAgICAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBwcmV2KTtcblxuICAgICAgICAgICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgICAgICAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBwcmV2O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIF92MlswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIG5leHQpO1xuICAgICAgICAgICAgICAgIF92MlsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIG5leHQpO1xuICAgICAgICAgICAgICAgIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkID0gZDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRcbiAgICAgICAgaWYgKG91dCkge1xuICAgICAgICAgICAgb3V0WzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICBvdXRbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG4gICAgICAgIHJldHVybiBtYXRoU3FydChkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTlgLxcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljQXQocDAsIHAxLCBwMiwgdCkge1xuICAgICAgICB2YXIgb25ldCA9IDEgLSB0O1xuICAgICAgICByZXR1cm4gb25ldCAqIChvbmV0ICogcDAgKyAyICogdCAqIHAxKSArIHQgKiB0ICogcDI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5a+85pWw5YC8XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCB0KSB7XG4gICAgICAgIHJldHVybiAyICogKCgxIC0gdCkgKiAocDEgLSBwMCkgKyB0ICogKHAyIC0gcDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTmlrnnqIvmoLlcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcm9vdHNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1Jvb3RBdChwMCwgcDEsIHAyLCB2YWwsIHJvb3RzKSB7XG4gICAgICAgIHZhciBhID0gcDAgLSAyICogcDEgKyBwMjtcbiAgICAgICAgdmFyIGIgPSAyICogKHAxIC0gcDApO1xuICAgICAgICB2YXIgYyA9IHAwIC0gdmFsO1xuXG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgICAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1jIC8gYjtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1iIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S6jOasoei0neWhnuWwlOaWueeoi+aegemZkOWAvFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0V4dHJlbXVtKHAwLCBwMSwgcDIpIHtcbiAgICAgICAgdmFyIGRpdmlkZXIgPSBwMCArIHAyIC0gMiAqIHAxO1xuICAgICAgICBpZiAoZGl2aWRlciA9PT0gMCkge1xuICAgICAgICAgICAgLy8gcDEgaXMgY2VudGVyIG9mIHAwIGFuZCBwMlxuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAocDAgLSBwMSkgLyBkaXZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog57uG5YiG5LqM5qyh6LSd5aGe5bCU5puy57q/XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHQsIG91dCkge1xuICAgICAgICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICAgICAgICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICAgICAgICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTtcblxuICAgICAgICAvLyBTZWcwXG4gICAgICAgIG91dFswXSA9IHAwO1xuICAgICAgICBvdXRbMV0gPSBwMDE7XG4gICAgICAgIG91dFsyXSA9IHAwMTI7XG5cbiAgICAgICAgLy8gU2VnMVxuICAgICAgICBvdXRbM10gPSBwMDEyO1xuICAgICAgICBvdXRbNF0gPSBwMTI7XG4gICAgICAgIG91dFs1XSA9IHAyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaKleWwhOeCueWIsOS6jOasoei0neWhnuWwlOabsue6v+S4iu+8jOi/lOWbnuaKleWwhOi3neemu+OAglxuICAgICAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXQg5oqV5bCE54K5XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1Byb2plY3RQb2ludChcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgeCwgeSwgb3V0XG4gICAgKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICAgICAgICB2YXIgZCA9IEluZmluaXR5O1xuXG4gICAgICAgIF92MFswXSA9IHg7XG4gICAgICAgIF92MFsxXSA9IHk7XG5cbiAgICAgICAgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICAgICAgICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIF90KTtcbiAgICAgICAgICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIF90KTtcbiAgICAgICAgICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjAsIF92MSk7XG4gICAgICAgICAgICBpZiAoZDEgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IF90O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkID0gSW5maW5pdHk7XG5cbiAgICAgICAgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgICAgICAgICAgdmFyIG5leHQgPSB0ICsgaW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyB0IC0gaW50ZXJ2YWxcbiAgICAgICAgICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHByZXYpO1xuICAgICAgICAgICAgX3YxWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgcHJldik7XG5cbiAgICAgICAgICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2ID49IDAgJiYgZDEgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IHByZXY7XG4gICAgICAgICAgICAgICAgZCA9IGQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdCArIGludGVydmFsXG4gICAgICAgICAgICAgICAgX3YyWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgbmV4dCk7XG4gICAgICAgICAgICAgICAgX3YyWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgbmV4dCk7XG4gICAgICAgICAgICAgICAgdmFyIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0XG4gICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHQpO1xuICAgICAgICAgICAgb3V0WzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coaW50ZXJ2YWwsIGkpO1xuICAgICAgICByZXR1cm4gbWF0aFNxcnQoZCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgY3ViaWNBdDogY3ViaWNBdCxcblxuICAgICAgICBjdWJpY0Rlcml2YXRpdmVBdDogY3ViaWNEZXJpdmF0aXZlQXQsXG5cbiAgICAgICAgY3ViaWNSb290QXQ6IGN1YmljUm9vdEF0LFxuXG4gICAgICAgIGN1YmljRXh0cmVtYTogY3ViaWNFeHRyZW1hLFxuXG4gICAgICAgIGN1YmljU3ViZGl2aWRlOiBjdWJpY1N1YmRpdmlkZSxcblxuICAgICAgICBjdWJpY1Byb2plY3RQb2ludDogY3ViaWNQcm9qZWN0UG9pbnQsXG5cbiAgICAgICAgcXVhZHJhdGljQXQ6IHF1YWRyYXRpY0F0LFxuXG4gICAgICAgIHF1YWRyYXRpY0Rlcml2YXRpdmVBdDogcXVhZHJhdGljRGVyaXZhdGl2ZUF0LFxuXG4gICAgICAgIHF1YWRyYXRpY1Jvb3RBdDogcXVhZHJhdGljUm9vdEF0LFxuXG4gICAgICAgIHF1YWRyYXRpY0V4dHJlbXVtOiBxdWFkcmF0aWNFeHRyZW11bSxcblxuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGU6IHF1YWRyYXRpY1N1YmRpdmlkZSxcblxuICAgICAgICBxdWFkcmF0aWNQcm9qZWN0UG9pbnQ6IHF1YWRyYXRpY1Byb2plY3RQb2ludFxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQGF1dGhvciBZaSBTaGVuKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cblxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJyk7XG5cbiAgICB2YXIgYmJveCA9IHt9O1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICB2YXIgbWF0aFNpbiA9IE1hdGguc2luO1xuICAgIHZhciBtYXRoQ29zID0gTWF0aC5jb3M7XG5cbiAgICB2YXIgc3RhcnQgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHZhciBlbmQgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHZhciBleHRyZW1pdHkgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgIC8qKlxuICAgICAqIOS7jumhtueCueaVsOe7hOS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwb2ludHMg6aG254K55pWw57uEXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgKi9cbiAgICBiYm94LmZyb21Qb2ludHMgPSBmdW5jdGlvbihwb2ludHMsIG1pbiwgbWF4KSB7XG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSBwb2ludHNbMF07XG4gICAgICAgIHZhciBsZWZ0ID0gcFswXTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcFswXTtcbiAgICAgICAgdmFyIHRvcCA9IHBbMV07XG4gICAgICAgIHZhciBib3R0b20gPSBwWzFdO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgbGVmdCA9IG1hdGhNaW4obGVmdCwgcFswXSk7XG4gICAgICAgICAgICByaWdodCA9IG1hdGhNYXgocmlnaHQsIHBbMF0pO1xuICAgICAgICAgICAgdG9wID0gbWF0aE1pbih0b3AsIHBbMV0pO1xuICAgICAgICAgICAgYm90dG9tID0gbWF0aE1heChib3R0b20sIHBbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWluWzBdID0gbGVmdDtcbiAgICAgICAgbWluWzFdID0gdG9wO1xuICAgICAgICBtYXhbMF0gPSByaWdodDtcbiAgICAgICAgbWF4WzFdID0gYm90dG9tO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tTGluZSA9IGZ1bmN0aW9uICh4MCwgeTAsIHgxLCB5MSwgbWluLCBtYXgpIHtcbiAgICAgICAgbWluWzBdID0gbWF0aE1pbih4MCwgeDEpO1xuICAgICAgICBtaW5bMV0gPSBtYXRoTWluKHkwLCB5MSk7XG4gICAgICAgIG1heFswXSA9IG1hdGhNYXgoeDAsIHgxKTtcbiAgICAgICAgbWF4WzFdID0gbWF0aE1heCh5MCwgeTEpO1xuICAgIH07XG5cbiAgICB2YXIgeERpbSA9IFtdO1xuICAgIHZhciB5RGltID0gW107XG4gICAgLyoqXG4gICAgICog5LuO5LiJ6Zi26LSd5aGe5bCU5puy57q/KHAwLCBwMSwgcDIsIHAzKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tQ3ViaWMgPSBmdW5jdGlvbihcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW4sIG1heFxuICAgICkge1xuICAgICAgICB2YXIgY3ViaWNFeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hO1xuICAgICAgICB2YXIgY3ViaWNBdCA9IGN1cnZlLmN1YmljQXQ7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbiA9IGN1YmljRXh0cmVtYSh4MCwgeDEsIHgyLCB4MywgeERpbSk7XG4gICAgICAgIG1pblswXSA9IEluZmluaXR5O1xuICAgICAgICBtaW5bMV0gPSBJbmZpbml0eTtcbiAgICAgICAgbWF4WzBdID0gLUluZmluaXR5O1xuICAgICAgICBtYXhbMV0gPSAtSW5maW5pdHk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB4RGltW2ldKTtcbiAgICAgICAgICAgIG1pblswXSA9IG1hdGhNaW4oeCwgbWluWzBdKTtcbiAgICAgICAgICAgIG1heFswXSA9IG1hdGhNYXgoeCwgbWF4WzBdKTtcbiAgICAgICAgfVxuICAgICAgICBuID0gY3ViaWNFeHRyZW1hKHkwLCB5MSwgeTIsIHkzLCB5RGltKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB5RGltW2ldKTtcbiAgICAgICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeSwgbWluWzFdKTtcbiAgICAgICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeSwgbWF4WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pblswXSA9IG1hdGhNaW4oeDAsIG1pblswXSk7XG4gICAgICAgIG1heFswXSA9IG1hdGhNYXgoeDAsIG1heFswXSk7XG4gICAgICAgIG1pblswXSA9IG1hdGhNaW4oeDMsIG1pblswXSk7XG4gICAgICAgIG1heFswXSA9IG1hdGhNYXgoeDMsIG1heFswXSk7XG5cbiAgICAgICAgbWluWzFdID0gbWF0aE1pbih5MCwgbWluWzFdKTtcbiAgICAgICAgbWF4WzFdID0gbWF0aE1heCh5MCwgbWF4WzFdKTtcbiAgICAgICAgbWluWzFdID0gbWF0aE1pbih5MywgbWluWzFdKTtcbiAgICAgICAgbWF4WzFdID0gbWF0aE1heCh5MywgbWF4WzFdKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5LuO5LqM6Zi26LSd5aGe5bCU5puy57q/KHAwLCBwMSwgcDIp5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAgICAgKi9cbiAgICBiYm94LmZyb21RdWFkcmF0aWMgPSBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBtaW4sIG1heCkge1xuICAgICAgICB2YXIgcXVhZHJhdGljRXh0cmVtdW0gPSBjdXJ2ZS5xdWFkcmF0aWNFeHRyZW11bTtcbiAgICAgICAgdmFyIHF1YWRyYXRpY0F0ID0gY3VydmUucXVhZHJhdGljQXQ7XG4gICAgICAgIC8vIEZpbmQgZXh0cmVtaXRpZXMsIHdoZXJlIGRlcml2YXRpdmUgaW4geCBkaW0gb3IgeSBkaW0gaXMgemVyb1xuICAgICAgICB2YXIgdHggPVxuICAgICAgICAgICAgbWF0aE1heChcbiAgICAgICAgICAgICAgICBtYXRoTWluKHF1YWRyYXRpY0V4dHJlbXVtKHgwLCB4MSwgeDIpLCAxKSwgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgdmFyIHR5ID1cbiAgICAgICAgICAgIG1hdGhNYXgoXG4gICAgICAgICAgICAgICAgbWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh5MCwgeTEsIHkyKSwgMSksIDBcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgdmFyIHggPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0eCk7XG4gICAgICAgIHZhciB5ID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdHkpO1xuXG4gICAgICAgIG1pblswXSA9IG1hdGhNaW4oeDAsIHgyLCB4KTtcbiAgICAgICAgbWluWzFdID0gbWF0aE1pbih5MCwgeTIsIHkpO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MiwgeCk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkyLCB5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5LuO5ZyG5byn5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFudGljbG9ja3dpc2VcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAgICAgKi9cbiAgICBiYm94LmZyb21BcmMgPSBmdW5jdGlvbiAoXG4gICAgICAgIHgsIHksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIG1pbiwgbWF4XG4gICAgKSB7XG4gICAgICAgIHZhciB2ZWMyTWluID0gdmVjMi5taW47XG4gICAgICAgIHZhciB2ZWMyTWF4ID0gdmVjMi5tYXg7XG5cbiAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xuXG5cbiAgICAgICAgaWYgKGRpZmYgJSBQSTIgPCAxZS00ICYmIGRpZmYgPiAxZS00KSB7XG4gICAgICAgICAgICAvLyBJcyBhIGNpcmNsZVxuICAgICAgICAgICAgbWluWzBdID0geCAtIHJ4O1xuICAgICAgICAgICAgbWluWzFdID0geSAtIHJ5O1xuICAgICAgICAgICAgbWF4WzBdID0geCArIHJ4O1xuICAgICAgICAgICAgbWF4WzFdID0geSArIHJ5O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRbMF0gPSBtYXRoQ29zKHN0YXJ0QW5nbGUpICogcnggKyB4O1xuICAgICAgICBzdGFydFsxXSA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIHk7XG5cbiAgICAgICAgZW5kWzBdID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIHg7XG4gICAgICAgIGVuZFsxXSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyB5O1xuXG4gICAgICAgIHZlYzJNaW4obWluLCBzdGFydCwgZW5kKTtcbiAgICAgICAgdmVjMk1heChtYXgsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIC8vIFRocmVzaCB0byBbMCwgTWF0aC5QSSAqIDJdXG4gICAgICAgIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlICUgKFBJMik7XG4gICAgICAgIGlmIChzdGFydEFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBQSTI7XG4gICAgICAgIH1cbiAgICAgICAgZW5kQW5nbGUgPSBlbmRBbmdsZSAlIChQSTIpO1xuICAgICAgICBpZiAoZW5kQW5nbGUgPCAwKSB7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IGVuZEFuZ2xlICsgUEkyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSAmJiAhYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgZW5kQW5nbGUgKz0gUEkyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0QW5nbGUgPCBlbmRBbmdsZSAmJiBhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICBzdGFydEFuZ2xlICs9IFBJMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IGVuZEFuZ2xlO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhciBudW1iZXIgPSAwO1xuICAgICAgICAvLyB2YXIgc3RlcCA9IChhbnRpY2xvY2t3aXNlID8gLU1hdGguUEkgOiBNYXRoLlBJKSAvIDI7XG4gICAgICAgIGZvciAodmFyIGFuZ2xlID0gMDsgYW5nbGUgPCBlbmRBbmdsZTsgYW5nbGUgKz0gTWF0aC5QSSAvIDIpIHtcbiAgICAgICAgICAgIGlmIChhbmdsZSA+IHN0YXJ0QW5nbGUpIHtcbiAgICAgICAgICAgICAgICBleHRyZW1pdHlbMF0gPSBtYXRoQ29zKGFuZ2xlKSAqIHJ4ICsgeDtcbiAgICAgICAgICAgICAgICBleHRyZW1pdHlbMV0gPSBtYXRoU2luKGFuZ2xlKSAqIHJ5ICsgeTtcblxuICAgICAgICAgICAgICAgIHZlYzJNaW4obWluLCBleHRyZW1pdHksIG1pbik7XG4gICAgICAgICAgICAgICAgdmVjMk1heChtYXgsIGV4dHJlbWl0eSwgbWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJib3g7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvYmJveC5qc1xuICoqIG1vZHVsZSBpZCA9IDI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBDTUQgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpLkNNRDtcbiAgICB2YXIgbGluZSA9IHJlcXVpcmUoJy4vbGluZScpO1xuICAgIHZhciBjdWJpYyA9IHJlcXVpcmUoJy4vY3ViaWMnKTtcbiAgICB2YXIgcXVhZHJhdGljID0gcmVxdWlyZSgnLi9xdWFkcmF0aWMnKTtcbiAgICB2YXIgYXJjID0gcmVxdWlyZSgnLi9hcmMnKTtcbiAgICB2YXIgbm9ybWFsaXplUmFkaWFuID0gcmVxdWlyZSgnLi91dGlsJykubm9ybWFsaXplUmFkaWFuO1xuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvY3VydmUnKTtcblxuICAgIHZhciB3aW5kaW5nTGluZSA9IHJlcXVpcmUoJy4vd2luZGluZ0xpbmUnKTtcblxuICAgIHZhciBjb250YWluU3Ryb2tlID0gbGluZS5jb250YWluU3Ryb2tlO1xuXG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuXG4gICAgdmFyIEVQU0lMT04gPSAxZS00O1xuXG4gICAgZnVuY3Rpb24gaXNBcm91bmRFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBFUFNJTE9OO1xuICAgIH1cblxuICAgIC8vIOS4tOaXtuaVsOe7hFxuICAgIHZhciByb290cyA9IFstMSwgLTEsIC0xXTtcbiAgICB2YXIgZXh0cmVtYSA9IFstMSwgLTFdO1xuXG4gICAgZnVuY3Rpb24gc3dhcEV4dHJlbWEoKSB7XG4gICAgICAgIHZhciB0bXAgPSBleHRyZW1hWzBdO1xuICAgICAgICBleHRyZW1hWzBdID0gZXh0cmVtYVsxXTtcbiAgICAgICAgZXh0cmVtYVsxXSA9IHRtcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aW5kaW5nQ3ViaWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5KSB7XG4gICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoeSA+IHkwICYmIHkgPiB5MSAmJiB5ID4geTIgJiYgeSA+IHkzKVxuICAgICAgICAgICAgfHwgKHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyICYmIHkgPCB5MylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgblJvb3RzID0gY3VydmUuY3ViaWNSb290QXQoeTAsIHkxLCB5MiwgeTMsIHksIHJvb3RzKTtcbiAgICAgICAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgICAgICB2YXIgbkV4dHJlbWEgPSAtMTtcbiAgICAgICAgICAgIHZhciB5MF8sIHkxXztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJvb3RzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHJvb3RzW2ldO1xuXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgd2luZGluZyBlcnJvciB3aGVuIGludGVyc2VjdGlvbiBwb2ludCBpcyB0aGUgY29ubmVjdCBwb2ludCBvZiB0d28gbGluZSBvZiBwb2x5Z29uXG4gICAgICAgICAgICAgICAgdmFyIHVuaXQgPSAodCA9PT0gMCB8fCB0ID09PSAxKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5jdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgICAgICAgICBpZiAoeF8gPCB4KSB7IC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5FeHRyZW1hIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBuRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyZW1hWzFdIDwgZXh0cmVtYVswXSAmJiBuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3YXBFeHRyZW1hKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeTBfID0gY3VydmUuY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYVswXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWIhuaIkOS4ieauteWNleiwg+WHveaVsFxuICAgICAgICAgICAgICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTBfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodCA8IGV4dHJlbWFbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTFfIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MyA8IHkxXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5YiG5oiQ5Lik5q615Y2V6LCD5Ye95pWwXG4gICAgICAgICAgICAgICAgICAgIGlmICh0IDwgZXh0cmVtYVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MF8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTMgPCB5MF8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpbmRpbmdRdWFkcmF0aWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyKVxuICAgICAgICAgICAgfHwgKHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuUm9vdHMgPSBjdXJ2ZS5xdWFkcmF0aWNSb290QXQoeTAsIHkxLCB5MiwgeSwgcm9vdHMpO1xuICAgICAgICBpZiAoblJvb3RzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0ID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5Mik7XG4gICAgICAgICAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgICAgICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgeV8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbmUgZW5kcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgIHZhciB1bml0ID0gKHJvb3RzW2ldID09PSAwIHx8IHJvb3RzW2ldID09PSAxKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeF8gPCB4KSB7ICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocm9vdHNbaV0gPCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHlfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkyIDwgeV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgICAgICAgICAgIHZhciB1bml0ID0gKHJvb3RzWzBdID09PSAwIHx8IHJvb3RzWzBdID09PSAxKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCByb290c1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKHhfIDwgeCkgeyAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHkyIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPXG4gICAgLy8gQXJjIOaXi+i9rFxuICAgIGZ1bmN0aW9uIHdpbmRpbmdBcmMoXG4gICAgICAgIGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHgsIHlcbiAgICApIHtcbiAgICAgICAgeSAtPSBjeTtcbiAgICAgICAgaWYgKHkgPiByIHx8IHkgPCAtcikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRtcCA9IE1hdGguc3FydChyICogciAtIHkgKiB5KTtcbiAgICAgICAgcm9vdHNbMF0gPSAtdG1wO1xuICAgICAgICByb290c1sxXSA9IHRtcDtcblxuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG4gICAgICAgIGlmIChkaWZmIDwgMWUtNCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpZmYgJSBQSTIgPCAxZS00KSB7XG4gICAgICAgICAgICAvLyBJcyBhIGNpcmNsZVxuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IDA7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IFBJMjtcbiAgICAgICAgICAgIHZhciBkaXIgPSBhbnRpY2xvY2t3aXNlID8gMSA6IC0xO1xuICAgICAgICAgICAgaWYgKHggPj0gcm9vdHNbMF0gKyBjeCAmJiB4IDw9IHJvb3RzWzFdICsgY3gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4odG1wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgICAgICAgICAgZW5kQW5nbGUgKz0gUEkyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgdmFyIHhfID0gcm9vdHNbaV07XG4gICAgICAgICAgICBpZiAoeF8gKyBjeCA+IHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHksIHhfKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gUEkyICsgYW5nbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUpXG4gICAgICAgICAgICAgICAgICAgIHx8IChhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJIC8gMiAmJiBhbmdsZSA8IE1hdGguUEkgKiAxLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpciA9IC1kaXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdyArPSBkaXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5QYXRoKGRhdGEsIGxpbmVXaWR0aCwgaXNTdHJva2UsIHgsIHkpIHtcbiAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICB2YXIgeGkgPSAwO1xuICAgICAgICB2YXIgeWkgPSAwO1xuICAgICAgICB2YXIgeDAgPSAwO1xuICAgICAgICB2YXIgeTAgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgLy8gQmVnaW4gYSBuZXcgc3VicGF0aFxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gQ01ELk0gJiYgaSA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzdWJwYXRoXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgICAgICAgLy8gaWYgKHcgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSArIDFdO1xuXG4gICAgICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgICAgICB5MCA9IHlpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgICAgICAgICAgICAgIC8vIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5L2/55SoXG4gICAgICAgICAgICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFIOWcqOesrOS4gOS4quWRveS7pOS4uiBMLCBDLCBRIOeahOaXtuWAmeS8muiuoeeul+WHuiBOYU5cbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgeCwgeSkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1YmljLmNvbnRhaW5TdHJva2UoeGksIHlpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdDdWJpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWFkcmF0aWMuY29udGFpblN0cm9rZSh4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nUXVhZHJhdGljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5Yik5pat55qE5byA6ZSA5q+U6L6D5aSnXG4gICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZFRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEFyYyDml4vovaxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSBNYXRoLmNvcyh0aGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTEgPSBNYXRoLnNpbih0aGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAvLyDkuI3mmK/nm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHgxO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB6ciDkvb/nlKhzY2FsZeadpeaooeaLn+akreWchiwg6L+Z6YeM5Lmf5a+5eOWBmuS4gOWumueahOe8qeaUvlxuICAgICAgICAgICAgICAgICAgICB2YXIgX3ggPSAoeCAtIGN4KSAqIHJ5IC8gcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJjLmNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCwgX3gsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0FyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3gsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBNYXRoLmNvcyh0aGV0YSArIGRUaGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICB5aSA9IE1hdGguc2luKHRoZXRhICsgZFRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHkwID0geWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0geDAgKyB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0geTAgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTAsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29udGFpblN0cm9rZSh4MSwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBjb250YWluU3Ryb2tlKHgxLCB5MSwgeDAsIHkxLCBsaW5lV2lkdGgsIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNvbnRhaW5TdHJva2UoeDAsIHkxLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgQ2xvY2t3aXNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDEsIHkwLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4MCwgeTEsIHgwLCB5MCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpblN0cm9rZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksIHgwLCB5MCwgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZSBhIHN1YnBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBzdWJwYXRocyBtYXkgb3ZlcmxhcFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHcgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzU3Ryb2tlICYmICFpc0Fyb3VuZEVxdWFsKHlpLCB5MCkpIHtcbiAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHcgIT09IDA7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uIChwYXRoRGF0YSwgeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCAwLCBmYWxzZSwgeCwgeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKHBhdGhEYXRhLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluUGF0aChwYXRoRGF0YSwgbGluZVdpZHRoLCB0cnVlLCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3BhdGguanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnur/mrrXljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKHgwLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICB2YXIgX2EgPSAwO1xuICAgICAgICAgICAgdmFyIF9iID0geDA7XG4gICAgICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh4MCAhPT0geDEpIHtcbiAgICAgICAgICAgICAgICBfYSA9ICh5MCAtIHkxKSAvICh4MCAtIHgxKTtcbiAgICAgICAgICAgICAgICBfYiA9ICh4MCAqIHkxIC0geDEgKiB5MCkgLyAoeDAgLSB4MSkgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHggLSB4MCkgPD0gX2wgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRtcCA9IF9hICogeCAtIHkgKyBfYjtcbiAgICAgICAgICAgIHZhciBfcyA9IHRtcCAqIHRtcCAvIChfYSAqIF9hICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gX3MgPD0gX2wgLyAyICogX2wgLyAyO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vbGluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvY3VydmUnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5LiJ5qyh6LSd5aGe5bCU5puy57q/5o+P6L655YyF5ZCr5Yik5patXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgzXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkzXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5TdHJva2U6IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sICYmIHkgPiB5MiArIF9sICYmIHkgPiB5MyArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCAmJiB5IDwgeTIgLSBfbCAmJiB5IDwgeTMgLSBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wgJiYgeCA+IHgzICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sICYmIHggPCB4MiAtIF9sICYmIHggPCB4MyAtIF9sKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGQgPSBjdXJ2ZS5jdWJpY1Byb2plY3RQb2ludChcbiAgICAgICAgICAgICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsXG4gICAgICAgICAgICAgICAgeCwgeSwgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBkIDw9IF9sIC8gMjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb250YWluL2N1YmljLmpzXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY29yZS9jdXJ2ZScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuozmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIGxpbmVXaWR0aCwgeCwgeSkge1xuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbCAmJiB5ID4geTIgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgJiYgeSA8IHkyIC0gX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sICYmIHggPiB4MiArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbCAmJiB4IDwgeDIgLSBfbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkID0gY3VydmUucXVhZHJhdGljUHJvamVjdFBvaW50KFxuICAgICAgICAgICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICAgICAgeCwgeSwgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBkIDw9IF9sIC8gMjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3F1YWRyYXRpYy5qc1xuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIHZhciBub3JtYWxpemVSYWRpYW4gPSByZXF1aXJlKCcuL3V0aWwnKS5ub3JtYWxpemVSYWRpYW47XG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlnIblvKfmj4/ovrnljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgY3hcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgY3lcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBzdGFydEFuZ2xlXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGVuZEFuZ2xlXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59ICBhbnRpY2xvY2t3aXNlXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKFxuICAgICAgICAgICAgY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICApIHtcblxuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbCA9IGxpbmVXaWR0aDtcblxuICAgICAgICAgICAgeCAtPSBjeDtcbiAgICAgICAgICAgIHkgLT0gY3k7XG4gICAgICAgICAgICB2YXIgZCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblxuICAgICAgICAgICAgaWYgKChkIC0gX2wgPiByKSB8fCAoZCArIF9sIDwgcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSAlIFBJMiA8IDFlLTQpIHtcbiAgICAgICAgICAgICAgICAvLyBJcyBhIGNpcmNsZVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICAgICAgICAgICAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgICAgICAgICBlbmRBbmdsZSArPSBQSTI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeCk7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgYW5nbGUgKz0gUEkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlKVxuICAgICAgICAgICAgICAgIHx8IChhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb250YWluL2FyYy5qc1xuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgbm9ybWFsaXplUmFkaWFuOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICAgICAgYW5nbGUgJT0gUEkyO1xuICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgIGFuZ2xlICs9IFBJMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhbmdsZTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3V0aWwuanNcbiAqKiBtb2R1bGUgaWQgPSAzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aW5kaW5nTGluZSh4MCwgeTAsIHgxLCB5MSwgeCwgeSkge1xuICAgICAgICBpZiAoKHkgPiB5MCAmJiB5ID4geTEpIHx8ICh5IDwgeTAgJiYgeSA8IHkxKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWdub3JlIGhvcml6b250YWwgbGluZVxuICAgICAgICBpZiAoeTEgPT09IHkwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlyID0geTEgPCB5MCA/IDEgOiAtMTtcbiAgICAgICAgdmFyIHQgPSAoeSAtIHkwKSAvICh5MSAtIHkwKTtcblxuICAgICAgICAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cbiAgICAgICAgaWYgKHQgPT09IDEgfHwgdCA9PT0gMCkge1xuICAgICAgICAgICAgZGlyID0geTEgPCB5MCA/IDAuNSA6IC0wLjU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeF8gPSB0ICogKHgxIC0geDApICsgeDA7XG5cbiAgICAgICAgcmV0dXJuIHhfID4geCA/IGRpciA6IDA7XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vd2luZGluZ0xpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5cbiAgICB2YXIgUGF0dGVybiA9IGZ1bmN0aW9uIChpbWFnZSwgcmVwZWF0KSB7XG4gICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgdGhpcy5yZXBlYXQgPSByZXBlYXQ7XG5cbiAgICAgICAgLy8gQ2FuIGJlIGNsb25lZFxuICAgICAgICB0aGlzLnR5cGUgPSAncGF0dGVybic7XG4gICAgfTtcblxuICAgIFBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm4gPSBmdW5jdGlvbiAoY3R4KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhc1BhdHRlcm5cbiAgICAgICAgICAgIHx8ICh0aGlzLl9jYW52YXNQYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odGhpcy5pbWFnZSwgdGhpcy5yZXBlYXQpKTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXR0ZXJuO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9QYXR0ZXJuLmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIENNRCA9IHJlcXVpcmUoJy4uL2NvcmUvUGF0aFByb3h5JykuQ01EO1xuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi4vY29yZS92ZWN0b3InKTtcbiAgICB2YXIgdjJBcHBseVRyYW5zZm9ybSA9IHZlYzIuYXBwbHlUcmFuc2Zvcm07XG5cbiAgICB2YXIgcG9pbnRzID0gW1tdLCBbXSwgW11dO1xuICAgIHZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgbWF0aEF0YW4yID0gTWF0aC5hdGFuMjtcbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1QYXRoKHBhdGgsIG0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgIHZhciBjbWQ7XG4gICAgICAgIHZhciBuUG9pbnQ7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgajtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIHZhciBwO1xuXG4gICAgICAgIHZhciBNID0gQ01ELk07XG4gICAgICAgIHZhciBDID0gQ01ELkM7XG4gICAgICAgIHZhciBMID0gQ01ELkw7XG4gICAgICAgIHZhciBSID0gQ01ELlI7XG4gICAgICAgIHZhciBBID0gQ01ELkE7XG4gICAgICAgIHZhciBRID0gQ01ELlE7XG5cbiAgICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGNtZCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgIGogPSBpO1xuICAgICAgICAgICAgblBvaW50ID0gMDtcblxuICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE06XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTDpcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDOlxuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFE6XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBtWzRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IG1bNV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IG1hdGhTcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSBtYXRoU3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gbWF0aEF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGN4XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSB4O1xuICAgICAgICAgICAgICAgICAgICAvLyBjeVxuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKz0geTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NhbGUgcnggYW5kIHJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIEFzc3VtZSBwc2kgaXMgMCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSAqPSBzeDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICo9IHN5O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kIGFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgcHNpXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUjpcbiAgICAgICAgICAgICAgICAgICAgLy8geDAsIHkwXG4gICAgICAgICAgICAgICAgICAgIHBbMF0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHBbMV0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgICAgICAgICAgICAgICAgIC8vIHgxLCB5MVxuICAgICAgICAgICAgICAgICAgICBwWzBdICs9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcFsxXSArPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBuUG9pbnQ7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBwID0gcG9pbnRzW2tdO1xuICAgICAgICAgICAgICAgIHBbMF0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgcFsxXSA9IGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgICAgICAgICAgLy8gV3JpdGUgYmFja1xuICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtUGF0aDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3Rvb2wvdHJhbnNmb3JtUGF0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAgICAgKi9cbiAgICB2YXIgR3JhZGllbnQgPSBmdW5jdGlvbiAoY29sb3JTdG9wcykge1xuXG4gICAgICAgIHRoaXMuY29sb3JTdG9wcyA9IGNvbG9yU3RvcHMgfHwgW107XG4gICAgfTtcblxuICAgIEdyYWRpZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogR3JhZGllbnQsXG5cbiAgICAgICAgYWRkQ29sb3JTdG9wOiBmdW5jdGlvbiAob2Zmc2V0LCBjb2xvcikge1xuICAgICAgICAgICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG5cbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JhZGllbnQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFRPRE8gRHJhZ2dhYmxlIGZvciBncm91cFxuLy8gRklYTUUgRHJhZ2dhYmxlIG9uIGVsZW1lbnQgd2hpY2ggaGFzIHBhcmVudCByb3RhdGlvbiBvciBzY2FsZVxuXG4gICAgZnVuY3Rpb24gRHJhZ2dhYmxlKCkge1xuXG4gICAgICAgIHRoaXMub24oJ21vdXNlZG93bicsIHRoaXMuX2RyYWdTdGFydCwgdGhpcyk7XG4gICAgICAgIHRoaXMub24oJ21vdXNlbW92ZScsIHRoaXMuX2RyYWcsIHRoaXMpO1xuICAgICAgICB0aGlzLm9uKCdtb3VzZXVwJywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7XG4gICAgICAgIHRoaXMub24oJ2dsb2JhbG91dCcsIHRoaXMuX2RyYWdFbmQsIHRoaXMpO1xuICAgICAgICAvLyB0aGlzLl9kcm9wVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgLy8gdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBudWxsO1xuXG4gICAgICAgIC8vIHRoaXMuX3ggPSAwO1xuICAgICAgICAvLyB0aGlzLl95ID0gMDtcbiAgICB9XG5cbiAgICBEcmFnZ2FibGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBEcmFnZ2FibGUsXG5cbiAgICAgICAgX2RyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICYmIGRyYWdnaW5nVGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gZHJhZ2dpbmdUYXJnZXQ7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSBlLm9mZnNldFg7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IGUub2Zmc2V0WTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoZHJhZ2dpbmdUYXJnZXQsICdkcmFnc3RhcnQnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IHRoaXMuX2RyYWdnaW5nVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGUub2Zmc2V0WTtcblxuICAgICAgICAgICAgICAgIHZhciBkeCA9IHggLSB0aGlzLl94O1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IHkgLSB0aGlzLl95O1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJpZnQoZHgsIGR5LCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGRyYWdnaW5nVGFyZ2V0LCAnZHJhZycsIGUuZXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRyb3BUYXJnZXQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5LCBkcmFnZ2luZ1RhcmdldCk7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3REcm9wVGFyZ2V0ID0gdGhpcy5fZHJvcFRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcm9wVGFyZ2V0ID0gZHJvcFRhcmdldDtcblxuICAgICAgICAgICAgICAgIGlmIChkcmFnZ2luZ1RhcmdldCAhPT0gZHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdERyb3BUYXJnZXQgJiYgZHJvcFRhcmdldCAhPT0gbGFzdERyb3BUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQobGFzdERyb3BUYXJnZXQsICdkcmFnbGVhdmUnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChkcm9wVGFyZ2V0LCAnZHJhZ2VudGVyJywgZS5ldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcblxuICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChkcmFnZ2luZ1RhcmdldCwgJ2RyYWdlbmQnLCBlLmV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2Ryb3BUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHRoaXMuX2Ryb3BUYXJnZXQsICdkcm9wJywgZS5ldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEcmFnZ2FibGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9taXhpbi9EcmFnZ2FibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBHcm91cOaYr+S4gOS4quWuueWZqO+8jOWPr+S7peaPkuWFpeWtkOiKgueCue+8jEdyb3Vw55qE5Y+Y5o2i5Lmf5Lya6KKr5bqU55So5Yiw5a2Q6IqC54K55LiKXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAnKTtcbiAqICAgICB2YXIgQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUnKTtcbiAqICAgICB2YXIgZyA9IG5ldyBHcm91cCgpO1xuICogICAgIGcucG9zaXRpb25bMF0gPSAxMDA7XG4gKiAgICAgZy5wb3NpdGlvblsxXSA9IDEwMDtcbiAqICAgICBnLmFkZChuZXcgQ2lyY2xlKHtcbiAqICAgICAgICAgc3R5bGU6IHtcbiAqICAgICAgICAgICAgIHg6IDEwMCxcbiAqICAgICAgICAgICAgIHk6IDEwMCxcbiAqICAgICAgICAgICAgIHI6IDIwLFxuICogICAgICAgICB9XG4gKiAgICAgfSkpO1xuICogICAgIHpyLmFkZChnKTtcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuLi9FbGVtZW50Jyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4uL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICAgICAqL1xuICAgIHZhciBHcm91cCA9IGZ1bmN0aW9uIChvcHRzKSB7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgRWxlbWVudC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRzKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gb3B0c1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcblxuICAgICAgICB0aGlzLl9fc3RvcmFnZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgR3JvdXAucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBHcm91cCxcblxuICAgICAgICBpc0dyb3VwOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2dyb3VwJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5omA5pyJ5a2Q5a2Z5YWD57Sg5piv5ZCm5ZON5bqU6byg5qCH5LqL5Lu2XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9jb250YWluZXIvR3JvdXAjc2lsZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lsZW50OiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL0VsZW1lbnQ+fVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmjIflrpogaW5kZXgg55qE5YS/5a2Q6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gaWR4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZEF0OiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW5baWR4XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5oyH5a6a5ZCN5a2X55qE5YS/5a2Q6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRPZk5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW5baV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRDb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5a2Q6IqC54K55Yiw5pyA5ZCOXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgY2hpbGQgIT09IHRoaXMgJiYgY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2RvQWRkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWtkOiKgueCueWcqCBuZXh0U2libGluZyDkuYvliY1cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IG5leHRTaWJsaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhZGRCZWZvcmU6IGZ1bmN0aW9uIChjaGlsZCwgbmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXNcbiAgICAgICAgICAgICAgICAmJiBuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnQgPT09IHRoaXMpIHtcblxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBjaGlsZHJlbi5pbmRleE9mKG5leHRTaWJsaW5nKTtcblxuICAgICAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAwLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvQWRkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb0FkZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50LnJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgICAgICAgICBpZiAoc3RvcmFnZSAmJiBzdG9yYWdlICE9PSBjaGlsZC5fX3N0b3JhZ2UpIHtcblxuICAgICAgICAgICAgICAgIHN0b3JhZ2UuYWRkVG9NYXAoY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOenu+mZpOWtkOiKgueCuVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICAgICAgICB2YXIgaWR4ID0genJVdGlsLmluZGV4T2YoY2hpbGRyZW4sIGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcblxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHN0b3JhZ2UpIHtcblxuICAgICAgICAgICAgICAgIHN0b3JhZ2UuZGVsRnJvbU1hcChjaGlsZC5pZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgenIgJiYgenIucmVmcmVzaCgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog56e76Zmk5omA5pyJ5a2Q6IqC54K5XG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLmRlbEZyb21NYXAoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmBjeWOhuaJgOacieWtkOiKgueCuVxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGVhY2hDaGlsZDogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7HluqbkvJjlhYjpgY3ljobmiYDmnInlrZDlrZnoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBjaGlsZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkQ2hpbGRyZW5Ub1N0b3JhZ2U6IGZ1bmN0aW9uIChzdG9yYWdlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5hZGRUb01hcChjaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuYWRkQ2hpbGRyZW5Ub1N0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRlbENoaWxkcmVuRnJvbVN0b3JhZ2U6IGZ1bmN0aW9uIChzdG9yYWdlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5kZWxGcm9tTWFwKGNoaWxkLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgICAgICAgICAvLyBUT0RPIENhY2hpbmdcbiAgICAgICAgICAgIHZhciByZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGluY2x1ZGVDaGlsZHJlbiB8fCB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciB0bXBNYXQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5pZ25vcmUgfHwgY2hpbGQuaW52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjaGlsZFJlY3QgPSBjaGlsZC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gY2hpbGQuZ2V0TG9jYWxUcmFuc2Zvcm0odG1wTWF0KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAgICAgLy8gVGhlIGJvdW5kaW5nUmVjdCBjYWNsdWF0ZWQgYnkgdHJhbnNmb3JtaW5nIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgLy8gcmVjdCBtYXkgYmUgYmlnZ2VyIHRoYW4gdGhlIGFjdHVhbCBidW5kaW5nUmVjdCB3aGVuIHJvdGF0aW9uXG4gICAgICAgICAgICAgICAgLy8gaXMgdXNlZC4gKENvbnNpZGVyIGEgY2lyY2xlIHJvdGF0ZWQgYWdpbnN0IGl0cyBjZW50ZXIsIHdoZXJlXG4gICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCBib3VuZGluZ1JlY3Qgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoYXQgbm90IGJlXG4gICAgICAgICAgICAgICAgLy8gcm90YXRlZC4pIEJ1dCB3ZSBjYW4gbm90IGZpbmQgYmV0dGVyIGFwcHJvYWNoIHRvIGNhbGN1bGF0ZVxuICAgICAgICAgICAgICAgIC8vIGFjdHVhbCBib3VuZGluZ1JlY3QgeWV0LCBjb25zaWRlcmluZyBwZXJmb3JtYW5jZS5cbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJlY3QuY29weShjaGlsZFJlY3QpO1xuICAgICAgICAgICAgICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSByZWN0IHx8IHRtcFJlY3QuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdC51bmlvbih0bXBSZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSByZWN0IHx8IGNoaWxkUmVjdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICByZWN0LnVuaW9uKGNoaWxkUmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY3QgfHwgdG1wUmVjdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoR3JvdXAsIEVsZW1lbnQpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHcm91cDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cC5qc1xuICoqIG1vZHVsZSBpZCA9IDQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEltYWdlIGVsZW1lbnRcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL0ltYWdlXG4gKi9cblxuXG5cbiAgICB2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKCcuL0Rpc3BsYXlhYmxlJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4uL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIExSVSA9IHJlcXVpcmUoJy4uL2NvcmUvTFJVJyk7XG4gICAgdmFyIGdsb2JhbEltYWdlQ2FjaGUgPSBuZXcgTFJVKDUwKTtcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgenJlbmRlci9ncmFwaGljL0ltYWdlXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gWkltYWdlKG9wdHMpIHtcbiAgICAgICAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB9XG5cbiAgICBaSW1hZ2UucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBaSW1hZ2UsXG5cbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcblxuICAgICAgICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgdmFyIHNyYyA9IHN0eWxlLmltYWdlO1xuICAgICAgICAgICAgdmFyIGltYWdlO1xuXG4gICAgICAgICAgICAvLyBNdXN0IGJpbmQgZWFjaCB0aW1lXG4gICAgICAgICAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcbiAgICAgICAgICAgIC8vIHN0eWxlLmltYWdlIGlzIGEgdXJsIHN0cmluZ1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UgPSB0aGlzLl9pbWFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0eWxlLmltYWdlIGlzIGFuIEhUTUxJbWFnZUVsZW1lbnQgb3IgSFRNTENhbnZhc0VsZW1lbnQgb3IgQ2FudmFzXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbWFnZSA9IHNyYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZJWE1FIENhc2UgY3JlYXRlIG1hbnkgaW1hZ2VzIHdpdGggc3JjXG4gICAgICAgICAgICBpZiAoIWltYWdlICYmIHNyYykge1xuICAgICAgICAgICAgICAgIC8vIFRyeSBnZXQgZnJvbSBnbG9iYWwgaW1hZ2UgY2FjaGVcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQoc3JjKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlZEltZ09iaikge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FjaGVkSW1nT2JqLnBlbmRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRJbWdPYmoucGVuZGluZ1tpXS5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWRJbWdPYmogPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nOiBbdGhpc11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gc3JjO1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxJbWFnZUNhY2hlLnB1dChzcmMsIGNhY2hlZEltZ09iaik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlID0gY2FjaGVkSW1nT2JqLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbWFnZSBpcyBub3QgY29tcGxldGUgZmluaXNoLCBhZGQgdG8gcGVuZGluZyBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW1hZ2Uud2lkdGggfHwgIWltYWdlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkSW1nT2JqLnBlbmRpbmcucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgLy8g5Zu+54mH5bey57uP5Yqg6L295a6M5oiQXG4gICAgICAgICAgICAgICAgLy8gaWYgKGltYWdlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKCFpbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIEVsc2UgaXMgY2FudmFzXG5cbiAgICAgICAgICAgICAgICB2YXIgeCA9IHN0eWxlLnggfHwgMDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcbiAgICAgICAgICAgICAgICAvLyDlm77niYfliqDovb3lpLHotKVcbiAgICAgICAgICAgICAgICBpZiAoIWltYWdlLndpZHRoIHx8ICFpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc3R5bGUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBhc3BlY3QgPSBpbWFnZS53aWR0aCAvIGltYWdlLmhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGltYWdlL2hlaWdodCByYXRpb1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGhlaWdodCAqIGFzcGVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwgJiYgd2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8g6K6+572udHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5zV2lkdGggJiYgc3R5bGUuc0hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ggPSBzdHlsZS5zeCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzeCwgc3ksIHN0eWxlLnNXaWR0aCwgc3R5bGUuc0hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsIHksIHdpZHRoLCBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGUuc3ggJiYgc3R5bGUuc3kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4ID0gc3R5bGUuc3g7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeSA9IHN0eWxlLnN5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc1dpZHRoID0gd2lkdGggLSBzeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNIZWlnaHQgPSBoZWlnaHQgLSBzeTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3gsIHN5LCBzV2lkdGgsIHNIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCB3aWR0aCwgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICAgICAgICAgIC8vIERyYXcgcmVjdCB0ZXh0XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdSZWN0VGV4dChjdHgsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIGlmICghIHRoaXMuX3JlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUueCB8fCAwLCBzdHlsZS55IHx8IDAsIHN0eWxlLndpZHRoIHx8IDAsIHN0eWxlLmhlaWdodCB8fCAwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhaSW1hZ2UsIERpc3BsYXlhYmxlKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gWkltYWdlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIFRleHQgZWxlbWVudFxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvVGV4dFxuICpcbiAqIFRPRE8gV3JhcHBpbmdcbiAqXG4gKiBUZXh0IG5vdCBzdXBwb3J0IGdyYWRpZW50XG4gKi9cblxuXG5cbiAgICB2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKCcuL0Rpc3BsYXlhYmxlJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJy4uL2NvbnRhaW4vdGV4dCcpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9UZXh0XG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICovXG4gICAgdmFyIFRleHQgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIH07XG5cbiAgICBUZXh0LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogVGV4dCxcblxuICAgICAgICB0eXBlOiAndGV4dCcsXG5cbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciB4ID0gc3R5bGUueCB8fCAwO1xuICAgICAgICAgICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0O1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICAgICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcblxuICAgICAgICAgICAgLy8gQWx3YXlzIGJpbmQgc3R5bGVcbiAgICAgICAgICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuXG4gICAgICAgICAgICBpZiAodGV4dCkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbjtcbiAgICAgICAgICAgICAgICB2YXIgZm9udCA9IHN0eWxlLnRleHRGb250IHx8IHN0eWxlLmZvbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCwgZm9udCwgc3R5bGUudGV4dEFsaWduLCAndG9wJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGV4dEJhc2VsaW5lXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gcmVjdC5oZWlnaHQgLyAyIC0gcmVjdC5saW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSByZWN0LmhlaWdodCAtIHJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gcmVjdC5saW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gSW52YWxpZCBmb250XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250IHx8ICcxMnB4IHNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0ZXh0QWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgZGVmYXVsdCBsZWZ0IHRleHRBbGlnbi4gR2l2aW5nIGludmFsaWQgdmFsdWUgd2lsbCBjYXVzZSBzdGF0ZSBub3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgaWYgKGN0eC50ZXh0QWxpZ24gIT09IHRleHRBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBpbiB0ZXh0IGNvbnRhaW4gZGVmYXVsdCBpcyB0b3BcbiAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lIHx8ICdhbHBoYWJldGljJztcbiAgICAgICAgICAgICAgICAvLyBVc2UgY2FudmFzIGRlZmF1bHQgYWxwaGFiZXRpYyBiYXNlbGluZVxuICAgICAgICAgICAgICAgIGlmIChjdHgudGV4dEJhc2VsaW5lICE9PSB0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbGluZUhlaWdodCA9IHRleHRDb250YWluLm1lYXN1cmVUZXh0KCflm70nLCBjdHguZm9udCkud2lkdGg7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dExpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlsbCBhZnRlciBzdHJva2Ugc28gdGhlIG91dGxpbmUgd2lsbCBub3QgY292ZXIgdGhlIG1haW4gcGFydC5cbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaGFzU3Ryb2tlKCkgJiYgY3R4LnN0cm9rZVRleHQodGV4dExpbmVzW2ldLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaGFzRmlsbCgpICYmIGN0eC5maWxsVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB5ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ247XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnRleHQgKyAnJywgc3R5bGUudGV4dEZvbnQgfHwgc3R5bGUuZm9udCwgc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA/ICd0b3AnIDogc3R5bGUudGV4dEJhc2VsaW5lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnkgLT0gcmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnkgLT0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjdC54ICs9IHN0eWxlLnggfHwgMDtcbiAgICAgICAgICAgICAgICByZWN0LnkgKz0gc3R5bGUueSB8fCAwO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcmVjdC54IC09IHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICByZWN0LnkgLT0gdyAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Qud2lkdGggKz0gdztcbiAgICAgICAgICAgICAgICAgICAgcmVjdC5oZWlnaHQgKz0gdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhUZXh0LCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRleHQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1RleHQuanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDlnIblvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9DaXJjbGVcbiAqL1xuXG5cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2NpcmNsZScsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIGN4OiAwLFxuICAgICAgICAgICAgY3k6IDAsXG4gICAgICAgICAgICByOiAwXG4gICAgICAgIH0sXG5cblxuICAgICAgICBidWlsZFBhdGggOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSwgaW5CdW5kbGUpIHtcbiAgICAgICAgICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgICAgICAgICAgLy8gQWx3YXlzIGRvIGl0IG1heSBoYXZlIHBlcmZvcm1lbmNlIGlzc3VlICggZmlsbCBtYXkgYmUgMnggbW9yZSBjb3N0KVxuICAgICAgICAgICAgaWYgKGluQnVuZGxlKSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhzaGFwZS5jeCArIHNoYXBlLnIsIHNoYXBlLmN5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgICAgICAgICAgLy8gY3R4Lm1vdmVUbyhzaGFwZS5jeCArIHNoYXBlLnIsIHNoYXBlLmN5KTtcbiAgICAgICAgICAgIGN0eC5hcmMoc2hhcGUuY3gsIHNoYXBlLmN5LCBzaGFwZS5yLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDmiYflvaJcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1NlY3RvclxuICovXG5cblxuXG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZW52Jyk7XG4gICAgdmFyIFBhdGggPSByZXF1aXJlKCcuLi9QYXRoJyk7XG5cbiAgICB2YXIgc2hhZG93VGVtcCA9IFtcbiAgICAgICAgWydzaGFkb3dCbHVyJywgMF0sXG4gICAgICAgIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLFxuICAgICAgICBbJ3NoYWRvd09mZnNldFgnLCAwXSxcbiAgICAgICAgWydzaGFkb3dPZmZzZXRZJywgMF1cbiAgICBdO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXRoLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3NlY3RvcicsXG5cbiAgICAgICAgc2hhcGU6IHtcblxuICAgICAgICAgICAgY3g6IDAsXG5cbiAgICAgICAgICAgIGN5OiAwLFxuXG4gICAgICAgICAgICByMDogMCxcblxuICAgICAgICAgICAgcjogMCxcblxuICAgICAgICAgICAgc3RhcnRBbmdsZTogMCxcblxuICAgICAgICAgICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuXG4gICAgICAgICAgICBjbG9ja3dpc2U6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBicnVzaDogKGVudi5icm93c2VyLmllICYmIGVudi5icm93c2VyLnZlcnNpb24gPj0gMTEpIC8vIHZlcnNpb246ICcxMS4wJ1xuICAgICAgICAgICAgLy8gRml4IHdlaXJkIGJ1ZyBpbiBzb21lIHZlcnNpb24gb2YgSUUxMSAobGlrZSAxMS4wLjk2MDAuMTc4MDEpLFxuICAgICAgICAgICAgLy8gd2hlcmUgZXhjZXB0aW9uIFwidW5leHBlY3RlZCBjYWxsIHRvIG1ldGhvZCBvciBwcm9wZXJ0eSBhY2Nlc3NcIlxuICAgICAgICAgICAgLy8gbWlnaHQgYmUgdGhyb3duIHdoZW4gY2FsbGluZyBjdHguZmlsbCBhZnRlciBhIHBhdGggd2hvc2UgYXJlYSBzaXplXG4gICAgICAgICAgICAvLyBpcyB6ZXJvIGlzIGRyYXduIGFuZCBjdHguY2xpcCgpIGlzIGNhbGxlZCBhbmQgc2hhZG93Qmx1ciBpcyBzZXQuXG4gICAgICAgICAgICAvLyAoZS5nLixcbiAgICAgICAgICAgIC8vICBjdHgubW92ZVRvKDEwLCAxMCk7XG4gICAgICAgICAgICAvLyAgY3R4LmxpbmVUbygyMCwgMTApO1xuICAgICAgICAgICAgLy8gIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIC8vICBjdHguY2xpcCgpO1xuICAgICAgICAgICAgLy8gIGN0eC5zaGFkb3dCbHVyID0gMTA7XG4gICAgICAgICAgICAvLyAgLi4uXG4gICAgICAgICAgICAvLyAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIC8vIClcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjbGlwUGF0aHMgPSB0aGlzLl9fY2xpcFBhdGhzO1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gY2xpcFBhdGhzW2ldICYmIGNsaXBQYXRoc1tpXS5zaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5zdGFydEFuZ2xlID09PSBzaGFwZS5lbmRBbmdsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhZG93VGVtcC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dUZW1wW2pdWzJdID0gc3R5bGVbc2hhZG93VGVtcFtqXVswXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlW3NoYWRvd1RlbXBbal1bMF1dID0gc2hhZG93VGVtcFtqXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgUGF0aC5wcm90b3R5cGUuYnJ1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlW3NoYWRvd1RlbXBbal1bMF1dID0gc2hhZG93VGVtcFtqXVsyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogUGF0aC5wcm90b3R5cGUuYnJ1c2gsXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICAgICAgICAgIHZhciByMCA9IE1hdGgubWF4KHNoYXBlLnIwIHx8IDAsIDApO1xuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcbiAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcblxuICAgICAgICAgICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIwICsgeCwgdW5pdFkgKiByMCArIHkpO1xuXG4gICAgICAgICAgICBjdHgubGluZVRvKHVuaXRYICogciArIHgsIHVuaXRZICogciArIHkpO1xuXG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhY2xvY2t3aXNlKTtcblxuICAgICAgICAgICAgY3R4LmxpbmVUbyhcbiAgICAgICAgICAgICAgICBNYXRoLmNvcyhlbmRBbmdsZSkgKiByMCArIHgsXG4gICAgICAgICAgICAgICAgTWF0aC5zaW4oZW5kQW5nbGUpICogcjAgKyB5XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAocjAgIT09IDApIHtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHgsIHksIHIwLCBlbmRBbmdsZSwgc3RhcnRBbmdsZSwgY2xvY2t3aXNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogZWNoYXJ0c+iuvuWkh+eOr+Wig+ivhuWIq1xuICpcbiAqIEBkZXNjIGVjaGFydHPln7rkuo5DYW52YXPvvIznuq9KYXZhc2NyaXB05Zu+6KGo5bqT77yM5o+Q5L6b55u06KeC77yM55Sf5Yqo77yM5Y+v5Lqk5LqS77yM5Y+v5Liq5oCn5YyW5a6a5Yi255qE5pWw5o2u57uf6K6h5Zu+6KGo44CCXG4gKiBAYXV0aG9yIGZpcmVkZVtmaXJlZGVAZmlyZWRlLnVzXVxuICogQGRlc2MgdGhhbmtzIHplcHRvLlxuICovXG5cbiAgICB2YXIgZW52ID0ge307XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIEluIG5vZGVcbiAgICAgICAgZW52ID0ge1xuICAgICAgICAgICAgYnJvd3Nlcjoge30sXG4gICAgICAgICAgICBvczoge30sXG4gICAgICAgICAgICBub2RlOiB0cnVlLFxuICAgICAgICAgICAgLy8gQXNzdW1lIGNhbnZhcyBpcyBzdXBwb3J0ZWRcbiAgICAgICAgICAgIGNhbnZhc1N1cHBvcnRlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW52ID0gZGV0ZWN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZW52O1xuXG4gICAgLy8gWmVwdG8uanNcbiAgICAvLyAoYykgMjAxMC0yMDEzIFRob21hcyBGdWNoc1xuICAgIC8vIFplcHRvLmpzIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4gICAgZnVuY3Rpb24gZGV0ZWN0KHVhKSB7XG4gICAgICAgIHZhciBvcyA9IHt9O1xuICAgICAgICB2YXIgYnJvd3NlciA9IHt9O1xuICAgICAgICAvLyB2YXIgd2Via2l0ID0gdWEubWF0Y2goL1dlYltrS11pdFtcXC9dezAsMX0oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIGFuZHJvaWQgPSB1YS5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/Lyk7XG4gICAgICAgIC8vIHZhciBpcGFkID0gdWEubWF0Y2goLyhpUGFkKS4qT1NcXHMoW1xcZF9dKykvKTtcbiAgICAgICAgLy8gdmFyIGlwb2QgPSB1YS5tYXRjaCgvKGlQb2QpKC4qT1NcXHMoW1xcZF9dKykpPy8pO1xuICAgICAgICAvLyB2YXIgaXBob25lID0gIWlwYWQgJiYgdWEubWF0Y2goLyhpUGhvbmVcXHNPUylcXHMoW1xcZF9dKykvKTtcbiAgICAgICAgLy8gdmFyIHdlYm9zID0gdWEubWF0Y2goLyh3ZWJPU3xocHdPUylbXFxzXFwvXShbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgdG91Y2hwYWQgPSB3ZWJvcyAmJiB1YS5tYXRjaCgvVG91Y2hQYWQvKTtcbiAgICAgICAgLy8gdmFyIGtpbmRsZSA9IHVhLm1hdGNoKC9LaW5kbGVcXC8oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIHNpbGsgPSB1YS5tYXRjaCgvU2lsa1xcLyhbXFxkLl9dKykvKTtcbiAgICAgICAgLy8gdmFyIGJsYWNrYmVycnkgPSB1YS5tYXRjaCgvKEJsYWNrQmVycnkpLipWZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBiYjEwID0gdWEubWF0Y2goLyhCQjEwKS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgcmltdGFibGV0b3MgPSB1YS5tYXRjaCgvKFJJTVxcc1RhYmxldFxcc09TKVxccyhbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgcGxheWJvb2sgPSB1YS5tYXRjaCgvUGxheUJvb2svKTtcbiAgICAgICAgLy8gdmFyIGNocm9tZSA9IHVhLm1hdGNoKC9DaHJvbWVcXC8oW1xcZC5dKykvKSB8fCB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKTtcbiAgICAgICAgdmFyIGZpcmVmb3ggPSB1YS5tYXRjaCgvRmlyZWZveFxcLyhbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgc2FmYXJpID0gd2Via2l0ICYmIHVhLm1hdGNoKC9Nb2JpbGVcXC8vKSAmJiAhY2hyb21lO1xuICAgICAgICAvLyB2YXIgd2VidmlldyA9IHVhLm1hdGNoKC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpLykgJiYgIWNocm9tZTtcbiAgICAgICAgdmFyIGllID0gdWEubWF0Y2goL01TSUVcXHMoW1xcZC5dKykvKVxuICAgICAgICAgICAgLy8gSUUgMTEgVHJpZGVudC83LjA7IHJ2OjExLjBcbiAgICAgICAgICAgIHx8IHVhLm1hdGNoKC9UcmlkZW50XFwvLis/cnY6KChbXFxkLl0rKSkvKTtcbiAgICAgICAgdmFyIGVkZ2UgPSB1YS5tYXRjaCgvRWRnZVxcLyhbXFxkLl0rKS8pOyAvLyBJRSAxMiBhbmQgMTIrXG5cbiAgICAgICAgdmFyIHdlQ2hhdCA9ICgvbWljcm9tZXNzZW5nZXIvaSkudGVzdCh1YSk7XG5cbiAgICAgICAgLy8gVG9kbzogY2xlYW4gdGhpcyB1cCB3aXRoIGEgYmV0dGVyIE9TL2Jyb3dzZXIgc2VwZXJhdGlvbjpcbiAgICAgICAgLy8gLSBkaXNjZXJuIChtb3JlKSBiZXR3ZWVuIG11bHRpcGxlIGJyb3dzZXJzIG9uIGFuZHJvaWRcbiAgICAgICAgLy8gLSBkZWNpZGUgaWYga2luZGxlIGZpcmUgaW4gc2lsayBtb2RlIGlzIGFuZHJvaWQgb3Igbm90XG4gICAgICAgIC8vIC0gRmlyZWZveCBvbiBBbmRyb2lkIGRvZXNuJ3Qgc3BlY2lmeSB0aGUgQW5kcm9pZCB2ZXJzaW9uXG4gICAgICAgIC8vIC0gcG9zc2libHkgZGV2aWRlIGluIG9zLCBkZXZpY2UgYW5kIGJyb3dzZXIgaGFzaGVzXG5cbiAgICAgICAgLy8gaWYgKGJyb3dzZXIud2Via2l0ID0gISF3ZWJraXQpIGJyb3dzZXIudmVyc2lvbiA9IHdlYmtpdFsxXTtcblxuICAgICAgICAvLyBpZiAoYW5kcm9pZCkgb3MuYW5kcm9pZCA9IHRydWUsIG9zLnZlcnNpb24gPSBhbmRyb2lkWzJdO1xuICAgICAgICAvLyBpZiAoaXBob25lICYmICFpcG9kKSBvcy5pb3MgPSBvcy5pcGhvbmUgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBob25lWzJdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgICAgICAgLy8gaWYgKGlwYWQpIG9zLmlvcyA9IG9zLmlwYWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBhZFsyXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gICAgICAgIC8vIGlmIChpcG9kKSBvcy5pb3MgPSBvcy5pcG9kID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwb2RbM10gPyBpcG9kWzNdLnJlcGxhY2UoL18vZywgJy4nKSA6IG51bGw7XG4gICAgICAgIC8vIGlmICh3ZWJvcykgb3Mud2Vib3MgPSB0cnVlLCBvcy52ZXJzaW9uID0gd2Vib3NbMl07XG4gICAgICAgIC8vIGlmICh0b3VjaHBhZCkgb3MudG91Y2hwYWQgPSB0cnVlO1xuICAgICAgICAvLyBpZiAoYmxhY2tiZXJyeSkgb3MuYmxhY2tiZXJyeSA9IHRydWUsIG9zLnZlcnNpb24gPSBibGFja2JlcnJ5WzJdO1xuICAgICAgICAvLyBpZiAoYmIxMCkgb3MuYmIxMCA9IHRydWUsIG9zLnZlcnNpb24gPSBiYjEwWzJdO1xuICAgICAgICAvLyBpZiAocmltdGFibGV0b3MpIG9zLnJpbXRhYmxldG9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHJpbXRhYmxldG9zWzJdO1xuICAgICAgICAvLyBpZiAocGxheWJvb2spIGJyb3dzZXIucGxheWJvb2sgPSB0cnVlO1xuICAgICAgICAvLyBpZiAoa2luZGxlKSBvcy5raW5kbGUgPSB0cnVlLCBvcy52ZXJzaW9uID0ga2luZGxlWzFdO1xuICAgICAgICAvLyBpZiAoc2lsaykgYnJvd3Nlci5zaWxrID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gc2lsa1sxXTtcbiAgICAgICAgLy8gaWYgKCFzaWxrICYmIG9zLmFuZHJvaWQgJiYgdWEubWF0Y2goL0tpbmRsZSBGaXJlLykpIGJyb3dzZXIuc2lsayA9IHRydWU7XG4gICAgICAgIC8vIGlmIChjaHJvbWUpIGJyb3dzZXIuY2hyb21lID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gY2hyb21lWzFdO1xuICAgICAgICBpZiAoZmlyZWZveCkge1xuICAgICAgICAgICAgYnJvd3Nlci5maXJlZm94ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyb3dzZXIudmVyc2lvbiA9IGZpcmVmb3hbMV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgKHNhZmFyaSAmJiAodWEubWF0Y2goL1NhZmFyaS8pIHx8ICEhb3MuaW9zKSkgYnJvd3Nlci5zYWZhcmkgPSB0cnVlO1xuICAgICAgICAvLyBpZiAod2VidmlldykgYnJvd3Nlci53ZWJ2aWV3ID0gdHJ1ZTtcblxuICAgICAgICBpZiAoaWUpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuaWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uID0gaWVbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWRnZSkge1xuICAgICAgICAgICAgYnJvd3Nlci5lZGdlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyb3dzZXIudmVyc2lvbiA9IGVkZ2VbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJdCBpcyBkaWZmaWN1bHQgdG8gZGV0ZWN0IFdlQ2hhdCBpbiBXaW4gUGhvbmUgcHJlY2lzZWx5LCBiZWNhdXNlIHVhIGNhblxuICAgICAgICAvLyBub3QgYmUgc2V0IG9uIHdpbiBwaG9uZS4gU28gd2UgZG8gbm90IGNvbnNpZGVyIFdpbiBQaG9uZS5cbiAgICAgICAgaWYgKHdlQ2hhdCkge1xuICAgICAgICAgICAgYnJvd3Nlci53ZUNoYXQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3MudGFibGV0ID0gISEoaXBhZCB8fCBwbGF5Ym9vayB8fCAoYW5kcm9pZCAmJiAhdWEubWF0Y2goL01vYmlsZS8pKSB8fFxuICAgICAgICAvLyAgICAgKGZpcmVmb3ggJiYgdWEubWF0Y2goL1RhYmxldC8pKSB8fCAoaWUgJiYgIXVhLm1hdGNoKC9QaG9uZS8pICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSk7XG4gICAgICAgIC8vIG9zLnBob25lICA9ICEhKCFvcy50YWJsZXQgJiYgIW9zLmlwb2QgJiYgKGFuZHJvaWQgfHwgaXBob25lIHx8IHdlYm9zIHx8XG4gICAgICAgIC8vICAgICAoY2hyb21lICYmIHVhLm1hdGNoKC9BbmRyb2lkLykpIHx8IChjaHJvbWUgJiYgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLykpIHx8XG4gICAgICAgIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvTW9iaWxlLykpIHx8IChpZSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnJvd3NlcjogYnJvd3NlcixcbiAgICAgICAgICAgIG9zOiBvcyxcbiAgICAgICAgICAgIG5vZGU6IGZhbHNlLFxuICAgICAgICAgICAgLy8g5Y6f55SfY2FudmFz5pSv5oyB77yM5pS55p6B56uv54K55LqGXG4gICAgICAgICAgICAvLyBjYW52YXNTdXBwb3J0ZWQgOiAhKGJyb3dzZXIuaWUgJiYgcGFyc2VGbG9hdChicm93c2VyLnZlcnNpb24pIDwgOSlcbiAgICAgICAgICAgIGNhbnZhc1N1cHBvcnRlZCA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAvLyBAc2VlIDxodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ4MTcwMjkvd2hhdHMtdGhlLWJlc3Qtd2F5LXRvLWRldGVjdC1hLXRvdWNoLXNjcmVlbi1kZXZpY2UtdXNpbmctamF2YXNjcmlwdD5cbiAgICAgICAgICAgIC8vIHdvcmtzIG9uIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIElFMTAvMTEgZG9lcyBub3Qgc3VwcG9ydCB0b3VjaCBldmVudCwgYW5kIE1TIEVkZ2Ugc3VwcG9ydHMgdGhlbSBidXQgbm90IGJ5XG4gICAgICAgICAgICAvLyBkZWZhdWx0LCBzbyB3ZSBkb250IGNoZWNrIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyBmb3IgdGhlbSBoZXJlLlxuICAgICAgICAgICAgdG91Y2hFdmVudHNTdXBwb3J0ZWQ6ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiAhYnJvd3Nlci5pZSAmJiAhYnJvd3Nlci5lZGdlLFxuICAgICAgICAgICAgLy8gPGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXBvaW50ZXIlMjBldmVudD4uXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzU3VwcG9ydGVkOiAnb25wb2ludGVyZG93bicgaW4gd2luZG93XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzdXBwb3J0cyBwb2ludGVyIGJ1dCBub3QgYnkgZGVmYXVsdCwgb25seSBNUyBicm93c2VycyBhcmUgcmVsaWFibGUgb24gcG9pbnRlclxuICAgICAgICAgICAgICAgIC8vIGV2ZW50cyBjdXJyZW50bHkuIFNvIHdlIGRvbnQgdXNlIHRoYXQgb24gb3RoZXIgYnJvd3NlcnMgdW5sZXNzIHRlc3RlZCBzdWZmaWNpZW50bHkuXG4gICAgICAgICAgICAgICAgLy8gQWx0aG91Z2ggSUUgMTAgc3VwcG9ydHMgcG9pbnRlciBldmVudCwgaXQgdXNlIG9sZCBzdHlsZSBhbmQgaXMgZGlmZmVyZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmQuIFNvIHdlIGV4Y2x1ZGUgdGhhdC4gKElFIDEwIGlzIGhhcmRseSB1c2VkIG9uIHRvdWNoIGRldmljZSlcbiAgICAgICAgICAgICAgICAmJiAoYnJvd3Nlci5lZGdlIHx8IChicm93c2VyLmllICYmIGJyb3dzZXIudmVyc2lvbiA+PSAxMSkpXG4gICAgICAgIH07XG4gICAgfVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS9lbnYuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDlnIbnjq9cbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1JpbmdcbiAqL1xuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdyaW5nJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgICByMDogMFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgICAgICAgICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUuciwgeSk7XG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHNoYXBlLnIsIDAsIFBJMiwgZmFsc2UpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUucjAsIHkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yMCwgMCwgUEkyLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDlpJrovrnlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9Qb2x5Z29uXG4gKi9cblxuXG4gICAgdmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvcG9seScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcbiAgICAgICAgXG4gICAgICAgIHR5cGU6ICdwb2x5Z29uJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgcG9pbnRzOiBudWxsLFxuXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxuXG4gICAgICAgICAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIHZhciBzbW9vdGhTcGxpbmUgPSByZXF1aXJlKCcuL3Ntb290aFNwbGluZScpO1xuICAgIHZhciBzbW9vdGhCZXppZXIgPSByZXF1aXJlKCcuL3Ntb290aEJlemllcicpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUsIGNsb3NlUGF0aCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICAgICAgICAgIHZhciBzbW9vdGggPSBzaGFwZS5zbW9vdGg7XG4gICAgICAgICAgICBpZiAocG9pbnRzICYmIHBvaW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgIGlmIChzbW9vdGggJiYgc21vb3RoICE9PSAnc3BsaW5lJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbFBvaW50cyA9IHNtb290aEJlemllcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cywgc21vb3RoLCBjbG9zZVBhdGgsIHNoYXBlLnNtb290aENvbnN0cmFpbnRcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGNsb3NlUGF0aCA/IGxlbiA6IGxlbiAtIDEpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcDEgPSBjb250cm9sUG9pbnRzW2kgKiAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcDIgPSBjb250cm9sUG9pbnRzW2kgKiAyICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBvaW50c1soaSArIDEpICUgbGVuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwMVswXSwgY3AxWzFdLCBjcDJbMF0sIGNwMlsxXSwgcFswXSwgcFsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNtb290aCA9PT0gJ3NwbGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHNtb290aFNwbGluZShwb2ludHMsIGNsb3NlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBvaW50c1tpXVswXSwgcG9pbnRzW2ldWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNsb3NlUGF0aCAmJiBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENhdG11bGwtUm9tIHNwbGluZSDmj5LlgLzmipjnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aFNwbGluZVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3ZlY3RvcicpO1xuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mykge1xuICAgICAgICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG4gICAgICAgIHZhciB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgICAgICAgcmV0dXJuICgyICogKHAxIC0gcDIpICsgdjAgKyB2MSkgKiB0M1xuICAgICAgICAgICAgICAgICsgKC0zICogKHAxIC0gcDIpIC0gMiAqIHYwIC0gdjEpICogdDJcbiAgICAgICAgICAgICAgICArIHYwICogdCArIHAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9zaGFwZS91dGlsL3Ntb290aFNwbGluZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyDnur/mrrXpobbngrnmlbDnu4RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG9vcFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBvaW50cywgaXNMb29wKSB7XG4gICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdmVjMi5kaXN0YW5jZShwb2ludHNbaSAtIDFdLCBwb2ludHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlZ3MgPSBkaXN0YW5jZSAvIDI7XG4gICAgICAgIHNlZ3MgPSBzZWdzIDwgbGVuID8gbGVuIDogc2VncztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBpIC8gKHNlZ3MgLSAxKSAqIChpc0xvb3AgPyBsZW4gOiBsZW4gLSAxKTtcbiAgICAgICAgICAgIHZhciBpZHggPSBNYXRoLmZsb29yKHBvcyk7XG5cbiAgICAgICAgICAgIHZhciB3ID0gcG9zIC0gaWR4O1xuXG4gICAgICAgICAgICB2YXIgcDA7XG4gICAgICAgICAgICB2YXIgcDEgPSBwb2ludHNbaWR4ICUgbGVuXTtcbiAgICAgICAgICAgIHZhciBwMjtcbiAgICAgICAgICAgIHZhciBwMztcbiAgICAgICAgICAgIGlmICghaXNMb29wKSB7XG4gICAgICAgICAgICAgICAgcDAgPSBwb2ludHNbaWR4ID09PSAwID8gaWR4IDogaWR4IC0gMV07XG4gICAgICAgICAgICAgICAgcDIgPSBwb2ludHNbaWR4ID4gbGVuIC0gMiA/IGxlbiAtIDEgOiBpZHggKyAxXTtcbiAgICAgICAgICAgICAgICBwMyA9IHBvaW50c1tpZHggPiBsZW4gLSAzID8gbGVuIC0gMSA6IGlkeCArIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcDAgPSBwb2ludHNbKGlkeCAtIDEgKyBsZW4pICUgbGVuXTtcbiAgICAgICAgICAgICAgICBwMiA9IHBvaW50c1soaWR4ICsgMSkgJSBsZW5dO1xuICAgICAgICAgICAgICAgIHAzID0gcG9pbnRzWyhpZHggKyAyKSAlIGxlbl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB3MiA9IHcgKiB3O1xuICAgICAgICAgICAgdmFyIHczID0gdyAqIHcyO1xuXG4gICAgICAgICAgICByZXQucHVzaChbXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGUocDBbMF0sIHAxWzBdLCBwMlswXSwgcDNbMF0sIHcsIHcyLCB3MyksXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGUocDBbMV0sIHAxWzFdLCBwMlsxXSwgcDNbMV0sIHcsIHcyLCB3MylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICog6LSd5aGe5bCU5bmz5ruR5puy57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhCZXppZXJcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICogICAgICAgICBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciB2Mk1pbiA9IHZlYzIubWluO1xuICAgIHZhciB2Mk1heCA9IHZlYzIubWF4O1xuICAgIHZhciB2MlNjYWxlID0gdmVjMi5zY2FsZTtcbiAgICB2YXIgdjJEaXN0YW5jZSA9IHZlYzIuZGlzdGFuY2U7XG4gICAgdmFyIHYyQWRkID0gdmVjMi5hZGQ7XG5cbiAgICAvKipcbiAgICAgKiDotJ3loZ7lsJTlubPmu5Hmm7Lnur9cbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhCZXppZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMg57q/5q616aG254K55pWw57uEXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNtb290aCDlubPmu5HnrYnnuqcsIDAtMVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb29wXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29uc3RyYWludCDlsIborqHnrpflh7rmnaXnmoTmjqfliLbngrnnuqbmnZ/lnKjkuIDkuKrljIXlm7Tnm5LlhoVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOavlOWmgiBbWzAsIDBdLCBbMTAwLCAxMDBdXSwg6L+Z5Liq5YyF5Zu055uS5Lya5LiOXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICDmlbTkuKrmipjnur/nmoTljIXlm7Tnm5LlgZrkuIDkuKrlubbpm4bnlKjmnaXnuqbmnZ/mjqfliLbngrnjgIJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSDorqHnrpflh7rmnaXnmoTmjqfliLbngrnmlbDnu4RcbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2ludHMsIHNtb290aCwgaXNMb29wLCBjb25zdHJhaW50KSB7XG4gICAgICAgIHZhciBjcHMgPSBbXTtcblxuICAgICAgICB2YXIgdiA9IFtdO1xuICAgICAgICB2YXIgdjEgPSBbXTtcbiAgICAgICAgdmFyIHYyID0gW107XG4gICAgICAgIHZhciBwcmV2UG9pbnQ7XG4gICAgICAgIHZhciBuZXh0UG9pbnQ7XG5cbiAgICAgICAgdmFyIG1pbiwgbWF4O1xuICAgICAgICBpZiAoY29uc3RyYWludCkge1xuICAgICAgICAgICAgbWluID0gW0luZmluaXR5LCBJbmZpbml0eV07XG4gICAgICAgICAgICBtYXggPSBbLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHYyTWluKG1pbiwgbWluLCBwb2ludHNbaV0pO1xuICAgICAgICAgICAgICAgIHYyTWF4KG1heCwgbWF4LCBwb2ludHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8g5LiO5oyH5a6a55qE5YyF5Zu055uS5YGa5bm26ZuGXG4gICAgICAgICAgICB2Mk1pbihtaW4sIG1pbiwgY29uc3RyYWludFswXSk7XG4gICAgICAgICAgICB2Mk1heChtYXgsIG1heCwgY29uc3RyYWludFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICAgICAgICAgIGlmIChpc0xvb3ApIHtcbiAgICAgICAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludHNbaSA/IGkgLSAxIDogbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjcHMucHVzaCh2ZWMyLmNsb25lKHBvaW50c1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50c1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb2ludCA9IHBvaW50c1tpICsgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2ZWMyLnN1Yih2LCBuZXh0UG9pbnQsIHByZXZQb2ludCk7XG5cbiAgICAgICAgICAgIC8vIHVzZSBkZWdyZWUgdG8gc2NhbGUgdGhlIGhhbmRsZSBsZW5ndGhcbiAgICAgICAgICAgIHYyU2NhbGUodiwgdiwgc21vb3RoKTtcblxuICAgICAgICAgICAgdmFyIGQwID0gdjJEaXN0YW5jZShwb2ludCwgcHJldlBvaW50KTtcbiAgICAgICAgICAgIHZhciBkMSA9IHYyRGlzdGFuY2UocG9pbnQsIG5leHRQb2ludCk7XG4gICAgICAgICAgICB2YXIgc3VtID0gZDAgKyBkMTtcbiAgICAgICAgICAgIGlmIChzdW0gIT09IDApIHtcbiAgICAgICAgICAgICAgICBkMCAvPSBzdW07XG4gICAgICAgICAgICAgICAgZDEgLz0gc3VtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2MlNjYWxlKHYxLCB2LCAtZDApO1xuICAgICAgICAgICAgdjJTY2FsZSh2MiwgdiwgZDEpO1xuICAgICAgICAgICAgdmFyIGNwMCA9IHYyQWRkKFtdLCBwb2ludCwgdjEpO1xuICAgICAgICAgICAgdmFyIGNwMSA9IHYyQWRkKFtdLCBwb2ludCwgdjIpO1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgICAgICB2Mk1heChjcDAsIGNwMCwgbWluKTtcbiAgICAgICAgICAgICAgICB2Mk1pbihjcDAsIGNwMCwgbWF4KTtcbiAgICAgICAgICAgICAgICB2Mk1heChjcDEsIGNwMSwgbWluKTtcbiAgICAgICAgICAgICAgICB2Mk1pbihjcDEsIGNwMSwgbWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNwcy5wdXNoKGNwMCk7XG4gICAgICAgICAgICBjcHMucHVzaChjcDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTG9vcCkge1xuICAgICAgICAgICAgY3BzLnB1c2goY3BzLnNoaWZ0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNwcztcbiAgICB9O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhCZXppZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZVxuICovXG5cblxuICAgIHZhciBwb2x5SGVscGVyID0gcmVxdWlyZSgnLi4vaGVscGVyL3BvbHknKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG4gICAgICAgIFxuICAgICAgICB0eXBlOiAncG9seWxpbmUnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBwb2ludHM6IG51bGwsXG5cbiAgICAgICAgICAgIHNtb290aDogZmFsc2UsXG5cbiAgICAgICAgICAgIHNtb290aENvbnN0cmFpbnQ6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG5cbiAgICAgICAgICAgIGZpbGw6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICBwb2x5SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDnn6nlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1JlY3RcbiAqL1xuXG5cbiAgICB2YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZSgnLi4vaGVscGVyL3JvdW5kUmVjdCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAncmVjdCcsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIC8vIOW3puS4iuOAgeWPs+S4iuOAgeWPs+S4i+OAgeW3puS4i+inkueahOWNiuW+hOS+neasoeS4unIx44CBcjLjgIFyM+OAgXI0XG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6MSAgICAgICAgIOebuOW9k+S6jiBbMSwgMSwgMSwgMV1cbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLpbMV0gICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ulsxLCAyXSAgICDnm7jlvZPkuo4gWzEsIDIsIDEsIDJdXG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6WzEsIDIsIDNdIOebuOW9k+S6jiBbMSwgMiwgMywgMl1cbiAgICAgICAgICAgIHI6IDAsXG5cbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoIXNoYXBlLnIpIHtcbiAgICAgICAgICAgICAgICBjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdW5kUmVjdEhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgICAgICAgICAgIHZhciByID0gc2hhcGUucjtcbiAgICAgICAgICAgIHZhciByMTtcbiAgICAgICAgICAgIHZhciByMjtcbiAgICAgICAgICAgIHZhciByMztcbiAgICAgICAgICAgIHZhciByNDtcblxuICAgICAgICAgICAgLy8gQ29udmVydCB3aWR0aCBhbmQgaGVpZ2h0IHRvIHBvc2l0aXZlIGZvciBiZXR0ZXIgYm9yZGVyUmFkaXVzXG4gICAgICAgICAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICAgICAgeCA9IHggKyB3aWR0aDtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiByID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGlmIChyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IHJbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHIxID0gcjMgPSByWzBdO1xuICAgICAgICAgICAgICAgICAgICByMiA9IHI0ID0gclsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoci5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcjEgPSByWzBdO1xuICAgICAgICAgICAgICAgICAgICByMiA9IHI0ID0gclsxXTtcbiAgICAgICAgICAgICAgICAgICAgcjMgPSByWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcjEgPSByWzBdO1xuICAgICAgICAgICAgICAgICAgICByMiA9IHJbMV07XG4gICAgICAgICAgICAgICAgICAgIHIzID0gclsyXTtcbiAgICAgICAgICAgICAgICAgICAgcjQgPSByWzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvdGFsO1xuICAgICAgICAgICAgaWYgKHIxICsgcjIgPiB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gcjEgKyByMjtcbiAgICAgICAgICAgICAgICByMSAqPSB3aWR0aCAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIHIyICo9IHdpZHRoIC8gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocjMgKyByNCA+IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSByMyArIHI0O1xuICAgICAgICAgICAgICAgIHIzICo9IHdpZHRoIC8gdG90YWw7XG4gICAgICAgICAgICAgICAgcjQgKj0gd2lkdGggLyB0b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyMiArIHIzID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSByMiArIHIzO1xuICAgICAgICAgICAgICAgIHIyICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIHIzICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIxICsgcjQgPiBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHIxICsgcjQ7XG4gICAgICAgICAgICAgICAgcjEgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgICAgICAgICAgICAgcjQgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyByMSwgeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHIyLCB5KTtcbiAgICAgICAgICAgIHIyICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcjJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHIzKTtcbiAgICAgICAgICAgIHIzICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcjMsIHkgKyBoZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyByNCwgeSArIGhlaWdodCk7XG4gICAgICAgICAgICByNCAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcjRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkgKyByMSk7XG4gICAgICAgICAgICByMSAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcjEsIHkpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOebtOe6v1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvTGluZVxuICovXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdsaW5lJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgLy8gU3RhcnQgcG9pbnRcbiAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgeTE6IDAsXG4gICAgICAgICAgICAvLyBFbmQgcG9pbnRcbiAgICAgICAgICAgIHgyOiAwLFxuICAgICAgICAgICAgeTI6IDAsXG5cbiAgICAgICAgICAgIHBlcmNlbnQ6IDFcbiAgICAgICAgfSxcblxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHgxID0gc2hhcGUueDE7XG4gICAgICAgICAgICB2YXIgeTEgPSBzaGFwZS55MTtcbiAgICAgICAgICAgIHZhciB4MiA9IHNoYXBlLngyO1xuICAgICAgICAgICAgdmFyIHkyID0gc2hhcGUueTI7XG4gICAgICAgICAgICB2YXIgcGVyY2VudCA9IHNoYXBlLnBlcmNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChwZXJjZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG5cbiAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICAgICAgICAgIHgyID0geDEgKiAoMSAtIHBlcmNlbnQpICsgeDIgKiBwZXJjZW50O1xuICAgICAgICAgICAgICAgIHkyID0geTEgKiAoMSAtIHBlcmNlbnQpICsgeTIgKiBwZXJjZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcG9pbnQgYXQgcGVyY2VudFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBwb2ludEF0OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgc2hhcGUueDEgKiAoMSAtIHApICsgc2hhcGUueDIgKiBwLFxuICAgICAgICAgICAgICAgIHNoYXBlLnkxICogKDEgLSBwKSArIHNoYXBlLnkyICogcFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDotJ3loZ7lsJTmm7Lnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9CZXppZXJDdXJ2ZVxuICovXG5cblxuICAgIHZhciBjdXJ2ZVRvb2wgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2N1cnZlJyk7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciBxdWFkcmF0aWNTdWJkaXZpZGUgPSBjdXJ2ZVRvb2wucXVhZHJhdGljU3ViZGl2aWRlO1xuICAgIHZhciBjdWJpY1N1YmRpdmlkZSA9IGN1cnZlVG9vbC5jdWJpY1N1YmRpdmlkZTtcbiAgICB2YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZVRvb2wucXVhZHJhdGljQXQ7XG4gICAgdmFyIGN1YmljQXQgPSBjdXJ2ZVRvb2wuY3ViaWNBdDtcbiAgICB2YXIgcXVhZHJhdGljRGVyaXZhdGl2ZUF0ID0gY3VydmVUb29sLnF1YWRyYXRpY0Rlcml2YXRpdmVBdDtcbiAgICB2YXIgY3ViaWNEZXJpdmF0aXZlQXQgPSBjdXJ2ZVRvb2wuY3ViaWNEZXJpdmF0aXZlQXQ7XG5cbiAgICB2YXIgb3V0ID0gW107XG5cbiAgICBmdW5jdGlvbiBzb21lVmVjdG9yQXQoc2hhcGUsIHQsIGlzVGFuZ2VudCkge1xuICAgICAgICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gICAgICAgIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcbiAgICAgICAgaWYgKGNweDIgPT09IG51bGwgfHwgY3B5MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUuY3B4Miwgc2hhcGUueDIsIHQpLFxuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBjdWJpY0Rlcml2YXRpdmVBdCA6IGN1YmljQXQpKHNoYXBlLnkxLCBzaGFwZS5jcHkxLCBzaGFwZS5jcHkyLCBzaGFwZS55MiwgdClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLngyLCB0KSxcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gcXVhZHJhdGljRGVyaXZhdGl2ZUF0IDogcXVhZHJhdGljQXQpKHNoYXBlLnkxLCBzaGFwZS5jcHkxLCBzaGFwZS55MiwgdClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnYmV6aWVyLWN1cnZlJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgeDE6IDAsXG4gICAgICAgICAgICB5MTogMCxcbiAgICAgICAgICAgIHgyOiAwLFxuICAgICAgICAgICAgeTI6IDAsXG4gICAgICAgICAgICBjcHgxOiAwLFxuICAgICAgICAgICAgY3B5MTogMCxcbiAgICAgICAgICAgIC8vIGNweDI6IDAsXG4gICAgICAgICAgICAvLyBjcHkyOiAwXG5cbiAgICAgICAgICAgIC8vIEN1cnZlIHNob3cgcGVyY2VudCwgZm9yIGFuaW1hdGluZ1xuICAgICAgICAgICAgcGVyY2VudDogMVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcbiAgICAgICAgICAgIGZpbGw6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeDEgPSBzaGFwZS54MTtcbiAgICAgICAgICAgIHZhciB5MSA9IHNoYXBlLnkxO1xuICAgICAgICAgICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgICAgICAgICB2YXIgeTIgPSBzaGFwZS55MjtcbiAgICAgICAgICAgIHZhciBjcHgxID0gc2hhcGUuY3B4MTtcbiAgICAgICAgICAgIHZhciBjcHkxID0gc2hhcGUuY3B5MTtcbiAgICAgICAgICAgIHZhciBjcHgyID0gc2hhcGUuY3B4MjtcbiAgICAgICAgICAgIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcbiAgICAgICAgICAgIGlmIChwZXJjZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG5cbiAgICAgICAgICAgIGlmIChjcHgyID09IG51bGwgfHwgY3B5MiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxLCBjcHgxLCB4MiwgcGVyY2VudCwgb3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNweDEgPSBvdXRbMV07XG4gICAgICAgICAgICAgICAgICAgIHgyID0gb3V0WzJdO1xuICAgICAgICAgICAgICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB5MSwgY3B5MSwgeTIsIHBlcmNlbnQsIG91dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjcHkxID0gb3V0WzFdO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IG91dFsyXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgY3B4MSwgY3B5MSxcbiAgICAgICAgICAgICAgICAgICAgeDIsIHkyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBjdWJpY1N1YmRpdmlkZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxLCBjcHgxLCBjcHgyLCB4MiwgcGVyY2VudCwgb3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNweDEgPSBvdXRbMV07XG4gICAgICAgICAgICAgICAgICAgIGNweDIgPSBvdXRbMl07XG4gICAgICAgICAgICAgICAgICAgIHgyID0gb3V0WzNdO1xuICAgICAgICAgICAgICAgICAgICBjdWJpY1N1YmRpdmlkZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxLCBjcHkxLCBjcHkyLCB5MiwgcGVyY2VudCwgb3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgICAgICAgICAgICAgIGNweTIgPSBvdXRbMl07XG4gICAgICAgICAgICAgICAgICAgIHkyID0gb3V0WzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgY3B4MSwgY3B5MSxcbiAgICAgICAgICAgICAgICAgICAgY3B4MiwgY3B5MixcbiAgICAgICAgICAgICAgICAgICAgeDIsIHkyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRBdDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBzb21lVmVjdG9yQXQodGhpcy5zaGFwZSwgdCwgZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGFuZ2VudCBhdCBwZXJjZW50XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHRhbmdlbnRBdDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBwID0gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZlYzIubm9ybWFsaXplKHAsIHApO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDlnIblvKdcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL0FyY1xuICovXG4gXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdhcmMnLFxuXG4gICAgICAgIHNoYXBlOiB7XG5cbiAgICAgICAgICAgIGN4OiAwLFxuXG4gICAgICAgICAgICBjeTogMCxcblxuICAgICAgICAgICAgcjogMCxcblxuICAgICAgICAgICAgc3RhcnRBbmdsZTogMCxcblxuICAgICAgICAgICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuXG4gICAgICAgICAgICBjbG9ja3dpc2U6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBzdHlsZToge1xuXG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcblxuICAgICAgICAgICAgZmlsbDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcblxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgICAgICAgICB2YXIgciA9IE1hdGgubWF4KHNoYXBlLnIsIDApO1xuICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xuICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gc2hhcGUuZW5kQW5nbGU7XG4gICAgICAgICAgICB2YXIgY2xvY2t3aXNlID0gc2hhcGUuY2xvY2t3aXNlO1xuXG4gICAgICAgICAgICB2YXIgdW5pdFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICAgICAgICAgIHZhciB1bml0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuXG4gICAgICAgICAgICBjdHgubW92ZVRvKHVuaXRYICogciArIHgsIHVuaXRZICogciArIHkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjLmpzXG4gKiogbW9kdWxlIGlkID0gNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIEdyYWRpZW50ID0gcmVxdWlyZSgnLi9HcmFkaWVudCcpO1xuXG4gICAgLyoqXG4gICAgICogeCwgeSwgeDIsIHkyIGFyZSBhbGwgcGVyY2VudCBmcm9tIDAgdG8gMVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeDI9MV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3kyPTBdXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gY29sb3JTdG9wc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbENvb3JkPWZhbHNlXVxuICAgICAqL1xuICAgIHZhciBMaW5lYXJHcmFkaWVudCA9IGZ1bmN0aW9uICh4LCB5LCB4MiwgeTIsIGNvbG9yU3RvcHMsIGdsb2JhbENvb3JkKSB7XG4gICAgICAgIHRoaXMueCA9IHggPT0gbnVsbCA/IDAgOiB4O1xuXG4gICAgICAgIHRoaXMueSA9IHkgPT0gbnVsbCA/IDAgOiB5O1xuXG4gICAgICAgIHRoaXMueDIgPSB4MiA9PSBudWxsID8gMSA6IHgyO1xuXG4gICAgICAgIHRoaXMueTIgPSB5MiA9PSBudWxsID8gMCA6IHkyO1xuXG4gICAgICAgIC8vIENhbiBiZSBjbG9uZWRcbiAgICAgICAgdGhpcy50eXBlID0gJ2xpbmVhcic7XG5cbiAgICAgICAgLy8gSWYgdXNlIGdsb2JhbCBjb29yZFxuICAgICAgICB0aGlzLmdsb2JhbCA9IGdsb2JhbENvb3JkIHx8IGZhbHNlO1xuXG4gICAgICAgIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG4gICAgfTtcblxuICAgIExpbmVhckdyYWRpZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogTGluZWFyR3JhZGllbnRcbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKExpbmVhckdyYWRpZW50LCBHcmFkaWVudCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExpbmVhckdyYWRpZW50O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJy4vR3JhZGllbnQnKTtcblxuICAgIC8qKlxuICAgICAqIHgsIHksIHIgYXJlIGFsbCBwZXJjZW50IGZyb20gMCB0byAxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTAuNV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MC41XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcj0wLjVdXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW2NvbG9yU3RvcHNdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZ2xvYmFsQ29vcmQ9ZmFsc2VdXG4gICAgICovXG4gICAgdmFyIFJhZGlhbEdyYWRpZW50ID0gZnVuY3Rpb24gKHgsIHksIHIsIGNvbG9yU3RvcHMsIGdsb2JhbENvb3JkKSB7XG4gICAgICAgIHRoaXMueCA9IHggPT0gbnVsbCA/IDAuNSA6IHg7XG5cbiAgICAgICAgdGhpcy55ID0geSA9PSBudWxsID8gMC41IDogeTtcblxuICAgICAgICB0aGlzLnIgPSByID09IG51bGwgPyAwLjUgOiByO1xuXG4gICAgICAgIC8vIENhbiBiZSBjbG9uZWRcbiAgICAgICAgdGhpcy50eXBlID0gJ3JhZGlhbCc7XG5cbiAgICAgICAgLy8gSWYgdXNlIGdsb2JhbCBjb29yZFxuICAgICAgICB0aGlzLmdsb2JhbCA9IGdsb2JhbENvb3JkIHx8IGZhbHNlO1xuXG4gICAgICAgIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG4gICAgfTtcblxuICAgIFJhZGlhbEdyYWRpZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogUmFkaWFsR3JhZGllbnRcbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKFJhZGlhbEdyYWRpZW50LCBHcmFkaWVudCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJhZGlhbEdyYWRpZW50O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblxyXG4gICAgdmFyIGFwaUxpc3QgPSBbXHJcbiAgICAgICAgJ2dldERvbScsICdnZXRacicsICdnZXRXaWR0aCcsICdnZXRIZWlnaHQnLCAnZGlzcGF0Y2hBY3Rpb24nLFxyXG4gICAgICAgICdvbicsICdvZmYnLCAndHJpZ2dlcicsICdnZXREYXRhVVJMJywgJ2dldENvbm5lY3RlZERhdGFVUkwnLCAnZ2V0TW9kZWwnLCAnZ2V0T3B0aW9uJ1xyXG4gICAgXTtcclxuXHJcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25BUEkoaW5zdGFuY2UpIHtcclxuICAgICAgICB6clV0aWwuZWFjaChhcGlMaXN0LCBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzW25hbWVdID0genJVdGlsLmJpbmQoaW5zdGFuY2VbbmFtZV0sIGluc3RhbmNlKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV4dGVuc2lvbkFQSTtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL0V4dGVuc2lvbkFwaS5qc1xuICoqIG1vZHVsZSBpZCA9IDU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuXHJcbiAgICAvKipcclxuICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFBvaW50XHJcbiAgICAgICpcclxuICAgICAgKlxyXG4gICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAqIEB0aGlzIHtQb2ludH1cclxuICAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIG9mIHBvaW50LlxyXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgb2YgcG9pbnQuXHJcbiAgICAgICogTm90ZTogRXZlbiBpZiBpdCBpcyBuYW1lZCBQb2ludCB0aGlzIGNsYXNzIHNob3VsZCBiZSBuYW1lZCBEb3QgYXMgRG90IGlzIGNsb3NlclxyXG4gICAgICAqIHRoZW4gUG9pbnQgZnJvbSBtYXRoIHBlcnNwZWN0aXZlLlxyXG4gICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIFBvaW50KHgsIHkpe1xyXG4gICAgICAgIC8qKlRoZSB4IGNvb3JkaW5hdGUgb2YgcG9pbnQqL1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLyoqVGhlIHkgY29vcmRpbmF0ZSBvZiBwb2ludCovXHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICBcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqQ3JlYXRlcyBhIHtQb2ludH0gb3V0IG9mIEpTT04gcGFyc2VkIG9iamVjdFxyXG4gICAgICpAcGFyYW0ge0pTT05PYmplY3R9IG8gLSB0aGUgSlNPTiBwYXJzZWQgb2JqZWN0XHJcbiAgICAgKkByZXR1cm4ge1BvaW50fSBhIG5ld2x5IGNvbnN0cnVjdGVkIFBvaW50XHJcbiAgICAgKiovXHJcbiAgICBQb2ludC5sb2FkID0gZnVuY3Rpb24obyl7XHJcbiAgICAgICAgdmFyIG5ld1BvaW50ID0gbmV3IFBvaW50KE51bWJlcihvLngpLCBOdW1iZXIoby55KSk7XHJcbiAgICAgICAgcmV0dXJuIG5ld1BvaW50O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqQ3JlYXRlcyBhbiBhcnJheSBvZiBwb2ludHMgZnJvbSBhbiBhcnJheSBvZiB7SlNPTk9iamVjdH1zXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSB0aGUgYXJyYXkgb2YgSlNPTk9iamVjdHNcclxuICAgICAqQHJldHVybiBhbiB7QXJyYXl9IG9mIHtQb2ludH1zXHJcbiAgICAgKiovXHJcbiAgICBQb2ludC5sb2FkQXJyYXkgPSBmdW5jdGlvbih2KXtcclxuICAgICAgICB2YXIgbmV3UG9pbnRzID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8IHYubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBuZXdQb2ludHMucHVzaChQb2ludC5sb2FkKHZbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld1BvaW50cztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKkNsb25lcyBhbiBhcnJheSBvZiBwb2ludHNcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIHRoZSBhcnJheSBvZiB7UG9pbnR9c1xyXG4gICAgICpAcmV0dXJuIGFuIHtBcnJheX0gb2Yge1BvaW50fXNcclxuICAgICAqKi9cclxuICAgIFBvaW50LmNsb25lQXJyYXkgPSBmdW5jdGlvbih2KXtcclxuICAgICAgICB2YXIgbmV3UG9pbnRzID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8IHYubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBuZXdQb2ludHMucHVzaCh2W2ldLmNsb25lKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3UG9pbnRzO1xyXG4gICAgfTtcclxuXHJcbiAgICBQb2ludC5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IgOiBQb2ludCxcclxuICAgICAgICBcclxuICAgICAgICB0cmFuc2Zvcm06ZnVuY3Rpb24obWF0cml4KXtcclxuICAgICAgICAgICAgdmFyIG9sZFggPSB0aGlzLng7XHJcbiAgICAgICAgICAgIHZhciBvbGRZID0gdGhpcy55O1xyXG4gICAgICAgICAgICB0aGlzLnggPSBtYXRyaXhbMF1bMF0gKiBvbGRYICsgbWF0cml4WzBdWzFdICogb2xkWSArIG1hdHJpeFswXVsyXTtcclxuICAgICAgICAgICAgdGhpcy55ID0gbWF0cml4WzFdWzBdICogb2xkWCArIG1hdHJpeFsxXVsxXSAqIG9sZFkgKyBtYXRyaXhbMV1bMl07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICAvKipUZXN0cyBpZiB0aGlzIHBvaW50IGlzIHNpbWlsYXIgdG8gb3RoZXIgcG9pbnRcclxuICAgICAgICAgKkBwYXJhbSB7UG9pbnR9IGFub3RoZXJQb2ludCAtIHRoZSBvdGhlciBwb2ludFxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBlcXVhbHM6ZnVuY3Rpb24oYW5vdGhlclBvaW50KXtcclxuICAgICAgICAgICAgaWYoISAoYW5vdGhlclBvaW50IGluc3RhbmNlb2YgUG9pbnQpICl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnggPT0gYW5vdGhlclBvaW50LngpXHJcbiAgICAgICAgICAgICYmICh0aGlzLnkgPT0gYW5vdGhlclBvaW50LnkpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqQ2xvbmUgY3VycmVudCBQb2ludFxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIG5ld1BvaW50ID0gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1BvaW50O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlRlc3RzIHRvIHNlZSBpZiBhIHBvaW50ICh4LCB5KSBpcyB3aXRoaW4gYSByYW5nZSBvZiBjdXJyZW50IFBvaW50XHJcbiAgICAgICAgICpAcGFyYW0ge051bWVyaWN9IHggLSB0aGUgeCBjb29yZGluYXRlIG9mIHRlc3RlZCBwb2ludFxyXG4gICAgICAgICAqQHBhcmFtIHtOdW1lcmljfSB5IC0gdGhlIHggY29vcmRpbmF0ZSBvZiB0ZXN0ZWQgcG9pbnRcclxuICAgICAgICAgKkBwYXJhbSB7TnVtZXJpY30gcmFkaXVzIC0gdGhlIHJhZGl1cyBvZiB0aGUgdmljaW5pdHlcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgbmVhcjpmdW5jdGlvbih4LCB5LCByYWRpdXMpe1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy54IC0geCwgMikgKyBNYXRoLnBvdyh0aGlzLnkgLSB5LCAyKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKGRpc3RhbmNlIDw9IHJhZGl1cyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uKHgseSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggPT0geCAmJiB0aGlzLnkgPT0geTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0b1N0cmluZzpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gJ1snICsgdGhpcy54ICsgJywnICsgdGhpcy55ICsgJ10nO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldFBvaW50czpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gW3RoaXNdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xyXG4gICAgXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvUG9pbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiBaUmVuZGVyLCBhIGhpZ2ggcGVyZm9ybWFuY2UgMmQgZHJhd2luZyBsaWJyYXJ5LlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMywgQmFpZHUgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZWNvbWZlL3pyZW5kZXIvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcbiAqL1xuLy8gR2xvYmFsIGRlZmluZXNcblxuICAgIHZhciBndWlkID0gcmVxdWlyZSgnLi9jb3JlL2d1aWQnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi9jb3JlL2VudicpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIEhhbmRsZXIgPSByZXF1aXJlKCcuL0hhbmRsZXInKTtcbiAgICB2YXIgU3RvcmFnZSA9IHJlcXVpcmUoJy4vU3RvcmFnZScpO1xuICAgIHZhciBBbmltYXRpb24gPSByZXF1aXJlKCcuL2FuaW1hdGlvbi9BbmltYXRpb24nKTtcbiAgICB2YXIgSGFuZGxlclByb3h5ID0gcmVxdWlyZSgnLi9kb20vSGFuZGxlclByb3h5Jyk7XG5cbiAgICB2YXIgdXNlVk1MID0gIWVudi5jYW52YXNTdXBwb3J0ZWQ7XG5cbiAgICB2YXIgcGFpbnRlckN0b3JzID0ge1xuICAgICAgICBjYW52YXM6IHJlcXVpcmUoJy4vUGFpbnRlcicpXG4gICAgfTtcblxuICAgIHZhciBpbnN0YW5jZXMgPSB7fTsgICAgLy8gWlJlbmRlcuWunuS+i21hcOe0ouW8lVxuXG4gICAgdmFyIHpyZW5kZXIgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgenJlbmRlci52ZXJzaW9uID0gJzMuNC4xJztcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemluZyBhIHpyZW5kZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2ZydcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpb11cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLmhlaWdodF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAgICAgKi9cbiAgICB6cmVuZGVyLmluaXQgPSBmdW5jdGlvbihkb20sIG9wdHMpIHtcbiAgICAgICAgdmFyIHpyID0gbmV3IFpSZW5kZXIoZ3VpZCgpLCBkb20sIG9wdHMpO1xuICAgICAgICBpbnN0YW5jZXNbenIuaWRdID0genI7XG4gICAgICAgIHJldHVybiB6cjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzcG9zZSB6cmVuZGVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgICAqL1xuICAgIHpyZW5kZXIuZGlzcG9zZSA9IGZ1bmN0aW9uICh6cikge1xuICAgICAgICBpZiAoenIpIHtcbiAgICAgICAgICAgIHpyLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzW2tleV0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHpyZW5kZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB6cmVuZGVyIGluc3RhbmNlIGJ5IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHpyZW5kZXIgaW5zdGFuY2UgaWRcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgICAqL1xuICAgIHpyZW5kZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlc1tpZF07XG4gICAgfTtcblxuICAgIHpyZW5kZXIucmVnaXN0ZXJQYWludGVyID0gZnVuY3Rpb24gKG5hbWUsIEN0b3IpIHtcbiAgICAgICAgcGFpbnRlckN0b3JzW25hbWVdID0gQ3RvcjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZGVsSW5zdGFuY2UoaWQpIHtcbiAgICAgICAgZGVsZXRlIGluc3RhbmNlc1tpZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSB6cmVuZGVyL1pSZW5kZXJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvWlJlbmRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7SFRNTERvbUVsZW1lbnR9IGRvbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnJlbmRlcmVyPSdjYW52YXMnXSAnY2FudmFzJyBvciAnc3ZnJ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmhlaWdodF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICovXG4gICAgdmFyIFpSZW5kZXIgPSBmdW5jdGlvbihpZCwgZG9tLCBvcHRzKSB7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRG9tRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpO1xuXG4gICAgICAgIHZhciByZW5kZXJlclR5cGUgPSBvcHRzLnJlbmRlcmVyO1xuICAgICAgICAvLyBUT0RPIFdlYkdMXG4gICAgICAgIGlmICh1c2VWTUwpIHtcbiAgICAgICAgICAgIGlmICghcGFpbnRlckN0b3JzLnZtbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcmVxdWlyZSBcXCd6cmVuZGVyL3ZtbC92bWxcXCcgdG8gc3VwcG9ydCBJRTgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9ICd2bWwnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFyZW5kZXJlclR5cGUgfHwgIXBhaW50ZXJDdG9yc1tyZW5kZXJlclR5cGVdKSB7XG4gICAgICAgICAgICByZW5kZXJlclR5cGUgPSAnY2FudmFzJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFpbnRlciA9IG5ldyBwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXShkb20sIHN0b3JhZ2UsIG9wdHMpO1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG5cbiAgICAgICAgdmFyIGhhbmRlclByb3h5ID0gIWVudi5ub2RlID8gbmV3IEhhbmRsZXJQcm94eShwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKSA6IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IG5ldyBIYW5kbGVyKHN0b3JhZ2UsIHBhaW50ZXIsIGhhbmRlclByb3h5LCBwYWludGVyLnJvb3QpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih7XG4gICAgICAgICAgICBzdGFnZToge1xuICAgICAgICAgICAgICAgIHVwZGF0ZTogenJVdGlsLmJpbmQodGhpcy5mbHVzaCwgdGhpcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLnN0YXJ0KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoO1xuXG4gICAgICAgIC8vIOS/ruaUuSBzdG9yYWdlLmRlbEZyb21NYXAsIOavj+asoeWIoOmZpOWFg+e0oOS5i+WJjeWIoOmZpOWKqOeUu1xuICAgICAgICAvLyBGSVhNRSDmnInngrl1Z2x5XG4gICAgICAgIHZhciBvbGREZWxGcm9tTWFwID0gc3RvcmFnZS5kZWxGcm9tTWFwO1xuICAgICAgICB2YXIgb2xkQWRkVG9NYXAgPSBzdG9yYWdlLmFkZFRvTWFwO1xuXG4gICAgICAgIHN0b3JhZ2UuZGVsRnJvbU1hcCA9IGZ1bmN0aW9uIChlbElkKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBzdG9yYWdlLmdldChlbElkKTtcblxuICAgICAgICAgICAgb2xkRGVsRnJvbU1hcC5jYWxsKHN0b3JhZ2UsIGVsSWQpO1xuXG4gICAgICAgICAgICBlbCAmJiBlbC5yZW1vdmVTZWxmRnJvbVpyKHNlbGYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0b3JhZ2UuYWRkVG9NYXAgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIG9sZEFkZFRvTWFwLmNhbGwoc3RvcmFnZSwgZWwpO1xuXG4gICAgICAgICAgICBlbC5hZGRTZWxmVG9acihzZWxmKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgWlJlbmRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFpSZW5kZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5blrp7kvovllK/kuIDmoIfor4ZcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlhYPntKBcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuYWRkUm9vdChlbCk7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTlhYPntKBcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZGVsUm9vdChlbCk7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2UgY29uZmlndXJhdGlvbiBvZiBsYXllclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gekxldmVsXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSBDbGVhciBjb2xvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5tb3Rpb25CbHVyPWZhbHNlXSBJZiBlbmFibGUgbW90aW9uIGJsdXJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubGFzdEZyYW1lQWxwaGE9MC43XSBNb3Rpb24gYmx1ciBmYWN0b3IuIExhcmdlciB2YWx1ZSBjYXVzZSBsb25nZXIgdHJhaWxlclxuICAgICAgICAqL1xuICAgICAgICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpMZXZlbCwgY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIuY29uZmlnTGF5ZXIoekxldmVsLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVwYWludCB0aGUgY2FudmFzIGltbWVkaWF0ZWx5XG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoSW1tZWRpYXRlbHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIG5lZWRzUmVmcmVzaCBhaGVhZCB0byBhdm9pZCBzb21ldGhpbmcgd3JvbmcgaGFwcGVucyBpbiByZWZyZXNoXG4gICAgICAgICAgICAvLyBPciBpdCB3aWxsIGNhdXNlIHpyZW5kZXIgcmVmcmVzaGVzIGFnYWluIGFuZCBhZ2Fpbi5cbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXZvaWQgdHJpZ2dlciB6ci5yZWZyZXNoIGluIEVsZW1lbnQjYmVmb3JlVXBkYXRlIGhvb2tcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmsgYW5kIHJlcGFpbnQgdGhlIGNhbnZhcyBpbiB0aGUgbmV4dCBmcmFtZSBvZiBicm93c2VyXG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm0gYWxsIHJlZnJlc2hcbiAgICAgICAgICovXG4gICAgICAgIGZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbmVlZHNSZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSW1tZWRpYXRlbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2hIb3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVySW1tZWRpYXRlbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGVsZW1lbnQgdG8gaG92ZXIgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICAgICAqL1xuICAgICAgICBhZGRIb3ZlcjogZnVuY3Rpb24gKGVsLCBzdHlsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFpbnRlci5hZGRIb3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRlci5hZGRIb3ZlcihlbCwgc3R5bGUpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBlbGVtZW50IGZyb20gaG92ZXIgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIoZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFyIGFsbCBob3ZlciBlbGVtZW50cyBpbiBob3ZlciBsYXllclxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXJIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFpbnRlci5jbGVhckhvdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyLmNsZWFySG92ZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZyZXNoIGhvdmVyIGluIG5leHQgZnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2hIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZyZXNoIGhvdmVyIGltbWVkaWF0ZWx5XG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoSG92ZXJJbW1lZGlhdGVseTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5yZWZyZXNoSG92ZXIgJiYgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNpemUgdGhlIGNhbnZhcy5cbiAgICAgICAgICogU2hvdWxkIGJlIGludm9rZWQgd2hlbiBjb250YWluZXIgc2l6ZSBpcyBjaGFuZ2VkXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24ob3B0cykge1xuICAgICAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIucmVzaXplKG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5yZXNpemUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcCBhbmQgY2xlYXIgYWxsIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXJBbmltYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmNsZWFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjb250YWluZXIgd2lkdGhcbiAgICAgICAgICovXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGNvbnRhaW5lciBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldEhlaWdodCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBvcnQgdGhlIGNhbnZhcyBhcyBCYXNlNjQgVVJMXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYmFja2dyb3VuZENvbG9yPScjZmZmJ11cbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBCYXNlNjQgVVJMXG4gICAgICAgICAqL1xuICAgICAgICAvLyB0b0RhdGFVUkw6IGZ1bmN0aW9uKHR5cGUsIGJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAvLyAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRSZW5kZXJlZENhbnZhcyh7XG4gICAgICAgIC8vICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgLy8gICAgIH0pLnRvRGF0YVVSTCh0eXBlKTtcbiAgICAgICAgLy8gfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydGluZyBhIHBhdGggdG8gaW1hZ2UuXG4gICAgICAgICAqIEl0IGhhcyBtdWNoIGJldHRlciBwZXJmb3JtYW5jZSBvZiBkcmF3aW5nIGltYWdlIHJhdGhlciB0aGFuIGRyYXdpbmcgYSB2ZWN0b3IgcGF0aC5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHBhdGhUb0ltYWdlOiBmdW5jdGlvbihlLCBkcHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhaW50ZXIucGF0aFRvSW1hZ2UoZSwgZHByKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGRlZmF1bHQgY3Vyc29yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3R5bGU9J2RlZmF1bHQnXSDkvovlpoIgY3Jvc3NoYWlyXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDdXJzb3JTdHlsZTogZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIuc2V0Q3Vyc29yU3R5bGUoY3Vyc29yU3R5bGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudEhhbmRsZXIgSGFuZGxlciBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5vbihldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgY29udGV4dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuYmluZCBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2V2ZW50SGFuZGxlcl0gSGFuZGxlciBmdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgb2ZmOiBmdW5jdGlvbihldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLm9mZihldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWdnZXIgZXZlbnQgbWFudWFsbHlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7ZXZlbnQ9fSBldmVudCBFdmVudCBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhciBhbGwgb2JqZWN0cyBhbmQgdGhlIGNhbnZhcy5cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZGVsUm9vdCgpO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLmNsZWFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3Bvc2Ugc2VsZi5cbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLnN0b3AoKTtcblxuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbiA9XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPVxuICAgICAgICAgICAgdGhpcy5wYWludGVyID1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciA9IG51bGw7XG5cbiAgICAgICAgICAgIGRlbEluc3RhbmNlKHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0genJlbmRlcjtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvenJlbmRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEhhbmRsZXJcbiAqIEBtb2R1bGUgenJlbmRlci9IYW5kbGVyXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoc2hlbnlpLjkxNEBnbWFpbC5jb20pXG4gKi9cblxuXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuICAgIHZhciBEcmFnZ2FibGUgPSByZXF1aXJlKCcuL21peGluL0RyYWdnYWJsZScpO1xuXG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi9taXhpbi9FdmVudGZ1bCcpO1xuXG4gICAgZnVuY3Rpb24gbWFrZUV2ZW50UGFja2V0KGV2ZVR5cGUsIHRhcmdldCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGV2ZVR5cGUsXG4gICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIGNhbmNlbEJ1YmJsZTogZmFsc2UsXG4gICAgICAgICAgICBvZmZzZXRYOiBldmVudC56clgsXG4gICAgICAgICAgICBvZmZzZXRZOiBldmVudC56clksXG4gICAgICAgICAgICBnZXN0dXJlRXZlbnQ6IGV2ZW50Lmdlc3R1cmVFdmVudCxcbiAgICAgICAgICAgIHBpbmNoWDogZXZlbnQucGluY2hYLFxuICAgICAgICAgICAgcGluY2hZOiBldmVudC5waW5jaFksXG4gICAgICAgICAgICBwaW5jaFNjYWxlOiBldmVudC5waW5jaFNjYWxlLFxuICAgICAgICAgICAgd2hlZWxEZWx0YTogZXZlbnQuenJEZWx0YSxcbiAgICAgICAgICAgIHpyQnlUb3VjaDogZXZlbnQuenJCeVRvdWNoXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRW1wdHlQcm94eSAoKSB7fVxuICAgIEVtcHR5UHJveHkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHZhciBoYW5kbGVyTmFtZXMgPSBbXG4gICAgICAgICdjbGljaycsICdkYmxjbGljaycsICdtb3VzZXdoZWVsJywgJ21vdXNlb3V0JyxcbiAgICAgICAgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdjb250ZXh0bWVudSdcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9IYW5kbGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2UgU3RvcmFnZSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXIgUGFpbnRlciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2RvbS9IYW5kbGVyUHJveHl9IHByb3h5IEhhbmRsZXJQcm94eSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYWludGVyUm9vdCBwYWludGVyLnJvb3QgKG5vdCBwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKS5cbiAgICAgKi9cbiAgICB2YXIgSGFuZGxlciA9IGZ1bmN0aW9uKHN0b3JhZ2UsIHBhaW50ZXIsIHByb3h5LCBwYWludGVyUm9vdCkge1xuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG5cbiAgICAgICAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcblxuICAgICAgICB0aGlzLnBhaW50ZXJSb290ID0gcGFpbnRlclJvb3Q7XG5cbiAgICAgICAgcHJveHkgPSBwcm94eSB8fCBuZXcgRW1wdHlQcm94eSgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm94eSBvZiBldmVudC4gY2FuIGJlIERvbSwgV2ViR0xTdXJmYWNlLCBldGMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3h5ID0gcHJveHk7XG5cbiAgICAgICAgLy8gQXR0YWNoIGhhbmRsZXJcbiAgICAgICAgcHJveHkuaGFuZGxlciA9IHRoaXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faG92ZXJlZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0RhdGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXN0VG91Y2hNb21lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXN0WDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xhc3RZO1xuXG5cbiAgICAgICAgRHJhZ2dhYmxlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdXRpbC5lYWNoKGhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHByb3h5Lm9uICYmIHByb3h5Lm9uKG5hbWUsIHRoaXNbbmFtZV0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gICAgSGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEhhbmRsZXIsXG5cbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB4ID0gZXZlbnQuenJYO1xuICAgICAgICAgICAgdmFyIHkgPSBldmVudC56clk7XG5cbiAgICAgICAgICAgIHZhciBob3ZlcmVkID0gdGhpcy5maW5kSG92ZXIoeCwgeSwgbnVsbCk7XG4gICAgICAgICAgICB2YXIgbGFzdEhvdmVyZWQgPSB0aGlzLl9ob3ZlcmVkO1xuICAgICAgICAgICAgdmFyIHByb3h5ID0gdGhpcy5wcm94eTtcblxuICAgICAgICAgICAgdGhpcy5faG92ZXJlZCA9IGhvdmVyZWQ7XG5cbiAgICAgICAgICAgIHByb3h5LnNldEN1cnNvciAmJiBwcm94eS5zZXRDdXJzb3IoaG92ZXJlZCA/IGhvdmVyZWQuY3Vyc29yIDogJ2RlZmF1bHQnKTtcblxuICAgICAgICAgICAgLy8gTW91c2Ugb3V0IG9uIHByZXZpb3VzIGhvdmVyZWQgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGxhc3RIb3ZlcmVkICYmIGhvdmVyZWQgIT09IGxhc3RIb3ZlcmVkICYmIGxhc3RIb3ZlcmVkLl9fenIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGxhc3RIb3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1vdXNlIG1vdmluZyBvbiBvbmUgZWxlbWVudFxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCAnbW91c2Vtb3ZlJywgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBvdmVyIG9uIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChob3ZlcmVkICYmIGhvdmVyZWQgIT09IGxhc3RIb3ZlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCAnbW91c2VvdmVyJywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQodGhpcy5faG92ZXJlZCwgJ21vdXNlb3V0JywgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBUaGVyZSBtaWdodCBiZSBzb21lIGRvbXMgY3JlYXRlZCBieSB1cHBlciBsYXllciBhcHBsaWNhdGlvblxuICAgICAgICAgICAgLy8gYXQgdGhlIHNhbWUgbGV2ZWwgb2YgcGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSAoZS5nLiwgdG9vbHRpcFxuICAgICAgICAgICAgLy8gZG9tIGNyZWF0ZWQgYnkgZWNoYXJ0cyksIHdoZXJlICdnbG9iYWxvdXQnIGV2ZW50IHNob3VsZCBub3RcbiAgICAgICAgICAgIC8vIGJlIHRyaWdnZXJlZCB3aGVuIG1vdXNlIGVudGVycyB0aGVzZSBkb21zLiAoQnV0ICdtb3VzZW91dCdcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSB0cmlnZ2VyZWQgYXQgdGhlIG9yaWdpbmFsIGhvdmVyZWQgZWxlbWVudCBhcyB1c3VhbCkuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGlubmVyRG9tO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgIT0gOSAmJiAhKFxuICAgICAgICAgICAgICAgIGlubmVyRG9tID0gZWxlbWVudCA9PT0gdGhpcy5wYWludGVyUm9vdFxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgICFpbm5lckRvbSAmJiB0aGlzLnRyaWdnZXIoJ2dsb2JhbG91dCcsIHtldmVudDogZXZlbnR9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzaXplXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5faG92ZXJlZCA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BhdGNoIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICAgICAgICogQHBhcmFtIHtldmVudD19IGV2ZW50QXJnc1xuICAgICAgICAgKi9cbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJncykge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICBoYW5kbGVyICYmIGhhbmRsZXIuY2FsbCh0aGlzLCBldmVudEFyZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHRoaXMucHJveHkuZGlzcG9zZSgpO1xuXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPVxuICAgICAgICAgICAgdGhpcy5wcm94eSA9XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7pu5jorqTnmoRjdXJzb3Igc3R5bGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JTdHlsZT0nZGVmYXVsdCddIOS+i+WmgiBjcm9zc2hhaXJcbiAgICAgICAgICovXG4gICAgICAgIHNldEN1cnNvclN0eWxlOiBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICAgICAgICAgIHZhciBwcm94eSA9IHRoaXMucHJveHk7XG4gICAgICAgICAgICBwcm94eS5zZXRDdXJzb3IgJiYgcHJveHkuc2V0Q3Vyc29yKGN1cnNvclN0eWxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5LqL5Lu25YiG5Y+R5Luj55CGXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRFbCDnm67moIflm77lvaLlhYPntKBcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSDkuovku7blkI3np7BcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcGF0Y2hUb0VsZW1lbnQ6IGZ1bmN0aW9uICh0YXJnZXRFbCwgZXZlbnROYW1lLCBldmVudCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9ICdvbicgKyBldmVudE5hbWU7XG4gICAgICAgICAgICB2YXIgZXZlbnRQYWNrZXQgPSBtYWtlRXZlbnRQYWNrZXQoZXZlbnROYW1lLCB0YXJnZXRFbCwgZXZlbnQpO1xuXG4gICAgICAgICAgICB2YXIgZWwgPSB0YXJnZXRFbDtcblxuICAgICAgICAgICAgd2hpbGUgKGVsKSB7XG4gICAgICAgICAgICAgICAgZWxbZXZlbnRIYW5kbGVyXVxuICAgICAgICAgICAgICAgICAgICAmJiAoZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlID0gZWxbZXZlbnRIYW5kbGVyXS5jYWxsKGVsLCBldmVudFBhY2tldCkpO1xuXG4gICAgICAgICAgICAgICAgZWwudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcblxuICAgICAgICAgICAgICAgIGVsID0gZWwucGFyZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAgICAgICAgICAgLy8g5YaS5rOh5Yiw6aG257qnIHpyZW5kZXIg5a+56LGhXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuICAgICAgICAgICAgICAgIC8vIOWIhuWPkeS6i+S7tuWIsOeUqOaIt+iHquWumuS5ieWxglxuICAgICAgICAgICAgICAgIC8vIOeUqOaIt+acieWPr+iDveWcqOWFqOWxgCBjbGljayDkuovku7bkuK0gZGlzcG9zZe+8jOaJgOS7pemcgOimgeWIpOaWreS4iyBwYWludGVyIOaYr+WQpuWtmOWcqFxuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRlciAmJiB0aGlzLnBhaW50ZXIuZWFjaE90aGVyTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YobGF5ZXJbZXZlbnRIYW5kbGVyXSkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJbZXZlbnRIYW5kbGVyXS5jYWxsKGxheWVyLCBldmVudFBhY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyLnRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlfSBleGNsdWRlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICovXG4gICAgICAgIGZpbmRIb3ZlcjogZnVuY3Rpb24oeCwgeSwgZXhjbHVkZSkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMCA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmICghbGlzdFtpXS5zaWxlbnRcbiAgICAgICAgICAgICAgICAgJiYgbGlzdFtpXSAhPT0gZXhjbHVkZVxuICAgICAgICAgICAgICAgICAvLyBnZXREaXNwbGF5TGlzdCBtYXkgaW5jbHVkZSBpZ25vcmVkIGl0ZW0gaW4gVk1MIG1vZGVcbiAgICAgICAgICAgICAgICAgJiYgIWxpc3RbaV0uaWdub3JlXG4gICAgICAgICAgICAgICAgICYmIGlzSG92ZXIobGlzdFtpXSwgeCwgeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIENvbW1vbiBoYW5kbGVyc1xuICAgIHV0aWwuZWFjaChbJ2NsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNld2hlZWwnLCAnZGJsY2xpY2snLCAnY29udGV4dG1lbnUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgSGFuZGxlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgaG92ZXIgYWdhaW4gdG8gYXZvaWQgY2xpY2sgZXZlbnQgaXMgZGlzcGF0Y2hlZCBtYW51YWxseS4gT3IgY2xpY2sgaXMgdHJpZ2dlcmVkIHdpdGhvdXQgbW91c2VvdmVyXG4gICAgICAgICAgICB2YXIgaG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKGV2ZW50LnpyWCwgZXZlbnQuenJZLCBudWxsKTtcblxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG93bmVsID0gaG92ZXJlZDtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIGNsaWNrIHRyaWdnZXJlZCBiZWZvcmUgbW91c2V1cFxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZWwgPSBob3ZlcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ21vc3VldXAnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBlbCA9IGhvdmVyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Rvd25lbCAhPT0gdGhpcy5fdXBlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsIG5hbWUsIGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGlzSG92ZXIoZGlzcGxheWFibGUsIHgsIHkpIHtcbiAgICAgICAgaWYgKGRpc3BsYXlhYmxlW2Rpc3BsYXlhYmxlLnJlY3RIb3ZlciA/ICdyZWN0Q29udGFpbicgOiAnY29udGFpbiddKHgsIHkpKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBkaXNwbGF5YWJsZTtcbiAgICAgICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGFuY2VzdG9yIGlzIHNpbGVudCBvciBjbGlwcGVkIGJ5IGFuY2VzdG9yXG4gICAgICAgICAgICAgICAgaWYgKGVsLnNpbGVudCB8fCAoZWwuY2xpcFBhdGggJiYgIWVsLmNsaXBQYXRoLmNvbnRhaW4oeCwgeSkpKSAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsID0gZWwucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdXRpbC5taXhpbihIYW5kbGVyLCBFdmVudGZ1bCk7XG4gICAgdXRpbC5taXhpbihIYW5kbGVyLCBEcmFnZ2FibGUpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBIYW5kbGVyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvSGFuZGxlci5qc1xuICoqIG1vZHVsZSBpZCA9IDYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIFN0b3JhZ2XlhoXlrrnku5PlupPmqKHlnZdcbiAqIEBtb2R1bGUgenJlbmRlci9TdG9yYWdlXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqIEBhdXRob3IgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly9naXRodWIuY29tL3Bpc3NhbmcvKVxuICovXG5cblxuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi9jb3JlL2VudicpO1xuXG4gICAgdmFyIEdyb3VwID0gcmVxdWlyZSgnLi9jb250YWluZXIvR3JvdXAnKTtcblxuICAgIC8vIFVzZSB0aW1zb3J0IGJlY2F1c2UgaW4gbW9zdCBjYXNlIGVsZW1lbnRzIGFyZSBwYXJ0aWFsbHkgc29ydGVkXG4gICAgLy8gaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvcGlzc2FuZy9qcjR4N21kbS84L1xuICAgIHZhciB0aW1zb3J0ID0gcmVxdWlyZSgnLi9jb3JlL3RpbXNvcnQnKTtcblxuICAgIGZ1bmN0aW9uIHNoYXBlQ29tcGFyZUZ1bmMoYSwgYikge1xuICAgICAgICBpZiAoYS56bGV2ZWwgPT09IGIuemxldmVsKSB7XG4gICAgICAgICAgICBpZiAoYS56ID09PSBiLnopIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAoYS56MiA9PT0gYi56Mikge1xuICAgICAgICAgICAgICAgIC8vICAgICAvLyBGSVhNRSBTbG93IGhhcyByZW5kZXJpZHggY29tcGFyZVxuICAgICAgICAgICAgICAgIC8vICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwODgzNDIxL3NvcnRpbmctaW4tamF2YXNjcmlwdC1zaG91bGQtZXZlcnktY29tcGFyZS1mdW5jdGlvbi1oYXZlLWEtcmV0dXJuLTAtc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgLy8gICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92OC92OC9ibG9iLzQ3Y2NlNTQ0YTMxZWQ1NTc3ZmZlMjk2M2Y2N2FjYjQxNDRlZTAyMzIvc3JjL2pzL2FycmF5LmpzI0wxMDEyXG4gICAgICAgICAgICAgICAgLy8gICAgIHJldHVybiBhLl9fcmVuZGVyaWR4IC0gYi5fX3JlbmRlcmlkeDtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuejIgLSBiLnoyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGEueiAtIGIuejtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS56bGV2ZWwgLSBiLnpsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5YaF5a655LuT5bqTIChNKVxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9TdG9yYWdlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIOaJgOacieW4uOinhOW9oueKtu+8jGlk57Si5byV55qEbWFwXG4gICAgICAgIHRoaXMuX2VsZW1lbnRzID0ge307XG5cbiAgICAgICAgdGhpcy5fcm9vdHMgPSBbXTtcblxuICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdCA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICB9O1xuXG4gICAgU3RvcmFnZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFN0b3JhZ2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RzW2ldLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6L+U5Zue5omA5pyJ5Zu+5b2i55qE57uY5Yi26Zif5YiXXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZT1mYWxzZV0g5piv5ZCm5Zyo6L+U5Zue5YmN5pu05paw6K+l5pWw57uEXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uELCDlnKggdXBkYXRlIOS4uiB0cnVlIOeahOaXtuWAmeacieaViFxuICAgICAgICAgKlxuICAgICAgICAgKiDor6bop4F7QGxpbmsgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5wcm90b3R5cGUudXBkYXRlRGlzcGxheUxpc3R9XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldERpc3BsYXlMaXN0OiBmdW5jdGlvbiAodXBkYXRlLCBpbmNsdWRlSWdub3JlKSB7XG4gICAgICAgICAgICBpbmNsdWRlSWdub3JlID0gaW5jbHVkZUlnbm9yZSB8fCBmYWxzZTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXlMaXN0KGluY2x1ZGVJZ25vcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXlMaXN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmm7TmlrDlm77lvaLnmoTnu5jliLbpmJ/liJfjgIJcbiAgICAgICAgICog5q+P5qyh57uY5Yi25YmN6YO95Lya6LCD55So77yM6K+l5pa55rOV5Lya5YWI5rex5bqm5LyY5YWI6YGN5Y6G5pW05Liq5qCR77yM5pu05paw5omA5pyJR3JvdXDlkoxTaGFwZeeahOWPmOaNouW5tuS4lOaKiuaJgOacieWPr+ingeeahFNoYXBl5L+d5a2Y5Yiw5pWw57uE5Lit77yMXG4gICAgICAgICAqIOacgOWQjuagueaNrue7mOWItueahOS8mOWFiOe6p++8iHpsZXZlbCA+IHogPiDmj5LlhaXpobrluo/vvInmjpLluo/lvpfliLDnu5jliLbpmJ/liJdcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUlnbm9yZT1mYWxzZV0g5piv5ZCm5YyF5ZCrIGlnbm9yZSDnmoTmlbDnu4RcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZURpc3BsYXlMaXN0OiBmdW5jdGlvbiAoaW5jbHVkZUlnbm9yZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuICAgICAgICAgICAgdmFyIHJvb3RzID0gdGhpcy5fcm9vdHM7XG4gICAgICAgICAgICB2YXIgZGlzcGxheUxpc3QgPSB0aGlzLl9kaXNwbGF5TGlzdDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb290cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlKHJvb3RzW2ldLCBudWxsLCBpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BsYXlMaXN0Lmxlbmd0aCA9IHRoaXMuX2Rpc3BsYXlMaXN0TGVuO1xuXG4gICAgICAgICAgICAvLyBmb3IgKHZhciBpID0gMCwgbGVuID0gZGlzcGxheUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIC8vICAgICBkaXNwbGF5TGlzdFtpXS5fX3JlbmRlcmlkeCA9IGk7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIC8vIGRpc3BsYXlMaXN0LnNvcnQoc2hhcGVDb21wYXJlRnVuYyk7XG4gICAgICAgICAgICBlbnYuY2FudmFzU3VwcG9ydGVkICYmIHRpbXNvcnQoZGlzcGxheUxpc3QsIHNoYXBlQ29tcGFyZUZ1bmMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVBbmRBZGREaXNwbGF5YWJsZTogZnVuY3Rpb24gKGVsLCBjbGlwUGF0aHMsIGluY2x1ZGVJZ25vcmUpIHtcblxuICAgICAgICAgICAgaWYgKGVsLmlnbm9yZSAmJiAhaW5jbHVkZUlnbm9yZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWwuYmVmb3JlVXBkYXRlKCk7XG5cbiAgICAgICAgICAgIGlmIChlbC5fX2RpcnR5KSB7XG5cbiAgICAgICAgICAgICAgICBlbC51cGRhdGUoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbC5hZnRlclVwZGF0ZSgpO1xuXG4gICAgICAgICAgICB2YXIgdXNlclNldENsaXBQYXRoID0gZWwuY2xpcFBhdGg7XG4gICAgICAgICAgICBpZiAodXNlclNldENsaXBQYXRoKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSDmlYjnjoflvbHlk41cbiAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRocyA9IGNsaXBQYXRocy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcFBhdGhzID0gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDbGlwUGF0aCA9IHVzZXJTZXRDbGlwUGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Q2xpcFBhdGggPSBlbDtcbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBhZGQgY2xpcCBwYXRoXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRDbGlwUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjbGlwUGF0aCDnmoTlj5jmjaLmmK/ln7rkuo7kvb/nlKjov5nkuKogY2xpcFBhdGgg55qE5YWD57SgXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDbGlwUGF0aC5wYXJlbnQgPSBwYXJlbnRDbGlwUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENsaXBQYXRoLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRocy5wdXNoKGN1cnJlbnRDbGlwUGF0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q2xpcFBhdGggPSBjdXJyZW50Q2xpcFBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDbGlwUGF0aCA9IGN1cnJlbnRDbGlwUGF0aC5jbGlwUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbC5pc0dyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwuX2NoaWxkcmVuO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGb3JjZSB0byBtYXJrIGFzIGRpcnR5IGlmIGdyb3VwIGlzIGRpcnR5XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIF9fZGlydHlQYXRoID9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQW5kQWRkRGlzcGxheWFibGUoY2hpbGQsIGNsaXBQYXRocywgaW5jbHVkZUlnbm9yZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWFyayBncm91cCBjbGVhbiBoZXJlXG4gICAgICAgICAgICAgICAgZWwuX19kaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbC5fX2NsaXBQYXRocyA9IGNsaXBQYXRocztcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0W3RoaXMuX2Rpc3BsYXlMaXN0TGVuKytdID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWbvuW9oihTaGFwZSnmiJbogIXnu4QoR3JvdXAp5Yiw5qC56IqC54K5XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICovXG4gICAgICAgIGFkZFJvb3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgLy8gRWxlbWVudCBoYXMgYmVlbiBhZGRlZFxuICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRzW2VsLmlkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICBlbC5hZGRDaGlsZHJlblRvU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hZGRUb01hcChlbCk7XG4gICAgICAgICAgICB0aGlzLl9yb290cy5wdXNoKGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5oyH5a6a55qE5Zu+5b2iKFNoYXBlKeaIluiAhee7hChHcm91cClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtlbElkXSDlpoLmnpzkuLrnqbrmuIXnqbrmlbTkuKpTdG9yYWdlXG4gICAgICAgICAqL1xuICAgICAgICBkZWxSb290OiBmdW5jdGlvbiAoZWxJZCkge1xuICAgICAgICAgICAgaWYgKGVsSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIOS4jeaMh+WummVsSWTmuIXnqbpcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5fcm9vdHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290IGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRzID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdHMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsSWQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWxJZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxSb290KGVsSWRbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoZWxJZCkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBlbCA9IHRoaXMuX2VsZW1lbnRzW2VsSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwgPSBlbElkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKHRoaXMuX3Jvb3RzLCBlbCk7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbEZyb21NYXAoZWwuaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2UodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFRvTWFwOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgZWwuX19zdG9yYWdlID0gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsLmRpcnR5KGZhbHNlKTtcblxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudHNbZWwuaWRdID0gZWw7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKGVsSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50c1tlbElkXTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxGcm9tTWFwOiBmdW5jdGlvbiAoZWxJZCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5fZWxlbWVudHM7XG4gICAgICAgICAgICB2YXIgZWwgPSBlbGVtZW50c1tlbElkXTtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50c1tlbElkXTtcbiAgICAgICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5fX3N0b3JhZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4heepuuW5tuS4lOmHiuaUvlN0b3JhZ2VcbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRzID1cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckxpc3QgPVxuICAgICAgICAgICAgdGhpcy5fcm9vdHMgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3BsYXlhYmxlU29ydEZ1bmM6IHNoYXBlQ29tcGFyZUZ1bmNcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTdG9yYWdlO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9TdG9yYWdlLmpzXG4gKiogbW9kdWxlIGlkID0gNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9temljY2FyZC9ub2RlLXRpbXNvcnRcblxuICAgIHZhciBERUZBVUxUX01JTl9NRVJHRSA9IDMyO1xuXG4gICAgdmFyIERFRkFVTFRfTUlOX0dBTExPUElORyA9IDc7XG5cbiAgICB2YXIgREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEggPSAyNTY7XG5cbiAgICBmdW5jdGlvbiBtaW5SdW5MZW5ndGgobikge1xuICAgICAgICB2YXIgciA9IDA7XG5cbiAgICAgICAgd2hpbGUgKG4gPj0gREVGQVVMVF9NSU5fTUVSR0UpIHtcbiAgICAgICAgICAgIHIgfD0gbiAmIDE7XG4gICAgICAgICAgICBuID4+PSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG4gKyByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSkge1xuICAgICAgICB2YXIgcnVuSGkgPSBsbyArIDE7XG5cbiAgICAgICAgaWYgKHJ1bkhpID09PSBoaSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGFyZShhcnJheVtydW5IaSsrXSwgYXJyYXlbbG9dKSA8IDApIHtcbiAgICAgICAgICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA8IDApIHtcbiAgICAgICAgICAgICAgICBydW5IaSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXZlcnNlUnVuKGFycmF5LCBsbywgcnVuSGkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pID49IDApIHtcbiAgICAgICAgICAgICAgICBydW5IaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJ1bkhpIC0gbG87XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV2ZXJzZVJ1bihhcnJheSwgbG8sIGhpKSB7XG4gICAgICAgIGhpLS07XG5cbiAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICAgIHZhciB0ID0gYXJyYXlbbG9dO1xuICAgICAgICAgICAgYXJyYXlbbG8rK10gPSBhcnJheVtoaV07XG4gICAgICAgICAgICBhcnJheVtoaS0tXSA9IHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgaGksIHN0YXJ0LCBjb21wYXJlKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gbG8pIHtcbiAgICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgc3RhcnQgPCBoaTsgc3RhcnQrKykge1xuICAgICAgICAgICAgdmFyIHBpdm90ID0gYXJyYXlbc3RhcnRdO1xuXG4gICAgICAgICAgICB2YXIgbGVmdCA9IGxvO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gc3RhcnQ7XG4gICAgICAgICAgICB2YXIgbWlkO1xuXG4gICAgICAgICAgICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgbWlkID0gbGVmdCArIHJpZ2h0ID4+PiAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUocGl2b3QsIGFycmF5W21pZF0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IG1pZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG4gPSBzdGFydCAtIGxlZnQ7XG5cbiAgICAgICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIDNdID0gYXJyYXlbbGVmdCArIDJdO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBhcnJheVtsZWZ0ICsgMl0gPSBhcnJheVtsZWZ0ICsgMV07XG5cbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2xlZnQgKyAxXSA9IGFycmF5W2xlZnRdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2xlZnQgKyBuXSA9IGFycmF5W2xlZnQgKyBuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJyYXlbbGVmdF0gPSBwaXZvdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdhbGxvcExlZnQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gICAgICAgIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG1heE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSAxO1xuXG4gICAgICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA+IDApIHtcbiAgICAgICAgICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0T2Zmc2V0ICs9IGhpbnQ7XG4gICAgICAgICAgICBvZmZzZXQgKz0gaGludDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRtcCA9IGxhc3RPZmZzZXQ7XG4gICAgICAgICAgICBsYXN0T2Zmc2V0ID0gaGludCAtIG9mZnNldDtcbiAgICAgICAgICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0T2Zmc2V0Kys7XG4gICAgICAgIHdoaWxlIChsYXN0T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICAgICAgICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIG1dKSA+IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2FsbG9wUmlnaHQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gICAgICAgIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG1heE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSAxO1xuXG4gICAgICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA8IDApIHtcbiAgICAgICAgICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuXG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCAtIG9mZnNldF0pIDwgMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRtcCA9IGxhc3RPZmZzZXQ7XG4gICAgICAgICAgICBsYXN0T2Zmc2V0ID0gaGludCAtIG9mZnNldDtcbiAgICAgICAgICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXhPZmZzZXQgPSBsZW5ndGggLSBoaW50O1xuXG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCArIG9mZnNldF0pID49IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RPZmZzZXQgKz0gaGludDtcbiAgICAgICAgICAgIG9mZnNldCArPSBoaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdE9mZnNldCsrO1xuXG4gICAgICAgIHdoaWxlIChsYXN0T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICAgICAgICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIG1dKSA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBUaW1Tb3J0KGFycmF5LCBjb21wYXJlKSB7XG4gICAgICAgIHZhciBtaW5HYWxsb3AgPSBERUZBVUxUX01JTl9HQUxMT1BJTkc7XG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgICB2YXIgdG1wU3RvcmFnZUxlbmd0aCA9IERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIO1xuICAgICAgICB2YXIgc3RhY2tMZW5ndGggPSAwO1xuICAgICAgICB2YXIgcnVuU3RhcnQ7XG4gICAgICAgIHZhciBydW5MZW5ndGg7XG4gICAgICAgIHZhciBzdGFja1NpemUgPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMiAqIERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIKSB7XG4gICAgICAgICAgICB0bXBTdG9yYWdlTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRtcCA9IFtdO1xuXG4gICAgICAgIHN0YWNrTGVuZ3RoID0gbGVuZ3RoIDwgMTIwID8gNSA6IGxlbmd0aCA8IDE1NDIgPyAxMCA6IGxlbmd0aCA8IDExOTE1MSA/IDE5IDogNDA7XG5cbiAgICAgICAgcnVuU3RhcnQgPSBbXTtcbiAgICAgICAgcnVuTGVuZ3RoID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gcHVzaFJ1bihfcnVuU3RhcnQsIF9ydW5MZW5ndGgpIHtcbiAgICAgICAgICAgIHJ1blN0YXJ0W3N0YWNrU2l6ZV0gPSBfcnVuU3RhcnQ7XG4gICAgICAgICAgICBydW5MZW5ndGhbc3RhY2tTaXplXSA9IF9ydW5MZW5ndGg7XG4gICAgICAgICAgICBzdGFja1NpemUgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlUnVucygpIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFja1NpemUgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBzdGFja1NpemUgLSAyO1xuXG4gICAgICAgICAgICAgICAgaWYgKG4gPj0gMSAmJiBydW5MZW5ndGhbbiAtIDFdIDw9IHJ1bkxlbmd0aFtuXSArIHJ1bkxlbmd0aFtuICsgMV0gfHwgbiA+PSAyICYmIHJ1bkxlbmd0aFtuIC0gMl0gPD0gcnVuTGVuZ3RoW25dICsgcnVuTGVuZ3RoW24gLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVuTGVuZ3RoW24gLSAxXSA8IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChydW5MZW5ndGhbbl0gPiBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXJnZUF0KG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZm9yY2VNZXJnZVJ1bnMoKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2tTaXplID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gc3RhY2tTaXplIC0gMjtcblxuICAgICAgICAgICAgICAgIGlmIChuID4gMCAmJiBydW5MZW5ndGhbbiAtIDFdIDwgcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWVyZ2VBdChuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlQXQoaSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0MSA9IHJ1blN0YXJ0W2ldO1xuICAgICAgICAgICAgdmFyIGxlbmd0aDEgPSBydW5MZW5ndGhbaV07XG4gICAgICAgICAgICB2YXIgc3RhcnQyID0gcnVuU3RhcnRbaSArIDFdO1xuICAgICAgICAgICAgdmFyIGxlbmd0aDIgPSBydW5MZW5ndGhbaSArIDFdO1xuXG4gICAgICAgICAgICBydW5MZW5ndGhbaV0gPSBsZW5ndGgxICsgbGVuZ3RoMjtcblxuICAgICAgICAgICAgaWYgKGkgPT09IHN0YWNrU2l6ZSAtIDMpIHtcbiAgICAgICAgICAgICAgICBydW5TdGFydFtpICsgMV0gPSBydW5TdGFydFtpICsgMl07XG4gICAgICAgICAgICAgICAgcnVuTGVuZ3RoW2kgKyAxXSA9IHJ1bkxlbmd0aFtpICsgMl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YWNrU2l6ZS0tO1xuXG4gICAgICAgICAgICB2YXIgayA9IGdhbGxvcFJpZ2h0KGFycmF5W3N0YXJ0Ml0sIGFycmF5LCBzdGFydDEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuICAgICAgICAgICAgc3RhcnQxICs9IGs7XG4gICAgICAgICAgICBsZW5ndGgxIC09IGs7XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZW5ndGgyID0gZ2FsbG9wTGVmdChhcnJheVtzdGFydDEgKyBsZW5ndGgxIC0gMV0sIGFycmF5LCBzdGFydDIsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgxIDw9IGxlbmd0aDIpIHtcbiAgICAgICAgICAgICAgICBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZUhpZ2goc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpIHtcbiAgICAgICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHRtcFtpXSA9IGFycmF5W3N0YXJ0MSArIGldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3Vyc29yMSA9IDA7XG4gICAgICAgICAgICB2YXIgY3Vyc29yMiA9IHN0YXJ0MjtcbiAgICAgICAgICAgIHZhciBkZXN0ID0gc3RhcnQxO1xuXG4gICAgICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcblxuICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX21pbkdhbGxvcCA9IG1pbkdhbGxvcDtcbiAgICAgICAgICAgIHZhciBjb3VudDEsIGNvdW50MiwgZXhpdDtcblxuICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICBjb3VudDEgPSAwO1xuICAgICAgICAgICAgICAgIGNvdW50MiA9IDA7XG4gICAgICAgICAgICAgICAgZXhpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShhcnJheVtjdXJzb3IyXSwgdG1wW2N1cnNvcjFdKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDEgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0KytdID0gdG1wW2N1cnNvcjErK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICgoY291bnQxIHwgY291bnQyKSA8IF9taW5HYWxsb3ApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDEgPSBnYWxsb3BSaWdodChhcnJheVtjdXJzb3IyXSwgdG1wLCBjdXJzb3IxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0ICs9IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjEgKz0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY291bnQyID0gZ2FsbG9wTGVmdCh0bXBbY3Vyc29yMV0sIGFycmF5LCBjdXJzb3IyLCBsZW5ndGgyLCAwLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3QgKz0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yMiArPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGgyIC09IGNvdW50MjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0KytdID0gdG1wW2N1cnNvcjErK107XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9taW5HYWxsb3AtLTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9taW5HYWxsb3AgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF9taW5HYWxsb3AgPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9taW5HYWxsb3AgKz0gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWluR2FsbG9wID0gX21pbkdhbGxvcDtcblxuICAgICAgICAgICAgbWluR2FsbG9wIDwgMSAmJiAobWluR2FsbG9wID0gMSk7XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ21lcmdlTG93IHByZWNvbmRpdGlvbnMgd2VyZSBub3QgcmVzcGVjdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VIaWdoIChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQyICsgaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjdXJzb3IxID0gc3RhcnQxICsgbGVuZ3RoMSAtIDE7XG4gICAgICAgICAgICB2YXIgY3Vyc29yMiA9IGxlbmd0aDIgLSAxO1xuICAgICAgICAgICAgdmFyIGRlc3QgPSBzdGFydDIgKyBsZW5ndGgyIC0gMTtcbiAgICAgICAgICAgIHZhciBjdXN0b21DdXJzb3IgPSAwO1xuICAgICAgICAgICAgdmFyIGN1c3RvbURlc3QgPSAwO1xuXG4gICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21DdXJzb3IgKyBpXSA9IHRtcFtpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgICAgICAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX21pbkdhbGxvcCA9IG1pbkdhbGxvcDtcblxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQxID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQyID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgZXhpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZSh0bXBbY3Vyc29yMl0sIGFycmF5W2N1cnNvcjFdKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IHRtcFtjdXJzb3IyLS1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDEgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBfbWluR2FsbG9wKTtcblxuICAgICAgICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQxID0gbGVuZ3RoMSAtIGdhbGxvcFJpZ2h0KHRtcFtjdXJzb3IyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgbGVuZ3RoMSAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3QgLT0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yMSAtPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGgxIC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBjb3VudDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IHRtcFtjdXJzb3IyLS1dO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb3VudDIgPSBsZW5ndGgyIC0gZ2FsbG9wTGVmdChhcnJheVtjdXJzb3IxXSwgdG1wLCAwLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCAtPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IyIC09IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMiArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IHRtcFtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9taW5HYWxsb3AtLTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9taW5HYWxsb3AgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF9taW5HYWxsb3AgPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9taW5HYWxsb3AgKz0gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWluR2FsbG9wID0gX21pbkdhbGxvcDtcblxuICAgICAgICAgICAgaWYgKG1pbkdhbGxvcCA8IDEpIHtcbiAgICAgICAgICAgICAgICBtaW5HYWxsb3AgPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRlc3QgLT0gbGVuZ3RoMTtcbiAgICAgICAgICAgICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICAgICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcignbWVyZ2VIaWdoIHByZWNvbmRpdGlvbnMgd2VyZSBub3QgcmVzcGVjdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBkZXN0IC0gKGxlbmd0aDIgLSAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWVyZ2VSdW5zID0gbWVyZ2VSdW5zO1xuICAgICAgICB0aGlzLmZvcmNlTWVyZ2VSdW5zID0gZm9yY2VNZXJnZVJ1bnM7XG4gICAgICAgIHRoaXMucHVzaFJ1biA9IHB1c2hSdW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydChhcnJheSwgY29tcGFyZSwgbG8sIGhpKSB7XG4gICAgICAgIGlmICghbG8pIHtcbiAgICAgICAgICAgIGxvID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhpKSB7XG4gICAgICAgICAgICBoaSA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW1haW5pbmcgPSBoaSAtIGxvO1xuXG4gICAgICAgIGlmIChyZW1haW5pbmcgPCAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcnVuTGVuZ3RoID0gMDtcblxuICAgICAgICBpZiAocmVtYWluaW5nIDwgREVGQVVMVF9NSU5fTUVSR0UpIHtcbiAgICAgICAgICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG4gICAgICAgICAgICBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgaGksIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0cyA9IG5ldyBUaW1Tb3J0KGFycmF5LCBjb21wYXJlKTtcblxuICAgICAgICB2YXIgbWluUnVuID0gbWluUnVuTGVuZ3RoKHJlbWFpbmluZyk7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcbiAgICAgICAgICAgIGlmIChydW5MZW5ndGggPCBtaW5SdW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9yY2UgPSByZW1haW5pbmc7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlID4gbWluUnVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlID0gbWluUnVuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBsbyArIGZvcmNlLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgICAgICAgICAgICAgcnVuTGVuZ3RoID0gZm9yY2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRzLnB1c2hSdW4obG8sIHJ1bkxlbmd0aCk7XG4gICAgICAgICAgICB0cy5tZXJnZVJ1bnMoKTtcblxuICAgICAgICAgICAgcmVtYWluaW5nIC09IHJ1bkxlbmd0aDtcbiAgICAgICAgICAgIGxvICs9IHJ1bkxlbmd0aDtcbiAgICAgICAgfSB3aGlsZSAocmVtYWluaW5nICE9PSAwKTtcblxuICAgICAgICB0cy5mb3JjZU1lcmdlUnVucygpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gc29ydDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvdGltc29ydC5qc1xuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOWKqOeUu+S4u+exuywg6LCD5bqm5ZKM566h55CG5omA5pyJ5Yqo55S75o6n5Yi25ZmoXG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25cbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuLy8gVE9ETyBBZGRpdGl2ZSBhbmltYXRpb25cbi8vIGh0dHA6Ly9pb3NvdGVyaWMuY29tL2FkZGl0aXZlLWFuaW1hdGlvbnMtYW5pbWF0ZXdpdGhkdXJhdGlvbi1pbi1pb3MtOC9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS92aWRlb3Mvd3dkYzIwMTQvIzIzNlxuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpLkRpc3BhdGNoZXI7XG5cbiAgICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgnLi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcblxuICAgIHZhciBBbmltYXRvciA9IHJlcXVpcmUoJy4vQW5pbWF0b3InKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBJWlJlbmRlclN0YWdlXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXBkYXRlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbmZyYW1lXVxuICAgICAqIEBwYXJhbSB7SVpSZW5kZXJTdGFnZX0gW29wdGlvbnMuc3RhZ2VdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgdmFyIGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oKTtcbiAgICAgKiAgICAgdmFyIG9iaiA9IHtcbiAgICAgKiAgICAgICAgIHg6IDEwMCxcbiAgICAgKiAgICAgICAgIHk6IDEwMFxuICAgICAqICAgICB9O1xuICAgICAqICAgICBhbmltYXRpb24uYW5pbWF0ZShub2RlLnBvc2l0aW9uKVxuICAgICAqICAgICAgICAgLndoZW4oMTAwMCwge1xuICAgICAqICAgICAgICAgICAgIHg6IDUwMCxcbiAgICAgKiAgICAgICAgICAgICB5OiA1MDBcbiAgICAgKiAgICAgICAgIH0pXG4gICAgICogICAgICAgICAud2hlbigyMDAwLCB7XG4gICAgICogICAgICAgICAgICAgeDogMTAwLFxuICAgICAqICAgICAgICAgICAgIHk6IDEwMFxuICAgICAqICAgICAgICAgfSlcbiAgICAgKiAgICAgICAgIC5zdGFydCgnc3BsaW5lJyk7XG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5zdGFnZSA9IG9wdGlvbnMuc3RhZ2UgfHwge307XG5cbiAgICAgICAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICAgICAgLy8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMuX2NsaXBzID0gW107XG5cbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3RpbWU7XG5cbiAgICAgICAgdGhpcy5fcGF1c2VkVGltZTtcblxuICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0O1xuXG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIERpc3BhdGNoZXIuY2FsbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQW5pbWF0aW9uLFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75YqgIGNsaXBcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQ2xpcDogZnVuY3Rpb24gKGNsaXApIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaXBzLnB1c2goY2xpcCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqAgYW5pbWF0b3JcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9IGFuaW1hdG9yXG4gICAgICAgICAqL1xuICAgICAgICBhZGRBbmltYXRvcjogZnVuY3Rpb24gKGFuaW1hdG9yKSB7XG4gICAgICAgICAgICBhbmltYXRvci5hbmltYXRpb24gPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNsaXBzID0gYW5pbWF0b3IuZ2V0Q2xpcHMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENsaXAoY2xpcHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXB9IGNsaXBcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNsaXA6IGZ1bmN0aW9uKGNsaXApIHtcbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fY2xpcHMsIGNsaXApO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpcHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIoOmZpOWKqOeUu+eJh+autVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICAgICAgICAgIHZhciBjbGlwcyA9IGFuaW1hdG9yLmdldENsaXBzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDbGlwKGNsaXBzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHZhciB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9wYXVzZWRUaW1lO1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gdGltZSAtIHRoaXMuX3RpbWU7XG4gICAgICAgICAgICB2YXIgY2xpcHMgPSB0aGlzLl9jbGlwcztcbiAgICAgICAgICAgIHZhciBsZW4gPSBjbGlwcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHZhciBkZWZlcnJlZEV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkQ2xpcHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IGNsaXBzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBlID0gY2xpcC5zdGVwKHRpbWUsIGRlbHRhKTtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBvdXQgdGhlIGV2ZW50cyBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlclxuICAgICAgICAgICAgICAgIC8vIHN0YWdlLnVwZGF0ZSwgbGlrZSBkZXN0cm95XG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRFdmVudHMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDbGlwcy5wdXNoKGNsaXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBmaW5pc2hlZCBjbGlwXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xpcHNbaV0uX25lZWRzUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBzW2ldID0gY2xpcHNbbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGNsaXBzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlbiA9IGRlZmVycmVkRXZlbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZENsaXBzW2ldLmZpcmUoZGVmZXJyZWRFdmVudHNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl90aW1lID0gdGltZTtcblxuICAgICAgICAgICAgdGhpcy5vbmZyYW1lKGRlbHRhKTtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdmcmFtZScsIGRlbHRhKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhZ2UudXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfc3RhcnRMb29wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9ydW5uaW5nKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLl9wYXVzZWQgJiYgc2VsZi5fdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8gOWni+i/kOihjOWKqOeUu1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdGhpcy5fdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0TG9vcCgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5YGc5q2i6L+Q6KGM5Yqo55S7XG4gICAgICAgICAqL1xuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhdXNlXG4gICAgICAgICAqL1xuICAgICAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzdW1lXG4gICAgICAgICAqL1xuICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZWRUaW1lICs9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSkgLSB0aGlzLl9wYXVzZVN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaTmiYDmnInliqjnlLvniYfmrrVcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGlwcyA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5a+55LiA5Liq55uu5qCH5Yib5bu65LiA5LiqYW5pbWF0b3Llr7nosaHvvIzlj6/ku6XmjIflrprnm67moIfkuK3nmoTlsZ7mgKfkvb/nlKjliqjnlLtcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmxvb3A9ZmFsc2VdIOaYr+WQpuW+queOr+aSreaUvuWKqOeUu1xuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2V0dGVyPW51bGxdXG4gICAgICAgICAqICAgICAgICAg5aaC5p6c5oyH5a6aZ2V0dGVy5Ye95pWw77yM5Lya6YCa6L+HZ2V0dGVy5Ye95pWw5Y+W5bGe5oCn5YC8XG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb3B0aW9ucy5zZXR0ZXI9bnVsbF1cbiAgICAgICAgICogICAgICAgICDlpoLmnpzmjIflrppzZXR0ZXLlh73mlbDvvIzkvJrpgJrov4dzZXR0ZXLlh73mlbDorr7nva7lsZ7mgKflgLxcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvbn5BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE8gR2FwXG4gICAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9vcCxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmdldHRlcixcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNldHRlclxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5hZGRBbmltYXRvcihhbmltYXRvcik7XG5cbiAgICAgICAgICAgIHJldHVybiBhbmltYXRvcjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB1dGlsLm1peGluKEFuaW1hdGlvbiwgRGlzcGF0Y2hlcik7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGlvbjtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOS6i+S7tui+heWKqeexu1xuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvZXZlbnRcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICovXG5cblxuICAgIHZhciBFdmVudGZ1bCA9IHJlcXVpcmUoJy4uL21peGluL0V2ZW50ZnVsJyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJy4vZW52Jyk7XG5cbiAgICB2YXIgaXNEb21MZXZlbDIgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpICYmICEhd2luZG93LmFkZEV2ZW50TGlzdGVuZXI7XG5cbiAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpIHtcbiAgICAgICAgLy8gQmxhY2tCZXJyeSA1LCBpT1MgMyAob3JpZ2luYWwgaVBob25lKSBkb24ndCBoYXZlIGdldEJvdW5kaW5nUmVjdFxuICAgICAgICByZXR1cm4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID8gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7bGVmdDogMCwgdG9wOiAwfTtcbiAgICB9XG5cbiAgICAvLyBgY2FsY3VsYXRlYCBpcyBvcHRpb25hbCwgZGVmYXVsdCBmYWxzZVxuICAgIGZ1bmN0aW9uIGNsaWVudFRvTG9jYWwoZWwsIGUsIG91dCwgY2FsY3VsYXRlKSB7XG4gICAgICAgIG91dCA9IG91dCB8fCB7fTtcblxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIFczQyBXb3JraW5nIERyYWZ0LCBvZmZzZXRYIGFuZCBvZmZzZXRZIHNob3VsZCBiZSByZWxhdGl2ZVxuICAgICAgICAvLyB0byB0aGUgcGFkZGluZyBlZGdlIG9mIHRoZSB0YXJnZXQgZWxlbWVudC4gVGhlIG9ubHkgYnJvd3NlciB1c2luZyB0aGlzIGNvbnZlbnRpb25cbiAgICAgICAgLy8gaXMgSUUuIFdlYmtpdCB1c2VzIHRoZSBib3JkZXIgZWRnZSwgT3BlcmEgdXNlcyB0aGUgY29udGVudCBlZGdlLCBhbmQgRmlyZUZveCBkb2VzXG4gICAgICAgIC8vIG5vdCBzdXBwb3J0IHRoZSBwcm9wZXJ0aWVzLlxuICAgICAgICAvLyAoc2VlIGh0dHA6Ly93d3cuamFja2xtb29yZS5jb20vbm90ZXMvbW91c2UtcG9zaXRpb24vKVxuICAgICAgICAvLyBJbiB6ciBwYWludGVyLmRvbSwgcGFkZGluZyBlZGdlIGVxdWFscyB0byBib3JkZXIgZWRnZS5cblxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBXaGVuIG1vdXNlbW92ZSBldmVudCB0cmlnZ2VyZWQgb24gZWMgdG9vbHRpcCwgdGFyZ2V0IGlzIG5vdCB6ciBwYWludGVyLmRvbSwgYW5kXG4gICAgICAgIC8vIG9mZnNldFgvWSBpcyByZWxhdGl2ZSB0byBlLnRhcmdldCwgd2hlcmUgdGhlIGNhbGN1bGF0aW9uIG9mIHpyWC9ZIHZpYSBvZmZzZXRYL1lcbiAgICAgICAgLy8gaXMgdG9vIGNvbXBsZXguIFNvIGNzcy10cmFuc2Zyb20gZG9udCBzdXBwb3J0IGluIHRoaXMgY2FzZSB0ZW1wb3JhcmlseS5cbiAgICAgICAgaWYgKGNhbGN1bGF0ZSB8fCAhZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2F1dGlvbjogSW4gRmlyZUZveCwgbGF5ZXJYL2xheWVyWSBNb3VzZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgY2xvc2VzdCBwb3NpdGlvbmVkXG4gICAgICAgIC8vIGFuY2VzdG9yIGVsZW1lbnQsIHNvIHdlIHNob3VsZCBtYWtlIHN1cmUgZWwgaXMgcG9zaXRpb25lZCAoZS5nLiwgbm90IHBvc2l0aW9uOnN0YXRpYykuXG4gICAgICAgIC8vIEJUVzEsIFdlYmtpdCBkb24ndCByZXR1cm4gdGhlIHNhbWUgcmVzdWx0cyBhcyBGRiBpbiBub24tc2ltcGxlIGNhc2VzIChsaWtlIGFkZFxuICAgICAgICAvLyB6b29tLWZhY3Rvciwgb3ZlcmZsb3cgLyBvcGFjaXR5IGxheWVycywgdHJhbnNmb3JtcyAuLi4pXG4gICAgICAgIC8vIEJUVzIsIChldi5vZmZzZXRZIHx8IGV2LnBhZ2VZIC0gJChldi50YXJnZXQpLm9mZnNldCgpLnRvcCkgaXMgbm90IGNvcnJlY3QgaW4gcHJlc2VydmUtM2QuXG4gICAgICAgIC8vIDxodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvODUyMyNjb21tZW50OjE0PlxuICAgICAgICAvLyBCVFczLCBJbiBmZiwgb2Zmc2V0WC9vZmZzZXRZIGlzIGFsd2F5cyAwLlxuICAgICAgICBlbHNlIGlmIChlbnYuYnJvd3Nlci5maXJlZm94ICYmIGUubGF5ZXJYICE9IG51bGwgJiYgZS5sYXllclggIT09IGUub2Zmc2V0WCkge1xuICAgICAgICAgICAgb3V0LnpyWCA9IGUubGF5ZXJYO1xuICAgICAgICAgICAgb3V0LnpyWSA9IGUubGF5ZXJZO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBJRTYrLCBjaHJvbWUsIHNhZmFyaSwgb3BlcmEuIChXaGVuIHdpbGwgZmYgc3VwcG9ydCBvZmZzZXRYPylcbiAgICAgICAgZWxzZSBpZiAoZS5vZmZzZXRYICE9IG51bGwpIHtcbiAgICAgICAgICAgIG91dC56clggPSBlLm9mZnNldFg7XG4gICAgICAgICAgICBvdXQuenJZID0gZS5vZmZzZXRZO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBzb21lIG90aGVyIGRldmljZSwgZS5nLiwgSU9TIHNhZmFyaS5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0R2V0WnJYWShlbCwgZSwgb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCkge1xuICAgICAgICAvLyBUaGlzIHdlbGwta25vd24gbWV0aG9kIGJlbG93IGRvZXMgbm90IHN1cHBvcnQgY3NzIHRyYW5zZm9ybS5cbiAgICAgICAgdmFyIGJveCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbCk7XG4gICAgICAgIG91dC56clggPSBlLmNsaWVudFggLSBib3gubGVmdDtcbiAgICAgICAgb3V0LnpyWSA9IGUuY2xpZW50WSAtIGJveC50b3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5aaC5p6c5a2Y5Zyo56ys5LiJ5pa55bWM5YWl55qE5LiA5LqbZG9t6Kem5Y+R55qE5LqL5Lu277yM5oiWdG91Y2jkuovku7bvvIzpnIDopoHovazmjaLkuIDkuIvkuovku7blnZDmoIcuXG4gICAgICogYGNhbGN1bGF0ZWAgaXMgb3B0aW9uYWwsIGRlZmF1bHQgZmFsc2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplRXZlbnQoZWwsIGUsIGNhbGN1bGF0ZSkge1xuXG4gICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICAgICAgICBpZiAoZS56clggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXZlbnRUeXBlID0gZS50eXBlO1xuICAgICAgICB2YXIgaXNUb3VjaCA9IGV2ZW50VHlwZSAmJiBldmVudFR5cGUuaW5kZXhPZigndG91Y2gnKSA+PSAwO1xuXG4gICAgICAgIGlmICghaXNUb3VjaCkge1xuICAgICAgICAgICAgY2xpZW50VG9Mb2NhbChlbCwgZSwgZSwgY2FsY3VsYXRlKTtcbiAgICAgICAgICAgIGUuenJEZWx0YSA9IChlLndoZWVsRGVsdGEpID8gZS53aGVlbERlbHRhIC8gMTIwIDogLShlLmRldGFpbCB8fCAwKSAvIDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdG91Y2ggPSBldmVudFR5cGUgIT0gJ3RvdWNoZW5kJ1xuICAgICAgICAgICAgICAgID8gZS50YXJnZXRUb3VjaGVzWzBdXG4gICAgICAgICAgICAgICAgOiBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgdG91Y2ggJiYgY2xpZW50VG9Mb2NhbChlbCwgdG91Y2gsIGUsIGNhbGN1bGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChpc0RvbUxldmVsMikge1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJldmVudERlZmF1bHQgYW5kIHN0b3BQcm9wYWdhdGlvbi5cbiAgICAgKiBOb3RpY2U6IGRvIG5vdCBkbyB0aGF0IGluIHpyZW5kZXIuIFVwcGVyIGFwcGxpY2F0aW9uXG4gICAgICogZG8gdGhhdCBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9ldmVudFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIDogZXZlbnTlr7nosaFcbiAgICAgKi9cbiAgICB2YXIgc3RvcCA9IGlzRG9tTGV2ZWwyXG4gICAgICAgID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGNsaWVudFRvTG9jYWw6IGNsaWVudFRvTG9jYWwsXG4gICAgICAgIG5vcm1hbGl6ZUV2ZW50OiBub3JtYWxpemVFdmVudCxcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogYWRkRXZlbnRMaXN0ZW5lcixcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogcmVtb3ZlRXZlbnRMaXN0ZW5lcixcblxuICAgICAgICBzdG9wOiBzdG9wLFxuICAgICAgICAvLyDlgZrlkJHkuIrlhbzlrrlcbiAgICAgICAgRGlzcGF0Y2hlcjogRXZlbnRmdWxcbiAgICB9O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL2V2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanNcbiAqKiBtb2R1bGUgaWQgPSA2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5cbiAgICB2YXIgZXZlbnRUb29sID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuLi9taXhpbi9FdmVudGZ1bCcpO1xuICAgIHZhciBlbnYgPSByZXF1aXJlKCcuLi9jb3JlL2VudicpO1xuICAgIHZhciBHZXN0dXJlTWdyID0gcmVxdWlyZSgnLi4vY29yZS9HZXN0dXJlTWdyJyk7XG5cbiAgICB2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IGV2ZW50VG9vbC5hZGRFdmVudExpc3RlbmVyO1xuICAgIHZhciByZW1vdmVFdmVudExpc3RlbmVyID0gZXZlbnRUb29sLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gICAgdmFyIG5vcm1hbGl6ZUV2ZW50ID0gZXZlbnRUb29sLm5vcm1hbGl6ZUV2ZW50O1xuXG4gICAgdmFyIFRPVUNIX0NMSUNLX0RFTEFZID0gMzAwO1xuXG4gICAgdmFyIG1vdXNlSGFuZGxlck5hbWVzID0gW1xuICAgICAgICAnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V3aGVlbCcsICdtb3VzZW91dCcsXG4gICAgICAgICdtb3VzZXVwJywgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnY29udGV4dG1lbnUnXG4gICAgXTtcblxuICAgIHZhciB0b3VjaEhhbmRsZXJOYW1lcyA9IFtcbiAgICAgICAgJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnLCAndG91Y2htb3ZlJ1xuICAgIF07XG5cbiAgICB2YXIgcG9pbnRlckV2ZW50TmFtZXMgPSB7XG4gICAgICAgIHBvaW50ZXJkb3duOiAxLCBwb2ludGVydXA6IDEsIHBvaW50ZXJtb3ZlOiAxLCBwb2ludGVyb3V0OiAxXG4gICAgfTtcblxuICAgIHZhciBwb2ludGVySGFuZGxlck5hbWVzID0genJVdGlsLm1hcChtb3VzZUhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIG5tID0gbmFtZS5yZXBsYWNlKCdtb3VzZScsICdwb2ludGVyJyk7XG4gICAgICAgIHJldHVybiBwb2ludGVyRXZlbnROYW1lc1tubV0gPyBubSA6IG5hbWU7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBldmVudE5hbWVGaXgobmFtZSkge1xuICAgICAgICByZXR1cm4gKG5hbWUgPT09ICdtb3VzZXdoZWVsJyAmJiBlbnYuYnJvd3Nlci5maXJlZm94KSA/ICdET01Nb3VzZVNjcm9sbCcgOiBuYW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NHZXN0dXJlKHByb3h5LCBldmVudCwgc3RhZ2UpIHtcbiAgICAgICAgdmFyIGdlc3R1cmVNZ3IgPSBwcm94eS5fZ2VzdHVyZU1ncjtcblxuICAgICAgICBzdGFnZSA9PT0gJ3N0YXJ0JyAmJiBnZXN0dXJlTWdyLmNsZWFyKCk7XG5cbiAgICAgICAgdmFyIGdlc3R1cmVJbmZvID0gZ2VzdHVyZU1nci5yZWNvZ25pemUoXG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIHByb3h5LmhhbmRsZXIuZmluZEhvdmVyKGV2ZW50LnpyWCwgZXZlbnQuenJZLCBudWxsKSxcbiAgICAgICAgICAgIHByb3h5LmRvbVxuICAgICAgICApO1xuXG4gICAgICAgIHN0YWdlID09PSAnZW5kJyAmJiBnZXN0dXJlTWdyLmNsZWFyKCk7XG5cbiAgICAgICAgLy8gRG8gbm90IGRvIGFueSBwcmV2ZW50RGVmYXVsdCBoZXJlLiBVcHBlciBhcHBsaWNhdGlvbiBkbyB0aGF0IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgaWYgKGdlc3R1cmVJbmZvKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGdlc3R1cmVJbmZvLnR5cGU7XG4gICAgICAgICAgICBldmVudC5nZXN0dXJlRXZlbnQgPSB0eXBlO1xuXG4gICAgICAgICAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KGdlc3R1cmVJbmZvLnRhcmdldCwgdHlwZSwgZ2VzdHVyZUluZm8uZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24gb25NU0dlc3R1cmVDaGFuZ2UocHJveHksIGV2ZW50KSB7XG4gICAgLy8gICAgIGlmIChldmVudC50cmFuc2xhdGlvblggfHwgZXZlbnQudHJhbnNsYXRpb25ZKSB7XG4gICAgLy8gICAgICAgICAvLyBtb3VzZW1vdmUgaXMgY2FycmllZCBieSBNU0dlc3R1cmUgdG8gcmVkdWNlIHRoZSBzZW5zaXRpdml0eS5cbiAgICAvLyAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoZXZlbnQudGFyZ2V0LCAnbW91c2Vtb3ZlJywgZXZlbnQpO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmIChldmVudC5zY2FsZSAhPT0gMSkge1xuICAgIC8vICAgICAgICAgZXZlbnQucGluY2hYID0gZXZlbnQub2Zmc2V0WDtcbiAgICAvLyAgICAgICAgIGV2ZW50LnBpbmNoWSA9IGV2ZW50Lm9mZnNldFk7XG4gICAgLy8gICAgICAgICBldmVudC5waW5jaFNjYWxlID0gZXZlbnQuc2NhbGU7XG4gICAgLy8gICAgICAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KGV2ZW50LnRhcmdldCwgJ3BpbmNoJywgZXZlbnQpO1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gICAgLyoqXG4gICAgICogUHJldmVudCBtb3VzZSBldmVudCBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgYWZ0ZXIgVG91Y2ggRXZlbnRzIGFjdGlvblxuICAgICAqIEBzZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9kZWx0YWtvc2gvaGFuZGpzL2Jsb2IvbWFzdGVyL3NyYy9oYW5kLmJhc2UuanM+XG4gICAgICogMS4gTW9iaWxlIGJyb3dzZXJzIGRpc3BhdGNoIG1vdXNlIGV2ZW50cyAzMDBtcyBhZnRlciB0b3VjaGVuZC5cbiAgICAgKiAyLiBDaHJvbWUgZm9yIEFuZHJvaWQgZGlzcGF0Y2ggbW91c2Vkb3duIGZvciBsb25nLXRvdWNoIGFib3V0IDY1MG1zXG4gICAgICogUmVzdWx0OiBCbG9ja2luZyBNb3VzZSBFdmVudHMgZm9yIDcwMG1zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFRvdWNoVGltZXIoaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UuX3RvdWNoaW5nID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGluc3RhbmNlLl90b3VjaFRpbWVyKTtcbiAgICAgICAgaW5zdGFuY2UuX3RvdWNoVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl90b3VjaGluZyA9IGZhbHNlO1xuICAgICAgICB9LCA3MDApO1xuICAgIH1cblxuXG4gICAgdmFyIGRvbUhhbmRsZXJzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogTW91c2UgbW92ZSBoYW5kbGVyXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdtb3VzZW1vdmUnLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIG91dCBoYW5kbGVyXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5b+955Wl5YyF5ZCr5Zyocm9vdOS4reeahGRvbeW8lei1t+eahG1vdXNlT3V0XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2VvdXQnLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvdWNo5byA5aeL5ZON5bqU5Ye95pWwXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hzdGFydDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IG1vdXNlIGJlaGF2aW91ciBzaG91bGQgbm90IGJlIGRpc2FibGVkIGhlcmUuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgcGFnZSBtYXkgbmVlZHMgdG8gYmUgc2xpZGVkLlxuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgICAgICAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cbiAgICAgICAgICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnc3RhcnQnKTtcblxuICAgICAgICAgICAgLy8gSW4gdG91Y2ggZGV2aWNlLCB0cmlnZ2VyIGBtb3VzZW1vdmVgKGBtb3VzZW92ZXJgKSBzaG91bGRcbiAgICAgICAgICAgIC8vIGJlIHRyaWdnZXJlZCwgYW5kIG11c3QgYmVmb3JlIGBtb3VzZWRvd25gIHRyaWdnZXJlZC5cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOenu+WKqOWTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgICAgICAgICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG4gICAgICAgICAgICBldmVudC56ckJ5VG91Y2ggPSB0cnVlO1xuXG4gICAgICAgICAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ2NoYW5nZScpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBtb3ZlIHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBnZXN0cnVlIGV2ZW50LCBiZWNhdXNlIG1vdXNlIG1vdmUgYW5kIHBpbmNoIG1heVxuICAgICAgICAgICAgLy8gYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOe7k+adn+WTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoZW5kOiBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgICAgICAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cbiAgICAgICAgICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG5cbiAgICAgICAgICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnZW5kJyk7XG5cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNldXAuY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICAgICAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIGBtb3VzZW91dGAgaGVyZSwgaW4gc3BpdGUgb2YgYG1vdXNlbW92ZWAoYG1vdXNlb3ZlcmApIGlzXG4gICAgICAgICAgICAvLyB0cmlnZ2VyZWQgaW4gYHRvdWNoc3RhcnRgLiBUaGlzIHNlZW1zIHRvIGJlIGlsbG9naWNhbCwgYnV0IGJ5IHRoaXMgbWVjaGFuaXNtLFxuICAgICAgICAgICAgLy8gd2UgY2FuIGNvbnZlbmllbnRseSBpbXBsZW1lbnQgXCJob3ZlciBzdHlsZVwiIGluIGJvdGggUEMgYW5kIHRvdWNoIGRldmljZSBqdXN0XG4gICAgICAgICAgICAvLyBieSBsaXN0ZW5pbmcgdG8gYG1vdXNlb3ZlcmAgdG8gYWRkIFwiaG92ZXIgc3R5bGVcIiBhbmQgbGlzdGVuaW5nIHRvIGBtb3VzZW91dGBcbiAgICAgICAgICAgIC8vIHRvIHJlbW92ZSBcImhvdmVyIHN0eWxlXCIgb24gYW4gZWxlbWVudCwgd2l0aG91dCBhbnkgYWRkaXRpb25hbCBjb2RlIGZvclxuICAgICAgICAgICAgLy8gY29tcGF0aWJpbGl0eS4gKGBtb3VzZW91dGAgd2lsbCBub3QgYmUgdHJpZ2dlcmVkIGluIGB0b3VjaGVuZGAsIHNvIFwiaG92ZXJcbiAgICAgICAgICAgIC8vIHN0eWxlXCIgd2lsbCByZW1haW4gZm9yIHVzZXIgdmlldylcblxuICAgICAgICAgICAgLy8gY2xpY2sgZXZlbnQgc2hvdWxkIGFsd2F5cyBiZSB0cmlnZ2VyZWQgbm8gbWF0dGVyIHdoZXRoZXJcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQuIFN5c3RlbSBjbGljayBjYW4gbm90IGJlIHByZXZlbnRlZC5cbiAgICAgICAgICAgIGlmICgrbmV3IERhdGUoKSAtIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA8IFRPVUNIX0NMSUNLX0RFTEFZKSB7XG4gICAgICAgICAgICAgICAgZG9tSGFuZGxlcnMuY2xpY2suY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9pbnRlcmRvd246IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBpZiAodXNlTVNHdWVzdHVyZSh0aGlzLCBldmVudCkpIHtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLl9tc0dlc3R1cmUuYWRkUG9pbnRlcihldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyBwb2ludGVybW92ZSBpcyBzbyBzZW5zaXRpdmUgdGhhdCBpdCBhbHdheXMgdHJpZ2dlcmVkIHdoZW5cbiAgICAgICAgICAgIC8vIHRhcChjbGljaykgb24gdG91Y2ggc2NyZWVuLCB3aGljaCBhZmZlY3Qgc29tZSBqdWRnZW1lbnQgaW5cbiAgICAgICAgICAgIC8vIHVwcGVyIGFwcGxpY2F0aW9uLiBTbywgd2UgZG9udCBzdXBwb3J0IG1vdXNlbW92ZSBvbiBNUyB0b3VjaFxuICAgICAgICAgICAgLy8gZGV2aWNlIHlldC5cbiAgICAgICAgICAgIGlmICghaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludGVydXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludGVyb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIHBvaW50ZXJvdXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0YXAgb24gdG91Y2ggc2NyZWVuXG4gICAgICAgICAgICAvLyAoSUUxMSsvRWRnZSBvbiBNUyBTdXJmYWNlKSBhZnRlciBjbGljayBldmVudCB0cmlnZ2VyZWQsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgbW91c291dCBiZWhhdmlvciB3ZSBkZWZpbmVkXG4gICAgICAgICAgICAvLyBpbiB0b3VjaGVuZC4gU28gd2UgdW5pZnkgdGhlbS5cbiAgICAgICAgICAgIC8vIChjaGVjayBkb21IYW5kbGVycy50b3VjaGVuZCBmb3IgZGV0YWlsZWQgZXhwbGFuYXRpb24pXG4gICAgICAgICAgICBpZiAoIWlzUG9pbnRlckZyb21Ub3VjaChldmVudCkpIHtcbiAgICAgICAgICAgICAgICBkb21IYW5kbGVycy5tb3VzZW91dC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICAgIHJldHVybiBwb2ludGVyVHlwZSA9PT0gJ3BlbicgfHwgcG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24gdXNlTVNHdWVzdHVyZShoYW5kbGVyUHJveHksIGV2ZW50KSB7XG4gICAgLy8gICAgIHJldHVybiBpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpICYmICEhaGFuZGxlclByb3h5Ll9tc0dlc3R1cmU7XG4gICAgLy8gfVxuXG4gICAgLy8gQ29tbW9uIGhhbmRsZXJzXG4gICAgenJVdGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJywgJ2NvbnRleHRtZW51J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGRvbUhhbmRsZXJzW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobmFtZSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICog5Li65o6n5Yi257G75a6e5L6L5Yid5aeL5YyWZG9tIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAqXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9IYW5kbGVyfSBpbnN0YW5jZSDmjqfliLbnsbvlrp7kvotcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0RG9tSGFuZGxlcihpbnN0YW5jZSkge1xuICAgICAgICB6clV0aWwuZWFjaCh0b3VjaEhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IHpyVXRpbC5iaW5kKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHpyVXRpbC5lYWNoKHBvaW50ZXJIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSB6clV0aWwuYmluZChkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICB6clV0aWwuZWFjaChtb3VzZUhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IG1ha2VNb3VzZUhhbmRsZXIoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZU1vdXNlSGFuZGxlcihmbiwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLl90b3VjaGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIEhhbmRsZXJEb21Qcm94eShkb20pIHtcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90b3VjaGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdG91Y2hUaW1lcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvR2VzdHVyZU1ncn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2dlc3R1cmVNZ3IgPSBuZXcgR2VzdHVyZU1ncigpO1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XG5cbiAgICAgICAgaW5pdERvbUhhbmRsZXIodGhpcyk7XG5cbiAgICAgICAgaWYgKGVudi5wb2ludGVyRXZlbnRzU3VwcG9ydGVkKSB7IC8vIE9ubHkgSUUxMSsvRWRnZVxuICAgICAgICAgICAgLy8gMS4gT24gZGV2aWNlcyB0aGF0IGJvdGggZW5hYmxlIHRvdWNoIGFuZCBtb3VzZSAoZS5nLiwgTVMgU3VyZmFjZSBhbmQgbGVub3ZvIFgyNDApLFxuICAgICAgICAgICAgLy8gSUUxMSsvRWRnZSBkbyBub3QgdHJpZ2dlciB0b3VjaCBldmVudCwgYnV0IHRyaWdnZXIgcG9pbnRlciBldmVudCBhbmQgbW91c2UgZXZlbnRcbiAgICAgICAgICAgIC8vIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgICAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBpdCBwcm9iYWJsZWx5IG9ubHkgdHJpZ2dlciBtb3VzZWRvd24gYnV0IG5vIG1vdXNldXAgd2hlbiB0YXAgb25cbiAgICAgICAgICAgIC8vIHNjcmVlbiwgd2hpY2ggZG8gbm90IG9jY3VycyBpbiBwb2ludGVyIGV2ZW50LlxuICAgICAgICAgICAgLy8gU28gd2UgdXNlIHBvaW50ZXIgZXZlbnQgdG8gYm90aCBkZXRlY3QgdG91Y2ggZ2VzdHVyZSBhbmQgbW91c2UgYmVoYXZpb3IuXG4gICAgICAgICAgICBtb3VudEhhbmRsZXJzKHBvaW50ZXJIYW5kbGVyTmFtZXMsIHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgLy8gTm90ZTogTVMgR2VzdHVyZSByZXF1aXJlIENTUyB0b3VjaC1hY3Rpb24gc2V0LiBCdXQgdG91Y2gtYWN0aW9uIGlzIG5vdCByZWxpYWJsZSxcbiAgICAgICAgICAgIC8vIHdoaWNoIGRvZXMgbm90IHByZXZlbnQgZGVmdWF1bHQgYmVoYXZpb3Igb2NjYXNpb25hbGx5ICh3aGljaCBtYXkgY2F1c2UgdmlldyBwb3J0XG4gICAgICAgICAgICAvLyB6b29tZWQgaW4gYnV0IHVzZSBjYW4gbm90IHpvb20gaXQgYmFjaykuIEFuZCBldmVudC5wcmV2ZW50RGVmYXVsdCgpIGRvZXMgbm90IHdvcmsuXG4gICAgICAgICAgICAvLyBTbyB3ZSBoYXZlIHRvIG5vdCB0byB1c2UgTVNHZXN0dXJlIGFuZCBub3QgdG8gc3VwcG9ydCB0b3VjaG1vdmUgYW5kIHBpbmNoIG9uIE1TXG4gICAgICAgICAgICAvLyB0b3VjaCBzY3JlZW4uIEFuZCB3ZSBvbmx5IHN1cHBvcnQgY2xpY2sgYmVoYXZpb3Igb24gTVMgdG91Y2ggc2NyZWVuIG5vdy5cblxuICAgICAgICAgICAgLy8gTVMgR2VzdHVyZSBFdmVudCBpcyBvbmx5IHN1cHBvcnRlZCBvbiBJRTExKy9FZGdlIGFuZCBvbiBXaW5kb3dzIDgrLlxuICAgICAgICAgICAgLy8gV2UgZG9udCBzdXBwb3J0IHRvdWNoIG9uIElFIG9uIHdpbjcuXG4gICAgICAgICAgICAvLyBTZWUgPGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDModj12cy44NSkuYXNweD5cbiAgICAgICAgICAgIC8vIGlmICh0eXBlb2YgTVNHZXN0dXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyAgICAgKHRoaXMuX21zR2VzdHVyZSA9IG5ldyBNU0dlc3R1cmUoKSkudGFyZ2V0ID0gZG9tOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgIC8vICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignTVNHZXN0dXJlQ2hhbmdlJywgb25NU0dlc3R1cmVDaGFuZ2UpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVudi50b3VjaEV2ZW50c1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIG1vdW50SGFuZGxlcnModG91Y2hIYW5kbGVyTmFtZXMsIHRoaXMpO1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZXIgb2YgJ21vdXNlb3V0JyBldmVudCBpcyBuZWVkZWQgaW4gdG91Y2ggbW9kZSwgd2hpY2ggd2lsbCBiZSBtb3VudGVkIGJlbG93LlxuICAgICAgICAgICAgICAgIC8vIGFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ21vdXNlb3V0JywgdGhpcy5fbW91c2VvdXRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMS4gQ29uc2lkZXJpbmcgc29tZSBkZXZpY2VzIHRoYXQgYm90aCBlbmFibGUgdG91Y2ggYW5kIG1vdXNlIGV2ZW50IChsaWtlIG9uIE1TIFN1cmZhY2VcbiAgICAgICAgICAgIC8vIGFuZCBsZW5vdm8gWDI0MCwgQHNlZSAjMjM1MCksIHdlIG1ha2UgbW91c2UgZXZlbnQgYmUgYWx3YXlzIGxpc3RlbmVkLCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIG1vdXNlIGV2ZW50IGNhbiBub3QgYmUgaGFuZGxlIGluIHRob3NlIGRldmljZXMuXG4gICAgICAgICAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBDaHJvbWUgd2lsbCB0cmlnZ2VyIGJvdGggdG91Y2ggZXZlbnQgYW5kIG1vdXNlIGV2ZW50LiBIb3cgdG8gcHJldmVudFxuICAgICAgICAgICAgLy8gbW91c2VldmVudCBhZnRlciB0b3VjaCBldmVudCB0cmlnZ2VyZWQsIHNlZSBgc2V0VG91Y2hUaW1lcmAuXG4gICAgICAgICAgICBtb3VudEhhbmRsZXJzKG1vdXNlSGFuZGxlck5hbWVzLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1vdW50SGFuZGxlcnMoaGFuZGxlck5hbWVzLCBpbnN0YW5jZSkge1xuICAgICAgICAgICAgenJVdGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZG9tLCBldmVudE5hbWVGaXgobmFtZSksIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSk7XG4gICAgICAgICAgICB9LCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlckRvbVByb3h5UHJvdG8gPSBIYW5kbGVyRG9tUHJveHkucHJvdG90eXBlO1xuICAgIGhhbmRsZXJEb21Qcm94eVByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYW5kbGVyTmFtZXMgPSBtb3VzZUhhbmRsZXJOYW1lcy5jb25jYXQodG91Y2hIYW5kbGVyTmFtZXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGhhbmRsZXJOYW1lc1tpXTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5kb20sIGV2ZW50TmFtZUZpeChuYW1lKSwgdGhpcy5faGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGhhbmRsZXJEb21Qcm94eVByb3RvLnNldEN1cnNvciA9IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS5jdXJzb3IgPSBjdXJzb3JTdHlsZSB8fCAnZGVmYXVsdCc7XG4gICAgfTtcblxuICAgIHpyVXRpbC5taXhpbihIYW5kbGVyRG9tUHJveHksIEV2ZW50ZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlckRvbVByb3h5O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZG9tL0hhbmRsZXJQcm94eS5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIE9ubHkgaW1wbGVtZW50cyBuZWVkZWQgZ2VzdHVyZXMgZm9yIG1vYmlsZS5cbiAqL1xuXG5cbiAgICB2YXIgZXZlbnRVdGlsID0gcmVxdWlyZSgnLi9ldmVudCcpO1xuXG4gICAgdmFyIEdlc3R1cmVNZ3IgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RyYWNrID0gW107XG4gICAgfTtcblxuICAgIEdlc3R1cmVNZ3IucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBHZXN0dXJlTWdyLFxuXG4gICAgICAgIHJlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2RvVHJhY2soZXZlbnQsIHRhcmdldCwgcm9vdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjb2duaXplKGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2subGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb1RyYWNrOiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCwgcm9vdCkge1xuICAgICAgICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuXG4gICAgICAgICAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0cmFja0l0ZW0gPSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXSxcbiAgICAgICAgICAgICAgICB0b3VjaGVzOiBbXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b3VjaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoID0gdG91Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gZXZlbnRVdGlsLmNsaWVudFRvTG9jYWwocm9vdCwgdG91Y2gsIHt9KTtcbiAgICAgICAgICAgICAgICB0cmFja0l0ZW0ucG9pbnRzLnB1c2goW3Bvcy56clgsIHBvcy56clldKTtcbiAgICAgICAgICAgICAgICB0cmFja0l0ZW0udG91Y2hlcy5wdXNoKHRvdWNoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdHJhY2sucHVzaCh0cmFja0l0ZW0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9yZWNvZ25pemU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHJlY29nbml6ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29nbml6ZXJzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdlc3R1cmVJbmZvID0gcmVjb2duaXplcnNbZXZlbnROYW1lXSh0aGlzLl90cmFjaywgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2VzdHVyZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXN0dXJlSW5mbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkaXN0KHBvaW50UGFpcikge1xuICAgICAgICB2YXIgZHggPSBwb2ludFBhaXJbMV1bMF0gLSBwb2ludFBhaXJbMF1bMF07XG4gICAgICAgIHZhciBkeSA9IHBvaW50UGFpclsxXVsxXSAtIHBvaW50UGFpclswXVsxXTtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjZW50ZXIocG9pbnRQYWlyKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAocG9pbnRQYWlyWzBdWzBdICsgcG9pbnRQYWlyWzFdWzBdKSAvIDIsXG4gICAgICAgICAgICAocG9pbnRQYWlyWzBdWzFdICsgcG9pbnRQYWlyWzFdWzFdKSAvIDJcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICB2YXIgcmVjb2duaXplcnMgPSB7XG5cbiAgICAgICAgcGluY2g6IGZ1bmN0aW9uICh0cmFjaywgZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0cmFja0xlbiA9IHRyYWNrLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKCF0cmFja0xlbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBpbmNoRW5kID0gKHRyYWNrW3RyYWNrTGVuIC0gMV0gfHwge30pLnBvaW50cztcbiAgICAgICAgICAgIHZhciBwaW5jaFByZSA9ICh0cmFja1t0cmFja0xlbiAtIDJdIHx8IHt9KS5wb2ludHMgfHwgcGluY2hFbmQ7XG5cbiAgICAgICAgICAgIGlmIChwaW5jaFByZVxuICAgICAgICAgICAgICAgICYmIHBpbmNoUHJlLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAmJiBwaW5jaEVuZFxuICAgICAgICAgICAgICAgICYmIHBpbmNoRW5kLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBwaW5jaFNjYWxlID0gZGlzdChwaW5jaEVuZCkgLyBkaXN0KHBpbmNoUHJlKTtcbiAgICAgICAgICAgICAgICAhaXNGaW5pdGUocGluY2hTY2FsZSkgJiYgKHBpbmNoU2NhbGUgPSAxKTtcblxuICAgICAgICAgICAgICAgIGV2ZW50LnBpbmNoU2NhbGUgPSBwaW5jaFNjYWxlO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBpbmNoQ2VudGVyID0gY2VudGVyKHBpbmNoRW5kKTtcbiAgICAgICAgICAgICAgICBldmVudC5waW5jaFggPSBwaW5jaENlbnRlclswXTtcbiAgICAgICAgICAgICAgICBldmVudC5waW5jaFkgPSBwaW5jaENlbnRlclsxXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwaW5jaCcsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdHJhY2tbMF0udGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBwaW5jaCBjdXJyZW50bHkuXG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR2VzdHVyZU1ncjtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS9HZXN0dXJlTWdyLmpzXG4gKiogbW9kdWxlIGlkID0gNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogRGVmYXVsdCBjYW52YXMgcGFpbnRlclxuICogQG1vZHVsZSB6cmVuZGVyL1BhaW50ZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbiBcblxuICAgIHZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbG9nID0gcmVxdWlyZSgnLi9jb3JlL2xvZycpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIHRpbXNvcnQgPSByZXF1aXJlKCcuL2NvcmUvdGltc29ydCcpO1xuXG4gICAgdmFyIExheWVyID0gcmVxdWlyZSgnLi9MYXllcicpO1xuXG4gICAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xuXG4gICAgLy8gUEVORElHTlxuICAgIC8vIExheWVyIGV4Y2VlZHMgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiBtYXkgaGF2ZSBzb21lIHByb2JsZW0gd2hlbiBmbHVzaCBkaXJlY3RseSBzZWNvbmQgdGltZS5cbiAgICAvL1xuICAgIC8vIE1heGltdW0gcHJvZ3Jlc3NpdmUgbGF5ZXIuIFdoZW4gZXhjZWVkaW5nIHRoaXMgbnVtYmVyLiBBbGwgZWxlbWVudHMgd2lsbCBiZSBkcmF3ZWQgaW4gdGhlIGxhc3QgbGF5ZXIuXG4gICAgdmFyIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgPSA1O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQxMCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGF5ZXJWYWxpZChsYXllcikge1xuICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihsYXllci5yZXNpemUpICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICB8fCB0eXBlb2YobGF5ZXIucmVmcmVzaCkgIT09ICdmdW5jdGlvbidcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuX191bnVzZWRDb3VudCsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc3RQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgaWYgKGxheWVyLl9fdW51c2VkQ291bnQgPT0gMSkge1xuICAgICAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICB2YXIgdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgIGZ1bmN0aW9uIGlzRGlzcGxheWFibGVDdWxsZWQoZWwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KGVsLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgaWYgKGVsLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHZpZXdSZWN0LndpZHRoID0gd2lkdGg7XG4gICAgICAgIHZpZXdSZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuICF0bXBSZWN0LmludGVyc2VjdCh2aWV3UmVjdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBwcmV2Q2xpcFBhdGhzKSB7XG4gICAgICAgIGlmIChjbGlwUGF0aHMgPT0gcHJldkNsaXBQYXRocykgeyAvLyBDYW4gYm90aCBiZSBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjbGlwUGF0aHMgfHwgIXByZXZDbGlwUGF0aHMgfHwgKGNsaXBQYXRocy5sZW5ndGggIT09IHByZXZDbGlwUGF0aHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvQ2xpcChjbGlwUGF0aHMsIGN0eCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gY2xpcFBhdGhzW2ldO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBjbGlwUGF0aC5wYXRoO1xuXG4gICAgICAgICAgICBjbGlwUGF0aC5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIHBhdGguYmVnaW5QYXRoKGN0eCk7XG4gICAgICAgICAgICBjbGlwUGF0aC5idWlsZFBhdGgocGF0aCwgY2xpcFBhdGguc2hhcGUpO1xuICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYWNrXG4gICAgICAgICAgICBjbGlwUGF0aC5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSb290KHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGRvbVJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAvLyBkb21Sb290Lm9uc2VsZWN0c3RhcnQgPSByZXR1cm5GYWxzZTsgLy8g6YG/5YWN6aG16Z2i6YCJ5Lit55qE5bC05bCsXG4gICAgICAgIGRvbVJvb3Quc3R5bGUuY3NzVGV4dCA9IFtcbiAgICAgICAgICAgICdwb3NpdGlvbjpyZWxhdGl2ZScsXG4gICAgICAgICAgICAnb3ZlcmZsb3c6aGlkZGVuJyxcbiAgICAgICAgICAgICd3aWR0aDonICsgd2lkdGggKyAncHgnLFxuICAgICAgICAgICAgJ2hlaWdodDonICsgaGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgICAgICdwYWRkaW5nOjAnLFxuICAgICAgICAgICAgJ21hcmdpbjowJyxcbiAgICAgICAgICAgICdib3JkZXItd2lkdGg6MCdcbiAgICAgICAgXS5qb2luKCc7JykgKyAnOyc7XG5cbiAgICAgICAgcmV0dXJuIGRvbVJvb3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL1BhaW50ZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290IOe7mOWbvuWuueWZqFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX0gc3RvcmFnZVxuICAgICAqIEBwYXJhbSB7T2piZWN0fSBvcHRzXG4gICAgICovXG4gICAgdmFyIFBhaW50ZXIgPSBmdW5jdGlvbiAocm9vdCwgc3RvcmFnZSwgb3B0cykge1xuICAgICAgICAvLyBJbiBub2RlIGVudmlyb25tZW50IHVzaW5nIG5vZGUtY2FudmFzXG4gICAgICAgIHZhciBzaW5nbGVDYW52YXMgPSAhcm9vdC5ub2RlTmFtZSAvLyBJbiBub2RlID9cbiAgICAgICAgICAgIHx8IHJvb3Qubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0NBTlZBUyc7XG5cbiAgICAgICAgdGhpcy5fb3B0cyA9IG9wdHMgPSB1dGlsLmV4dGVuZCh7fSwgb3B0cyB8fCB7fSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRwciA9IG9wdHMuZGV2aWNlUGl4ZWxSYXRpbyB8fCBjb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2luZ2xlQ2FudmFzID0gc2luZ2xlQ2FudmFzO1xuICAgICAgICAvKipcbiAgICAgICAgICog57uY5Zu+5a655ZmoXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG5cbiAgICAgICAgdmFyIHJvb3RTdHlsZSA9IHJvb3Quc3R5bGU7XG5cbiAgICAgICAgaWYgKHJvb3RTdHlsZSkge1xuICAgICAgICAgICAgcm9vdFN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICByb290U3R5bGVbJy13ZWJraXQtdXNlci1zZWxlY3QnXSA9XG4gICAgICAgICAgICByb290U3R5bGVbJ3VzZXItc2VsZWN0J10gPVxuICAgICAgICAgICAgcm9vdFN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcblxuICAgICAgICAgICAgcm9vdC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdCA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp6cmVuZGVyL0xheWVyPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBPYmplY3Q+fVxuICAgICAgICAgKiBAdHlwZSB7cHJpdmF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xheWVyQ29uZmlnID0ge307XG5cbiAgICAgICAgaWYgKCFzaW5nbGVDYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdGhpcy5fZ2V0U2l6ZSgwKTtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX2dldFNpemUoMSk7XG5cbiAgICAgICAgICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdCA9IGNyZWF0ZVJvb3QoXG4gICAgICAgICAgICAgICAgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoZG9tUm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAob3B0cy53aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcm9vdC53aWR0aCA9IG9wdHMud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJvb3QuaGVpZ2h0ID0gb3B0cy5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2UgY2FudmFzIHdpZHRoIGFuZCBoZWlnaHQgZGlyZWN0bHlcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJvb3Qud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcm9vdC5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgbGF5ZXIgaWYgb25seSBvbmUgZ2l2ZW4gY2FudmFzXG4gICAgICAgICAgICAvLyBEZXZpY2UgcGl4ZWwgcmF0aW8gaXMgZml4ZWQgdG8gMSBiZWNhdXNlIGdpdmVuIGNhbnZhcyBoYXMgaXRzIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgICB2YXIgbWFpbkxheWVyID0gbmV3IExheWVyKHJvb3QsIHRoaXMsIDEpO1xuICAgICAgICAgICAgbWFpbkxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgICAvLyBGSVhNRSBVc2UgY2FudmFzIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgICAgIC8vIG1haW5MYXllci5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBsYXllcnNbMF0gPSBtYWluTGF5ZXI7XG4gICAgICAgICAgICB6bGV2ZWxMaXN0LnB1c2goMCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2RvbVJvb3QgPSByb290O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGF5ZXJzIGZvciBwcm9ncmVzc2l2ZSByZW5kZXJpbmdcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL0xheWVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faG92ZXJsYXllcjtcblxuICAgICAgICB0aGlzLl9ob3ZlckVsZW1lbnRzID0gW107XG4gICAgfTtcblxuICAgIFBhaW50ZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBQYWludGVyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBwYWludGVyIHVzZSBhIHNpbmdsZSBjYW52YXNcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGlzU2luZ2xlQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2luZ2xlQ2FudmFzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7SFRNTERpdkVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRWaWV3cG9ydFJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb21Sb290O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliLfmlrBcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbcGFpbnRBbGw9ZmFsc2VdIOW8uuWItue7mOWItuaJgOaciWRpc3BsYXlhYmxlXG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoOiBmdW5jdGlvbiAocGFpbnRBbGwpIHtcblxuICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcblxuICAgICAgICAgICAgdGhpcy5fcGFpbnRMaXN0KGxpc3QsIHBhaW50QWxsKTtcblxuICAgICAgICAgICAgLy8gUGFpbnQgY3VzdHVtIGxheWVyc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcbiAgICAgICAgICAgICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fICYmIGxheWVyLnJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0UHJvZ2Vzc2l2ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRIb3ZlcjogZnVuY3Rpb24gKGVsLCBob3ZlclN0eWxlKSB7XG4gICAgICAgICAgICBpZiAoZWwuX19ob3Zlck1pcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlbE1pcnJvciA9IG5ldyBlbC5jb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICAgICAgc3R5bGU6IGVsLnN0eWxlLFxuICAgICAgICAgICAgICAgIHNoYXBlOiBlbC5zaGFwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbE1pcnJvci5fX2Zyb20gPSBlbDtcbiAgICAgICAgICAgIGVsLl9faG92ZXJNaXIgPSBlbE1pcnJvcjtcbiAgICAgICAgICAgIGVsTWlycm9yLnNldFN0eWxlKGhvdmVyU3R5bGUpO1xuICAgICAgICAgICAgdGhpcy5faG92ZXJFbGVtZW50cy5wdXNoKGVsTWlycm9yKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVIb3ZlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgZWxNaXJyb3IgPSBlbC5fX2hvdmVyTWlyO1xuICAgICAgICAgICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgICAgICAgICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZihob3ZlckVsZW1lbnRzLCBlbE1pcnJvcik7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICBob3ZlckVsZW1lbnRzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuX19ob3Zlck1pciA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJIb3ZlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvdmVyRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IGhvdmVyRWxlbWVudHNbaV0uX19mcm9tO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20uX19ob3Zlck1pciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaG92ZXJFbGVtZW50cy5sZW5ndGggPSAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlZnJlc2hIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGhvdmVyRWxlbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGhvdmVyTGF5ZXIgPSB0aGlzLl9ob3ZlcmxheWVyO1xuICAgICAgICAgICAgaG92ZXJMYXllciAmJiBob3ZlckxheWVyLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIGlmICghbGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltc29ydChob3ZlckVsZW1lbnRzLCB0aGlzLnN0b3JhZ2UuZGlzcGxheWFibGVTb3J0RnVuYyk7XG5cbiAgICAgICAgICAgIC8vIFVzZSBhIGV4dHJlYW0gbGFyZ2UgemxldmVsXG4gICAgICAgICAgICAvLyBGSVhNRT9cbiAgICAgICAgICAgIGlmICghaG92ZXJMYXllcikge1xuICAgICAgICAgICAgICAgIGhvdmVyTGF5ZXIgPSB0aGlzLl9ob3ZlcmxheWVyID0gdGhpcy5nZXRMYXllcigxZTUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICAgICAgICAgIGhvdmVyTGF5ZXIuY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGhvdmVyRWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsRWwgPSBlbC5fX2Zyb207XG4gICAgICAgICAgICAgICAgLy8gT3JpZ2luYWwgZWwgaXMgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgICAgICBpZiAoIShvcmlnaW5hbEVsICYmIG9yaWdpbmFsRWwuX196cikpIHtcbiAgICAgICAgICAgICAgICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRWwuX19ob3Zlck1pciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIC8vIEZJWE1FIHN0eWxlIGFuZCBzaGFwZSA/XG4gICAgICAgICAgICAgICAgaWYgKCFvcmlnaW5hbEVsLmludmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBlbC50cmFuc2Zvcm0gPSBvcmlnaW5hbEVsLnRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW52VHJhbnNmb3JtID0gb3JpZ2luYWxFbC5pbnZUcmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICAgIGVsLl9fY2xpcFBhdGhzID0gb3JpZ2luYWxFbC5fX2NsaXBQYXRocztcbiAgICAgICAgICAgICAgICAgICAgLy8gZWwuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgaG92ZXJMYXllciwgdHJ1ZSwgc2NvcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvdmVyTGF5ZXIuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc3RhcnRQcm9nZXNzaXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICghc2VsZi5fZnVydGhlclByb2dyZXNzaXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgYSB0b2tlbiB0byBzdG9wIHByb2dyZXNzIHN0ZXBzIHRyaWdnZXJlZCBieVxuICAgICAgICAgICAgLy8gcHJldmlvdXMgenIucmVmcmVzaCBjYWxsaW5nLlxuICAgICAgICAgICAgdmFyIHRva2VuID0gc2VsZi5fcHJvZ3Jlc3NpdmVUb2tlbiA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICAgICAgICBzZWxmLl9wcm9ncmVzcysrO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgcmVmcmVzaGVkIG9yIGRpc3Bvc2VkXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBzZWxmLl9wcm9ncmVzc2l2ZVRva2VuICYmIHNlbGYuc3RvcmFnZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2RvUGFpbnRMaXN0KHNlbGYuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fZnVydGhlclByb2dyZXNzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9wcm9ncmVzcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcHJvZ3Jlc3NpdmVUb2tlbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9jbGVhclByb2dyZXNzaXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc2l2ZVRva2VuID0gLTE7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICB1dGlsLmVhY2godGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgJiYgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9wYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0LCBwYWludEFsbCkge1xuXG4gICAgICAgICAgICBpZiAocGFpbnRBbGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhaW50QWxsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyU3RhdHVzKGxpc3QpO1xuXG4gICAgICAgICAgICB0aGlzLl9jbGVhclByb2dyZXNzaXZlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcihwcmVQcm9jZXNzTGF5ZXIpO1xuXG4gICAgICAgICAgICB0aGlzLl9kb1BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcihwb3N0UHJvY2Vzc0xheWVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZG9QYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0LCBwYWludEFsbCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRMYXllcjtcbiAgICAgICAgICAgIHZhciBjdXJyZW50WkxldmVsO1xuICAgICAgICAgICAgdmFyIGN0eDtcblxuICAgICAgICAgICAgLy8gdmFyIGludlRyYW5zZm9ybSA9IFtdO1xuICAgICAgICAgICAgdmFyIHNjb3BlO1xuXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NpdmVMYXllcklkeCA9IDA7XG4gICAgICAgICAgICB2YXIgY3VycmVudFByb2dyZXNzaXZlTGF5ZXI7XG5cbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgICAgIHZhciBsYXllclByb2dyZXNzO1xuICAgICAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5fcHJvZ3Jlc3M7XG4gICAgICAgICAgICBmdW5jdGlvbiBmbHVzaFByb2dyZXNzaXZlTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgbGF5ZXIgZG9uJ3QgY2xlYXIgaW4gbmV4dCBwcm9ncmVzc2l2ZSBmcmFtZVxuICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UobGF5ZXIuZG9tLCAwLCAwLCB3aWR0aCAqIGRwciwgaGVpZ2h0ICogZHByKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgZWxaTGV2ZWwgPSB0aGlzLl9zaW5nbGVDYW52YXMgPyAwIDogZWwuemxldmVsO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVsRnJhbWUgPSBlbC5fX2ZyYW1lO1xuXG4gICAgICAgICAgICAgICAgLy8gRmx1c2ggYXQgY3VycmVudCBjb250ZXh0XG4gICAgICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgICAgIGlmIChlbEZyYW1lIDwgMCAmJiBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgICAgICAgICBmbHVzaFByb2dyZXNzaXZlTGF5ZXIoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hhbmdlIGRyYXcgbGF5ZXJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFpMZXZlbCAhPT0gZWxaTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHNjb3BlXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSAwIHpsZXZlbCBpZiBvbmx5IGhhcyBvbmUgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRaTGV2ZWwgPSBlbFpMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExheWVyID0gdGhpcy5nZXRMYXllcihjdXJyZW50WkxldmVsKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRMYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdaTGV2ZWwgJyArIGN1cnJlbnRaTGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArICcgaGFzIGJlZW4gdXNlZCBieSB1bmtvd24gbGF5ZXIgJyArIGN1cnJlbnRMYXllci5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IGN1cnJlbnRMYXllci5jdHg7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNvdW50XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllci5fX3VudXNlZENvdW50ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudExheWVyLl9fZGlydHkgfHwgcGFpbnRBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllci5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEoY3VycmVudExheWVyLl9fZGlydHkgfHwgcGFpbnRBbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlbEZyYW1lID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvZ3Jlc3NpdmUgbGF5ZXIgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKHByb2dyZXNzaXZlTGF5ZXJJZHgrKywgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiAtIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5jdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIucmVuZGVyU2NvcGUgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MgPiBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBRdWljayBqdW1wIGFsbCBwcm9ncmVzc2l2ZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBwcm9ncmVzc2l2ZSBlbGVtZW50IGFyZSBub3QgZGlydHksIGp1bXAgb3ZlciBhbmQgZmx1c2ggZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19uZXh0SWR4Tm90UHJvZyAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllclByb2dyZXNzID0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCByZW5kZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGxheWVyUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3MgPSBmcmFtZSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxGcmFtZSA9PT0gZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIsIHRydWUsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLnJlbmRlclNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBjdXJyZW50TGF5ZXIsIHBhaW50QWxsLCBzY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWwuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBmbHVzaFByb2dyZXNzaXZlTGF5ZXIoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBsYXN0TGF5ZXIgY3R4XG4gICAgICAgICAgICBjdHggJiYgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIC8vIElmIHN0aWxsIGhhcyBjbGlwcGluZyBzdGF0ZVxuICAgICAgICAgICAgLy8gaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgICAgICAgICAgLy8gICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBsYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Z1cnRoZXJQcm9ncmVzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvUGFpbnRFbDogZnVuY3Rpb24gKGVsLCBjdXJyZW50TGF5ZXIsIGZvcmNlUGFpbnQsIHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gY3VycmVudExheWVyLmN0eDtcbiAgICAgICAgICAgIHZhciBtID0gZWwudHJhbnNmb3JtO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBmb3JjZVBhaW50KVxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBpbnZpc2libGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICYmICFlbC5pbnZpc2libGVcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdHJhbnNwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgICYmIGVsLnN0eWxlLm9wYWNpdHkgIT09IDBcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgc2NhbGUgMCBlbGVtZW50LCBpbiBzb21lIGVudmlyb25tZW50IGxpa2Ugbm9kZS1jYW52YXNcbiAgICAgICAgICAgICAgICAvLyBEcmF3IGEgc2NhbGUgMCBlbGVtZW50IGNhbiBjYXVzZSBhbGwgZm9sbG93aW5nIGRyYXcgd3JvbmdcbiAgICAgICAgICAgICAgICAvLyBBbmQgc2V0VHJhbnNmb3JtIHdpdGggc2NhbGUgMCB3aWxsIGNhdXNlIHNldCBiYWNrIHRyYW5zZm9ybSBmYWlsZWQuXG4gICAgICAgICAgICAgICAgJiYgIShtICYmICFtWzBdICYmICFtWzNdKVxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBjdWxsZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgICYmICEoZWwuY3VsbGluZyAmJiBpc0Rpc3BsYXlhYmxlQ3VsbGVkKGVsLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KSlcbiAgICAgICAgICAgICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNsaXBQYXRocyA9IGVsLl9fY2xpcFBhdGhzO1xuXG4gICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgd2hlbiBjbGlwcGluZyBvbiBncm91cCB3aXRoIHNldmVyYWwgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUucHJldkNsaXBMYXllciAhPT0gY3VycmVudExheWVyXG4gICAgICAgICAgICAgICAgICAgIHx8IGlzQ2xpcFBhdGhDaGFuZ2VkKGNsaXBQYXRocywgc2NvcGUucHJldkVsQ2xpcFBhdGhzKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBoYXMgcHJldmlvdXMgY2xpcHBpbmcgc3RhdGUsIHJlc3RvcmUgZnJvbSBpdFxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUucHJldkVsQ2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyID0gc2NvcGUucHJldkVsQ2xpcFBhdGhzID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgcHJldkVsIHNpbmNlIGNvbnRleHQgaGFzIGJlZW4gcmVzdG9yZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZFbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTmV3IGNsaXBwaW5nIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb0NsaXAoY2xpcFBhdGhzLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IGN1cnJlbnRMYXllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZFbENsaXBQYXRocyA9IGNsaXBQYXRocztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaChjdHgpO1xuXG4gICAgICAgICAgICAgICAgZWwuYnJ1c2goY3R4LCBzY29wZS5wcmV2RWwgfHwgbnVsbCk7XG4gICAgICAgICAgICAgICAgc2NvcGUucHJldkVsID0gZWw7XG5cbiAgICAgICAgICAgICAgICBlbC5hZnRlckJydXNoICYmIGVsLmFmdGVyQnJ1c2goY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+WIHpsZXZlbCDmiYDlnKjlsYLvvIzlpoLmnpzkuI3lrZjlnKjliJnkvJrliJvlu7rkuIDkuKrmlrDnmoTlsYJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9MYXllcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldExheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2luZ2xlQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG4gICAgICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxheWVyXG4gICAgICAgICAgICAgICAgbGF5ZXIgPSBuZXcgTGF5ZXIoJ3pyXycgKyB6bGV2ZWwsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgICAgICAgICAgICBsYXllci5fX2J1aWx0aW5fXyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLm1lcmdlKGxheWVyLCB0aGlzLl9sYXllckNvbmZpZ1t6bGV2ZWxdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydExheWVyKHpsZXZlbCwgbGF5ZXIpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGFmdGVyIGRvbSBpbnNlcnRlZCB0byBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC8vIE9yIGV4Y2FudmFzIHdpbGwgZ2V0IDBweCBjbGllbnRXaWR0aCBhbmQgY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgbGF5ZXIuaW5pdENvbnRleHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluc2VydExheWVyOiBmdW5jdGlvbiAoemxldmVsLCBsYXllcikge1xuXG4gICAgICAgICAgICB2YXIgbGF5ZXJzTWFwID0gdGhpcy5fbGF5ZXJzO1xuICAgICAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICAgICAgdmFyIGxlbiA9IHpsZXZlbExpc3QubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHByZXZMYXllciA9IG51bGw7XG4gICAgICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICAgICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290O1xuXG4gICAgICAgICAgICBpZiAobGF5ZXJzTWFwW3psZXZlbF0pIHtcbiAgICAgICAgICAgICAgICBsb2coJ1pMZXZlbCAnICsgemxldmVsICsgJyBoYXMgYmVlbiB1c2VkIGFscmVhZHknKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpcyBhIHZhbGlkIGxheWVyXG4gICAgICAgICAgICBpZiAoIWlzTGF5ZXJWYWxpZChsYXllcikpIHtcbiAgICAgICAgICAgICAgICBsb2coJ0xheWVyIG9mIHpsZXZlbCAnICsgemxldmVsICsgJyBpcyBub3QgdmFsaWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW4gPiAwICYmIHpsZXZlbCA+IHpsZXZlbExpc3RbMF0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHpsZXZlbExpc3RbaV0gPCB6bGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHpsZXZlbExpc3RbaSArIDFdID4gemxldmVsXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldkxheWVyID0gbGF5ZXJzTWFwW3psZXZlbExpc3RbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgemxldmVsTGlzdC5zcGxpY2UoaSArIDEsIDAsIHpsZXZlbCk7XG5cbiAgICAgICAgICAgIGxheWVyc01hcFt6bGV2ZWxdID0gbGF5ZXI7XG5cbiAgICAgICAgICAgIC8vIFZpdHVhbCBsYXllciB3aWxsIG5vdCBkaXJlY3RseSBzaG93IG9uIHRoZSBzY3JlZW4uXG4gICAgICAgICAgICAvLyAoSXQgY2FuIGJlIGEgV2ViR0wgbGF5ZXIgYW5kIGFzc2lnbmVkIHRvIGEgWkltYWdlIGVsZW1lbnQpXG4gICAgICAgICAgICAvLyBCdXQgaXQgc3RpbGwgdW5kZXIgbWFuYWdlbWVudCBvZiB6cmVuZGVyLlxuICAgICAgICAgICAgaWYgKCFsYXllci52aXJ0dWFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZMYXllcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldkRvbSA9IHByZXZMYXllci5kb207XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2RG9tLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Sb290Lmluc2VydEJlZm9yZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllci5kb20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldkRvbS5uZXh0U2libGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbVJvb3QuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5pbnNlcnRCZWZvcmUobGF5ZXIuZG9tLCBkb21Sb290LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5hcHBlbmRDaGlsZChsYXllci5kb20pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEl0ZXJhdGUgZWFjaCBsYXllclxuICAgICAgICBlYWNoTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICAgICAgdmFyIHo7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbel0sIHopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEl0ZXJhdGUgZWFjaCBidWlsZGluIGxheWVyXG4gICAgICAgIGVhY2hCdWlsdGluTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICAgICAgdmFyIGxheWVyO1xuICAgICAgICAgICAgdmFyIHo7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgICAgICAgICAgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgbGF5ZXIsIHopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdGVyYXRlIGVhY2ggb3RoZXIgbGF5ZXIgZXhjZXB0IGJ1aWxkaW4gbGF5ZXJcbiAgICAgICAgZWFjaE90aGVyTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICAgICAgdmFyIGxheWVyO1xuICAgICAgICAgICAgdmFyIHo7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgICAgICAgICAgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGxheWVyLCB6KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluaJgOacieW3suWIm+W7uueahOWxglxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9MYXllcj59IFtwcmV2TGF5ZXJdXG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXllcnM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZUxheWVyU3RhdHVzOiBmdW5jdGlvbiAobGlzdCkge1xuXG4gICAgICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgICAgICAgICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJzID0gdGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnM7XG5cbiAgICAgICAgICAgIHZhciBlbENvdW50c0xhc3RGcmFtZSA9IHt9O1xuICAgICAgICAgICAgdmFyIHByb2dyZXNzaXZlRWxDb3VudHNMYXN0RnJhbWUgPSB7fTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKGZ1bmN0aW9uIChsYXllciwgeikge1xuICAgICAgICAgICAgICAgIGVsQ291bnRzTGFzdEZyYW1lW3pdID0gbGF5ZXIuZWxDb3VudDtcbiAgICAgICAgICAgICAgICBsYXllci5lbENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBsYXllci5fX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdXRpbC5lYWNoKHByb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIsIGlkeCkge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzaXZlRWxDb3VudHNMYXN0RnJhbWVbaWR4XSA9IGxheWVyLmVsQ291bnQ7XG4gICAgICAgICAgICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUxheWVyQ291bnQgPSAwO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyO1xuICAgICAgICAgICAgdmFyIGxhc3RQcm9ncmVzc2l2ZUtleTtcbiAgICAgICAgICAgIHZhciBmcmFtZUNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBsaXN0W2ldO1xuICAgICAgICAgICAgICAgIHZhciB6bGV2ZWwgPSB0aGlzLl9zaW5nbGVDYW52YXMgPyAwIDogZWwuemxldmVsO1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgICAgIHZhciBlbFByb2dyZXNzID0gZWwucHJvZ3Jlc3NpdmU7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLmVsQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IGxheWVyLl9fZGlydHkgfHwgZWwuX19kaXJ0eTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLy8vLy8vIFVwZGF0ZSBwcm9ncmVzc2l2ZVxuICAgICAgICAgICAgICAgIGlmIChlbFByb2dyZXNzID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IHdyb25nIHByb2dyZXNzaXZlIHNlcXVlbmNlIHByb2JsZW0uXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0UHJvZ3Jlc3NpdmVLZXkgIT09IGVsUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQcm9ncmVzc2l2ZUtleSA9IGVsUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsRnJhbWUgPSBlbC5fX2ZyYW1lID0gZnJhbWVDb3VudCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVyQ291bnQsIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gcHJvZ3Jlc3NpdmVMYXllcnNbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHByb2dyZXNzaXZlTGF5ZXJzW2lkeF0gPSBuZXcgTGF5ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwcm9ncmVzc2l2ZScsIHRoaXMsIHRoaXMuZHByXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5pbml0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19kaXJ0eSA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fZGlydHkgfHwgZWwuX19kaXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuZWxDb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MsIGVsRnJhbWVcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQga2VlcCByZW5kZXJpbmcgdGhpcyAgbGF5ZXIgYmVjYXVzZSBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgaXMgbm90IGZpbmlzaGVkIHlldFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLl9fZnJhbWUgPSAtMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NpdmVMYXllckNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJDb3VudCsrO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgPSBpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDlsYLkuK3nmoTlhYPntKDmlbDph4/mnInlj5HnlJ/lj5jljJZcbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcihmdW5jdGlvbiAobGF5ZXIsIHopIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxDb3VudHNMYXN0RnJhbWVbel0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJzLmxlbmd0aCA9IE1hdGgubWluKHByb2dyZXNzaXZlTGF5ZXJDb3VudCwgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUik7XG4gICAgICAgICAgICB1dGlsLmVhY2gocHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllciwgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzaXZlRWxDb3VudHNMYXN0RnJhbWVbaWR4XSAhPT0gbGF5ZXIuZWxDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuX19wcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4hemZpGhvdmVy5bGC5aSW5omA5pyJ5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKHRoaXMuX2NsZWFyTGF5ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NsZWFyTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5L+u5pS55oyH5a6aemxldmVs55qE57uY5Yi25Y+C5pWwXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB6bGV2ZWxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyDphY3nva7lr7nosaFcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSDmr4/mrKHmuIXnqbrnlLvluIPnmoTpopzoibJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubW90aW9uQmx1cj1mYWxzZV0g5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmxhc3RGcmFtZUFscGhhPTAuN11cbiAgICAgICAgICogICAgICAgICAgICAgICAgIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAgICAgICAqL1xuICAgICAgICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyQ29uZmlnID0gdGhpcy5fbGF5ZXJDb25maWc7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllckNvbmZpZ1t6bGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnW3psZXZlbF0gPSBjb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLm1lcmdlKGxheWVyQ29uZmlnW3psZXZlbF0sIGNvbmZpZywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG5cbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllciwgbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTmjIflrprlsYJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbCDlsYLmiYDlnKjnmoR6bGV2ZWxcbiAgICAgICAgICovXG4gICAgICAgIGRlbExheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgICAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW3psZXZlbF07XG4gICAgICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5ZXIuZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgICAgIGRlbGV0ZSBsYXllcnNbemxldmVsXTtcblxuICAgICAgICAgICAgemxldmVsTGlzdC5zcGxpY2UodXRpbC5pbmRleE9mKHpsZXZlbExpc3QsIHpsZXZlbCksIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDljLrln5/lpKflsI/lj5jljJblkI7ph43nu5hcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdDtcbiAgICAgICAgICAgIC8vIEZJWE1FIFdoeSA/XG4gICAgICAgICAgICBkb21Sb290LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgaW5wdXQgdy9oXG4gICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMuX29wdHM7XG4gICAgICAgICAgICB3aWR0aCAhPSBudWxsICYmIChvcHRzLndpZHRoID0gd2lkdGgpO1xuICAgICAgICAgICAgaGVpZ2h0ICE9IG51bGwgJiYgKG9wdHMuaGVpZ2h0ID0gaGVpZ2h0KTtcblxuICAgICAgICAgICAgd2lkdGggPSB0aGlzLl9nZXRTaXplKDApO1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5fZ2V0U2l6ZSgxKTtcblxuICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICAgICAgICAgIC8vIOS8mOWMluayoeacieWunumZheaUueWPmOeahHJlc2l6ZVxuICAgICAgICAgICAgaWYgKHRoaXMuX3dpZHRoICE9IHdpZHRoIHx8IGhlaWdodCAhPSB0aGlzLl9oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBkb21Sb290LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgIGRvbVJvb3Quc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGF5ZXJzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF6Zmk5Y2V54us55qE5LiA5Liq5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6YeK5pS+XG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgICAgIHRoaXMucm9vdCA9XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPVxuXG4gICAgICAgICAgICB0aGlzLl9kb21Sb290ID1cbiAgICAgICAgICAgIHRoaXMuX2xheWVycyA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UmVuZGVyZWRDYW52YXM6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaW5nbGVDYW52YXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzWzBdLmRvbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGltYWdlTGF5ZXIgPSBuZXcgTGF5ZXIoJ2ltYWdlJywgdGhpcywgb3B0cy5waXhlbFJhdGlvIHx8IHRoaXMuZHByKTtcbiAgICAgICAgICAgIGltYWdlTGF5ZXIuaW5pdENvbnRleHQoKTtcblxuICAgICAgICAgICAgaW1hZ2VMYXllci5jbGVhckNvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICBpbWFnZUxheWVyLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIHZhciBkaXNwbGF5TGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcblxuICAgICAgICAgICAgdmFyIHNjb3BlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZGlzcGxheUxpc3RbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBpbWFnZUxheWVyLCB0cnVlLCBzY29wZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbWFnZUxheWVyLmRvbTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPlue7mOWbvuWMuuWfn+WuveW6plxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W57uY5Zu+5Yy65Z+f6auY5bqmXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFNpemU6IGZ1bmN0aW9uICh3aElkeCkge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgICAgICAgICAgdmFyIHdoID0gWyd3aWR0aCcsICdoZWlnaHQnXVt3aElkeF07XG4gICAgICAgICAgICB2YXIgY3doID0gWydjbGllbnRXaWR0aCcsICdjbGllbnRIZWlnaHQnXVt3aElkeF07XG4gICAgICAgICAgICB2YXIgcGx0ID0gWydwYWRkaW5nTGVmdCcsICdwYWRkaW5nVG9wJ11bd2hJZHhdO1xuICAgICAgICAgICAgdmFyIHByYiA9IFsncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdCb3R0b20nXVt3aElkeF07XG5cbiAgICAgICAgICAgIGlmIChvcHRzW3doXSAhPSBudWxsICYmIG9wdHNbd2hdICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChvcHRzW3doXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgICAgICAgICAgdmFyIHN0bCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUocm9vdCk7XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKHJvb3RbY3doXSB8fCBwYXJzZUludDEwKHN0bFt3aF0pIHx8IHBhcnNlSW50MTAocm9vdC5zdHlsZVt3aF0pKVxuICAgICAgICAgICAgICAgIC0gKHBhcnNlSW50MTAoc3RsW3BsdF0pIHx8IDApXG4gICAgICAgICAgICAgICAgLSAocGFyc2VJbnQxMChzdGxbcHJiXSkgfHwgMClcbiAgICAgICAgICAgICkgfCAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhdGhUb0ltYWdlOiBmdW5jdGlvbiAocGF0aCwgZHByKSB7XG4gICAgICAgICAgICBkcHIgPSBkcHIgfHwgdGhpcy5kcHI7XG5cbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHBhdGguc3R5bGU7XG4gICAgICAgICAgICB2YXIgc2hhZG93Qmx1clNpemUgPSBzdHlsZS5zaGFkb3dCbHVyO1xuICAgICAgICAgICAgdmFyIHNoYWRvd09mZnNldFggPSBzdHlsZS5zaGFkb3dPZmZzZXRYO1xuICAgICAgICAgICAgdmFyIHNoYWRvd09mZnNldFkgPSBzdHlsZS5zaGFkb3dPZmZzZXRZO1xuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmhhc1N0cm9rZSgpID8gc3R5bGUubGluZVdpZHRoIDogMDtcblxuICAgICAgICAgICAgdmFyIGxlZnRNYXJnaW4gPSBNYXRoLm1heChsaW5lV2lkdGggLyAyLCAtc2hhZG93T2Zmc2V0WCArIHNoYWRvd0JsdXJTaXplKTtcbiAgICAgICAgICAgIHZhciByaWdodE1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIHNoYWRvd09mZnNldFggKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgICAgICAgICB2YXIgdG9wTWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgLXNoYWRvd09mZnNldFkgKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgICAgICAgICB2YXIgYm90dG9tTWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgc2hhZG93T2Zmc2V0WSArIHNoYWRvd0JsdXJTaXplKTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGggKyBsZWZ0TWFyZ2luICsgcmlnaHRNYXJnaW47XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKyB0b3BNYXJnaW4gKyBib3R0b21NYXJnaW47XG5cbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAgICAgY3R4LnNjYWxlKGRwciwgZHByKTtcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBjdHguZHByID0gZHByO1xuXG4gICAgICAgICAgICB2YXIgcGF0aFRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcGF0aC5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogcGF0aC5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICBzY2FsZTogcGF0aC5zY2FsZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhdGgucG9zaXRpb24gPSBbbGVmdE1hcmdpbiAtIHJlY3QueCwgdG9wTWFyZ2luIC0gcmVjdC55XTtcbiAgICAgICAgICAgIHBhdGgucm90YXRpb24gPSAwO1xuICAgICAgICAgICAgcGF0aC5zY2FsZSA9IFsxLCAxXTtcbiAgICAgICAgICAgIHBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHBhdGguYnJ1c2goY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIEltYWdlU2hhcGUgPSByZXF1aXJlKCcuL2dyYXBoaWMvSW1hZ2UnKTtcbiAgICAgICAgICAgIHZhciBpbWdTaGFwZSA9IG5ldyBJbWFnZVNoYXBlKHtcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogY2FudmFzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChwYXRoVHJhbnNmb3JtLnBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbWdTaGFwZS5wb3NpdGlvbiA9IHBhdGgucG9zaXRpb24gPSBwYXRoVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGF0aFRyYW5zZm9ybS5yb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW1nU2hhcGUucm90YXRpb24gPSBwYXRoLnJvdGF0aW9uID0gcGF0aFRyYW5zZm9ybS5yb3RhdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhdGhUcmFuc2Zvcm0uc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGltZ1NoYXBlLnNjYWxlID0gcGF0aC5zY2FsZSA9IHBhdGhUcmFuc2Zvcm0uc2NhbGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbWdTaGFwZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhaW50ZXI7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL1BhaW50ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvTGF5ZXJcbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuICAgIHZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuICAgIHZhciBTdHlsZSA9IHJlcXVpcmUoJy4vZ3JhcGhpYy9TdHlsZScpO1xuICAgIHZhciBQYXR0ZXJuID0gcmVxdWlyZSgnLi9ncmFwaGljL1BhdHRlcm4nKTtcblxuICAgIGZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Yib5bu6ZG9tXG4gICAgICpcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgZG9tIGlkIOW+heeUqFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGRvbSB0eXBl77yMc3VjaCBhcyBjYW52YXMsIGRpdiBldGMuXG4gICAgICogQHBhcmFtIHtQYWludGVyfSBwYWludGVyIHBhaW50ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRG9tKGlkLCB0eXBlLCBwYWludGVyLCBkcHIpIHtcbiAgICAgICAgdmFyIG5ld0RvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgICAgIHZhciB3aWR0aCA9IHBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgdmFyIG5ld0RvbVN0eWxlID0gbmV3RG9tLnN0eWxlO1xuICAgICAgICAvLyDmsqFhcHBlbmTlkaLvvIzor7fljp/osIXmiJHov5nmoLflhpnvvIzmuIXmmbB+XG4gICAgICAgIG5ld0RvbVN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgbmV3RG9tU3R5bGUubGVmdCA9IDA7XG4gICAgICAgIG5ld0RvbVN0eWxlLnRvcCA9IDA7XG4gICAgICAgIG5ld0RvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICBuZXdEb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICBuZXdEb20ud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgbmV3RG9tLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAvLyBpZOS4jeS9nOS4uue0ouW8leeUqO+8jOmBv+WFjeWPr+iDvemAoOaIkOeahOmHjeWQje+8jOWumuS5ieS4uuengeacieWxnuaAp1xuICAgICAgICBuZXdEb20uc2V0QXR0cmlidXRlKCdkYXRhLXpyLWRvbS1pZCcsIGlkKTtcbiAgICAgICAgcmV0dXJuIG5ld0RvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvTGF5ZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9QYWludGVyfSBwYWludGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkcHJdXG4gICAgICovXG4gICAgdmFyIExheWVyID0gZnVuY3Rpb24oaWQsIHBhaW50ZXIsIGRwcikge1xuICAgICAgICB2YXIgZG9tO1xuICAgICAgICBkcHIgPSBkcHIgfHwgY29uZmlnLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkb20gPSBjcmVhdGVEb20oaWQsICdjYW52YXMnLCBwYWludGVyLCBkcHIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCB1c2luZyBpc0RvbSBiZWNhdXNlIGluIG5vZGUgaXQgd2lsbCByZXR1cm4gZmFsc2VcbiAgICAgICAgZWxzZSBpZiAodXRpbC5pc09iamVjdChpZCkpIHtcbiAgICAgICAgICAgIGRvbSA9IGlkO1xuICAgICAgICAgICAgaWQgPSBkb20uaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcblxuICAgICAgICB2YXIgZG9tU3R5bGUgPSBkb20uc3R5bGU7XG4gICAgICAgIGlmIChkb21TdHlsZSkgeyAvLyBOb3QgaW4gbm9kZVxuICAgICAgICAgICAgZG9tLm9uc2VsZWN0c3RhcnQgPSByZXR1cm5GYWxzZTsgLy8g6YG/5YWN6aG16Z2i6YCJ5Lit55qE5bC05bCsXG4gICAgICAgICAgICBkb21TdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID0gJ25vbmUnO1xuICAgICAgICAgICAgZG9tU3R5bGVbJ3VzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgICAgICAgICBkb21TdHlsZVsnLXdlYmtpdC10b3VjaC1jYWxsb3V0J10gPSAnbm9uZSc7XG4gICAgICAgICAgICBkb21TdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgICAgICBkb21TdHlsZVsncGFkZGluZyddID0gMDtcbiAgICAgICAgICAgIGRvbVN0eWxlWydtYXJnaW4nXSA9IDA7XG4gICAgICAgICAgICBkb21TdHlsZVsnYm9yZGVyLXdpZHRoJ10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kb21CYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdHhCYWNrID0gbnVsbDtcblxuICAgICAgICB0aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuXG4gICAgICAgIHRoaXMuY29uZmlnID0gbnVsbDtcblxuICAgICAgICAvLyBDb25maWdzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmr4/mrKHmuIXnqbrnlLvluIPnmoTpopzoibJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhckNvbG9yID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuW8gOWQr+WKqOaAgeaooeezilxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW90aW9uQmx1ciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICog5Zyo5byA5ZCv5Yqo5oCB5qih57OK55qE5pe25YCZ5L2/55So77yM5LiO5LiK5LiA5bin5re35ZCI55qEYWxwaGHlgLzvvIzlgLzotorlpKflsL7ov7notormmI7mmL5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMC43XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RGcmFtZUFscGhhID0gMC43O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMYXllciBkcHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHByID0gZHByO1xuICAgIH07XG5cbiAgICBMYXllci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IExheWVyLFxuXG4gICAgICAgIGVsQ291bnQ6IDAsXG5cbiAgICAgICAgX19kaXJ0eTogdHJ1ZSxcblxuICAgICAgICBpbml0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jdHggPSB0aGlzLmRvbS5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICB0aGlzLmN0eC5kcHIgPSB0aGlzLmRwcjtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVCYWNrQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZHByID0gdGhpcy5kcHI7XG5cbiAgICAgICAgICAgIHRoaXMuZG9tQmFjayA9IGNyZWF0ZURvbSgnYmFjay0nICsgdGhpcy5pZCwgJ2NhbnZhcycsIHRoaXMucGFpbnRlciwgZHByKTtcbiAgICAgICAgICAgIHRoaXMuY3R4QmFjayA9IHRoaXMuZG9tQmFjay5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICBpZiAoZHByICE9IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gaGVpZ2h0XG4gICAgICAgICAqL1xuICAgICAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgZHByID0gdGhpcy5kcHI7XG5cbiAgICAgICAgICAgIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgICAgICAgICAgIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgICAgICAgICAgIHZhciBkb21CYWNrID0gdGhpcy5kb21CYWNrO1xuXG4gICAgICAgICAgICBkb21TdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIGRvbVN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICAgICAgICAgIGRvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICAgICAgZG9tLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAgICAgaWYgKGRvbUJhY2spIHtcbiAgICAgICAgICAgICAgICBkb21CYWNrLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgICAgICAgICAgZG9tQmFjay5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICAgICAgICAgICAgICBpZiAoZHByICE9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHhCYWNrLnNjYWxlKGRwciwgZHByKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4heepuuivpeWxgueUu+W4g1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyQWxsIENsZWFyIGFsbCB3aXRoIG91dCBtb3Rpb24gYmx1clxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uIChjbGVhckFsbCkge1xuICAgICAgICAgICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gZG9tLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGRvbS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBjbGVhckNvbG9yID0gdGhpcy5jbGVhckNvbG9yO1xuICAgICAgICAgICAgdmFyIGhhdmVNb3Rpb25CTHVyID0gdGhpcy5tb3Rpb25CbHVyICYmICFjbGVhckFsbDtcbiAgICAgICAgICAgIHZhciBsYXN0RnJhbWVBbHBoYSA9IHRoaXMubGFzdEZyYW1lQWxwaGE7XG5cbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgaWYgKGhhdmVNb3Rpb25CTHVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRvbUJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVCYWNrQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jdHhCYWNrLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcbiAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgICAgICBkb20sIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoIC8gZHByLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgLyBkcHJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgaWYgKGNsZWFyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuO1xuICAgICAgICAgICAgICAgIC8vIEdyYWRpZW50XG4gICAgICAgICAgICAgICAgaWYgKGNsZWFyQ29sb3IuY29sb3JTdG9wcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSBjYW52YXMgZ3JhZGllbnRcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuID0gY2xlYXJDb2xvci5fX2NhbnZhc0dyYWRpZW50IHx8IFN0eWxlLmdldEdyYWRpZW50KGN0eCwgY2xlYXJDb2xvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yLl9fY2FudmFzR3JhZGllbnQgPSBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhdHRlcm5cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbGVhckNvbG9yLmltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiA9IFBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm4uY2FsbChjbGVhckNvbG9yLCBjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gfHwgY2xlYXJDb2xvcjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhdmVNb3Rpb25CTHVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbUJhY2sgPSB0aGlzLmRvbUJhY2s7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBsYXN0RnJhbWVBbHBoYTtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGRvbUJhY2ssIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMYXllcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL0xheWVyLmpzXG4gKiogbW9kdWxlIGlkID0gNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKi9cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1wiKTtcclxuICAgIHZhciBCUE1OTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvQlBNTk5vZGUuanNcIik7XHJcbiAgICB2YXIgQlBNTk1vZGVsID0gcmVxdWlyZShcIi4vbW9kZWwvQlBNTk1vZGVsLmpzXCIpO1xyXG4gICAgdmFyIFN0YXJ0RXZlbnROb2RlID0gcmVxdWlyZShcIi4vbm9kZS9ldmVudC9TdGFydEV2ZW50Tm9kZVwiKTtcclxuICAgIHZhciBFbmRFdmVudE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL2V2ZW50L0VuZEV2ZW50Tm9kZVwiKTtcclxuICAgIHZhciBVc2VyVGFza05vZGUgPSByZXF1aXJlKFwiLi9ub2RlL3Rhc2svVXNlclRhc2tOb2RlXCIpO1xyXG4gICAgdmFyIE1hbnVhbFRhc2tOb2RlID0gcmVxdWlyZShcIi4vbm9kZS90YXNrL01hbnVhbFRhc2tOb2RlXCIpO1xyXG4gICAgdmFyIFNjcmlwdFRhc2tOb2RlID0gcmVxdWlyZShcIi4vbm9kZS90YXNrL1NjcmlwdFRhc2tOb2RlXCIpO1xyXG4gICAgdmFyIE1haWxUYXNrTm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvdGFzay9NYWlsVGFza05vZGVcIik7XHJcbiAgICB2YXIgQ2F0Y2hUaW1lckV2ZW50Tm9kZSA9IHJlcXVpcmUoXCIuL25vZGUvZXZlbnQvYm91bmRhcnlldmVudC9DYXRjaFRpbWVyRXZlbnROb2RlXCIpO1xyXG4gICAgdmFyIENhdGNoU2lnbmFsRXZlbnROb2RlID0gcmVxdWlyZShcIi4vbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L0NhdGNoU2lnbmFsRXZlbnROb2RlXCIpO1xyXG4gICAgdmFyIFRocm93U2lnbmFsRXZlbnROb2RlID0gcmVxdWlyZShcIi4vbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L1Rocm93U2lnbmFsRXZlbnROb2RlXCIpO1xyXG4gICAgdmFyIEluY2x1c2l2ZUdhdGV3YXlOb2RlID0gcmVxdWlyZShcIi4vbm9kZS9nYXRld2F5L0luY2x1c2l2ZUdhdGV3YXlOb2RlXCIpO1xyXG4gICAgdmFyIEV4Y2x1c2l2ZUdhdGV3YXlOb2RlID0gcmVxdWlyZShcIi4vbm9kZS9nYXRld2F5L0V4Y2x1c2l2ZUdhdGV3YXlOb2RlXCIpO1xyXG4gICAgdmFyIFBhcmFsbGVsR2F0ZXdheU5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL2dhdGV3YXkvUGFyYWxsZWxHYXRld2F5Tm9kZVwiKTtcclxuICAgIHZhciBTdWJQcmNlc3NOb2RlID0gcmVxdWlyZShcIi4vbm9kZS9TdWJQcm9jZXNzTm9kZVwiKTtcclxuICAgIHZhciBCcG1uID0gcmVxdWlyZShcIi4vQnBtbi5qc1wiKTtcclxuICAgIC8qKlxyXG4gICAgICog5qC55o2u57uT54K55pWw57uEIOWvvOWHukpTT07moLzlvI/nmoTmlbDmja5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBub2RlcyDnu5PngrnmlbDnu4RcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBicG1uTW9kZWwgYnBtbueahG1vZGVsXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25uZWN0b3JzIOaJgOaciei/nue6v1xyXG4gICAgICogQHJldHVybiB7SlNPTn0gSlNPTuagvOW8j+eahOaVsOaNrlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0pzb24oYnBtbk1vZGVsLCBub2RlcywgY29ubmVjdG9ycykge1xyXG4gICAgICAgIHZhciBqc29uQXJyID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAvL+WOu+aOieWtkOa1geeoi+mHjOmdoueahOiKgueCuVxyXG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgQnBtbi5pc1N1YlByb2Nlc3Mobm9kZS5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiggbm9kZSAmJiBub2RlLnRvSlNPTikge1xyXG4gICAgICAgICAgICAgICAganNvbkFyci5wdXNoKG5vZGUudG9KU09OKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5aKe5Yqg57q/XHJcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGNvbm5lY3RvcnMubGVuZ3RoO2orKyl7XHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3IgPSBjb25uZWN0b3JzW2pdO1xyXG4gICAgICAgICAgICAvL+WOu+aOieWtkOa1geeoi+mHjOmdoueahOe6v+autVxyXG4gICAgICAgICAgICBpZiAoY29ubmVjdG9yLnBhcmVudCAmJiBCcG1uLmlzU3ViUHJvY2Vzcyhjb25uZWN0b3IucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIGNvbm5lY3RvciAmJiBjb25uZWN0b3IudG9KU09OKSB7XHJcbiAgICAgICAgICAgICAgICBqc29uQXJyLnB1c2goY29ubmVjdG9yLnRvSlNPTigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBicG1uTW9kZWwuc2V0KFwiY2hpbGRTaGFwZXNcIiwganNvbkFycik7XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gYnBtbk1vZGVsLm9wdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNriBKU09OIOeUn+aIkOiKgueCuVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBmaXNoVG9wb0JwbW4gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBqc29uICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tSnNvbihmaXNoVG9wb0JwbW4sIGpzb24pIHtcclxuICAgICAgICAvLyAxLua4heepuueUu+W4g1xyXG4gICAgICAgIGZpc2hUb3BvQnBtbi5jbGVhcih0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gMi7lhYjliJvlu7roioLngrkgIOmBjeWOhuW9oueKtiDojrflj5bmqKHlnotcclxuICAgICAgICB2YXIgYnBtbk1vZGVsID0gbmV3IEJQTU5Nb2RlbChqc29uKTtcclxuXHJcbiAgICAgICAgZmlzaFRvcG9CcG1uLm1vZGVsID0gYnBtbk1vZGVsO1xyXG5cclxuICAgICAgICB2YXIgYnBtbldpZHRoID0gYnBtbk1vZGVsLmdldChcInByb3BlcnRpZXMud2lkdGhcIik7XHJcbiAgICAgICAgdmFyIGJwbW5IZWlnaHQgPSBicG1uTW9kZWwuZ2V0KFwicHJvcGVydGllcy5oZWlnaHRcIik7XHJcbiAgICAgICAgaWYgKGJwbW5XaWR0aCA+IDAgJiYgYnBtbkhlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgZmlzaFRvcG9CcG1uLnJlc2l6ZShicG1uV2lkdGgsYnBtbkhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY2hpbGRTaGFwZXMgPSBicG1uTW9kZWwuZ2V0KFwiY2hpbGRTaGFwZXNcIik7XHJcbiAgICAgICAgdmFyIGNvbm5lY3RvcnMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkU2hhcGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGNoaWxkU2hhcGVzW2ldO1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IHNoYXBlLnN0ZW5jaWwudHlwZTtcclxuXHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gQnBtbi5TRVFVRU5DRV9GTE9XKSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3JzLnB1c2goc2hhcGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZGVsID0gbmV3IEJQTU5Nb2RlbChzaGFwZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3JlYXRlZE5vZGUgPSBmaXNoVG9wb0JwbW4uYWRkTm9kZUJ5TW9kZWwobW9kZWwsZmFsc2UsdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBCcG1uLlNVQl9QUk9DRVNTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1Yk5vZGUgPSBtb2RlbC5nZXQoXCJjaGlsZFNoYXBlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1Yk5vZGUubGVuZ3RoOyBqKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJNb2RlbCA9IG5ldyBCUE1OTW9kZWwoc3ViTm9kZVtqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKEJwbW4uaXNGbG93TW9kZWwoc3ViTW9kZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXNoVG9wb0JwbW4uYWRkQ29ubmVjdG9yQnlNb2RlbChzdWJNb2RlbCwgY3JlYXRlZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1cGVyVXBwZXJMZWZ0ID0gbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJVcHBlckxlZnQgPSBzdWJNb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZWwuc2V0KFwiYm91bmRzLnVwcGVyTGVmdFwiLCB7IHg6IHN1YlVwcGVyTGVmdC54ICsgc3VwZXJVcHBlckxlZnQueCwgeTogc3ViVXBwZXJMZWZ0LnkgKyBzdXBlclVwcGVyTGVmdC55IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlzaFRvcG9CcG1uLmFkZE5vZGVCeU1vZGVsKHN1Yk1vZGVsLHRydWUsdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMy4g5YaN5Yib5bu657q/XHJcbiAgICAgICAgZm9yKHZhciBrID0gMCwgbGVuID0gY29ubmVjdG9ycy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xyXG4gICAgICAgICAgICB2YXIgbW9kZWxMaW5lID0gbmV3IEJQTU5Nb2RlbChjb25uZWN0b3JzW2tdKTsgLy8gc2hhcGVcclxuICAgICAgICAgICAgZmlzaFRvcG9CcG1uLmFkZENvbm5lY3RvckJ5TW9kZWwobW9kZWxMaW5lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIDQu5Yib5bu65LqL5Lu25o+S5qe9XHJcbiAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBjaGlsZFNoYXBlcy5sZW5ndGg7IG0rKykge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRTaGFwZXNbbV0ucHJvcGVydGllcy5zbG90RXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgbiA9IDA7biA8IGNoaWxkU2hhcGVzW21dLnByb3BlcnRpZXMuc2xvdEV2ZW50Lmxlbmd0aDsgbisrKXtcclxuICAgICAgICAgICAgICAgICAgICBmaW5kTm9kZUJ5SWQoZmlzaFRvcG9CcG1uLGNoaWxkU2hhcGVzW21dLnJlc291cmNlSWQpLnNsb3RFdmVudC5wdXNoKGZpbmROb2RlQnlJZChmaXNoVG9wb0JwbW4sY2hpbGRTaGFwZXNbbV0ucHJvcGVydGllcy5zbG90RXZlbnRbbl0pKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja5pZOWcqGZpc2hUb3BvQnBtbuS4reafpeaJvlxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBmaXNoVG9wb0JwbW4gIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbm9kZUlkIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZmluZE5vZGVCeUlkKGZpc2hUb3BvQnBtbiwgbm9kZUlkKSB7XHJcbiAgICAgICAgdmFyIG5vZGU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGZpc2hUb3BvQnBtbi5hbGxOb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBpZiAoZmlzaFRvcG9CcG1uLmFsbE5vZGVzW2ldLm1vZGVsLmdldChcInJlc291cmNlSWRcIikgPT0gbm9kZUlkKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gZmlzaFRvcG9CcG1uLmFsbE5vZGVzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJCUE1OTm9kZSAoKSB7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhTdGFydEV2ZW50Tm9kZSwgXCJTdGFydE5vbmVFdmVudFwiKTtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKEVuZEV2ZW50Tm9kZSwgXCJFbmROb25lRXZlbnRcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhVc2VyVGFza05vZGUsIFwiVXNlclRhc2tcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhNYW51YWxUYXNrTm9kZSwgXCJNYW51YWxUYXNrXCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoU2NyaXB0VGFza05vZGUsIFwiU2NyaXB0VGFza1wiKTtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKE1haWxUYXNrTm9kZSwgXCJNYWlsVGFza1wiKTtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKENhdGNoVGltZXJFdmVudE5vZGUsIFwiQ2F0Y2hUaW1lckV2ZW50XCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoQ2F0Y2hTaWduYWxFdmVudE5vZGUsIFwiQ2F0Y2hTaWduYWxFdmVudFwiKTtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKFRocm93U2lnbmFsRXZlbnROb2RlLCBcIlRocm93U2lnbmFsRXZlbnRcIik7XHJcbiAgICAgICAgQlBNTk5vZGUucmVnaXN0ZXJDbGFzcyhJbmNsdXNpdmVHYXRld2F5Tm9kZSwgXCJJbmNsdXNpdmVHYXRld2F5XCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoRXhjbHVzaXZlR2F0ZXdheU5vZGUsIFwiRXhjbHVzaXZlR2F0ZXdheVwiKTtcclxuICAgICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKFBhcmFsbGVsR2F0ZXdheU5vZGUsIFwiUGFyYWxsZWxHYXRld2F5XCIpO1xyXG4gICAgICAgIEJQTU5Ob2RlLnJlZ2lzdGVyQ2xhc3MoU3ViUHJjZXNzTm9kZSwgXCJTdWJQcm9jZXNzXCIpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBpc0hvdmVyKG5vZGUsIHgsIHkpIHtcclxuICAgICAgICB2YXIgY3ggLCBjeTtcclxuICAgICAgICBpZihub2RlLnBhcmVudCl7XHJcbiAgICAgICAgICAgIGlmKG5vZGUucGFyZW50Lm1vZGVsLmdldChcInN0ZW5jaWwudHlwZVwiKSA9PSBcIlN1YlByb2Nlc3NcIil7XHJcbiAgICAgICAgICAgICAgICBjeCA9IHggLSBub2RlLnBhcmVudC5nZXRSZWN0KCkuYm91bmRpbmdSZWN0Lng7XHJcbiAgICAgICAgICAgICAgICBjeSA9IHkgLSBub2RlLnBhcmVudC5nZXRSZWN0KCkuYm91bmRpbmdSZWN0Lnk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5yZWN0Q29udGFpbihjeCwgY3kpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUucmVjdENvbnRhaW4oeCwgeSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZEhvdmVyKGxpc3QsIHgsIHksIGV4Y2x1ZGVzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwIDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0V4Y2x1ZGUoZXhjbHVkZXMsbGlzdFtpXSkgLy9saXN0W2ldICE9PSBleGNsdWRlXHJcbiAgICAgICAgICAgICAvLyBnZXREaXNwbGF5TGlzdCBtYXkgaW5jbHVkZSBpZ25vcmVkIGl0ZW0gaW4gVk1MIG1vZGVcclxuICAgICAgICAgICAgICYmICFsaXN0W2ldLmlnbm9yZVxyXG4gICAgICAgICAgICAgJiYgaXNIb3ZlcihsaXN0W2ldLCB4LCB5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRXhjbHVkZShleGNsdWRlcywgbm9kZSkge1xyXG4gICAgICAgIHJldHVybiB6clV0aWwuaW5kZXhPZihleGNsdWRlcyxub2RlKSA9PSAtMTtcclxuICAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgdmFyIEJwbW5VdGlsID0ge1xyXG4gICAgICAgIHRvSnNvbjogdG9Kc29uLFxyXG4gICAgICAgIGZyb21Kc29uOiBmcm9tSnNvbixcclxuICAgICAgICByZWdpc3RlckJQTU5Ob2RlOiByZWdpc3RlckJQTU5Ob2RlLFxyXG4gICAgICAgIGZpbmRIb3ZlcjogZmluZEhvdmVyXHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCcG1uVXRpbDtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL0JwbW5VdGlsLmpzXG4gKiogbW9kdWxlIGlkID0gNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDlt6Xlhbfmlrnms5XnsbtcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgUG9pbnQgPSByZXF1aXJlKFwiLi9Qb2ludC5qc1wiKTtcclxuICAgIHZhciBMaW5lID0gcmVxdWlyZShcIi4vTGluZVN0cnVjdC5qc1wiKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgLyoqXHJcbiAgICAgKiDmnoTpgKDnsbvnu6fmib/lhbPns7tcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGF6eiDmupDnsbtcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VDbGF6eiDln7rnsbtcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaW5oZXJpdHMoY2xhenosIGJhc2VDbGF6eikge1xyXG4gICAgICAgIHZhciBjbGF6elByb3RvdHlwZSA9IGNsYXp6LnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gRigpIHt9XHJcbiAgICAgICAgRi5wcm90b3R5cGUgPSBiYXNlQ2xhenoucHJvdG90eXBlO1xyXG4gICAgICAgIGNsYXp6LnByb3RvdHlwZSA9IG5ldyBGKCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gY2xhenpQcm90b3R5cGUpIHtcclxuICAgICAgICAgICAgY2xhenoucHJvdG90eXBlW3Byb3BdID0gY2xhenpQcm90b3R5cGVbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsYXp6LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNsYXp6O1xyXG4gICAgICAgIGNsYXp6LnN1cGVyQ2xhc3MgPSBiYXNlQ2xheno7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0VVVJRCgpIHtcclxuICAgICAgICB2YXIgY2hhcnMgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLnNwbGl0KCcnKSxcclxuICAgICAgICAgICAgdXVpZCA9IG5ldyBBcnJheSgzNiksXHJcbiAgICAgICAgICAgIHJuZCA9IDAsXHJcbiAgICAgICAgICAgIHI7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzNjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpID09IDggfHwgaSA9PSAxMyB8fCBpID09IDE4IHx8IGkgPT0gMjMpIHtcclxuICAgICAgICAgICAgICAgIHV1aWRbaV0gPSAnLSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PSAxNCkge1xyXG4gICAgICAgICAgICAgICAgdXVpZFtpXSA9ICc0JztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChybmQgPD0gMHgwMikgcm5kID0gMHgyMDAwMDAwICsgKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDApIHwgMDtcclxuICAgICAgICAgICAgICAgIHIgPSBybmQgJiAweGY7XHJcbiAgICAgICAgICAgICAgICBybmQgPSBybmQgPj4gNDtcclxuICAgICAgICAgICAgICAgIHV1aWRbaV0gPSBjaGFyc1soaSA9PSAxOSkgPyAociAmIDB4MykgfCAweDggOiByXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJzaWQtXCIgKyB1dWlkLmpvaW4oJycpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuoeeul+S4pOeCueS5i+mXtOeahOi3neemu1xyXG4gICAgICpAcGFyYW0ge1BvaW50fSBwMSAtIGZpcnN0IHtQb2ludH1cclxuICAgICAqQHBhcmFtIHtQb2ludH0gcDIgLSBzZWNvbmQge1BvaW50fVxyXG4gICAgICpAcmV0dXJuIHtOdW1iZXJ9IC0gdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhvc2UgMiBwb2ludHMuIEl0IGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGRpc3RhbmNlKHAxLCBwMikge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDEueCAtIHAyLngsIDIpICsgTWF0aC5wb3cocDEueSAtIHAyLnksIDIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOi/lOWbnuS4gOadoeaKmOe6vyDmnIDplb/nmoTkuKTkuKrngrlcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcG9pbnRzIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0TWF4TGluZUxlbmd0aChwb2ludHMpIHtcclxuICAgICAgICB2YXIgbSA9IGRpc3RhbmNlKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW3BvaW50c1swXSwgcG9pbnRzWzFdXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChtIDwgZGlzdGFuY2UocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKSkge1xyXG4gICAgICAgICAgICAgICAgbSA9IGRpc3RhbmNlKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSlcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtwb2ludHNbaV0sIHBvaW50c1tpICsgMV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlJldHVybnMgdGhlIGxlbmd0aCBvZiBhIFBvbHlsaW5lIHRoYXQgd291bGQgYmUgY3JlYXRlZCB3aXRoIGEgc2V0IG9mIHBvaW50c1xyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gYW4ge0FycmF5fSBvZiB7UG9pbnRzfVxyXG4gICAgICpAcmV0dXJuIHtOdW1iZXJ9IC0gYSBwb3NpdGl2ZSBudW1iZXIgZXF1YWwgd2l0aCB0b3RhbCBsZW5ndGgqL1xyXG4gICAgZnVuY3Rpb24gZ2V0UG9seWxpbmVMZW5ndGgodikge1xyXG4gICAgICAgIHZhciBsID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGwgKz0gZGlzdGFuY2UodltpXSwgdltpICsgMV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGw7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlJldHVybnMgdGhlIG1heCBvZiBhIHZlY3RvclxyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gdmVjdG9yIG9mIHtOdW1iZXJ9c1xyXG4gICAgICpAcmV0dXJuIHtOdW1iZXJ9IC0gdGhlIG1heGltdW0gbnVtYmVyIGZyb20gdGhlIHZlY3RvciBvciBOYU4gaWYgdmVjdG9yIGlzIGVtcHR5XHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBtYXgodikge1xyXG4gICAgICAgIGlmICh2LmxlbmdodCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG0gPSB2WzBdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChtIDwgdltpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSB2W2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlJldHVybnMgdGhlIG1pbiBvZiBhIHZlY3RvclxyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gdmVjdG9yIG9mIHtOdW1iZXJ9c1xyXG4gICAgICpAcmV0dXJuIHtOdW1iZXJ9IC0gdGhlIG1pbmltdW0gbnVtYmVyIGZyb20gdGhlIHZlY3RvciBvciBOYU4gaWYgdmVjdG9yIGlzIGVtcHR5XHJcbiAgICAgKkBhdXRob3IgYWxleEBzY3JpcHRvaWQuY29tXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBtaW4odikge1xyXG4gICAgICAgIGlmICh2LmxlbmdodCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG0gPSB2WzBdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChtID4gdltpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSB2W2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliKTmlq0g54K55pWw57uEIOaYr+WQpuato+S6pOebtOe6v+i3r+W+hFxyXG4gICAgICpUZXN0cyBpZiBhIHZlY3RvciBvZiBwb2ludHMgaXMgYW4gb3J0aG9nb25hbCBwYXRoIChtb3ZpbmcgaW4gbXVsdGlwbGVzIG9mIDkwIGRlZ3JlZXMpXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSBhbiB7QXJyYXl9IG9mIHtQb2ludH1zXHJcbiAgICAgKkByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiBwYXRoIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIG9ydGhvZ29uYWxQYXRoKHYpIHtcclxuICAgICAgICBpZiAodi5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHZbaV0ueCAhPSB2W2kgKyAxXS54ICYmIHZbaV0ueSAhPSB2W2kgKyAxXS55KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqVGVzdCB0byBzZWUgaWYgMiB7TGluZX1zIGludGVyc2VjdHMuIFRoZXkgYXJlIGNvbnNpZGVyZWQgZmluaXRlIHNlZ21lbnRzXHJcbiAgICAgKmFuZCBub3QgdGhlIGluZmluaXRlIGxpbmVzIGZyb20gZ2VvbWV0cnlcclxuICAgICAqQHBhcmFtIHtMaW5lfSBsMSAtIGZpc3QgbGluZS9zZWdtZW50XHJcbiAgICAgKkBwYXJhbSB7TGluZX0gbDIgLSBsYXN0IGxpbmUvc2VnbWVudFxyXG4gICAgICpAcmV0dXJuIHtCb29sZWFufSB0cnVlIC0gaWYgdGhlIGxpbmVzIGludGVyc2VjdCBvciBmYWxzZSBpZiBub3RcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RzTGluZShsMSwgbDIpIHtcclxuICAgICAgICAvLyBjaGVjayBmb3IgdHdvIHZlcnRpY2FsIGxpbmVzXHJcbiAgICAgICAgaWYgKGwxLnN0YXJ0UG9pbnQueCA9PSBsMS5lbmRQb2ludC54ICYmIGwyLnN0YXJ0UG9pbnQueCA9PSBsMi5lbmRQb2ludC54KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsMS5zdGFydFBvaW50LnggPT0gbDIuc3RhcnRQb2ludC54ID8gLy8gaWYgJ2luZmluaXRlICdsaW5lcyBkbyBjb2luY2lkZSxcclxuICAgICAgICAgICAgICAgIC8vIHRoZW4gY2hlY2sgc2VnbWVudCBib3VuZHMgZm9yIG92ZXJsYXBwaW5nXHJcbiAgICAgICAgICAgICAgICBsMS5jb250YWlucyhsMi5zdGFydFBvaW50LngsIGwyLnN0YXJ0UG9pbnQueSkgfHxcclxuICAgICAgICAgICAgICAgIGwxLmNvbnRhaW5zKGwyLmVuZFBvaW50LngsIGwyLmVuZFBvaW50LnkpIDpcclxuICAgICAgICAgICAgICAgIC8vIGxpbmVzIGFyZSBwYXJhbGVsXHJcbiAgICAgICAgICAgICAgICBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgb25lIGxpbmUgaXMgdmVydGljYWwsIGFuZCBhbm90aGVyIGxpbmUgaXMgbm90IHZlcnRpY2FsXHJcbiAgICAgICAgZWxzZSBpZiAobDEuc3RhcnRQb2ludC54ID09IGwxLmVuZFBvaW50LnggfHwgbDIuc3RhcnRQb2ludC54ID09IGwyLmVuZFBvaW50LngpIHtcclxuICAgICAgICAgICAgLy8gbGV0IGFzc3VtZSBsMiBpcyB2ZXJ0aWNhbCwgb3RoZXJ3aXNlIGV4Y2hhbmdlIHRoZW1cclxuICAgICAgICAgICAgaWYgKGwxLnN0YXJ0UG9pbnQueCA9PSBsMS5lbmRQb2ludC54KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGwxO1xyXG4gICAgICAgICAgICAgICAgbDEgPSBsMjtcclxuICAgICAgICAgICAgICAgIGwyID0gbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmaW5kaW5nIGludGVyc2VjdGlvbiBvZiAnaW5maW5pdGUnIGxpbmVzXHJcbiAgICAgICAgICAgIC8vIGVxdWF0aW9uIG9mIHRoZSBmaXJzdCBsaW5lIGlzIHkgPSBheCArIGIsIHNlY29uZDogeCA9IGNcclxuICAgICAgICAgICAgdmFyIGEgPSAobDEuZW5kUG9pbnQueSAtIGwxLnN0YXJ0UG9pbnQueSkgLyAobDEuZW5kUG9pbnQueCAtIGwxLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHZhciBiID0gbDEuc3RhcnRQb2ludC55IC0gYSAqIGwxLnN0YXJ0UG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIHgwID0gbDIuc3RhcnRQb2ludC54O1xyXG4gICAgICAgICAgICB2YXIgeTAgPSBhICogeDAgKyBiO1xyXG4gICAgICAgICAgICByZXR1cm4gbDEuY29udGFpbnMoeDAsIHkwKSAmJiBsMi5jb250YWlucyh4MCwgeTApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2hlY2sgbm9ybWFsIGNhc2UgLSBib3RoIGxpbmVzIGFyZSBub3QgdmVydGljYWxcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy9saW5lIGVxdWF0aW9uIGlzIDogeSA9IGEqeCArIGIsIGIgPSB5IC0gYSAqIHhcclxuICAgICAgICAgICAgdmFyIGExID0gKGwxLmVuZFBvaW50LnkgLSBsMS5zdGFydFBvaW50LnkpIC8gKGwxLmVuZFBvaW50LnggLSBsMS5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgYjEgPSBsMS5zdGFydFBvaW50LnkgLSBhMSAqIGwxLnN0YXJ0UG9pbnQueDtcclxuXHJcbiAgICAgICAgICAgIHZhciBhMiA9IChsMi5lbmRQb2ludC55IC0gbDIuc3RhcnRQb2ludC55KSAvIChsMi5lbmRQb2ludC54IC0gbDIuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgdmFyIGIyID0gbDIuc3RhcnRQb2ludC55IC0gYTIgKiBsMi5zdGFydFBvaW50Lng7XHJcblxyXG4gICAgICAgICAgICBpZiAoYTEgPT0gYTIpIHsgLy9wYXJhbGVsIGxpbmVzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYjEgPT0gYjIgP1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBjb2luY2lkZSBsaW5lcywgY2hlY2sgZm9yIHNlZ21lbnQgYm91bmRzIG92ZXJsYXBwaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgbDEuY29udGFpbnMobDIuc3RhcnRQb2ludC54LCBsMi5zdGFydFBvaW50LnkpIHx8IGwxLmNvbnRhaW5zKGwyLmVuZFBvaW50LngsIGwyLmVuZFBvaW50LnkpIDpcclxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgY29pbmNpZGUgcGFyYWxlbCBsaW5lcyBoYXZlIG5vIGNoYW5jZSB0byBpbnRlcnNlY3RcclxuICAgICAgICAgICAgICAgICAgICBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIHsgLy91c3VhbCBjYXNlIC0gbm9uIHBhcmFsZWwsIHRoZSAnaW5maW5pdGUnIGxpbmVzIGludGVyc2VjdHMuLi53ZSBvbmx5IG5lZWQgdG8ga25vdyBpZiBpbnNpZGUgdGhlIHNlZ21lbnRcclxuXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICogaWYgb25lIG9mIHRoZSBsaW5lcyBhcmUgdmVydGljYWwsIHRoZW4geDAgaXMgZXF1YWwgdG8gdGhlaXIgeCxcclxuICAgICAgICAgICAgICAgICAqIG90aGVyd2lzZTpcclxuICAgICAgICAgICAgICAgICAqIHkxID0gYTEgKiB4ICsgYjFcclxuICAgICAgICAgICAgICAgICAqIHkyID0gYTIgKiB4ICsgYjJcclxuICAgICAgICAgICAgICAgICAqID0+IHgwID0gKGIyIC0gYjEpIC8gKGExIC0gYTIpXHJcbiAgICAgICAgICAgICAgICAgKiA9PiB5MCA9IGExICogeDAgKyBiMVxyXG4gICAgICAgICAgICAgICAgICoqL1xyXG4gICAgICAgICAgICAgICAgeDAgPSAoYjIgLSBiMSkgLyAoYTEgLSBhMik7XHJcbiAgICAgICAgICAgICAgICB5MCA9IGExICogeDAgKyBiMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsMS5jb250YWlucyh4MCwgeTApICYmIGwyLmNvbnRhaW5zKHgwLCB5MCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpUZXN0cyBpZiBhIGEgcG9seWxpbmUgZGVmaW5lZCBieSBhIHNldCBvZiBwb2ludHMgaW50ZXJzZWN0cyBhIHJlY3RhbmdsZVxyXG4gICAgICpAcGFyYW0ge0FycmF5fSBwb2ludHMgLSBhbmQge0FycmF5fSBvZiB7UG9pbnR9c1xyXG4gICAgICpAcGFyYW0ge0FycmF5fSBib3VuZHMgLSB0aGUgYm91bmRzIG9mIHRoZSByZWN0YW5nbGUgZGVmaW5lZCBieSAoeDEsIHkxLCB4MiwgeTIpXHJcbiAgICAgKkBwYXJhbSB7Qm9vbGVhbn0gY2xvc2VkUG9seWxpbmUgLSBpbmNhc2UgcG9seWxpbmUgaXMgY2xvc2VkIGZpZ3VyZSB0aGVuIHRydWUsIGVsc2UgZmFsc2VcclxuICAgICAqXHJcbiAgICAgKkByZXR1cm4gdHJ1ZSAtIGlmIGxpbmUgaW50ZXJzZWN0cyB0aGUgcmVjdGFuZ2xlLCBmYWxzZSAtIGlmIG5vdFxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gcG9seWxpbmVJbnRlcnNlY3RzUmVjdGFuZ2xlKHBvaW50cywgYm91bmRzLCBjbG9zZWRQb2x5bGluZSkge1xyXG5cclxuXHJcbiAgICAgICAgLy9nZXQgdGhlIDQgbGluZXMvc2VnbWVudHMgcmVwcmVzZW50ZWQgYnkgdGhlIGJvdW5kc1xyXG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xyXG4gICAgICAgIGxpbmVzLnB1c2gobmV3IExpbmUobmV3IFBvaW50KGJvdW5kc1swXSwgYm91bmRzWzFdKSwgbmV3IFBvaW50KGJvdW5kc1syXSwgYm91bmRzWzFdKSkpO1xyXG4gICAgICAgIGxpbmVzLnB1c2gobmV3IExpbmUobmV3IFBvaW50KGJvdW5kc1syXSwgYm91bmRzWzFdKSwgbmV3IFBvaW50KGJvdW5kc1syXSwgYm91bmRzWzNdKSkpO1xyXG4gICAgICAgIGxpbmVzLnB1c2gobmV3IExpbmUobmV3IFBvaW50KGJvdW5kc1syXSwgYm91bmRzWzNdKSwgbmV3IFBvaW50KGJvdW5kc1swXSwgYm91bmRzWzNdKSkpO1xyXG4gICAgICAgIGxpbmVzLnB1c2gobmV3IExpbmUobmV3IFBvaW50KGJvdW5kc1swXSwgYm91bmRzWzNdKSwgbmV3IFBvaW50KGJvdW5kc1swXSwgYm91bmRzWzFdKSkpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvaW50cy5sZW5ndGggLSAxOyBrKyspIHtcclxuICAgICAgICAgICAgLy9jcmVhdGUgYSBsaW5lIG91dCBvZiBlYWNoIDIgY29uc2VjdXRpdmUgcG9pbnRzXHJcbiAgICAgICAgICAgIHZhciB0ZW1wTGluZSA9IG5ldyBMaW5lKHBvaW50c1trXSwgcG9pbnRzW2sgKyAxXSk7XHJcblxyXG4gICAgICAgICAgICAvL3NlZSBpZiB0aGF0IGxpbmUgaW50ZXJzZWN0IGFueSBvZiB0aGUgbGluZSBvbiBib3VuZHMgYm9yZGVyXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaW5lSW50ZXJzZWN0c0xpbmUodGVtcExpbmUsIGxpbmVzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NoZWNrIHRoZSBjbG9zZWQgZmlndXJlIC0gdGhhdCBpcyBsYXN0IHBvaW50IGNvbm5lY3RlZCB0byB0aGUgZmlyc3RcclxuICAgICAgICBpZiAoY2xvc2VkUG9seWxpbmUpIHtcclxuICAgICAgICAgICAgLy9jcmVhdGUgYSBsaW5lIG91dCBvZiBlYWNoIDIgY29uc2VjdXRpdmUgcG9pbnRzXHJcbiAgICAgICAgICAgIHZhciB0ZW1wTGluZTEgPSBuZXcgTGluZShwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLCBwb2ludHNbMF0pO1xyXG5cclxuICAgICAgICAgICAgLy9zZWUgaWYgdGhhdCBsaW5lIGludGVyc2VjdCBhbnkgb2YgdGhlIGxpbmUgb24gYm91bmRzIGJvcmRlclxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZUludGVyc2VjdHNMaW5lKHRlbXBMaW5lMSwgbGluZXNbal0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuoeeul+i3r+W+hOeahOWIhuaVsFxyXG4gICAgICogU2NvcmUgYSBvcnRvZ29uYWwgcGF0aCBtYWRlIG91dCBvZiBQb2ludHNcclxuICAgICAqSXRlcmF0ZXMgb3ZlciBhIHNldCBvZiBwb2ludHMgKG1pbmltdW0gMylcclxuICAgICAqRm9yIGVhY2ggMyBwb2ludHMgKGksIGkrMSwgaSsyKSA6XHJcbiAgICAgKiAgLSBpZiB0aGUgM3JkIG9uZSBpcyBhZnRlciB0aGUgMm5kIG9uIHRoZSBzYW1lIGxpbmUgd2UgYWRkICsxXHJcbiAgICAgKiAgLSBpZiB0aGUgM3JkIGlzIHVwIG9yIGRvd24gcmVsYXRlZCB0byB0aGUgMm5kIHdlIGRvIG5vdCBkbyBhbnl0aGluZyArMFxyXG4gICAgICogIC0gaWYgdGhlIDNyZCBnb2VzIGJhY2sgd2UgaW1lZGlhdGVsbHkgcmV0dXJuIC0xXHJcbiAgICAgKkBwYXJhbSB7QXJyYXl9IHYgLSBhbiBhcnJheSBvZiB7UG9pbnR9c1xyXG4gICAgICpAcmV0dXJuIHtOdW1iZXJ9IC0gLTEgaWYgdGhlIHBhdGggaXMgd3JvbmcgKGdvZXMgYmFjaykgb3Igc29tZXRoaW5nID49IDAgaWYgaXMgZmluZVxyXG4gICAgICogIFRoZSBiaWdnZXIgdGhlIG51bWJlciB0aGUgc21vb3RoIHRoZSBwYXRoIGlzXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBzY29yZVBhdGgodikge1xyXG4gICAgICAgIGlmICh2Lmxlbmd0aCA8PSAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzY29yZSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2Lmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodltpIC0gMV0ueCA9PSB2W2ldLnggJiYgdltpXS54ID09IHZbaSArIDFdLngpIHsgLy9vbiB0aGUgc2FtZSB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgICAgaWYgKHNpZ251bSh2W2kgKyAxXS55IC0gdltpXS55KSA9PSBzaWdudW0odltpXS55IC0gdltpIC0gMV0ueSkpIHsgLy9zYW1lIGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlKys7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvL2dvaW5nIGJhY2sgLSBubyBnb29kXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZbaSAtIDFdLnkgPT0gdltpXS55ICYmIHZbaV0ueSA9PSB2W2kgKyAxXS55KSB7IC8vb24gdGhlIHNhbWUgaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAgICAgaWYgKHNpZ251bSh2W2kgKyAxXS54IC0gdltpXS54KSA9PSBzaWdudW0odltpXS54IC0gdltpIC0gMV0ueCkpIHsgLy9zYW1lIGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlKys7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvL2dvaW5nIGJhY2sgLSBubyBnb29kXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgeyAvL25vdCBvbiBzYW1lIHZlcnRpY2FsIG5vciBob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICBzY29yZS0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2NvcmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDov5Tlm57mlbDlrZfnrKblj7fvvIgrIC0pXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaWduIG9mIGEgbnVtYmVyXHJcbiAgICAgKkBwYXJhbSB7TnVtYmVyfSB4IC0gdGhlIG51bWJlclxyXG4gICAgICpAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICpAc2VlIDxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NpZ25fZnVuY3Rpb25cIj5odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NpZ25fZnVuY3Rpb248L2E+XHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBzaWdudW0oeCkge1xyXG4gICAgICAgIGlmICh4ID4gMClcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgZWxzZSBpZiAoeCA8IDApXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yik5patIOeCueaVsOe7hCDmmK/kuI3mmK/mnInmlYjot6/lvoTvvIjmsqHmnInlm57ot6/vvIlcclxuICAgICAqVGVzdHMgaWYgYSB2ZWN0b3Igb2YgcG9pbnRzIGlzIGEgdmFsaWQgcGF0aCAobm90IGdvaW5nIGJhY2spXHJcbiAgICAgKlRoZXJlIGFyZSBhIGZldyBwcm9ibGVtcyBoZXJlLiBJZiB5b3UgaGF2ZSBwMSwgcDIsIHAzIGFuZCBwNCBhbmQgcDIgPSBwMyB5b3UgbmVlZCB0byBpZ25vcmUgdGhhdFxyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gYW4ge0FycmF5fSBvZiB7UG9pbnR9c1xyXG4gICAgICpAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgcGF0aCBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBmb3J3YXJkUGF0aCh2KSB7XHJcbiAgICAgICAgaWYgKHYubGVuZ3RoIDw9IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoIC0gMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh2W2ldLnggPT0gdltpICsgMV0ueCAmJiB2W2kgKyAxXS54ID09IHZbaSArIDJdLngpIHsgLy9vbiB0aGUgc2FtZSB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgICAgaWYgKHNpZ251bSh2W2kgKyAxXS55IC0gdltpXS55KSAhPSAwKSB7IC8vdGVzdCBvbmx5IHdlIGhhdmUgYSBwcm9ncmVzc2luZyBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ251bSh2W2kgKyAxXS55IC0gdltpXS55KSA9PSAtMSAqIHNpZ251bSh2W2kgKyAyXS55IC0gdltpICsgMV0ueSkpIHsgLy9nb2luZyBiYWNrIChpZ25vcmUgemVybylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2W2ldLnkgPT0gdltpICsgMV0ueSAmJiB2W2kgKyAxXS55ID09IHZbaSArIDJdLnkpIHsgLy9vbiB0aGUgc2FtZSBob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2lnbnVtKHZbaSArIDFdLnggLSB2W2ldLngpICE9IDApIHsgLy90ZXN0IG9ubHkgd2UgaGF2ZSBhIHByb2dyZXNzaW5nIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbnVtKHZbaSArIDFdLnggLSB2W2ldLngpID09IC0xICogc2lnbnVtKHZbaSArIDJdLnggLSB2W2kgKyAxXS54KSkgeyAvL2dvaW5nIGJhY2sgKGlnbm9yZSB6ZXJvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWwhlt4OjAseTowXei9rOWMluS4ulswLCAwXSAg57uZenJlbmRlcuS9v+eUqFxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwb2ludHMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBpc1JldmVydCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRyYXNsYXRlUG9pbnRzKHBvaW50cywgaXNSZXZlcnQpIHtcclxuICAgICAgICB2YXIgbmV3UG9pbnRzID0gW107XHJcbiAgICAgICAgaWYgKGlzUmV2ZXJ0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XHJcbiAgICAgICAgICAgICAgICBuZXdQb2ludHMucHVzaChuZXcgUG9pbnQocG9pbnRbMF0sIHBvaW50WzFdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ld1BvaW50cztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvaW50cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50MSA9IHBvaW50c1tqXTtcclxuICAgICAgICAgICAgICAgIG5ld1BvaW50cy5wdXNoKFtwb2ludDEueCwgcG9pbnQxLnldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3UG9pbnRzO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJvdGF0aW9uTWF0cml4KGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIG1SZXR1cm4gPSBbXHJcbiAgICAgICAgICAgIFtNYXRoLmNvcyhhbmdsZSksIC1NYXRoLnNpbihhbmdsZSksIDBdLFxyXG4gICAgICAgICAgICBbTWF0aC5zaW4oYW5nbGUpLCBNYXRoLmNvcyhhbmdsZSksIDBdLFxyXG4gICAgICAgICAgICBbMCwgMCwgMV1cclxuICAgICAgICBdO1xyXG4gICAgICAgIHJldHVybiBtUmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0aW9uTWF0cml4KGR4LCBkeSkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFsxLCAwLCBkeF0sXHJcbiAgICAgICAgICAgIFswLCAxLCBkeV0sXHJcbiAgICAgICAgICAgIFswLCAwLCAxXVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2NhbGVNYXRyaXgoc3gsIHN5KSB7XHJcbiAgICAgICAgaWYgKHN5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgc3kgPSBzeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW3N4LCAwLCAwXSxcclxuICAgICAgICAgICAgWzAsIHN5LCAwXSxcclxuICAgICAgICAgICAgWzAsIDAsIDFdXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogSXQgd2lsbCByZXR1cm4gdGhlIGVuZCBwb2ludCBvZiBhIGxpbmUgb24gYSBnaXZlbiBhbmdsZSAoY2xvY2t3aXNlKS5cclxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHN0YXJ0UG9pbnQgLSB0aGUgc3RhcnQgb2YgdGhlIGxpbmVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgLSB0aGUgYW5nbGUgb2YgdGhlIGxpbmUgaW4gcmFkaWFuc1xyXG4gICAgICogQHJldHVybiB7UG9pbnR9IC0gdGhlIGVuZFBvaW50IG9mIHRoZSBsaW5lXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEVuZFBvaW50KHN0YXJ0UG9pbnQsIGxlbmd0aCwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgZW5kUG9pbnQgPSBzdGFydFBvaW50LmNsb25lKCk7XHJcbiAgICAgICAgZW5kUG9pbnQudHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KC1zdGFydFBvaW50LngsIC1zdGFydFBvaW50LnkpKTtcclxuICAgICAgICBlbmRQb2ludC55IC09IGxlbmd0aDtcclxuICAgICAgICBlbmRQb2ludC50cmFuc2Zvcm0ocm90YXRpb25NYXRyaXgoYW5nbGUpKTtcclxuICAgICAgICBlbmRQb2ludC50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgoc3RhcnRQb2ludC54LCBzdGFydFBvaW50LnkpKTtcclxuICAgICAgICByZXR1cm4gZW5kUG9pbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bojrflj5bkuKTkuKrlm77lvaLnmoTlpJbpnaLlm5vkuKrov57mjqXngrlcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbm9kZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRDb25uZWN0b3JQb2ludHMobm9kZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxlZnQ6IG5ldyBQb2ludChub2RlLngsIG5vZGUueSArIG5vZGUuaGVpZ2h0IC8gMiksIC8v55+p5b2iIOW3puS4reeahOS9jee9rlxyXG4gICAgICAgICAgICB0b3A6IG5ldyBQb2ludChub2RlLnggKyBub2RlLndpZHRoIC8gMiwgbm9kZS55KSwgLy/nn6nlvaIg5LiK5Lit55qE5L2N572uXHJcbiAgICAgICAgICAgIHJpZ2h0OiBuZXcgUG9pbnQobm9kZS54ICsgbm9kZS53aWR0aCwgbm9kZS55ICsgbm9kZS5oZWlnaHQgLyAyKSwgLy/nn6nlvaIg5Y+z5Lit55qE5L2N572uXHJcbiAgICAgICAgICAgIGJvdHRvbTogbmV3IFBvaW50KG5vZGUueCArIG5vZGUud2lkdGggLyAyLCBub2RlLnkgKyBub2RlLmhlaWdodCksIC8v55+p5b2iIOS4i+S4reeahOS9jee9rlxyXG4gICAgICAgICAgICBjZW50ZXI6IG5ldyBQb2ludChub2RlLnggKyBub2RlLndpZHRoIC8gMiwgbm9kZS55ICsgbm9kZS5oZWlnaHQgLyAyKSAvL+S4remXtOS9jee9rlxyXG5cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W6I635Y+W5Lik5Liq5Zu+5b2i55qE5aSW6Z2i5Zub5Liq6L+e5o6l54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0U29sdFBvaW50cyhub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgLy90b3BcclxuICAgICAgICAgICAgW01hdGgucm91bmQobm9kZS5nZXRSZWN0KCkud2lkdGggLyAzIC8xMCkqMTAsIDAgXSxcclxuICAgICAgICAgICAgW01hdGgucm91bmQoMipub2RlLmdldFJlY3QoKS53aWR0aCAvIDMgLzEwKSoxMCwgMCBdLFxyXG4gICAgICAgICAgICAvL3JpZ2h0XHJcbiAgICAgICAgICAgIFtub2RlLmdldFJlY3QoKS53aWR0aCwgTWF0aC5yb3VuZChub2RlLmdldFJlY3QoKS5oZWlnaHQgLyAzIC8xMCkqMTAgXSxcclxuICAgICAgICAgICAgW25vZGUuZ2V0UmVjdCgpLndpZHRoLCBNYXRoLnJvdW5kKDIqbm9kZS5nZXRSZWN0KCkuaGVpZ2h0IC8gMyAvMTApKjEwIF0sXHJcbiAgICAgICAgICAgIC8vYm90dG9tXHJcbiAgICAgICAgICAgIFtNYXRoLnJvdW5kKG5vZGUuZ2V0UmVjdCgpLndpZHRoIC8gMyAvMTApKjEwLCBub2RlLmdldFJlY3QoKS5oZWlnaHQgXSxcclxuICAgICAgICAgICAgW01hdGgucm91bmQoMipub2RlLmdldFJlY3QoKS53aWR0aCAvIDMgLzEwKSoxMCwgbm9kZS5nZXRSZWN0KCkuaGVpZ2h0IF0sXHJcbiAgICAgICAgICAgIC8vbGVmdFxyXG4gICAgICAgICAgICBbMCwgTWF0aC5yb3VuZChub2RlLmdldFJlY3QoKS5oZWlnaHQgLyAzIC8xMCkqMTAgXSxcclxuICAgICAgICAgICAgWzAsIE1hdGgucm91bmQoMipub2RlLmdldFJlY3QoKS5oZWlnaHQgLyAzIC8xMCkqMTAgXVxyXG5cclxuICAgICAgICBdXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorqHnrpcgcDEgcDLkuKTngrnmiYDov57mjqXnmoTnm7Tnur/nmoTop5LluqZcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcDEgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwMiBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdGFuZ2VudFJvdGF0aW9uKHAxLCBwMikge1xyXG4gICAgICAgIHJldHVybiAtTWF0aC5QSSAvIDIgLSBNYXRoLmF0YW4yKFxyXG4gICAgICAgICAgICBwMi55IC0gcDEueSwgcDIueCAtIHAxLnhcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yik5patM+eCueaYr+WQpuWcqOS4gOadoeebtOe6v+S4ilxyXG4gICAgICogVGVzdHMgaWYgMyBwb2ludHMgYXJlIGNvbGluaWFyIHdpdGggbWF0cml4IGRldGVybWluYW50cy5cclxuICAgICAqIElmIHRoZSBkZXRlcm1pbmF0IG9mIG1hdHJpeFxyXG4gICAgICogLyAgICAgICAgIFxcXHJcbiAgICAgKiB8IHgxIHkxIDEgfFxyXG4gICAgICogfCB4MiB5MiAxIHxcclxuICAgICAqIHwgeDMgeTMgMSB8XHJcbiAgICAgKiBcXCAgICAgICAgIC9cclxuICAgICAqIGlzIHplcm8gaXQgbWVhbnMgdGhhdCB0aGUgcG9pbnRzIGFyZSBjb2xpbmVhclxyXG4gICAgICpAcGFyYW0ge1BvaW50fSBwMSAtIGZpcnN0IHBvaW50XHJcbiAgICAgKkBwYXJhbSB7UG9pbnR9IHAyIC0gc2Vjb25kIHBvaW50XHJcbiAgICAgKkBwYXJhbSB7UG9pbnR9IHAzIC0gdGhpcmQgcG9pbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcmVjaXNzaW9uXHJcbiAgICAgKkByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiBjb2xpbmlhciBhbmQgZmFsc2UgaWYgbm90XHJcbiAgICAgKkBhdXRob3IgQWxleFxyXG4gICAgICpAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGV0ZXJtaW5hbnRcclxuICAgICAqQHNlZSBodHRwczovL3Blb3BsZS5yaWNobGFuZC5lZHUvamFtZXMvbGVjdHVyZS9tMTE2L21hdHJpY2VzL2FwcGxpY2F0aW9ucy5odG1sXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBjb2xsaW5lYXJpdHkocDEsIHAyLCBwMywgcHJlY2lzc2lvbikge1xyXG4gICAgICAgIHZhciBkZXRlcm1pbmFudCA9IChwMS54ICogcDIueSArIHAxLnkgKiBwMy54ICsgcDIueCAqIHAzLnkpIC0gKHAyLnkgKiBwMy54ICsgcDEueSAqIHAyLnggKyBwMS54ICogcDMueSk7XHJcblxyXG4gICAgICAgIGlmIChwcmVjaXNzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhkZXRlcm1pbmFudCkgPD0gcHJlY2lzc2lvbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZGV0ZXJtaW5hbnQgPT09IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWbm+iIjeS6lOWFpSDkv53lrZhkZWNpbWFsc+eahOWwj+aVsFxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gZW5oYW5jZWRSb3VuZChudW1iZXIsIGRlY2ltYWxzKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyICogTWF0aC5wb3coMTAsIGRlY2ltYWxzKSkgLyBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W5Lik54K55LmL6Ze055qE6ZW/5bqmXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBnZXRMZW5ndGgoc3RhcnRQb2ludCwgZW5kUG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHN0YXJ0UG9pbnQueCAtIGVuZFBvaW50LngsIDIpICsgTWF0aC5wb3coc3RhcnRQb2ludC55IC0gZW5kUG9pbnQueSwgMikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W6KeS5bqmXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNlbnRlclBvaW50ICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG91dHNpZGVQb2ludCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHJvdW5kICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEFuZ2xlKGNlbnRlclBvaW50LCBvdXRzaWRlUG9pbnQsIHJvdW5kKSB7XHJcbiAgICAgICAgY2VudGVyUG9pbnQueCA9IGVuaGFuY2VkUm91bmQoY2VudGVyUG9pbnQueCwgNSk7XHJcbiAgICAgICAgY2VudGVyUG9pbnQueSA9IGVuaGFuY2VkUm91bmQoY2VudGVyUG9pbnQueSwgNSk7XHJcbiAgICAgICAgb3V0c2lkZVBvaW50LnggPSBlbmhhbmNlZFJvdW5kKG91dHNpZGVQb2ludC54LCA1KTtcclxuICAgICAgICBvdXRzaWRlUG9pbnQueSA9IGVuaGFuY2VkUm91bmQob3V0c2lkZVBvaW50LnksIDUpO1xyXG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbigob3V0c2lkZVBvaW50LnggLSBjZW50ZXJQb2ludC54KSAvIChvdXRzaWRlUG9pbnQueSAtIGNlbnRlclBvaW50LnkpKTtcclxuICAgICAgICBhbmdsZSA9IC1hbmdsZTtcclxuXHJcbiAgICAgICAgLy9lbmRBbmdsZSs9OTA7XHJcbiAgICAgICAgaWYgKG91dHNpZGVQb2ludC54ID49IGNlbnRlclBvaW50LnggJiYgb3V0c2lkZVBvaW50LnkgPj0gY2VudGVyUG9pbnQueSkge1xyXG4gICAgICAgICAgICBhbmdsZSArPSBNYXRoLlBJO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3V0c2lkZVBvaW50LnggPD0gY2VudGVyUG9pbnQueCAmJiBvdXRzaWRlUG9pbnQueSA+PSBjZW50ZXJQb2ludC55KSB7XHJcbiAgICAgICAgICAgIGFuZ2xlICs9IE1hdGguUEk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvdXRzaWRlUG9pbnQueCA8PSBjZW50ZXJQb2ludC54ICYmIG91dHNpZGVQb2ludC55IDw9IGNlbnRlclBvaW50LnkpIHtcclxuICAgICAgICAgICAgYW5nbGUgKz0gTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChhbmdsZSA+PSBNYXRoLlBJICogMikge1xyXG4gICAgICAgICAgICBhbmdsZSAtPSBNYXRoLlBJICogMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTmFOKGFuZ2xlKSkgeyAvL05hblxyXG4gICAgICAgICAgICBhbmdsZSA9IDA7IC8vd2UgYXJlIGF0IGNlbnRlciBwb2ludDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJvdW5kKSB7XHJcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5yb3VuZChhbmdsZSAvIHJvdW5kKSAqIHJvdW5kXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhbmdsZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRSZWN0KG5vZGUpIHtcclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAvL+WIm+W7uuacgOWwj+WMheWbtOebkuiZmue6v1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICBwb2ludHNbMF0gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgcG9pbnRzWzFdID0gW2JvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgcG9pbnRzWzJdID0gW2JvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICBwb2ludHNbM10gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICBwb2ludHNbNF0gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcblxyXG4gICAgICAgIHZhciBib3VuZFJlY3QsIGN4LCBjeTtcclxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoaWMuQ2lyY2xlKSB7XHJcbiAgICAgICAgICAgIC8v5rOoOiDlm6Dkuovku7bkuLrlnIblvaIgIOaJgOS7pSB4IHkg5Li65ZyG5b+D55qE5L2N572uICDljIXlm7Tnn6nlvaLopoHlh4/ljrvlrr3luqbkuIDljYpcclxuICAgICAgICAgICAgYm91bmRSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChOdW1iZXIobm9kZS5wb3NpdGlvblswXSkgLSBOdW1iZXIoYm91bmRpbmdSZWN0LndpZHRoIC8gMiksXHJcbiAgICAgICAgICAgICAgICBOdW1iZXIobm9kZS5wb3NpdGlvblsxXSkgLSBOdW1iZXIoYm91bmRpbmdSZWN0LmhlaWdodCAvIDIpLFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyKGJvdW5kaW5nUmVjdC53aWR0aCksIE51bWJlcihib3VuZGluZ1JlY3QuaGVpZ2h0KSk7XHJcbiAgICAgICAgICAgIGN4ID0gTnVtYmVyKG5vZGUucG9zaXRpb25bMF0pO1xyXG4gICAgICAgICAgICBjeSA9IE51bWJlcihub2RlLnBvc2l0aW9uWzFdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBib3VuZFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KE51bWJlcihub2RlLnBvc2l0aW9uWzBdKSxcclxuICAgICAgICAgICAgICAgIE51bWJlcihub2RlLnBvc2l0aW9uWzFdKSxcclxuICAgICAgICAgICAgICAgIE51bWJlcihib3VuZGluZ1JlY3Qud2lkdGgpLCBOdW1iZXIoYm91bmRpbmdSZWN0LmhlaWdodCkpO1xyXG4gICAgICAgICAgICBjeCA9IE51bWJlcihub2RlLnBvc2l0aW9uWzBdKSArIE51bWJlcihib3VuZGluZ1JlY3Qud2lkdGgpIC8gMjtcclxuICAgICAgICAgICAgY3kgPSBOdW1iZXIobm9kZS5wb3NpdGlvblsxXSkgKyBOdW1iZXIoYm91bmRpbmdSZWN0LmhlaWdodCkgLyAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBOdW1iZXIoY3gpLFxyXG4gICAgICAgICAgICB5OiBOdW1iZXIoY3kpLFxyXG4gICAgICAgICAgICB3aWR0aDogTnVtYmVyKGJvdW5kaW5nUmVjdC53aWR0aCksXHJcbiAgICAgICAgICAgIGhlaWdodDogTnVtYmVyKGJvdW5kaW5nUmVjdC5oZWlnaHQpLFxyXG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcclxuICAgICAgICAgICAgYm91bmRpbmdSZWN0OiBib3VuZFJlY3RcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBTdGFja2VkTWFwID0ge1xyXG4gICAgICAgIGNyZWF0ZU5ldzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFjayA9IFtdO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJLZXkgPSB0aGlzLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFycktleS5wdXNoKHZhbHVlKVxyXG5cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBzdGFja1tpXS5rZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFja1tpXS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL+WmguaenOayoeacieaJvuWIsOeahOivne+8jOWImeWIm+W7uuS4gOS4quaWsOeahOaVsOe7hFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goeyBrZXk6IGtleSwgdmFsdWU6IHZhbHVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBrZXlzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKHN0YWNrW2ldLmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHRvcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBzdGFja1tpXS5rZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2suc3BsaWNlKGlkeCwgMSlbMF07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlSXRlbTogZnVuY3Rpb24oa2V5LCBpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycktleSA9IHRoaXMuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0genJVdGlsLmluZGV4T2YoYXJyS2V5LCBpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBhcnJLZXkuc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlVG9wOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2suc3BsaWNlKHN0YWNrLmxlbmd0aCAtIDEsIDEpWzBdO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2suc3BsaWNlKDAsIHN0YWNrLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiByYW5kb21Db2xvcigpIHtcclxuICAgICAgICB2YXIgYXJySGV4ID0gW1wiMFwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiLCBcIjVcIiwgXCI2XCIsIFwiN1wiLCBcIjhcIiwgXCI5XCIsIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiXSxcclxuICAgICAgICAgICAgc3RySGV4ID0gXCIjXCIsXHJcbiAgICAgICAgICAgIGluZGV4O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTUpO1xyXG4gICAgICAgICAgICBzdHJIZXggKz0gYXJySGV4W2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0ckhleDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29sbGluZWFyUmVkdWN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIHIgPSBbXTtcclxuXHJcbiAgICAgICAgaWYodi5sZW5ndGggPCAzKXtcclxuICAgICAgICAgICAgcmV0dXJuIFBvaW50LmNsb25lQXJyYXkodik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByLnB1c2goIHZbMF0uY2xvbmUoKSApO1xyXG4gICAgICAgIGZvcih2YXIgaT0xOyBpIDwgdi5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICAgICAgaWYoICh2W2ktMV0ueCA9PSB2W2ldLnggJiYgdltpXS54ID09IHZbaSsxXS54KSAgfHwgICh2W2ktMV0ueSA9PSB2W2ldLnkgJiYgdltpXS55ID09IHZbaSsxXS55KSApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICByLnB1c2goIHZbaV0uY2xvbmUoKSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHIucHVzaCggdlt2Lmxlbmd0aC0xXS5jbG9uZSgpICk7XHJcblxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxyXG4gICAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxyXG4gICAgdmFyIHRlbXBsYXRlU2V0dGluZ3MgPSB7XHJcbiAgICAgICAgZXZhbHVhdGU6IC88JShbXFxzXFxTXSs/KSU+L2csXHJcbiAgICAgICAgaW50ZXJwb2xhdGU6IC88JT0oW1xcc1xcU10rPyklPi9nLFxyXG4gICAgICAgIGVzY2FwZTogLzwlLShbXFxzXFxTXSs/KSU+L2dcclxuICAgIH07XHJcblxyXG4gICAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxyXG4gICAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xyXG4gICAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXHJcbiAgICB2YXIgbm9NYXRjaCA9IC8oLileLztcclxuXHJcbiAgICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxyXG4gICAgLy8gc3RyaW5nIGxpdGVyYWwuXHJcbiAgICB2YXIgZXNjYXBlcyA9IHtcclxuICAgICAgICBcIidcIjogXCInXCIsXHJcbiAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXHJcbiAgICAgICAgJ1xccic6ICdyJyxcclxuICAgICAgICAnXFxuJzogJ24nLFxyXG4gICAgICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcclxuICAgICAgICAnXFx1MjAyOSc6ICd1MjAyOSdcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx1MjAyOHxcXHUyMDI5L2c7XHJcblxyXG4gICAgdmFyIGVzY2FwZUNoYXIgPSBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cclxuICAgIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcclxuICAgIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxyXG4gICAgLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxyXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUodGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XHJcbiAgICAgICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcclxuICAgICAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xyXG4gICAgICAgIHNldHRpbmdzID0genJVdGlsLmRlZmF1bHRzKHNldHRpbmdzLCB0ZW1wbGF0ZVNldHRpbmdzLCB0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXHJcbiAgICAgICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xyXG4gICAgICAgICAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcclxuICAgICAgICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcclxuICAgICAgICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxyXG4gICAgICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcclxuXHJcbiAgICAgICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cclxuICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xyXG4gICAgICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlLCBpbnRlcnBvbGF0ZSwgZXZhbHVhdGUsIG9mZnNldCkge1xyXG4gICAgICAgICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xyXG4gICAgICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGlmIChlc2NhcGUpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZlc3QuXHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xyXG5cclxuICAgICAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxyXG4gICAgICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XHJcblxyXG4gICAgICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcclxuICAgICAgICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcclxuICAgICAgICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgc291cmNlKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGUuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxyXG4gICAgICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonO1xyXG4gICAgICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgYXJndW1lbnQgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xyXG5cclxuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcclxuICAgICAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmICh6clV0aWwuaXNBcnJheUxpa2Uob2JqKSAmJiAoenJVdGlsLmlzQXJyYXkob2JqKSB8fCB6clV0aWwuaXNTdHJpbmcob2JqKSkpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgICAgIGluaGVyaXRzOiBpbmhlcml0cyxcclxuICAgICAgICBnZXRVVUlEOiBnZXRVVUlELFxyXG4gICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuICAgICAgICBnZXRQb2x5bGluZUxlbmd0aDogZ2V0UG9seWxpbmVMZW5ndGgsXHJcbiAgICAgICAgbWF4OiBtYXgsXHJcbiAgICAgICAgbWluOiBtaW4sXHJcbiAgICAgICAgaXNFbXB0eTogaXNFbXB0eSxcclxuICAgICAgICBvcnRob2dvbmFsUGF0aDogb3J0aG9nb25hbFBhdGgsXHJcbiAgICAgICAgcG9seWxpbmVJbnRlcnNlY3RzUmVjdGFuZ2xlOiBwb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGUsXHJcbiAgICAgICAgc2NvcmVQYXRoOiBzY29yZVBhdGgsXHJcbiAgICAgICAgZm9yd2FyZFBhdGg6IGZvcndhcmRQYXRoLFxyXG4gICAgICAgIHRyYXNsYXRlUG9pbnRzOiB0cmFzbGF0ZVBvaW50cyxcclxuICAgICAgICBnZXRFbmRQb2ludDogZ2V0RW5kUG9pbnQsXHJcbiAgICAgICAgZ2V0Q29ubmVjdG9yUG9pbnRzOiBnZXRDb25uZWN0b3JQb2ludHMsXHJcbiAgICAgICAgdGFuZ2VudFJvdGF0aW9uOiB0YW5nZW50Um90YXRpb24sXHJcbiAgICAgICAgY29sbGluZWFyaXR5OiBjb2xsaW5lYXJpdHksXHJcbiAgICAgICAgdHJhbnNsYXRpb25NYXRyaXg6IHRyYW5zbGF0aW9uTWF0cml4LFxyXG4gICAgICAgIHNjYWxlTWF0cml4OiBzY2FsZU1hdHJpeCxcclxuICAgICAgICByb3VuZDogZW5oYW5jZWRSb3VuZCxcclxuICAgICAgICBnZXRMZW5ndGg6IGdldExlbmd0aCxcclxuICAgICAgICBnZXRBbmdsZTogZ2V0QW5nbGUsXHJcbiAgICAgICAgZ2V0UmVjdDogZ2V0UmVjdCxcclxuICAgICAgICBTdGFja2VkTWFwOiBTdGFja2VkTWFwLFxyXG4gICAgICAgIGdldE1heExpbmVMZW5ndGg6IGdldE1heExpbmVMZW5ndGgsXHJcbiAgICAgICAgcmFuZG9tQ29sb3I6IHJhbmRvbUNvbG9yLFxyXG4gICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcclxuICAgICAgICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXHJcbiAgICAgICAgZ2V0U29sdFBvaW50czpnZXRTb2x0UG9pbnRzLFxyXG4gICAgICAgIGNvbGxpbmVhclJlZHVjdGlvbjogY29sbGluZWFyUmVkdWN0aW9uXHJcbiAgICB9O1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuXHJcbiAgICAvKipcclxuICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgTGluZS4gQSBMaW5lIGlzIGFjdHVhbGx5IGEgc2VnbWVudCBhbmQgbm90IGEgcHVyZVxyXG4gICAgICAqIGdlb21ldHJpY2FsIExpbmVcclxuICAgICAgKlxyXG4gICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAqIEB0aGlzIHtMaW5lfVxyXG4gICAgICAqIEBwYXJhbSB7UG9pbnR9IHN0YXJ0UG9pbnQgLSBzdGFydGluZyBwb2ludCBvZiB0aGUgbGluZVxyXG4gICAgICAqIEBwYXJhbSB7UG9pbnR9IGVuZFBvaW50IC0gdGhlIGVuZGluZyBwb2ludCBvZiB0aGUgbGluZVxyXG4gICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIExpbmUoc3RhcnRQb2ludCwgZW5kUG9pbnQpe1xyXG4gICAgICAgIC8qKlN0YXJ0aW5nIHtAbGluayBQb2ludH0gb2YgdGhlIGxpbmUqL1xyXG4gICAgICAgIHRoaXMuc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQ7XHJcblxyXG4gICAgICAgIC8qKkVuZGluZyB7QGxpbmsgUG9pbnR9IG9mIHRoZSBsaW5lKi9cclxuICAgICAgICB0aGlzLmVuZFBvaW50ID0gZW5kUG9pbnQ7XHJcblxyXG4gICAgICAgIC8qKlNlcmlhbGl6YXRpb24gdHlwZSovXHJcbiAgICAgICAgdGhpcy5vVHlwZSA9ICdMaW5lJzsgLy9vYmplY3QgdHlwZSB1c2VkIGZvciBKU09OIGRlc2VyaWFsaXphdGlvblxyXG4gICAgfVxyXG5cclxuICAgIC8qKkNyZWF0ZXMgYSB7TGluZX0gb3V0IG9mIEpTT04gcGFyc2VkIG9iamVjdFxyXG4gICAgICpAcGFyYW0ge0pTT05PYmplY3R9IG8gLSB0aGUgSlNPTiBwYXJzZWQgb2JqZWN0XHJcbiAgICAgKkByZXR1cm4ge0xpbmV9IGEgbmV3bHkgY29uc3RydWN0ZWQgTGluZVxyXG4gICAgICoqL1xyXG4gICAgTGluZS5sb2FkID0gZnVuY3Rpb24obyl7XHJcbiAgICAgICAgdmFyIG5ld0xpbmUgPSBuZXcgTGluZShcclxuICAgICAgICAgICAgUG9pbnQubG9hZChvLnN0YXJ0UG9pbnQpLFxyXG4gICAgICAgICAgICBQb2ludC5sb2FkKG8uZW5kUG9pbnQpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld0xpbmU7XHJcbiAgICB9O1xyXG5cclxuICAgIExpbmUucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnRydWN0b3I6IExpbmUsXHJcblxyXG5cclxuXHJcbiAgICAgICAgY2xvbmU6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBMaW5lKHRoaXMuc3RhcnRQb2ludC5jbG9uZSgpLCB0aGlzLmVuZFBvaW50LmNsb25lKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGVxdWFsczpmdW5jdGlvbihhbm90aGVyTGluZSl7XHJcbiAgICAgICAgICAgIGlmKCFhbm90aGVyTGluZSBpbnN0YW5jZW9mIExpbmUpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0UG9pbnQuZXF1YWxzKGFub3RoZXJMaW5lLnN0YXJ0UG9pbnQpXHJcbiAgICAgICAgICAgICYmIHRoaXMuZW5kUG9pbnQuZXF1YWxzKGFub3RoZXJMaW5lLmVuZFBvaW50KVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKiBUZXN0cyB0byBzZWUgaWYgYSBwb2ludCBiZWxvbmdzIHRvIHRoaXMgbGluZSAobm90IGFzIGluZmluaXRlIGxpbmUgYnV0IG1vcmUgbGlrZSBhIHNlZ21lbnQpXHJcbiAgICAgICAgICogQWxnb3JpdGhtOiBDb21wdXRlIGxpbmUncyBlcXVhdGlvbiBhbmQgc2VlIGlmICh4LCB5KSB2ZXJpZmllcyBpdC5cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIHRoZSBYIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSB0aGUgWSBjb29yZGluYXRlc1xyXG4gICAgICAgICAqKi9cclxuICAgICAgICBjb250YWluczogZnVuY3Rpb24oeCwgeSl7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgcmVjdGFuZ2xlIGJvdW5kcyBvZiB0aGUgc2VnbWVudFxyXG4gICAgICAgICAgICBpZiAoTWF0aC5taW4odGhpcy5zdGFydFBvaW50LngsIHRoaXMuZW5kUG9pbnQueCkgPD0geFxyXG4gICAgICAgICAgICAgICAgJiYgeCA8PSBNYXRoLm1heCh0aGlzLnN0YXJ0UG9pbnQueCwgdGhpcy5lbmRQb2ludC54KVxyXG4gICAgICAgICAgICAgICAgJiYgTWF0aC5taW4odGhpcy5zdGFydFBvaW50LnksIHRoaXMuZW5kUG9pbnQueSkgPD0geVxyXG4gICAgICAgICAgICAgICAgJiYgeSA8PSBNYXRoLm1heCh0aGlzLnN0YXJ0UG9pbnQueSwgdGhpcy5lbmRQb2ludC55KSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciB2ZXJ0aWNhbCBsaW5lXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydFBvaW50LnggPT0gdGhpcy5lbmRQb2ludC54KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggPT0gdGhpcy5zdGFydFBvaW50Lng7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyB1c3VhbCAobm90IHZlcnRpY2FsKSBsaW5lIGNhbiBiZSByZXByZXNlbnRlZCBhcyB5ID0gYSAqIHggKyBiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSAodGhpcy5lbmRQb2ludC55IC0gdGhpcy5zdGFydFBvaW50LnkpIC8gKHRoaXMuZW5kUG9pbnQueCAtIHRoaXMuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMuc3RhcnRQb2ludC55IC0gYSAqIHRoaXMuc3RhcnRQb2ludC54O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5ID09IGEgKiB4ICsgYjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICpTZWUgaWYgd2UgYXJlIG5lYXIgYSB7TGluZX0gYnkgYSBjZXJ0YWluIHJhZGl1cyAoYWxzbyBpbmNsdWRlcyB0aGUgZXh0cmVtaXRpZXMgaW50byBjb21wdXRhdGlvbilcclxuICAgICAgICAgKkBwYXJhbSB7TnVtYmVyfSB4IC0gdGhlIHggY29vcmRpbmF0ZXNcclxuICAgICAgICAgKkBwYXJhbSB7TnVtYmVyfSB5IC0gdGhlIHkgY29vcmRpbmF0ZXNcclxuICAgICAgICAgKkBwYXJhbSB7TnVtYmVyfSByYWRpdXMgLSB0aGUgcmFkaXVzIHRvIHNlYXJjaCBmb3JcclxuICAgICAgICAgKkBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9mcm9tX2FfcG9pbnRfdG9fYV9saW5lXHJcbiAgICAgICAgICpAc2VlIFwiTWF0aGVtYXRpY3MgZm9yIENvbXB1dGVyIEdyYXBoaWNzLCAybmQgRWQuLCBieSBKb2huIFZpY2UsIHBhZ2UgMjI3XCJcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgbmVhcjpmdW5jdGlvbih4LHkscmFkaXVzKXtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuZW5kUG9pbnQueCA9PT0gdGhpcy5zdGFydFBvaW50LngpeyAvL1ZlcnRpY2FsIGxpbmUsIHNvIHRoZSB2aWNpbml0eSBhcmVhIGlzIGEgcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCAodGhpcy5zdGFydFBvaW50LnktcmFkaXVzPD15ICYmIHRoaXMuZW5kUG9pbnQueStyYWRpdXM+PXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICh0aGlzLmVuZFBvaW50LnktcmFkaXVzPD15ICYmIHRoaXMuc3RhcnRQb2ludC55K3JhZGl1cz49eSkpXHJcbiAgICAgICAgICAgICAgICAmJiB4ID4gdGhpcy5zdGFydFBvaW50LnggLSByYWRpdXMgJiYgeCA8IHRoaXMuc3RhcnRQb2ludC54ICsgcmFkaXVzIDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5zdGFydFBvaW50LnkgPT09IHRoaXMuZW5kUG9pbnQueSl7IC8vSG9yaXpvbnRhbCBsaW5lLCBzbyB0aGUgdmljaW5pdHkgYXJlYSBpcyBhIHJlY3RhbmdsZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICggKHRoaXMuc3RhcnRQb2ludC54IC0gcmFkaXVzPD14ICYmIHRoaXMuZW5kUG9pbnQueCtyYWRpdXM+PXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICh0aGlzLmVuZFBvaW50LngtcmFkaXVzPD14ICYmIHRoaXMuc3RhcnRQb2ludC54K3JhZGl1cz49eCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHk+dGhpcy5zdGFydFBvaW50LnktcmFkaXVzICYmIHk8dGhpcy5zdGFydFBvaW50LnkrcmFkaXVzIDtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBzdGFydFggPSBNYXRoLm1pbih0aGlzLmVuZFBvaW50LngsdGhpcy5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gTWF0aC5taW4odGhpcy5lbmRQb2ludC55LHRoaXMuc3RhcnRQb2ludC55KTtcclxuICAgICAgICAgICAgdmFyIGVuZFggPSBNYXRoLm1heCh0aGlzLmVuZFBvaW50LngsdGhpcy5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgZW5kWSA9IE1hdGgubWF4KHRoaXMuZW5kUG9pbnQueSx0aGlzLnN0YXJ0UG9pbnQueSk7XHJcblxyXG4gICAgICAgICAgICAvKldlIHdpbGwgY29tcHV0ZSB0aGUgZGlzdGFuY2UgZnJvbSBwb2ludCB0byB0aGUgbGluZVxyXG4gICAgICAgICAgICAgKiBieSB1c2luZyB0aGUgYWxnb3JpdGhtIGZyb21cclxuICAgICAgICAgICAgICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9mcm9tX2FfcG9pbnRfdG9fYV9saW5lXHJcbiAgICAgICAgICAgICAqICovXHJcblxyXG4gICAgICAgICAgICAvL0ZpcnN0IHdlIG5lZWQgdG8gZmluZCBhLGIsYyBvZiB0aGUgbGluZSBlcXVhdGlvbiBheCArIGJ5ICsgYyA9IDBcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmVuZFBvaW50LnkgLSB0aGlzLnN0YXJ0UG9pbnQueTtcclxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLnN0YXJ0UG9pbnQueCAtIHRoaXMuZW5kUG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIGMgPSAtKHRoaXMuc3RhcnRQb2ludC54ICogdGhpcy5lbmRQb2ludC55IC0gdGhpcy5lbmRQb2ludC54ICogdGhpcy5zdGFydFBvaW50LnkpO1xyXG5cclxuICAgICAgICAgICAgLy9TZWNvbmRseSB3ZSBnZXQgdGhlIGRpc3RhbmNlIFwiTWF0aGVtYXRpY3MgZm9yIENvbXB1dGVyIEdyYXBoaWNzLCAybmQgRWQuLCBieSBKb2huIFZpY2UsIHBhZ2UgMjI3XCJcclxuICAgICAgICAgICAgdmFyIGQgPSBNYXRoLmFicyggKGEqeCArIGIqeSArIGMpIC8gTWF0aC5zcXJ0KE1hdGgucG93KGEsMikgKyBNYXRoLnBvdyhiLDIpKSApO1xyXG5cclxuICAgICAgICAgICAgLy9UaGlyZGx5IHdlIGdldCBjb29yZGluYXRlcyBvZiBjbG9zZXN0IGxpbmUncyBwb2ludCB0byB0YXJnZXQgcG9pbnRcclxuICAgICAgICAgICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc3RhbmNlX2Zyb21fYV9wb2ludF90b19hX2xpbmUjQ2FydGVzaWFuX2Nvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIHZhciBjbG9zZXN0WCA9IChiICogKGIqeCAtIGEqeSkgLSBhKmMpIC8gKCBNYXRoLnBvdyhhLDIpICsgTWF0aC5wb3coYiwyKSApO1xyXG4gICAgICAgICAgICB2YXIgY2xvc2VzdFkgPSAoYSAqICgtYip4ICsgYSp5KSAtIGIqYykgLyAoIE1hdGgucG93KGEsMikgKyBNYXRoLnBvdyhiLDIpICk7XHJcblxyXG4gICAgICAgICAgICB2YXIgciA9ICggZCA8PSByYWRpdXMgJiYgZW5kWD49Y2xvc2VzdFggJiYgY2xvc2VzdFg+PXN0YXJ0WCAmJiBlbmRZPj1jbG9zZXN0WSAmJiBjbG9zZXN0WT49c3RhcnRZICkgLy90aGUgcHJvamVjdGlvbiBvZiB0aGUgcG9pbnQgZmFsbHMgSU5TSURFIG9mIHRoZSBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICB8fCB0aGlzLnN0YXJ0UG9pbnQubmVhcih4LHkscmFkaXVzKSB8fCB0aGlzLmVuZFBvaW50Lm5lYXIoeCx5LHJhZGl1cyk7IC8vdGhlIHByb2plY3Rpb24gb2YgdGhlIHBvaW50IGZhbGxzIE9VVFNJREUgb2YgdGhlIHNlZ21lbnRcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAgcjtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgYXJyYXkgZWFjaCB0aW1lLCBvciB3ZSB3aWxsIGFmZmVjdCB0aGUgYWN0dWFsIHNoYXBlKi9cclxuICAgICAgICBnZXRQb2ludHM6ZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh0aGlzLnN0YXJ0UG9pbnQpO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh0aGlzLmVuZFBvaW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipSZXR1cm4gdGhlIHtQb2ludH0gY29ycmVzcG9uZGluZyB0aGUgdCBjZXJ0YWluIHQgdmFsdWVcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gdCB0aGUgdmFsdWUgb2YgcGFyYW1ldGVyIHQsIHdoZXJlIHQgaW4gWzAsMV0sIHQgaXMgbGlrZSBhIHBlcmNlbnQqL1xyXG4gICAgICAgIGdldFBvaW50OiBmdW5jdGlvbih0KXtcclxuICAgICAgICAgICAgdmFyIFhwID0gdCAqICh0aGlzLmVuZFBvaW50LnggLSB0aGlzLnN0YXJ0UG9pbnQueCkgKyB0aGlzLnN0YXJ0UG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIFlwID0gdCAqICh0aGlzLmVuZFBvaW50LnkgLSB0aGlzLnN0YXJ0UG9pbnQueSkgKyB0aGlzLnN0YXJ0UG9pbnQueTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWHAsIFlwKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyAvKipcclxuICAgICAgICAvLyAgKiBSZXR1cm5zIHRoZSBtaWRkbGUgb2YgdGhlIGxpbmVcclxuICAgICAgICAvLyAgKiBAcmV0dXJuIHtQb2ludH0gdGhlIG1pZGRsZSBwb2ludFxyXG4gICAgICAgIC8vICAqICovXHJcbiAgICAgICAgLy8gZ2V0TWlkZGxlIDogZnVuY3Rpb24oKXtcclxuICAgICAgICAvLyAgICAgcmV0dXJuIFV0aWwuZ2V0TWlkZGxlKHRoaXMuc3RhcnRQb2ludCwgdGhpcy5lbmRQb2ludCk7XHJcbiAgICAgICAgLy8gfSxcclxuXHJcblxyXG4gICAgICAgIC8vIGdldExlbmd0aCA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgLy8gICAgIHJldHVybiBVdGlsLmdldExlbmd0aCh0aGlzLnN0YXJ0UG9pbnQsIHRoaXMuZW5kUG9pbnQpO1xyXG4gICAgICAgIC8vIH0sXHJcblxyXG4gICAgICAgIC8vIC8qKlxyXG4gICAgICAgIC8vICAqR2V0IGJvdW5kcyBmb3IgdGhpcyBsaW5lXHJcbiAgICAgICAgLy8gICpAYXV0aG9yIEFsZXggR2hlb3JnaGl1IDxhbGV4QHNjcmlwdG9pZC5jb20+XHJcbiAgICAgICAgLy8gICoqL1xyXG4gICAgICAgIC8vIGdldEJvdW5kczpmdW5jdGlvbigpe1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gVXRpbC5nZXRCb3VuZHModGhpcy5nZXRQb2ludHMoKSk7XHJcbiAgICAgICAgLy8gfSxcclxuXHJcbiAgICAgICAgLyoqU3RyaW5nIHJlcHJlc2VudGF0aW9uKi9cclxuICAgICAgICB0b1N0cmluZzpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gJ2xpbmUoJyArIHRoaXMuc3RhcnRQb2ludCArICcsJyArIHRoaXMuZW5kUG9pbnQgKyAnKSc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gTGluZTtcclxuXHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9MaW5lU3RydWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiBCUE1O6IqC54K557G7ICDmiYDmnInnmoRCUE1O5b2i54q26YO957un5om/5LiO5a6D77yM55So5oi36Ieq5a6a5LmJ6IqC54K55Y+v5Lul57un5om/5a6D5bm25rOo5YaM5Y2z5Y+v5L2/55SoXHJcbiAqIEBjbGFzcyBmaXNoLnRvcG8uRmlzaFRvcG9CcG1uLkJQTU5Ob2RlXHJcbiAqL1xyXG5cclxuXHJcblx0dmFyIE5vZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL05vZGVcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cdHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG5cdHZhciBjbGF6elV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvY2xhenonKTtcclxuXHQvL+WIm+W7uk5vZGXnsbsg5omA5pyJ5b2i54q26YO957un5om/Tm9kZVxyXG5cdGZ1bmN0aW9uIEJQTU5Ob2RlKG1vZGVsLCBhcGkpIHtcclxuXHRcdE5vZGUuY2FsbCh0aGlzKTtcclxuXHRcdHRoaXMubW9kZWwgPSBtb2RlbDtcclxuXHRcdHRoaXMub3B0aW9ucyA9XHJcblx0XHR7XHJcblx0XHRcdG91dGxpbmU6IHtcclxuXHRcdFx0XHRlbmFibGU6IHRydWUsIC8vIOaYr+WQpuacieWkluahhlxyXG5cdFx0XHRcdHJhZGl1czogdHJ1ZSwgLy8g5piv5ZCm5ZyG6KeSXHJcblx0XHRcdFx0aW5pdFZpc2libGU6IGZhbHNlXHJcblx0XHRcdH0sXHJcblx0XHRcdHRleHQ6IHtcclxuXHRcdFx0XHRjb2xvcjogJyMwMDAwMDAnLCAvLyDmlofmnKzpopzoibJcclxuXHRcdFx0XHRsaW5lSGVpZ2h0OiAyNCAvLyDmlofmnKzooYzpq5hcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHRcdHRoaXMuYnBtbkluZm8gPSB7dHlwZTogLTEsIG5hbWU6XCJCUE1ORGlhZ3JhbVwiLCBkaXNwbGF5TmFtZTpcIlRhc2tcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG5cdFx0dmFyIHJlc291cmNlSWQgPSBtb2RlbC5nZXQoXCJyZXNvdXJjZUlkXCIpO1xyXG5cdFx0aWYocmVzb3VyY2VJZCAmJiByZXNvdXJjZUlkICE9IFwiXCIpIHtcclxuXHRcdFx0dGhpcy5yZXNvdXJjZUlkID0gcmVzb3VyY2VJZDtcclxuXHRcdH1cclxuXHJcbiAgICAgICAgLy/liKTmlq3mmK/lkKbmnIlvcGVyYXRpb25Ob2RlXHJcbiAgICAgICAgdmFyIHByb3AgPSBtb2RlbC5nZXQoXCJwcm9wZXJ0aWVzXCIpO1xyXG4gICAgICAgIGlmIChwcm9wLm9wZXJhdGlvbkljb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlcmF0aW9uSWNvbnMgPSBwcm9wLm9wZXJhdGlvbkljb25zO1xyXG4gICAgICAgIH1cclxuXHRcdHRoaXMuaW5pdEV2ZW50KGFwaSk7XHJcblx0fVxyXG5cclxuICAgIEJQTU5Ob2RlLnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbihhcGkpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydkYmxjbGljaycsICdjbGljayddOy8vJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCdcclxuXHJcblxyXG4gICAgICAgIHpyVXRpbC5lYWNoKE1PVVNFX0VWRU5UX05BTUVTLCBmdW5jdGlvbiAoZXZlTmFtZSkge1xyXG4gICAgICAgICAgICB0aGF0Lm9uKGV2ZU5hbWUsIGZ1bmN0aW9uIChlKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG5cdCAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcblx0ICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBldmVOYW1lO1xyXG5cdCAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGF0O1xyXG5cdCAgICAgICAgICAgIGFwaS50cmlnZ2VyKGV2ZU5hbWUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluW9k+WJjeiKgueCueeahOWMheWbtOWSjCDnm7jlhbPlj4LmlbBcclxuICAgICAqIEByZXR1cm5zIHt7eDpOdW1iZXIsIHk6TnVtYmVyLCB3aWR0aDpOdW1iZXIsIGhlaWdodDpOdW1iZXIsIHBvaW50czpBcnJheSwgYm91bmRpbmdSZWN0Ok9iamVjdH19XHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSByZXR1cm4ueCDlvZPliY3oioLngrnnmoTkuK3lv4Pngrl45YC8XHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSByZXR1cm4ueSDlvZPliY3oioLngrnnmoTkuK3lv4Pngrl55YC8XHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSByZXR1cm4ud2lkdGgg5b2T5YmN6IqC54K555qE5a695bqmXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSByZXR1cm4uaGVpZ2h0IOW9k+WJjeiKgueCueeahOmrmOW6plxyXG4gICAgICogQHJldHVybnMge0FycmF5fSByZXR1cm4ucG9pbnRzIOW9k+WJjeiKgueCueeahOWMheWbtOWSjCBb5bem5LiK6KeS5Z2Q5qCH77yM5Y+z5LiK6KeS5Z2Q5qCH77yM5Y+z5LiL6KeS5Z2Q5qCH77yM5Y+z5LiL6KeS5Z2Q5qCHXSDnlKjkuo7oioLngrnpgInkuK3ml7bljIXlm7TomZrnur/moYZcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJldHVybi5ib3VuZGluZ1JlY3Qg5b2T5YmN6IqC54K555qE5YyF5Zu055+p5b2iXHJcbiAgICAgKi9cclxuICAgIEJQTU5Ob2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6L+U5Zue5b2T5YmN6IqC54K555qE5YyF5Zu055+p5b2iXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IOW9k+WJjeiKgueCueeahOWMheWbtOefqeW9oiAg5LiA6Iis5LiN5YyF5ous5LiL6Z2i55qE5paH5a2XXHJcbiAgICAgKi9cclxuICAgIEJQTU5Ob2RlLnByb3RvdHlwZS5nZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva7lm77lhYPnmoTkvY3nva5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHjlnZDmoIdcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHnlnZDmoIdcclxuICAgICAqL1xyXG4gICAgQlBNTk5vZGUucHJvdG90eXBlLnNldFBvc2l0aW9uICA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5p+l55yL5b2T5YmN6IqC54K55piv5ZCmIOWMheaLrHggLHkg5Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggeOWdkOagh1xyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB5IHnlnZDmoIdcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAg5piv5ZCm5Zyo6IyD5Zu05YaFXHJcbiAgICAgKi9cclxuICAgIEJQTU5Ob2RlLnByb3RvdHlwZS5yZWN0Q29udGFpbiA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIFx0dmFyIHJlY3QgPSB0aGlzLmdldFJlY3QoKTtcclxuICAgICAgICByZXR1cm4gcmVjdC5ib3VuZGluZ1JlY3QuY29udGFpbih4LHkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOi/lOWbnmpzb27lr7nosaFcclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30ganNvbuWvueixoVxyXG4gICAgICovXHJcblx0QlBNTk5vZGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5tb2RlbC5zZXQoXCJyZXNvdXJjZUlkXCIsIHRoaXMucmVzb3VyY2VJZCk7XHJcblx0XHR0aGlzLm1vZGVsLnNldChcInByb3BlcnRpZXMudHlwZVwiLCB0aGlzLmJwbW5JbmZvLnR5cGUpO1xyXG5cdFx0dGhpcy5tb2RlbC5zZXQoXCJzdGVuY2lsLnR5cGVcIiwgdGhpcy5icG1uSW5mby5uYW1lKTsgIC8vc3RlbmNpbC5pZFxyXG5cclxuICAgICAgICBpZiAodGhpcy5zbG90RXZlbnQgJiYgdGhpcy5zbG90RXZlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgYXJyU2xvdEV2ZW50ID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnNsb3RFdmVudC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgYXJyU2xvdEV2ZW50LnB1c2godGhpcy5zbG90RXZlbnRbaV0ucmVzb3VyY2VJZClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcInByb3BlcnRpZXMuc2xvdEV2ZW50XCIsIGFyclNsb3RFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwicHJvcGVydGllcy50eXBlXCIsIHRoaXMuYnBtbkluZm8udHlwZSk7XHJcblxyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRSZWN0KCkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIsIHBhcnNlSW50KHJlY3QueCkpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIsIHBhcnNlSW50KHJlY3QueSkpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLmxvd2VyUmlnaHQueFwiLCBwYXJzZUludChyZWN0LnggKyByZWN0LndpZHRoKSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC55XCIsIHBhcnNlSW50KHJlY3QueSArIHJlY3QuaGVpZ2h0KSk7XHJcblx0XHRyZXR1cm4gdGhpcy5tb2RlbC5vcHRpb247XHJcblx0fTtcclxuXHJcblx0LyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5qC55o2u5bGe5oCn6K6+572u5qih5Z6L5pWw5o2uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uIOaooeWei+aVsOaNrlxyXG4gICAgICovXHJcbiAgICBCUE1OTm9kZS5wcm90b3R5cGUuc2V0TW9kZWwgPSBmdW5jdGlvbihvcHRpb24pIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG9yaWdpblRleHQgPSB0aGlzLm1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKTtcclxuICAgICAgICB0aGlzLm1vZGVsLm1lcmdlT3B0aW9uKG9wdGlvbik7XHJcbiAgICAgICAgaWYob3JpZ2luVGV4dCAhPSBvcHRpb24ucHJvcGVydGllcy5uYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IHRoaXMuY2hpbGRPZk5hbWUoXCJUaXRsZVwiKTtcclxuICAgICAgICAgICAgdmFyIG5hbWVCeXRlTGVuZ3RoID0gb3B0aW9uLnByb3BlcnRpZXMubmFtZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBzaG93TmFtZTtcclxuICAgICAgICAgICAgaWYobmFtZUJ5dGVMZW5ndGggPiA2NCl7XHJcbiAgICAgICAgICAgICAgICBzaG93TmFtZSA9IG9wdGlvbi5wcm9wZXJ0aWVzLm5hbWUuc3Vic3RyKDAsNjQpKycuLic7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmFsYXJtKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsYXJtLmlzU2hvdyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgc2hvd05hbWUgPSBvcHRpb24ucHJvcGVydGllcy5uYW1lO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5hbGFybSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGFybS5pc1Nob3cgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGl0bGUuYXR0cihcInN0eWxlXCIse3RleHQ6c2hvd05hbWV9KTtcclxuICAgICAgICAgICAgdGhhdC5yZWZyZXNoVGV4dCh0aGF0KTtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBvcHRpb24ucHJvcGVydGllcy5uYW1lO1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuYWxhcm0uY2hpbGRPZk5hbWUoXCJUZXh0XCIpO1xyXG4gICAgICAgICAgICB0ZXh0LmF0dHIoXCJzdHlsZVwiLHt0ZXh0Om5hbWV9KTtcclxuICAgICAgICAgICAgdmFyIGdyb3VwV2lkdGggPSB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLndpZHRoKzQ7XHJcbiAgICAgICAgICAgIHZhciBncm91cEhlaWdodCA9IHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0Kzg7XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXHJcbiAgICAgICAgICAgICAgICBbMCwwXSxcclxuICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLDBdLFxyXG4gICAgICAgICAgICAgICAgW2dyb3VwV2lkdGgsZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgW2dyb3VwV2lkdGgtMyxncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICBbZ3JvdXBXaWR0aC02LGdyb3VwSGVpZ2h0KzNdLFxyXG4gICAgICAgICAgICAgICAgW2dyb3VwV2lkdGgtOSxncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICBbMCxncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgICAgICBbMCwwXVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB2YXIgUG9seWxpbmUgPSB0aGlzLmFsYXJtLmNoaWxkT2ZOYW1lKFwiUG9seWxpbmVcIik7XHJcbiAgICAgICAgICAgIFBvbHlsaW5lLmF0dHIoXCJzaGFwZVwiLHtwb2ludHM6cG9pbnRzfSk7XHJcbiAgICAgICAgICAgIHZhciBncm91cFBvc2l0aW9uID0gW3RoaXMucG9zaXRpb25bMF0rdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aC0odGhpcy5hbGFybS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aC02KSx0aGlzLnBvc2l0aW9uWzFdLXRoaXMuYWxhcm0uZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0LTNdO1xyXG4gICAgICAgICAgICB0aGlzLmFsYXJtLmF0dHIoXCJwb3NpdGlvblwiLGdyb3VwUG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoQlBNTk5vZGUsTm9kZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDms6jlhoxCUE1O6IqC54K555qE57G777yM5Y+q5pyJ5rOo5YaM6L+H5ZCO77yM5omN6IO95ZyoQlBNTue8lui+keWZqOS4rea3u+WKoFxyXG4gICAgICogQG1ldGhvZCByZWdpc3RlckNsYXNzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gQ2xhenog57un5om/5LqGQlBNTk5vZGXnmoTlrp7njrDnsbtcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnRUeXBlIOazqOWGjOexu+eahOWQjeensFxyXG4gICAgICpcclxuICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICBCUE1OTm9kZS5yZWdpc3RlckNsYXNzKEN1c3RvbU5vZGUsIFwiQ3VzdG9tTm9kZVwiKTtcclxuICAgICAqL1xyXG5cdGNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoQlBNTk5vZGUsIHtcclxuICAgICAgICByZWdpc3RlcldoZW5FeHRlbmQ6IHRydWVcclxuICAgIH0pO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gQlBNTk5vZGU7XHJcblxyXG5cclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvQlBNTk5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4vZ3JhcGhpYycpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsLmpzXCIpXHJcbiAgICAvL+WIm+W7uk5vZGXnsbsg5omA5pyJ5b2i54q26YO957un5om/Tm9kZSAg5YyF5ousZnJvbUpTT04gdG9KU09OXHJcbiAgICBmdW5jdGlvbiBOb2RlKCkge1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VJZCA9IHV0aWwuZ2V0VVVJRCgpOyAvLyDnlJ/miJDoioLngrlJRFxyXG4gICAgICAgIGdyYXBoaWMuR3JvdXAuY2FsbCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOeUseeItuexu+WunueOsFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlLHniLbnsbvlrp7njrBcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0ganNvbiBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBOb2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24oanNvbikge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkcmF3VGV4dFxyXG4gICAgICogQGRlc2NyaXB0aW9uIOeUu+S4gOS4quaWh+acrFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxyXG4gICAgICovXHJcbiAgICBOb2RlLnByb3RvdHlwZS5kcmF3VGV4dCA9IGZ1bmN0aW9uKG5hbWUsY29sb3IpIHtcclxuICAgICAgICB2YXIgdGV4dE5hbWUgPSB0aGlzLmJwbW5JbmZvLm5hbWU7XHJcbiAgICAgICAgaWYobmFtZSAhPSBudWxsKXtcclxuICAgICAgICAgICAgdGV4dE5hbWUgPSBuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGV4dCA9IG5ldyBncmFwaGljLlRleHQoe1xyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dE5hbWUsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IgPyBjb2xvciA6IHRoaXMub3B0aW9ucy50ZXh0LmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6ICcxMnB4IE1pY3Jvc29mdCBZYUhlaSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgemxldmVsOiAyMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8v5paH5a2X57uY5Yi255qE5L2N572uICBcclxuICAgICAgICAvL3ggPSDkuK3lv4PngrkueCAtIOi1t+Wni+S9jee9ri54IC0g5paH5a2X5a695bqm55qE5LiA5Y2KXHJcbiAgICAgICAgdmFyIHggPSB0aGlzLmdldFJlY3QoKS54IC0gdGhpcy5wb3NpdGlvblswXSAtIHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLyAyO1xyXG4gICAgICAgIC8veSA9IOS4reW/g+eCuS55IC0g6LW35aeL5L2N572uLnkgKyDoioLngrnpq5jluqbnmoTkuIDljYogKyDlgY/np7vlgLzvvIg277yJXHJcbiAgICAgICAgdmFyIHkgPSB0aGlzLmdldFJlY3QoKS55IC0gdGhpcy5wb3NpdGlvblsxXSArIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC8gMiArIHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0ICsgNjtcclxuICAgICAgICB0ZXh0LmF0dHIoXCJzdHlsZVwiLCB7IHg6IHgsIHk6IHkgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgcmVjdDogdGV4dC5nZXRCb3VuZGluZ1JlY3QoKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiByZWZyZXNoVGV4dFxyXG4gICAgICogQGRlc2NyaXB0aW9uIOWIt+aWsOaWh+acrFxyXG4gICAgICovXHJcbiAgICBOb2RlLnByb3RvdHlwZS5yZWZyZXNoVGV4dCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5jaGlsZE9mTmFtZShcIlRpdGxlXCIpO1xyXG4gICAgICAgIHZhciB4ID0gdGhpcy5nZXRSZWN0KCkueCAtIHRoaXMucG9zaXRpb25bMF0gLSB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC8gMjtcclxuICAgICAgICB2YXIgeSA9IHRoaXMuZ2V0UmVjdCgpLnkgLSB0aGlzLnBvc2l0aW9uWzFdICsgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyICsgdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgKyA2O1xyXG4gICAgICAgIHRleHQuYXR0cihcInN0eWxlXCIsIHsgeDogeCwgeTogeSB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOeUseeItuexu+WunueOsFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgZ3JhcGhpYy5VdGlsLmluaGVyaXRzKE5vZGUsIGdyYXBoaWMuR3JvdXApO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblxyXG4gICAgdmFyIGNsYXp6ID0ge307XHJcblxyXG4gICAgdmFyIFRZUEVfREVMSU1JVEVSID0gJy4nO1xyXG4gICAgdmFyIElTX0NPTlRBSU5FUiA9ICdfX19GVF9fQ09NUE9ORU5UX19DT05UQUlORVJfX18nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHZhciBwYXJzZUNsYXNzVHlwZSA9IGNsYXp6LnBhcnNlQ2xhc3NUeXBlID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICB2YXIgcmV0ID0ge21haW46ICcnLCBzdWI6ICcnfTtcclxuICAgICAgICBpZiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZS5zcGxpdChUWVBFX0RFTElNSVRFUik7XHJcbiAgICAgICAgICAgIHJldC5tYWluID0gY29tcG9uZW50VHlwZVswXSB8fCAnJztcclxuICAgICAgICAgICAgcmV0LnN1YiA9IGNvbXBvbmVudFR5cGVbMV0gfHwgJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHVibGljICDnm7jmr5Qg55u05o6l55SoenJVdGlsLmluaGVyaXRzIOWlveWkhOaYryAg5Y+v5Lul55u05o6l6LCD55So54i257G755qE5p6E6YCg5Ye95pWwXHJcbiAgICAgKi9cclxuICAgIGNsYXp6LmVuYWJsZUNsYXNzRXh0ZW5kID0gZnVuY3Rpb24gKFJvb3RDbGFzcywgcHJlQ29uc3RydWN0KSB7XHJcbiAgICAgICAgUm9vdENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xyXG4gICAgICAgICAgICB2YXIgRXh0ZW5kZWRDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHByZUNvbnN0cnVjdCAmJiBwcmVDb25zdHJ1Y3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIFJvb3RDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgenJVdGlsLmV4dGVuZChFeHRlbmRlZENsYXNzLnByb3RvdHlwZSwgcHJvdG8pO1xyXG5cclxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5leHRlbmQgPSB0aGlzLmV4dGVuZDtcclxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckNhbGwgPSBzdXBlckNhbGw7XHJcbiAgICAgICAgICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJBcHBseSA9IHN1cGVyQXBwbHk7XHJcbiAgICAgICAgICAgIHpyVXRpbC5pbmhlcml0cyhFeHRlbmRlZENsYXNzLCB0aGlzKTtcclxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckNsYXNzID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBFeHRlbmRlZENsYXNzO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHN1cGVyQ2FsbCBzaG91bGQgaGF2ZSBjbGFzcyBpbmZvLCB3aGljaCBjYW4gbm90IGJlIGZldGNoIGZyb20gJ3RoaXMnLlxyXG4gICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOlxyXG4gICAgLy8gY2xhc3MgQSBoYXMgbWV0aG9kIGYsXHJcbiAgICAvLyBjbGFzcyBCIGluaGVyaXRzIGNsYXNzIEEsIG92ZXJyaWRlcyBtZXRob2QgZiwgZiBjYWxsIHN1cGVyQXBwbHkoJ2YnKSxcclxuICAgIC8vIGNsYXNzIEMgaW5oZXJpdHMgY2xhc3MgQiwgZG8gbm90IG92ZXJyaWRlcyBtZXRob2QgZixcclxuICAgIC8vIHRoZW4gd2hlbiBtZXRob2Qgb2YgY2xhc3MgQyBpcyBjYWxsZWQsIGRlYWQgbG9vcCBvY2N1cmVkLlxyXG4gICAgZnVuY3Rpb24gc3VwZXJDYWxsKGNvbnRleHQsIG1ldGhvZE5hbWUpIHtcclxuICAgICAgICB2YXIgYXJncyA9IHpyVXRpbC5zbGljZShhcmd1bWVudHMsIDIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1cGVyQXBwbHkoY29udGV4dCwgbWV0aG9kTmFtZSwgYXJncykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudGl0eVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVnaXN0ZXJXaGVuRXh0ZW5kXVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjbGF6ei5lbmFibGVDbGFzc01hbmFnZW1lbnQgPSBmdW5jdGlvbiAoZW50aXR5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbXBvbmVudCBtb2RlbCBjbGFzc2VzXHJcbiAgICAgICAgICoga2V5OiBjb21wb25lbnRUeXBlLFxyXG4gICAgICAgICAqIHZhbHVlOlxyXG4gICAgICAgICAqICAgICBjb21wb25lbnRDbGFzcywgd2hlbiBjb21wb25lbnRUeXBlIGlzICd4eHgnXHJcbiAgICAgICAgICogICAgIG9yIE9iamVjdC48c3ViS2V5LCBjb21wb25lbnRDbGFzcz4sIHdoZW4gY29tcG9uZW50VHlwZSBpcyAneHh4Lnl5J1xyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB7fTtcclxuXHJcbiAgICAgICAgZW50aXR5LnJlZ2lzdGVyQ2xhc3MgPSBmdW5jdGlvbiAoQ2xhenosIGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudFR5cGUuc3ViKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+W3sue7j+azqOWGjOi/h+S6hu+8jOebtOaOpei/lOWbnlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXSA9IENsYXp6O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50VHlwZS5zdWIgIT09IElTX0NPTlRBSU5FUikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBtYWtlQ29udGFpbmVyKGNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcltjb21wb25lbnRUeXBlLnN1Yl0gPSBDbGF6ejtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gQ2xheno7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZW50aXR5LmdldENsYXNzID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGVNYWluLCBzdWJUeXBlLCB0aHJvd1doZW5Ob3RGb3VuZCkge1xyXG4gICAgICAgICAgICB2YXIgQ2xhenogPSBzdG9yYWdlW2NvbXBvbmVudFR5cGVNYWluXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChDbGF6eiAmJiBDbGF6eltJU19DT05UQUlORVJdKSB7XHJcbiAgICAgICAgICAgICAgICBDbGF6eiA9IHN1YlR5cGUgPyBDbGF6eltzdWJUeXBlXSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aHJvd1doZW5Ob3RGb3VuZCAmJiAhQ2xhenopIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAnQ29tcG9uZW50ICcgKyBjb21wb25lbnRUeXBlTWFpbiArICcuJyArIChzdWJUeXBlIHx8ICcnKSArICcgbm90IGV4aXN0cy4gTG9hZCBpdCBmaXJzdC4nXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gQ2xheno7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZW50aXR5LmdldENsYXNzZXNCeU1haW5UeXBlID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmpbSVNfQ09OVEFJTkVSXSkge1xyXG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2gob2JqLCBmdW5jdGlvbiAobywgdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgIT09IElTX0NPTlRBSU5FUiAmJiByZXN1bHQucHVzaChvKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBlbnRpdHkuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICAvLyBKdXN0IGNvbnNpZGVyIGNvbXBvbmVudFR5cGUubWFpbi5cclxuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gISFzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IExpa2UgWydhYScsICdiYiddLCBidXQgY2FuIG5vdCBiZSBbJ2FhLnh4J11cclxuICAgICAgICAgKi9cclxuICAgICAgICBlbnRpdHkuZ2V0QWxsQ2xhc3NNYWluVHlwZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0eXBlcyA9IFtdO1xyXG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdG9yYWdlLCBmdW5jdGlvbiAob2JqLCB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKHR5cGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIGEgbWFpbiB0eXBlIGlzIGNvbnRhaW5lciBhbmQgaGFzIHN1YiB0eXBlc1xyXG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gIGNvbXBvbmVudFR5cGVcclxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVudGl0eS5oYXNTdWJUeXBlcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcclxuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmpbSVNfQ09OVEFJTkVSXTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBlbnRpdHkucGFyc2VDbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbWFrZUNvbnRhaW5lcihjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XHJcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyIHx8ICFjb250YWluZXJbSVNfQ09OVEFJTkVSXSkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dID0ge307XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJbSVNfQ09OVEFJTkVSXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnJlZ2lzdGVyV2hlbkV4dGVuZCkge1xyXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxFeHRlbmQgPSBlbnRpdHkuZXh0ZW5kO1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxFeHRlbmQpIHtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5leHRlbmQgPSBmdW5jdGlvbiAocHJvdG8pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgRXh0ZW5kZWRDbGFzcyA9IG9yaWdpbmFsRXh0ZW5kLmNhbGwodGhpcywgcHJvdG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRpdHkucmVnaXN0ZXJDbGFzcyhFeHRlbmRlZENsYXNzLCBwcm90by50eXBlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBlbnRpdHk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gY2xheno7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9jbGF6ei5qc1xuICoqIG1vZHVsZSBpZCA9IDc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICogQlBNTiBtb2RlbFxyXG4gKlxyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL01vZGVsJyk7XHJcbiAgICB2YXIgQlBNTk1vZGVsID0gTW9kZWwuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ0JQTU4nLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcclxuICAgICAgICAgICAgcmVzb3VyY2VJZDogXCJcIiwgIC8v6LWE5rqQSURcclxuXHJcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IC0xLCAgLy/nsbvlnotcclxuICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsIC8v5ZCN56ewXHJcbiAgICAgICAgICAgICAgICBub3RlczogXCJcIiwgIC8v5aSH5rOoXHJcbiAgICAgICAgICAgICAgICAvL25vOiBcIlwiXHJcbiAgICAgICAgICAgICAgICBleHRQcm9wZXJ0aWVzOiB7fSAgLy/mianlsZXlsZ7mgKdcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHN0ZW5jaWw6IHt0eXBlOiBcIkJQTU5EaWFncmFtXCJ9LFxyXG5cclxuICAgICAgICAgICAgY2hpbGRTaGFwZXM6IFtdLCAgICAvL+WtkOW9oueKtlxyXG5cclxuICAgICAgICAgICAgb3V0Z29pbmc6IFtdLCAgLy8g5LiL5LiA5Liq6KaB6L+e5o6l55qE5b2i54q2XHJcblxyXG4gICAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgICAgIHVwcGVyTGVmdDoge3g6MCwgeTowfSwgIC8v5bem5LiK6KeS5Z2Q5qCHXHJcbiAgICAgICAgICAgICAgICBsb3dlclJpZ2h0OiB7eDowLCB5OjB9IC8v5Y+z5LiL6KeS5Z2Q5qCHXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQlBNTk1vZGVsO1xyXG5cclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL21vZGVsL0JQTU5Nb2RlbC5qc1xuICoqIG1vZHVsZSBpZCA9IDc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog6IqC54K5562J55qE5qih5Z6LXHJcbiAqIOmHjOmdouWtmOeahOaVsOaNrueUqOadpeWkhOeQhuW6j+WIl+WMluWSjOWPjeW6j+WIl+WMllxyXG4gKiBAY2xhc3MgZmlzaC50b3BvLm1vZGVsXHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi9jbGF6eicpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1vZGVsKG9wdGlvbiwgcGFyZW50TW9kZWwsICBleHRyYU9wdCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50TW9kZWwgPSBwYXJlbnRNb2RlbDtcclxuICAgICAgICB0aGlzLm9wdGlvbiA9IG9wdGlvbjtcclxuXHJcbiAgICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxyXG4gICAgICAgIGlmICh0aGlzLmluaXQpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KG9wdGlvbiwgcGFyZW50TW9kZWwsICBleHRyYU9wdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBNb2RlbC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBNb2RlbCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTW9kZWwg55qE5Yid5aeL5YyW5Ye95pWwXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCB0aGlzLmdldERlZmF1bHRPcHRpb24oKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0RGVmYXVsdE9wdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ19fZGVmYXVsdE9wdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0TGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIENsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHQgPSBDbGFzcy5wcm90b3R5cGUuZGVmYXVsdE9wdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBvcHQgJiYgb3B0TGlzdC5wdXNoKG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBDbGFzcy5zdXBlckNsYXNzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0T3B0aW9uID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gb3B0TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb24gPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbiwgb3B0TGlzdFtpXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGVmYXVsdE9wdGlvbiA9IGRlZmF1bHRPcHRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kZWZhdWx0T3B0aW9uO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICAgICAgenJVdGlsLm1lcmdlKHRoaXMub3B0aW9uLCBvcHRpb24sIHRydWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPlm1vZGVs55qE5p+Q5Liq5bGe5oCn55qE5YC8XHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggbW9kZWzkuK3nmoTlsZ7mgKdcclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAgICAgbm9kZS5tb2RlbC5nZXQoXCJvcHRpb25zLnRleHRcIik7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAocGF0aCwgaWdub3JlUGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghcGF0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5vcHRpb247XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRNb2RlbCA9IHRoaXMucGFyZW50TW9kZWw7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gb2JqIGNvdWxkIGJlIG51bWJlci9zdHJpbmcvLi4uIChsaWtlIDApXHJcbiAgICAgICAgICAgICAgICBvYmogPSAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSA/IG9ialtwYXRoW2ldXSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2JqID09IG51bGwgJiYgcGFyZW50TW9kZWwgJiYgIWlnbm9yZVBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgb2JqID0gcGFyZW50TW9kZWwuZ2V0KHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6K6+572ubW9kZWznmoTmn5DkuKrlsZ7mgKfnmoTlgLxcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBtb2RlbOS4reeahOWxnuaAp1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSDmiYDpnIDopoHorr7nva7nmoTlgLxcclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAgICAgbm9kZS5tb2RlbC5zZXQoXCJvcHRpb25zLnRleHRcIixcIuS+i+WtkFwiKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXRoLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5vcHRpb247XHJcblxyXG4gICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKFwiLlwiKSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgb2JqW3BhdGhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRBcnJheSAgPSBwYXRoLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGZpZWxkQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRSZWYgPSBvYmo7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGROYW1lO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkQXJyYXlbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudFJlZltmaWVsZE5hbWVdID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlZltmaWVsZE5hbWVdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZWYgPSBjdXJyZW50UmVmW2ZpZWxkTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWUgPSBmaWVsZEFycmF5W24tMV07XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVmW2ZpZWxkTmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0U2hhbGxvdzogZnVuY3Rpb24gKGtleSwgaWdub3JlUGFyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IG9wdGlvbiAmJiBvcHRpb25ba2V5XTtcclxuICAgICAgICAgICAgdmFyIHBhcmVudE1vZGVsID0gdGhpcy5wYXJlbnRNb2RlbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsICYmIHBhcmVudE1vZGVsICYmICFpZ25vcmVQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IHBhcmVudE1vZGVsLmdldFNoYWxsb3coa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0TW9kZWw6IGZ1bmN0aW9uIChwYXRoLCBwYXJlbnRNb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXQocGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciB0aGlzUGFyZW50TW9kZWwgPSB0aGlzLnBhcmVudE1vZGVsO1xyXG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoXHJcbiAgICAgICAgICAgICAgICBvYmosIHBhcmVudE1vZGVsIHx8ICh0aGlzUGFyZW50TW9kZWwgJiYgdGhpc1BhcmVudE1vZGVsLmdldE1vZGVsKHBhdGgpKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kZWw7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICrmuIXnqbptb2RlbOeahG9wdGlvblxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb24gPT0gbnVsbDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKCkge30sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIEN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoenJVdGlsLmNsb25lKHRoaXMub3B0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFbmFibGUgTW9kZWwuZXh0ZW5kLlxyXG4gICAgY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKE1vZGVsKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTW9kZWwuanNcbiAqKiBtb2R1bGUgaWQgPSA3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcblx0dmFyIEV2ZW50Tm9kZSA9IHJlcXVpcmUoXCIuL0V2ZW50Tm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBpZD1cInNpZC1GRjBBREZDMC1EM0VDLTQyMzctQUQxNi1BMzYyNzNEMUZFNkRcIiB0aXRsZT1cIlN0YXJ0IGV2ZW50XCI+XHJcbiAqICAgIDxjaXJjbGUgaWQ9XCJzaWQtRkYwQURGQzAtRDNFQy00MjM3LUFEMTYtQTM2MjczRDFGRTZEYmdfZnJhbWVcIiBjeD1cIjE1XCIgY3k9XCIxNVwiIHI9XCIxNVwiIHN0cm9rZT1cIlwiIGZpbGw9XCIjN0VEMzIxXCI+PC9jaXJjbGU+XHJcbiAqICAgIDxwYXRoIGQ9XCJNMTEuMjUsOC4yNSBMMTEuMjUsMjIuNSBMMjIuNSwxNS4zNzUgTDExLjI1LDguMjUgWlwiIGlkPVwic2lkLUZGMEFERkMwLUQzRUMtNDIzNy1BRDE2LUEzNjI3M0QxRkU2RHBhdGgxXCIgZmlsbD1cIiNGRkZGRkZcIj48L3BhdGg+XHJcbiAqIDwvZz5cclxuICovXHJcblxyXG5cdGZ1bmN0aW9uIFN0YXJ0RXZlbnROb2RlKG1vZGVsLCBhcGkpIHtcclxuXHRcdEV2ZW50Tm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRJY29uID0gJ00xMS4yNSw4LjI1IEwxMS4yNSwyMi41IEwyMi41LDE1LjM3NSBMMTEuMjUsOC4yNSBaJztcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMjA7XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDI5LCBuYW1lOlwiU3RhcnROb25lRXZlbnRcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG5cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcblxyXG5cdH1cclxuXHJcbiAgICBTdGFydEV2ZW50Tm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB2YXIgY2lyY2xlID0gbmV3IGdyYXBoaWMuQ2lyY2xlKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogJyM3RUQzMjEnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgejoyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2lyY2xlLm5hbWUgPSBcIkNpcmNsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKGNpcmNsZSk7XHJcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZTtcclxuICAgICAgICB2YXIgcmVjdCA9IHt4Oi1pdGVtU2l6ZS8yLCB5OiAtaXRlbVNpemUvMiwgd2lkdGg6IGl0ZW1TaXplLCBoZWlnaHQ6aXRlbVNpemV9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5zdGFydEljb24sIHtzdHlsZToge2ZpbGw6ICcjRkZGRkZGJ30sejoyfSwgcmVjdCxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIikraXRlbVNpemUgLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIikraXRlbVNpemVdO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHJcblx0enJVdGlsLmluaGVyaXRzKFN0YXJ0RXZlbnROb2RlLCBFdmVudE5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gU3RhcnRFdmVudE5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2V2ZW50L1N0YXJ0RXZlbnROb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG4gICAgdmFyIEJQTU5Ob2RlID0gcmVxdWlyZShcIi4uL0JQTU5Ob2RlXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcbiAgICAvL+WIm+W7uk5vZGXnsbsg5omA5pyJ5b2i54q26YO957un5om/Tm9kZSAg5YyF5ousZnJvbUpTT04gdG9KU09OXHJcbiAgICAvL1xyXG4gICAgZnVuY3Rpb24gRXZlbnROb2RlKG1vZGVsLGFwaSkge1xyXG4gICAgICAgIEJQTU5Ob2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5icG1uSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTpcIkV2ZW50Tm9kZVwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBFdmVudE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIEV2ZW50Tm9kZS5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIGJvZHkuLi5cclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAvL+WIm+W7uuacgOWwj+WMheWbtOebkuiZmue6v1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICBwb2ludHNbMF0gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzFdID1bYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzJdID1bYm91bmRpbmdSZWN0LndpZHRoLzIsYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbM10gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbNF0gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcblxyXG4gICAgICAgIC8v5rOoOiDlm6Dkuovku7bkuLrlnIblvaIgIOaJgOS7pSB4IHkg5Li65ZyG5b+D55qE5L2N572uICDljIXlm7Tnn6nlvaLopoHlh4/ljrvlrr3luqbkuIDljYpcclxuICAgICAgICB2YXIgYm91bmRSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCh0aGlzLnBvc2l0aW9uWzBdIC0gYm91bmRpbmdSZWN0LndpZHRoLzIgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0gLSBib3VuZGluZ1JlY3QuaGVpZ2h0LzIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRpbmdSZWN0LndpZHRoLCBib3VuZGluZ1JlY3QuaGVpZ2h0KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB0aGlzLnBvc2l0aW9uWzBdLFxyXG4gICAgICAgICAgICB5OiB0aGlzLnBvc2l0aW9uWzFdLFxyXG4gICAgICAgICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLzIsXHJcbiAgICAgICAgICAgIGhlaWdodDogYm91bmRpbmdSZWN0LmhlaWdodC8yLFxyXG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcclxuICAgICAgICAgICAgYm91bmRpbmdSZWN0OiBib3VuZFJlY3RcclxuICAgICAgICB9O1xyXG5cclxuICAgIH07XHJcbiAgICBFdmVudE5vZGUucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ocFgscFkpIHtcclxuICAgICAgICAvLyBib2R5Li4uXHJcbiAgICAgICAgdGhpcy5hdHRyKCdwb3NpdGlvbicsW3BYLHBZXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEV2ZW50Tm9kZS5wcm90b3R5cGUuZ2V0Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IHRoaXMuY2hpbGRPZk5hbWUoXCJDaXJjbGVcIik7XHJcbiAgICAgICAgcmV0dXJuIGNpcmNsZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhFdmVudE5vZGUsQlBNTk5vZGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudE5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2V2ZW50L0V2ZW50Tm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuXHR2YXIgRXZlbnROb2RlID0gcmVxdWlyZShcIi4vRXZlbnROb2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcblxyXG4vKipcclxuPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgaWQ9XCJzaWQtMzlFRjA0NUUtNjZCNS00NDlELUIzMDAtNUNCQ0U0RDY2OThFXCIgdGl0bGU9XCJJbnRlcm1lZGlhdGUgc2lnbmFsIGNhdGNoaW5nIGV2ZW50XCI+XHJcbiAgPGNpcmNsZSBpZD1cInNpZC0zOUVGMDQ1RS02NkI1LTQ0OUQtQjMwMC01Q0JDRTRENjY5OEViZ19mcmFtZVwiIGN4PVwiMTVcIiBjeT1cIjE1XCIgcj1cIjE1XCIgZmlsbD1cIiNEMDAxMUJcIj48L2NpcmNsZT5cclxuICA8cmVjdCBpZD1cInNpZC0zOUVGMDQ1RS02NkI1LTQ0OUQtQjMwMC01Q0JDRTRENjY5OEViZ19yZWN0XCIgZmlsbD1cIiNGRkZGRkZcIiB4PVwiOVwiIHk9XCI5XCIgd2lkdGg9XCIxMlwiIGhlaWdodD1cIjEyXCI+PC9yZWN0PlxyXG48L2c+XHJcbiAqL1xyXG5cclxuXHRmdW5jdGlvbiBFbmRFdmVudE5vZGUobW9kZWwsIGFwaSkge1xyXG5cdFx0RXZlbnROb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLmJwbW5UeXBlID0gXCJFbmROb25lRXZlbnRcIjtcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMjA7XHJcbiAgICAgICAgdGhpcy5yZWN0U2l6ZSA9IDEyO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiAzMSwgbmFtZTpcIkVuZE5vbmVFdmVudFwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG5cdH1cclxuXHJcbiAgICBFbmRFdmVudE5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHZhciBjaXJjbGUgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgIHI6IHRoaXMuaXRlbVNpemVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjRDAwMTFCJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICBjaXJjbGUubmFtZSA9IFwiQ2lyY2xlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQoY2lyY2xlKTtcclxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgeDogLXRoaXMucmVjdFNpemUvMixcclxuICAgICAgICAgICAgICAgIHk6IC10aGlzLnJlY3RTaXplLzIsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5yZWN0U2l6ZSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZWN0U2l6ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNGRkZGRkYnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWRkKHJlY3QpO1xyXG4gICAgICAgIHZhciBpdGVtU2l6ZSA9IHRoaXMuaXRlbVNpemUqMjtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKStpdGVtU2l6ZS8yICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpK2l0ZW1TaXplLzJdO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoRW5kRXZlbnROb2RlLCBFdmVudE5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gRW5kRXZlbnROb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9FbmRFdmVudE5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcblx0dmFyIFRhc2tOb2RlID0gcmVxdWlyZShcIi4vVGFza05vZGUuanNcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbi8qKlxyXG4gKlxyXG4gKiA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBtaW5pbXVtU2l6ZT1cIjg1IDU1XCIgaWQ9XCJzaWQtOEExQ0RBMjEtOUNEMC00OEVDLUI0OUQtNjQ0NzRFRURFRjZEXCIgdGl0bGU9XCJVc2VyIHRhc2tcIj5cclxuICogICA8cmVjdCBpZD1cInNpZC04QTFDREEyMS05Q0QwLTQ4RUMtQjQ5RC02NDQ3NEVFREVGNkR0ZXh0X2ZyYW1lXCIgYW5jaG9ycz1cImJvdHRvbSB0b3AgcmlnaHQgbGVmdFwiIHg9XCIxLjAwMDAwMDA1OTgzNzc1NVwiIHk9XCIxLjAxNjIwMjQ5MjRcIiB3aWR0aD1cIjcyXCIgaGVpZ2h0PVwiMjIuMDAwMDAwMDAwMDAwMDA0XCIgcng9XCI3XCIgcnk9XCI3XCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjBcIiBmaWxsPVwibm9uZVwiPlxyXG4gKiAgIDwvcmVjdD5cclxuICogICA8cmVjdCBpZD1cInNpZC04QTFDREEyMS05Q0QwLTQ4RUMtQjQ5RC02NDQ3NEVFREVGNkRiZ19mcmFtZVwiIHJlc2l6ZT1cInZlcnRpY2FsIGhvcml6b250YWxcIiB4PVwiNS45ODM3NzU0OWUtOFwiIHk9XCIwLjAxNjIwMjQ5MjRcIiB3aWR0aD1cIjg1XCIgaGVpZ2h0PVwiNTVcIiByeD1cIjdcIiByeT1cIjdcIiBzdHJva2U9XCIjYmJiYmJiXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGZpbGw9XCIjZjlmOWY5XCI+XHJcbiAqICAgPC9yZWN0PlxyXG4gKiAgIDxyZWN0IHhtbG5zOm9yeXg9XCJodHRwOi8vd3d3LmIzbW4ub3JnL29yeXhcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgaWQ9XCJzaWQtOEExQ0RBMjEtOUNEMC00OEVDLUI0OUQtNjQ0NzRFRURFRjZEYXJlYV9zdGF0ZVwiIGFuY2hvcnM9XCJib3R0b21cIiB4PVwiNS45ODM3NzU0OWUtOFwiIHk9XCI0NS4wMTYyMDI0OTI0XCIgd2lkdGg9XCI4NVwiIGhlaWdodD1cIjEwXCIgcng9XCIxMFwiIHJ5PVwiMTBcIiByZXNpemU9XCJob3Jpem9udGFsXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjBcIiBmaWxsPVwibm9uZVwiIHN0eWxlPVwiXCI+XHJcbiAqICAgPC9yZWN0PlxyXG4gKiAgIDx0ZXh0IHhtbG5zOm9yeXg9XCJodHRwOi8vd3d3LmIzbW4ub3JnL29yeXhcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZm9udC1zaXplPVwiMTJcIiBpZD1cInNpZC04QTFDREEyMS05Q0QwLTQ4RUMtQjQ5RC02NDQ3NEVFREVGNkR0ZXh0X25hbWVcIiB4PVwiNTJcIiB5PVwiMzVcIiBhbGlnbj1cIm1pZGRsZSBjZW50ZXJcIiBmaXR0b2VsZW09XCJ0ZXh0X2ZyYW1lXCIgc3Ryb2tlPVwiIzM3M2U0OFwiIHN0cm9rZS13aWR0aD1cIjBwdFwiIGxldHRlci1zcGFjaW5nPVwiLTAuMDFweFwiIHRyYW5zZm9ybT1cInJvdGF0ZSgwIDUyIDM1KVwiIG9yeXg6Zm9udFNpemU9XCIxMlwiIHRleHQtYW5jaG9yPVwibWlkZGxlXCI+XHJcbiAqICAgICAgIDx0c3BhbiB4PVwiNTJcIiB5PVwiMzVcIiBkeT1cIjVcIj5UYXNrXHJcbiAqICAgICAgIDwvdHNwYW4+XHJcbiAqICAgPC90ZXh0PlxyXG4gKiAgIDxnIGlkPVwic2lkLThBMUNEQTIxLTlDRDAtNDhFQy1CNDlELTY0NDc0RUVERUY2RHVzZXJUYXNrXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDUuMDAwMDAwLCA1LjAwMDAwMClcIiBmaWxsPVwiIzQ5OTBFMlwiPlxyXG4gKiAgICAgICA8cGF0aCBhbmNob3JzPVwidG9wIGxlZnRcIiBkPVwiIE00LjY4OTc1NDc0OTgzNzc1NSAwLjc1NDc0OTcyMTQwMDAwMDEgIEMzLjEyNDkwODYzOTgzNzc1NSAxLjUwOTQ5OTQ0MjQgMi41MzY5MDI5ODk4Mzc3NTUgMi44MzU5NDA0NTI0IDMuMDM4ODUzMjk5ODM3NzU0NyA1LjM4NzgxOTQ3MjM5OTk5OTUgIEMzLjU0MDgwMzU5OTgzNzc1NSA3LjkzOTY5ODUwMjQgNC4yNTY4NTQzNzk4Mzc3NTYgNy45NzI5MjE4MTI0IDQuNjg5NzU0NzQ5ODM3NzU1IDguOTIwNzYyNTkyNCAgQzUuMTIyNjU1MTE5ODM3NzU1IDkuODY4NjAzMzcyMzk5OTk5IDQuODM0MDU0ODg5ODM3NzU1NiAxMC42NzA2MjI0OTI0IDMuODIzOTUzODc5ODM3NzU0NiAxMS4xMDgwODc0OTI0ICBDMi44MTM4NTI4Nzk4Mzc3NTUgMTEuNTQ1NTUyNDkyNCAxLjE5Njc1NTA5NDk5OTk5OTllLTcgMTIuODU3OTQ3MzkyNCA1Ljk4Mzc3NTQ5ZS04IDEzLjU4NzA1NTY5MjQgIEMwIDE0LjMxNjE2Mzk5MjQgMS4yMjY1NTEyODk4Mzc3NTUgMTQuMjQzMjUzMDkyNCAyLjMwODgwMjM2OTgzNzc1NDcgMTQuMjQzMjUzMDkyNCAgQzMuMzkxMDUzNDQ5ODM3NzU1IDE0LjI0MzI1MzA5MjQgOS4wOTA5MDkxNDk4Mzc3NTUgMTQuMjQzMjUzMDkyNCA5LjA5MDkwOTE0OTgzNzc1NSAxNC4yNDMyNTMwOTI0ICBMOS4xNjMwNTkyMTk4Mzc3NTQgMC41MjM3NzA0ODA0MDAwMDAxICBDOS4xNjMwNTkyMTk4Mzc3NTQgMC41MjM3NzA0ODA0MDAwMDAxIDYuMjU0NjAwODU5ODM3NzU2IDAgNC42ODk3NTQ3NDk4Mzc3NTUgMC43NTQ3NDk3MjE0MDAwMDAxICB6XCIgaWQ9XCJzaWQtOEExQ0RBMjEtOUNEMC00OEVDLUI0OUQtNjQ0NzRFRURFRjZEUGF0aC0xNFwiPlxyXG4gKiAgICAgICA8L3BhdGg+XHJcbiAqICAgICAgIDxwYXRoIGFuY2hvcnM9XCJ0b3AgbGVmdFwiIGQ9XCIgTTkuNTk1OTU5NjU5ODM3NzU3IDAuNzU0NzQ5NzIxNDAwMDAwMSAgQzExLjE2MDgwNTc1OTgzNzc1MyAxLjUwOTQ5OTQ0MjQgMTEuNTc2NTE3ODU5ODM3NzU0IDIuNzQ2NjU0NjgyNCAxMS4wNzQ1Njc1NTk4Mzc3NTcgNS4yOTg1MzM3MDIzOTk5OTkgIEMxMC41NzI2MTcyNTk4Mzc3NTYgNy44NTA0MTI3MzI0IDEwLjAyODg2MDA1OTgzNzc1NCA3Ljk3MjkyMTgxMjQgOS41OTU5NTk2NTk4Mzc3NTcgOC45MjA3NjI1OTI0ICBDOS4xNjMwNTkyNzk4Mzc3NTMgOS44Njg2MDMzNzIzOTk5OTkgOS40NTE2NTk1MTk4Mzc3NTQgMTAuNjcwNjIyNDkyNCAxMC40NjE3NjA1NTk4Mzc3NTcgMTEuMTA4MDg3NDkyNCAgQzExLjQ3MTg2MTU1OTgzNzc1NSAxMS41NDU1NTI0OTI0IDE0LjI4NTcxNDI1OTgzNzc1NSAxMi44NTc5NDczOTI0IDE0LjI4NTcxNDM1OTgzNzc1NyAxMy41ODcwNTU2OTI0ICBDMTQuMjg1NzE0MzU5ODM3NzU3IDE0LjMxNjE2Mzk5MjQgMTMuMDU5MTYzMTU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgMTEuOTc2OTEyMDU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEMxMC44OTQ2NjA5NTk4Mzc3NTQgMTQuMjQzMjUzMDkyNCA2LjM0OTIwNjQwOTgzNzc1NSAxNC4yNDMyNTMwOTI0IDYuMzQ5MjA2NDA5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEw2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgIEM2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgOC4wMzExMTM1NDk4Mzc3NTUgMCA5LjU5NTk1OTY1OTgzNzc1NyAwLjc1NDc0OTcyMTQwMDAwMDEgIHpcIiBpZD1cInNpZC04QTFDREEyMS05Q0QwLTQ4RUMtQjQ5RC02NDQ3NEVFREVGNkRQYXRoLTE0LUNvcHlcIj5cclxuICogICAgICAgPC9wYXRoPlxyXG4gKiAgIDwvZz5cclxuICogPC9nPlxyXG4gKi9cclxuXHJcbiAgICBmdW5jdGlvbiBVc2VyVGFza05vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgVGFza05vZGUuY2FsbCh0aGlzLG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmVjdFNpemUgPSB7d2lkdGg6MTAwLCBoZWlnaHQ6NjB9O1xyXG4gICAgICAgIHRoaXMuaWNvblBhdGggPSBcIk03NjUuNTczNzQxIDcxOC40ODk4ODhjLTE0Ljk5OTYyMi0xMTIuNjU5ODczLTExOS42NzE1NjctMTk2LjQzODk3NC0yMzcuNzc2NDUyLTE5Ni40Mzg5NzQtMTE4LjkxMjI3MyAwLTIyMC41MTQyOTkgODUuMjc3MjIyLTIzOC4yMDMxNyAxOTguNzcwMDY2LTExLjg0MDY3NiA3Ni4wNzE1NTkgNTQuNTg1MTk5IDcxLjMyNjQ4OSA1NC41ODUxOTkgNzEuMzI2NDg5bDM2MC43MzQ4NzggMEM3MDQuOTEzMTczIDc5Mi4xNDg0OTEgNzc2LjYwODA1MiA4MDEuMzY0Mzg3IDc2NS41NzM3NDEgNzE4LjQ4OTg4OHpNNjkwLjI0OTE5NSAzNjUuNzE4Mzc5YzAgODkuOTExNzc2LTcyLjg4OTA3NyAxNjIuODEwMDYzLTE2Mi43OTY3NiAxNjIuODEwMDYzLTg5LjkwODcwNiAwLTE2Mi43OTc3ODMtNzIuODk4Mjg3LTE2Mi43OTc3ODMtMTYyLjgxMDA2MyAwLTg5LjkxNjg5MiA3Mi44ODkwNzctMTYyLjgwNTk3IDE2Mi43OTc3ODMtMTYyLjgwNTk3QzYxNy4zNjAxMTggMjAyLjkxMjQwOSA2OTAuMjQ5MTk1IDI3NS44MDE0ODcgNjkwLjI0OTE5NSAzNjUuNzE4Mzc5elwiO1xyXG4gICAgICAgIHRoaXMuYnBtbkluZm8gPSB7dHlwZTogMCwgbmFtZTpcIlVzZXJUYXNrXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcbiAgICB9XHJcblxyXG4gICAgVXNlclRhc2tOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB5OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5yZWN0U2l6ZS53aWR0aC0xLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJlY3RTaXplLmhlaWdodC0xLFxyXG4gICAgICAgICAgICAgICAgcjogN1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZjlmOWY5JyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyNiYmJiYmInXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlY3QubmFtZSA9IFwiUmVjdFwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHJlY3QpO1xyXG5cclxuICAgICAgICB2YXIgaWNvblJlY3QgPSB7eDo1LCB5OiA1LCB3aWR0aDogMTUsIGhlaWdodDoxNX07XHJcbiAgICAgICAgdmFyIHBhdGhJY29uID0gZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoLCB7c3R5bGU6IHtmaWxsOiAnIzQ5OTBFMid9LHo6Mn0sIGljb25SZWN0KTtcclxuICAgICAgICB0aGlzLmFkZChwYXRoSWNvbik7XHJcbiAgICAgICAvLyB0aGlzLmFkZChncmFwaGljLm1ha2VQYXRoKHRoaXMuaWNvblBhdGgyLCB7c3R5bGU6IHtmaWxsOiAnIzQ5OTBFMid9fSwgcmVjdCxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpLCBtb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIildO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhVc2VyVGFza05vZGUsVGFza05vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gVXNlclRhc2tOb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL1VzZXJUYXNrTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuXHR2YXIgQlBNTk5vZGUgPSByZXF1aXJlKFwiLi4vQlBNTk5vZGVcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcblx0Ly/liJvlu7pOb2Rl57G7IOaJgOacieW9oueKtumDvee7p+aJv05vZGVcclxuXHQvL1xyXG5cdGZ1bmN0aW9uIFRhc2tOb2RlKG1vZGVsLCBhcGkpIHtcclxuXHJcblx0XHRCUE1OTm9kZS5jYWxsKHRoaXMsIG1vZGVsLCBhcGkpO1xyXG5cdFx0dGhpcy5icG1uSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTpcIlRhc2tOb2RlXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgdGhpcy5zbG90ID0gW107XHJcbiAgICAgICAgdGhpcy5zbG90RXZlbnQgPSBbXTtcclxuICAgICAgICB0aGlzLmlzQ2FuU2xvdCA9IHRydWU7ICAvL+eUqOS6juaOp+WItuacrOiKgueCueaYr+WQpuWPr+S7peiiq+aPkuanvVxyXG5cdH1cclxuXHJcbiAgICBUYXNrTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBUYXNrTm9kZS5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIC8v5Yib5bu65pyA5bCP5YyF5Zu055uS6Jma57q/XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgIHBvaW50c1swXSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbMV0gPVtib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbMl0gPVtib3VuZGluZ1JlY3Qud2lkdGgvMixib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1szXSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMixib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1s0XSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuXHJcbiAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QodGhpcy5wb3NpdGlvblswXSAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC5oZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMucG9zaXRpb25bMF0rYm91bmRpbmdSZWN0LndpZHRoLzIsXHJcbiAgICAgICAgICAgIHk6IHRoaXMucG9zaXRpb25bMV0rYm91bmRpbmdSZWN0LmhlaWdodC8yLFxyXG4gICAgICAgICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxyXG4gICAgICAgICAgICBib3VuZGluZ1JlY3Q6IGJvdW5kUmVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIFRhc2tOb2RlLnByb3RvdHlwZS5nZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2hpbGRPZk5hbWUoXCJSZWN0XCIpO1xyXG4gICAgICAgIHJldHVybiByZWN0LmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBUYXNrTm9kZS5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbihwWCxwWSkge1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIHRoaXMuYXR0cigncG9zaXRpb24nLFtwWC1ib3VuZGluZ1JlY3Qud2lkdGgvMixwWS1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdKTtcclxuXHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoVGFza05vZGUsQlBNTk5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gVGFza05vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL3Rhc2svVGFza05vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy9NYW51YWxUYXNr6IqC54K5XHJcblxyXG5cdHZhciBUYXNrTm9kZSA9IHJlcXVpcmUoXCIuL1Rhc2tOb2RlLmpzXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4vKipcclxuICpcclxuICogIDxnIHBvaW50ZXItZXZlbnRzPVwiZmlsbFwiIG1pbmltdW1TaXplPVwiODIgNDJcIiBpZD1cInNpZC1BOTU0NTIyNC00Q0FFLTQ1MEQtODkzRC0xMkNGQTdFNjg4MjVcIiB0aXRsZT1cIk1hbnVhbCB0YXNrXCI+XHJcbiAqICAgICA8cmVjdCBpZD1cInNpZC1BOTU0NTIyNC00Q0FFLTQ1MEQtODkzRC0xMkNGQTdFNjg4MjV0ZXh0X2ZyYW1lXCIgYW5jaG9ycz1cImJvdHRvbSB0b3AgcmlnaHQgbGVmdFwiIHg9XCIxXCIgeT1cIjFcIiB3aWR0aD1cIjc0XCIgaGVpZ2h0PVwiMzlcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIwXCIgZmlsbD1cIm5vbmVcIj48L3JlY3Q+XHJcbiAqICAgICA8cmVjdCBpZD1cInNpZC1BOTU0NTIyNC00Q0FFLTQ1MEQtODkzRC0xMkNGQTdFNjg4MjViZ19mcmFtZVwiIHJlc2l6ZT1cInZlcnRpY2FsIGhvcml6b250YWxcIiB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCI4MFwiIGhlaWdodD1cIjQwXCIgcng9XCIxMFwiIHJ5PVwiMTBcIiBzdHJva2U9XCIjYmJiYmJiXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGZpbGw9XCIjZjlmOWY5XCI+PC9yZWN0PlxyXG4gKiAgICAgPHJlY3QgeG1sbnM6b3J5eD1cImh0dHA6Ly93d3cuYjNtbi5vcmcvb3J5eFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBpZD1cInNpZC1BOTU0NTIyNC00Q0FFLTQ1MEQtODkzRC0xMkNGQTdFNjg4MjVhcmVhX3N0YXRlXCIgYW5jaG9ycz1cImJvdHRvbVwiIHg9XCIwXCIgeT1cIjMwXCIgd2lkdGg9XCI4MFwiIGhlaWdodD1cIjEwXCIgcng9XCIxMFwiIHJ5PVwiMTBcIiByZXNpemU9XCJob3Jpem9udGFsXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjBcIiBmaWxsPVwibm9uZVwiIHN0eWxlPVwiXCI+PC9yZWN0PlxyXG4gKiAgICAgPHRleHQgeG1sbnM6b3J5eD1cImh0dHA6Ly93d3cuYjNtbi5vcmcvb3J5eFwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmb250LXNpemU9XCIxMlwiIGlkPVwic2lkLUE5NTQ1MjI0LTRDQUUtNDUwRC04OTNELTEyQ0ZBN0U2ODgyNXRleHRfbmFtZVwiIHg9XCI0M1wiIHk9XCIyNFwiIGFsaWduPVwibWlkZGxlIGNlbnRlclwiIGZpdHRvZWxlbT1cInRleHRfZnJhbWVcIiBzdHJva2U9XCIjMzczZTQ4XCIgc3Ryb2tlLXdpZHRoPVwiMHB0XCIgbGV0dGVyLXNwYWNpbmc9XCItMC4wMXB4XCIgdHJhbnNmb3JtPVwicm90YXRlKDAgNDMgMjQpXCIgb3J5eDpmb250U2l6ZT1cIjEyXCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIj48dHNwYW4geD1cIjQzXCIgeT1cIjI0XCIgZHk9XCI1XCI+VGFzazwvdHNwYW4+PC90ZXh0PlxyXG4gKiAgICAgPGcgaWQ9XCJzaWQtQTk1NDUyMjQtNENBRS00NTBELTg5M0QtMTJDRkE3RTY4ODI1bWFudWFsVGFza1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgzLDEpIHNjYWxlKDAuOClcIj5cclxuICogICAgIDxwYXRoIGFuY2hvcnM9XCJ0b3AgbGVmdFwiIHN0eWxlPVwiZmlsbDojZDFiNTc1O3N0cm9rZT1ub25lXCIgZD1cIm0gMTcsOS4zMjkwMzI2IGMgLTAuMDA2OSwwLjU1MTI0NjEgLTAuNDU1MTY2LDEuMDQ1NTg5NCAtMC45NDA3NzgsMS4wMzc2NjA0IGwgLTUuNzkyNzQ2LDAgYyAwLjAwNTMsMC4xMTkzODEgMC4wMDI2LDAuMjM3MTA3IDAuMDA2MSwwLjM1NTk2NSBsIDUuMTU0OTE4LDAgYyAwLjQ4MjAzMiwtMC4wMDk2IDAuOTI1NTI5LDAuNDkwNTEgMC45MTk1MjUsMS4wMzc1NzQgLTAuMDA3OCwwLjUzNzEyOCAtMC40NDYyODMsMS4wMTc1MzEgLTAuOTE5NTIxLDEuMDA3NjgzIGwgLTUuMjQ1MjczLDAgYyAtMC4wMTUwNywwLjEwNDQ4NCAtMC4wMzM4OSwwLjIwNDA4MSAtMC4wNTMxNiwwLjMwMTU5MSBsIDIuNjMwMTc1LDAgYyAwLjQ1NDEzNywtMC4wMDk2IDAuODcyMTEyLDAuNDYxNzU0IDAuODY2Mzg2LDAuOTc3MTg2IEMgMTMuNjE5NTI2LDE0LjU1NDEwNiAxMy4yMDYyOTMsMTUuMDA5NDk4IDEyLjc1OTI0LDE1IEwgMy43NzUzMDU0LDE1IEMgMy42MDQ1ODEyLDE1IDMuNDMzNTUyLDE0Ljk0NDIzIDMuMjkxNjM2MywxNC44MzcxMzYgYyAtMC4wMDE3NCwwIC0wLjAwNDM2LDAgLTAuMDA2MDksMCBDIDEuNzIxMjAzNSwxNC4zNjc4MDEgMC45OTk5ODI1NSwxMS40NTg2NDEgMSwxMS40NTg2NDEgTCAxLDcuNDU4ODM5MyBjIDAsMCAwLjY2MjMxNDQsLTEuMzE2MzMzIDEuODM5MDU4MywtMi4wODcyNTg0IDEuMTc2NzYxNCwtMC43NzExODY4IDYuODA1MzM1OCwtMi40MDQ5NyA3LjI1ODc4NDcsLTIuODA1MjkwMSAwLjQ1MzQ4NCwtMC40MDAzMiAxLjY2MDIxMywxLjQ4NTk5NDIgMC4wNDc3NSwyLjQwMTA0ODcgQyA4LjUzMzIzMTUsNS44ODIzOTQgOC41MDczNTEsNS43OTk2MTEzIDguNDM3MDI5Miw1Ljc5MzY4NTkgbCA2LjM1Njk3NDgsLTAuMDA4NzEgYyAwLjQ5NzA0NiwtMC4wMDk1OCAwLjk1MjI3MywwLjUwOTc2NzYgMC45NDYxMiwxLjA3MzgyMzIgLTAuMDA1MywwLjU1NjEyNiAtMC40NTYxNzYsMS4wNTY2NTY2IC0wLjk0NjEyLDEuMDQ5Njg1NCBsIC00LjcyNDM1LDAgYyAwLjAxMzA3LDAuMTE0OTM3NCAwLjAyNDQsMC4yMjgxMzE5IDAuMDM3MjEsMC4zNDk4NjYxIGwgNS45NTIxOTUsMCBjIDAuNDk0NTE3LC0wLjAwODcxIDAuOTQ3OTA2LDAuNTA2NjMwNSAwLjk0MDc5NSwxLjA2Nzk4NDggelwiIGlkPVwic2lkLUE5NTQ1MjI0LTRDQUUtNDUwRC04OTNELTEyQ0ZBN0U2ODgyNV9zaWQtQTk1NDUyMjQtNENBRS00NTBELTg5M0QtMTJDRkE3RTY4ODI1XzE3XCI+PC9wYXRoPlxyXG4gKiAgICAgPC9nPlxyXG4gKiA8L2c+XHJcbiAqL1xyXG4gICAgZnVuY3Rpb24gTWFudWFsVGFza05vZGUobW9kZWwsYXBpKSB7XHJcbiAgICAgICAgVGFza05vZGUuY2FsbCh0aGlzLG1vZGVsLCBhcGkpO1xyXG4gICAgICAgIHRoaXMucmVjdFNpemUgPSB7d2lkdGg6MTAwLCBoZWlnaHQ6NjB9O1xyXG4gICAgICAgIHRoaXMuaWNvblBhdGggPSBcIm0gMTcsOS4zMjkwMzI2IGMgLTAuMDA2OSwwLjU1MTI0NjEgLTAuNDU1MTY2LDEuMDQ1NTg5NCAtMC45NDA3NzgsMS4wMzc2NjA0IGwgLTUuNzkyNzQ2LDAgYyAwLjAwNTMsMC4xMTkzODEgMC4wMDI2LDAuMjM3MTA3IDAuMDA2MSwwLjM1NTk2NSBsIDUuMTU0OTE4LDAgYyAwLjQ4MjAzMiwtMC4wMDk2IDAuOTI1NTI5LDAuNDkwNTEgMC45MTk1MjUsMS4wMzc1NzQgLTAuMDA3OCwwLjUzNzEyOCAtMC40NDYyODMsMS4wMTc1MzEgLTAuOTE5NTIxLDEuMDA3NjgzIGwgLTUuMjQ1MjczLDAgYyAtMC4wMTUwNywwLjEwNDQ4NCAtMC4wMzM4OSwwLjIwNDA4MSAtMC4wNTMxNiwwLjMwMTU5MSBsIDIuNjMwMTc1LDAgYyAwLjQ1NDEzNywtMC4wMDk2IDAuODcyMTEyLDAuNDYxNzU0IDAuODY2Mzg2LDAuOTc3MTg2IEMgMTMuNjE5NTI2LDE0LjU1NDEwNiAxMy4yMDYyOTMsMTUuMDA5NDk4IDEyLjc1OTI0LDE1IEwgMy43NzUzMDU0LDE1IEMgMy42MDQ1ODEyLDE1IDMuNDMzNTUyLDE0Ljk0NDIzIDMuMjkxNjM2MywxNC44MzcxMzYgYyAtMC4wMDE3NCwwIC0wLjAwNDM2LDAgLTAuMDA2MDksMCBDIDEuNzIxMjAzNSwxNC4zNjc4MDEgMC45OTk5ODI1NSwxMS40NTg2NDEgMSwxMS40NTg2NDEgTCAxLDcuNDU4ODM5MyBjIDAsMCAwLjY2MjMxNDQsLTEuMzE2MzMzIDEuODM5MDU4MywtMi4wODcyNTg0IDEuMTc2NzYxNCwtMC43NzExODY4IDYuODA1MzM1OCwtMi40MDQ5NyA3LjI1ODc4NDcsLTIuODA1MjkwMSAwLjQ1MzQ4NCwtMC40MDAzMiAxLjY2MDIxMywxLjQ4NTk5NDIgMC4wNDc3NSwyLjQwMTA0ODcgQyA4LjUzMzIzMTUsNS44ODIzOTQgOC41MDczNTEsNS43OTk2MTEzIDguNDM3MDI5Miw1Ljc5MzY4NTkgbCA2LjM1Njk3NDgsLTAuMDA4NzEgYyAwLjQ5NzA0NiwtMC4wMDk1OCAwLjk1MjI3MywwLjUwOTc2NzYgMC45NDYxMiwxLjA3MzgyMzIgLTAuMDA1MywwLjU1NjEyNiAtMC40NTYxNzYsMS4wNTY2NTY2IC0wLjk0NjEyLDEuMDQ5Njg1NCBsIC00LjcyNDM1LDAgYyAwLjAxMzA3LDAuMTE0OTM3NCAwLjAyNDQsMC4yMjgxMzE5IDAuMDM3MjEsMC4zNDk4NjYxIGwgNS45NTIxOTUsMCBjIDAuNDk0NTE3LC0wLjAwODcxIDAuOTQ3OTA2LDAuNTA2NjMwNSAwLjk0MDc5NSwxLjA2Nzk4NDggelwiO1xyXG4gICAgICAvLyAgdGhpcy5pY29uUGF0aDIgPSBcIk05LjU5NTk1OTY1OTgzNzc1NyAwLjc1NDc0OTcyMTQwMDAwMDEgIEMxMS4xNjA4MDU3NTk4Mzc3NTMgMS41MDk0OTk0NDI0IDExLjU3NjUxNzg1OTgzNzc1NCAyLjc0NjY1NDY4MjQgMTEuMDc0NTY3NTU5ODM3NzU3IDUuMjk4NTMzNzAyMzk5OTk5ICBDMTAuNTcyNjE3MjU5ODM3NzU2IDcuODUwNDEyNzMyNCAxMC4wMjg4NjAwNTk4Mzc3NTQgNy45NzI5MjE4MTI0IDkuNTk1OTU5NjU5ODM3NzU3IDguOTIwNzYyNTkyNCAgQzkuMTYzMDU5Mjc5ODM3NzUzIDkuODY4NjAzMzcyMzk5OTk5IDkuNDUxNjU5NTE5ODM3NzU0IDEwLjY3MDYyMjQ5MjQgMTAuNDYxNzYwNTU5ODM3NzU3IDExLjEwODA4NzQ5MjQgIEMxMS40NzE4NjE1NTk4Mzc3NTUgMTEuNTQ1NTUyNDkyNCAxNC4yODU3MTQyNTk4Mzc3NTUgMTIuODU3OTQ3MzkyNCAxNC4yODU3MTQzNTk4Mzc3NTcgMTMuNTg3MDU1NjkyNCAgQzE0LjI4NTcxNDM1OTgzNzc1NyAxNC4zMTYxNjM5OTI0IDEzLjA1OTE2MzE1OTgzNzc1NSAxNC4yNDMyNTMwOTI0IDExLjk3NjkxMjA1OTgzNzc1NSAxNC4yNDMyNTMwOTI0ICBDMTAuODk0NjYwOTU5ODM3NzU0IDE0LjI0MzI1MzA5MjQgNi4zNDkyMDY0MDk4Mzc3NTUgMTQuMjQzMjUzMDkyNCA2LjM0OTIwNjQwOTgzNzc1NSAxNC4yNDMyNTMwOTI0ICBMNi4xNTIwNjE5Njk4Mzc3NTUgMC40Mjk5MjYyNjk0ICBDNi4xNTIwNjE5Njk4Mzc3NTUgMC40Mjk5MjYyNjk0IDguMDMxMTEzNTQ5ODM3NzU1IDAgOS41OTU5NTk2NTk4Mzc3NTcgMC43NTQ3NDk3MjE0MDAwMDAxICB6XCI7XHJcbiAgICAgICAgdGhpcy5icG1uSW5mbyA9IHt0eXBlOiA0LCBuYW1lOlwiTWFudWFsVGFza1wiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIE1hbnVhbFRhc2tOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB5OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5yZWN0U2l6ZS53aWR0aC0xLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJlY3RTaXplLmhlaWdodC0xLFxyXG4gICAgICAgICAgICAgICAgcjogN1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZjlmOWY5JyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyNiYmJiYmInXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlY3QubmFtZSA9IFwiUmVjdFwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHJlY3QpO1xyXG5cclxuICAgICAgICB2YXIgaWNvbnJlY3QgPSB7eDo1LCB5OiA1LCB3aWR0aDogMTUsIGhlaWdodDoxNX07XHJcbiAgICAgICAgdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoLCB7c3R5bGU6IHtmaWxsOiAnI2QxYjU3NSd9LHo6Mn0sIGljb25yZWN0KSk7XHJcblxyXG4gICAgICAgLy8gdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoMiwge3N0eWxlOiB7ZmlsbDogJyM0OTkwRTInfX0sIHJlY3QsXCJjZW50ZXJcIikpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAgW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSk7XHJcbiAgICAgICAgdGl0bGUudGV4dC5uYW1lID0gXCJUaXRsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHRpdGxlLnRleHQpO1xyXG4gICAgfTtcclxuXHJcblx0enJVdGlsLmluaGVyaXRzKE1hbnVhbFRhc2tOb2RlLFRhc2tOb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IE1hbnVhbFRhc2tOb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL01hbnVhbFRhc2tOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vU2NyaXB0VGFza+iKgueCuVxyXG5cclxuXHR2YXIgVGFza05vZGUgPSByZXF1aXJlKFwiLi9UYXNrTm9kZS5qc1wiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuLyoqXHJcbiAqXHJcbiAqICA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBtaW5pbXVtU2l6ZT1cIjgyIDQyXCIgaWQ9XCJzaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEXCIgdGl0bGU9XCJTY3JpcHQgdGFza1wiPlxyXG4gKiAgICAgPHJlY3QgaWQ9XCJzaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEdGV4dF9mcmFtZVwiIGFuY2hvcnM9XCJib3R0b20gdG9wIHJpZ2h0IGxlZnRcIiB4PVwiMVwiIHk9XCIxXCIgd2lkdGg9XCI3NFwiIGhlaWdodD1cIjM5XCIgcng9XCIxMFwiIHJ5PVwiMTBcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMFwiIGZpbGw9XCJub25lXCI+PC9yZWN0PlxyXG4gKiAgICAgPHJlY3QgaWQ9XCJzaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEYmdfZnJhbWVcIiByZXNpemU9XCJ2ZXJ0aWNhbCBob3Jpem9udGFsXCIgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiODBcIiBoZWlnaHQ9XCI0MFwiIHJ4PVwiMTBcIiByeT1cIjEwXCIgc3Ryb2tlPVwiI2JiYmJiYlwiIHN0cm9rZS13aWR0aD1cIjFcIiBmaWxsPVwiI2Y5ZjlmOVwiPjwvcmVjdD5cclxuICogICAgIDxyZWN0IHhtbG5zOm9yeXg9XCJodHRwOi8vd3d3LmIzbW4ub3JnL29yeXhcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgaWQ9XCJzaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEYXJlYV9zdGF0ZVwiIGFuY2hvcnM9XCJib3R0b21cIiB4PVwiMFwiIHk9XCIzMFwiIHdpZHRoPVwiODBcIiBoZWlnaHQ9XCIxMFwiIHJ4PVwiMTBcIiByeT1cIjEwXCIgcmVzaXplPVwiaG9yaXpvbnRhbFwiIHN0cm9rZT1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIwXCIgZmlsbD1cIm5vbmVcIiBzdHlsZT1cIlwiPjwvcmVjdD5cclxuICogICAgIDx0ZXh0IHhtbG5zOm9yeXg9XCJodHRwOi8vd3d3LmIzbW4ub3JnL29yeXhcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZm9udC1zaXplPVwiMTJcIiBpZD1cInNpZC1CODNERkE5RS0wMDY2LTQwMzItQTlFOC1BN0ZGMTlDMUFCNUR0ZXh0X25hbWVcIiB4PVwiNDNcIiB5PVwiMjRcIiBhbGlnbj1cIm1pZGRsZSBjZW50ZXJcIiBmaXR0b2VsZW09XCJ0ZXh0X2ZyYW1lXCIgc3Ryb2tlPVwiIzM3M2U0OFwiIHN0cm9rZS13aWR0aD1cIjBwdFwiIGxldHRlci1zcGFjaW5nPVwiLTAuMDFweFwiIHRyYW5zZm9ybT1cInJvdGF0ZSgwIDQzIDI0KVwiIG9yeXg6Zm9udFNpemU9XCIxMlwiIHRleHQtYW5jaG9yPVwibWlkZGxlXCI+PHRzcGFuIHg9XCI0M1wiIHk9XCIyNFwiIGR5PVwiNVwiPlRhc2s8L3RzcGFuPjwvdGV4dD5cclxuICogICAgIDxnIGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RHNjcmlwdFRhc2tcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMiwyKSBzY2FsZSgwLjgpXCI+XHJcbiAqICAgICA8cGF0aCBhbmNob3JzPVwidG9wIGxlZnRcIiBkPVwibSA1LDIgMCwwLjA5NCBjIDAuMjM3MDYsMC4wNjQgMC41MzE4OSwwLjE2NDUgMC44MTI1LDAuMzc1IDAuNTU4MiwwLjQxODYgMS4wNTEwOSwxLjIyOCAxLjE1NjI1LDIuNTMxMiBsIDguMDMxMjUsMCAxLDAgMSwwIGMgMCwtMyAtMiwtMyAtMiwtMyBsIC0xMCwwIHogTSA0LDMgNCwxMyAyLDEzIGMgMCwzIDIsMyAyLDMgbCA5LDAgYyAwLDAgMiwwIDIsLTMgTCAxNSw2IDYsNiA2LDUuNSBDIDYsNC4xMTExIDUuNTU5NSwzLjUyOSA1LjE4NzUsMy4yNSA0LjgxNTUsMi45NzEgNC41LDMgNC41LDMgTCA0LDMgelwiIHN0eWxlPVwiZmlsbDojNzJhN2QwO3N0cm9rZTpub25lXCIgaWQ9XCJzaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEX3NpZC1CODNERkE5RS0wMDY2LTQwMzItQTlFOC1BN0ZGMTlDMUFCNURfMTdcIj48L3BhdGg+XHJcbiAqICAgICA8L2c+XHJcbiAqIDwvZz5cclxuICovXHJcbiAgICBmdW5jdGlvbiBTY3JpcHRUYXNrTm9kZShtb2RlbCxhcGkpIHtcclxuICAgICAgICBUYXNrTm9kZS5jYWxsKHRoaXMsbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2l6ZSA9IHt3aWR0aDoxMDAsIGhlaWdodDo2MH07XHJcbiAgICAgICAgdGhpcy5pY29uUGF0aCA9IFwibSA1LDIgMCwwLjA5NCBjIDAuMjM3MDYsMC4wNjQgMC41MzE4OSwwLjE2NDUgMC44MTI1LDAuMzc1IDAuNTU4MiwwLjQxODYgMS4wNTEwOSwxLjIyOCAxLjE1NjI1LDIuNTMxMiBsIDguMDMxMjUsMCAxLDAgMSwwIGMgMCwtMyAtMiwtMyAtMiwtMyBsIC0xMCwwIHogTSA0LDMgNCwxMyAyLDEzIGMgMCwzIDIsMyAyLDMgbCA5LDAgYyAwLDAgMiwwIDIsLTMgTCAxNSw2IDYsNiA2LDUuNSBDIDYsNC4xMTExIDUuNTU5NSwzLjUyOSA1LjE4NzUsMy4yNSA0LjgxNTUsMi45NzEgNC41LDMgNC41LDMgTCA0LDMgelwiO1xyXG4gICAgICAvLyAgdGhpcy5pY29uUGF0aDIgPSBcIk05LjU5NTk1OTY1OTgzNzc1NyAwLjc1NDc0OTcyMTQwMDAwMDEgIEMxMS4xNjA4MDU3NTk4Mzc3NTMgMS41MDk0OTk0NDI0IDExLjU3NjUxNzg1OTgzNzc1NCAyLjc0NjY1NDY4MjQgMTEuMDc0NTY3NTU5ODM3NzU3IDUuMjk4NTMzNzAyMzk5OTk5ICBDMTAuNTcyNjE3MjU5ODM3NzU2IDcuODUwNDEyNzMyNCAxMC4wMjg4NjAwNTk4Mzc3NTQgNy45NzI5MjE4MTI0IDkuNTk1OTU5NjU5ODM3NzU3IDguOTIwNzYyNTkyNCAgQzkuMTYzMDU5Mjc5ODM3NzUzIDkuODY4NjAzMzcyMzk5OTk5IDkuNDUxNjU5NTE5ODM3NzU0IDEwLjY3MDYyMjQ5MjQgMTAuNDYxNzYwNTU5ODM3NzU3IDExLjEwODA4NzQ5MjQgIEMxMS40NzE4NjE1NTk4Mzc3NTUgMTEuNTQ1NTUyNDkyNCAxNC4yODU3MTQyNTk4Mzc3NTUgMTIuODU3OTQ3MzkyNCAxNC4yODU3MTQzNTk4Mzc3NTcgMTMuNTg3MDU1NjkyNCAgQzE0LjI4NTcxNDM1OTgzNzc1NyAxNC4zMTYxNjM5OTI0IDEzLjA1OTE2MzE1OTgzNzc1NSAxNC4yNDMyNTMwOTI0IDExLjk3NjkxMjA1OTgzNzc1NSAxNC4yNDMyNTMwOTI0ICBDMTAuODk0NjYwOTU5ODM3NzU0IDE0LjI0MzI1MzA5MjQgNi4zNDkyMDY0MDk4Mzc3NTUgMTQuMjQzMjUzMDkyNCA2LjM0OTIwNjQwOTgzNzc1NSAxNC4yNDMyNTMwOTI0ICBMNi4xNTIwNjE5Njk4Mzc3NTUgMC40Mjk5MjYyNjk0ICBDNi4xNTIwNjE5Njk4Mzc3NTUgMC40Mjk5MjYyNjk0IDguMDMxMTEzNTQ5ODM3NzU1IDAgOS41OTU5NTk2NTk4Mzc3NTcgMC43NTQ3NDk3MjE0MDAwMDAxICB6XCI7XHJcbiAgICAgICAgdGhpcy5icG1uSW5mbyA9IHt0eXBlOiA3LCBuYW1lOlwiU2NyaXB0VGFza1wiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIFNjcmlwdFRhc2tOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB5OiAwLjUsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5yZWN0U2l6ZS53aWR0aC0xLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnJlY3RTaXplLmhlaWdodC0xLFxyXG4gICAgICAgICAgICAgICAgcjogN1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZjlmOWY5JyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyNiYmJiYmInXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlY3QubmFtZSA9IFwiUmVjdFwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHJlY3QpO1xyXG5cclxuICAgICAgICB2YXIgaWNvbnJlY3QgPSB7eDo1LCB5OiA1LCB3aWR0aDogMTUsIGhlaWdodDoxNX07XHJcbiAgICAgICAgdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoLCB7c3R5bGU6IHtmaWxsOiAnIzcyYTdkMCd9LHo6Mn0sIGljb25yZWN0KSk7XHJcblxyXG4gICAgICAgLy8gdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLmljb25QYXRoMiwge3N0eWxlOiB7ZmlsbDogJyM0OTkwRTInfX0sIHJlY3QsXCJjZW50ZXJcIikpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAgW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpXTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmRyYXdUZXh0KG1vZGVsLmdldChcInByb3BlcnRpZXMubmFtZVwiKSk7XHJcbiAgICAgICAgdGl0bGUudGV4dC5uYW1lID0gXCJUaXRsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKHRpdGxlLnRleHQpO1xyXG4gICAgfTtcclxuXHJcblx0enJVdGlsLmluaGVyaXRzKFNjcmlwdFRhc2tOb2RlLFRhc2tOb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IFNjcmlwdFRhc2tOb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL1NjcmlwdFRhc2tOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vTWFpbFRhc2voioLngrlcclxuXHJcblx0dmFyIFRhc2tOb2RlID0gcmVxdWlyZShcIi4vVGFza05vZGUuanNcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbi8qKlxyXG4gKlxyXG4gKiAgPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgbWluaW11bVNpemU9XCI4MiA0MlwiIGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RFwiIHRpdGxlPVwiU2NyaXB0IHRhc2tcIj5cclxuICogICAgIDxyZWN0IGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RHRleHRfZnJhbWVcIiBhbmNob3JzPVwiYm90dG9tIHRvcCByaWdodCBsZWZ0XCIgeD1cIjFcIiB5PVwiMVwiIHdpZHRoPVwiNzRcIiBoZWlnaHQ9XCIzOVwiIHJ4PVwiMTBcIiByeT1cIjEwXCIgc3Ryb2tlPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjBcIiBmaWxsPVwibm9uZVwiPjwvcmVjdD5cclxuICogICAgIDxyZWN0IGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RGJnX2ZyYW1lXCIgcmVzaXplPVwidmVydGljYWwgaG9yaXpvbnRhbFwiIHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiNDBcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHN0cm9rZT1cIiNiYmJiYmJcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIiNmOWY5ZjlcIj48L3JlY3Q+XHJcbiAqICAgICA8cmVjdCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGlkPVwic2lkLUI4M0RGQTlFLTAwNjYtNDAzMi1BOUU4LUE3RkYxOUMxQUI1RGFyZWFfc3RhdGVcIiBhbmNob3JzPVwiYm90dG9tXCIgeD1cIjBcIiB5PVwiMzBcIiB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiMTBcIiByeD1cIjEwXCIgcnk9XCIxMFwiIHJlc2l6ZT1cImhvcml6b250YWxcIiBzdHJva2U9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMFwiIGZpbGw9XCJub25lXCIgc3R5bGU9XCJcIj48L3JlY3Q+XHJcbiAqICAgICA8dGV4dCB4bWxuczpvcnl4PVwiaHR0cDovL3d3dy5iM21uLm9yZy9vcnl4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZvbnQtc2l6ZT1cIjEyXCIgaWQ9XCJzaWQtQjgzREZBOUUtMDA2Ni00MDMyLUE5RTgtQTdGRjE5QzFBQjVEdGV4dF9uYW1lXCIgeD1cIjQzXCIgeT1cIjI0XCIgYWxpZ249XCJtaWRkbGUgY2VudGVyXCIgZml0dG9lbGVtPVwidGV4dF9mcmFtZVwiIHN0cm9rZT1cIiMzNzNlNDhcIiBzdHJva2Utd2lkdGg9XCIwcHRcIiBsZXR0ZXItc3BhY2luZz1cIi0wLjAxcHhcIiB0cmFuc2Zvcm09XCJyb3RhdGUoMCA0MyAyNClcIiBvcnl4OmZvbnRTaXplPVwiMTJcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPjx0c3BhbiB4PVwiNDNcIiB5PVwiMjRcIiBkeT1cIjVcIj5UYXNrPC90c3Bhbj48L3RleHQ+XHJcbiAqICAgICA8ZyBpZD1cInNpZC1CODNERkE5RS0wMDY2LTQwMzItQTlFOC1BN0ZGMTlDMUFCNURzY3JpcHRUYXNrXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDIsMikgc2NhbGUoMC44KVwiPlxyXG4gKiAgICAgICAgPHBhdGggYW5jaG9ycz1cInRvcCBsZWZ0XCIgZD1cIk0wLjMzMjYzODkzNiwxLjE3MzkxMzA0IEw4Ljk4MTI1MTI2LDYuNjUyMTczOTFcIiBpZD1cInNpZC0wOUI5N0M1RS1CRUE4LTQwQTItOUYyMi0zMDY0QTI3NDVEQkVMaW5lXCIgc3Ryb2tlPVwiI0ZGRkZGRlwiIHN0cm9rZS1saW5lY2FwPVwic3F1YXJlXCI+PC9wYXRoPlxyXG4gKiAgICAgICAgPHBhdGggYW5jaG9ycz1cInRvcCBsZWZ0XCIgZD1cIk0xNy41NTAwMzAyLDEuMTczOTEzMDQgTDguOTAxNDE3OTIsNi42NTIxNzM5MVwiIGlkPVwic2lkLTA5Qjk3QzVFLUJFQTgtNDBBMi05RjIyLTMwNjRBMjc0NURCRUxpbmUtQ29weS00XCIgc3Ryb2tlPVwiI0ZGRkZGRlwiIHN0cm9rZS1saW5lY2FwPVwic3F1YXJlXCI+PC9wYXRoPlxyXG4gKlx0ICAgPC9nPlxyXG4gKiA8L2c+XHJcbiAqL1xyXG4gICAgZnVuY3Rpb24gTWFpbFRhc2tOb2RlKG1vZGVsLGFwaSkge1xyXG4gICAgICAgIFRhc2tOb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnJlY3RTaXplID0ge3dpZHRoOjEwMCwgaGVpZ2h0OjYwfTtcclxuICAgICAgICB0aGlzLmljb25QYXRoID0gXCJNNDkuMDEzLDUxLjAwM2MxLjg0NywxLjMwMyw3LjQxNCw1LjE3NCwxNi43MDIsMTEuNjFTODIuMTE4LDc0LjAwNSw4Ny4wNjEsNzcuNDhjMC41NDMsMC4zODEsMS42OTcsMS4yMDksMy40NjIsMi40ODVjMS43NjUsMS4yNzcsMy4yMzIsMi4zMSw0LjM5OSwzLjA5N2MxLjE2OCwwLjc4NywyLjU4LDEuNjcsNC4yMzcsMi42NDdjMS42NTcsMC45NzcsMy4yMTksMS43MTEsNC42ODUsMi4xOThjMS40NjcsMC40OSwyLjgyNSwwLjczMyw0LjA3NCwwLjczM0gxMDhoMC4wODJjMS4yNDksMCwyLjYwNy0wLjI0Myw0LjA3NC0wLjczM2MxLjQ2Ni0wLjQ4NywzLjAyOS0xLjIyMiw0LjY4NS0yLjE5OGMxLjY1Ni0wLjk3OCwzLjA2OC0xLjg2LDQuMjM2LTIuNjQ3czIuNjM0LTEuODIsNC4zOTktMy4wOTdzMi45Mi0yLjEwNCwzLjQ2My0yLjQ4NWM0Ljk5Ni0zLjQ3NiwxNy43MDctMTIuMzAyLDM4LjEyOS0yNi40NzljMy45NjUtMi43NjksNy4yNzctNi4xMSw5LjkzOS0xMC4wMjFDMTc5LjY3LDM3LjA3MSwxODEsMzIuOTcsMTgxLDI4LjY3OWMwLTMuNTg1LTEuMjkxLTYuNjU0LTMuODcxLTkuMjA3Yy0yLjU4LTIuNTUzLTUuNjM2LTMuODI5LTkuMTY1LTMuODI5SDQ4LjAzNWMtNC4xODIsMC03LjQsMS40MTItOS42NTQsNC4yMzZDMzYuMTI3LDIyLjcwNCwzNSwyNi4yMzUsMzUsMzAuNDcxYzAsMy40MjIsMS40OTQsNy4xMyw0LjQ4MSwxMS4xMjJTNDUuNjQ2LDQ4LjcyMiw0OS4wMTMsNTEuMDAzeiBNMTcyLjg1Miw1OS43MmMtMTcuODE0LDEyLjA1Ny0zMS4zNCwyMS40MjctNDAuNTcyLDI4LjEwOGMtMy4wOTYsMi4yODEtNS42MDgsNC4wNjEtNy41MzcsNS4zMzZjLTEuOTI4LDEuMjc3LTQuNDk0LDIuNTgtNy42OTksMy45MTFjLTMuMjA0LDEuMzMxLTYuMTkxLDEuOTk2LTguOTYxLDEuOTk2SDEwOGgtMC4wODJjLTIuNzcsMC01Ljc1OC0wLjY2NS04Ljk2Mi0xLjk5NnMtNS43NzEtMi42MzQtNy42OTktMy45MTFjLTEuOTI4LTEuMjc1LTQuNDQtMy4wNTUtNy41MzYtNS4zMzZjLTcuMzMzLTUuMzc3LTIwLjgzLTE0Ljc0Ny00MC40OTItMjguMTA4Yy0zLjA5Ni0yLjA2My01LjgzOS00LjQyNy04LjIyOS03LjA4OHY2NC42ODhjMCwzLjU4NiwxLjI3Niw2LjY1NCwzLjgyOSw5LjIwN2MyLjU1MywyLjU1NCw1LjYyMiwzLjgzLDkuMjA3LDMuODNoMTE5LjkyOWMzLjU4NCwwLDYuNjUzLTEuMjc2LDkuMjA2LTMuODNjMi41NTQtMi41NTQsMy44MjktNS42MjEsMy44MjktOS4yMDdWNTIuNjMyQzE3OC42NjQsNTUuMjM4LDE3NS45NDksNTcuNjAyLDE3Mi44NTIsNTkuNzJ6XCI7XHJcbiAgICAgIC8vICB0aGlzLmljb25QYXRoMiA9IFwiTTkuNTk1OTU5NjU5ODM3NzU3IDAuNzU0NzQ5NzIxNDAwMDAwMSAgQzExLjE2MDgwNTc1OTgzNzc1MyAxLjUwOTQ5OTQ0MjQgMTEuNTc2NTE3ODU5ODM3NzU0IDIuNzQ2NjU0NjgyNCAxMS4wNzQ1Njc1NTk4Mzc3NTcgNS4yOTg1MzM3MDIzOTk5OTkgIEMxMC41NzI2MTcyNTk4Mzc3NTYgNy44NTA0MTI3MzI0IDEwLjAyODg2MDA1OTgzNzc1NCA3Ljk3MjkyMTgxMjQgOS41OTU5NTk2NTk4Mzc3NTcgOC45MjA3NjI1OTI0ICBDOS4xNjMwNTkyNzk4Mzc3NTMgOS44Njg2MDMzNzIzOTk5OTkgOS40NTE2NTk1MTk4Mzc3NTQgMTAuNjcwNjIyNDkyNCAxMC40NjE3NjA1NTk4Mzc3NTcgMTEuMTA4MDg3NDkyNCAgQzExLjQ3MTg2MTU1OTgzNzc1NSAxMS41NDU1NTI0OTI0IDE0LjI4NTcxNDI1OTgzNzc1NSAxMi44NTc5NDczOTI0IDE0LjI4NTcxNDM1OTgzNzc1NyAxMy41ODcwNTU2OTI0ICBDMTQuMjg1NzE0MzU5ODM3NzU3IDE0LjMxNjE2Mzk5MjQgMTMuMDU5MTYzMTU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgMTEuOTc2OTEyMDU5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEMxMC44OTQ2NjA5NTk4Mzc3NTQgMTQuMjQzMjUzMDkyNCA2LjM0OTIwNjQwOTgzNzc1NSAxNC4yNDMyNTMwOTI0IDYuMzQ5MjA2NDA5ODM3NzU1IDE0LjI0MzI1MzA5MjQgIEw2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgIEM2LjE1MjA2MTk2OTgzNzc1NSAwLjQyOTkyNjI2OTQgOC4wMzExMTM1NDk4Mzc3NTUgMCA5LjU5NTk1OTY1OTgzNzc1NyAwLjc1NDc0OTcyMTQwMDAwMDEgIHpcIjtcclxuICAgICAgICB0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDgsIG5hbWU6XCJNYWlsVGFza1wiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIE1haWxUYXNrTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgeDogMC41LFxyXG4gICAgICAgICAgICAgICAgeTogMC41LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMucmVjdFNpemUud2lkdGgtMSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZWN0U2l6ZS5oZWlnaHQtMSxcclxuICAgICAgICAgICAgICAgIHI6IDdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2Y5ZjlmOScsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjYmJiYmJiJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICByZWN0Lm5hbWUgPSBcIlJlY3RcIjtcclxuICAgICAgICB0aGlzLmFkZChyZWN0KTtcclxuXHJcbiAgICAgICAgdmFyIGljb25yZWN0ID0ge3g6NSwgeTogNSwgd2lkdGg6IDIwLCBoZWlnaHQ6MTV9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5pY29uUGF0aCwge3N0eWxlOiB7ZmlsbDogJyM3MmE3ZDAnfSx6OjJ9LCBpY29ucmVjdCkpO1xyXG5cclxuICAgICAgIC8vIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5pY29uUGF0aDIsIHtzdHlsZToge2ZpbGw6ICcjNDk5MEUyJ319LCByZWN0LFwiY2VudGVyXCIpKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gIFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiksIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5kcmF3VGV4dChtb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhNYWlsVGFza05vZGUsVGFza05vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gTWFpbFRhc2tOb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS90YXNrL01haWxUYXNrTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvL+i+ueeVjOS6i+S7ti0tLeaNleiOt+WumuaXtuWZqOS6i+S7tuiKgueCuVxyXG5cclxuXHR2YXIgRXZlbnROb2RlID0gcmVxdWlyZShcIi4uL0V2ZW50Tm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBpZD1cInNpZC1GRjBBREZDMC1EM0VDLTQyMzctQUQxNi1BMzYyNzNEMUZFNkRcIiB0aXRsZT1cIlN0YXJ0IGV2ZW50XCI+XHJcbiAqICAgIDxjaXJjbGUgaWQ9XCJzaWQtRjhERkJEQUQtMjg1Mi00QTlBLTg0RTktQTY1OTQzQTA5NjJCYmdfZnJhbWVcIiBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIxNVwiIHN0cm9rZT1cIiM1ODU4NThcIiBmaWxsPVwiI2ZmZmZmZlwiIHN0cm9rZS13aWR0aD1cIjFcIiBzdHlsZT1cInN0cm9rZS1kYXNoYXJyYXk6IDUuNSwgM1wiPjwvY2lyY2xlPlxyXG4gKiAgICA8Y2lyY2xlIGlkPVwic2lkLUY4REZCREFELTI4NTItNEE5QS04NEU5LUE2NTk0M0EwOTYyQmZyYW1lMl9ub25faW50ZXJydXB0aW5nXCIgY3g9XCIxNlwiIGN5PVwiMTZcIiByPVwiMTJcIiBzdHJva2U9XCIjNTg1ODU4XCIgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIxXCIgc3R5bGU9XCJzdHJva2UtZGFzaGFycmF5OiA0LjUsIDNcIj48L2NpcmNsZT5cclxuICogICAgPGNpcmNsZSBpZD1cInNpZC1GOERGQkRBRC0yODUyLTRBOUEtODRFOS1BNjU5NDNBMDk2MkJmcmFtZVwiIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjE1XCIgc3Ryb2tlPVwiIzU4NTg1OFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMVwiPjwvY2lyY2xlPlxyXG4gKiAgICA8Y2lyY2xlIGlkPVwic2lkLUY4REZCREFELTI4NTItNEE5QS04NEU5LUE2NTk0M0EwOTYyQmZyYW1lMlwiIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjEyXCIgc3Ryb2tlPVwiIzU4NTg1OFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMVwiPjwvY2lyY2xlPlxyXG4gKiAgICA8cGF0aCBpZD1cInNpZC1GOERGQkRBRC0yODUyLTRBOUEtODRFOS1BNjU5NDNBMDk2MkJwYXRoMVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg2LDYpXCIgZD1cIk0gMTAgMCBDIDQuNDc3MTUyNSAwIDAgNC40NzcxNTI1IDAgMTAgQyAwIDE1LjUyMjg0NyA0LjQ3NzE1MjUgMjAgMTAgMjAgQyAxNS41MjI4NDcgMjAgMjAgMTUuNTIyODQ3IDIwIDEwIEMgMjAgNC40NzcxNTI1IDE1LjUyMjg0NyAxLjE4NDIzNzllLTE1IDEwIDAgeiBNIDkuMDkzNzUgMS4wMzEyNSBDIDkuMjI5MjE2NCAxLjAxNzQ5MjYgOS4zNjI4MjUgMS4wMzg5MzExIDkuNSAxLjAzMTI1IEwgOS41IDMuNSBMIDEwLjUgMy41IEwgMTAuNSAxLjAzMTI1IEMgMTUuMDYzNTI2IDEuMjg2NzgzMSAxOC43MTMyMTcgNC45MzY0NzM4IDE4Ljk2ODc1IDkuNSBMIDE2LjUgOS41IEwgMTYuNSAxMC41IEwgMTguOTY4NzUgMTAuNSBDIDE4LjcxMzIxNyAxNS4wNjM1MjYgMTUuMDYzNTI2IDE4LjcxMzIxNyAxMC41IDE4Ljk2ODc1IEwgMTAuNSAxNi41IEwgOS41IDE2LjUgTCA5LjUgMTguOTY4NzUgQyA0LjkzNjQ3MzggMTguNzEzMjE3IDEuMjg2NzgzMSAxNS4wNjM1MjYgMS4wMzEyNSAxMC41IEwgMy41IDEwLjUgTCAzLjUgOS41IEwgMS4wMzEyNSA5LjUgQyAxLjI3OTEwMiA1LjA3MzY0ODggNC43MjI1MzI2IDEuNDc1MTcxMyA5LjA5Mzc1IDEuMDMxMjUgeiBNIDkuNSA1IEwgOS41IDguMDYyNSBDIDguNjM3MzAwNyA4LjI4NDQ2MjcgOCA5LjA2ODAxOTUgOCAxMCBDIDggMTEuMTA0NTY5IDguODk1NDMwNSAxMiAxMCAxMiBDIDEwLjkzMTk4MSAxMiAxMS43MTU1MzcgMTEuMzYyNjk5IDExLjkzNzUgMTAuNSBMIDE0IDEwLjUgTCAxNCA5LjUgTCAxMS45Mzc1IDkuNSBDIDExLjc1NjY0MiA4Ljc5NzA1OTkgMTEuMjAyOTQgOC4yNDMzNTg1IDEwLjUgOC4wNjI1IEwgMTAuNSA1IEwgOS41IDUgeiBcIiBmaWxsPVwiIzU4NTg1OFwiIHN0cm9rZT1cIm5vbmVcIj48L3BhdGg+XHJcbiAqIDwvZz5cclxuICovXHJcblxyXG5cdGZ1bmN0aW9uIENhdGNoVGltZXJFdmVudE5vZGUobW9kZWwsIGFwaSkge1xyXG5cdFx0RXZlbnROb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnN0YXJ0SWNvbiA9ICdNIDEwIDAgQyA0LjQ3NzE1MjUgMCAwIDQuNDc3MTUyNSAwIDEwIEMgMCAxNS41MjI4NDcgNC40NzcxNTI1IDIwIDEwIDIwIEMgMTUuNTIyODQ3IDIwIDIwIDE1LjUyMjg0NyAyMCAxMCBDIDIwIDQuNDc3MTUyNSAxNS41MjI4NDcgMS4xODQyMzc5ZS0xNSAxMCAwIHogTSA5LjA5Mzc1IDEuMDMxMjUgQyA5LjIyOTIxNjQgMS4wMTc0OTI2IDkuMzYyODI1IDEuMDM4OTMxMSA5LjUgMS4wMzEyNSBMIDkuNSAzLjUgTCAxMC41IDMuNSBMIDEwLjUgMS4wMzEyNSBDIDE1LjA2MzUyNiAxLjI4Njc4MzEgMTguNzEzMjE3IDQuOTM2NDczOCAxOC45Njg3NSA5LjUgTCAxNi41IDkuNSBMIDE2LjUgMTAuNSBMIDE4Ljk2ODc1IDEwLjUgQyAxOC43MTMyMTcgMTUuMDYzNTI2IDE1LjA2MzUyNiAxOC43MTMyMTcgMTAuNSAxOC45Njg3NSBMIDEwLjUgMTYuNSBMIDkuNSAxNi41IEwgOS41IDE4Ljk2ODc1IEMgNC45MzY0NzM4IDE4LjcxMzIxNyAxLjI4Njc4MzEgMTUuMDYzNTI2IDEuMDMxMjUgMTAuNSBMIDMuNSAxMC41IEwgMy41IDkuNSBMIDEuMDMxMjUgOS41IEMgMS4yNzkxMDIgNS4wNzM2NDg4IDQuNzIyNTMyNiAxLjQ3NTE3MTMgOS4wOTM3NSAxLjAzMTI1IHogTSA5LjUgNSBMIDkuNSA4LjA2MjUgQyA4LjYzNzMwMDcgOC4yODQ0NjI3IDggOS4wNjgwMTk1IDggMTAgQyA4IDExLjEwNDU2OSA4Ljg5NTQzMDUgMTIgMTAgMTIgQyAxMC45MzE5ODEgMTIgMTEuNzE1NTM3IDExLjM2MjY5OSAxMS45Mzc1IDEwLjUgTCAxNCAxMC41IEwgMTQgOS41IEwgMTEuOTM3NSA5LjUgQyAxMS43NTY2NDIgOC43OTcwNTk5IDExLjIwMjk0IDguMjQzMzU4NSAxMC41IDguMDYyNSBMIDEwLjUgNSBMIDkuNSA1IHonO1xyXG4gICAgICAgIHRoaXMuaXRlbVNpemUgPSAxMDtcclxuXHRcdHRoaXMuYnBtbkluZm8gPSB7dHlwZTogNDMsIG5hbWU6XCJDYXRjaFRpbWVyRXZlbnRcIiB9OyAgICAvL+iKgueCueS/oeaBr1xyXG4gICAgICAgIHRoaXMucmVuZGVyKG1vZGVsKTtcclxuXHR9XHJcblxyXG4gICAgQ2F0Y2hUaW1lckV2ZW50Tm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuXHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZS0wLjVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTonIzU4NTg1OCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejoyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2lyY2xlLm5hbWUgPSBcIkNpcmNsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKGNpcmNsZSk7XHJcbiAgICAgICAgdmFyIGNpcmNsZTEgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgIHI6IHRoaXMuaXRlbVNpemUtM1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjNTg1ODU4J1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZChjaXJjbGUxKTtcclxuXHJcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZSs2O1xyXG4gICAgICAgIHZhciByZWN0ID0ge3g6LWl0ZW1TaXplLzIsIHk6IC1pdGVtU2l6ZS8yLCB3aWR0aDogaXRlbVNpemUsIGhlaWdodDppdGVtU2l6ZX07XHJcbiAgICAgICAgdGhpcy5hZGQoZ3JhcGhpYy5tYWtlUGF0aCh0aGlzLnN0YXJ0SWNvbiwge3N0eWxlOiB7c3Ryb2tlOicjNTg1ODU4J30sejoyfSwgcmVjdCxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIikrdGhpcy5pdGVtU2l6ZSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKSt0aGlzLml0ZW1TaXplXTtcclxuXHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoQ2F0Y2hUaW1lckV2ZW50Tm9kZSwgRXZlbnROb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IENhdGNoVGltZXJFdmVudE5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2V2ZW50L2JvdW5kYXJ5ZXZlbnQvQ2F0Y2hUaW1lckV2ZW50Tm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvL+i+ueeVjOS6i+S7ti0tLeaNleiOt+S/oeWPt+mHj+S6i+S7tlxyXG5cclxuXHR2YXIgRXZlbnROb2RlID0gcmVxdWlyZShcIi4uL0V2ZW50Tm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBpZD1cInNpZC1GRjBBREZDMC1EM0VDLTQyMzctQUQxNi1BMzYyNzNEMUZFNkRcIiB0aXRsZT1cIlN0YXJ0IGV2ZW50XCI+XHJcbiAqICAgIDxjaXJjbGUgaWQ9XCJzaWQtRjhERkJEQUQtMjg1Mi00QTlBLTg0RTktQTY1OTQzQTA5NjJCYmdfZnJhbWVcIiBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIxNVwiIHN0cm9rZT1cIiM1ODU4NThcIiBmaWxsPVwiI2ZmZmZmZlwiIHN0cm9rZS13aWR0aD1cIjFcIiBzdHlsZT1cInN0cm9rZS1kYXNoYXJyYXk6IDUuNSwgM1wiPjwvY2lyY2xlPlxyXG4gKiAgICA8Y2lyY2xlIGlkPVwic2lkLUY4REZCREFELTI4NTItNEE5QS04NEU5LUE2NTk0M0EwOTYyQmZyYW1lMl9ub25faW50ZXJydXB0aW5nXCIgY3g9XCIxNlwiIGN5PVwiMTZcIiByPVwiMTJcIiBzdHJva2U9XCIjNTg1ODU4XCIgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIxXCIgc3R5bGU9XCJzdHJva2UtZGFzaGFycmF5OiA0LjUsIDNcIj48L2NpcmNsZT5cclxuICogICAgPHBhdGggaWQ9XCJzaWQtM0NDMzM5MjQtNzNGMy00RDEzLUEyQTktMDI0MjUzMDY4MERFc2lnbmFsQ2F0Y2hpbmdcIiBzdHJva2U9XCIjNTg1ODU4XCIgZD1cIiBNNy43MTI0OTcxIDIwLjI0NzM0MiAgTDIyLjMzMzMzNCAyMC4yNDczNDIgIEwxNS4wMjI5MTUwMDAwMDAwMDEgNy41NzU5NTEyMDAwMDAwMDEgIEw3LjcxMjQ5NzEgMjAuMjQ3MzQyICB6XCIgc3R5bGU9XCJmaWxsOm5vbmU7c3Ryb2tlLXdpZHRoOjEuNDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZVwiPjwvcGF0aD5cclxuICogPC9nPlxyXG4gKi9cclxuXHJcblx0ZnVuY3Rpb24gQ2F0Y2hTaWduYWxFdmVudE5vZGUobW9kZWwsIGFwaSkge1xyXG5cdFx0RXZlbnROb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnN0YXJ0SWNvbiA9ICdNNy43MTI0OTcxIDIwLjI0NzM0MiAgTDIyLjMzMzMzNCAyMC4yNDczNDIgIEwxNS4wMjI5MTUwMDAwMDAwMDEgNy41NzU5NTEyMDAwMDAwMDEgIEw3LjcxMjQ5NzEgMjAuMjQ3MzQyICB6JztcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMTA7XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDcyLCBuYW1lOlwiQ2F0Y2hTaWduYWxFdmVudFwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG5cdH1cclxuXHJcbiAgICBDYXRjaFNpZ25hbEV2ZW50Tm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuXHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZS0wLjVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTonIzU4NTg1OCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejoyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2lyY2xlLm5hbWUgPSBcIkNpcmNsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKGNpcmNsZSk7XHJcbiAgICAgICAgdmFyIGNpcmNsZTEgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgIHI6IHRoaXMuaXRlbVNpemUtM1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjNTg1ODU4J1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZChjaXJjbGUxKTtcclxuXHJcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZSs2O1xyXG4gICAgICAgIHZhciByZWN0ID0ge3g6LWl0ZW1TaXplLzIsIHk6IC1pdGVtU2l6ZS8yLTMsIHdpZHRoOiBpdGVtU2l6ZSwgaGVpZ2h0Oml0ZW1TaXplfTtcclxuICAgICAgICB0aGlzLmFkZChncmFwaGljLm1ha2VQYXRoKHRoaXMuc3RhcnRJY29uLCB7c3R5bGU6IHtzdHJva2U6JyM1ODU4NTgnLGZpbGw6JyNmZmZmZmYnfSx6OjJ9LCByZWN0LFwiY2VudGVyXCIpKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSt0aGlzLml0ZW1TaXplICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpK3RoaXMuaXRlbVNpemVdO1xyXG5cclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhDYXRjaFNpZ25hbEV2ZW50Tm9kZSwgRXZlbnROb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IENhdGNoU2lnbmFsRXZlbnROb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L0NhdGNoU2lnbmFsRXZlbnROb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8v6L6555WM5LqL5Lu2LS0tVGhyb3dTaWduYWxFdmVudOiKgueCuVxyXG5cclxuXHR2YXIgRXZlbnROb2RlID0gcmVxdWlyZShcIi4uL0V2ZW50Tm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBpZD1cInNpZC1GRjBBREZDMC1EM0VDLTQyMzctQUQxNi1BMzYyNzNEMUZFNkRcIiB0aXRsZT1cIlN0YXJ0IGV2ZW50XCI+XHJcbiAqICAgIDxjaXJjbGUgaWQ9XCJzaWQtRjhERkJEQUQtMjg1Mi00QTlBLTg0RTktQTY1OTQzQTA5NjJCYmdfZnJhbWVcIiBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIxNVwiIHN0cm9rZT1cIiM1ODU4NThcIiBmaWxsPVwiI2ZmZmZmZlwiIHN0cm9rZS13aWR0aD1cIjFcIiBzdHlsZT1cInN0cm9rZS1kYXNoYXJyYXk6IDUuNSwgM1wiPjwvY2lyY2xlPlxyXG4gKiAgICA8Y2lyY2xlIGlkPVwic2lkLUY4REZCREFELTI4NTItNEE5QS04NEU5LUE2NTk0M0EwOTYyQmZyYW1lMl9ub25faW50ZXJydXB0aW5nXCIgY3g9XCIxNlwiIGN5PVwiMTZcIiByPVwiMTJcIiBzdHJva2U9XCIjNTg1ODU4XCIgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIxXCIgc3R5bGU9XCJzdHJva2UtZGFzaGFycmF5OiA0LjUsIDNcIj48L2NpcmNsZT5cclxuICogICAgPHBhdGggaWQ9XCJzaWQtM0NDMzM5MjQtNzNGMy00RDEzLUEyQTktMDI0MjUzMDY4MERFc2lnbmFsQ2F0Y2hpbmdcIiBzdHJva2U9XCIjNTg1ODU4XCIgZD1cIiBNNy43MTI0OTcxIDIwLjI0NzM0MiAgTDIyLjMzMzMzNCAyMC4yNDczNDIgIEwxNS4wMjI5MTUwMDAwMDAwMDEgNy41NzU5NTEyMDAwMDAwMDEgIEw3LjcxMjQ5NzEgMjAuMjQ3MzQyICB6XCIgc3R5bGU9XCJmaWxsOm5vbmU7c3Ryb2tlLXdpZHRoOjEuNDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZVwiPjwvcGF0aD5cclxuICogPC9nPlxyXG4gKi9cclxuXHJcblx0ZnVuY3Rpb24gVGhyb3dTaWduYWxFdmVudE5vZGUobW9kZWwsIGFwaSkge1xyXG5cdFx0RXZlbnROb2RlLmNhbGwodGhpcyxtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnN0YXJ0SWNvbiA9ICdNNy43MTI0OTcxIDIwLjI0NzM0MiAgTDIyLjMzMzMzNCAyMC4yNDczNDIgIEwxNS4wMjI5MTUwMDAwMDAwMDEgNy41NzU5NTEyMDAwMDAwMDEgIEw3LjcxMjQ5NzEgMjAuMjQ3MzQyICB6JztcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMTA7XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDc1LCBuYW1lOlwiVGhyb3dTaWduYWxFdmVudFwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG5cdH1cclxuXHJcbiAgICBUaHJvd1NpZ25hbEV2ZW50Tm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuXHJcbiAgICAgICAgdmFyIGNpcmNsZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICAgICAgcjogdGhpcy5pdGVtU2l6ZS0wLjVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTonIzU4NTg1OCdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejoyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2lyY2xlLm5hbWUgPSBcIkNpcmNsZVwiO1xyXG4gICAgICAgIHRoaXMuYWRkKGNpcmNsZSk7XHJcbiAgICAgICAgdmFyIGNpcmNsZTEgPSBuZXcgZ3JhcGhpYy5DaXJjbGUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgICAgIHI6IHRoaXMuaXRlbVNpemUtM1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjNTg1ODU4J1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjJcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZChjaXJjbGUxKTtcclxuXHJcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZSs2O1xyXG4gICAgICAgIHZhciByZWN0ID0ge3g6LWl0ZW1TaXplLzIsIHk6IC1pdGVtU2l6ZS8yLTMsIHdpZHRoOiBpdGVtU2l6ZSwgaGVpZ2h0Oml0ZW1TaXplfTtcclxuICAgICAgICB0aGlzLmFkZChncmFwaGljLm1ha2VQYXRoKHRoaXMuc3RhcnRJY29uLCB7c3R5bGU6IHtzdHJva2U6JyM1ODU4NTgnLGZpbGw6JyMwMDAwMDAnfSx6OjJ9LCByZWN0LFwiY2VudGVyXCIpKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gW21vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueFwiKSt0aGlzLml0ZW1TaXplICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpK3RoaXMuaXRlbVNpemVdO1xyXG5cclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhUaHJvd1NpZ25hbEV2ZW50Tm9kZSwgRXZlbnROb2RlKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IFRocm93U2lnbmFsRXZlbnROb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9ldmVudC9ib3VuZGFyeWV2ZW50L1Rocm93U2lnbmFsRXZlbnROb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gOTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vSW5jbHVzaXZlR2F0ZVdheeiKgueCuVxyXG5cclxuXHR2YXIgR2F0ZXdheU5vZGUgPSByZXF1aXJlKFwiLi9HYXRld2F5Tm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBpZD1cInNpZC1GRjBBREZDMC1EM0VDLTQyMzctQUQxNi1BMzYyNzNEMUZFNkRcIiB0aXRsZT1cIlN0YXJ0IGV2ZW50XCI+XHJcbiAqICAgIDxwYXRoIGQ9XCIgTTAgMTkuNTA2MzkzOTY0ICBMMTkuNTA2MzkzOTY0IDAgIEwzOS4wMTI3ODc5NjQgMTkuNTA2MzkzOTY0ICBMMTkuNTA2MzkzOTY0IDM5LjAxMjc4Nzk2NCAgTDAgMTkuNTA2MzkzOTY0ICBMMCAxOS41MDYzOTM5NjQgIHpcIiBpZD1cInNpZC02RDBFOTNEQS0wRTBCLTQ3RjAtQUY4NS0zRjMyMzAzNjc2NTFSZWN0YW5nbGUtMVwiIGZpbGw9XCIjRjZBNjIzXCI+PC9wYXRoPlxyXG4gKiAgICA8cGF0aCBkPVwiIE0xOS44NTEyMjE1NjQgMjcuNzgyMjU2MDY0MDAwMDAyICBDMjQuMjMxNDEwOTY0IDI3Ljc4MjI1NjA2NDAwMDAwMiAyNy43ODIyNTYwNjQwMDAwMDIgMjQuMjMxNDEwOTY0IDI3Ljc4MjI1NjA2NDAwMDAwMiAxOS44NTEyMjE1NjQgIEMyNy43ODIyNTYwNjQwMDAwMDIgMTUuNDcxMDMyMTYzOTk5OTk5IDI0LjIzMTQxMDk2NCAxMS45MjAxODcwNjM5OTk5OTkgMTkuODUxMjIxNTY0IDExLjkyMDE4NzA2Mzk5OTk5OSAgQzE1LjQ3MTAzMjE2Mzk5OTk5OSAxMS45MjAxODcwNjM5OTk5OTkgMTEuOTIwMTg3MDYzOTk5OTk5IDE1LjQ3MTAzMjE2Mzk5OTk5OSAxMS45MjAxODcwNjM5OTk5OTkgMTkuODUxMjIxNTY0ICBDMTEuOTIwMTg3MDYzOTk5OTk5IDI0LjIzMTQxMDk2NCAxNS40NzEwMzIxNjM5OTk5OTkgMjcuNzgyMjU2MDY0MDAwMDAyIDE5Ljg1MTIyMTU2NCAyNy43ODIyNTYwNjQwMDAwMDIgIHpcIiBpZD1cInNpZC02RDBFOTNEQS0wRTBCLTQ3RjAtQUY4NS0zRjMyMzAzNjc2NTFPdmFsLTRcIiBmaWxsPVwiI0ZGRkZGRlwiPjwvcGF0aD5cclxuICogPC9nPlxyXG4gKi9cclxuXHJcblx0ZnVuY3Rpb24gSW5jbHVzaXZlR2F0ZXdheU5vZGUobW9kZWwsIGFwaSkge1xyXG5cdFx0R2F0ZXdheU5vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnN0YXJ0SWNvbiA9ICdNMCAxOS41MDYzOTM5NjQgIEwxOS41MDYzOTM5NjQgMCAgTDM5LjAxMjc4Nzk2NCAxOS41MDYzOTM5NjQgIEwxOS41MDYzOTM5NjQgMzkuMDEyNzg3OTY0ICBMMCAxOS41MDYzOTM5NjQgIEwwIDE5LjUwNjM5Mzk2NCAgeic7XHJcbiAgICAgICAgdGhpcy5uZXh0SWNvbiA9ICdNMTkuODUxMjIxNTY0IDI3Ljc4MjI1NjA2NDAwMDAwMiAgQzI0LjIzMTQxMDk2NCAyNy43ODIyNTYwNjQwMDAwMDIgMjcuNzgyMjU2MDY0MDAwMDAyIDI0LjIzMTQxMDk2NCAyNy43ODIyNTYwNjQwMDAwMDIgMTkuODUxMjIxNTY0ICBDMjcuNzgyMjU2MDY0MDAwMDAyIDE1LjQ3MTAzMjE2Mzk5OTk5OSAyNC4yMzE0MTA5NjQgMTEuOTIwMTg3MDYzOTk5OTk5IDE5Ljg1MTIyMTU2NCAxMS45MjAxODcwNjM5OTk5OTkgIEMxNS40NzEwMzIxNjM5OTk5OTkgMTEuOTIwMTg3MDYzOTk5OTk5IDExLjkyMDE4NzA2Mzk5OTk5OSAxNS40NzEwMzIxNjM5OTk5OTkgMTEuOTIwMTg3MDYzOTk5OTk5IDE5Ljg1MTIyMTU2NCAgQzExLjkyMDE4NzA2Mzk5OTk5OSAyNC4yMzE0MTA5NjQgMTUuNDcxMDMyMTYzOTk5OTk5IDI3Ljc4MjI1NjA2NDAwMDAwMiAxOS44NTEyMjE1NjQgMjcuNzgyMjU2MDY0MDAwMDAyICB6JztcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMjA7XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDIwLCBuYW1lOlwiSW5jbHVzaXZlR2F0ZXdheVwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG5cdH1cclxuXHJcbiAgICBJbmNsdXNpdmVHYXRld2F5Tm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICB2YXIgaXRlbVNpemUgPSB0aGlzLml0ZW1TaXplKjI7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB7eDotaXRlbVNpemUvMiwgeTogLWl0ZW1TaXplLzIsIHdpZHRoOiBpdGVtU2l6ZSwgaGVpZ2h0Oml0ZW1TaXplfTtcclxuICAgICAgICB2YXIgcGF0aCA9IGdyYXBoaWMubWFrZVBhdGgodGhpcy5zdGFydEljb24sIHtzdHlsZToge2ZpbGw6ICcjRjZBNjIzJ30sejoyfSwgcmVjdCxcImNlbnRlclwiKTtcclxuICAgICAgICBwYXRoLm5hbWUgPSAnUGF0aCc7XHJcbiAgICAgICAgdGhpcy5hZGQocGF0aCk7XHJcbiAgICAgICAgdmFyIGl0ZW1TaXplMSA9IHRoaXMuaXRlbVNpemU7XHJcbiAgICAgICAgdmFyIHJlY3QxID0ge3g6LWl0ZW1TaXplMS8yLCB5OiAtaXRlbVNpemUxLzIsIHdpZHRoOiBpdGVtU2l6ZTEsIGhlaWdodDppdGVtU2l6ZTF9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5uZXh0SWNvbiwge3N0eWxlOiB7ZmlsbDogJyNGRkZGRkYnfSx6OjJ9LCByZWN0MSxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIikraXRlbVNpemUxICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpK2l0ZW1TaXplMV07XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5kcmF3VGV4dChtb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhJbmNsdXNpdmVHYXRld2F5Tm9kZSwgR2F0ZXdheU5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gSW5jbHVzaXZlR2F0ZXdheU5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2dhdGV3YXkvSW5jbHVzaXZlR2F0ZXdheU5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy/miYDmnIlHYXRlV2F56IqC54K555qE5Z+657G7XHJcblxyXG4gICAgdmFyIEJQTU5Ob2RlID0gcmVxdWlyZShcIi4uL0JQTU5Ob2RlXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcbiAgICAvL+WIm+W7uk5vZGXnsbsg5omA5pyJ5b2i54q26YO957un5om/Tm9kZSAg5YyF5ousZnJvbUpTT04gdG9KU09OXHJcbiAgICAvL1xyXG4gICAgZnVuY3Rpb24gR2F0ZXdheU5vZGUobW9kZWwsIGFwaSkge1xyXG4gICAgICAgIEJQTU5Ob2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5icG1uSW5mbyA9IHt0eXBlOiAtMSwgbmFtZTpcIkdhdGV3YXlOb2RlXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICB9XHJcblxyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLmdldFJlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAvL+WIm+W7uuacgOWwj+WMheWbtOebkuiZmue6v1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICBwb2ludHNbMF0gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzFdID1bYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgcG9pbnRzWzJdID1bYm91bmRpbmdSZWN0LndpZHRoLzIsYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbM10gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbNF0gPVstYm91bmRpbmdSZWN0LndpZHRoLzIsLWJvdW5kaW5nUmVjdC5oZWlnaHQvMl07XHJcbiAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QodGhpcy5wb3NpdGlvblswXSAtIGJvdW5kaW5nUmVjdC53aWR0aC8yICxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdIC0gYm91bmRpbmdSZWN0LmhlaWdodC8yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nUmVjdC53aWR0aCwgYm91bmRpbmdSZWN0LmhlaWdodCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogdGhpcy5wb3NpdGlvblswXSxcclxuICAgICAgICAgICAgeTogdGhpcy5wb3NpdGlvblsxXSxcclxuICAgICAgICAgICAgd2lkdGg6IGJvdW5kaW5nUmVjdC53aWR0aC8yLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQvMixcclxuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgICAgICAgIGJvdW5kaW5nUmVjdDogYm91bmRSZWN0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9O1xyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ocFgscFkpIHtcclxuICAgICAgICAvLyBib2R5Li4uXHJcbiAgICAgICAgdGhpcy5hdHRyKCdwb3NpdGlvbicsW3BYLHBZXSk7XHJcbiAgICB9O1xyXG4gICAgR2F0ZXdheU5vZGUucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5jaGlsZE9mTmFtZShcIlBhdGhcIik7XHJcbiAgICAgICAgcmV0dXJuIHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhHYXRld2F5Tm9kZSxCUE1OTm9kZSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdhdGV3YXlOb2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9nYXRld2F5L0dhdGV3YXlOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vRXhjbHVzaXZlR2F0ZVdheeiKgueCuVxyXG5cclxuXHR2YXIgR2F0ZXdheU5vZGUgPSByZXF1aXJlKFwiLi9HYXRld2F5Tm9kZVwiKTtcclxuXHR2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiA8ZyBwb2ludGVyLWV2ZW50cz1cImZpbGxcIiBpZD1cInNpZC1GRjBBREZDMC1EM0VDLTQyMzctQUQxNi1BMzYyNzNEMUZFNkRcIiB0aXRsZT1cIlN0YXJ0IGV2ZW50XCI+XHJcbiAqICAgIDxwYXRoIGQ9XCIgTTAgMTkuNTA2MzkzOTY0ICBMMTkuNTA2MzkzOTY0IDAgIEwzOS4wMTI3ODc5NjQgMTkuNTA2MzkzOTY0ICBMMTkuNTA2MzkzOTY0IDM5LjAxMjc4Nzk2NCAgTDAgMTkuNTA2MzkzOTY0ICBMMCAxOS41MDYzOTM5NjQgIHpcIiBpZD1cInNpZC02RDBFOTNEQS0wRTBCLTQ3RjAtQUY4NS0zRjMyMzAzNjc2NTFSZWN0YW5nbGUtMVwiIGZpbGw9XCIjRjZBNjIzXCI+PC9wYXRoPlxyXG4gKiAgICA8cGF0aCBkPVwiIE04LjI3NTg2MjA2OSAxMS45NjU1MTcyNjkwMDAwMDEgIEwxLjQ5OTk5OTk5OSAxMS45NjU1MTcyNjkwMDAwMDEgIEwwIDExLjk2NTUxNzI2OTAwMDAwMSAgTDAgOC45NjU1MTcyMzkgIEwxLjQ5OTk5OTk5OSA4Ljk2NTUxNzIzOSAgTDguMjc1ODYyMDY5IDguOTY1NTE3MjM5ICBMOC4yNzU4NjIwNjkgMS40OTk5OTk5OTkgIEw4LjI3NTg2MjA2OSAwICBMMTEuMjc1ODYyMDY5IDAgIEwxMS4yNzU4NjIwNjkgMS40OTk5OTk5OTkgIEwxMS4yNzU4NjIwNjkgOC45NjU1MTcyMzkgIEwxOC43NDEzNzkyNjkgOC45NjU1MTcyMzkgIEwyMC4yNDEzNzkyNjkgOC45NjU1MTcyMzkgIEwyMC4yNDEzNzkyNjkgMTEuOTY1NTE3MjY5MDAwMDAxICBMMTguNzQxMzc5MjY5IDExLjk2NTUxNzI2OTAwMDAwMSAgTDExLjI3NTg2MjA2OSAxMS45NjU1MTcyNjkwMDAwMDEgIEwxMS4yNzU4NjIwNjkgMTguNzQxMzc5MjY5ICBMMTEuMjc1ODYyMDY5IDIwLjI0MTM3OTI2OSAgTDguMjc1ODYyMDY5IDIwLjI0MTM3OTI2OSAgTDguMjc1ODYyMDY5IDE4Ljc0MTM3OTI2OSAgTDguMjc1ODYyMDY5IDExLjk2NTUxNzI2OTAwMDAwMSAgelwiIGlkPVwic2lkLTFCODhEMkRGLUEwOEYtNDgzNy05MUYyLTkxRjY3QUNBQjI5QUxpbmUtQ29weVwiPjwvcGF0aD5cclxuICogPC9nPlxyXG4gKi9cclxuXHJcblx0ZnVuY3Rpb24gRXhjbHVzaXZlR2F0ZXdheU5vZGUobW9kZWwsIGFwaSkge1xyXG5cdFx0R2F0ZXdheU5vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuICAgICAgICB0aGlzLnN0YXJ0SWNvbiA9ICdNMCAxOS41MDYzOTM5NjQgIEwxOS41MDYzOTM5NjQgMCAgTDM5LjAxMjc4Nzk2NCAxOS41MDYzOTM5NjQgIEwxOS41MDYzOTM5NjQgMzkuMDEyNzg3OTY0ICBMMCAxOS41MDYzOTM5NjQgIEwwIDE5LjUwNjM5Mzk2NCAgeic7XHJcbiAgICAgICAgdGhpcy5uZXh0SWNvbiA9ICdNMTkuOTA0MTI5MDY0MDAwMDAzIDE3LjY3Njk5Mzk2NDAwMDAwNSAgTDI0Ljk5NzQ1Nzg2NDAwMDAwNSAxMi41ODM2NjQ4NjQwMDAwMDMgIEwyNi4wNTgxMTgwNjQwMDAwMDYgMTEuNTIzMDA0NjY0MDAwMDAyICBMMjguMTc5NDM4NDY0IDEzLjY0NDMyNDk2NDAwMDAwMyAgTDI3LjExODc3ODI2NCAxNC43MDQ5ODUxNjQwMDAwMDIgIEwyMi4wMjU0NDkzNjQwMDAwMDQgMTkuNzk4MzE0MzY0ICBMMjcuMTE4Nzc4MjY0IDI0Ljg5MTY0MzQ2NDAwMDAwNSAgTDI4LjE3OTQzODQ2NCAyNS45NTIzMDM2NjQwMDAwMDYgIEwyNi4wNTgxMTgwNjQwMDAwMDYgMjguMDczNjIzOTY0MDAwMDAzICBMMjQuOTk3NDU3ODY0MDAwMDA1IDI3LjAxMjk2Mzc2NDAwMDAwNiAgTDE5LjkwNDEyOTA2NDAwMDAwMyAyMS45MTk2MzQ3NjQgIEwxNC44MTA4MDAxNjQwMDAwMDMgMjcuMDEyOTYzNzY0MDAwMDA2ICBMMTMuNzUwMTQwMDY0MDAwMDAyIDI4LjA3MzYyMzk2NDAwMDAwMyAgTDExLjYyODgxOTY2NDAwMDAwMyAyNS45NTIzMDM2NjQwMDAwMDYgIEwxMi42ODk0Nzk3NjQwMDAwMDMgMjQuODkxNjQzNDY0MDAwMDA1ICBMMTcuNzgyODA4NzY0MDAwMDAyIDE5Ljc5ODMxNDM2NCAgTDEyLjY4OTQ3OTc2NDAwMDAwMyAxNC43MDQ5ODUxNjQwMDAwMDIgIEwxMS42Mjg4MTk2NjQwMDAwMDMgMTMuNjQ0MzI0OTY0MDAwMDAzICBMMTMuNzUwMTQwMDY0MDAwMDAyIDExLjUyMzAwNDY2NDAwMDAwMiAgTDE0LjgxMDgwMDE2NDAwMDAwMyAxMi41ODM2NjQ4NjQwMDAwMDMgIEwxOS45MDQxMjkwNjQwMDAwMDMgMTcuNjc2OTkzOTY0MDAwMDA1ICB6JztcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMjA7XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDE3LCBuYW1lOlwiRXhjbHVzaXZlR2F0ZXdheVwiIH07ICAgIC8v6IqC54K55L+h5oGvXHJcbiAgICAgICAgdGhpcy5yZW5kZXIobW9kZWwpO1xyXG5cdH1cclxuXHJcbiAgICBFeGNsdXNpdmVHYXRld2F5Tm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICB2YXIgaXRlbVNpemUgPSB0aGlzLml0ZW1TaXplKjI7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB7eDotaXRlbVNpemUvMiwgeTogLWl0ZW1TaXplLzIsIHdpZHRoOiBpdGVtU2l6ZSwgaGVpZ2h0Oml0ZW1TaXplfTtcclxuICAgICAgICB2YXIgcGF0aCA9IGdyYXBoaWMubWFrZVBhdGgodGhpcy5zdGFydEljb24sIHtzdHlsZToge2ZpbGw6ICcjRjZBNjIzJ30sejoyfSwgcmVjdCxcImNlbnRlclwiKTtcclxuICAgICAgICBwYXRoLm5hbWUgPSAnUGF0aCc7XHJcbiAgICAgICAgdGhpcy5hZGQocGF0aCk7XHJcbiAgICAgICAgdmFyIGl0ZW1TaXplMSA9IHRoaXMuaXRlbVNpemU7XHJcbiAgICAgICAgdmFyIHJlY3QxID0ge3g6LWl0ZW1TaXplMS8yLCB5OiAtaXRlbVNpemUxLzIsIHdpZHRoOiBpdGVtU2l6ZTEsIGhlaWdodDppdGVtU2l6ZTF9O1xyXG4gICAgICAgIHRoaXMuYWRkKGdyYXBoaWMubWFrZVBhdGgodGhpcy5uZXh0SWNvbiwge3N0eWxlOiB7ZmlsbDogJyNGRkZGRkYnfSx6OjJ9LCByZWN0MSxcImNlbnRlclwiKSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIikraXRlbVNpemUxICwgbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpK2l0ZW1TaXplMV07XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5kcmF3VGV4dChtb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuICAgIH07XHJcblxyXG5cdHpyVXRpbC5pbmhlcml0cyhFeGNsdXNpdmVHYXRld2F5Tm9kZSwgR2F0ZXdheU5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gRXhjbHVzaXZlR2F0ZXdheU5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL2dhdGV3YXkvRXhjbHVzaXZlR2F0ZXdheU5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy9QYXJhbGxlbEdhdGVXYXnoioLngrlcclxuXHJcblx0dmFyIEdhdGV3YXlOb2RlID0gcmVxdWlyZShcIi4vR2F0ZXdheU5vZGVcIik7XHJcblx0dmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcblxyXG4vKipcclxuICogPGcgcG9pbnRlci1ldmVudHM9XCJmaWxsXCIgaWQ9XCJzaWQtRkYwQURGQzAtRDNFQy00MjM3LUFEMTYtQTM2MjczRDFGRTZEXCIgdGl0bGU9XCJTdGFydCBldmVudFwiPlxyXG4gKiAgICA8cGF0aCBkPVwiIE0wIDE5LjUwNjM5Mzk2NCAgTDE5LjUwNjM5Mzk2NCAwICBMMzkuMDEyNzg3OTY0IDE5LjUwNjM5Mzk2NCAgTDE5LjUwNjM5Mzk2NCAzOS4wMTI3ODc5NjQgIEwwIDE5LjUwNjM5Mzk2NCAgTDAgMTkuNTA2MzkzOTY0ICB6XCIgaWQ9XCJzaWQtNkQwRTkzREEtMEUwQi00N0YwLUFGODUtM0YzMjMwMzY3NjUxUmVjdGFuZ2xlLTFcIiBmaWxsPVwiI0Y2QTYyM1wiPjwvcGF0aD5cclxuICogICAgPHBhdGggZD1cIiBNMTkuOTA0MTI5MDY0MDAwMDAzIDE3LjY3Njk5Mzk2NDAwMDAwNSAgTDI0Ljk5NzQ1Nzg2NDAwMDAwNSAxMi41ODM2NjQ4NjQwMDAwMDMgIEwyNi4wNTgxMTgwNjQwMDAwMDYgMTEuNTIzMDA0NjY0MDAwMDAyICBMMjguMTc5NDM4NDY0IDEzLjY0NDMyNDk2NDAwMDAwMyAgTDI3LjExODc3ODI2NCAxNC43MDQ5ODUxNjQwMDAwMDIgIEwyMi4wMjU0NDkzNjQwMDAwMDQgMTkuNzk4MzE0MzY0ICBMMjcuMTE4Nzc4MjY0IDI0Ljg5MTY0MzQ2NDAwMDAwNSAgTDI4LjE3OTQzODQ2NCAyNS45NTIzMDM2NjQwMDAwMDYgIEwyNi4wNTgxMTgwNjQwMDAwMDYgMjguMDczNjIzOTY0MDAwMDAzICBMMjQuOTk3NDU3ODY0MDAwMDA1IDI3LjAxMjk2Mzc2NDAwMDAwNiAgTDE5LjkwNDEyOTA2NDAwMDAwMyAyMS45MTk2MzQ3NjQgIEwxNC44MTA4MDAxNjQwMDAwMDMgMjcuMDEyOTYzNzY0MDAwMDA2ICBMMTMuNzUwMTQwMDY0MDAwMDAyIDI4LjA3MzYyMzk2NDAwMDAwMyAgTDExLjYyODgxOTY2NDAwMDAwMyAyNS45NTIzMDM2NjQwMDAwMDYgIEwxMi42ODk0Nzk3NjQwMDAwMDMgMjQuODkxNjQzNDY0MDAwMDA1ICBMMTcuNzgyODA4NzY0MDAwMDAyIDE5Ljc5ODMxNDM2NCAgTDEyLjY4OTQ3OTc2NDAwMDAwMyAxNC43MDQ5ODUxNjQwMDAwMDIgIEwxMS42Mjg4MTk2NjQwMDAwMDMgMTMuNjQ0MzI0OTY0MDAwMDAzICBMMTMuNzUwMTQwMDY0MDAwMDAyIDExLjUyMzAwNDY2NDAwMDAwMiAgTDE0LjgxMDgwMDE2NDAwMDAwMyAxMi41ODM2NjQ4NjQwMDAwMDMgIEwxOS45MDQxMjkwNjQwMDAwMDMgMTcuNjc2OTkzOTY0MDAwMDA1ICB6XCIgaWQ9XCJzaWQtOEZDRDZDMDEtQjk3My00QzlDLUE5MEItM0QyQURGQzc1MjE3TGluZVwiIGZpbGw9XCIjRkZGRkZGXCI+PC9wYXRoPlxyXG4gKiA8L2c+XHJcbiAqL1xyXG5cclxuXHRmdW5jdGlvbiBQYXJhbGxlbEdhdGV3YXlOb2RlKG1vZGVsLCBhcGkpIHtcclxuXHRcdEdhdGV3YXlOb2RlLmNhbGwodGhpcywgbW9kZWwsIGFwaSk7XHJcbiAgICAgICAgdGhpcy5zdGFydEljb24gPSAnTTAgMTkuNTA2MzkzOTY0ICBMMTkuNTA2MzkzOTY0IDAgIEwzOS4wMTI3ODc5NjQgMTkuNTA2MzkzOTY0ICBMMTkuNTA2MzkzOTY0IDM5LjAxMjc4Nzk2NCAgTDAgMTkuNTA2MzkzOTY0ICBMMCAxOS41MDYzOTM5NjQgIHonO1xyXG4gICAgICAgIHRoaXMubmV4dEljb24gPSAnTTguMjc1ODYyMDY5IDExLjk2NTUxNzI2OTAwMDAwMSAgTDEuNDk5OTk5OTk5IDExLjk2NTUxNzI2OTAwMDAwMSAgTDAgMTEuOTY1NTE3MjY5MDAwMDAxICBMMCA4Ljk2NTUxNzIzOSAgTDEuNDk5OTk5OTk5IDguOTY1NTE3MjM5ICBMOC4yNzU4NjIwNjkgOC45NjU1MTcyMzkgIEw4LjI3NTg2MjA2OSAxLjQ5OTk5OTk5OSAgTDguMjc1ODYyMDY5IDAgIEwxMS4yNzU4NjIwNjkgMCAgTDExLjI3NTg2MjA2OSAxLjQ5OTk5OTk5OSAgTDExLjI3NTg2MjA2OSA4Ljk2NTUxNzIzOSAgTDE4Ljc0MTM3OTI2OSA4Ljk2NTUxNzIzOSAgTDIwLjI0MTM3OTI2OSA4Ljk2NTUxNzIzOSAgTDIwLjI0MTM3OTI2OSAxMS45NjU1MTcyNjkwMDAwMDEgIEwxOC43NDEzNzkyNjkgMTEuOTY1NTE3MjY5MDAwMDAxICBMMTEuMjc1ODYyMDY5IDExLjk2NTUxNzI2OTAwMDAwMSAgTDExLjI3NTg2MjA2OSAxOC43NDEzNzkyNjkgIEwxMS4yNzU4NjIwNjkgMjAuMjQxMzc5MjY5ICBMOC4yNzU4NjIwNjkgMjAuMjQxMzc5MjY5ICBMOC4yNzU4NjIwNjkgMTguNzQxMzc5MjY5ICBMOC4yNzU4NjIwNjkgMTEuOTY1NTE3MjY5MDAwMDAxICB6JztcclxuICAgICAgICB0aGlzLml0ZW1TaXplID0gMjA7XHJcblx0XHR0aGlzLmJwbW5JbmZvID0ge3R5cGU6IDIwLCBuYW1lOlwiUGFyYWxsZWxHYXRld2F5XCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcblx0fVxyXG5cclxuICAgIFBhcmFsbGVsR2F0ZXdheU5vZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZSoyO1xyXG4gICAgICAgIHZhciByZWN0ID0ge3g6LWl0ZW1TaXplLzIsIHk6IC1pdGVtU2l6ZS8yLCB3aWR0aDogaXRlbVNpemUsIGhlaWdodDppdGVtU2l6ZX07XHJcbiAgICAgICAgdmFyIHBhdGggPSBncmFwaGljLm1ha2VQYXRoKHRoaXMuc3RhcnRJY29uLCB7c3R5bGU6IHtmaWxsOiAnI0Y2QTYyMyd9LHo6Mn0sIHJlY3QsXCJjZW50ZXJcIik7XHJcbiAgICAgICAgcGF0aC5uYW1lID0gJ1BhdGgnO1xyXG4gICAgICAgIHRoaXMuYWRkKHBhdGgpO1xyXG4gICAgICAgIHZhciBpdGVtU2l6ZTEgPSB0aGlzLml0ZW1TaXplO1xyXG4gICAgICAgIHZhciByZWN0MSA9IHt4Oi1pdGVtU2l6ZTEvMiwgeTogLWl0ZW1TaXplMS8yLCB3aWR0aDogaXRlbVNpemUxLCBoZWlnaHQ6aXRlbVNpemUxfTtcclxuICAgICAgICB0aGlzLmFkZChncmFwaGljLm1ha2VQYXRoKHRoaXMubmV4dEljb24sIHtzdHlsZToge2ZpbGw6ICcjRkZGRkZGJ30sejoyfSwgcmVjdDEsXCJjZW50ZXJcIikpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBbbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpK2l0ZW1TaXplMSAsIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKStpdGVtU2l6ZTFdO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZHJhd1RleHQobW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpKTtcclxuICAgICAgICB0aXRsZS50ZXh0Lm5hbWUgPSBcIlRpdGxlXCI7XHJcbiAgICAgICAgdGhpcy5hZGQodGl0bGUudGV4dCk7XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoUGFyYWxsZWxHYXRld2F5Tm9kZSwgR2F0ZXdheU5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gUGFyYWxsZWxHYXRld2F5Tm9kZTtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWJwbW4vbGliL25vZGUvZ2F0ZXdheS9QYXJhbGxlbEdhdGV3YXlOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8v5a2Q5rWB56iLXHJcblxyXG5cdHZhciBCUE1OTm9kZSA9IHJlcXVpcmUoXCIuL0JQTU5Ob2RlXCIpO1xyXG5cdHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcycpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG5cdC8v5Yib5bu6Tm9kZeexuyDmiYDmnInlvaLnirbpg73nu6fmib9Ob2RlXHJcblx0Ly9cclxuXHRmdW5jdGlvbiBTdWJQcm9jZXNzTm9kZShtb2RlbCwgYXBpKSB7XHJcblxyXG5cdFx0QlBNTk5vZGUuY2FsbCh0aGlzLCBtb2RlbCwgYXBpKTtcclxuXHRcdHRoaXMuYnBtbkluZm8gPSB7dHlwZTogLTEsIG5hbWU6XCJTdWJQcm9jZXNzXCIgfTsgICAgLy/oioLngrnkv6Hmga9cclxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XHJcbiAgICAgICAgdGhpcy5zbG90ID0gW107XHJcbiAgICAgICAgdGhpcy5zbG90RXZlbnQgPSBbXTtcclxuICAgICAgICB0aGlzLmlzQ2FuU2xvdCA9IHRydWU7XHJcbiAgICAgICAgdmFyIHdpZHRoLGhlaWdodDtcclxuICAgICAgICB3aWR0aCA9IG1vZGVsLmdldChcImJvdW5kcy5sb3dlclJpZ2h0LnhcIiktbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIpO1xyXG4gICAgICAgIGhlaWdodCA9IG1vZGVsLmdldChcImJvdW5kcy5sb3dlclJpZ2h0LnlcIiktbW9kZWwuZ2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIpO1xyXG4gICAgICAgIGlmKCF3aWR0aCB8fCB3aWR0aCA8PSAwKXtcclxuICAgICAgICAgICAgd2lkdGggPSAxNjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKCFoZWlnaHQgfHwgaGVpZ2h0IDw9IDApe1xyXG4gICAgICAgICAgICBoZWlnaHQgPSAxMDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJlY3RTaXplID0ge3dpZHRoOndpZHRoLCBoZWlnaHQ6aGVpZ2h0fTtcclxuICAgICAgICB0aGlzLnJlbmRlcihtb2RlbCk7XHJcblx0fVxyXG5cclxuXHJcbiAgICBTdWJQcm9jZXNzTm9kZS5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24oYXBpKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFsnZGJsY2xpY2snLCAnY2xpY2snXTsvLydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnXHJcblxyXG5cclxuICAgICAgICB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24gKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgdGhhdC5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gZS50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5wYXJlbnQgJiYgIGN1cnJlbnQucGFyZW50IGluc3RhbmNlb2YgQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBldmVOYW1lO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IHRoYXQ7XHJcbiAgICAgICAgICAgICAgICBhcGkudHJpZ2dlcihldmVOYW1lLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgXHR2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgeDogMC41LFxyXG4gICAgICAgICAgICAgICAgeTogMC41LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMucmVjdFNpemUud2lkdGgtMSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZWN0U2l6ZS5oZWlnaHQtMSxcclxuICAgICAgICAgICAgICAgIHI6IDdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnI2Y5ZjlmOScsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjYmJiYmJiJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6OjBcclxuICAgICAgICB9KTtcclxuICAgICAgICByZWN0Lm5hbWUgPSBcIlJlY3RcIjtcclxuICAgICAgICB0aGlzLmFkZChyZWN0KTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gIFttb2RlbC5nZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiksIG1vZGVsLmdldChcImJvdW5kcy51cHBlckxlZnQueVwiKV07XHJcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5kcmF3VGV4dChtb2RlbC5nZXQoXCJwcm9wZXJ0aWVzLm5hbWVcIikpO1xyXG4gICAgICAgIHRpdGxlLnRleHQubmFtZSA9IFwiVGl0bGVcIjtcclxuICAgICAgICB0aGlzLmFkZCh0aXRsZS50ZXh0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gYm9keS4uLlxyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIC8v5Yib5bu65pyA5bCP5YyF5Zu055uS6Jma57q/XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgIHBvaW50c1swXSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbMV0gPVtib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuICAgICAgICBwb2ludHNbMl0gPVtib3VuZGluZ1JlY3Qud2lkdGgvMixib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1szXSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMixib3VuZGluZ1JlY3QuaGVpZ2h0LzJdO1xyXG4gICAgICAgIHBvaW50c1s0XSA9Wy1ib3VuZGluZ1JlY3Qud2lkdGgvMiwtYm91bmRpbmdSZWN0LmhlaWdodC8yXTtcclxuXHJcbiAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QodGhpcy5wb3NpdGlvblswXSAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC5oZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMucG9zaXRpb25bMF0rYm91bmRpbmdSZWN0LndpZHRoLzIsXHJcbiAgICAgICAgICAgIHk6IHRoaXMucG9zaXRpb25bMV0rYm91bmRpbmdSZWN0LmhlaWdodC8yLFxyXG4gICAgICAgICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxyXG4gICAgICAgICAgICBib3VuZGluZ1JlY3Q6IGJvdW5kUmVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHBYLHBZKSB7XHJcbiAgICAgICAgLy8gYm9keS4uLlxyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIHRoaXMuYXR0cigncG9zaXRpb24nLFtwWC1ib3VuZGluZ1JlY3Qud2lkdGgvMixwWS1ib3VuZGluZ1JlY3QuaGVpZ2h0LzJdKTtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBTdWJQcm9jZXNzTm9kZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKG9wdCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jaGlsZE9mTmFtZShcIlJlY3RcIik7XHJcbiAgICAgICAgcmVjdC5zZXRTaGFwZShvcHQuc2hhcGUpO1xyXG4gICAgICAgIHRoaXMuYXR0cigncG9zaXRpb24nLG9wdC5wb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoVGV4dCgpO1xyXG4gICAgfTtcclxuXHJcblxyXG5cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5nZXRCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2hpbGRPZk5hbWUoXCJSZWN0XCIpO1xyXG4gICAgICAgIHJldHVybiByZWN0LmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNruWxnuaAp+iuvue9ruaooeWei+aVsOaNrlxyXG4gICAgICogQHBhcmFtIHtbdHlwZV19IG9wdGlvbiBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIFN1YlByb2Nlc3NOb2RlLnByb3RvdHlwZS5zZXRNb2RlbCA9IGZ1bmN0aW9uKG9wdGlvbikge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgb3JpZ2luVGV4dCA9IHRoaXMubW9kZWwuZ2V0KFwicHJvcGVydGllcy5uYW1lXCIpO1xyXG4gICAgICAgIHRoaXMubW9kZWwubWVyZ2VPcHRpb24ob3B0aW9uKTtcclxuICAgICAgICBpZihvcmlnaW5UZXh0ICE9IG9wdGlvbi5wcm9wZXJ0aWVzLm5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5jaGlsZE9mTmFtZShcIlRpdGxlXCIpO1xyXG4gICAgICAgICAgICB2YXIgbmFtZUJ5dGVMZW5ndGggPSBvcHRpb24ucHJvcGVydGllcy5uYW1lLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIHNob3dOYW1lO1xyXG4gICAgICAgICAgICBpZihuYW1lQnl0ZUxlbmd0aCA+IDY0KXtcclxuICAgICAgICAgICAgICAgIHNob3dOYW1lID0gb3B0aW9uLnByb3BlcnRpZXMubmFtZS5zdWJzdHIoMCw2NCkrJy4uJztcclxuICAgICAgICAgICAgICAgIHRoaXMuYWxhcm0uaXNTaG93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBzaG93TmFtZSA9IG9wdGlvbi5wcm9wZXJ0aWVzLm5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsYXJtLmlzU2hvdyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRpdGxlLmF0dHIoXCJzdHlsZVwiLHt0ZXh0OnNob3dOYW1lfSk7XHJcbiAgICAgICAgICAgIHRoYXQucmVmcmVzaFRleHQodGhhdCk7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gb3B0aW9uLnByb3BlcnRpZXMubmFtZTtcclxuICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmFsYXJtLmNoaWxkT2ZOYW1lKFwiVGV4dFwiKTtcclxuICAgICAgICAgICAgdGV4dC5hdHRyKFwic3R5bGVcIix7dGV4dDpuYW1lfSk7XHJcbiAgICAgICAgICAgIHZhciBncm91cFdpZHRoID0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCs0O1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBIZWlnaHQgPSB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCs4O1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW1xyXG4gICAgICAgICAgICAgICAgWzAsMF0sXHJcbiAgICAgICAgICAgICAgICBbZ3JvdXBXaWR0aCwwXSxcclxuICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLTMsZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgW2dyb3VwV2lkdGgtNixncm91cEhlaWdodCszXSxcclxuICAgICAgICAgICAgICAgIFtncm91cFdpZHRoLTksZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgWzAsZ3JvdXBIZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgWzAsMF1cclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgdmFyIFBvbHlsaW5lID0gdGhpcy5hbGFybS5jaGlsZE9mTmFtZShcIlBvbHlsaW5lXCIpO1xyXG4gICAgICAgICAgICBQb2x5bGluZS5hdHRyKFwic2hhcGVcIix7cG9pbnRzOnBvaW50c30pO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvbiA9IFt0aGlzLnBvc2l0aW9uWzBdK3RoaXMuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGgtKHRoaXMuYWxhcm0uZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGgtNiksdGhpcy5wb3NpdGlvblsxXS10aGlzLmFsYXJtLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodC0zXTtcclxuICAgICAgICAgICAgdGhpcy5hbGFybS5hdHRyKFwicG9zaXRpb25cIixncm91cFBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBTdWJQcm9jZXNzTm9kZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJyZXNvdXJjZUlkXCIsIHRoaXMucmVzb3VyY2VJZCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJwcm9wZXJ0aWVzLnR5cGVcIiwgdGhpcy5icG1uSW5mby50eXBlKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0ZW5jaWwudHlwZVwiLCB0aGlzLmJwbW5JbmZvLm5hbWUpOyAgLy9zdGVuY2lsLmlkXHJcbiAgICAgICAgaWYgKHRoaXMuc2xvdEV2ZW50ICYmIHRoaXMuc2xvdEV2ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGFyclNsb3RFdmVudCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5zbG90RXZlbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGFyclNsb3RFdmVudC5wdXNoKHRoaXMuc2xvdEV2ZW50W2ldLnJlc291cmNlSWQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJwcm9wZXJ0aWVzLnNsb3RFdmVudFwiLCBhcnJTbG90RXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdmFyIHJlY3QgPSB0aGlzLmdldFJlY3QoKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiwgcmVjdC54KTtcclxuICAgICAgICAgICAgLy8gdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIiwgcmVjdC55KTtcclxuICAgICAgICAgICAgLy8gdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC54XCIsIHJlY3QueCArIHJlY3QuYm91bmRpbmdSZWN0LndpZHRoKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC55XCIsIHJlY3QueSArIHJlY3QuYm91bmRpbmdSZWN0LmhlaWdodCk7XHJcblxyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRSZWN0KCkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIsIHJlY3QueCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIiwgcmVjdC55KTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImJvdW5kcy5sb3dlclJpZ2h0LnhcIiwgcmVjdC54ICsgcmVjdC53aWR0aCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC55XCIsIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcclxuXHJcblxyXG5cclxuICAgICAgICAvLyDliqDlhaXlrZDmtYHnqIvnmoQg6IqC54K5XHJcbiAgICAgICAgdmFyIGFyckNoaWxkU2FocGVzID0gW107XHJcbiAgICAgICAgdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24oY2hpbGQpe1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCUE1OTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgYXJyQ2hpbGRTYWhwZXMucHVzaChjaGlsZC50b0pTT04oKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgYXJyQ2hpbGRTYWhwZXMucHVzaChjaGlsZC50b0pTT04oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImNoaWxkU2hhcGVzXCIsIGFyckNoaWxkU2FocGVzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5vcHRpb247XHJcbiAgICB9O1xyXG5cclxuXHR6clV0aWwuaW5oZXJpdHMoU3ViUHJvY2Vzc05vZGUsQlBNTk5vZGUpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gU3ViUHJvY2Vzc05vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9ub2RlL1N1YlByb2Nlc3NOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDov57mjqXnur9cclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBOb2RlID0gcmVxdWlyZShcIi4uL05vZGUuanNcIik7XHJcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoXCIuL1N5bWJvbC5qc1wiKTtcclxuICAgIHZhciBIYW5kbGUgPSByZXF1aXJlKFwiLi9IYW5kbGUuanNcIik7XHJcbiAgICB2YXIgRWZmZWN0TGluZSA9IHJlcXVpcmUoXCIuL0VmZmVjdExpbmUuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdGlvblBvaW50ID0gcmVxdWlyZShcIi4vQ29ubmVjdGlvblBvaW50LmpzXCIpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uL1BvaW50LmpzXCIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiDmnoTpgKDlh73mlbBcclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfSBvcHRpb25zIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQ29ubmVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICBOb2RlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5vcHRpb24gJiYgb3B0aW9ucy5tb2RlbC5vcHRpb24ucmVzb3VyY2VJZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlSWQgPSBvcHRpb25zLm1vZGVsLm9wdGlvbi5yZXNvdXJjZUlkO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VJZCA9IFV0aWwuZ2V0VVVJRCgpOyAvLyDnlJ/miJDoioLngrlJRFxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHN5bWJvbDogeyB0eXBlOiBcImFycm93XCIsIHNpemU6IDEwLCBjb2xvcjogXCIjMDAwMDAwXCIgfSwgLy/nrq3lpLQgIOWPr+mAieWAvOS4uu+8miAnY2lyY2xlJywgJ3JlY3QnLCAncm91bmRSZWN0JywgJ3RyaWFuZ2xlJywgJ2RpYW1vbmQnLCAncGluJywgJ2Fycm93J1xyXG4gICAgICAgICAgICBzdHlsZTogeyBsaW5lV2lkdGg6IDEsIHN0cm9rZTogXCIjMDAwMDAwXCIsIGxpbmVUeXBlOiBDb25uZWN0b3IuVFlQRV9TVFJBSUdIVCB9LCAvL+agt+W8j1xyXG4gICAgICAgICAgICBob3ZlclN0eWxlOiB7IGxpbmVXaWR0aDogMiwgc3Ryb2tlOiBcImxpbWVcIiB9LCAvL+enu+S4iuWOu+eahOagt+W8j1xyXG4gICAgICAgICAgICBhcnJvd0hvdmVyU3R5bGU6IHsgZmlsbDogXCJsaW1lXCIgfSxcclxuICAgICAgICAgICAgc2hhcGU6IHsgcG9pbnRzOiBudWxsLCBzbW9vdGg6IGZhbHNlLCBzbW9vdGhDb25zdHJhaW50OiBudWxsIH0sIC8v5b2i54q2XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBbMCwgMF0sXHJcbiAgICAgICAgICAgIGlzRWRpdDogdHJ1ZSwgLy/mmK/lkKblj6/nvJbovpFcclxuICAgICAgICAgICAgdGV4dDoge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAnIzAwMDAwMCcsIC8vIOaWh+acrOminOiJslxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6ICcxMnB4IE1pY3Jvc29mdCBZYUhlaSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgejogMFxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVzID0gW107XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGFydE5vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZW5kTm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hdXRvQ2hhbmdlUG9zaXRpb24gPSBmYWxzZVxyXG4gICAgICAgIHRoaXMubGluZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ncm91cEN1cnZlID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcclxuICAgICAgICB0aGlzLmljb25zID0gW107IC8vIOeUqOS6juWtmOWCqOe6v+auteS4iumdoueahOaTjeS9nOWbvuagh1xyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQgPSAnc3RyYWlnaHQnO1xyXG5cclxuICAgIENvbm5lY3Rvci5UWVBFX0pBR0dFRCA9ICdqYWdnZWQnO1xyXG5cclxuICAgIENvbm5lY3Rvci5UWVBFX0NVUlZFID0gJ2N1cnZlJztcclxuXHJcbiAgICBDb25uZWN0b3IuUkFESVVTID0gMztcclxuXHJcbiAgICBDb25uZWN0b3IuU1RBUlRfTk9ERSA9IFwic3RhcnROb2RlXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLkVORF9OT0RFID0gXCJlbmROb2RlXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLkxFRlQgPSBcImxlZnRcIjtcclxuXHJcbiAgICBDb25uZWN0b3IuUklHSFQgPSBcInJpZ2h0XCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLlRPUCA9IFwidG9wXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLkJPVFRPTSA9IFwiYm90dG9tXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLkJPVFRPTSA9IFwiYm90dG9tXCI7XHJcblxyXG4gICAgQ29ubmVjdG9yLlNFUEVSQVRPUiA9IFwiLVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiDph43mlrDnlLvnur/vvIzlpoLmnpzkvKDnqbrliJnmoLnmja50dXJuaW5nUG9pbnRzIOmHjeaWsOeUu+e6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwb2ludHMgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbihwb2ludHMpIHtcclxuICAgICAgICBpZiAocG9pbnRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHVybmluZ1BvaW50cyA9IHBvaW50cztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/lsIZbeDowLHk6MF3ovazljJbkuLpbMCwgMF0gIOe7mXpyZW5kZXLkvb/nlKhcclxuICAgICAgICB2YXIgcG9pbnRzID0gVXRpbC50cmFzbGF0ZVBvaW50cyh0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG5cclxuICAgICAgICBpZiAoKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkgJiYgKHBvaW50cy5sZW5ndGggPiAyKSkge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGlmeUN1cnZlKHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lLmF0dHIoJ3NoYXBlJywgeyBwb2ludHM6IHBvaW50cyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsaW5lVGV4dCA9IHRoaXMuY2hpbGRPZk5hbWUoJ2xpbmVUZXh0Jyk7XHJcbiAgICAgICAgLy/lvIDlp4vmsqHmnInliJvlu7rmlofmnKzvvIzlkI7mnaXkvKDov5vmnaV0ZXh05LqG77yM6ZyA6KaB5YWI5Yib5bu65paH5pysXHJcbiAgICAgICAgaWYgKCFsaW5lVGV4dCAmJiB0aGlzLm9wdGlvbnMudGV4dC50ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5kcmF3VGV4dChcImxpbmVUZXh0XCIsIHRoaXMub3B0aW9ucy50ZXh0LnRleHQsIDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmFkZCh0ZXh0LnRleHQpO1xyXG4gICAgICAgICAgICBsaW5lVGV4dCA9IHRoaXMuY2hpbGRPZk5hbWUoJ2xpbmVUZXh0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaW5lVGV4dCkge1xyXG4gICAgICAgICAgICBsaW5lVGV4dC5zZXRTdHlsZShcInRleHRcIiwgdGhpcy5vcHRpb25zLnRleHQudGV4dCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGV4dFBvaW50ID0gdGhpcy5nZXRUZXh0UG9zdGlvbih0aGlzLm9wdGlvbnMudGV4dCk7XHJcblxyXG4gICAgICAgICAgICAvLyBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUICkge1xyXG4gICAgICAgICAgICAvLyAgICAgbGluZVRleHQuYXR0cigncm90YXRpb24nLCB0aGlzLmdldFRleHRSb3RhdGlvbih0ZXh0UG9pbnQpKTtcclxuICAgICAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAgICAgbGluZVRleHQuYXR0cihcInBvc2l0aW9uXCIsIHRleHRQb2ludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzeW1ib2xUbyA9IHRoaXMuY2hpbGRPZk5hbWUoJ3RvU3ltYm9sJyk7XHJcbiAgICAgICAgaWYgKHN5bWJvbFRvKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWZmZWN0ICYmIHRoaXMub3B0aW9ucy5lZmZlY3Quc2hvdykge1xyXG4gICAgICAgICAgICAgICAgbmV3IEVmZmVjdExpbmUoc3ltYm9sVG8sIHRoaXMub3B0aW9ucywgdGhpcy5ncm91cEN1cnZlLCB0aGlzLnBvbHlMaW5lKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFRvLmF0dHIoJ3Bvc2l0aW9uJywgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUby5hdHRyKCdyb3RhdGlvbicsIFV0aWwudGFuZ2VudFJvdGF0aW9uKHRoaXMudHVybmluZ1BvaW50c1t0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMl0sIHRoaXMudHVybmluZ1BvaW50c1t0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOa4suafk1xyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIC8vMS7liJvlu7rnrq3lpLRcclxuICAgICAgICB2YXIgc3ltYm9sVG8gPSB0aGlzLmNyZWF0ZVN5bWJvbCgndG9TeW1ib2wnLCB0aGlzLm9wdGlvbnMpOyAvL2Fycm93LHRyaWFuZ2xlXHJcbiAgICAgICAgaWYgKHN5bWJvbFRvKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHN5bWJvbFRvKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vMi7liJvlu7rnur9cclxuICAgICAgICB0aGlzLmN1cnZlTGluZSA9IG5ldyBncmFwaGljLkJlemllckN1cnZlKHtcclxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcclxuICAgICAgICAgICAgc3R5bGU6IHRoaXMub3B0aW9ucy5zdHlsZSxcclxuICAgICAgICAgICAgejogdGhpcy5vcHRpb25zLnpcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmdyb3VwQ3VydmUuYWRkKHRoaXMuY3VydmVMaW5lKTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLmdyb3VwQ3VydmUpO1xyXG5cclxuICAgICAgICB0aGlzLnBvbHlMaW5lID0gbmV3IGdyYXBoaWMuUG9seWxpbmUoe1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5vcHRpb25zLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICBzaGFwZTogdGhpcy5vcHRpb25zLnNoYXBlLFxyXG4gICAgICAgICAgICBzdHlsZTogdGhpcy5vcHRpb25zLnN0eWxlLFxyXG4gICAgICAgICAgICB6OiB0aGlzLm9wdGlvbnMuelxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMucG9seUxpbmUpO1xyXG5cclxuICAgICAgICBpZiAoKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkpIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lID0gdGhpcy5ncm91cEN1cnZlO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUhvdmVyU3R5bGUodGhpcy5jdXJ2ZUxpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLnBvbHlMaW5lLmhpZGUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmUgPSB0aGlzLnBvbHlMaW5lO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUhvdmVyU3R5bGUodGhpcy5wb2x5TGluZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VydmVMaW5lLmhpZGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vMy7kvqblkKznur/kuovku7ZcclxuICAgICAgICB2YXIgTU9VU0VfRVZFTlRfTkFNRVMgPSBbJ2RibGNsaWNrJywgJ2NsaWNrJ107IC8vJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCdcclxuICAgICAgICB6clV0aWwuZWFjaChNT1VTRV9FVkVOVF9OQU1FUywgZnVuY3Rpb24oZXZlTmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmUub24oZXZlTmFtZSwgenJVdGlsLmJpbmQoZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJDb25uZWN0b3I6XCIgKyBldmVOYW1lO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IHRoYXQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlzRWRpdCA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNFZGl0ICYmIHRoaXMuY29ubmVjdGlvblBvaW50cy5sZW5ndGggPCAxICYmIHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlQWxsY29ubmVjdGlvblBvaW50KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhbmRsZXMubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcGVTZXRIYW5kbGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdGhpcykpO1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAvLzMu5Yib5bu66LCD5pW057q/55qE6L+e5o6l54K5XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pc0VkaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMuY29uUG9pbnRzR3JvdXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy80LuWIm+W7uue6v+S4iuaWh+acrFxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dC50ZXh0ICYmIHRoaXMub3B0aW9ucy50ZXh0LnRleHQgIT0gXCJcIikge1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZHJhd1RleHQoXCJsaW5lVGV4dFwiLCB0aGlzLm9wdGlvbnMudGV4dC50ZXh0LCAwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5hZGQodGV4dC50ZXh0KTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy/orr7nva5zdHlsZVxyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5jb2xvcikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuZWFjaENoaWxkKGZ1bmN0aW9uKGN1cnZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VydmUuYXR0cihcInN0eWxlXCIsIHsgc3Ryb2tlOiBvcHRpb25zLmNvbG9yIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUoY3VydmUsIHsgc3Ryb2tlOiBvcHRpb25zLmNvbG9yIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvbHlMaW5lLmF0dHIoXCJzdHlsZVwiLCB7IHN0cm9rZTogb3B0aW9ucy5jb2xvciB9KTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUodGhpcy5wb2x5TGluZSwgeyBzdHJva2U6IG9wdGlvbnMuY29sb3IgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICAgICAgaWYgKHN5bWJvbFRvKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUby5hdHRyKFwic3R5bGVcIiwgeyBmaWxsOiBvcHRpb25zLmNvbG9yIH0pO1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpYy5zZXROb3JtYWxTdHlsZShzeW1ib2xUbywgeyBmaWxsOiBvcHRpb25zLmNvbG9yIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zdHlsZS5zdHJva2UgPSBvcHRpb25zLmNvbG9yO1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuc3R5bGUuc3Ryb2tlXCIsIG9wdGlvbnMuY29sb3IpO1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuc3ltYm9sLmNvbG9yXCIsIG9wdGlvbnMuY29sb3IpO1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3ltYm9sLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICAgICAgLy/lvIDlp4vmsqHmnInliJvlu7rmlofmnKzvvIzlkI7mnaXkvKDov5vmnaV0ZXh05LqG77yM6ZyA6KaB5YWI5Yib5bu65paH5pysXHJcbiAgICAgICAgICAgIGlmICghbGluZVRleHQgJiYgb3B0aW9ucy50ZXh0LnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5kcmF3VGV4dChcImxpbmVUZXh0XCIsIG9wdGlvbnMudGV4dC50ZXh0LCAwLCAwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHRleHQudGV4dCk7XHJcbiAgICAgICAgICAgICAgICBsaW5lVGV4dCA9IHRoaXMuY2hpbGRPZk5hbWUoJ2xpbmVUZXh0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRleHQudGV4dCB8fCBvcHRpb25zLnRleHQudGV4dCA9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lVGV4dC5zZXRTdHlsZShcInRleHRcIiwgb3B0aW9ucy50ZXh0LnRleHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRleHQudGV4dCA9IG9wdGlvbnMudGV4dC50ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ZXh0UG9pbnQgPSB0aGlzLmdldFRleHRQb3N0aW9uKG9wdGlvbnMudGV4dCk7XHJcbiAgICAgICAgICAgIGxpbmVUZXh0LmF0dHIoXCJwb3NpdGlvblwiLCB0ZXh0UG9pbnQpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50ZXh0LnRleHRQb3MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZXh0LnRleHRQb3MgPSBvcHRpb25zLnRleHQudGV4dFBvcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZXh0LnRleHRQb3MgPSAnY2VudGVyJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50ZXh0LmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lVGV4dC5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IG9wdGlvbnMudGV4dC5jb2xvclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGV4dC5jb2xvciA9IG9wdGlvbnMudGV4dC5jb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMudGV4dFwiLCBvcHRpb25zLnRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN5bWJvbC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3ltYm9sLnR5cGUgPSBvcHRpb25zLnN5bWJvbC50eXBlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zLnN5bWJvbC50eXBlXCIsIG9wdGlvbnMuc3ltYm9sLnR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN5bWJvbC5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3ltYm9sLnNpemUgPSBvcHRpb25zLnN5bWJvbC5zaXplO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zLnN5bWJvbC5zaXplXCIsIG9wdGlvbnMuc3ltYm9sLnNpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN5bWJvbC5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN5bWJvbC5jb2xvciA9IG9wdGlvbnMuc3ltYm9sLmNvbG9yO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zLnN5bWJvbC5jb2xvclwiLCBvcHRpb25zLnN5bWJvbC5jb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3ltYm9sLnopIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zeW1ib2wueiA9IG9wdGlvbnMuc3ltYm9sLno7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuc3ltYm9sLnpcIiwgb3B0aW9ucy5zeW1ib2wueik7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgc3ltYm9sVG8gPSB0aGlzLmNoaWxkT2ZOYW1lKCd0b1N5bWJvbCcpO1xyXG4gICAgICAgICAgICBpZiAoc3ltYm9sVG8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHN5bWJvbFRvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3ltYm9sID0gdGhpcy5jcmVhdGVTeW1ib2woXCJ0b1N5bWJvbFwiLCB0aGlzLm1vZGVsLmdldChcIm9wdGlvbnNcIikpXHJcbiAgICAgICAgICAgIGlmIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHN5bWJvbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bnur/mrrXnmoTkvY3nva5cclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gdGV4dCB7dGV4dDonJywgY29sb3I6JycsIHRleHRQb3M6Jyd9XHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAge3gseX1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5nZXRUZXh0UG9zdGlvbiA9IGZ1bmN0aW9uKHRleHQpIHtcclxuICAgICAgICB2YXIgdGV4dFBvc3Rpb24gPSBbXTtcclxuICAgICAgICB2YXIgdGV4dFdpZHRoID0gZ3JhcGhpYy50ZXh0Q29udGFpbi5nZXRXaWR0aCh0ZXh0LnRleHQsIHRleHQudGV4dEZvbnQpO1xyXG4gICAgICAgIGlmICh0ZXh0ICYmIHRleHQudGV4dFBvcykge1xyXG4gICAgICAgICAgICBpZiAodGV4dC50ZXh0UG9zID09ICdzdGFydCcpIHtcclxuICAgICAgICAgICAgICAgIHZhciB4T2Zmc2V0ID0gdGV4dC54T2Zmc2V0IHx8IDA7XHJcbiAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFt0aGlzLnR1cm5pbmdQb2ludHNbMF0ueCArIHhPZmZzZXQsIHRoaXMudHVybmluZ1BvaW50c1swXS55XTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXh0LnRleHRQb3MgPT0gJ2VuZCcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBVdGlsLmdldE1heExpbmVMZW5ndGgoW3RoaXMudHVybmluZ1BvaW50c1t0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMl0sIHRoaXMudHVybmluZ1BvaW50c1t0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMV1dKTtcclxuICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IFV0aWwuZ2V0QW5nbGUocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IFV0aWwuZGlzdGFuY2UocG9pbnRzWzBdLCBwb2ludHNbMV0pIC0gdGV4dFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1BvaW50ID0gVXRpbC5nZXRFbmRQb2ludChwb2ludHNbMF0sIGxlbmd0aCwgYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgdGV4dFBvc3Rpb24gPSBbbmV3UG9pbnQueCwgbmV3UG9pbnQueV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IHRoaXMubWlkZGxlKHRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5taWRkbGUodGV4dCk7XHJcbiAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW3Bvc2l0aW9uWzBdIC0gdGV4dFdpZHRoIC8gMiwgcG9zaXRpb25bMV1dO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHRQb3N0aW9uO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPlue6v+auteeahOaXi+i9rOinkuW6plxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSB0ZXh0UG9zdGlvbiB7eCx5fVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICDop5LluqblgLxcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5nZXRUZXh0Um90YXRpb24gPSBmdW5jdGlvbih0ZXh0UG9zdGlvbikge1xyXG4gICAgICAgIC8v6K6h566X5Ye65p6B5Z2Q5qCH55qE6KeS5bqmXHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFV0aWwuZ2V0TWF4TGluZUxlbmd0aCh0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgIHZhciBhbmdsZSA9IC1NYXRoLmF0YW4yKHBvaW50c1sxXS55IC0gdGV4dFBvc3Rpb25bMV0sIHBvaW50c1sxXS54IC0gdGV4dFBvc3Rpb25bMF0pOyAvLyxNYXRoLlBJLzJcclxuICAgICAgICByZXR1cm4gYW5nbGU7XHJcbiAgICB9O1xyXG5cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY3JlYXRlSG92ZXJTdHlsZSA9IGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob3ZlclN0eWxlKSB7XHJcbiAgICAgICAgICAgIGdyYXBoaWMuc2V0RWxlbWVudEhvdmVyU3RsKGVsLCB0aGlzLm9wdGlvbnMuaG92ZXJTdHlsZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3ltYm9sVG8gPSB0aGlzLmNoaWxkT2ZOYW1lKCd0b1N5bWJvbCcpO1xyXG4gICAgICAgICAgICBpZiAoc3ltYm9sVG8pIHsgZ3JhcGhpYy5zZXRFbGVtZW50SG92ZXJTdGwoc3ltYm9sVG8sIHRoaXMub3B0aW9ucy5hcnJvd0hvdmVyU3R5bGUpOyB9XHJcblxyXG4gICAgICAgICAgICBlbC5vbignbW91c2VvdmVyJywgenJVdGlsLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5kb0VudGVySG92ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzeW1ib2xUbykgeyBncmFwaGljLmRvRW50ZXJIb3ZlcihzeW1ib2xUbyk7IH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlLmVhY2hDaGlsZChmdW5jdGlvbihsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuZG9FbnRlckhvdmVyKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgenJVdGlsLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5kb0xlYXZlSG92ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzeW1ib2xUbykgeyBncmFwaGljLmRvTGVhdmVIb3ZlcihzeW1ib2xUbyk7IH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuZWFjaENoaWxkKGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5kb0xlYXZlSG92ZXIobGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu6Tm9kZeeahOi/nuaOpeeCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jcmVhdGVBbGxjb25uZWN0aW9uUG9pbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc1JlY3QgPSB0aGlzLnN0YXJ0Tm9kZS5nZXRSZWN0ID8gdGhpcy5zdGFydE5vZGUuZ2V0UmVjdCgpLmJvdW5kaW5nUmVjdCA6IFV0aWwuZ2V0UmVjdCh0aGlzLnN0YXJ0Tm9kZSkuYm91bmRpbmdSZWN0O1xyXG5cclxuICAgICAgICB2YXIgZVJlY3QgPSB0aGlzLmVuZE5vZGUuZ2V0UmVjdCA/IHRoaXMuZW5kTm9kZS5nZXRSZWN0KCkuYm91bmRpbmdSZWN0IDogVXRpbC5nZXRSZWN0KHRoaXMuZW5kTm9kZSkuYm91bmRpbmdSZWN0O1xyXG5cclxuICAgICAgICB2YXIgc0Nvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoc1JlY3QpO1xyXG4gICAgICAgIHZhciBlQ29ubmVjdG9yUG9pbnQgPSBVdGlsLmdldENvbm5lY3RvclBvaW50cyhlUmVjdCk7XHJcblxyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuc3RhcnROb2RlLCBzQ29ubmVjdG9yUG9pbnQubGVmdCwgQ29ubmVjdG9yLlNUQVJUX05PREUgKyBDb25uZWN0b3IuU0VQRVJBVE9SICsgQ29ubmVjdG9yLkxFRlQpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuc3RhcnROb2RlLCBzQ29ubmVjdG9yUG9pbnQucmlnaHQsIENvbm5lY3Rvci5TVEFSVF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5SSUdIVCk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcy5zdGFydE5vZGUsIHNDb25uZWN0b3JQb2ludC50b3AsIENvbm5lY3Rvci5TVEFSVF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5UT1ApO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuc3RhcnROb2RlLCBzQ29ubmVjdG9yUG9pbnQuYm90dG9tLCBDb25uZWN0b3IuU1RBUlRfTk9ERSArIENvbm5lY3Rvci5TRVBFUkFUT1IgKyBDb25uZWN0b3IuQk9UVE9NKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcy5lbmROb2RlLCBlQ29ubmVjdG9yUG9pbnQubGVmdCwgQ29ubmVjdG9yLkVORF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5MRUZUKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLmVuZE5vZGUsIGVDb25uZWN0b3JQb2ludC5yaWdodCwgQ29ubmVjdG9yLkVORF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5SSUdIVCk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcy5lbmROb2RlLCBlQ29ubmVjdG9yUG9pbnQudG9wLCBDb25uZWN0b3IuRU5EX05PREUgKyBDb25uZWN0b3IuU0VQRVJBVE9SICsgQ29ubmVjdG9yLlRPUCk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcy5lbmROb2RlLCBlQ29ubmVjdG9yUG9pbnQuYm90dG9tLCBDb25uZWN0b3IuRU5EX05PREUgKyBDb25uZWN0b3IuU0VQRVJBVE9SICsgQ29ubmVjdG9yLkJPVFRPTSk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLCB0aGlzLnR1cm5pbmdQb2ludHNbMF0uY2xvbmUoKSwgQ29ubmVjdGlvblBvaW50LlRZUEVfQ09OTkVDVE9SKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcywgdGhpcy50dXJuaW5nUG9pbnRzW3RoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxXS5jbG9uZSgpLCBDb25uZWN0aW9uUG9pbnQuVFlQRV9DT05ORUNUT1IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uui/nuaOpeeCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc2hhcGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwb2ludCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHR5cGUgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSA9IGZ1bmN0aW9uKHNoYXBlLCBwb2ludCwgdHlwZSkge1xyXG4gICAgICAgIHZhciBjb25Qb2ludCA9IG5ldyBDb25uZWN0aW9uUG9pbnQodGhpcywgcG9pbnQsIHR5cGUsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cC5hZGQoY29uUG9pbnQuc2hhcGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOa4heepuuaOp+WItueCuVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY2xlYXJIYW5kbGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhhbmRsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhpcy5oYW5kbGVzW2ldLmhhbmRsZVNoYXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oYW5kbGVzID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuY29uUG9pbnRzR3JvdXApIHtcclxuICAgICAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cC5yZW1vdmVBbGwoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu65ouG57q/IOe6v+aWreeahOaOp+WItueCuVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuc2hhcGVTZXRIYW5kbGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAyOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGg7XHJcbiAgICAgICAgICAgIHZhciB4LCB5O1xyXG4gICAgICAgICAgICAvL+aYr+WQpuWcqOS4gOadoee6v+S4ilxyXG4gICAgICAgICAgICB2YXIgaXNDb2xsaW5lYWl0eUZpcnN0ID0gVXRpbC5jb2xsaW5lYXJpdHkodGhpcy50dXJuaW5nUG9pbnRzW2kgLSAxXSwgdGhpcy50dXJuaW5nUG9pbnRzW2ldLCB0aGlzLnR1cm5pbmdQb2ludHNbaSArIDFdKTtcclxuICAgICAgICAgICAgdmFyIGlzQ29sbGluZWFpdHlTZWNvbmQgPSBVdGlsLmNvbGxpbmVhcml0eSh0aGlzLnR1cm5pbmdQb2ludHNbaV0sIHRoaXMudHVybmluZ1BvaW50c1tpICsgMV0sIHRoaXMudHVybmluZ1BvaW50c1tpICsgMl0pO1xyXG4gICAgICAgICAgICBpZiAoKCFpc0NvbGxpbmVhaXR5Rmlyc3QgJiYgKCFpc0NvbGxpbmVhaXR5U2Vjb25kIHx8IHRoaXMudHVybmluZ1BvaW50c1tpICsgMV0uZXF1YWxzKHRoaXMudHVybmluZ1BvaW50c1tpICsgMl0pKSkgfHwgKCghaXNDb2xsaW5lYWl0eUZpcnN0IHx8IHRoaXMudHVybmluZ1BvaW50c1tpIC0gMV0uZXF1YWxzKHRoaXMudHVybmluZ1BvaW50c1tpXSkpICYmICFpc0NvbGxpbmVhaXR5U2Vjb25kKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR1cm5pbmdQb2ludHNbaV0ueCA9PT0gdGhpcy50dXJuaW5nUG9pbnRzW2kgKyAxXS54KSB7IC8vc2FtZSB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgICAgICAgIHggPSB0aGlzLnR1cm5pbmdQb2ludHNbaV0ueDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gKHRoaXMudHVybmluZ1BvaW50c1tpXS55ICsgdGhpcy50dXJuaW5nUG9pbnRzW2kgKyAxXS55KSAvIDI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGggPSBuZXcgSGFuZGxlKCdoJywgeCwgeSwgdGhpcyk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50dXJuaW5nUG9pbnRzW2ldLnkgPT09IHRoaXMudHVybmluZ1BvaW50c1tpICsgMV0ueSkgeyAvLyBzYW1lIGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgICAgICB4ID0gKHRoaXMudHVybmluZ1BvaW50c1tpXS54ICsgdGhpcy50dXJuaW5nUG9pbnRzW2kgKyAxXS54KSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHRoaXMudHVybmluZ1BvaW50c1tpXS55O1xyXG4gICAgICAgICAgICAgICAgICAgIGggPSBuZXcgSGFuZGxlKCd2JywgeCwgeSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKGguaGFuZGxlU2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcy5wdXNoKGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu6566t5aS0XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5hbWUgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBvcHRpb25zIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY3JlYXRlU3ltYm9sID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBzeW1ib2xUeXBlID0gb3B0aW9ucy5zeW1ib2wudHlwZTtcclxuICAgICAgICB2YXIgc3ltYm9sU2l6ZSA9IG9wdGlvbnMuc3ltYm9sLnNpemU7XHJcbiAgICAgICAgaWYgKHN5bWJvbFR5cGUgPT09ICdub25lJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHN5bWJvbFNpemUpKSB7XHJcbiAgICAgICAgICAgIHN5bWJvbFNpemUgPSBbc3ltYm9sU2l6ZSwgc3ltYm9sU2l6ZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc3ltYm9sWkluZGV4ID0gb3B0aW9ucy56O1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zeW1ib2wueikgeyBzeW1ib2xaSW5kZXggPSBvcHRpb25zLnN5bWJvbC56IH07XHJcblxyXG4gICAgICAgIHZhciBzeW1ib2xQYXRoID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2woXHJcbiAgICAgICAgICAgIHN5bWJvbFR5cGUsIC1zeW1ib2xTaXplWzBdIC8gMiwgLXN5bWJvbFNpemVbMV0gLyAyLFxyXG4gICAgICAgICAgICBzeW1ib2xTaXplWzBdLCBzeW1ib2xTaXplWzFdLCBvcHRpb25zLnN5bWJvbC5jb2xvciwgc3ltYm9sWkluZGV4XHJcbiAgICAgICAgKTtcclxuICAgICAgICBzeW1ib2xQYXRoLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgICAgICByZXR1cm4gc3ltYm9sUGF0aDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnu5jliLbnur/mrrXkuIrnmoTmlofmnKxcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gY29udGVudCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5hbWUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSB4ICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0geSAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGNvbG9yICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5kcmF3VGV4dCA9IGZ1bmN0aW9uKG5hbWUsIGNvbnRlbnQsIHgsIHksIGNvbG9yKSB7XHJcbiAgICAgICAgdmFyIHRleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IGNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgICAgeTogeSxcclxuICAgICAgICAgICAgICAgIGZpbGw6IGNvbG9yID8gY29sb3IgOiB0aGlzLm9wdGlvbnMudGV4dC5jb2xvcixcclxuICAgICAgICAgICAgICAgIHRleHRGb250OiB0aGlzLm9wdGlvbnMudGV4dC50ZXh0Rm9udFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6bGV2ZWw6IDIwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGV4dC5uYW1lID0gbmFtZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICAgICAgICByZWN0OiB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bnur/mrrXnmoTkuK3pl7TlgLxcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gdGV4dFxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLm1pZGRsZSA9IGZ1bmN0aW9uKHRleHQpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9TVFJBSUdIVCkge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gVXRpbC5nZXRNYXhMaW5lTGVuZ3RoKHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgICAgIC8v5aaC5p6c5piv5rGC57q/5q615LiK55qE5paH5a2X55qE5Lit6Ze05YC8XHJcbiAgICAgICAgICAgIC8vIGlmKHRleHQpIHtcclxuICAgICAgICAgICAgLy8gICAgIC8v5Y+W5Ye65a2X55qE6ZW/5bqm77yM6K6h566X6KeS5bqm77yMXHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgdGV4dFdpZHRoID0gZ3JhcGhpYy50ZXh0Q29udGFpbi5nZXRXaWR0aCh0ZXh0LnRleHQsIHRleHQudGV4dEZvbnQpO1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIGFuZ2xlID0gVXRpbC5nZXRBbmdsZShwb2ludHNbMF0scG9pbnRzWzFdKTtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBsZW5ndGggPSAgVXRpbC5kaXN0YW5jZShwb2ludHNbMF0scG9pbnRzWzFdKS8yIC0gdGV4dFdpZHRoLzI7XHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgbmV3UG9pbnQgPSBVdGlsLmdldEVuZFBvaW50KHBvaW50c1swXSwgbGVuZ3RoLCBhbmdsZSk7XHJcbiAgICAgICAgICAgIC8vICAgICByZXR1cm4gW25ld1BvaW50LngsIG5ld1BvaW50LnldO1xyXG4gICAgICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIG1pZGRsZVggPSAocG9pbnRzWzBdLnggKyBwb2ludHNbMV0ueCkvMjtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBtaWRkbGVZID0gKHBvaW50c1swXS55ICsgcG9pbnRzWzFdLnkpIC8yO1xyXG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuIFttaWRkbGVYLCBtaWRkbGVZXTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICB2YXIgbWlkZGxlWCA9IChwb2ludHNbMF0ueCArIHBvaW50c1sxXS54KSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBtaWRkbGVZID0gKHBvaW50c1swXS55ICsgcG9pbnRzWzFdLnkpIC8gMjtcclxuICAgICAgICAgICAgcmV0dXJuIFttaWRkbGVYLCBtaWRkbGVZXTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9KQUdHRUQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vZmluZCB0b3RhbCBkaXN0YW5jZVxyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLmdldExlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgLy9maW5kIGJldHdlZW4gd2hhdCB0dXJuaW5nIHBvaW50cyB0aGUgaGFsZiBkaXN0YW5jZSBpc1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcclxuICAgICAgICAgICAgdmFyIGVsbGFwc2VkRGlzdGFuY2UgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gVXRpbC5nZXRMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzW2ldLCB0aGlzLnR1cm5pbmdQb2ludHNbaSArIDFdKTtcclxuICAgICAgICAgICAgICAgIGlmIChlbGxhcHNlZERpc3RhbmNlICsgc2VnbWVudCA8IGRpc3RhbmNlIC8gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsbGFwc2VkRGlzdGFuY2UgKz0gc2VnbWVudDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vd2UgaGF2ZSB0aGUgbWlkZGxlIGRpc3RhbmNlIHNvbWV3aGVyZSBiZXR3ZWVuIGkobmRleCkgYW5kIGkobmRleCkrMVxyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtaXNzaW5nRGlzdGFuY2UgPSBkaXN0YW5jZSAvIDIgLSBlbGxhcHNlZERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKFV0aWwucm91bmQodGhpcy50dXJuaW5nUG9pbnRzW2luZGV4XS54LCAzKSA9PSBVdGlsLnJvdW5kKHRoaXMudHVybmluZ1BvaW50c1tpbmRleCArIDFdLngsIDMpKSB7IC8vdmVydGljYWwgc2VnbWVudCAoc2FtZSB4KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4XS54LCBNYXRoLm1pbih0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLnksIHRoaXMudHVybmluZ1BvaW50c1tpbmRleCArIDFdLnkpICsgbWlzc2luZ0Rpc3RhbmNlXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbC5yb3VuZCh0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLnksIDMpID09IFV0aWwucm91bmQodGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueSwgMykpIHsgLy9ob3Jpem9udGFsIHNlZ21lbnQgKHNhbWUgeSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW01hdGgubWluKHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueCwgdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueCkgKyBtaXNzaW5nRGlzdGFuY2UsIHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb25uZWN0b3I6bWlkZGxlKCkgLSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4gXCIgKyB0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdICsgXCIgXCIgKyB0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXggKyAxXSArIFwiIG5yIG9mIHBvaW50cyBcIiArIHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gMC41O1xyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgd2Fsa2VkID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2Fsa2VkICsgVXRpbC5kaXN0YW5jZSh0aGlzLnR1cm5pbmdQb2ludHNbal0sIHRoaXMudHVybmluZ1BvaW50c1tqICsgMV0pID4gbCAqIHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB3YWxrZWQgKz0gVXRpbC5kaXN0YW5jZSh0aGlzLnR1cm5pbmdQb2ludHNbal0sIHRoaXMudHVybmluZ1BvaW50c1tqICsgMV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdCA9IGwgKiB0IC0gd2Fsa2VkO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFNlZ21lbnRMZW5ndGggPSBVdGlsLmRpc3RhbmNlKHRoaXMudHVybmluZ1BvaW50c1tqXSwgdGhpcy50dXJuaW5nUG9pbnRzW2ogKyAxXSk7XHJcblxyXG4gICAgICAgICAgICAvL2ZpbmQgdGhlIHBvc2l0aW9uL3JhdGlvbiBvZiB0aGUgbWlkZGxlIG9mIFBvbHlsaW5lIG9uIGN1cnJlbnQgc2VnbWVudFxyXG4gICAgICAgICAgICB2YXIgc2VnbWVudFBlcmNlbnQgPSByZXN0IC8gY3VycmVudFNlZ21lbnRMZW5ndGg7XHJcblxyXG4gICAgICAgICAgICB2YXIgWHAgPSBzZWdtZW50UGVyY2VudCAqICh0aGlzLnR1cm5pbmdQb2ludHNbaiArIDFdLnggLSB0aGlzLnR1cm5pbmdQb2ludHNbal0ueCkgKyB0aGlzLnR1cm5pbmdQb2ludHNbal0ueDtcclxuICAgICAgICAgICAgdmFyIFlwID0gc2VnbWVudFBlcmNlbnQgKiAodGhpcy50dXJuaW5nUG9pbnRzW2ogKyAxXS55IC0gdGhpcy50dXJuaW5nUG9pbnRzW2pdLnkpICsgdGhpcy50dXJuaW5nUG9pbnRzW2pdLnk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW1hwLCBZcF07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZmluZCB0b3RhbCBkaXN0YW5jZVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy9maW5kIHRvdGFsIGRpc3RhbmNlXHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gVXRpbC5nZXRMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzW2ldLCB0aGlzLnR1cm5pbmdQb2ludHNbaSArIDFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOi9rEpTT07lr7nosaFcclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInJlc291cmNlSWRcIiwgdGhpcy5yZXNvdXJjZUlkKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInByb3BlcnRpZXMudHlwZVwiLCAxNCk7XHJcblxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLnVwcGVyTGVmdC54XCIsIHRoaXMucG9zaXRpb25bMF0pO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLnVwcGVyTGVmdC55XCIsIHRoaXMucG9zaXRpb25bMV0pO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLmxvd2VyUmlnaHQueFwiLCBwYXJzZUludCh0aGlzLnBvc2l0aW9uWzBdICsgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCkpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwiYm91bmRzLmxvd2VyUmlnaHQueVwiLCBwYXJzZUludCh0aGlzLnBvc2l0aW9uWzFdICsgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQpKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0eWxlLnNQb3NcIiwgdGhpcy5zUG9zKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcInN0eWxlLmVQb3NcIiwgdGhpcy5lUG9zKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImRvY2tlcnNcIiwgdGhpcy50dXJuaW5nUG9pbnRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5vcHRpb247XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVmcmVzaE1vZGVsXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZWZyZXNoTW9kZWwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuZG9ja2Vyc1wiLCB0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgIHZhciBpY29ucyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pY29ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgaWNvbk5vZGUgPSB0aGlzLmljb25zW2ldO1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gW2ljb25Ob2RlLmtleSwge1xyXG4gICAgICAgICAgICAgICAgaWNvbjogaWNvbk5vZGUuc3R5bGUuaW1hZ2UsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogaWNvbk5vZGUuc3R5bGUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGljb25Ob2RlLnN0eWxlLmhlaWdodFxyXG4gICAgICAgICAgICB9XTtcclxuICAgICAgICAgICAgaWNvbnMucHVzaChvcHRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImljb25zXCIsIGljb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDosIPmlbTmm7Lnur/nmoTlvaLnirZcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBwb2ludHMg54K55pWw57uEXHJcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLm1vZGlmeUN1cnZlID0gZnVuY3Rpb24ocG9pbnRzKSB7XHJcbiAgICAgICAgdmFyIHNvbCA9IHRoaXMuZ2V0Q3VydmVQb2ludChwb2ludHMpO1xyXG5cclxuICAgICAgICAvLyAxLiDlpoLmnpzmm7Lnur/nmoTmlbDph48g5q+U5pWw6YeP55qE5Lit5pWw6YeP6KaB5bCRIOWImeWIoOmZpOWkmuS9meeahOe6v+autVxyXG4gICAgICAgIHZhciB3aWxsRGVsQ3VydmVzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IHNvbC5sZW5ndGgsIGNudEN1cnZlID0gdGhpcy5ncm91cEN1cnZlLmNoaWxkQ291bnQoKTsgaiA8IGNudEN1cnZlOyBqKyspIHtcclxuICAgICAgICAgICAgd2lsbERlbEN1cnZlcy5wdXNoKHRoaXMuZ3JvdXBDdXJ2ZS5jaGlsZEF0KGopKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgenJVdGlsLmVhY2god2lsbERlbEN1cnZlcywgZnVuY3Rpb24oY3VydmUpIHtcclxuICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlLnJlbW92ZShjdXJ2ZSk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgLy8gMi4g6YGN5Y6G5puy57q/ICAg5aaC5p6c5a2Y5Zyo5YiZ55u05o6l6K6+572u5b2i54q277yM5ZCm5YiZ5Yib5bu6XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb2wubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdyb3VwQ3VydmUuY2hpbGRBdChpKTtcclxuICAgICAgICAgICAgaWYgKGxpbmUpIHtcclxuICAgICAgICAgICAgICAgIGxpbmUuYXR0cignc2hhcGUnLCBzb2xbaV0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cmUgPSBuZXcgZ3JhcGhpYy5CZXppZXJDdXJ2ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogdGhpcy5vcHRpb25zLnN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiBzb2xbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgejogdGhpcy5vcHRpb25zLnpcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlLmFkZChjdXJlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlSG92ZXJTdHlsZShjdXJlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5qC55o2u5Lyg5YWl55qE54K55pWw57uE6K6h566X5puy57q/55qE54K5XHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gUCDngrnmlbDnu4RcclxuICAgICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgIOabsue6v+eahOeCueaVsOe7hFxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmdldEN1cnZlUG9pbnQgPSBmdW5jdGlvbihQKSB7XHJcbiAgICAgICAgdmFyIG4gPSBQLmxlbmd0aDtcclxuICAgICAgICB2YXIgc29sID0gW107XHJcbiAgICAgICAgaWYgKG4gPT09IDMpIHtcclxuICAgICAgICAgICAgc29sLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgeDE6IFBbMF0ueCxcclxuICAgICAgICAgICAgICAgIHkxOiBQWzBdLnksXHJcbiAgICAgICAgICAgICAgICBjcHgxOiBQWzFdLngsXHJcbiAgICAgICAgICAgICAgICBjcHkxOiBQWzFdLnksXHJcbiAgICAgICAgICAgICAgICB4MjogUFsyXS54LFxyXG4gICAgICAgICAgICAgICAgeTI6IFBbMl0ueVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHNvbDtcclxuICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDQpIHtcclxuICAgICAgICAgICAgc29sLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgeDE6IFBbMF0ueCxcclxuICAgICAgICAgICAgICAgIHkxOiBQWzBdLnksXHJcbiAgICAgICAgICAgICAgICBjcHgxOiBQWzFdLngsXHJcbiAgICAgICAgICAgICAgICBjcHkxOiBQWzFdLnksXHJcbiAgICAgICAgICAgICAgICBjcHgyOiBQWzJdLngsXHJcbiAgICAgICAgICAgICAgICBjcHkyOiBQWzJdLnksXHJcbiAgICAgICAgICAgICAgICB4MjogUFszXS54LFxyXG4gICAgICAgICAgICAgICAgeTI6IFBbM10ueVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHNvbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKkNvbXB1dGVzIGZhY3RvcmlhbFxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrIHRoZSBudW1iZXJcclxuICAgICAgICAgKiAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGZhY3Qoaykge1xyXG4gICAgICAgICAgICBpZiAoayA9PT0gMCB8fCBrID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrICogZmFjdChrIC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKkNvbXB1dGVzIEJlcm5zdGFpbiovXHJcbiAgICAgICAgZnVuY3Rpb24gQihpLCBuLCB1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWN0KG4pIC8gKGZhY3QoaSkgKiBmYWN0KG4gLSBpKSkgKiBNYXRoLnBvdyh1LCBpKSAqIE1hdGgucG93KDEgLSB1LCBuIC0gaSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipDb21wdXRlcyB0aGUgc3VtIGJldHdlZW4gdHdvIHBvaW50XHJcbiAgICAgICAgICpAcGFyYW0gcDEgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcGFyYW0gcDIgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcmV0dXJuIHtQb2ludH0gdGhlIHN1bSBvZiBpbml0aWFsIHBvaW50c1xyXG4gICAgICAgICAqKi9cclxuICAgICAgICBmdW5jdGlvbiBzdW0ocDEsIHAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocDEueCArIHAyLngsIHAxLnkgKyBwMi55KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKkNvbXB1dGVzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gZmlyc3Qge1BvaW50fSBhbmQgc2Vjb25kIHtQb2ludH1cclxuICAgICAgICAgKkBwYXJhbSBwMSAtIHtQb2ludH1cclxuICAgICAgICAgKkBwYXJhbSBwMiAtIHtQb2ludH1cclxuICAgICAgICAgKkByZXR1cm4ge1BvaW50fSB0aGUgc3VtIG9mIGluaXRpYWwgcG9pbnRzXHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGZ1bmN0aW9uIG1pbnVzKHAxLCBwMikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHAxLnggLSBwMi54LCBwMS55IC0gcDIueSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipDb21wdXRlcyB0aGUgZGl2aXNpb24gb2YgYSB7UG9pbnR9IGJ5IGEgbnVtYmVyXHJcbiAgICAgICAgICpAcGFyYW0gcCAtIHtQb2ludH1cclxuICAgICAgICAgKkBwYXJhbSBuciAtIHtOdW1iZXJ9XHJcbiAgICAgICAgICpAcmV0dXJuIHtQb2ludH1cclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZnVuY3Rpb24gZGl2aWRlKHAsIG5yKSB7XHJcbiAgICAgICAgICAgIGlmIChuciA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkRpdmlzaW9uIGJ5IHplcm8gbm90IGFsbG93ZWQgKHlldCA6KSBcIiArIHRoaXMuY2FsbGVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocC54IC8gbnIsIHAueSAvIG5yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKkNvbXB1dGVzIHRoZSBtdWx0aXBsaWNhdGlvbiBvZiBhIHtQb2ludH0gYnkgYSBudW1iZXJcclxuICAgICAgICAgKkBwYXJhbSBwIC0ge1BvaW50fVxyXG4gICAgICAgICAqQHBhcmFtIG5yIC0ge051bWJlcn1cclxuICAgICAgICAgKkByZXR1cm4ge1BvaW50fVxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBmdW5jdGlvbiBtdWx0aXBseShwLCBucikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHAueCAqIG5yLCBwLnkgKiBucik7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqSSBkbyBub3QgZ2V0IHdoeSBmaXJzdCA0IG11c3QgYmUgMCBhbmQgbGFzdCAzIG9mIHNhbWUgdmFsdWUuLi4uLlxyXG4gICAgICAgICAqYnV0IG90aGVyd2lzZSB3ZSB3aWxsIGdldCBkaXZpc2lvbiBieSB6ZXJvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGsgPSBbMCwgMCwgMF07XHJcblxyXG4gICAgICAgIHZhciBqO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPD0gbiAtIDM7IGorKykge1xyXG4gICAgICAgICAgICBrLnB1c2goaik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBrLnB1c2gobiAtIDMsIG4gLSAzKTtcclxuXHJcblxyXG5cclxuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG4gLSAzOyBpKyspIHtcclxuICAgICAgICAgICAgLy9xMSAtIGNvbXB1dGUgc3RhcnQgcG9pbnRcclxuICAgICAgICAgICAgdmFyIHExID0gZGl2aWRlKHN1bShtdWx0aXBseShQW2ldLCBrW2kgKyA0XSAtIGtbaSArIDJdKSwgbXVsdGlwbHkoUFtpICsgMV0sIGtbaSArIDJdIC0ga1tpICsgMV0pKSwga1tpICsgNF0gLSBrW2kgKyAxXSk7XHJcblxyXG4gICAgICAgICAgICAvL3EwIC0gY29tcHV0ZSAxc3QgY29udHJvbGwgcG9pbnRcclxuICAgICAgICAgICAgdmFyIHFfMDEgPSAoa1tpICsgM10gLSBrW2kgKyAyXSkgLyAoa1tpICsgM10gLSBrW2kgKyAxXSk7XHJcbiAgICAgICAgICAgIHZhciBxXzAyID0gZGl2aWRlKHN1bShtdWx0aXBseShQW2kgLSAxXSwga1tpICsgM10gLSBrW2kgKyAyXSksIG11bHRpcGx5KFBbaV0sIGtbaSArIDJdIC0ga1tpXSkpLCBrW2kgKyAzXSAtIGtbaV0pO1xyXG4gICAgICAgICAgICB2YXIgcV8wMyA9IG11bHRpcGx5KHExLCAoa1tpICsgMl0gLSBrW2kgKyAxXSkgLyAoa1tpICsgM10gLSBrW2kgKyAxXSkpO1xyXG4gICAgICAgICAgICB2YXIgcTAgPSBzdW0obXVsdGlwbHkocV8wMiwgcV8wMSksIHFfMDMpO1xyXG5cclxuICAgICAgICAgICAgLy9xMiAtIGNvbXB1dGUgMm5kIGNvbnRyb2xsIHBvaW50XHJcbiAgICAgICAgICAgIHZhciBxMiA9IGRpdmlkZShzdW0obXVsdGlwbHkoUFtpXSwga1tpICsgNF0gLSBrW2kgKyAzXSksIG11bHRpcGx5KFBbaSArIDFdLCBrW2kgKyAzXSAtIGtbaSArIDFdKSksIGtbaSArIDRdIC0ga1tpICsgMV0pO1xyXG5cclxuICAgICAgICAgICAgLy9xMyAtIGNvbXB1dGUgZW5kIHBvaW50XHJcbiAgICAgICAgICAgIHZhciBxXzMxID0gKGtbaSArIDNdIC0ga1tpICsgMl0pIC8gKGtbaSArIDRdIC0ga1tpICsgMl0pO1xyXG4gICAgICAgICAgICB2YXIgcV8zMiA9IGRpdmlkZShzdW0obXVsdGlwbHkoUFtpICsgMV0sIGtbaSArIDVdIC0ga1tpICsgM10pLCBtdWx0aXBseShQW2kgKyAyXSwga1tpICsgM10gLSBrW2kgKyAyXSkpLCBrW2kgKyA1XSAtIGtbaSArIDJdKTtcclxuICAgICAgICAgICAgdmFyIHFfMzMgPSBtdWx0aXBseShxMiwgKGtbaSArIDRdIC0ga1tpICsgM10pIC8gKGtbaSArIDRdIC0ga1tpICsgMl0pKTtcclxuICAgICAgICAgICAgdmFyIHEzID0gc3VtKG11bHRpcGx5KHFfMzIsIHFfMzEpLCBxXzMzKTtcclxuXHJcbiAgICAgICAgICAgIC8vc3RvcmUgc29sdXRpb25cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgc29sLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgeDE6IHEwLngsXHJcbiAgICAgICAgICAgICAgICB5MTogcTAueSxcclxuICAgICAgICAgICAgICAgIGNweDE6IHExLngsXHJcbiAgICAgICAgICAgICAgICBjcHkxOiBxMS55LFxyXG4gICAgICAgICAgICAgICAgY3B4MjogcTIueCxcclxuICAgICAgICAgICAgICAgIGNweTI6IHEyLnksXHJcbiAgICAgICAgICAgICAgICB4MjogcTMueCxcclxuICAgICAgICAgICAgICAgIHkyOiBxMy55XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNvbDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFV0aWwuaW5oZXJpdHMoQ29ubmVjdG9yLCBOb2RlKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbm5lY3RvcjtcclxuXHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIFN5bWJvbCBmYWN0b3J5XHJcblxyXG5cclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vZ3JhcGhpYycpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XHJcbiAgICAvKipcclxuICAgICAqIFRyaWFuZ2xlIHNoYXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRyaWFuZ2xlID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcbiAgICAgICAgdHlwZTogJ3RyaWFuZ2xlJyxcclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBjeCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgY3kgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcclxuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIERpYW1vbmQgc2hhcGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgRGlhbW9uZCA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xyXG4gICAgICAgIHR5cGU6ICdkaWFtb25kJyxcclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBjeDogMCxcclxuICAgICAgICAgICAgY3k6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBjeCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgY3kgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgcGF0aC5tb3ZlVG8oY3gsIGN5IC0gaGVpZ2h0KTtcclxuICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCwgY3kgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCAtIHdpZHRoLCBjeSk7XHJcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQaW4gc2hhcGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgUGluID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcbiAgICAgICAgdHlwZTogJ3BpbicsXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgLy8geCwgeSBvbiB0aGUgY3VzcFxyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XHJcbiAgICAgICAgICAgIHZhciB3ID0gc2hhcGUud2lkdGggLyA1ICogMztcclxuICAgICAgICAgICAgLy8gSGVpZ2h0IG11c3QgYmUgbGFyZ2VyIHRoYW4gd2lkdGhcclxuICAgICAgICAgICAgdmFyIGggPSBNYXRoLm1heCh3LCBzaGFwZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICB2YXIgciA9IHcgLyAyO1xyXG5cclxuICAgICAgICAgICAgLy8gRGlzdCBvbiB5IHdpdGggdGFuZ2VudCBwb2ludCBhbmQgY2lyY2xlIGNlbnRlclxyXG4gICAgICAgICAgICB2YXIgZHkgPSByICogciAvIChoIC0gcik7XHJcbiAgICAgICAgICAgIHZhciBjeSA9IHkgLSBoICsgciArIGR5O1xyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmFzaW4oZHkgLyByKTtcclxuICAgICAgICAgICAgLy8gRGlzdCBvbiB4IHdpdGggdGFuZ2VudCBwb2ludCBhbmQgY2lyY2xlIGNlbnRlclxyXG4gICAgICAgICAgICB2YXIgZHggPSBNYXRoLmNvcyhhbmdsZSkgKiByO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRhblggPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgICAgIHZhciB0YW5ZID0gTWF0aC5jb3MoYW5nbGUpO1xyXG5cclxuICAgICAgICAgICAgcGF0aC5hcmMoXHJcbiAgICAgICAgICAgICAgICB4LCBjeSwgcixcclxuICAgICAgICAgICAgICAgIE1hdGguUEkgLSBhbmdsZSxcclxuICAgICAgICAgICAgICAgIE1hdGguUEkgKiAyICsgYW5nbGVcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjcExlbiA9IHIgKiAwLjY7XHJcbiAgICAgICAgICAgIHZhciBjcExlbjIgPSByICogMC43O1xyXG4gICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXHJcbiAgICAgICAgICAgICAgICB4ICsgZHggLSB0YW5YICogY3BMZW4sIGN5ICsgZHkgKyB0YW5ZICogY3BMZW4sXHJcbiAgICAgICAgICAgICAgICB4LCB5IC0gY3BMZW4yLFxyXG4gICAgICAgICAgICAgICAgeCwgeVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oXHJcbiAgICAgICAgICAgICAgICB4LCB5IC0gY3BMZW4yLFxyXG4gICAgICAgICAgICAgICAgeCAtIGR4ICsgdGFuWCAqIGNwTGVuLCBjeSArIGR5ICsgdGFuWSAqIGNwTGVuLFxyXG4gICAgICAgICAgICAgICAgeCAtIGR4LCBjeSArIGR5XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJvdyBzaGFwZVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBBcnJvdyA9IGdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xyXG5cclxuICAgICAgICB0eXBlOiAnYXJyb3cnLFxyXG5cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XHJcbiAgICAgICAgICAgIHZhciBkeCA9IHdpZHRoIC8gMyAqIDI7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGR4LCB5ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgaGVpZ2h0IC8gNCAqIDMpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHggLSBkeCwgeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBvZiBwYXRoIGNvbnRydWN0b3JzXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aD59XHJcbiAgICAgKi9cclxuICAgIHZhciBzeW1ib2xDdG9ycyA9IHtcclxuICAgICAgICBsaW5lOiBncmFwaGljLkxpbmUsXHJcblxyXG4gICAgICAgIHJlY3Q6IGdyYXBoaWMuUmVjdCxcclxuXHJcbiAgICAgICAgcm91bmRSZWN0OiBncmFwaGljLlJlY3QsXHJcblxyXG4gICAgICAgIHNxdWFyZTogZ3JhcGhpYy5SZWN0LFxyXG5cclxuICAgICAgICBjaXJjbGU6IGdyYXBoaWMuQ2lyY2xlLFxyXG5cclxuICAgICAgICBkaWFtb25kOiBEaWFtb25kLFxyXG5cclxuICAgICAgICBwaW46IFBpbixcclxuXHJcbiAgICAgICAgYXJyb3c6IEFycm93LFxyXG5cclxuICAgICAgICB0cmlhbmdsZTogVHJpYW5nbGVcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHN5bWJvbFNoYXBlTWFrZXJzID0ge1xyXG5cclxuICAgICAgICBsaW5lOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgLy8gRklYTUVcclxuICAgICAgICAgICAgc2hhcGUueDEgPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55MSA9IHkgKyBoIC8gMjtcclxuICAgICAgICAgICAgc2hhcGUueDIgPSB4ICsgdztcclxuICAgICAgICAgICAgc2hhcGUueTIgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geTtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJvdW5kUmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geTtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgICAgICBzaGFwZS5yID0gTWF0aC5taW4odywgaCkgLyA0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNxdWFyZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4odywgaCk7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4O1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geTtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSBzaXplO1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBzaXplO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNpcmNsZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIC8vIFB1dCBjaXJjbGUgaW4gdGhlIGNlbnRlciBvZiBzcXVhcmVcclxuICAgICAgICAgICAgc2hhcGUuY3ggPSB4ICsgdyAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLmN5ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS5yID0gTWF0aC5taW4odywgaCkgLyAyO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRpYW1vbmQ6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcclxuICAgICAgICAgICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwaW46IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS54ID0geCArIHcgLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYXJyb3c6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS54ID0geCArIHcgLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS55ID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdHJpYW5nbGU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcclxuICAgICAgICAgICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBzeW1ib2xCdWlsZFByb3hpZXMgPSB7fTtcclxuICAgIGZvciAodmFyIG5hbWUgaW4gc3ltYm9sQ3RvcnMpIHtcclxuICAgICAgICBzeW1ib2xCdWlsZFByb3hpZXNbbmFtZV0gPSBuZXcgc3ltYm9sQ3RvcnNbbmFtZV0oKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgU3ltYm9sID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdzeW1ib2wnLFxyXG5cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBzeW1ib2xUeXBlOiAnJyxcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJlZm9yZUJydXNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIC8vIEZJWE1FXHJcbiAgICAgICAgICAgIGlmIChzaGFwZS5zeW1ib2xUeXBlID09PSAncGluJyAmJiBzdHlsZS50ZXh0UG9zaXRpb24gPT09ICdpbnNpZGUnKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0UG9zaXRpb24gPSBbJzUwJScsICc0MCUnXTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbFR5cGUgPSBzaGFwZS5zeW1ib2xUeXBlO1xyXG4gICAgICAgICAgICB2YXIgcHJveHlTeW1ib2wgPSBzeW1ib2xCdWlsZFByb3hpZXNbc3ltYm9sVHlwZV07XHJcbiAgICAgICAgICAgIGlmIChzaGFwZS5zeW1ib2xUeXBlICE9PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJveHlTeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHJlY3RcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2xUeXBlID0gJ3JlY3QnO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3h5U3ltYm9sID0gc3ltYm9sQnVpbGRQcm94aWVzW3N5bWJvbFR5cGVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sU2hhcGVNYWtlcnNbc3ltYm9sVHlwZV0oXHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUueCwgc2hhcGUueSwgc2hhcGUud2lkdGgsIHNoYXBlLmhlaWdodCwgcHJveHlTeW1ib2wuc2hhcGVcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBwcm94eVN5bWJvbC5idWlsZFBhdGgoY3R4LCBwcm94eVN5bWJvbC5zaGFwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBQcm92aWRlIHNldENvbG9yIGhlbHBlciBtZXRob2QgdG8gYXZvaWQgZGV0ZXJtaW5lIGlmIHNldCB0aGUgZmlsbCBvciBzdHJva2Ugb3V0c2lkZVxyXG4gICAgdmFyIHN5bWJvbFBhdGhTZXRDb2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdpbWFnZScpIHtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbFN0eWxlID0gdGhpcy5zdHlsZTtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbFNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgaWYgKHN5bWJvbFNoYXBlICYmIHN5bWJvbFNoYXBlLnN5bWJvbFR5cGUgPT09ICdsaW5lJykge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fX2lzRW1wdHlCcnVzaCkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3I7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5maWxsID0gJyNmZmYnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRklYTUUg5Yik5pat5Zu+5b2i6buY6K6k5piv5aGr5YWF6L+Y5piv5o+P6L6577yM5L2/55SoIG9ubHlTdHJva2UgP1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuZmlsbCAmJiAoc3ltYm9sU3R5bGUuZmlsbCA9IGNvbG9yKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLnN0cm9rZSAmJiAoc3ltYm9sU3R5bGUuc3Ryb2tlID0gY29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBzeW1ib2xVdGlsID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZSBhIHN5bWJvbCBlbGVtZW50IHdpdGggZ2l2ZW4gc3ltYm9sIGNvbmZpZ3VyYXRpb246IHNoYXBlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2xUeXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3XHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gelxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNyZWF0ZVN5bWJvbDogZnVuY3Rpb24gKHN5bWJvbFR5cGUsIHgsIHksIHcsIGgsIGNvbG9yLCB6KSB7XHJcbiAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gc3ltYm9sVHlwZS5pbmRleE9mKCdlbXB0eScpID09PSAwO1xyXG4gICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sVHlwZSA9IHN5bWJvbFR5cGUuc3Vic3RyKDUsIDEpLnRvTG93ZXJDYXNlKCkgKyBzeW1ib2xUeXBlLnN1YnN0cig2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3ltYm9sUGF0aDtcclxuXHJcbiAgICAgICAgICAgIGlmIChzeW1ib2xUeXBlLmluZGV4T2YoJ2ltYWdlOi8vJykgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFBhdGggPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHN5bWJvbFR5cGUuc2xpY2UoOCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHo6IHpcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN5bWJvbFR5cGUuaW5kZXhPZigncGF0aDovLycpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xQYXRoID0gZ3JhcGhpYy5tYWtlUGF0aChzeW1ib2xUeXBlLnNsaWNlKDcpLCB7ejogen0sIG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgdywgaCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sUGF0aCA9IG5ldyBTeW1ib2woe1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbFR5cGU6IHN5bWJvbFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHo6IHpcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzeW1ib2xQYXRoLl9faXNFbXB0eUJydXNoID0gaXNFbXB0eTtcclxuXHJcbiAgICAgICAgICAgIHN5bWJvbFBhdGguc2V0Q29sb3IgPSBzeW1ib2xQYXRoU2V0Q29sb3I7XHJcblxyXG4gICAgICAgICAgICBzeW1ib2xQYXRoLnNldENvbG9yKGNvbG9yKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xQYXRoO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzeW1ib2xVdGlsO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL1N5bWJvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog55S75Y+l5p+EXHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XHJcbiAgICBmdW5jdGlvbiBIYW5kbGUodHlwZSwgeCwgeSwgY29ubmVjdG9yKXtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG5cclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcclxuXHJcbiAgICAgICAgdGhpcy5oYW5kbGVTaGFwZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogeCxcclxuICAgICAgICAgICAgICAgIGN5OiB5LFxyXG4gICAgICAgICAgICAgICAgcjogSGFuZGxlLlJBRElVU1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IFwicmdiKDAsMjU1LDApXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6XCJyZ2IoMCwwLDApXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgeiA6IGNvbm5lY3Rvci5vcHRpb25zLnogKyAyLCAgLy/oioLngrla5Li6MSDnur/mrrXkuLowO1xyXG4gICAgICAgICAgICBkcmFnZ2FibGU6dHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVTaGFwZS5vbihcImRyYWdcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB0aGF0LmFjdGlvbkNvbm5lY3RvcihlLm9mZnNldFgsZS5vZmZzZXRZKTtcclxuICAgICAgICB9KTtcclxuICAgICAgIC8vIHJldHVybiB0aGlzLmNpcmNsZTtcclxuICAgIH1cclxuXHJcbiAgICBIYW5kbGUuUkFESVVTID0gNDtcclxuXHJcbiAgICBIYW5kbGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvciA6IEhhbmRsZSxcclxuXHJcbiAgICAgICAgZXF1YWxzIDogZnVuY3Rpb24oYW5vdGhlckhhbmRsZSl7XHJcbiAgICAgICAgICAgIGlmKCFhbm90aGVySGFuZGxlIGluc3RhbmNlb2YgSGFuZGxlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBhbm90aGVySGFuZGxlLnR5cGVcclxuICAgICAgICAgICAgJiYgdGhpcy54ID09IGFub3RoZXJIYW5kbGUueFxyXG4gICAgICAgICAgICAmJiB0aGlzLnkgPT0gYW5vdGhlckhhbmRsZS55XHJcbiAgICAgICAgICAgICYmIHRoaXMudmlzaWJsZSA9PSBhbm90aGVySGFuZGxlLnZpc2libGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog56e75Yqo5Y+l5p+EXHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBuZXdYIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5ld1kgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWN0aW9uQ29ubmVjdG9yOiBmdW5jdGlvbihuZXdYLCBuZXdZKXtcclxuICAgICAgICAgICAgc3dpdGNoKHRoaXMudHlwZSl7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd2JzpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5om+5Ye65Lik5Liq6L2s5oqY54K577yI5Y+v56e75Yqo5Y+l5p+E5Zyo6L+Z5Lik5Liq6L2s5oqY54K55Lit6Ze077yJXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHMubGVuZ3RoLTE7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS55ID09IHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS55ID09IHRoaXMueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5taW4odGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS54LCB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueCkgPD0gdGhpcy54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLm1heCh0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLngsIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS54KSA+PSB0aGlzLngpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFZID0gbmV3WSAtIHRoaXMueTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRpb25NYXRyaXggPSBVdGlsLnRyYW5zbGF0aW9uTWF0cml4KDAsIGRlbHRhWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaW5kZXgtMV0udHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2luZGV4XS50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSBuZXdZOyAgLy/lsIblj6Xmn4TmlrDnmoTkvY3nva7otYvlgLznu5l5XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmib7lh7rkuKTkuKrovazmipjngrnvvIjlj6/np7vliqjlj6Xmn4TlnKjov5nkuKTkuKrovazmipjngrnkuK3pl7TvvIlcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50cy5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLnggPT0gdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnggPT0gdGhpcy54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLm1pbih0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnksIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS55KSA8PSB0aGlzLnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGgubWF4KHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueSwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLnkpID49IHRoaXMueSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFYID0gbmV3WC10aGlzLng7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uTWF0cml4ID0gVXRpbC50cmFuc2xhdGlvbk1hdHJpeChkZWx0YVgsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaW5kZXgtMV0udHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2luZGV4XS50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSBuZXdYOyAvL+WwhuWPpeafhOaWsOeahOS9jee9rui1i+WAvOe7mXhcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAvLy4gdGhpcy5zaGFwZS51cGRhdGVNaWRkbGVUZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlO1xyXG5cclxuXHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvSGFuZGxlLmpzXG4gKiogbW9kdWxlIGlkID0gOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDov57nur/liqjmgIHmlYjmnpxcclxuICogQGF1dGhvciBtaWFvLmN1bnpoaVxyXG4gKi9cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XHJcbiAgICB2YXIgY3VydmVVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9jdXJ2ZScpO1xyXG4gICAgdmFyIHN5bWJvbFV0aWwgPSByZXF1aXJlKCcuL1N5bWJvbC5qcycpO1xyXG5cclxuICAgIGZ1bmN0aW9uIEVmZmVjdExpbmUoc3ltYm9sLCBvcHRpb25zLCBncm91cEN1cnZlLCBwb2x5TGluZSkge1xyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGVyY2VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XHJcbiAgICAgICAgdGhpcy5ncm91cEN1cnZlID0gZ3JvdXBDdXJ2ZTtcclxuICAgICAgICB0aGlzLmluaXRTeW1ib2wob3B0aW9ucywgcG9seUxpbmUpO1xyXG4gICAgfVxyXG4gICAgdmFyIEVmZmVjdExpbmVQcm90byA9IEVmZmVjdExpbmUucHJvdG90eXBlO1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by5pbml0U3ltYm9sID0gZnVuY3Rpb24ob3B0aW9ucywgcG9seUxpbmUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuejIgPSAxMDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuY3VsbGluZyA9IHRydWU7XHJcbiAgICAgICAgdmFyIHBlcmlvZCA9IG9wdGlvbnMuZWZmZWN0LnBlcmlvZCAqIDEwMDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX190ID0gMDtcclxuICAgICAgICB0aGlzLnN5bWJvbC5zdG9wQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgaWYgKChvcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IFwiY3VydmVcIikpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXBDdXJ2ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgcGVyaW9kID0gcGVyaW9kIC8gdGhpcy5ncm91cEN1cnZlLl9jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmVBbmltYXRlKHRoaXMuZ3JvdXBDdXJ2ZS5fY2hpbGRyZW5bMF0sIGksIHBlcmlvZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zeW1ib2wuYW5pbWF0ZSgnJywgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIC53aGVuKHBlcmlvZCwge1xyXG4gICAgICAgICAgICAgICAgICAgIF9fdDogMVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5kZWxheSgwKVxyXG4gICAgICAgICAgICAgICAgLmR1cmluZyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVN5bWJvbFBvc2l0aW9uUG9seWxpbmUoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuc3RhcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRBbmltYXRpb25Qb2ludHNQb2x5bGluZShwb2x5TGluZS5zaGFwZS5wb2ludHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by5ncm91cEN1cnZlQW5pbWF0ZSA9IGZ1bmN0aW9uKGN1cnZlTGluZSwgaSwgcGVyaW9kKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIGlmIChjdXJ2ZUxpbmUgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGN1cnZlTGluZSA9IHRoaXMuZ3JvdXBDdXJ2ZS5fY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcG9pbnRzO1xyXG4gICAgICAgIHZhciBwb3MgPSBjdXJ2ZUxpbmUuc2hhcGU7XHJcbiAgICAgICAgcG9pbnRzID0gW1xyXG4gICAgICAgICAgICBbcG9zLngxLCBwb3MueTFdLFxyXG4gICAgICAgICAgICBbcG9zLngyLCBwb3MueTJdLFxyXG4gICAgICAgICAgICBbcG9zLmNweDEsIHBvcy5jcHkxXSxcclxuICAgICAgICAgICAgW3Bvcy5jcHgyLCBwb3MuY3B5Ml1cclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuc2V0QW5pbWF0aW9uUG9pbnRzQmV6aWVyQ3VydmUocG9pbnRzKTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5hbmltYXRlKCcnKVxyXG4gICAgICAgICAgICAud2hlbihwZXJpb2QsIHtcclxuICAgICAgICAgICAgICAgIF9fdDogMVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZGVsYXkoMClcclxuICAgICAgICAgICAgLmR1cmluZyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlU3ltYm9sUG9zaXRpb25CZXppZXJDdXJ2ZSgpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZG9uZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuc3ltYm9sLl9fdCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGF0Lmdyb3VwQ3VydmVBbmltYXRlKHRoYXQuZ3JvdXBDdXJ2ZS5fY2hpbGRyZW5baSArIDFdLCBpICsgMSwgcGVyaW9kKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0YXJ0KCk7XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgRWZmZWN0TGluZVByb3RvLnNldEFuaW1hdGlvblBvaW50c0JlemllckN1cnZlID0gZnVuY3Rpb24ocG9pbnRzKSB7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX19wMSA9IHBvaW50c1swXTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX3AyID0gcG9pbnRzWzFdO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fY3AxID0gcG9pbnRzWzJdIHx8IFtcclxuICAgICAgICAgICAgKHBvaW50c1swXVswXSArIHBvaW50c1sxXVswXSkgLyAyLFxyXG4gICAgICAgICAgICAocG9pbnRzWzBdWzFdICsgcG9pbnRzWzFdWzFdKSAvIDJcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fY3AyID0gcG9pbnRzWzNdO1xyXG4gICAgfTtcclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8udXBkYXRlU3ltYm9sUG9zaXRpb25CZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBwMSA9IHRoaXMuc3ltYm9sLl9fcDE7XHJcbiAgICAgICAgdmFyIHAyID0gdGhpcy5zeW1ib2wuX19wMjtcclxuICAgICAgICB2YXIgY3AxID0gdGhpcy5zeW1ib2wuX19jcDE7XHJcbiAgICAgICAgdmFyIGNwMiA9IHRoaXMuc3ltYm9sLl9fY3AyO1xyXG4gICAgICAgIHZhciB0ID0gdGhpcy5zeW1ib2wuX190O1xyXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnN5bWJvbC5wb3NpdGlvbjtcclxuICAgICAgICB2YXIgdHgsIHR5O1xyXG4gICAgICAgIGlmIChjcDJbMF0gIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhciBjdWJpY0F0ID0gY3VydmVVdGlsLmN1YmljQXQ7XHJcbiAgICAgICAgICAgIHZhciBjdWJpY0Rlcml2YXRpdmVBdCA9IGN1cnZlVXRpbC5jdWJpY0Rlcml2YXRpdmVBdDtcclxuICAgICAgICAgICAgcG9zWzBdID0gY3ViaWNBdChwMVswXSwgY3AxWzBdLCBjcDJbMF0sIHAyWzBdLCB0KTtcclxuICAgICAgICAgICAgcG9zWzFdID0gY3ViaWNBdChwMVsxXSwgY3AxWzFdLCBjcDJbMV0sIHAyWzFdLCB0KTtcclxuICAgICAgICAgICAgLy8gVGFuZ2VudFxyXG4gICAgICAgICAgICB0eCA9IGN1YmljRGVyaXZhdGl2ZUF0KHAxWzBdLCBjcDFbMF0sIGNwMlswXSwgcDJbMF0sIHQpO1xyXG4gICAgICAgICAgICB0eSA9IGN1YmljRGVyaXZhdGl2ZUF0KHAxWzFdLCBjcDFbMV0sIGNwMlsxXSwgcDJbMV0sIHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlVXRpbC5xdWFkcmF0aWNBdDtcclxuICAgICAgICAgICAgdmFyIHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IGN1cnZlVXRpbC5xdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XHJcbiAgICAgICAgICAgIHBvc1swXSA9IHF1YWRyYXRpY0F0KHAxWzBdLCBjcDFbMF0sIHAyWzBdLCB0KTtcclxuICAgICAgICAgICAgcG9zWzFdID0gcXVhZHJhdGljQXQocDFbMV0sIGNwMVsxXSwgcDJbMV0sIHQpO1xyXG4gICAgICAgICAgICAvLyBUYW5nZW50XHJcbiAgICAgICAgICAgIHR4ID0gcXVhZHJhdGljRGVyaXZhdGl2ZUF0KHAxWzBdLCBjcDFbMF0sIHAyWzBdLCB0KTtcclxuICAgICAgICAgICAgdHkgPSBxdWFkcmF0aWNEZXJpdmF0aXZlQXQocDFbMV0sIGNwMVsxXSwgcDJbMV0sIHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN5bWJvbC5yb3RhdGlvbiA9IC1NYXRoLmF0YW4yKHR5LCB0eCkgLSBNYXRoLlBJIC8gMjtcclxuXHJcbiAgICAgICAgdGhpcy5zeW1ib2wuaWdub3JlID0gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by5zZXRBbmltYXRpb25Qb2ludHNQb2x5bGluZSA9IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcclxuICAgICAgICB2YXIgYWNjTGVuQXJyID0gWzBdO1xyXG4gICAgICAgIHZhciBsZW4gPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwMSA9IHBvaW50c1tpIC0gMV07XHJcbiAgICAgICAgICAgIHZhciBwMiA9IHBvaW50c1tpXTtcclxuICAgICAgICAgICAgbGVuICs9IHZlYzIuZGlzdChwMSwgcDIpO1xyXG4gICAgICAgICAgICBhY2NMZW5BcnIucHVzaChsZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWNjTGVuQXJyLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGFjY0xlbkFycltqXSAvPSBsZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX29mZnNldHMgPSBhY2NMZW5BcnI7XHJcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9sYXN0RnJhbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fbGFzdEZyYW1lUGVyY2VudCA9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by51cGRhdGVTeW1ib2xQb3NpdGlvblBvbHlsaW5lID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLnN5bWJvbC5fX3Q7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX3BvaW50cztcclxuICAgICAgICB2YXIgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XHJcbiAgICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmICghb2Zmc2V0cykge1xyXG4gICAgICAgICAgICAvLyBIYXMgbGVuZ3RoIDBcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxhc3RGcmFtZSA9IHRoaXMuX2xhc3RGcmFtZTtcclxuICAgICAgICB2YXIgZnJhbWU7XHJcblxyXG4gICAgICAgIGlmICh0IDwgdGhpcy5fbGFzdEZyYW1lUGVyY2VudCkge1xyXG4gICAgICAgICAgICAvLyBTdGFydCBmcm9tIHRoZSBuZXh0IGZyYW1lXHJcbiAgICAgICAgICAgIC8vIFBFTkRJTkcgc3RhcnQgZnJvbSBsYXN0RnJhbWUgP1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1pbihsYXN0RnJhbWUgKyAxLCBsZW4gLSAxKTtcclxuICAgICAgICAgICAgZm9yIChmcmFtZSA9IHN0YXJ0OyBmcmFtZSA+PSAwOyBmcmFtZS0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0c1tmcmFtZV0gPD0gdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFBFTkRJTkcgcmVhbGx5IG5lZWQgdG8gZG8gdGhpcyA/XHJcbiAgICAgICAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUsIGxlbiAtIDIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGZyYW1lID0gbGFzdEZyYW1lOyBmcmFtZSA8IGxlbjsgZnJhbWUrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldHNbZnJhbWVdID4gdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUgLSAxLCBsZW4gLSAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmVjMi5sZXJwKFxyXG4gICAgICAgICAgICB0aGlzLnN5bWJvbC5wb3NpdGlvbiwgcG9pbnRzW2ZyYW1lXSwgcG9pbnRzW2ZyYW1lICsgMV0sXHJcbiAgICAgICAgICAgICh0IC0gb2Zmc2V0c1tmcmFtZV0pIC8gKG9mZnNldHNbZnJhbWUgKyAxXSAtIG9mZnNldHNbZnJhbWVdKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IGZyYW1lO1xyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZVBlcmNlbnQgPSB0O1xyXG4gICAgICAgIHZhciBhbmdsZSA9IC1NYXRoLmF0YW4yKHBvaW50c1tmcmFtZSArIDFdWzFdIC0gcG9pbnRzW2ZyYW1lXVsxXSwgcG9pbnRzW2ZyYW1lICsgMV1bMF0gLSBwb2ludHNbZnJhbWVdWzBdKTtcclxuICAgICAgICB0aGlzLnN5bWJvbC5yb3RhdGlvbiA9IGFuZ2xlIC0gTWF0aC5QSSAvIDI7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuaWdub3JlID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFZmZlY3RMaW5lO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0VmZmVjdExpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIOaOp+WItueCuVxyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsLmpzXCIpO1xyXG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvblBvaW50KGNvbm5lY3RvciwgcG9pbnQsIHR5cGUsIG9wdGlvbnMpe1xyXG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yO1xyXG5cclxuICAgICAgICB0aGlzLnBvaW50ID0gcG9pbnQuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IENvbm5lY3Rpb25Qb2ludC5OT1JNQUxfQ09MT1I7XHJcblxyXG4gICAgICAgIHRoaXMub1R5cGUgPSAnQ29ubmVjdGlvblBvaW50JztcclxuXHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogdGhpcy5wb2ludC54LFxyXG4gICAgICAgICAgICAgICAgY3k6IHRoaXMucG9pbnQueSxcclxuICAgICAgICAgICAgICAgIHI6IENvbm5lY3Rpb25Qb2ludC5SQURJVVNcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiB0aGlzLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjMDAwMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6IDogb3B0aW9ucy56ICsgMiAgLy/oioLngrla5Li6MSDnur/mrrXkuLowO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2hhcGUudHlwZSA9ICB0aGlzLnR5cGU7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhcGUuY29ubmVjdG9yID0gY29ubmVjdG9yO1xyXG4gICAgICAgIC8vcmV0dXJuIHRoaXMuY2lyY2xlO1xyXG4gICAgfVxyXG5cclxuICAgIENvbm5lY3Rpb25Qb2ludC5OT1JNQUxfQ09MT1IgPSBcIiNGRkZGMzNcIjsgLy95ZWxsb3cuXHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50Lk9WRVJfQ09MT1IgPSBcIiNGRjk5MDBcIjsgLy9vcmFuZ2VcclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQuQ09OTkVDVEVEX0NPTE9SID0gXCIjZmYwMDAwXCI7IC8vcmVkXHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlJBRElVUyA9IDQ7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlRZUEVfRklHVVJFID0gJ2ZpZ3VyZSc7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlRZUEVfQ09OTkVDVE9SID0gJ2Nvbm5lY3Rvcic7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IgOiBDb25uZWN0aW9uUG9pbnQsXHJcblxyXG4gICAgICAgIGVxdWFscyA6IGZ1bmN0aW9uKGFub3RoZXJDb25uZWN0aW9uUG9pbnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb2ludC5lcXVhbHMoYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5wb2ludClcclxuICAgICAgICAgICAgJiYgdGhpcy5jb25uZWN0b3IgPT0gYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5jb25uZWN0b3JcclxuICAgICAgICAgICAgJiYgdGhpcy50eXBlID09IGFub3RoZXJDb25uZWN0aW9uUG9pbnQudHlwZVxyXG4gICAgICAgICAgICAmJiB0aGlzLmNvbG9yID09IGFub3RoZXJDb25uZWN0aW9uUG9pbnQuY29sb3JcclxuICAgICAgICAgICAgJiYgdGhpcy5yYWRpdXMgPT0gYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5yYWRpdXM7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uUG9pbnQ7XHJcblxyXG5cclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0aW9uUG9pbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiBCUE1O6Z2Z5oCB5pa55rOV57G7XHJcbiAqIEBjbGFzcyBmaXNoLnRvcG8uRmlzaFRvcG9CcG1uLkJwbW5cclxuICovXHJcblxyXG5cdHZhciBCcG1uID0ge1xyXG5cdFx0QlBNTl9UWVBFOlwic3RlbmNpbC50eXBlXCIsXHJcblx0XHRCUE1OX1NDUklQVF9UQVNLOiBcIlNjcmlwdFRhc2tcIixcclxuXHRcdEJQTU5fRVZFTlRfU1VCX1BST0NFU1M6IFwiU3ViUHJvY2Vzc1Rhc2tcIixcclxuXHRcdEJQTU5fVEFTSzpcIlRhc2tcIixcclxuXHRcdFRFTVBMQVRFOiBcIkJQTU5EaWFncmFtXCIsXHJcblx0XHRSRVNPVVJDRV9JRDogXCJyZXNvdXJjZUlkXCIsXHJcblx0XHRTRVFVRU5DRV9GTE9XOiBcIlNlcXVlbmNlRmxvd1wiLFxyXG5cdFx0U1VCX1BST0NFU1M6IFwiU3ViUHJvY2Vzc1wiLFxyXG5cdFx0VVNFUl9EQVRBOiBcInByb3BlcnRpZXMudXNlckRhdGFcIixcclxuXHJcblx0XHRTVEFSVF9FVkVOVDogXCJTdGFydE5vbmVFdmVudFwiLFxyXG5cdFx0RU5EX0VWRU5UOiBcIkVuZE5vbmVFdmVudFwiLFxyXG5cdFx0VVNFUl9UQVNLOiBcIlVzZXJUYXNrXCIsXHJcblx0XHRNQU5VQUxfVEFTSzogXCJNYW51YWxUYXNrXCIsXHJcblx0XHRTQ1JJUFRfVEFTSzogXCJTY3JpcHRUYXNrXCIsXHJcblx0XHRNQUlMX1RBU0s6IFwiTWFpbFRhc2tcIixcclxuXHRcdENBVENIX1RJTUVSX0VWRU5UOiBcIkNhdGNoVGltZXJFdmVudFwiLFxyXG5cdFx0Q0FUQ0hfU0lHTkFMX0VWRU5UOiBcIkNhdGNoU2lnbmFsRXZlbnRcIixcclxuXHRcdFRIUk9XX1NJR05BTF9FVkVOVDogXCJUaHJvd1NpZ25hbEV2ZW50XCIsXHJcblx0XHRJTkNMVVNJVkVfR0FURVdBWTogXCJJbmNsdXNpdmVHYXRld2F5XCIsXHJcblx0XHRFWENMVVNJVkVfR0FURVdBWTogXCJFeGNsdXNpdmVHYXRld2F5XCIsXHJcblx0XHRQQVJBTExFTF9HQVRFV0FZOiBcIlBhcmFsbGVsR2F0ZXdheVwiLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog5Yik5pat6IqC54K55piv5ZCmIEJQTU7mqKHmnb8g57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcblx0XHQgKi9cclxuXHRcdGlzVGVtcGxhdGU6IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dmFyIGJwbW50eXBlID0gbm9kZS5tb2RlbC5nZXQoQnBtbi5CUE1OX1RZUEUpO1xyXG5cdFx0XHRyZXR1cm4gYnBtbnR5cGUgPT09IEJwbW4uVEVNUExBVEU7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog5Yik5pat6IqC54K55piv5ZCmIEFjdGl2aXR5IOexu+Wei1xyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZSDpnIDopoHliKTmlq3nsbvlnovnmoToioLngrlcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG5cdFx0ICovXHJcblx0XHRpc0FjdGl2aXR5OiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuIChicG1udHlwZS5pbmRleE9mKFwiVGFza1wiKSAhPSAtMSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog5Yik5pat6IqC54K55piv5ZCmIOWtkOa1geeoiyDnsbvlnotcclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gIG5vZGUg6ZyA6KaB5Yik5pat57G75Z6L55qE6IqC54K5XHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuXHRcdCAqL1xyXG5cdFx0aXNTdWJQcm9jZXNzOiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuICBicG1udHlwZSA9PSBCcG1uLlNVQl9QUk9DRVNTXHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog5Yik5pat6IqC54K55piv5ZCmIOe9keWFsyDnsbvlnotcclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gIG5vZGUg6ZyA6KaB5Yik5pat57G75Z6L55qE6IqC54K5XHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuXHRcdCAqL1xyXG5cdFx0aXNHYXRld2F5OiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuIGJwbW50eXBlLmluZGV4T2YoXCJHYXRld2F5XCIpICE9IC0xO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOWIpOaWreiKgueCueaYr+WQpiDnur/mrrUg57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcblx0XHQgKi9cclxuXHRcdGlzRmxvdzogZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR2YXIgYnBtbnR5cGUgPSBub2RlLm1vZGVsLmdldChCcG1uLkJQTU5fVFlQRSk7XHJcblx0XHRcdHJldHVybiBicG1udHlwZSA9PT0gQnBtbi5TRVFVRU5DRV9GTE9XO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiDliKTmlq3mqKHlnovmmK/lkKYg57q/5q61IOexu+Wei1xyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbW9kZWwg6ZyA6KaB5Yik5pat57G75Z6L55qE5qih5Z6LXHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuXHRcdCAqL1xyXG5cdFx0aXNGbG93TW9kZWw6IGZ1bmN0aW9uKG1vZGVsKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG1vZGVsLmdldChCcG1uLkJQTU5fVFlQRSk7XHJcblx0XHRcdHJldHVybiBicG1udHlwZSA9PT0gQnBtbi5TRVFVRU5DRV9GTE9XO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOWIpOaWreiKgueCueaYr+WQpiDkuovku7Yg57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcblx0XHQgKi9cclxuXHRcdGlzRXZlbnQ6IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dmFyIGJwbW50eXBlID0gbm9kZS5tb2RlbC5nZXQoQnBtbi5CUE1OX1RZUEUpO1xyXG5cdFx0XHRyZXR1cm4gYnBtbnR5cGUuaW5kZXhPZihcIkV2ZW50XCIpICE9IC0xO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOWIpOaWreiKgueCueaYr+WQpiDmj5Lns5/kuovku7Yg57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcblx0XHQgKi9cclxuXHRcdGlzU2xvdEV2ZW50OiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuIGJwbW50eXBlID09IEJwbW4uQ0FUQ0hfVElNRVJfRVZFTlQgfHwgYnBtbnR5cGUgPT0gQnBtbi5DQVRDSF9TSUdOQUxfRVZFTlQgfHwgYnBtbnR5cGUgPT0gQnBtbi5USFJPV19TSUdOQUxfRVZFTlQ7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog6I635Y+W5b2T5YmN6IqC54K555qE57G75Z6LXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSAgICAgIOiKgueCueeahOexu+Wei1xyXG5cdFx0ICovXHJcblx0XHRnZXRUeXBlOiBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHZhciBicG1udHlwZSA9IG5vZGUubW9kZWwuZ2V0KEJwbW4uQlBNTl9UWVBFKTtcclxuXHRcdFx0cmV0dXJuIGJwbW50eXBlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOi/lOWbnuW9k+WJjeiKgueCueeahOagt+W8j+mAiemhuVxyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZSDpnIDopoHliKTmlq3nsbvlnovnmoToioLngrlcclxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gICAgICDmoLflvI/lr7nosaFcclxuXHRcdCAqL1xyXG5cdFx0Z2V0U3R5bGU6IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0cmV0dXJuIG5vZGUubW9kZWwub3B0aW9uLnN0eWxlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIOi/lOWbnuW9k+WJjeiKgueCueeahOWxnuaAp+mAiemhuVxyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSAgbm9kZSDpnIDopoHliKTmlq3nsbvlnovnmoToioLngrlcclxuXHRcdCAqIEByZXR1cm4gIHtPYmplY3R9ICAgICAg5bGe5oCn5a+56LGhXHJcblx0XHQgKi9cclxuXHRcdGdldFByb3A6IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0cmV0dXJuIG5vZGUubW9kZWwub3B0aW9uLnByb3BlcnRpZXM7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICog6I635Y+W55So5oi36Ieq5a6a5LmJ55qE5pWw5o2uXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9ICBub2RlIOmcgOimgeWIpOaWreexu+Wei+eahOiKgueCuVxyXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSAgIOeUqOaIt+iHquWumuS5ieeahOaVsOaNrlxyXG5cdFx0ICovXHJcblx0XHRnZXRVc2VyRGF0YTogZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR2YXIgbW9kZWwgPSBub2RlLm1vZGVsO1xyXG5cdFx0XHRyZXR1cm4gbW9kZWwuZ2V0KEJwbW4uVVNFUl9EQVRBKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiDorr7nva7nlKjmiLfnmoToh6rlrprkuYnmlbDmja5cclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gIG5vZGUg6ZyA6KaB5Yik5pat57G75Z6L55qE6IqC54K5XHJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdXNlckRhdGEg55So5oi355qE6Ieq5a6a5LmJ5pWw5o2uXHJcblx0XHQgKi9cclxuXHRcdHNldFVzZXJEYXRhOiBmdW5jdGlvbihub2RlLCB1c2VyRGF0YSkge1xyXG5cdFx0XHR2YXIgbW9kZWwgPSBub2RlLm1vZGVsO1xyXG5cdFx0XHRtb2RlbC5zZXQoQnBtbi5VU0VSX0RBVEEsIHVzZXJEYXRhKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IEJwbW47XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1icG1uL2xpYi9CcG1uLmpzXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog6YCJ5Lit6IqC54K55ZCO77yM5Ye6546w55qE5pON5L2c5qGG5Y+K5oyJ6ZKuXHJcbiAqL1xyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3V0aWwuanNcIik7XHJcbiAgICB2YXIgQnBtbiA9IHJlcXVpcmUoXCIuLi9CcG1uLmpzXCIpO1xyXG4gICAgdmFyIE9wZXJhdGlvbk5vZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvT3BlcmF0aW9uTm9kZS5qc1wiKTtcclxuXHJcbiAgICBmdW5jdGlvbiBCcG1uT3BlcmF0aW9uTm9kZShub2RlLCB6ciwgZm9yYmlkRWRpdCkge1xyXG4gICAgICAgIE9wZXJhdGlvbk5vZGUuY2FsbCh0aGlzLCBub2RlLCB6ciwgZm9yYmlkRWRpdCk7XHJcbiAgICB9XHJcblxyXG4gICAgQnBtbk9wZXJhdGlvbk5vZGUucHJvdG90eXBlLnJlbmRlck90aGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKEJwbW4uaXNTdWJQcm9jZXNzKHRoaXMubm9kZSkpIHtcclxuICAgICAgICAgICAgLy/lt6bkuIrop5LmlL7lpKfnrq3lpLRcclxuICAgICAgICAgICAgdmFyIGxlZnRUb3BBcnJvdyA9IHsgeDogMCwgeTogMCwgd2lkdGg6IDEwLCBoZWlnaHQ6IDEwIH07XHJcbiAgICAgICAgICAgIHZhciBsZWZ0VG9wQXJyb3dQYXRoID0gJ00wIDEwMCBMMCAwIEwxMDAgMCBMMTAwIDIwIEwyMCAyMCBMMjAgMTAwIHonO1xyXG4gICAgICAgICAgICB0aGlzLmxlZnRUb3AgPSBncmFwaGljLm1ha2VQYXRoKGxlZnRUb3BBcnJvd1BhdGgsIHsgc3R5bGU6IHsgZmlsbDogJyMwMDAwMDAnIH0gfSwgbGVmdFRvcEFycm93KTtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0VG9wLmF0dHIoXCJjdXJzb3JcIiwgXCJudy1yZXNpemVcIik7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdFRvcC5pc1NlbGZDb21wdXRlUG9zID0gdHJ1ZTsgIC8vIOiHquW3seiuoeeul+S9jee9rlxyXG4gICAgICAgICAgICAvL+WPs+S4i+inkuaUvuWkp+eureWktFxyXG4gICAgICAgICAgICB2YXIgcmlnaHRCb3R0b21BcnJvdyA9IHsgeDogMCwgeTogMCwgd2lkdGg6IDEwLCBoZWlnaHQ6IDEwIH07XHJcbiAgICAgICAgICAgIHZhciByaWdodEJvdHRvbUFycm93UGF0aCA9ICdNMCAxMDAgTDEwMCAxMDAgTDEwMCAwIEw4MCAwIEw4MCA4MCBMMCA4MCB6JztcclxuICAgICAgICAgICAgdGhpcy5yaWdodEJvdHRvbSA9IGdyYXBoaWMubWFrZVBhdGgocmlnaHRCb3R0b21BcnJvd1BhdGgsIHsgc3R5bGU6IHsgZmlsbDogJyMwMDAwMDAnIH0gfSwgcmlnaHRCb3R0b21BcnJvdyk7XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHRCb3R0b20uYXR0cihcImN1cnNvclwiLCBcInNlLXJlc2l6ZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5yaWdodEJvdHRvbS5pc1NlbGZDb21wdXRlUG9zID0gdHJ1ZTsgIC8vIOiHquW3seiuoeeul+S9jee9rlxyXG5cclxuICAgICAgICAgICAgdGhpcy5hZGQodGhpcy5yaWdodEJvdHRvbSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMubGVmdFRvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBCcG1uT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVmcmVzaFBvc2l0aW9uT3RoZXIgPSBmdW5jdGlvbihub2RlLG5vZGVSZWN0KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZvcmJpZEVkaXQpIHtcclxuICAgICAgICAgICAgaWYgKEJwbW4uaXNTdWJQcm9jZXNzKHRoaXMubm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydFgsIHN0YXJ0WTtcclxuICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IDIwO1xyXG4gICAgICAgICAgICAgICAgLy/nn6nlvaLmnIDlsI/plb/lkozlrr1cclxuICAgICAgICAgICAgICAgIHZhciB3aWR0aE1pbiA9IDEwMDtcclxuICAgICAgICAgICAgICAgIHZhciBoZWlnaHRNaW4gPSA2MDtcclxuICAgICAgICAgICAgICAgIHZhciBsZWZ0VG9wUG9zaXRpb24sIG5vd2xlZnRUb3BQb3NpdGlvbiA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0U2xvdFBvaW50cywgc3RhcnRQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVmdFRvcC5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0U2xvdFBvaW50cyA9IHV0aWwuZ2V0U29sdFBvaW50cyhub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uID0genJVdGlsLmNsb25lKG5vZGUucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRUb3BQb3NpdGlvbiA9IG5vZGVSZWN0LnBvaW50c1swXTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFggPSBlLmV2ZW50LmNsaWVudFg7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRZID0gZS5ldmVudC5jbGllbnRZO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRTY2FsZURyYWcoZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsZWZ0U2NhbGVEcmFnKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdEFycm93ID0gZnVuY3Rpb24oZSkgeyBsZWZ0QXJyb3dEcmFnKGUpOyB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBsZWZ0QXJyb3dEcmFnKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8y5Liq5ZyG6Ze06Led5aSq5bCP5pe2LOS4jeWcqOaLluWKqFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5yaWdodEJvdHRvbS5wb3NpdGlvblswXSAtIHRoYXQubGVmdFRvcC5wb3NpdGlvblswXSA8ICh3aWR0aE1pbiArIDEwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQucmlnaHRCb3R0b20ucG9zaXRpb25bMV0gLSB0aGF0LmxlZnRUb3AucG9zaXRpb25bMV0gPCAoaGVpZ2h0TWluICsgMTApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5sZWZ0VG9wLnBvc2l0aW9uWzBdID0gdGhhdC5yaWdodEJvdHRvbS5wb3NpdGlvblswXSAtICh3aWR0aE1pbiArIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmxlZnRUb3AucG9zaXRpb25bMV0gPSB0aGF0LnJpZ2h0Qm90dG9tLnBvc2l0aW9uWzFdIC0gKGhlaWdodE1pbiArIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5sZWZ0VG9wLnBvc2l0aW9uWzBdID0gdGhhdC5yaWdodEJvdHRvbS5wb3NpdGlvblswXSAtICh3aWR0aE1pbiArIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVJlY3QodGhhdC5sZWZ0VG9wLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnJpZ2h0Qm90dG9tLnBvc2l0aW9uWzFdIC0gdGhhdC5sZWZ0VG9wLnBvc2l0aW9uWzFdIDwgKGhlaWdodE1pbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmxlZnRUb3AucG9zaXRpb25bMV0gPSB0aGF0LnJpZ2h0Qm90dG9tLnBvc2l0aW9uWzFdIC0gKGhlaWdodE1pbiArIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVJlY3QodGhhdC5sZWZ0VG9wLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVSZWN0KHRoYXQubGVmdFRvcCwgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNjYWxlUmVjdChkb20sIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21Qb3NpdGlvbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPD0gTWF0aC5hYnMocGFyc2VJbnQoKGUuZXZlbnQuY2xpZW50WCAtIHN0YXJ0WCkgLyBwaXhlbCkpOyBuKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5ldmVudC5jbGllbnRYIC0gc3RhcnRYIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93bGVmdFRvcFBvc2l0aW9uWzBdID0gbGVmdFRvcFBvc2l0aW9uWzBdIC0gcGl4ZWwgKiAobik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbVBvc2l0aW9uWzBdID0gbm93bGVmdFRvcFBvc2l0aW9uWzBdIC0gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub3dsZWZ0VG9wUG9zaXRpb25bMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd2xlZnRUb3BQb3NpdGlvblswXSA9IGxlZnRUb3BQb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVJlY3QucG9pbnRzWzJdWzBdIC0gbm93bGVmdFRvcFBvc2l0aW9uWzBdID4gd2lkdGhNaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd2xlZnRUb3BQb3NpdGlvblswXSA9IGxlZnRUb3BQb3NpdGlvblswXSArIHBpeGVsICogKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tUG9zaXRpb25bMF0gPSBub3dsZWZ0VG9wUG9zaXRpb25bMF0gLSAxMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbVBvc2l0aW9uWzBdID0gdGhhdC5yaWdodEJvdHRvbS5wb3NpdGlvblswXSAtIHdpZHRoTWluO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPD0gTWF0aC5hYnMocGFyc2VJbnQoKGUuZXZlbnQuY2xpZW50WSAtIHN0YXJ0WSkgLyBwaXhlbCkpOyBtKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5ldmVudC5jbGllbnRZIC0gc3RhcnRZIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93bGVmdFRvcFBvc2l0aW9uWzFdID0gbGVmdFRvcFBvc2l0aW9uWzFdIC0gcGl4ZWwgKiAobSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbVBvc2l0aW9uWzFdID0gbm93bGVmdFRvcFBvc2l0aW9uWzFdIC0gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub3dsZWZ0VG9wUG9zaXRpb25bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd2xlZnRUb3BQb3NpdGlvblsxXSA9IGxlZnRUb3BQb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVJlY3QucG9pbnRzWzJdWzFdIC0gbm93bGVmdFRvcFBvc2l0aW9uWzFdID4gaGVpZ2h0TWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dsZWZ0VG9wUG9zaXRpb25bMV0gPSBsZWZ0VG9wUG9zaXRpb25bMV0gKyBwaXhlbCAqIChtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbVBvc2l0aW9uWzFdID0gbm93bGVmdFRvcFBvc2l0aW9uWzFdIC0gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Qb3NpdGlvblsxXSA9IHRoYXQucmlnaHRCb3R0b20ucG9zaXRpb25bMV0gLSBoZWlnaHRNaW47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tLmF0dHIoXCJwb3NpdGlvblwiLCBkb21Qb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF0gPSBbbm93bGVmdFRvcFBvc2l0aW9uWzBdLCBub3dsZWZ0VG9wUG9zaXRpb25bMV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzFdID0gW25vZGVSZWN0LnBvaW50c1sxXVswXSwgbm93bGVmdFRvcFBvc2l0aW9uWzFdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1syXSA9IG5vZGVSZWN0LnBvaW50c1syXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1szXSA9IFtub3dsZWZ0VG9wUG9zaXRpb25bMF0sIG5vZGVSZWN0LnBvaW50c1szXVsxXSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzRdID0gW25vd2xlZnRUb3BQb3NpdGlvblswXSwgbm93bGVmdFRvcFBvc2l0aW9uWzFdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJPcGVyYXRpb25Ob2RlOnNjYWxlRHJhZ0xlZnRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC56ci5vbignbW91c2Vtb3ZlJywgbGVmdEFycm93KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdEVuZCA9IGZ1bmN0aW9uKGUpIHsgbGVmdERyYWdFbmQoZSkgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbGVmdERyYWdFbmQoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnpyLm9mZignbW91c2Vtb3ZlJywgbGVmdEFycm93KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC56ci5vZmYoXCJtb3VzZXVwXCIsIGxlZnRFbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5hcnJvd05hbWUgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcIk9wZXJhdGlvbk5vZGU6c2NhbGVEcmFnRW5kXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zdGFydFNsb3RQb2ludHMgPSBzdGFydFNsb3RQb2ludHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnpyLm9uKFwibW91c2V1cFwiLCBsZWZ0RW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHRCb3R0b21Qb3NpdGlvbiwgbm93cmlnaHRCb3R0b21Qb3NpdGlvbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodEJvdHRvbS5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0U2xvdFBvaW50cyA9IHV0aWwuZ2V0U29sdFBvaW50cyhub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uID0genJVdGlsLmNsb25lKG5vZGUucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Qm90dG9tUG9zaXRpb24gPSBub2RlUmVjdC5wb2ludHNbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRYID0gZS5ldmVudC5jbGllbnRYO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0WSA9IGUuZXZlbnQuY2xpZW50WTtcclxuICAgICAgICAgICAgICAgICAgICByaWdodFNjYWxlRHJhZyhlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJpZ2h0U2NhbGVEcmFnKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHRBcnJvdyA9IGZ1bmN0aW9uKGUpIHsgcmlnaHRBcnJvd0RyYWcoZSk7IH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJpZ2h0QXJyb3dEcmFnKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8y5Liq5ZyG6Ze06Led5aSq5bCP5pe2LOS4jeWcqOaLluWKqFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5yaWdodEJvdHRvbS5wb3NpdGlvblswXSAtIHRoYXQubGVmdFRvcC5wb3NpdGlvblswXSA8ICh3aWR0aE1pbiArIDEwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQucmlnaHRCb3R0b20ucG9zaXRpb25bMV0gLSB0aGF0LmxlZnRUb3AucG9zaXRpb25bMV0gPCAoaGVpZ2h0TWluICsgMTApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5yaWdodEJvdHRvbS5wb3NpdGlvblswXSA9IHRoYXQubGVmdFRvcC5wb3NpdGlvblswXSArICh3aWR0aE1pbiArIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnJpZ2h0Qm90dG9tLnBvc2l0aW9uWzFdID0gdGhhdC5sZWZ0VG9wLnBvc2l0aW9uWzFdICsgKGhlaWdodE1pbiArIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5yaWdodEJvdHRvbS5wb3NpdGlvblswXSA9IHRoYXQubGVmdFRvcC5wb3NpdGlvblswXSArIHdpZHRoTWluO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlUmVjdCh0aGF0LnJpZ2h0Qm90dG9tLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnJpZ2h0Qm90dG9tLnBvc2l0aW9uWzFdIC0gdGhhdC5sZWZ0VG9wLnBvc2l0aW9uWzFdIDwgKGhlaWdodE1pbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnJpZ2h0Qm90dG9tLnBvc2l0aW9uWzFdID0gdGhhdC5sZWZ0VG9wLnBvc2l0aW9uWzFdICsgaGVpZ2h0TWluO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlUmVjdCh0aGF0LnJpZ2h0Qm90dG9tLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVSZWN0KHRoYXQucmlnaHRCb3R0b20sIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzY2FsZVJlY3QoZG9tLCBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9tUG9zaXRpb24gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDw9IE1hdGguYWJzKHBhcnNlSW50KChlLmV2ZW50LmNsaWVudFggLSBzdGFydFgpIC8gcGl4ZWwpKTsgbisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZXZlbnQuY2xpZW50WCAtIHN0YXJ0WCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93cmlnaHRCb3R0b21Qb3NpdGlvblswXSA9IHJpZ2h0Qm90dG9tUG9zaXRpb25bMF0gKyBwaXhlbCAqIChuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tUG9zaXRpb25bMF0gPSBub3dyaWdodEJvdHRvbVBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm93cmlnaHRCb3R0b21Qb3NpdGlvblswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93cmlnaHRCb3R0b21Qb3NpdGlvblswXSA9IHJpZ2h0Qm90dG9tUG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vd3JpZ2h0Qm90dG9tUG9zaXRpb25bMF0gLSBub2RlUmVjdC5wb2ludHNbMF1bMF0gPiB3aWR0aE1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93cmlnaHRCb3R0b21Qb3NpdGlvblswXSA9IHJpZ2h0Qm90dG9tUG9zaXRpb25bMF0gLSBwaXhlbCAqIChuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbVBvc2l0aW9uWzBdID0gbm93cmlnaHRCb3R0b21Qb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbVBvc2l0aW9uWzBdID0gdGhhdC5sZWZ0VG9wLnBvc2l0aW9uWzBdICsgd2lkdGhNaW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8PSBNYXRoLmFicyhwYXJzZUludCgoZS5ldmVudC5jbGllbnRZIC0gc3RhcnRZKSAvIHBpeGVsKSk7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmV2ZW50LmNsaWVudFkgLSBzdGFydFkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd3JpZ2h0Qm90dG9tUG9zaXRpb25bMV0gPSByaWdodEJvdHRvbVBvc2l0aW9uWzFdICsgcGl4ZWwgKiAobSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbVBvc2l0aW9uWzFdID0gbm93cmlnaHRCb3R0b21Qb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vd3JpZ2h0Qm90dG9tUG9zaXRpb25bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd3JpZ2h0Qm90dG9tUG9zaXRpb25bMV0gPSByaWdodEJvdHRvbVBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3dyaWdodEJvdHRvbVBvc2l0aW9uWzFdIC0gbm9kZVJlY3QucG9pbnRzWzBdWzFdID4gaGVpZ2h0TWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3dyaWdodEJvdHRvbVBvc2l0aW9uWzFdID0gcmlnaHRCb3R0b21Qb3NpdGlvblsxXSAtIHBpeGVsICogKG0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tUG9zaXRpb25bMV0gPSBub3dyaWdodEJvdHRvbVBvc2l0aW9uWzFdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbVBvc2l0aW9uWzFdID0gdGhhdC5sZWZ0VG9wLnBvc2l0aW9uWzFdICsgaGVpZ2h0TWluO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tLmF0dHIoXCJwb3NpdGlvblwiLCBkb21Qb3NpdGlvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdID0gbm9kZVJlY3QucG9pbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzFdID0gW25vd3JpZ2h0Qm90dG9tUG9zaXRpb25bMF0sIG5vZGVSZWN0LnBvaW50c1sxXVsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbMl0gPSBbbm93cmlnaHRCb3R0b21Qb3NpdGlvblswXSwgbm93cmlnaHRCb3R0b21Qb3NpdGlvblsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbM10gPSBbbm9kZVJlY3QucG9pbnRzWzNdWzBdLCBub3dyaWdodEJvdHRvbVBvc2l0aW9uWzFdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1s0XSA9IG5vZGVSZWN0LnBvaW50c1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJPcGVyYXRpb25Ob2RlOnNjYWxlRHJhZ1JpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzID0gcG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuenIub24oJ21vdXNlbW92ZScsIHJpZ2h0QXJyb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByaWdodEVuZCA9IGZ1bmN0aW9uKGUpIHsgcmlnaHREcmFnRW5kKGUpIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJpZ2h0RHJhZ0VuZChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuenIub2ZmKCdtb3VzZW1vdmUnLCByaWdodEFycm93KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC56ci5vZmYoXCJtb3VzZXVwXCIsIHJpZ2h0RW5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYXJyb3dOYW1lID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiT3BlcmF0aW9uTm9kZTpzY2FsZURyYWdFbmRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnN0YXJ0U2xvdFBvaW50cyA9IHN0YXJ0U2xvdFBvaW50cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuenIub24oXCJtb3VzZXVwXCIsIHJpZ2h0RW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMubGVmdFRvcC5hdHRyKFwicG9zaXRpb25cIiwgW25vZGVSZWN0LnBvaW50c1swXVswXSAtIDEwLCBub2RlUmVjdC5wb2ludHNbMF1bMV0gLSAxMF0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodEJvdHRvbS5hdHRyKFwicG9zaXRpb25cIiwgW25vZGVSZWN0LnBvaW50c1syXVswXSwgbm9kZVJlY3QucG9pbnRzWzJdWzFdXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyDorqHnrpfmlbTkuKrnmoTkvY3nva5cclxuICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKEJwbW4uaXNTdWJQcm9jZXNzKG5vZGUucGFyZW50KSkgeyAvL2lmKG5vZGUucGFyZW50Lm1vZGVsLmdldChcInN0ZW5jaWwudHlwZVwiKSA9PSBcIlN1YlByb2Nlc3NcIil7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHIoXCJwb3NpdGlvblwiLCBbbm9kZVJlY3QueCArIG5vZGUucGFyZW50LnBvc2l0aW9uWzBdLCBub2RlUmVjdC55ICsgbm9kZS5wYXJlbnQucG9zaXRpb25bMV1dKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5hdHRyKFwicG9zaXRpb25cIiwgW25vZGVSZWN0LngsIG5vZGVSZWN0LnldKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIEJwbW5PcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUdFTkQgPSBcIk9wZXJhdGlvbk5vZGU6ZHJhZ2VuZEFycm93XCI7XHJcbiAgICBCcG1uT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHID0gXCJPcGVyYXRpb25Ob2RlOmRyYWdBcnJvd1wiO1xyXG4gICAgQnBtbk9wZXJhdGlvbk5vZGUuQVJST1dfRFJBR1NUQVJUID0gXCJPcGVyYXRpb25Ob2RlOmRyYWdzdGFydEFycm93XCI7XHJcbiAgICBCcG1uT3BlcmF0aW9uTm9kZS5ERUxFVEVfQ0xJQ0sgPSBcIk9wZXJhdGlvbk5vZGU6ZGVsZXRlQ2xpY2tcIjtcclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoQnBtbk9wZXJhdGlvbk5vZGUsIE9wZXJhdGlvbk5vZGUpO1xyXG5cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJwbW5PcGVyYXRpb25Ob2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbm9kZS9CcG1uT3BlcmF0aW9uTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIOmAieS4reiKgueCueWQju+8jOWHuueOsOeahOaTjeS9nOahhuWPiuaMiemSrlxyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuICAgIHZhciBOb2RlID0gcmVxdWlyZShcIi4uL05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XHJcblxyXG4gICAgZnVuY3Rpb24gT3BlcmF0aW9uTm9kZShub2RlLCB6ciwgZm9yYmlkRWRpdCkge1xyXG4gICAgICAgIE5vZGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMuenIgPSB6cjtcclxuICAgICAgICB0aGlzLmZvcmJpZEVkaXQgPSBmb3JiaWRFZGl0OyAvL1xyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy/kuovku7ZcclxuICAgIE9wZXJhdGlvbk5vZGUuQVJST1dfRFJBR0VORCA9IFwiT3BlcmF0aW9uTm9kZTpkcmFnZW5kQXJyb3dcIjtcclxuICAgIE9wZXJhdGlvbk5vZGUuQVJST1dfRFJBRyA9IFwiT3BlcmF0aW9uTm9kZTpkcmFnQXJyb3dcIjtcclxuICAgIE9wZXJhdGlvbk5vZGUuQVJST1dfRFJBR1NUQVJUID0gXCJPcGVyYXRpb25Ob2RlOmRyYWdzdGFydEFycm93XCI7XHJcbiAgICBPcGVyYXRpb25Ob2RlLkRFTEVURV9DTElDSyA9IFwiT3BlcmF0aW9uTm9kZTpkZWxldGVDbGlja1wiO1xyXG5cclxuICAgIGlmKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgLy/lhoXnva7mk43kvZzlm77moIfnmoTlm77lg49cclxuICAgICAgICBPcGVyYXRpb25Ob2RlLm9waWNvbnMgPSB7XHJcbiAgICAgICAgICAgIFNUUkFJR0hUOiAnTTEzLjk2MSwyLjMwOWMtMC4wNTEtMC4xMjItMC4xNDgtMC4yMi0wLjI3LTAuMjdMMTMuNSwyaC01QzguMjI0LDIsOCwyLjIyNCw4LDIuNVM4LjIyNCwzLDguNSwzaDMuNzkzTDIuMTQ2LDEzLjE0NmMtMC4xOTUsMC4xOTUtMC4xOTUsMC41MTIsMCwwLjcwN3MwLjUxMiwwLjE5NSwwLjcwNywwTDEzLDMuNzA3VjcuNUMxMyw3Ljc3NiwxMy4yMjUsOCwxMy41LDhTMTQsNy43NzYsMTQsNy41di01TDEzLjk2MSwyLjMwOXonLFxyXG4gICAgICAgICAgICBKQUdHRUQ6ICdNOTYuMDQ2LDEzLjYwNEg4NC4yMTNjLTEuMTA0LDAtMiwwLjg5Ni0yLDJ2NDIuMTg4SDM4LjMxNHYtMTAuNzdjMC0wLjcxNS0wLjM4MS0xLjM3NS0xLTEuNzMyYy0wLjYxOS0wLjM1Ny0xLjM4Mi0wLjM1NS0yLDBMMi45NTQsNjMuOTc3Yy0wLjYxOSwwLjM1Ny0xLDEuMDE4LTEsMS43MzJzMC4zODEsMS4zNzUsMSwxLjczMmwzMi4zNiwxOC42ODdjMC4zMDksMC4xNzksMC42NTUsMC4yNjgsMSwwLjI2OHMwLjY5LTAuMDg5LDEtMC4yNjhjMC42MTktMC4zNTcsMS0xLjAxOCwxLTEuNzMyVjczLjYyNWg1Ny43MzJjMS4xMDQsMCwyLTAuODk2LDItMlYxNS42MDRDOTguMDQ2LDE0LjUsOTcuMTUxLDEzLjYwNCw5Ni4wNDYsMTMuNjA0eicsXHJcbiAgICAgICAgICAgIENVUlZFOiAnTTUxMC41MzYsMjY4LjA5OGMxMy41NDEsMCwyNy4wNzgtNS4yMDcsMzcuMzQ3LTE1LjZjMjAuMzc5LTIwLjYyNSwyMC4xOC01My44NjYtMC40NDUtNzQuMjQ1TDQxNC4xNjcsNDYuNTdjLTkuOTA1LTkuNzg2LTIzLjMyNS0xNS4yNDQtMzcuMjE1LTE1LjE1NGMtMTMuOTIzLDAuMDgzLTI3LjI0NCw1LjY5NS0zNy4wMywxNS41OTlsLTEyOS45MTIsMTMxLjQ4Yy0yMC4zNzksMjAuNjI1LTIwLjE4LDUzLjg2NiwwLjQ0NSw3NC4yNDVjMjAuNjI1LDIwLjM3OSw1My44NjYsMjAuMTgsNzQuMjQ1LTAuNDQ1bDQwLjYxOC00MS4xMDhjMC4wMjEsMC40NjQsMC4wMjksMC45MjcsMC4wNjIsMS4zOTRjNC4xNzgsNTkuMDA4LDQuNjY4LDExOS44MzIsMTYuNjMzLDE3Ny45MzFjMjMuOTM3LDExNi4yMzIsMTAzLjcwNSwxOTEuOTYxLDE5MS40ODksMjY0LjAyNGM0Ny4yOTIsMzguODIzLDc5LjY2LDk0LjEyMiw5OC42MDEsMTUxLjY3M2M5Ljc2NSwyOS42NjksMTQuNzE0LDc3LjExNSwxNy4yMTUsMTA3LjE1N2MyLjI2MSwyNy4xNjEsMjUuMDgsNDcuOTc4LDUyLjMzMyw0Ny43MDlsMS4wNjEtMC4wMWMzMC4yMjgtMC4yOTgsNTMuODEtMjYuMjExLDUxLjMwNi01Ni4zMzZjLTIuOTIxLTM1LjE1LTguODU4LTg5LjgyOC0yMC45MjUtMTI3LjQ5Yy0xNi4yODMtNTAuODIxLTQwLjAxNi05OS40NjMtNzQuNzY2LTE0MC4yNDVjLTMzLjk5My0zOS44OTItNzUuNDU2LTcyLjQwMy0xMTMuMzM4LTEwOC4zNzNjLTQ3LjA5MS00NC43MTMtODQuOTc3LTk1LjE2MS05OC4wMDYtMTU5LjcxOWMtMTAuNTQxLTUyLjIzMS0xMi43ODktMTA1LjIxNS0xNi40NjEtMTU4LjU2Mmw0My4xMTgsNDIuNjA0QzQ4My44NywyNjMuMDUzLDQ5Ny4yMDUsMjY4LjA5OCw1MTAuNTM2LDI2OC4wOTh6JyxcclxuICAgICAgICAgICAgREVMOiAnTTczLjY0MSw0NS45NTdsLTAuMDIxLDAuMjUyYzAsMC4wMzIsMC4wMjEsMC4wNiwwLjAyMSwwLjA4OGMwLDAuMDY1LTAuMDIyLDAuMTI2LTAuMDI2LDAuMTkxbC0yLjY4NSw1NC44NzhINzAuOTFjLTAuMjMxLDQuMzA0LTUuMTY2LDEwLjgxLTMxLjc0OCwxMC44MWMtMjYuNTgsMC0zMS41MDktNi41MDYtMzEuNzQ2LTEwLjgxSDcuNDFMNC43MzEsNDYuNDg4Yy0wLjAwOS0wLjA2LTAuMDI4LTAuMTI2LTAuMDI4LTAuMTkxYzAtMC4wMzIsMC4wMS0wLjA2LDAuMDEtMC4wODhsLTAuMDEtMC4yNTJoMC4wMjhjMC4wOTktMC40NjYsMC4zNjQtMC45MTksMC43ODQtMS4zNTNjMy40MzksMy40NzcsMTcuMTkxLDQuMDUxLDMzLjY0Niw0LjA1MXMzMC4yMjEtMC41NzQsMzMuNjQyLTQuMDUxYzAuNDI2LDAuNDM0LDAuNzExLDAuODg3LDAuNzg0LDEuMzUzSDczLjY0MXogTTc4LjMzNSwyNS4xMDJ2Ni40MDdjMCwxLjMxNi0xLjM0LDIuNTY3LTMuNzE1LDMuNjk2Yy02LjI2NiwyLjkzNi0xOS43NzcsNC45NzUtMzUuNDU5LDQuOTc1Yy0xNS42NjYsMC0yOS4xODktMi4wMzktMzUuNDQyLTQuOTc1QzEuMzMsMzQuMDc1LDAsMzIuODI1LDAsMzEuNTA5di02LjQwN2MwLTMuMzc0LDguNjgxLTYuMjg2LDIxLjM1OS03LjcyNFYzLjkyOWMwLTIuMTYsMS43NjgtMy45MjksMy45My0zLjkyOWgyNi4zMTRjMi4xNjQsMCwzLjkzOCwxLjc3MywzLjkzOCwzLjkzOHYxMy4yOTZDNjguOTgsMTguNjA2LDc4LjMzMywyMS42MTEsNzguMzM1LDI1LjEwMnogTTQ4LjQxNiwxMS4zOTVjMC0yLjM0OC0wLjMyMS00LjI3LTAuNzE1LTQuMjdjLTAuMzkzLDAtMi42NDEsMC00Ljk3OSwwaC04LjU0NWMtMi4zNTIsMC00LjU5MiwwLTQuOTg5LDBjLTAuMzg4LDAtMC43MTQsMS45MjItMC43MTQsNC4yN3Y1LjM2N2wxLjA4My0wLjA2NWMzLjA2Ny0wLjE3Myw2LjI4Ni0wLjI3LDkuNTk1LTAuMjcxYzMuMjAyLDAsNi4yOTIsMC4wOTgsOS4yNjQsMC4yNTJWMTEuMzk1eidcclxuICAgICAgICB9O1xyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgT3BlcmF0aW9uTm9kZS5vcGljb25zID0ge1xyXG4gICAgICAgICAgICBTVFJBSUdIVDogJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQXdBQUFBTUNBWUFBQUJXZFZ6bkFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVFdsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTjNXSlAzRmo3ZjkyVVBWa0xZOExHWGJJRUFJaU9zQ01nUVdhSVFrZ0JoaEJBU1FNV0ZpQXBXRkJVUm5FaFZ4SUxWQ2tpZGlPS2dLTGhuUVlxSVdvdFZYRGp1SDl5bnRYMTY3KzN0KzlmN3ZPZWM1L3pPZWM4UGdCRVNKcEhtb21vQU9WS0ZQRHJZSDQ5UFNNVEp2WUFDRlVqZ0JDQVE1c3ZDWndYRkFBRHdBM2w0Zm5Td1Avd0JyMjhBQWdCdzFTNGtFc2ZoLzRPNlVDWlhBQ0NSQU9BaUV1Y0xBWkJTQU1ndVZNZ1VBTWdZQUxCVHMyUUtBSlFBQUd4NWZFSWlBS29OQU96MFNUNEZBTmlwazl3WEFOaWlIS2tJQUkwQkFKa29SeVFDUUxzQVlGV0JVaXdDd01JQW9LeEFJaTRFd0s0QmdGbTJNa2NDZ0wwRkFIYU9XSkFQUUdBQWdKbENMTXdBSURnQ0FFTWVFODBESUV3RG9ERFN2K0NwWDNDRnVFZ0JBTURMbGMyWFM5SXpGTGlWMEJwMzh2RGc0aUhpd215eFFtRVhLUkJtQ2VRaW5KZWJJeE5JNXdOTXpnd0FBQnI1MGNIK09EK1E1K2JrNGVabTUyenY5TVdpL212d2J5SStJZkhmL3J5TUFnUUFFRTdQNzlwZjVlWFdBM0RIQWJCMXYydXBXd0RhVmdCbzMvbGRNOXNKb0ZvSzBIcjVpM2s0L0VBZW5xRlF5RHdkSEFvTEMrMGxZcUc5TU9PTFB2OHo0Vy9naTM3Mi9FQWUvdHQ2OEFCeG1rQ1pyY0NqZy8xeFlXNTJybEtPNThzRVFqRnU5K2NqL3NlRmYvMk9LZEhpTkxGY0xCV0s4VmlKdUZBaVRjZDV1VktSUkNISmxlSVM2WDh5OFIrVy9RbVRkdzBBcklaUHdFNjJCN1hMYk1CKzdnRUNpdzVZMG5ZQVFIN3pMWXdhQzVFQUVHYzBNbm4zQUFDVHYvbVBRQ3NCQU0yWHBPTUFBTHpvR0Z5b2xCZE14Z2dBQUVTZ2dTcXdRUWNNd1JTc3dBNmN3UjI4d0JjQ1lRWkVRQXdrd0R3UVFnYmtnQndLb1JpV1FSbFV3RHJZQkxXd0F4cWdFWnJoRUxUQk1UZ041K0FTWElIcmNCY0dZQmlld2hpOGhna0VRY2dJRTJFaE9vZ1JZbzdZSXM0SUY1bU9CQ0poU0RTU2dLUWc2WWdVVVNMRnlIS2tBcWxDYXBGZFNDUHlMWElVT1kxY1FQcVEyOGdnTW9yOGlyeEhNWlNCc2xFRDFBSjFRTG1vSHhxS3hxQnowWFEwRDEyQWxxSnIwUnEwSGoyQXRxS24wVXZvZFhRQWZZcU9ZNERSTVE1bWpObGhYSXlIUldDSldCb214eFpqNVZnMVZvODFZeDFZTjNZVkc4Q2VZZThJSkFLTGdCUHNDRjZFRU1Kc2dwQ1FSMWhNV0VPb0pld2p0Qks2Q0ZjSmc0UXh3aWNpazZoUHRDVjZFdm5FZUdJNnNaQllScXdtN2lFZUlaNGxYaWNPRTErVFNDUU95WkxrVGdvaEpaQXlTUXRKYTBqYlNDMmtVNlErMGhCcG5Fd202NUJ0eWQ3a0NMS0FyQ0NYa2JlUUQ1QlBrdnZKdytTM0ZEckZpT0pNQ2FJa1VxU1VFa28xWlQvbEJLV2ZNa0tab0twUnphbWUxQWlxaURxZldrbHRvSFpRTDFPSHFSTTBkWm9selpzV1E4dWtMYVBWMEpwcFoybjNhQy9wZExvSjNZTWVSWmZRbDlKcjZBZnA1K21EOUhjTURZWU5nOGRJWWlnWmF4bDdHYWNZdHhrdm1VeW1CZE9YbWNoVU1OY3lHNWxubUErWWIxVllLdllxZkJXUnloS1ZPcFZXbFg2VjU2cFVWWE5WUDlWNXFndFVxMVVQcTE1V2ZhWkdWYk5RNDZrSjFCYXIxYWtkVmJ1cE5xN09VbmRTajFEUFVWK2p2bC85Z3ZwakRiS0doVWFnaGtpalZHTzN4aG1OSVJiR01tWHhXRUxXY2xZRDZ5eHJtRTFpVzdMNTdFeDJCZnNiZGk5N1RGTkRjNnBtckdhUlpwM21jYzBCRHNheDRQQTUyWnhLemlIT0RjNTdMUU10UHkyeDFtcXRacTErclRmYWV0cSsybUx0Y3UwVzdldmE3M1Z3blVDZExKMzFPbTA2OTNVSnVqYTZVYnFGdXR0MXorbyswMlByZWVrSjljcjFEdW5kMFVmMWJmU2o5UmZxNzlidjBSODNNRFFJTnBBWmJERTRZL0RNa0dQb2E1aHB1Tkh3aE9Hb0VjdG91cEhFYUtQUlNhTW51Q2J1aDJmak5YZ1hQbWFzYnh4aXJEVGVaZHhyUEdGaWFUTGJwTVNreGVTK0tjMlVhNXBtdXRHMDAzVE16TWdzM0t6WXJNbnNqam5Wbkd1ZVliN1p2TnY4allXbFJaekZTb3MyaThlVzJwWjh5d1dXVFpiM3JKaFdQbFo1VnZWVzE2eEoxbHpyTE90dDFsZHNVQnRYbXd5Yk9wdkx0cWl0bTYzRWRwdHQzeFRpRkk4cDBpbjFVMjdhTWV6ODdBcnNtdXdHN1RuMllmWWw5bTMyengzTUhCSWQxanQwTzN4eWRIWE1kbXh3dk91azRUVERxY1NwdytsWFp4dG5vWE9kOHpVWHBrdVF5eEtYZHBjWFUyMm5pcWR1bjNyTGxlVWE3cnJTdGRQMW81dTdtOXl0MlczVTNjdzl4WDJyKzAwdW14dkpYY005NzBIMDhQZFk0bkhNNDUybm02ZkM4NURuTDE1MlhsbGUrNzBlVDdPY0pwN1dNRzNJMjhSYjRMM0xlMkE2UGoxbCtzN3BBejdHUGdLZmVwK0h2cWErSXQ4OXZpTisxbjZaZmdmOG52czcrc3Y5ai9pLzRYbnlGdkZPQldBQndRSGxBYjJCR29HekEyc0RId1NaQktVSE5RV05CYnNHTHd3K0ZVSU1DUTFaSDNLVGI4QVg4aHY1WXpQY1p5eWEwUlhLQ0owVldodjZNTXdtVEI3V0VZNkd6d2pmRUg1dnB2bE02Y3kyQ0lqZ1IyeUl1QjlwR1prWCtYMFVLU295cWk3cVViUlRkSEYwOXl6V3JPUlorMmU5anZHUHFZeTVPOXRxdG5KMlo2eHFiRkpzWSt5YnVJQzRxcmlCZUlmNFJmR1hFblFUSkFudGllVEUyTVE5aWVOekF1ZHNtak9jNUpwVWxuUmpydVhjb3JrWDV1bk95NTUzUEZrMVdaQjhPSVdZRXBleVArV0RJRUpRTHhoUDVhZHVUUjBUOG9TYmhVOUZ2cUtOb2xHeHQ3aEtQSkxtblZhVjlqamRPMzFEK21pR1QwWjF4ak1KVDFJcmVaRVprcmtqODAxV1JOYmVyTS9aY2RrdE9aU2NsSnlqVWcxcGxyUXIxekMzS0xkUFppc3JrdzNrZWVadHlodVRoOHIzNUNQNWMvUGJGV3lGVE5HanRGS3VVQTRXVEMrb0szaGJHRnQ0dUVpOVNGclVNOTltL3VyNUl3dUNGbnk5a0xCUXVMQ3oyTGg0V2ZIZ0lyOUZ1eFlqaTFNWGR5NHhYVks2WkhocDhOSjl5MmpMc3BiOVVPSllVbFh5YW5uYzhvNVNnOUtscFVNcmdsYzBsYW1VeWN0dXJ2UmF1V01WWVpWa1ZlOXFsOVZiVm44cUY1VmZySENzcUs3NHNFYTQ1dUpYVGwvVmZQVjViZHJhM2txM3l1M3JTT3VrNjI2czkxbS9yMHE5YWtIVjBJYndEYTBiOFkzbEcxOXRTdDUwb1hwcTlZN050TTNLelFNMVlUWHRXOHkyck52eW9UYWo5bnFkZjEzTFZ2MnRxN2UrMlNiYTFyL2RkM3Z6RG9NZEZUdmU3NVRzdkxVcmVGZHJ2VVY5OVc3UzdvTGRqeHBpRzdxLzVuN2R1RWQzVDhXZWozdWxld2YyUmUvcmFuUnZiTnl2djcreUNXMVNObzBlU0RwdzVadUFiOXFiN1pwM3RYQmFLZzdDUWVYQko5K21mSHZqVU9paHpzUGN3ODNmbVgrMzlRanJTSGtyMGpxL2Rhd3RvMjJnUGFHOTcraU1vNTBkWGgxSHZyZi9mdTh4NDJOMXh6V1BWNTZnblNnOThmbmtncFBqcDJTbm5wMU9QejNVbWR4NTkwejhtV3RkVVYyOVowUFBuajhYZE81TXQxLzN5ZlBlNTQ5ZDhMeHc5Q0wzWXRzbHQwdXRQYTQ5UjM1dy9lRklyMXR2NjJYM3krMVhQSzUwOUUzck85SHYwMy82YXNEVmM5ZjQxeTVkbjNtOTc4YnNHN2R1SnQwY3VDVzY5ZmgyOXUwWGR3cnVUTnhkZW85NHIveSsydjNxQi9vUDZuKzAvckZsd0czZytHREFZTS9EV1EvdkRnbUhudjZVLzlPSDRkSkh6RWZWSTBZampZK2RIeDhiRFJxOThtVE9rK0duc3FjVHo4cCtWdjk1NjNPcjU5Lzk0dnRMejFqODJQQUwrWXZQdjY1NXFmTnk3NnVwcnpySEk4Y2Z2TTU1UGZHbS9LM08yMzN2dU8rNjM4ZTlINWtvL0VEK1VQUFIrbVBIcDlCUDl6N25mUDc4TC9lRTgvc2wwcDh6QUFBQUlHTklVazBBQUhvbEFBQ0Fnd0FBK2Y4QUFJRHBBQUIxTUFBQTZtQUFBRHFZQUFBWGI1SmZ4VVlBQUFCUVNVUkJWSGphbEpGQkRvQXdDTUNxSDVlZjF3c2hJZXFHU3pnc3RFQUFsYThBQXJERlNuaVRUdmJQL2x0WHYxS0k2alNCMjNoVHVISi80SWV3ZzVzd2dVdVl3c25PWVpVajk0c2FneU55RHdEYTFobjdaQ09Ld3dBQUFBQkpSVTVFcmtKZ2dnPT0nLFxyXG4gICAgICAgICAgICBKQUdHRUQ6ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUF3QUFBQU1DQVlBQUFCV2RWem5BQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1RXbERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk4zV0pQM0ZqN2Y5MlVQVmtMWThMR1hiSUVBSWlPc0NNZ1FXYUlRa2dCaGhCQVNRTVdGaUFwV0ZCVVJuRWhWeElMVkNraWRpT0tnS0xoblFZcUlXb3RWWERqdUg5eW50WDE2NyszdCs5Zjd2T2VjNS96T2VjOFBnQkVTSnBIbW9tb0FPVktGUERyWUg0OVBTTVRKdllBQ0ZVamdCQ0FRNXN2Q1p3WEZBQUR3QTNsNGZuU3dQL3dCcjI4QUFnQncxUzRrRXNmaC80TzZVQ1pYQUNDUkFPQWlFdWNMQVpCU0FNZ3VWTWdVQU1nWUFMQlRzMlFLQUpRQUFHeDVmRUlpQUtvTkFPejBTVDRGQU5pcGs5d1hBTmlpSEtrSUFJMEJBSmtvUnlRQ1FMc0FZRldCVWl3Q3dNSUFvS3hBSWk0RXdLNEJnRm0yTWtjQ2dMMEZBSGFPV0pBUFFHQUFnSmxDTE13QUlEZ0NBRU1lRTgwRElFd0RvRERTditDcFgzQ0Z1RWdCQU1ETGxjMlhTOUl6RkxpVjBCcDM4dkRnNGlIaXdteXhRbUVYS1JCbUNlUWluSmViSXhOSTV3Tk16Z3dBQUJyNTBjSCtPRCtRNStiazRlWm01Mnp2OU1XaS9tdndieUkrSWZIZi9yeU1BZ1FBRUU3UDc5cGY1ZVhXQTNESEFiQjF2MnVwV3dEYVZnQm8zL2xkTTlzSm9Gb0swSHI1aTNrNC9FQWVucUZReUR3ZEhBb0xDKzBsWXFHOU1PT0xQdjh6NFcvZ2kzNzIvRUFlL3R0NjhBQnhta0NacmNDamcvMXhZVzUycmxLTzU4c0VRakZ1OStjai9zZUZmLzJPS2RIaU5MRmNMQldLOFZpSnVGQWlUY2Q1dVZLUlJDSEpsZUlTNlg4eThSK1cvUW1UZHcwQXJJWlB3RTYyQjdYTGJNQis3Z0VDaXc1WTBuWUFRSDd6TFl3YUM1RUFFR2MwTW5uM0FBQ1R2L21QUUNzQkFNMlhwT01BQUx6b0dGeW9sQmRNeGdnQUFFU2dnU3F3UVFjTXdSU3N3QTZjd1IyOHdCY0NZUVpFUUF3a3dEd1FRZ2JrZ0J3S29SaVdRUmxVd0RyWUJMV3dBeHFnRVpyaEVMVEJNVGdONStBU1hJSHJjQmNHWUJpZXdoaThoZ2tFUWNnSUUyRWhPb2dSWW83WUlzNElGNW1PQkNKaFNEU1NnS1FnNllnVVVTTEZ5SEtrQXFsQ2FwRmRTQ1B5TFhJVU9ZMWNRUHFRMjhnZ01vcjhpcnhITVpTQnNsRUQxQUoxUUxtb0h4cUt4cUJ6MFhRMEQxMkFscUpyMFJxMEhqMkF0cUtuMFV2b2RYUUFmWXFPWTREUk1RNW1qTmxoWEl5SFJXQ0pXQm9teHhaajVWZzFWbzgxWXgxWU4zWVZHOENlWWU4SUpBS0xnQlBzQ0Y2RUVNSnNncENRUjFoTVdFT29KZXdqdEJLNkNGY0pnNFF4d2ljaWs2aFB0Q1Y2RXZuRWVHSTZzWkJZUnF3bTdpRWVJWjRsWGljT0UxK1RTQ1FPeVpMa1Rnb2hKWkF5U1F0SmEwamJTQzJrVTZRKzBoQnBuRXdtNjVCdHlkN2tDTEtBckNDWGtiZVFENUJQa3Z2SncrUzNGRHJGaU9KTUNhSWtVcVNVRWtvMVpUL2xCS1dmTWtLWm9LcFJ6YW1lMUFpcWlEcWZXa2x0b0haUUwxT0hxUk0wZFpvbHpac1dROHVrTGFQVjBKcHBaMm4zYUMvcGRMb0ozWU1lUlpmUWw5SnI2QWZwNSttRDlIY01EWVlOZzhkSVlpZ1pheGw3R2FjWXR4a3ZtVXltQmRPWG1jaFVNTmN5RzVsbm1BK1liMVZZS3ZZcWZCV1J5aEtWT3BWV2xYNlY1NnBVVlhOVlA5VjVxZ3RVcTFVUHExNVdmYVpHVmJOUTQ2a0oxQmFyMWFrZFZidXBOcTdPVW5kU2oxRFBVVitqdmwvOWd2cGpEYktHaFVhZ2hraWpWR08zeGhtTklSYkdNbVh4V0VMV2NsWUQ2eXhybUUxaVc3TDU3RXgyQmZzYmRpOTdURk5EYzZwbXJHYVJacDNtY2MwQkRzYXg0UEE1Mlp4S3ppSE9EYzU3TFFNdFB5MngxbXF0WnExK3JUZmFldHErMm1MdGN1MFc3ZXZhNzNWd25VQ2RMSjMxT20wNjkzVUp1amE2VWJxRnV0dDF6K28rMDJQcmVla0o5Y3IxRHVuZDBVZjFiZlNqOVJmcTc5YnYwUjgzTURRSU5wQVpiREU0WS9ETWtHUG9hNWhwdU5Id2hPR29FY3RvdXBIRWFLUFJTYU1udUNidWgyZmpOWGdYUG1hc2J4eGlyRFRlWmR4clBHRmlhVExicE1Ta3hlUytLYzJVYTVwbXV0RzAwM1RNek1nczNLellyTW5zampuVm5HdWVZYjdadk52OGpZV2xSWnpGU29zMmk4ZVcycFo4eXdXV1RaYjNySmhXUGxaNVZ2VlcxNnhKMWx6ckxPdHQxbGRzVUJ0WG13eWJPcHZMdHFpdG02M0VkcHR0M3hUaUZJOHAwaW4xVTI3YU1lejg3QXJzbXV3RzdUbjJZZllsOW0zMnp4M01IQklkMWp0ME8zeHlkSFhNZG14d3ZPdWs0VFREcWNTcHcrbFhaeHRub1hPZDh6VVhwa3VReXhLWGRwY1hVMjJuaXFkdW4zckxsZVVhN3JyU3RkUDFvNXU3bTl5dDJXM1UzY3c5eFgyciswMHVteHZKWGNNOTcwSDA4UGRZNG5ITTQ1Mm5tNmZDODVEbkwxNTJYbGxlKzcwZVQ3T2NKcDdXTUczSTI4UmI0TDNMZTJBNlBqMWwrczdwQXo3R1BnS2ZlcCtIdnFhK0l0ODl2aU4rMW42WmZnZjhudnM3K3N2OWovaS80WG55RnZGT0JXQUJ3UUhsQWIyQkdvR3pBMnNESHdTWkJLVUhOUVdOQmJzR0x3dytGVUlNQ1ExWkgzS1RiOEFYOGh2NVl6UGNaeXlhMFJYS0NKMFZXaHY2TU13bVRCN1dFWTZHendqZkVINXZwdmxNNmN5MkNJamdSMnlJdUI5cEdaa1grWDBVS1NveXFpN3FVYlJUZEhGMDl5eldyT1JaKzJlOWp2R1BxWXk1Tzl0cXRuSjJaNnhxYkZKc1kreWJ1SUM0cXJpQmVJZjRSZkdYRW5RVEpBbnRpZVRFMk1ROWllTnpBdWRzbWpPYzVKcFVsblJqcnVYY29ya1g1dW5PeTU1M1BGazFXWkI4T0lXWUVwZXlQK1dESUVKUUx4aFA1YWR1VFIwVDhvU2JoVTlGdnFLTm9sR3h0N2hLUEpMbW5WYVY5ampkTzMxRCttaUdUMFoxeGpNSlQxSXJlWkVaa3JrajgwMVdSTmJlck0vWmNka3RPWlNjbEp5alVnMXBsclFyMXpDM0tMZFBaaXNya3cza2VlWnR5aHVUaDhyMzVDUDVjL1BiRld5RlROR2p0Rkt1VUE0V1RDK29LM2hiR0Z0NHVFaTlTRnJVTTk5bS91cjVJd3VDRm55OWtMQlF1TEN6MkxoNFdmSGdJcjlGdXhZamkxTVhkeTR4WFZLNlpIaHA4Tko5eTJqTHNwYjlVT0pZVWxYeWFubmM4bzVTZzlLbHBVTXJnbGMwbGFtVXljdHVydlJhdVdNVllaVmtWZTlxbDlWYlZuOHFGNVZmckhDc3FLNzRzRWE0NXVKWFRsL1ZmUFY1YmRyYTNrcTN5dTNyU091azYyNnM5MW0vcjBxOWFrSFYwSWJ3RGEwYjhZM2xHMTl0U3Q1MG9YcHE5WTdOdE0zS3pRTTFZVFh0Vzh5MnJOdnlvVGFqOW5xZGYxM0xWdjJ0cTdlKzJTYmExci9kZDN2ekRvTWRGVHZlNzVUc3ZMVXJlRmRydlVWOTlXN1M3b0xkanhwaUc3cS81bjdkdUVkM1Q4V2VqM3VsZXdmMlJlL3JhblJ2Yk55dnY3K3lDVzFTTm8wZVNEcHc1WnVBYjlxYjdacDN0WEJhS2c3Q1FlWEJKOSttZkh2alVPaWh6c1BjdzgzZm1YKzM5UWpyU0hrcjBqcS9kYXd0bzIyZ1BhRzk3K2lNbzUwZFhoMUh2cmYvZnU4eDQyTjF4eldQVjU2Z25TZzk4Zm5rZ3BQanAyU25ucDFPUHozVW1keDU5MHo4bVd0ZFVWMjlaMFBQbmo4WGRPNU10MS8zeWZQZTU0OWQ4THh3OUNMM1l0c2x0MHV0UGE0OVIzNXcvZUZJcjF0djYyWDN5KzFYUEs1MDlFM3JPOUh2MDMvNmFzRFZjOWY0MXk1ZG4zbTk3OGJzRzdkdUp0MGN1Q1c2OWZoMjl1MFhkd3J1VE54ZGVvOTRyL3krMnYzcUIvb1A2biswL3JGbHdHM2crR0RBWU0vRFdRL3ZEZ21IbnY2VS85T0g0ZEpIekVmVkkwWWpqWStkSHg4YkRScTk4bVRPaytHbnNxY1R6OHArVnY5NTYzT3I1OS85NHZ0THoxajgyUEFMK1l2UHY2NTVxZk55NzZ1cHJ6ckhJOGNmdk01NVBmR20vSzNPMjMzdnVPKzYzOGU5SDVrby9FRCtVUFBSK21QSHA5QlA5ejduZlA3OEwvZUU4L3NsMHA4ekFBQUFJR05JVWswQUFIb2xBQUNBZ3dBQStmOEFBSURwQUFCMU1BQUE2bUFBQURxWUFBQVhiNUpmeFVZQUFBQ2dTVVJCVkhqYWhOR3hEY0pBRElYaEw2R0tSRWRGaVZna0k1QTlhQkVGRFFWRE1BVUxVTEFCRXlEUkk3b0kycU94a0FpWDVDUTNKNy9uMzg5U1N2b0tlNlNmR2hMa1JLV0JWeFRGQkErOHY1OER6ald1NFh6Qk1ZdUVCVTdSZUVmemc5ZHBYc2Y0Rmp0VWY0WWR3U3FjdDcyb0dhUXpucGpsQkdVbmxUbGVtR0dUalM1Y3EyQnVZNGNEcGozcGFYQUw5aE9XSTRlVUl1OTY3T29wSlo4QkFQZFcvdURPdXdyekFBQUFBRWxGVGtTdVFtQ0MnLFxyXG4gICAgICAgICAgICBDVVJWRTogJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQXdBQUFBTUNBWUFBQUJXZFZ6bkFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFLVFdsRFExQlFhRzkwYjNOb2IzQWdTVU5ESUhCeWIyWnBiR1VBQUhqYW5WTjNXSlAzRmo3ZjkyVVBWa0xZOExHWGJJRUFJaU9zQ01nUVdhSVFrZ0JoaEJBU1FNV0ZpQXBXRkJVUm5FaFZ4SUxWQ2tpZGlPS2dLTGhuUVlxSVdvdFZYRGp1SDl5bnRYMTY3KzN0KzlmN3ZPZWM1L3pPZWM4UGdCRVNKcEhtb21vQU9WS0ZQRHJZSDQ5UFNNVEp2WUFDRlVqZ0JDQVE1c3ZDWndYRkFBRHdBM2w0Zm5Td1Avd0JyMjhBQWdCdzFTNGtFc2ZoLzRPNlVDWlhBQ0NSQU9BaUV1Y0xBWkJTQU1ndVZNZ1VBTWdZQUxCVHMyUUtBSlFBQUd4NWZFSWlBS29OQU96MFNUNEZBTmlwazl3WEFOaWlIS2tJQUkwQkFKa29SeVFDUUxzQVlGV0JVaXdDd01JQW9LeEFJaTRFd0s0QmdGbTJNa2NDZ0wwRkFIYU9XSkFQUUdBQWdKbENMTXdBSURnQ0FFTWVFODBESUV3RG9ERFN2K0NwWDNDRnVFZ0JBTURMbGMyWFM5SXpGTGlWMEJwMzh2RGc0aUhpd215eFFtRVhLUkJtQ2VRaW5KZWJJeE5JNXdOTXpnd0FBQnI1MGNIK09EK1E1K2JrNGVabTUyenY5TVdpL212d2J5SStJZkhmL3J5TUFnUUFFRTdQNzlwZjVlWFdBM0RIQWJCMXYydXBXd0RhVmdCbzMvbGRNOXNKb0ZvSzBIcjVpM2s0L0VBZW5xRlF5RHdkSEFvTEMrMGxZcUc5TU9PTFB2OHo0Vy9naTM3Mi9FQWUvdHQ2OEFCeG1rQ1pyY0NqZy8xeFlXNTJybEtPNThzRVFqRnU5K2NqL3NlRmYvMk9LZEhpTkxGY0xCV0s4VmlKdUZBaVRjZDV1VktSUkNISmxlSVM2WDh5OFIrVy9RbVRkdzBBcklaUHdFNjJCN1hMYk1CKzdnRUNpdzVZMG5ZQVFIN3pMWXdhQzVFQUVHYzBNbm4zQUFDVHYvbVBRQ3NCQU0yWHBPTUFBTHpvR0Z5b2xCZE14Z2dBQUVTZ2dTcXdRUWNNd1JTc3dBNmN3UjI4d0JjQ1lRWkVRQXdrd0R3UVFnYmtnQndLb1JpV1FSbFV3RHJZQkxXd0F4cWdFWnJoRUxUQk1UZ041K0FTWElIcmNCY0dZQmlld2hpOGhna0VRY2dJRTJFaE9vZ1JZbzdZSXM0SUY1bU9CQ0poU0RTU2dLUWc2WWdVVVNMRnlIS2tBcWxDYXBGZFNDUHlMWElVT1kxY1FQcVEyOGdnTW9yOGlyeEhNWlNCc2xFRDFBSjFRTG1vSHhxS3hxQnowWFEwRDEyQWxxSnIwUnEwSGoyQXRxS24wVXZvZFhRQWZZcU9ZNERSTVE1bWpObGhYSXlIUldDSldCb214eFpqNVZnMVZvODFZeDFZTjNZVkc4Q2VZZThJSkFLTGdCUHNDRjZFRU1Kc2dwQ1FSMWhNV0VPb0pld2p0Qks2Q0ZjSmc0UXh3aWNpazZoUHRDVjZFdm5FZUdJNnNaQllScXdtN2lFZUlaNGxYaWNPRTErVFNDUU95WkxrVGdvaEpaQXlTUXRKYTBqYlNDMmtVNlErMGhCcG5Fd202NUJ0eWQ3a0NMS0FyQ0NYa2JlUUQ1QlBrdnZKdytTM0ZEckZpT0pNQ2FJa1VxU1VFa28xWlQvbEJLV2ZNa0tab0twUnphbWUxQWlxaURxZldrbHRvSFpRTDFPSHFSTTBkWm9selpzV1E4dWtMYVBWMEpwcFoybjNhQy9wZExvSjNZTWVSWmZRbDlKcjZBZnA1K21EOUhjTURZWU5nOGRJWWlnWmF4bDdHYWNZdHhrdm1VeW1CZE9YbWNoVU1OY3lHNWxubUErWWIxVllLdllxZkJXUnloS1ZPcFZXbFg2VjU2cFVWWE5WUDlWNXFndFVxMVVQcTE1V2ZhWkdWYk5RNDZrSjFCYXIxYWtkVmJ1cE5xN09VbmRTajFEUFVWK2p2bC85Z3ZwakRiS0doVWFnaGtpalZHTzN4aG1OSVJiR01tWHhXRUxXY2xZRDZ5eHJtRTFpVzdMNTdFeDJCZnNiZGk5N1RGTkRjNnBtckdhUlpwM21jYzBCRHNheDRQQTUyWnhLemlIT0RjNTdMUU10UHkyeDFtcXRacTErclRmYWV0cSsybUx0Y3UwVzdldmE3M1Z3blVDZExKMzFPbTA2OTNVSnVqYTZVYnFGdXR0MXorbyswMlByZWVrSjljcjFEdW5kMFVmMWJmU2o5UmZxNzlidjBSODNNRFFJTnBBWmJERTRZL0RNa0dQb2E1aHB1Tkh3aE9Hb0VjdG91cEhFYUtQUlNhTW51Q2J1aDJmak5YZ1hQbWFzYnh4aXJEVGVaZHhyUEdGaWFUTGJwTVNreGVTK0tjMlVhNXBtdXRHMDAzVE16TWdzM0t6WXJNbnNqam5Wbkd1ZVliN1p2TnY4allXbFJaekZTb3MyaThlVzJwWjh5d1dXVFpiM3JKaFdQbFo1VnZWVzE2eEoxbHpyTE90dDFsZHNVQnRYbXd5Yk9wdkx0cWl0bTYzRWRwdHQzeFRpRkk4cDBpbjFVMjdhTWV6ODdBcnNtdXdHN1RuMllmWWw5bTMyengzTUhCSWQxanQwTzN4eWRIWE1kbXh3dk91azRUVERxY1NwdytsWFp4dG5vWE9kOHpVWHBrdVF5eEtYZHBjWFUyMm5pcWR1bjNyTGxlVWE3cnJTdGRQMW81dTdtOXl0MlczVTNjdzl4WDJyKzAwdW14dkpYY005NzBIMDhQZFk0bkhNNDUybm02ZkM4NURuTDE1MlhsbGUrNzBlVDdPY0pwN1dNRzNJMjhSYjRMM0xlMkE2UGoxbCtzN3BBejdHUGdLZmVwK0h2cWErSXQ4OXZpTisxbjZaZmdmOG52czcrc3Y5ai9pLzRYbnlGdkZPQldBQndRSGxBYjJCR29HekEyc0RId1NaQktVSE5RV05CYnNHTHd3K0ZVSU1DUTFaSDNLVGI4QVg4aHY1WXpQY1p5eWEwUlhLQ0owVldodjZNTXdtVEI3V0VZNkd6d2pmRUg1dnB2bE02Y3kyQ0lqZ1IyeUl1QjlwR1prWCtYMFVLU295cWk3cVViUlRkSEYwOXl6V3JPUlorMmU5anZHUHFZeTVPOXRxdG5KMlo2eHFiRkpzWSt5YnVJQzRxcmlCZUlmNFJmR1hFblFUSkFudGllVEUyTVE5aWVOekF1ZHNtak9jNUpwVWxuUmpydVhjb3JrWDV1bk95NTUzUEZrMVdaQjhPSVdZRXBleVArV0RJRUpRTHhoUDVhZHVUUjBUOG9TYmhVOUZ2cUtOb2xHeHQ3aEtQSkxtblZhVjlqamRPMzFEK21pR1QwWjF4ak1KVDFJcmVaRVprcmtqODAxV1JOYmVyTS9aY2RrdE9aU2NsSnlqVWcxcGxyUXIxekMzS0xkUFppc3JrdzNrZWVadHlodVRoOHIzNUNQNWMvUGJGV3lGVE5HanRGS3VVQTRXVEMrb0szaGJHRnQ0dUVpOVNGclVNOTltL3VyNUl3dUNGbnk5a0xCUXVMQ3oyTGg0V2ZIZ0lyOUZ1eFlqaTFNWGR5NHhYVks2WkhocDhOSjl5MmpMc3BiOVVPSllVbFh5YW5uYzhvNVNnOUtscFVNcmdsYzBsYW1VeWN0dXJ2UmF1V01WWVpWa1ZlOXFsOVZiVm44cUY1VmZySENzcUs3NHNFYTQ1dUpYVGwvVmZQVjViZHJhM2txM3l1M3JTT3VrNjI2czkxbS9yMHE5YWtIVjBJYndEYTBiOFkzbEcxOXRTdDUwb1hwcTlZN050TTNLelFNMVlUWHRXOHkyck52eW9UYWo5bnFkZjEzTFZ2MnRxN2UrMlNiYTFyL2RkM3Z6RG9NZEZUdmU3NVRzdkxVcmVGZHJ2VVY5OVc3UzdvTGRqeHBpRzdxLzVuN2R1RWQzVDhXZWozdWxld2YyUmUvcmFuUnZiTnl2djcreUNXMVNObzBlU0RwdzVadUFiOXFiN1pwM3RYQmFLZzdDUWVYQko5K21mSHZqVU9paHpzUGN3ODNmbVgrMzlRanJTSGtyMGpxL2Rhd3RvMjJnUGFHOTcraU1vNTBkWGgxSHZyZi9mdTh4NDJOMXh6V1BWNTZnblNnOThmbmtncFBqcDJTbm5wMU9QejNVbWR4NTkwejhtV3RkVVYyOVowUFBuajhYZE81TXQxLzN5ZlBlNTQ5ZDhMeHc5Q0wzWXRzbHQwdXRQYTQ5UjM1dy9lRklyMXR2NjJYM3krMVhQSzUwOUUzck85SHYwMy82YXNEVmM5ZjQxeTVkbjNtOTc4YnNHN2R1SnQwY3VDVzY5ZmgyOXUwWGR3cnVUTnhkZW85NHIveSsydjNxQi9vUDZuKzAvckZsd0czZytHREFZTS9EV1EvdkRnbUhudjZVLzlPSDRkSkh6RWZWSTBZampZK2RIeDhiRFJxOThtVE9rK0duc3FjVHo4cCtWdjk1NjNPcjU5Lzk0dnRMejFqODJQQUwrWXZQdjY1NXFmTnk3NnVwcnpySEk4Y2Z2TTU1UGZHbS9LM08yMzN2dU8rNjM4ZTlINWtvL0VEK1VQUFIrbVBIcDlCUDl6N25mUDc4TC9lRTgvc2wwcDh6QUFBQUlHTklVazBBQUhvbEFBQ0Fnd0FBK2Y4QUFJRHBBQUIxTUFBQTZtQUFBRHFZQUFBWGI1SmZ4VVlBQUFDYVNVUkJWSGphak5BOURnRUJFSWJoWjBVVW9oZVJLRjFCcTNVZUYxaVZRcVZRYVNRTzRnQ2k1QUlTalVZcGhORXN5U2E3ZGllWllyN00rODJQaUZDV1NCRzUvQWNVUVEzVjBjYjdXOVFCdXJoZ0JzMGF3QWluaUVpVEpGRzEvekRiZmZyVEtvQU43dWhWQXBoa3h5NXlla256R0RjYzBDb0ZNTUFTVHh6Ukx6QXp4eHA3dlBEQUNwMmk2VW5tZHMwY2Q5aEd4TG5zeDU4QkFHOGMzcFpwYk04L0FBQUFBRWxGVGtTdVFtQ0MnLFxyXG4gICAgICAgICAgICBERUw6ICdNNzMuNjQxLDQ1Ljk1N2wtMC4wMjEsMC4yNTJjMCwwLjAzMiwwLjAyMSwwLjA2LDAuMDIxLDAuMDg4YzAsMC4wNjUtMC4wMjIsMC4xMjYtMC4wMjYsMC4xOTFsLTIuNjg1LDU0Ljg3OEg3MC45MWMtMC4yMzEsNC4zMDQtNS4xNjYsMTAuODEtMzEuNzQ4LDEwLjgxYy0yNi41OCwwLTMxLjUwOS02LjUwNi0zMS43NDYtMTAuODFINy40MUw0LjczMSw0Ni40ODhjLTAuMDA5LTAuMDYtMC4wMjgtMC4xMjYtMC4wMjgtMC4xOTFjMC0wLjAzMiwwLjAxLTAuMDYsMC4wMS0wLjA4OGwtMC4wMS0wLjI1MmgwLjAyOGMwLjA5OS0wLjQ2NiwwLjM2NC0wLjkxOSwwLjc4NC0xLjM1M2MzLjQzOSwzLjQ3NywxNy4xOTEsNC4wNTEsMzMuNjQ2LDQuMDUxczMwLjIyMS0wLjU3NCwzMy42NDItNC4wNTFjMC40MjYsMC40MzQsMC43MTEsMC44ODcsMC43ODQsMS4zNTNINzMuNjQxeiBNNzguMzM1LDI1LjEwMnY2LjQwN2MwLDEuMzE2LTEuMzQsMi41NjctMy43MTUsMy42OTZjLTYuMjY2LDIuOTM2LTE5Ljc3Nyw0Ljk3NS0zNS40NTksNC45NzVjLTE1LjY2NiwwLTI5LjE4OS0yLjAzOS0zNS40NDItNC45NzVDMS4zMywzNC4wNzUsMCwzMi44MjUsMCwzMS41MDl2LTYuNDA3YzAtMy4zNzQsOC42ODEtNi4yODYsMjEuMzU5LTcuNzI0VjMuOTI5YzAtMi4xNiwxLjc2OC0zLjkyOSwzLjkzLTMuOTI5aDI2LjMxNGMyLjE2NCwwLDMuOTM4LDEuNzczLDMuOTM4LDMuOTM4djEzLjI5NkM2OC45OCwxOC42MDYsNzguMzMzLDIxLjYxMSw3OC4zMzUsMjUuMTAyeiBNNDguNDE2LDExLjM5NWMwLTIuMzQ4LTAuMzIxLTQuMjctMC43MTUtNC4yN2MtMC4zOTMsMC0yLjY0MSwwLTQuOTc5LDBoLTguNTQ1Yy0yLjM1MiwwLTQuNTkyLDAtNC45ODksMGMtMC4zODgsMC0wLjcxNCwxLjkyMi0wLjcxNCw0LjI3djUuMzY3bDEuMDgzLTAuMDY1YzMuMDY3LTAuMTczLDYuMjg2LTAuMjcsOS41OTUtMC4yNzFjMy4yMDIsMCw2LjI5MiwwLjA5OCw5LjI2NCwwLjI1MlYxMS4zOTV6J1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJCYXNlKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZvcmJpZEVkaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJPdGhlcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIE9wZXJhdGlvbk5vZGUucHJvdG90eXBlLnJlbmRlckJhc2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNyZWF0ZU9wZXJhdGlvbigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBPcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5jcmVhdGVPcGVyYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgbWUgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMudmlydHVhbFJlY3QgPSBuZXcgZ3JhcGhpYy5Qb2x5bGluZSh7IHN0eWxlOiB7IGxpbmVEYXNoOiBbMl0gfSB9KTtcclxuICAgICAgICB0aGlzLnZpcnR1YWxSZWN0LmlzU2VsZkNvbXB1dGVQb3MgPSB0cnVlOyAgLy8g6Ieq5bex6K6h566X5L2N572uXHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy52aXJ0dWFsUmVjdCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgaWYgKHRoaXMubm9kZS5vcGVyYXRpb25JY29ucykge1xyXG4gICAgICAgICAgICB6clV0aWwuZWFjaCh0aGlzLm5vZGUub3BlcmF0aW9uSWNvbnMsIGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIC8v5qOA5p+l5piv5ZCm5piv5YaF572u5Zu+5qCHXHJcbiAgICAgICAgICAgICAgICB2YXIgb3BJY29uSW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKE9wZXJhdGlvbk5vZGUub3BpY29uc1tpdGVtLm5hbWUgKyBcIlwiXSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mb3JiaWRFZGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ubmFtZSA9PSBcIkRFTFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5Z6D5Zy+5qG2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0MSA9IHsgeDogMCwgeTogMCwgd2lkdGg6IDEwLCBoZWlnaHQ6IDE1IH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlID0gZ3JhcGhpYy5tYWtlUGF0aChPcGVyYXRpb25Ob2RlLm9waWNvbnNbaXRlbS5uYW1lICsgXCJcIl0sIHsgc3R5bGU6IHsgZmlsbDogJyMwMDAwMDAnIH0sejptZS5ub2RlLnorMSB9LCByZWN0MSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0uY2FsbGJhY2spe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2Uub24oXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm5vZGUgPSBtZS5ub2RlOyAgLy8g5bCG5omA6ZmE55qE6IqC54K55Lmf5Lyg6YCS5Ye65Y67XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jYWxsYmFjayhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IE9wZXJhdGlvbk5vZGUuREVMRVRFX0NMSUNLO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWVudi5jYW52YXNTdXBwb3J0ZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAxNSwgaGVpZ2h0OiAxNSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2UgPSBncmFwaGljLm1ha2VQYXRoKE9wZXJhdGlvbk5vZGUub3BpY29uc1tpdGVtLm5hbWUgKyBcIlwiXSwgeyBzdHlsZTogeyBmaWxsOiAnIzAwMDAwMCcgfSxkcmFnZ2FibGU6dHJ1ZSx6Om1lLm5vZGUueisxLGxpbmVUeXBlOiBDb25uZWN0b3JbXCJUWVBFX1wiICsgaXRlbS5uYW1lXSB9LCByZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VVcmwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVXJsLnNyYyA9IE9wZXJhdGlvbk5vZGUub3BpY29uc1tpdGVtLm5hbWUgKyBcIlwiXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlID0gbmV3IGdyYXBoaWMuSW1hZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOmltYWdlVXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6ICdkZWZhdWx0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6MTUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDoxNVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHo6IG1lLm5vZGUueisxLCAvL3pJbmRleCDnva7kuo7mnIDpq5hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lVHlwZTogQ29ubmVjdG9yW1wiVFlQRV9cIiArIGl0ZW0ubmFtZV0gLy/ljLrliIbkuI3lkIznmoTnur/mrrVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgTU9VU0VfRVZFTlRfTkFNRVMgPSBbJ2RyYWdzdGFydCcsICdkcmFnJywgJ2RyYWdlbmQnXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlLm9uKGV2ZU5hbWUsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZGF0YSA9IGl0ZW0ub3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJPcGVyYXRpb25Ob2RlOlwiICsgZXZlTmFtZSArIFwiQXJyb3dcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8v55So5oi36Ieq5a6a5LmJ55qE5Zu+5qCH5pS+5Zyo6L+Z6YeM77yM55So5oi35Lyg6L+b5p2l55qE5Zu+5qCH5Y+q6IO95ZON5bqUY2xpY2vkuovku7bvvIzlhbblroPkuovku7bmmoLkuI3mlK/mjIFcclxuICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZSA9IG5ldyBncmFwaGljLkltYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBpdGVtLmljb25QYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGl0ZW0ud2lkdGggfHwgMTUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGl0ZW0uaGVpZ2h0IHx8IDE1XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHo6bWUubm9kZS56KzEgLy96SW5kZXgg572u5LqO5pyA6auYXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2Uub24oXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubm9kZSA9IG1lLm5vZGU7ICAvLyDlsIbmiYDpmYTnmoToioLngrnkuZ/kvKDpgJLlh7rljrtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY2FsbGJhY2soZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdG9kbyDnlKjmiLfoh6rlrprlm77moIdjbGlja+S6i+S7tuaYr+WQpuimgea0vuWPkeWIsOWklumdolxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2UubmFtZSA9IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgICAgIG1lLmFkZChvcEljb25JbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVmcmVzaFBvc3Rpb24gPSBmdW5jdGlvbihub2RlLG5vZGVSZWN0KSB7XHJcbiAgICAgICAgdmFyIG1lID0gdGhpcztcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgdmFyIHJiUG9pbnQgPSBub2RlUmVjdC5wb2ludHNbMl07IC8v5Y+W5Y+z5LiL6KeS5Z2Q5qCHXHJcbiAgICAgICAgLy8xLuWumuS9jeiZmuahhlxyXG4gICAgICAgIHRoaXMudmlydHVhbFJlY3Quc2V0U2hhcGUoeyBwb2ludHM6IG5vZGVSZWN0LnBvaW50cyB9KTtcclxuICAgICAgICAvLzIu5a6a5L2N5q+P5Liq5bCP5Zu+5qCHXHJcbiAgICAgICAgdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24obm9kZUl0ZW0pIHtcclxuICAgICAgICAgICAgaWYgKCFub2RlSXRlbS5pc1NlbGZDb21wdXRlUG9zKSB7XHJcbiAgICAgICAgICAgICAgICAvLyA4cHjmmK/nrKzkuIDkuKrmk43kvZzmjInpkq7lm77moIfnmoTot53nprsg6Z2g5aSq6L+R5LiN5aW955yLICAgIDIwcHjmmK/mr4/kuKrlm77moIfnmoTpl7TpmpQgIDEwcHjmmK/lm77moIflkJHlgY/nmoTot53nprtcclxuICAgICAgICAgICAgICAgIG5vZGVJdGVtLmF0dHIoXCJwb3NpdGlvblwiLCBbcmJQb2ludFswXSArIDggKyAoaSsrICogMjApLCByYlBvaW50WzFdIC0gMTBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbk90aGVyKG5vZGUsbm9kZVJlY3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICBPcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5yZW5kZXJPdGhlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8v55WZ57uZ5omp5bGV5L2/55SoXHJcbiAgICB9O1xyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVmcmVzaFBvc2l0aW9uT3RoZXIgPSBmdW5jdGlvbihub2RlLG5vZGVSZWN0KSB7XHJcbiAgICAgICAgLy/nlZnnu5nmianlsZXkvb/nlKhcclxuICAgICAgICAvLzMu5a6a5L2N5pW05Liqb3BlcmF0aW9uTm9kZVxyXG4gICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC5pc0JnICYmIG5vZGUucGFyZW50LmlzQmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmF0dHIoXCJwb3NpdGlvblwiLCBbbm9kZVJlY3QueCwgbm9kZVJlY3QueV0pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5hdHRyKFwicG9zaXRpb25cIiwgW25vZGVSZWN0LnggKyBub2RlLnBhcmVudC5wb3NpdGlvblswXStub2RlLnNoYXBlLngsIG5vZGVSZWN0LnkgKyBub2RlLnBhcmVudC5wb3NpdGlvblsxXStub2RlLnNoYXBlLnldKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB6clV0aWwuaW5oZXJpdHMoT3BlcmF0aW9uTm9kZSwgTm9kZSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE9wZXJhdGlvbk5vZGU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL09wZXJhdGlvbk5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiBicG1u6L+e57q/566h55CG57G7XHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL0Nvbm5lY3Rpb25NYW5hZ2VyLmpzXCIpO1xyXG4gICAgdmFyIEJQTU5Nb2RlbCA9IHJlcXVpcmUoXCIuLi9tb2RlbC9CUE1OTW9kZWwuanNcIik7XHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9Qb2ludC5qc1wiKTtcclxuXHJcbiAgICBmdW5jdGlvbiBCcG1uQ29ubmVjdGlvbk1hbmFnZXIoKSB7XHJcbiAgICAgICAgQ29ubmVjdGlvbk1hbmFnZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnN0ZW5jaWxUeXBlID0gXCJTZXF1ZW5jZUZsb3dcIjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66L+e57q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHN0YXJ0Tm9kZSBb5byA5aeL6IqC54K5XVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBlbmROb2RlICAgW+e7k+adn+iKgueCuV1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gdHlwZSAgICAgIFvnsbvlnotdXHJcbiAgICAgKiBAcGFyYW0ge1t0eXBlXX0gW2FwaV0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgW+i/lOWbnui/nue6v11cclxuICAgICAqL1xyXG4gICAgQnBtbkNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0b3JDcmVhdGUgPSBmdW5jdGlvbihzdGFydE5vZGUsIGVuZE5vZGUsIHR5cGUsIGFwaSkge1xyXG4gICAgICAgIHZhciBtb2RlbCA9IG5ldyBCUE1OTW9kZWwoe30pO1xyXG4gICAgICAgIG1vZGVsLnNldChcInN0eWxlLmxpbmVUeXBlXCIsIHR5cGUpO1xyXG4gICAgICAgIG1vZGVsLnNldChcInN0ZW5jaWwudHlwZVwiLCB0aGlzLnN0ZW5jaWxUeXBlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yQ3JlYXRlQnlPcHRpb25zKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgeyBtb2RlbDogbW9kZWwsIGlzRWRpdDogdHJ1ZSwgc3R5bGU6IHsgbGluZVR5cGU6IHR5cGUgfSB9LCBhcGkpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNrm9wZXRpb25zLm1vZGVsIOWPjeW6j+WIl+WMlue6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFydE5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBlbmROb2RlICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBvcHRpb25zICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBhcGkgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBCcG1uQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3RvckNyZWF0ZUJ5T3B0aW9ucyA9IGZ1bmN0aW9uKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgb3B0aW9ucywgYXBpKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBtb2RlbCA9IG9wdGlvbnMubW9kZWw7XHJcbiAgICAgICAgbW9kZWwub3B0aW9uLnRleHQgPSB7XHJcbiAgICAgICAgICAgIHRleHQ6IG1vZGVsLm9wdGlvbi5wcm9wZXJ0aWVzLm5hbWVcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0aW9ucy50ZXh0ID0ge1xyXG4gICAgICAgICAgICB0ZXh0OiBtb2RlbC5vcHRpb24ucHJvcGVydGllcy5uYW1lXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbm5lY3Rvci5zdGFydE5vZGUgPSBzdGFydE5vZGU7XHJcbiAgICAgICAgY29ubmVjdG9yLmVuZE5vZGUgPSBlbmROb2RlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbm5lY3RvcnMucHVzaChjb25uZWN0b3IpO1xyXG5cclxuICAgICAgICAvL+WIpOaWreS4gOS4i3NQb3MsZVBvc1xyXG4gICAgICAgIGNvbm5lY3Rvci5zUG9zID0gbW9kZWwuZ2V0KFwic3R5bGUuc1Bvc1wiKTtcclxuICAgICAgICBjb25uZWN0b3IuZVBvcyA9IG1vZGVsLmdldChcInN0eWxlLmVQb3NcIik7XHJcblxyXG4gICAgICAgIC8v5Yik5pat5LiA5LiLIG1vZGVs6YeM5pyJ5rKh5pyJZG9ja2Vyc++8jOWmguaenOacieWImeiwg+eUqOaehOmAoHBvaW505pWw57uEICDmiJbogIXosIPnlKhyZWZyZXNoQ29ubmVjdG9y6K6h566X5aaC5L2V55S757q/XHJcbiAgICAgICAgdmFyIGRvY2tlcnMgPSBtb2RlbC5nZXQoXCJkb2NrZXJzXCIpO1xyXG4gICAgICAgIGlmIChkb2NrZXJzICYmIGRvY2tlcnMubGVuZ3RoID49IDIpIHtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFBvaW50LmxvYWRBcnJheShkb2NrZXJzKTtcclxuICAgICAgICAgICAgY29ubmVjdG9yLnJlZnJlc2gocG9pbnRzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25uZWN0b3IoY29ubmVjdG9yLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbm5lY3Rvci5jb25Qb2ludHNHcm91cC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIGFyclNwbGl0ID0gZS50YXJnZXQudHlwZS5zcGxpdChDb25uZWN0b3IuU0VQRVJBVE9SKTtcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IGUudGFyZ2V0LmNvbm5lY3RvcjtcclxuICAgICAgICAgICAgaWYgKGFyclNwbGl0WzBdID09PSBDb25uZWN0b3IuU1RBUlRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLnNQb3MgPSBhcnJTcGxpdFsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcnJTcGxpdFswXSA9PT0gQ29ubmVjdG9yLkVORF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IuZVBvcyA9IGFyclNwbGl0WzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoYXQucmVmcmVzaENvbm5lY3Rvcihjb25uZWN0b3IsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiY29uUG9pbnRzR3JvdXA6Y2xpY2tcIjtcclxuICAgICAgICAgICAgcGFyYW1zLmxpbmVOb2RlID0gdGhhdC5zZWxDb25uZWN0b3I7XHJcbiAgICAgICAgICAgIGFwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydkYmxjbGljaycsICdjbGljayddO1xyXG4gICAgICAgIHpyVXRpbC5lYWNoKE1PVVNFX0VWRU5UX05BTUVTLCBmdW5jdGlvbihldmVOYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5vbihcIkNvbm5lY3RvcjpcIiArIGV2ZU5hbWUsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGUudGFyZ2V0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGF0LnNlbENvbm5lY3RvciAhPT0gc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbENvbm5lY3RvciAmJiB0aGF0LnJlZnJlc2hDb25uZWN0b3IodGhhdC5zZWxDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsQ29ubmVjdG9yID0gc2VsZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gZXZlTmFtZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGF0LnNlbENvbm5lY3RvcjtcclxuICAgICAgICAgICAgICAgIGFwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIW9wdGlvbnMuaXNGcm9tTW9kZWwpIHtcclxuICAgICAgICAgICAgLy8xLuiuvue9rui1t+Wni+iKgueCueeahG91dGdvaW5n5pWw57uEIOS4uue6v+auteeahElEXHJcbiAgICAgICAgICAgIHZhciBzdGFydE5vZGVPdXRnb2luZyA9IHN0YXJ0Tm9kZS5tb2RlbC5nZXQoXCJvdXRnb2luZ1wiKTtcclxuICAgICAgICAgICAgc3RhcnROb2RlT3V0Z29pbmcucHVzaChjb25uZWN0b3IucmVzb3VyY2VJZCk7XHJcbiAgICAgICAgICAgIC8vMi7orr7nva7nur/mrrXnmoRvdXRnb2luZ+aVsOe7hCDkuLrnu5PmnZ/oioLngrnnmoRJRFxyXG4gICAgICAgICAgICB2YXIgY29ubmVjdG9yT3V0Z29pbmcgPSBjb25uZWN0b3IubW9kZWwuZ2V0KFwib3V0Z29pbmdcIik7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rvck91dGdvaW5nLnB1c2goZW5kTm9kZS5yZXNvdXJjZUlkKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572u57q/5q6155qE5qih5Z6L5pWw5o2uICAo57G75Z6LIOaWh+WtlylcclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfSBjb25uZWN0b3IgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtIHtbdHlwZV19IG9wdGlvbiAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIEJwbW5Db25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0TW9kZWwgPSBmdW5jdGlvbihjb25uZWN0b3IsIG9wdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgb3JpZ2luTGluZVR5cGUgPSBjb25uZWN0b3IubW9kZWwuZ2V0KFwic3R5bGUubGluZVR5cGVcIik7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5OYW1lID0gY29ubmVjdG9yLm9wdGlvbnMudGV4dC50ZXh0O1xyXG4gICAgICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy50ZXh0LnRleHQgPSBvcHRpb24ucHJvcGVydGllcy5uYW1lO1xyXG4gICAgICAgICAgICBjb25uZWN0b3IubW9kZWwubWVyZ2VPcHRpb24ob3B0aW9uKTtcclxuICAgICAgICAgICAgLy/mloflrZfkuI3kuIDoh7Tml7ZcclxuICAgICAgICAgICAgaWYgKG9yaWdpbk5hbWUgIT0gb3B0aW9uLnByb3BlcnRpZXMubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29ubmVjdG9yKGNvbm5lY3RvciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yi35paw6L+e5o6l57q/XHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBub2RlIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqL1xyXG4gICAgQnBtbkNvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZWZyZXNoTGluZUJ5Tm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb25uZWN0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RvcnNbaV0uc3RhcnROb2RlID09IG5vZGUgfHwgdGhpcy5jb25uZWN0b3JzW2ldLmVuZE5vZGUgPT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29ubmVjdG9yKHRoaXMuY29ubmVjdG9yc1tpXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKEJwbW5Db25uZWN0aW9uTWFuYWdlciwgQ29ubmVjdGlvbk1hbmFnZXIpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQnBtbkNvbm5lY3Rpb25NYW5hZ2VyO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYnBtbi9saWIvbWFuYWdlci9CcG1uQ29ubmVjdGlvbk1hbmFnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDov57nur/nrqHnkIbnsbtcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgTm9kZSA9IHJlcXVpcmUoXCIuLi9Ob2RlXCIpO1xyXG4gICAgdmFyIFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIExvZyA9IHJlcXVpcmUoXCIuLi9Mb2cuanNcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblxyXG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvbk1hbmFnZXIoKSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0b3JzID0gW107IC8v5b2T5YmN55S75biD5omA5pyJ55qE57q/5q61XHJcbiAgICAgICAgdGhpcy5zZWxDb25uZWN0b3IgPSBudWxsOyAvL+W9k+WJjemAieS4reeahOe6v+autVxyXG4gICAgICAgIHRoaXMudGVtcENvbm5lY3RvciA9IG51bGw7IC8v5Li05pe257q/5q61XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva7nur/nmoTkuI3lj6/nvJbovpFcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZm9yYmlkRWRpdCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdG9yRm9yYmlkRWRpdCA9IGZ1bmN0aW9uKGZvcmJpZEVkaXQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29ubmVjdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnNbaV0ub3B0aW9ucy5pc0VkaXQgPSAhZm9yYmlkRWRpdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5riF56m66L+e5o6l57q/XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsZWFyU2VsZWN0Q29uID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbENvbm5lY3RvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25uZWN0b3IodGhpcy5zZWxDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWIoOmZpOi/nuaOpee6v1xyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZVNlbGVjdENvbiA9IGZ1bmN0aW9uKG5vZGUsIF96cikge1xyXG4gICAgICAgICAgICB2YXIgZGVsZXRlTGluZSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29ubmVjdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yc1tpXS5zdGFydE5vZGUgPT0gbm9kZSB8fCB0aGlzLmNvbm5lY3RvcnNbaV0uZW5kTm9kZSA9PSBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8xLuWwhue6vyDmiYDogZTnmoRzdGFydE5vZGXnmoRvdXRnb2luZ+aVsOaNruWIoOmZpFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydE5vZGVPdXRnb2luZyA9IHRoaXMuY29ubmVjdG9yc1tpXS5zdGFydE5vZGUubW9kZWwuZ2V0KFwib3V0Z29pbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB6clV0aWwuaW5kZXhPZihzdGFydE5vZGVPdXRnb2luZywgdGhpcy5jb25uZWN0b3JzW2ldLnJlc291cmNlSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGVPdXRnb2luZy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLzIu5LuOX3py5LiK5Yig6ZmkXHJcbiAgICAgICAgICAgICAgICAgICAgX3pyLnJlbW92ZSh0aGlzLmNvbm5lY3RvcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9ycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsQ29ubmVjdG9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDliKDpmaTpgInlrprnmoTnur9cclxuICAgICAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVMaW5lID0gZnVuY3Rpb24oX3pyKSB7XHJcbiAgICAgICAgLy8xLuWwhue6vyDmiYDogZTnmoRzdGFydE5vZGXnmoRvdXRnb2luZ+aVsOaNruWIoOmZpFxyXG4gICAgICAgIHZhciBzdGFydE5vZGVPdXRnb2luZyA9IHRoaXMuc2VsQ29ubmVjdG9yLnN0YXJ0Tm9kZS5tb2RlbC5nZXQoXCJvdXRnb2luZ1wiKTtcclxuICAgICAgICBpbmRleCA9IHpyVXRpbC5pbmRleE9mKHN0YXJ0Tm9kZU91dGdvaW5nLCB0aGlzLnNlbENvbm5lY3Rvci5yZXNvdXJjZUlkKTtcclxuICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgc3RhcnROb2RlT3V0Z29pbmcuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rvck1hcCkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5nZXRUd29Ob2RlSWQodGhpcy5zZWxDb25uZWN0b3Iuc3RhcnROb2RlLCB0aGlzLnNlbENvbm5lY3Rvci5lbmROb2RlKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JNYXAucmVtb3ZlSXRlbShrZXksIHRoaXMuc2VsQ29ubmVjdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vMi7ku45fenLkuIrliKDpmaRcclxuICAgICAgICBfenIucmVtb3ZlKHRoaXMuc2VsQ29ubmVjdG9yKTtcclxuXHJcblxyXG4gICAgICAgIC8vMy7ku47nur/mlbDmja7kuK3liKDpmaRcclxuICAgICAgICB2YXIgaW5kZXggPSB6clV0aWwuaW5kZXhPZih0aGlzLmNvbm5lY3RvcnMsIHRoaXMuc2VsQ29ubmVjdG9yKTtcclxuICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsQ29ubmVjdG9yID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOmHjeaWsOeUu+e6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBjb25uZWN0b3IgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBmb3JjZVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVmcmVzaENvbm5lY3RvciA9IGZ1bmN0aW9uKGNvbm5lY3RvciwgZm9yY2UpIHtcclxuICAgICAgICAvLyDlj6rmnInpnIDopoHlvLrliLbliLfmlrAgIOaIluiAhSDov57nur/kuLrnqbrvvIg8Minml7Yg5omN6L+b6KGM6YeN5paw6K6h566X6YeN57uYXHJcbiAgICAgICAgaWYgKGZvcmNlIHx8ICghY29ubmVjdG9yLnR1cm5pbmdQb2ludHMpIHx8IChjb25uZWN0b3IudHVybmluZ1BvaW50cy5sZW5ndGggPCAyKSkge1xyXG4gICAgICAgICAgICBpZiAoY29ubmVjdG9yLm1vZGVsICYmIGNvbm5lY3Rvci5tb2RlbC5nZXQoXCJzdHlsZS5saW5lVHlwZVwiKSkgeyBjb25uZWN0b3Iub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9IGNvbm5lY3Rvci5tb2RlbC5nZXQoXCJzdHlsZS5saW5lVHlwZVwiKTsgfVxyXG4gICAgICAgICAgICB2YXIgYXJyU3RhcnRFbmRQb2ludCA9IHRoaXMuZ2V0U3RhcnRFbmRQb2ludChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB2YXIgZXNjYXBlRGlzdGFuY2UgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24gJiYgY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24uZXNjYXBlRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIGVzY2FwZURpc3RhbmNlID0gY29ubmVjdG9yLm9wdGlvbnMucG9zaXRpb24uZXNjYXBlRGlzdGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNvbHV0aW9ucyA9IHRoaXMuY29ubmVjdG9yMlBvaW50cyhjb25uZWN0b3Iub3B0aW9ucy5zdHlsZS5saW5lVHlwZSwgYXJyU3RhcnRFbmRQb2ludFswXSwgYXJyU3RhcnRFbmRQb2ludFsxXSxcclxuICAgICAgICAgICAgICAgIGFyclN0YXJ0RW5kUG9pbnRbMl0sIGFyclN0YXJ0RW5kUG9pbnRbM10sIGVzY2FwZURpc3RhbmNlKTsgLy8gVFlQRV9TVFJBSUdIVCBUWVBFX0pBR0dFRFxyXG5cclxuICAgICAgICAgICAgY29ubmVjdG9yLnJlZnJlc2goc29sdXRpb25zWzBdWzJdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbm5lY3Rvci5jbGVhckhhbmRsZXMoKTsgLy/muIXnqbpoYW5kbGVcclxuICAgIH1cclxuXHJcblxyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFN0YXJ0RW5kUG9pbnQgPSBmdW5jdGlvbihjb25uZWN0b3IpIHtcclxuICAgICAgICB2YXIgc3RhcnROb2RlID0gY29ubmVjdG9yLnN0YXJ0Tm9kZTtcclxuICAgICAgICB2YXIgZW5kTm9kZSA9IGNvbm5lY3Rvci5lbmROb2RlO1xyXG5cclxuICAgICAgICB2YXIgc1JlY3QgPSBzdGFydE5vZGUuZ2V0UmVjdCA/IHN0YXJ0Tm9kZS5nZXRSZWN0KCkuYm91bmRpbmdSZWN0IDogVXRpbC5nZXRSZWN0KHN0YXJ0Tm9kZSkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgIHZhciBzQm91bmRzID0gW051bWJlcihzUmVjdC54KSwgTnVtYmVyKHNSZWN0LnkpLCBOdW1iZXIoc1JlY3QueCkgKyBOdW1iZXIoc1JlY3Qud2lkdGgpLCBOdW1iZXIoc1JlY3QueSkgKyBOdW1iZXIoc1JlY3QuaGVpZ2h0KV07XHJcblxyXG4gICAgICAgIHZhciBlUmVjdCA9IGVuZE5vZGUuZ2V0UmVjdCA/IGVuZE5vZGUuZ2V0UmVjdCgpLmJvdW5kaW5nUmVjdCA6IFV0aWwuZ2V0UmVjdChlbmROb2RlKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgdmFyIGVCb3VuZHMgPSBbTnVtYmVyKGVSZWN0LngpLCBOdW1iZXIoZVJlY3QueSksIE51bWJlcihlUmVjdC54KSArIE51bWJlcihlUmVjdC53aWR0aCksIE51bWJlcihlUmVjdC55KSArIE51bWJlcihlUmVjdC5oZWlnaHQpXTtcclxuXHJcblxyXG4gICAgICAgIHZhciBzQ29ubmVjdG9yUG9pbnQgPSBVdGlsLmdldENvbm5lY3RvclBvaW50cyhzUmVjdCk7XHJcbiAgICAgICAgdmFyIGVDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKGVSZWN0KTtcclxuXHJcbiAgICAgICAgLy/liKTmlq3lpoLmnpzmsqHmnInmjIflrprkvY3nva7nmoTor50sIOWIpOaWreW8gOWni+iKgueCueWcqOe7k+adn+e7k+aenOW3pui+ueWImemHh+eUqCByaWdodC1sZWZ0IOWQpuWImemHh+eUqGxlZnQtcmlnaHRcclxuICAgICAgICBpZiAoIWNvbm5lY3Rvci5zUG9zIHx8ICFjb25uZWN0b3IuZVBvcykge1xyXG4gICAgICAgICAgICBpZiAoc1JlY3QueCA8IGVSZWN0LngpIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5zUG9zID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLmVQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5zUG9zID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IuZVBvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhcnRQb2ludCA9IHRoaXMuY2FsY1BvaW50RXhwcmVzc2lvbihjb25uZWN0b3Iuc1Bvcywgc0Nvbm5lY3RvclBvaW50KTtcclxuICAgICAgICB2YXIgZW5kUG9pbnQgPSB0aGlzLmNhbGNQb2ludEV4cHJlc3Npb24oY29ubmVjdG9yLmVQb3MsIGVDb25uZWN0b3JQb2ludCk7XHJcbiAgICAgICAgcmV0dXJuIFtzdGFydFBvaW50LCBlbmRQb2ludCwgc0JvdW5kcywgZUJvdW5kc107XHJcbiAgICB9XHJcblxyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNhbGNQb2ludEV4cHJlc3Npb24gPSBmdW5jdGlvbihwb3MsIHBvaW50KSB7XHJcbiAgICAgICAgdmFyIHZhcmlhYmxlID0ge1xyXG4gICAgICAgICAgICB0b3A6IHBvaW50LnRvcC54LFxyXG4gICAgICAgICAgICBsZWZ0OiBwb2ludC5sZWZ0LnksXHJcbiAgICAgICAgICAgIHJpZ2h0OiBwb2ludC5yaWdodC55LFxyXG4gICAgICAgICAgICBib3R0b206IHBvaW50LmJvdHRvbS54LFxyXG4gICAgICAgICAgICBjZW50ZXI6IHBvaW50LmNlbnRlci54XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBcIjwlIHByaW50KFwiICsgcG9zICsgXCIpICU+XCI7XHJcbiAgICAgICAgdmFyIHZhbCA9IHBhcnNlSW50KFV0aWwudGVtcGxhdGUoZXhwcmVzc2lvbikodmFyaWFibGUpKTtcclxuICAgICAgICBpZiAocG9zLmluZGV4T2YoXCJ0b3BcIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh2YWwsIHBvaW50LnRvcC55KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBvcy5pbmRleE9mKFwibGVmdFwiKSAhPSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHBvaW50LmxlZnQueCwgdmFsKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBvcy5pbmRleE9mKFwicmlnaHRcIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwb2ludC5yaWdodC54LCB2YWwpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocG9zLmluZGV4T2YoXCJib3R0b21cIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh2YWwsIHBvaW50LmJvdHRvbS55KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBvcy5pbmRleE9mKFwiY2VudGVyXCIpICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodmFsLCBwb2ludC5ib3R0b20ueSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicG9z5Y+C5pWw6ZSZ6K+vXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uuaIluS/ruaUueS4tOaXtue6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFydE5vZGUgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSByRW5kUG9pbnQgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBsaW5lVHlwZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5tYW5hZ2VUZW1wQ29ubmVjdG9yID0gZnVuY3Rpb24oc3RhcnROb2RlLCByRW5kUG9pbnQsIGxpbmVUeXBlKSB7XHJcblxyXG4gICAgICAgIHZhciBzUmVjdCA9IHN0YXJ0Tm9kZS5nZXRSZWN0ID8gc3RhcnROb2RlLmdldFJlY3QoKS5ib3VuZGluZ1JlY3QgOiBVdGlsLmdldFJlY3Qoc3RhcnROb2RlKS5ib3VuZGluZ1JlY3Q7XHJcblxyXG4gICAgICAgIHZhciBzQm91bmRzID0gW3NSZWN0LngsIHNSZWN0LnksIHNSZWN0LnggKyBzUmVjdC53aWR0aCwgc1JlY3QueSArIHNSZWN0LmhlaWdodF07XHJcbiAgICAgICAgdmFyIHNDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKHNSZWN0KTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnRlbXBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy50ZW1wQ29ubmVjdG9yID0gbmV3IENvbm5lY3Rvcih7IGlzRWRpdDogZmFsc2UsIHN0eWxlOiB7IGxpbmVUeXBlOiBsaW5lVHlwZSB9IH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IHRoaXMudGVtcENvbm5lY3RvcjtcclxuICAgICAgICAvL+WIpOaWreWmguaenOayoeacieaMh+WumuS9jee9rueahOivnSwg5Yik5pat5byA5aeL6IqC54K55Zyo57uT5p2f57uT5p6c5bem6L655YiZ6YeH55SoIHJpZ2h0LWxlZnQg5ZCm5YiZ6YeH55SobGVmdC1yaWdodFxyXG4gICAgICAgIGlmIChzUmVjdC54IDwgckVuZFBvaW50LngpIHtcclxuICAgICAgICAgICAgY29ubmVjdG9yLnNQb3MgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5lUG9zID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29ubmVjdG9yLnNQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgY29ubmVjdG9yLmVQb3MgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9IGxpbmVUeXBlO1xyXG4gICAgICAgIHZhciBzb2x1dGlvbnMgPSB0aGlzLmNvbm5lY3RvcjJQb2ludHMobGluZVR5cGUsIHNDb25uZWN0b3JQb2ludFtjb25uZWN0b3Iuc1Bvc10sIHJFbmRQb2ludCxcclxuICAgICAgICAgICAgc0JvdW5kcywgbnVsbCk7IC8vIFRZUEVfU1RSQUlHSFQgVFlQRV9KQUdHRURcclxuXHJcbiAgICAgICAgY29ubmVjdG9yLnJlZnJlc2goc29sdXRpb25zWzBdWzJdKTtcclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yig6Zmk5Li05pe257q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHpyICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZVRlbXBDb25uZWN0b3IgPSBmdW5jdGlvbih6cikge1xyXG4gICAgICAgIGlmICh0aGlzLnRlbXBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgenIucmVtb3ZlKHRoaXMudGVtcENvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgIHRoaXMudGVtcENvbm5lY3RvciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOeul+WHuiDkuKTkuKroioLngrkg5oyH5a6a5Lik5Liq54K55aaC5L2V6IGU57q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHR5cGUgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFydFBvaW50IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZW5kUG9pbnQgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHNCb3VuZHMgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBlQm91bmRzICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0b3IyUG9pbnRzID0gZnVuY3Rpb24odHlwZSwgc3RhcnRQb2ludCwgZW5kUG9pbnQsIHNCb3VuZHMsIGVCb3VuZHMsIGVzY2FwZURpc3RhbmNlKSB7XHJcbiAgICAgICAgdmFyIGZpZ3VyZUVzY2FwZURpc3RhbmNlID0gWzMwLCAzMF07XHJcbiAgICAgICAgaWYgKGVzY2FwZURpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkoZXNjYXBlRGlzdGFuY2UpKSB7XHJcbiAgICAgICAgICAgICAgICBmaWd1cmVFc2NhcGVEaXN0YW5jZSA9IFtlc2NhcGVEaXN0YW5jZSwgZXNjYXBlRGlzdGFuY2VdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmlndXJlRXNjYXBlRGlzdGFuY2UgPSBlc2NhcGVEaXN0YW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTG9nLmdyb3VwKFwiY29ubmVjdGlvbk1hbmFnZXI6IGNvbm5lY3RvcjJQb2ludHNcIik7XHJcblxyXG5cclxuICAgICAgICBMb2cuaW5mbyhcIkNvbm5lY3Rpb25NYW5hZ2VyOiBjb25uZWN0b3IyUG9pbnRzIChcIiArIHR5cGUgKyBcIiwgXCIgKyBzdGFydFBvaW50ICsgXCIsIFwiICsgZW5kUG9pbnQgKyBcIiwgXCIgKyBzQm91bmRzICsgXCIsIFwiICsgZUJvdW5kcyArICcpJyk7XHJcbiAgICAgICAgdmFyIHNvbHV0aW9ucyA9IFtdO1xyXG5cclxuXHJcblxyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUOiAvL+ebtOe6v1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtzdGFydFBvaW50LmNsb25lKCksIGVuZFBvaW50LmNsb25lKCldO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzdHJhaWdodCcsICdzdHJhaWdodCcsIHBvaW50c10pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIENvbm5lY3Rvci5UWVBFX0NVUlZFOiAvL+absue6v1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb25uZWN0b3IuVFlQRV9KQUdHRUQ6IC8v5oqY57q/XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRFeGl0UG9pbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZEV4aXRQb2ludCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9maW5kIHN0YXJ0IGV4aXQgcG9pbnQgIOWvu+aJvuW8gOWni+WHuuWPo1xyXG4gICAgICAgICAgICAgICAgaWYgKHNCb3VuZHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3RlbnRpYWxFeGl0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChzdGFydFBvaW50LngsIHNCb3VuZHNbMV0gLSBmaWd1cmVFc2NhcGVEaXN0YW5jZVswXSkpOyAvL25vcnRoIOWMl1xyXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KHNCb3VuZHNbMl0gKyBmaWd1cmVFc2NhcGVEaXN0YW5jZVswXSwgc3RhcnRQb2ludC55KSk7IC8vZWFzdCAg5LicXHJcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoc3RhcnRQb2ludC54LCBzQm91bmRzWzNdICsgZmlndXJlRXNjYXBlRGlzdGFuY2VbMF0pKTsgLy9zb3V0aCAg5Y2XXHJcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoc0JvdW5kc1swXSAtIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzBdLCBzdGFydFBvaW50LnkpKTsgLy93ZXN0ICDopb9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9waWNrIGNsb3Nlc3QgZXhpdCBwb2ludCAg5a+75om+5LiOIHN0YXJ0UG9pbnQg5pyA6Z2g6L+R55qE5Ye65Y+j54K5XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRFeGl0UG9pbnQgPSBwb3RlbnRpYWxFeGl0c1swXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvdGVudGlhbEV4aXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChVdGlsLmRpc3RhbmNlKHN0YXJ0UG9pbnQsIHBvdGVudGlhbEV4aXRzW2ldKSA8IFV0aWwuZGlzdGFuY2Uoc3RhcnRQb2ludCwgc3RhcnRFeGl0UG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEV4aXRQb2ludCA9IHBvdGVudGlhbEV4aXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL2ZpbmQgZW5kIGV4aXQgcG9pbnQgIOWvu+aJvue7k+adn+WHuuWPo1xyXG4gICAgICAgICAgICAgICAgaWYgKGVCb3VuZHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3RlbnRpYWxFeGl0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChlbmRQb2ludC54LCBlQm91bmRzWzFdIC0gZmlndXJlRXNjYXBlRGlzdGFuY2VbMV0pKTsgLy9ub3J0aFxyXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KGVCb3VuZHNbMl0gKyBmaWd1cmVFc2NhcGVEaXN0YW5jZVsxXSwgZW5kUG9pbnQueSkpOyAvL2Vhc3RcclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChlbmRQb2ludC54LCBlQm91bmRzWzNdICsgZmlndXJlRXNjYXBlRGlzdGFuY2VbMV0pKTsgLy9zb3V0aFxyXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KGVCb3VuZHNbMF0gLSBmaWd1cmVFc2NhcGVEaXN0YW5jZVsxXSwgZW5kUG9pbnQueSkpOyAvL3dlc3RcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9waWNrIGNsb3Nlc3QgZXhpdCBwb2ludCAg5a+75om+5LiOIGVuZFBvaW50IOacgOmdoOi/keeahOWHuuWPo+eCuVxyXG4gICAgICAgICAgICAgICAgICAgIGVuZEV4aXRQb2ludCA9IHBvdGVudGlhbEV4aXRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG90ZW50aWFsRXhpdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWwuZGlzdGFuY2UoZW5kUG9pbnQsIHBvdGVudGlhbEV4aXRzW2ldKSA8IFV0aWwuZGlzdGFuY2UoZW5kUG9pbnQsIGVuZEV4aXRQb2ludCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEV4aXRQb2ludCA9IHBvdGVudGlhbEV4aXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vQmFzaWMgc29sdXRpb24g5pyA5Z+65pys55qE6Kej5Yaz5pa55qGIICAg5Li65YW25LuW6Kej5Yaz5pa55qGI5YGa5YeG5aSHXHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IFtzdGFydFBvaW50XTtcclxuICAgICAgICAgICAgICAgIHZhciBnYXBJbmRleCA9IDA7IC8vdGhlIGluZGV4IG9mIHRoZSBnYXAgKHdoZXJlIGRvIHdlIG5lZWQgdG8gaW5zZXJ0IG5ldyBwb2ludHMpIERPIE5PVCBDSEFOR0UgSVRcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydEV4aXRQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHMucHVzaChzdGFydEV4aXRQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FwSW5kZXggPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVuZEV4aXRQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHMucHVzaChlbmRFeGl0UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcy5wdXNoKGVuZFBvaW50KTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vU08gLSBubyBhZGRpdGlvbmFsIHBvaW50cyAgICAgUzAg6Kej5Yaz5pa55qGIIOS4jea3u+WKoOS7u+S9leeCuSAg5Z+65pys5LiN5Lya6KKr6YeH55SoXHJcbiAgICAgICAgICAgICAgICB2YXIgczAgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMCcsICdzMCcsIHMwXSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1MxICAgUzEg6Kej5Yaz5pa55qGIICDlj6rmnInkuIDkuKrmipjngrlcclxuICAgICAgICAgICAgICAgIHZhciBzMSA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9maXJzdCB2YXJpYW50ICAg56ys5LiA5Liq5Y+Y5L2TIHMxIHMxXzHmlrnmoYggIOaKmOe6v+eCueWcqCBzdGFydEV4aXRQb2ludOeahFgg5LiOIGVuZEV4aXRQb2ludOeahCBZ5L2N572uXHJcbiAgICAgICAgICAgICAgICB2YXIgczFfMSA9IFBvaW50LmNsb25lQXJyYXkoczEpO1xyXG4gICAgICAgICAgICAgICAgczFfMS5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBuZXcgUG9pbnQoczFfMVtnYXBJbmRleF0ueCwgczFfMVtnYXBJbmRleCArIDFdLnkpKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczEnLCAnczFfMScsIHMxXzFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3NlY29uZCB2YXJpYW50ICDnrKzkuozlj5jkvZMgczEgczEtMuaWueahiCAg5oqY57q/54K55ZyoIGVuZEV4aXRQb2ludOeahFgg5LiOICBzdGFydEV4aXRQb2ludOeahFnkvY3nva5cclxuICAgICAgICAgICAgICAgIHZhciBzMV8yID0gUG9pbnQuY2xvbmVBcnJheShzMSk7XHJcbiAgICAgICAgICAgICAgICBzMV8yLnNwbGljZShnYXBJbmRleCArIDEsIDAsIG5ldyBQb2ludChzMV8yW2dhcEluZGV4ICsgMV0ueCwgczFfMltnYXBJbmRleF0ueSkpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMScsICdzMV8yJywgczFfMl0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1MyICBTMiDop6PlhrPmlrnmoYggIOa3u+WKoOS4pOS4quaKmOeCuVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVmFyaWFudCBJICAgczJfMeaWueahiFxyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzEgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzFfMSA9IG5ldyBQb2ludCgoczJfMVtnYXBJbmRleF0ueCArIHMyXzFbZ2FwSW5kZXggKyAxXS54KSAvIDIsIHMyXzFbZ2FwSW5kZXhdLnkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzFfMiA9IG5ldyBQb2ludCgoczJfMVtnYXBJbmRleF0ueCArIHMyXzFbZ2FwSW5kZXggKyAxXS54KSAvIDIsIHMyXzFbZ2FwSW5kZXggKyAxXS55KTtcclxuICAgICAgICAgICAgICAgIHMyXzEuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgczJfMV8xLCBzMl8xXzIpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl8xJywgczJfMV0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgSUkgIHMyXzHmlrnmoYggIDHmipjnur/ngrkgeDogc3RhcnRFeGl0UG9pbnTnmoRYIOS9jee9riB5OiBzdGFydEV4aXRQb2ludOeahHkrZW5kRXhpdFBvaW5055qEeS8yXHJcbiAgICAgICAgICAgICAgICAvLzHmipjnur/ngrkgeDplbmRFeGl0UG9pbnTnmoR4ICB5OnN0YXJ0RXhpdFBvaW5055qEeStlbmRFeGl0UG9pbnTnmoR5LzJcclxuICAgICAgICAgICAgICAgIHZhciBzMl8yID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl8yXzEgPSBuZXcgUG9pbnQoczJfMltnYXBJbmRleF0ueCwgKHMyXzJbZ2FwSW5kZXhdLnkgKyBzMl8yW2dhcEluZGV4ICsgMV0ueSkgLyAyKTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl8yXzIgPSBuZXcgUG9pbnQoczJfMltnYXBJbmRleCArIDFdLngsIChzMl8yW2dhcEluZGV4XS55ICsgczJfMltnYXBJbmRleCArIDFdLnkpIC8gMik7XHJcbiAgICAgICAgICAgICAgICBzMl8yLnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzJfMSwgczJfMl8yKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczInLCAnczJfMicsIHMyXzJdKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9WYXJpYW50IElJSVxyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzMgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgLy9maW5kIHRoZSBhbW91bnQgKHN0b3JlZCBpbiBkZWx0YSkgb2YgcGl4ZWxzIHdlIG5lZWQgdG8gbW92ZSByaWdodCBzbyBubyBpbnRlcnNlY3Rpb24gd2l0aCBhIGZpZ3VyZSB3aWxsIGJlIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIC8vIVNlZTogIC9kb2N1bWVudHMvc3BlY3MvY29ubmVjdGVkX2ZpZ3VyZXNfZGVsdGFzLmpwZyBmaWxlXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGVhc3RFeGl0cyA9IFtzMl8zW2dhcEluZGV4XS54ICsgMjAsIHMyXzNbZ2FwSW5kZXggKyAxXS54ICsgMjBdOyAvL2FkZCBwb2ludHMgWCBjb29yZGluYXRlcyB0byBiZSBhYmxlIHRvIGdlbmVyYXRlIFZhcmlhbnQgSUlJIGV2ZW4gaW4gdGhlIGFic2VuY2Ugb2YgZmlndXJlcyA6cFxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWFzdEV4aXRzLnB1c2goc0JvdW5kc1syXSArIDIwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZUJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVhc3RFeGl0cy5wdXNoKGVCb3VuZHNbMl0gKyAyMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGVhc3RFeGl0ID0gVXRpbC5tYXgoZWFzdEV4aXRzKTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl8zXzEgPSBuZXcgUG9pbnQoZWFzdEV4aXQsIHMyXzNbZ2FwSW5kZXhdLnkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzNfMiA9IG5ldyBQb2ludChlYXN0RXhpdCwgczJfM1tnYXBJbmRleCArIDFdLnkpO1xyXG4gICAgICAgICAgICAgICAgczJfMy5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBzMl8zXzEsIHMyXzNfMik7XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MyJywgJ3MyXzMnLCBzMl8zXSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vVmFyaWFudCBJViAgczJfNOaWueahiFxyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzQgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgLy9maW5kIHRoZSBhbW91bnQgKHN0b3JlZCBpbiBkZWx0YSkgb2YgcGl4ZWxzIHdlIG5lZWQgdG8gbW92ZSB1cCBzbyBubyBpbnRlcnNlY3Rpb24gd2l0aCBhIGZpZ3VyZSB3aWxsIGJlIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIC8vIVNlZTogIC9kb2N1bWVudHMvc3BlY3MvY29ubmVjdGVkX2ZpZ3VyZXNfZGVsdGFzLmpwZyBmaWxlXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5vcnRoRXhpdHMgPSBbczJfNFtnYXBJbmRleF0ueSAtIDIwLCBzMl80W2dhcEluZGV4ICsgMV0ueSAtIDIwXTsgLy9hZGQgcG9pbnRzIHkgY29vcmRpbmF0ZXMgdG8gYmUgYWJsZSB0byBnZW5lcmF0ZSBWYXJpYW50IElJSSBldmVuIGluIHRoZSBhYnNlbmNlIG9mIGZpZ3VyZXMgOnBcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc0JvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcnRoRXhpdHMucHVzaChzQm91bmRzWzFdIC0gMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ydGhFeGl0cy5wdXNoKGVCb3VuZHNbMV0gLSAyMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5vcnRoRXhpdCA9IFV0aWwubWluKG5vcnRoRXhpdHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzRfMSA9IG5ldyBQb2ludChzMl80W2dhcEluZGV4XS54LCBub3J0aEV4aXQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzRfMiA9IG5ldyBQb2ludChzMl80W2dhcEluZGV4ICsgMV0ueCwgbm9ydGhFeGl0KTtcclxuICAgICAgICAgICAgICAgIHMyXzQuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgczJfNF8xLCBzMl80XzIpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl80JywgczJfNF0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgVlxyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzUgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgLy9maW5kIHRoZSBhbW91bnQgKHN0b3JlZCBpbiBkZWx0YSkgb2YgcGl4ZWxzIHdlIG5lZWQgdG8gbW92ZSBsZWZ0IHNvIG5vIGludGVyc2VjdGlvbiB3aXRoIGEgZmlndXJlIHdpbGwgYmUgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgLy8hU2VlOiAgL2RvY3VtZW50cy9zcGVjcy9jb25uZWN0ZWRfZmlndXJlc19kZWx0YXMuanBnIGZpbGVcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgd2VzdEV4aXRzID0gW3MyXzVbZ2FwSW5kZXhdLnggLSAyMCwgczJfNVtnYXBJbmRleCArIDFdLnggLSAyMF07IC8vYWRkIHBvaW50cyB4IGNvb3JkaW5hdGVzIHRvIGJlIGFibGUgdG8gZ2VuZXJhdGUgVmFyaWFudCBJSUkgZXZlbiBpbiB0aGUgYWJzZW5jZSBvZiBmaWd1cmVzIDpwXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB3ZXN0RXhpdHMucHVzaChzQm91bmRzWzBdIC0gMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2VzdEV4aXRzLnB1c2goZUJvdW5kc1swXSAtIDIwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgd2VzdEV4aXQgPSBVdGlsLm1pbih3ZXN0RXhpdHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzVfMSA9IG5ldyBQb2ludCh3ZXN0RXhpdCwgczJfNVtnYXBJbmRleF0ueSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNV8yID0gbmV3IFBvaW50KHdlc3RFeGl0LCBzMl81W2dhcEluZGV4ICsgMV0ueSk7XHJcbiAgICAgICAgICAgICAgICBzMl81LnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzVfMSwgczJfNV8yKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczInLCAnczJfNScsIHMyXzVdKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9WYXJpYW50IFZJXHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNiA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICAvL2ZpbmQgdGhlIGFtb3VudCAoc3RvcmVkIGluIGRlbHRhKSBvZiBwaXhlbHMgd2UgbmVlZCB0byBtb3ZlIGRvd24gc28gbm8gaW50ZXJzZWN0aW9uIHdpdGggYSBmaWd1cmUgd2lsbCBiZSBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAvLyFTZWU6ICAvZG9jdW1lbnRzL3NwZWNzL2Nvbm5lY3RlZF9maWd1cmVzX2RlbHRhcy5qcGcgZmlsZVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzb3V0aEV4aXRzID0gW3MyXzZbZ2FwSW5kZXhdLnkgKyAyMCwgczJfNltnYXBJbmRleCArIDFdLnkgKyAyMF07IC8vYWRkIHBvaW50cyB5IGNvb3JkaW5hdGVzIHRvIGJlIGFibGUgdG8gZ2VuZXJhdGUgVmFyaWFudCBJSUkgZXZlbiBpbiB0aGUgYWJzZW5jZSBvZiBmaWd1cmVzIDpwXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3V0aEV4aXRzLnB1c2goc0JvdW5kc1szXSArIDIwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZUJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvdXRoRXhpdHMucHVzaChlQm91bmRzWzNdICsgMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzb3V0aEV4aXQgPSBVdGlsLm1heChzb3V0aEV4aXRzKTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl82XzEgPSBuZXcgUG9pbnQoczJfNltnYXBJbmRleF0ueCwgc291dGhFeGl0KTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl82XzIgPSBuZXcgUG9pbnQoczJfNltnYXBJbmRleCArIDFdLngsIHNvdXRoRXhpdCk7XHJcbiAgICAgICAgICAgICAgICBzMl82LnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzZfMSwgczJfNl8yKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczInLCAnczJfNicsIHMyXzZdKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vRklMVEVSIHNvbHV0aW9uc1xyXG5cclxuICAgICAgICAgICAgICAgIC8qQWxnb3JpdGhtXHJcbiAgICAgICAgICAgICAgICAgKiAwLiBzb2x1dGlvbnMgYXJlIG9yZGVyZWQgZnJvbSBtaW5pbW11biBuciBvZiBwb2ludHMgdG8gbWF4aW11bSA+OilcclxuICAgICAgICAgICAgICAgICAqIDEuIHJlbW92ZSBhbGwgc29sdXRpb25zIHRoYXQgYXJlIG5vdCBvcnRob2dvbmFsIChtYWlubHkgczAgc29sdXRpb24pXHJcbiAgICAgICAgICAgICAgICAgKiAyLiByZW1vdmUgYWxsIHNvbHV0aW9ucyB0aGF0IGdvIGJhY2t3YXJkICh3ZSB3aWxsIG5vdCBuZWVkIHRoZW0gZXZlcilcclxuICAgICAgICAgICAgICAgICAqIDMuIHJlbW92ZSBhbGwgc29sdXRpb25zIHdpdGggaW50ZXJzZWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICogNC4gcGljayBmaXJzdCBjbGFzcyBvZiBzb2x1dGlvbnMgd2l0aCBzYW1lIG5yIG9mIHBvaW50cyAoZXg6IDIpXHJcbiAgICAgICAgICAgICAgICAgKiA1LiBwaWNrIHRoZSBmaXJzdCBzb2x1dGlvbiB3aXRoIDkwIGRlZ3JlZSBhbmdsZXMgKGxlc3MgdHVybmFyb3VuZHMpXHJcbiAgICAgICAgICAgICAgICAgKiAobm90IGludGVyZXN0ZXRlZCkgc29ydCBieSBsZW5ndGggOnBcclxuICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgIC8vMS4gZmlsdGVyIG5vbiBvcnRvZ29uYWwgc29sdXRpb25zIOWIoOmZpOS4jeaYr+ato+S6pOebtOe6v+eahOaWueahiFxyXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIkZpbHRlciBvcnRob2dvbmFsIHNvbHV0aW9ucy4gSW5pdGlhbCBudW1iZXIgb2Ygc29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3J0aG9nb25hbFNvbHV0aW9uID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBzb2x1dGlvbnMubGVuZ3RoOyBsKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gc29sdXRpb25zW2xdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbC5vcnRob2dvbmFsUGF0aChzb2x1dGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ydGhvZ29uYWxTb2x1dGlvbi5wdXNoKHNvbHV0aW9uc1tsXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zID0gb3J0aG9nb25hbFNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiXFxuXFx0T3J0aG9nb25hbFNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8yLiBmaWx0ZXIgYmFja3dhcmQgc29sdXRpb25zICDov4fmu6Qg5YCS6YCA55qE5pa55qGIXHJcbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZG8gbm90IGFsbG93IHN0YXJ0IGFuZCBlbmQgcG9pbnRzIHRvIGNvaW5jaWRlIC0gaWdub3JlIHRoZW1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRQb2ludC5lcXVhbHMoZW5kUG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiU3RhcnQgYW5kIGVuZCBwb2ludCBjb2luY2lkZS4uLnNraXAgYmFja3dhcmQgc29sdXRpb24uIEkgdGhpbmsgd2Ugd2lsbCBqdXN0IGZhbGwgb24gczAgOilcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJGaWx0ZXIgYmFja3dhcmQgc29sdXRpb25zLiBJbml0aWFsIG51bWJlciBvZiBzb2x1dGlvbnMgPSBcIiArIHNvbHV0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9yd2FyZFNvbHV0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHNvbHV0aW9ucy5sZW5ndGg7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gc29sdXRpb25zW2xdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWwuZm9yd2FyZFBhdGgoc29sdXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZFNvbHV0aW9ucy5wdXNoKHNvbHV0aW9uc1tsXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSB0ZW1wICsgXCJcXG5cXHRcIiArIHNvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucyA9IGZvcndhcmRTb2x1dGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiXFxuXFx0IEZvcndhcmRTb2x1dGlvbnMgPSBcIiArIHNvbHV0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29sdXRpb25zLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIkRpc2NhcmRlZCBzb2x1dGlvbnM6IFwiICsgdGVtcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vMy4gRmlsdGVyIG5vbiBpbnRlcnNlY3Rpbmcgc29sdXRpb25zICDljrvpmaTmsqHmnInkuqTpm4YoKeeahOaWueahiFxyXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIkZpbHRlciBub24gaW50ZXJzZWN0aW5nIHNvbHV0aW9ucy4gSW5pdGlhbCBudW1iZXIgb2Ygc29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9uSW50ZXJzZWN0aW9uU29sdXRpb25zID0gW11cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHNvbHV0aW9ucy5sZW5ndGg7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sdXRpb24gPSBzb2x1dGlvbnNbbF1bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vTG9nLmluZm8oXCJTb2x1dGlvbiBpZD0gXCIgKyBzb2x1dGlvbnNbbF1bMV0gKyAnIG5yIHBvaW50cyA9ICcgKyBzb2x1dGlvbi5sZW5ndGggKyBcIiwgcG9pbnRzID0gXCIgKyBzb2x1dGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnNlY3QgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbm5lckxpbmVzID0gc29sdXRpb24uc2xpY2UoKTsgLy9qdXN0IGEgc2hhbGxvdyBjb3B5XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKklmIGFueSBib3VuZHMganVzdCB0cmltIHRoZSBzb2x1dGlvbi4gU28gd2UgYXZvaWQgdGhlIHN0cmFuZ2UgY2FzZSB3aGVuIGEgY29ubmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKnN0YXJ0ZXMgZnJvbSBhIHBvaW50IG9uIGEgZmlndXJlIGFuZCBlbmRzIGluc2lkZSBvZiB0aGUgc2FtZSBmaWd1cmUsIGJ1dCBub3Qgb24gYSBjb25uZWN0aW9uIHBvaW50Ki9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVCb3VuZHMgfHwgc0JvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pMG5uZXJMaW5lcyA9IGlubmVyTGluZXMuc2xpY2UoMCwgaW5uZXJMaW5lcy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyTGluZXMgPSBpbm5lckxpbmVzLnNsaWNlKDEsIGlubmVyTGluZXMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0xvZy5pbmZvKFwiXFx0IGVCb3VuZHMgcHJlc2VudCxpbm5lckxpbmVzIG5yLiBwb2ludHMgPSBcIiArIGlubmVyTGluZXMubGVuZ3RoICsgXCIsIHBvaW50cyA9IFwiICsgaW5uZXJMaW5lcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9ub3cgdGVzdCBmb3IgaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3QgPSBpbnRlcnNlY3QgfHwgVXRpbC5wb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGUoaW5uZXJMaW5lcywgc0JvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdCA9IGludGVyc2VjdCB8fCBVdGlsLnBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZShpbm5lckxpbmVzLCBlQm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnRlcnNlY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbkludGVyc2VjdGlvblNvbHV0aW9ucy5wdXNoKHNvbHV0aW9uc1tsXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vSWYgYWxsIHNvbHV0aW9ucyBpbnRlcnNlY3QgdGhhbiB0aGlzIGlzIGRlc3RpbnkgIDopIGFuZCBqdXN0IGlnbm9yZSB0aGUgaW50ZXJzZWN0aW9uIGZpbHRlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub25JbnRlcnNlY3Rpb25Tb2x1dGlvbnMubGVuZ3RoICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWFzaWduIHRvIHNvbHV0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSBub25JbnRlcnNlY3Rpb25Tb2x1dGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIlxcblxcdCBub25JbnRlcnNlY3Rpb25Tb2x1dGlvbnMgPSBcIiArIHNvbHV0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLzQuIGdldCBmaXJzdCBjbGFzcyBvZiBzb2x1dGlvbnMgd2l0aCBzYW1lIG5yIG9mIHBvaW50cyDpgInmi6nkuI7nrKzkuIDkuKrmlrnmoYjngrnmlbDkuIDmoLflpJrnmoTmlrnmoYjvvIjlm6DkuLrnrKzkuIDkuKrmlrnmoYjngrnmlbDmnIDlsJHvvIlcclxuICAgICAgICAgICAgICAgIGlmICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXCJHZXQgZmlyc3QgY2xhc3Mgb2Ygc29sdXRpb25zIHdpdGggc2FtZSBuciBvZiBwb2ludHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvbHV0aW9ucy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIlRoaXMgaXMgbm90IHBvc3NpYmxlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0U29sdXRpb24gPSBzb2x1dGlvbnNbMF1bMl07IC8vcGljayBmaXJzdCBzb2x1dGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuck9mUG9pbnRzID0gZmlyc3RTb2x1dGlvbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhbWVOclBvaW50c1NvbHV0aW9uID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgc29sdXRpb25zLmxlbmd0aDsgbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IHNvbHV0aW9uc1tsXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvbHV0aW9uLmxlbmd0aCA9PSBuck9mUG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1lTnJQb2ludHNTb2x1dGlvbi5wdXNoKHNvbHV0aW9uc1tsXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucyA9IHNhbWVOclBvaW50c1NvbHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8qNS4gIOiuoeeul+i3r+W+hOWIhuaVsCDvvIzlj5bmnIDliIbmlbDpq5jnmoRcclxuICAgICAgICAgICAgICAgICBQaWNrIHRoZSBmaXJzdCBzb2x1dGlvbiB3aXRoIDkwIGRlZ3JlZSBhbmdsZXMgKGxlc3MgdHVybmFyb3VuZHMpXHJcbiAgICAgICAgICAgICAgICAgKmluIGNhc2Ugd2UgaGF2ZSBtb3JlIHRoYW4gb25lIHNvbHV0aW9uIGluIG91ciBjbGFzc1xyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwicGljayB0aGUgZmlyc3Qgc29sdXRpb24gd2l0aCA5MCBkZWdyZWUgYW5nbGVzIChsZXNzIHR1cm5hcm91bmRzKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc29sSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgc29sdXRpb25zLmxlbmd0aDsgbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IHNvbHV0aW9uc1tsXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWwuc2NvcmVQYXRoKHNvbHV0aW9uc1tzb2xJbmRleF1bMl0pIDwgVXRpbC5zY29yZVBhdGgoc29sdXRpb25zW2xdWzJdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29sSW5kZXggPSBsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucyA9IFtzb2x1dGlvbnNbc29sSW5kZXhdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1NNT09USElORyBjdXJ2ZVxyXG4gICAgICAgIGlmICh0eXBlID09PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkge1xyXG4gICAgICAgICAgICB0aGlzLnNtb290aEN1cnZlKHNvbHV0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vRU5EIFNNT09USElORyBjdXJ2ZVxyXG5cclxuICAgICAgICBMb2cuZ3JvdXBFbmQoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNvbHV0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc21vb3RoQ3VydmUgPSBmdW5jdGlvbihzb2x1dGlvbnMpIHtcclxuICAgICAgICB2YXIgb3B0aW9uID0gMztcclxuXHJcbiAgICAgICAgc3dpdGNoIChvcHRpb24pIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgLy9kbyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMTogLy9hZGQgaW50ZXJtZWRpYXRlIHBvaW50c1xyXG4gICAgICAgICAgICAgICAgLy9BZGQgdGhlIG1pZGRsZSBwb2ludCBmb3Igc3RhcnQgYW5kIGVuZCBzZWdtZW50IHNvIHRoYXQgd2UgXCJmb3JjZVwiIHRoZVxyXG4gICAgICAgICAgICAgICAgLy9jdXJ2ZSB0byBib3RoIGNvbWUgXCJwZXJwZW5kaWN1bGFyXCIgb24gYm91bmRzIGFuZCBhbHNvIG1ha2UgdGhlIGN1cnZlXHJcbiAgICAgICAgICAgICAgICAvL1wiZmxlZVwiIG1vcmUgZnJvbSBib3VuZHMgKG9uIGV4aXQpXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHNvbHV0aW9ucy5sZW5ndGg7IHMrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2xUdXJuaW5nUG9pbnRzID0gc29sdXRpb25zW3NdWzJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2ZpcnN0IHNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYTEgPSBzb2xUdXJuaW5nUG9pbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhMiA9IHNvbFR1cm5pbmdQb2ludHNbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0TWlkZGxlUG9pbnQgPSBVdGlsLmdldE1pZGRsZShhMSwgYTIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNvbFR1cm5pbmdQb2ludHMuc3BsaWNlKDEsIDAsIHN0YXJ0TWlkZGxlUG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2xhc3Qgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhMyA9IHNvbFR1cm5pbmdQb2ludHNbc29sVHVybmluZ1BvaW50cy5sZW5ndGggLSAyXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYTQgPSBzb2xUdXJuaW5nUG9pbnRzW3NvbFR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZE1pZGRsZVBvaW50ID0gVXRpbC5nZXRNaWRkbGUoYTMsIGE0KTtcclxuICAgICAgICAgICAgICAgICAgICBzb2xUdXJuaW5nUG9pbnRzLnNwbGljZShzb2xUdXJuaW5nUG9pbnRzLmxlbmd0aCAtIDEsIDAsIGVuZE1pZGRsZVBvaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAyOiAvL3JlbW92ZSBwb2ludHNcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc29sdXRpb25zLmxlbmd0aDsgcysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbFR5cGUgPSBzb2x1dGlvbnNbc11bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvbFR5cGUgPT0gJ3MxJyB8fCBzb2xUeXBlID09ICdzMicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvbFR1cm5pbmdQb2ludHMgPSBzb2x1dGlvbnNbc11bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbFR1cm5pbmdQb2ludHMuc3BsaWNlKDEsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2xUdXJuaW5nUG9pbnRzLnNwbGljZShzb2xUdXJuaW5nUG9pbnRzLmxlbmd0aCAtIDIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgLypyZW1vdmUgY29saW5lYXIgcG9pbnQgZm9yIHMxIGFzIGl0IHNlZW1zIHRoYXQgbW9yZSBjb2xpbmVhciBwb2ludHMgZG8gbm90IGxvb2sgZ29vZFxyXG4gICAgICAgICAgICAgICAgICogb24gb3JnYW5pYyBzb2x1dGlvbnMgPjpEKi9cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc29sdXRpb25zLmxlbmd0aDsgcysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbFR5cGUgPSBzb2x1dGlvbnNbc11bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvbFR5cGUgPT0gJ3MxJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sVHVybmluZ1BvaW50cyA9IHNvbHV0aW9uc1tzXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZHVjZWRTb2x1dGlvbiA9IFV0aWwuY29sbGluZWFyUmVkdWN0aW9uKHNvbFR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnNbc11bMl0gPSByZWR1Y2VkU29sdXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfSAvL2VuZCBzd2l0Y2hcclxuXHJcbiAgICB9XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvQ29ubmVjdGlvbk1hbmFnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDml6Xlv5fnsbtcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIExvZyAgPSB7XHJcbiAgICAgICAgTE9HX0xFVkVMX05PTkUgIDogMCxcclxuXHJcbiAgICAgICAgTE9HX0xFVkVMX0RFQlVHIDogMSxcclxuXHJcbiAgICAgICAgTE9HX0xFVkVMX0lORk8gOiAyLFxyXG5cclxuICAgICAgICBMT0dfTEVWRUxfRVJST1IgOiAzLFxyXG5cclxuICAgICAgICBsZXZlbCA6IHRoaXMuTE9HX0xFVkVMX0VSUk9SLFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIGxlc3MgaW1wb3J0YW50IG9mIGFsbCBtZXNzYWdlc1xyXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgLSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWRcclxuICAgICAgICAqKi9cclxuICAgICAgICBkZWJ1ZzogZnVuY3Rpb24gKG1lc3NhZ2Upe1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5sZXZlbCA8PSB0aGlzLkxPR19MRVZFTF9ERUJVRyl7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pbiBGRiBpcyBkZWJ1Z1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlLmRlYnVnID09ICdmdW5jdGlvbicpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNley8vVE9ETzogaW4gSUUgaXMgbG9nXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIFRoZSBjb21tb25seSB1c2VkIGxvZyBtZXNzYWdlXHJcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZFxyXG4gICAgICAgICoqL1xyXG4gICAgICAgIGluZm8gOiBmdW5jdGlvbiAobWVzc2FnZSl7XHJcbiAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxldmVsIDw9IHRoaXMuTE9HX0xFVkVMX0lORk8pe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIHdvcnNlIGtpbmQgb2YgbWVzc2FnZS4gVXN1YWxseSBhIGNyYXNoXHJcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZFxyXG4gICAgICAgICoqL1xyXG4gICAgICAgIGVycm9yIDogZnVuY3Rpb24gKG1lc3NhZ2Upe1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5sZXZlbCA8PSB0aGlzLkxPR19MRVZFTF9FUlJPUil7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqU3RhcnQgZ3JvdXBpbmcgdGhlIGxvZyBtZXNzYWdlc1xyXG4gICAgICAgICAqQHBhcmFtIHtTdHJpbmd9IHRpdGxlIC0gdGhlIHRpdGxlIG9mIHRoZSBncm91cFxyXG4gICAgICAgICAqQHNlZSA8YSBocmVmPVwiaHR0cDovL2dldGZpcmVidWcuY29tL2xvZ2dpbmdcIj5odHRwOi8vZ2V0ZmlyZWJ1Zy5jb20vbG9nZ2luZzwvYT5cclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZ3JvdXAgOiBmdW5jdGlvbih0aXRsZSl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMubGV2ZWwgPD0gdGhpcy5MT0dfTEVWRUxfSU5GTyl7IC8vaWdub3JlIGdyb3VwIGlmIGxldmVsIG5vdCBkZWJ1ZyBvciBpbmZvXHJcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpeyAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqSWYgd2UgZG8gbm90IHRlc3QgZm9yIGdyb3VwKCkgZnVuY3Rpb24geW91IHdpbGwgZ2V0IGFuIGVycm9yIGluIE9wZXJhXHJcbiAgICAgICAgICAgICAgICAgICAgICphcyBPcGVyYSBoYXMgaXQncyBvd24gY29uc29sZS4uLndoaWNoIGRvZXMgbm90IGhhdmUgYSBncm91cCgpIGZ1bmN0aW9uKi9cclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZS5ncm91cCA9PT0gJ2Z1bmN0aW9uJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXAodGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKkVuZHMgY3VycmVudCBtZXNzYWdlIGdyb3VwaW5nKi9cclxuICAgICAgICBncm91cEVuZCA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMubGV2ZWwgPD0gdGhpcy5MT0dfTEVWRUxfSU5GTyl7IC8vaWdub3JlIGdyb3VwIGlmIGxldmVsIG5vdCBkZWJ1ZyBvciBpbmZvXHJcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKklmIHdlIGRvIG5vdCB0ZXN0IGZvciBncm91cEVuZCgpIGZ1bmN0aW9uIHlvdSB3aWxsIGdldCBhbiBlcnJvciBpbiBPcGVyYVxyXG4gICAgICAgICAgICAgICAgICAgICAqYXMgT3BlcmEgaGFzIGl0J3Mgb3duIGNvbnNvbGUuLi53aGljaCBkb2VzIG5vdCBoYXZlIGEgZ3JvdXAoKSBmdW5jdGlvbiovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUuZ3JvdXBFbmQgPT09ICdmdW5jdGlvbicpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLy9Mb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX0RFQlVHOyBcclxuICAgIExvZy5sZXZlbCA9IExvZy5MT0dfTEVWRUxfRVJST1I7IFxyXG4gICAgLy9Mb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX0VSUk9SO1xyXG4gICAgLy9Mb2cubGV2ZWwgPSBMb2cuTE9HX0xFVkVMX05PTkU7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExvZztcclxuICAgIFxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Mb2cuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxyXG4gKiDov57nur/mk43kvZznsbtcclxuICogQGF1dGhvciBtaWFvLmN1bnpoaVxyXG4gKi9cclxuXHJcbiAgICB2YXIgTm9kZSA9IHJlcXVpcmUoXCIuLi9Ob2RlXCIpO1xyXG4gICAgdmFyIFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIGZ1bmN0aW9uIExpbmVPcGVyYXRpb25NYW5hZ2VyKGNvbm5lY3Rpb25NYW5hZ2VyKSB7XHJcbiAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9ucyA9IFtdLFxyXG4gICAgICAgICAgICB0aGlzLmlzRWRpdCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IGNvbm5lY3Rpb25NYW5hZ2VyO1xyXG4gICAgfVxyXG5cclxuICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLnByb3RvdHlwZS5jcmVhdE9wZXJhdGlvbiA9IGZ1bmN0aW9uKGtleSwgb2JqLCBhcGkpIHtcclxuICAgICAgICB2YXIgbGluZU9wZXJhdGlvbiA9IG5ldyBncmFwaGljLkltYWdlKHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGltYWdlOiBvYmouaWNvbixcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBvYmoud2lkdGggfHwgMTUsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG9iai5oZWlnaHQgfHwgMTVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxpbmVPcGVyYXRpb24ua2V5ID0ga2V5O1xyXG4gICAgICAgIGxpbmVPcGVyYXRpb24ub3BlcmF0aW9uID0gdHJ1ZTtcclxuICAgICAgICBsaW5lT3BlcmF0aW9uLmhpZGUoKTtcclxuICAgICAgICBvYmoubGluZU5vZGUuaWNvbnMucHVzaChsaW5lT3BlcmF0aW9uKTtcclxuICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25zLnB1c2gobGluZU9wZXJhdGlvbik7XHJcblxyXG4gICAgICAgIC8v5bCP5Zu+5qCHIOeCueWHu+S6i+S7tiAg5aaC5p6c5pyJ5Zue6LCD5YiZ6LCD55So5Zue6LCD77yM5ZCm5YiZ5rS+5Y+R5LqL5Lu2XHJcbiAgICAgICAgbGluZU9wZXJhdGlvbi5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgaWYgKG9iai5jYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgb2JqLmNhbGxiYWNrKG9iai5saW5lTm9kZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcImNsaWNrXCI7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZWxlbWVudFR5cGUgPSBcIkxpbmVPcGVyYXRpb25JY29uXCI7XHJcbiAgICAgICAgICAgICAgICBhcGkudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbGluZU9wZXJhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuoeeul+Wwj+Wbvuagh+eahOS9jee9ru+8jOW5tuaYvuekulxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBjb25uZWN0b3IgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5wcm90b3R5cGUuYmluZE9wZXJhdGlvbiA9IGZ1bmN0aW9uKGNvbm5lY3Rvcikge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRWRpdCA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwb2ludFBvc2l0aW9uID0gY29ubmVjdG9yLm1pZGRsZSgpO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbm5lY3Rvci5pY29ucy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBsZW5ndGgucHVzaChjb25uZWN0b3IuaWNvbnNbal0uc3R5bGUud2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdG90YWxMZW5ndGggPSAwO1xyXG4gICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgY29ubmVjdG9yLmljb25zLmxlbmd0aDsgbSsrKSB7XHJcbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGxlbmd0aFttXSArIDEwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbm5lY3Rvci5pY29ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY29ubmVjdG9yUG9zaXRpb24gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGk7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yUG9zaXRpb24gKz0gbGVuZ3RoW2tdICsgMTA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29ubmVjdG9yLmljb25zW2ldLmF0dHIoXCJwb3NpdGlvblwiLCBbcG9pbnRQb3NpdGlvblswXSArIGNvbm5lY3RvclBvc2l0aW9uIC0gdG90YWxMZW5ndGggLyAyLCBwb2ludFBvc2l0aW9uWzFdICsgNV0pO1xyXG4gICAgICAgICAgICBjb25uZWN0b3IuaWNvbnNbaV0uc2hvdygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBMaW5lT3BlcmF0aW9uTWFuYWdlci5wcm90b3R5cGUuaGlkZUFsbExpbmVPcGVyYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBmb3IgKHZhciBsaSA9IDA7IGxpIDwgdGhpcy5saW5lT3BlcmF0aW9ucy5sZW5ndGg7IGxpKyspIHtcclxuICAgICAgICAgICAgdmFyIGljb24gPSB0aGlzLmxpbmVPcGVyYXRpb25zW2xpXTtcclxuICAgICAgICAgICAgaWNvbi5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLnByb3RvdHlwZS5hZGRJY29uID0gZnVuY3Rpb24oa2V5LCBvYmosIHpyLCBhcGkpIHtcclxuICAgICAgICAvL+WIpOaWreaYr+Wwj+Wbvuagh+WQpuWtmOWcqCDvvIzlrZjlnKjliJnnm7TmjqXov5Tlm55cclxuICAgICAgICBpZiAob2JqLmxpbmVOb2RlLmljb25zKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxpbmVOb2RlLmljb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqLmxpbmVOb2RlLmljb25zW2ldLmtleSA9PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmRPcGVyYXRpb24ob2JqLmxpbmVOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsaW5lT3BlcmF0aW9uID0gdGhpcy5jcmVhdE9wZXJhdGlvbihrZXksIG9iaiwgYXBpKTtcclxuICAgICAgICB6ci5hZGQobGluZU9wZXJhdGlvbik7XHJcbiAgICAgICAgdGhpcy5iaW5kT3BlcmF0aW9uKG9iai5saW5lTm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmVPcGVyYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgTGluZU9wZXJhdGlvbk1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZUljb25PYmogPSBmdW5jdGlvbihwYXJlbnRaciwgbGluZU5vZGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpY29uOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQXdBQUFBT0JBTUFBQURwaytEZkFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBRnpVa2RDQUs3T0hPa0FBQUF0VUV4VVJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNR2dLRDRBQUFBUGRGSk9Vd0RIL2crYWdFU2o0WTZ6VWlSbmg3bG53YmtBQUFCTFNVUkJWQWpYWTJCZ1lEWmdBSUVubmtDYTdhNWNZR3dDd3drbElPaGhNQkVFZ21JR25sQWdPTURBcHJoUVVHZ0RBNXZXZEpjaVhKUkdSMGRUQWdQelEwRkJTYUJwek1iR0Jnd0FJb1VXM3NRMkVka0FBQUFBU1VWT1JLNUNZSUk9XCIsXHJcbiAgICAgICAgICAgIHdpZHRoOiAxMixcclxuICAgICAgICAgICAgaGVpZ2h0OiAxNCxcclxuICAgICAgICAgICAgbGluZU5vZGU6IGxpbmVOb2RlLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lTm9kZS5pY29ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFpyLnJlbW92ZShsaW5lTm9kZS5pY29uc1tpXSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZGVsZXRlTGluZShwYXJlbnRacik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVBbGxMaW5lT3BlcmF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExpbmVPcGVyYXRpb25NYW5hZ2VyO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9MaW5lT3BlcmF0aW9uTWFuYWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIOi+heWKqee6v+aTjeS9nOexu1xyXG4gKiBAYXV0aG9yIG1pYW8uY3VuemhpXHJcbiAqL1xyXG5cclxuXHR2YXIgTm9kZSA9IHJlcXVpcmUoXCIuLi9Ob2RlXCIpO1xyXG5cdHZhciBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xyXG5cdHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgUG9pbnQgPSByZXF1aXJlKFwiLi4vUG9pbnQuanNcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblxyXG4gICAgdmFyIEd1aWRlbGluZXMgPSB7XHJcbiAgICAgICAgdmlydHVhbFhMaW5lOm51bGwsXHJcbiAgICAgICAgdmlydHVhbFlMaW5lOm51bGwsXHJcbiAgICAgICAgY3JlYXRlR3VpZGVsaW5lczpmdW5jdGlvbih6cil7XHJcbiAgICAgICAgICAgIC8v5Yib5bu6eOi9tOiZmue6v1xyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxYTGluZSA9IG5ldyBncmFwaGljLkxpbmUoe1xyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lRGFzaDogWzVdXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgejogM1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy/liJvlu7pZ6L206Jma57q/XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbFlMaW5lID0gbmV3IGdyYXBoaWMuTGluZSh7XHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVEYXNoOiBbNV1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB6OiAzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB6ci5hZGQodGhpcy52aXJ0dWFsWExpbmUpO1xyXG4gICAgICAgICAgICB6ci5hZGQodGhpcy52aXJ0dWFsWUxpbmUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAganVkZ2VBbGlnbm1lbnQ6ZnVuY3Rpb24obm93UmVjdFBvc2l0aW9uLGRvbUFycmF5LG1heFdpZHRoLG1heEhlaWdodCl7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgLy/lvqrnjq/liKTmlq3msLTlubPlr7npvZBcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGRvbUFycmF5Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm93UmVjdFBvc2l0aW9uWzFdID09IGRvbUFycmF5W2pdLnBvc2l0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC52aXJ0dWFsWExpbmUuYXR0cigncG9zaXRpb24nLCBbMCwgbm93UmVjdFBvc2l0aW9uWzFdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC52aXJ0dWFsWExpbmUuYXR0cihcInNoYXBlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDI6IG1heFdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnZpcnR1YWxYTGluZS5hdHRyKFwic2hhcGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4MjogMFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8v5b6q546v5Yik5pat5Z6C55u05a+56b2QXHJcbiAgICAgICAgICAgIGZvciAodmFyIG0gPSAwLCBsZW4xID0gZG9tQXJyYXkubGVuZ3RoOyBtIDwgbGVuMTsgbSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm93UmVjdFBvc2l0aW9uWzBdID09IGRvbUFycmF5W21dLnBvc2l0aW9uWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC52aXJ0dWFsWUxpbmUuYXR0cigncG9zaXRpb24nLCBbbm93UmVjdFBvc2l0aW9uWzBdLCAwXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC52aXJ0dWFsWUxpbmUuYXR0cihcInNoYXBlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTI6IG1heEhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LnZpcnR1YWxZTGluZS5hdHRyKFwic2hhcGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5MjogMFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBHdWlkZWxpbmVzO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9HdWlkZWxpbmVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxuICAgIC8vcG9seWZpbGwgYmluZFxyXG4gICAgaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xyXG4gICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24ob1RoaXMpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNSBpbnRlcm5hbCBJc0NhbGxhYmxlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcbiAgICAgICAgICAgICAgICBmVG9CaW5kID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGZOT1AgPSBmdW5jdGlvbigpIHt9LFxyXG4gICAgICAgICAgICAgICAgZkJvdW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1AgJiYgb1RoaXMgPyB0aGlzIDogb1RoaXMgfHwgd2luZG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZOT1AucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XHJcbiAgICAgICAgICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZCb3VuZDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vcG9seWZpbGwgcmVtb3ZlXHJcbiAgICBpZiAoISgncmVtb3ZlJyBpbiBFbGVtZW50LnByb3RvdHlwZSkpIHtcclxuICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3BvbHlmaWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMTA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbiAgICByZXF1aXJlKCcuL2dyYXBoaWMnKTtcbiAgICByZXF1aXJlKCcuLi96cmVuZGVyJykucmVnaXN0ZXJQYWludGVyKCd2bWwnLCByZXF1aXJlKCcuL1BhaW50ZXInKSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi92bWwvdm1sLmpzXG4gKiogbW9kdWxlIGlkID0gMTEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9OT1RFLVZNTFxuLy8gVE9ETyBVc2UgcHJveHkgbGlrZSBzdmcgaW5zdGVhZCBvZiBvdmVyd3JpdGUgYnJ1c2ggbWV0aG9kc1xuXG5cbmlmICghcmVxdWlyZSgnLi4vY29yZS9lbnYnKS5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4uL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIENNRCA9IHJlcXVpcmUoJy4uL2NvcmUvUGF0aFByb3h5JykuQ01EO1xuICAgIHZhciBjb2xvclRvb2wgPSByZXF1aXJlKCcuLi90b29sL2NvbG9yJyk7XG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnLi4vY29udGFpbi90ZXh0Jyk7XG4gICAgdmFyIFJlY3RUZXh0ID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9taXhpbi9SZWN0VGV4dCcpO1xuICAgIHZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvRGlzcGxheWFibGUnKTtcbiAgICB2YXIgWkltYWdlID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9JbWFnZScpO1xuICAgIHZhciBUZXh0ID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9UZXh0Jyk7XG4gICAgdmFyIFBhdGggPSByZXF1aXJlKCcuLi9ncmFwaGljL1BhdGgnKTtcblxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvR3JhZGllbnQnKTtcblxuICAgIHZhciB2bWxDb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgY29zID0gTWF0aC5jb3M7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luO1xuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG5cbiAgICB2YXIgYXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xuXG4gICAgdmFyIGNvbW1hID0gJywnO1xuICAgIHZhciBpbWFnZVRyYW5zZm9ybVByZWZpeCA9ICdwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQnO1xuXG4gICAgdmFyIFogPSAyMTYwMDtcbiAgICB2YXIgWjIgPSBaIC8gMjtcblxuICAgIHZhciBaTEVWRUxfQkFTRSA9IDEwMDAwMDtcbiAgICB2YXIgWl9CQVNFID0gMTAwMDtcblxuICAgIHZhciBpbml0Um9vdEVsU3R5bGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7d2lkdGg6MXB4O2hlaWdodDoxcHg7JztcbiAgICAgICAgZWwuY29vcmRzaXplID0gWiArICcsJyAgKyBaO1xuICAgICAgICBlbC5jb29yZG9yaWdpbiA9ICcwLDAnO1xuICAgIH07XG5cbiAgICB2YXIgZW5jb2RlSHRtbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcocykucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gICAgfTtcblxuICAgIHZhciByZ2IyU3RyID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICAgICAgcmV0dXJuICdyZ2IoJyArIFtyLCBnLCBiXS5qb2luKCcsJykgKyAnKSc7XG4gICAgfTtcblxuICAgIHZhciBhcHBlbmQgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgJiYgcGFyZW50ICYmIGNoaWxkLnBhcmVudE5vZGUgIT09IHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkICYmIHBhcmVudCAmJiBjaGlsZC5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldFpJbmRleCA9IGZ1bmN0aW9uICh6bGV2ZWwsIHosIHoyKSB7XG4gICAgICAgIC8vIHog55qE5Y+W5YC86IyD5Zu05Li6IFswLCAxMDAwXVxuICAgICAgICByZXR1cm4gKHBhcnNlRmxvYXQoemxldmVsKSB8fCAwKSAqIFpMRVZFTF9CQVNFICsgKHBhcnNlRmxvYXQoeikgfHwgMCkgKiBaX0JBU0UgKyB6MjtcbiAgICB9O1xuXG4gICAgdmFyIHBhcnNlUGVyY2VudCA9IGZ1bmN0aW9uICh2YWx1ZSwgbWF4VmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sYXN0SW5kZXhPZignJScpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBtYXhWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBQQVRIXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgdmFyIHNldENvbG9yQW5kT3BhY2l0eSA9IGZ1bmN0aW9uIChlbCwgY29sb3IsIG9wYWNpdHkpIHtcbiAgICAgICAgdmFyIGNvbG9yQXJyID0gY29sb3JUb29sLnBhcnNlKGNvbG9yKTtcbiAgICAgICAgb3BhY2l0eSA9ICtvcGFjaXR5O1xuICAgICAgICBpZiAoaXNOYU4ob3BhY2l0eSkpIHtcbiAgICAgICAgICAgIG9wYWNpdHkgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xvckFycikge1xuICAgICAgICAgICAgZWwuY29sb3IgPSByZ2IyU3RyKGNvbG9yQXJyWzBdLCBjb2xvckFyclsxXSwgY29sb3JBcnJbMl0pO1xuICAgICAgICAgICAgZWwub3BhY2l0eSA9IG9wYWNpdHkgKiBjb2xvckFyclszXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZ2V0Q29sb3JBbmRBbHBoYSA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICB2YXIgY29sb3JBcnIgPSBjb2xvclRvb2wucGFyc2UoY29sb3IpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcmdiMlN0cihjb2xvckFyclswXSwgY29sb3JBcnJbMV0sIGNvbG9yQXJyWzJdKSxcbiAgICAgICAgICAgIGNvbG9yQXJyWzNdXG4gICAgICAgIF07XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVGaWxsTm9kZSA9IGZ1bmN0aW9uIChlbCwgc3R5bGUsIHpyRWwpIHtcbiAgICAgICAgLy8gVE9ETyBwYXR0ZXJuXG4gICAgICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcbiAgICAgICAgaWYgKGZpbGwgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gTW9kaWZpZWQgZnJvbSBleGNhbnZhc1xuICAgICAgICAgICAgaWYgKGZpbGwgaW5zdGFuY2VvZiBHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudFR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgZm9jdXMgPSBbMCwgMF07XG4gICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbCBvZmZzZXRcbiAgICAgICAgICAgICAgICB2YXIgc2hpZnQgPSAwO1xuICAgICAgICAgICAgICAgIC8vIHNjYWxlIGZhY3RvciBmb3Igb2Zmc2V0XG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuc2lvbiA9IDE7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB6ckVsLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciByZWN0V2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciByZWN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGwudHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRUeXBlID0gJ2dyYWRpZW50JztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHpyRWwudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcDAgPSBbZmlsbC54ICogcmVjdFdpZHRoLCBmaWxsLnkgKiByZWN0SGVpZ2h0XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAxID0gW2ZpbGwueDIgKiByZWN0V2lkdGgsIGZpbGwueTIgKiByZWN0SGVpZ2h0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDEsIHAxLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IHAxWzBdIC0gcDBbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeSA9IHAxWzFdIC0gcDBbMV07XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihkeCwgZHkpICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGFuZ2xlIHNob3VsZCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlICs9IDM2MDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcnkgc21hbGwgYW5nbGVzIHByb2R1Y2UgYW4gdW5leHBlY3RlZCByZXN1bHQgYmVjYXVzZSB0aGV5IGFyZVxuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0ZWQgdG8gYSBzY2llbnRpZmljIG5vdGF0aW9uIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMWUtNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudFR5cGUgPSAnZ3JhZGllbnRyYWRpYWwnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcDAgPSBbZmlsbC54ICogcmVjdFdpZHRoLCBmaWxsLnkgKiByZWN0SGVpZ2h0XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHpyRWwudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSB6ckVsLnNjYWxlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSByZWN0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSByZWN0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBmb2N1cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBlcmNlbnQgaW4gYm91bmRpbmcgcmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgKHAwWzBdIC0gcmVjdC54KSAvIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHAwWzFdIC0gcmVjdC55KSAvIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMCwgcDAsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aWR0aCAvPSBzY2FsZVswXSAqIFo7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAvPSBzY2FsZVsxXSAqIFo7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaW1lbnNpb24gPSBtYXRoTWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDIgKiAwIC8gZGltZW5zaW9uO1xuICAgICAgICAgICAgICAgICAgICBleHBhbnNpb24gPSAyICogZmlsbC5yIC8gZGltZW5zaW9uIC0gc2hpZnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBzb3J0IHRoZSBjb2xvciBzdG9wcyBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgb2Zmc2V0LFxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBJRSB3b24ndCBpbnRlcnByZXQgaXQgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhciBzdG9wcyA9IGZpbGwuY29sb3JTdG9wcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHN0b3BzLnNvcnQoZnVuY3Rpb24oY3MxLCBjczIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNzMS5vZmZzZXQgLSBjczIub2Zmc2V0O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHN0b3BzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBDb2xvciBhbmQgYWxwaGEgbGlzdCBvZiBmaXJzdCBhbmQgbGFzdCBzdG9wXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yQW5kQWxwaGFMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3AgPSBzdG9wc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yQW5kQWxwaGEgPSBnZXRDb2xvckFuZEFscGhhKHN0b3AuY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnMucHVzaChzdG9wLm9mZnNldCAqIGV4cGFuc2lvbiArIHNoaWZ0ICsgJyAnICsgY29sb3JBbmRBbHBoYVswXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yQW5kQWxwaGFMaXN0LnB1c2goY29sb3JBbmRBbHBoYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yMSA9IGNvbG9yQW5kQWxwaGFMaXN0WzBdWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IyID0gY29sb3JBbmRBbHBoYUxpc3RbMV1bMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5MSA9IGNvbG9yQW5kQWxwaGFMaXN0WzBdWzFdICogc3R5bGUub3BhY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wYWNpdHkyID0gY29sb3JBbmRBbHBoYUxpc3RbMV1bMV0gKiBzdHlsZS5vcGFjaXR5O1xuXG4gICAgICAgICAgICAgICAgICAgIGVsLnR5cGUgPSBncmFkaWVudFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGVsLm1ldGhvZCA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgZWwuZm9jdXMgPSAnMTAwJSc7XG4gICAgICAgICAgICAgICAgICAgIGVsLmFuZ2xlID0gYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNvbG9yID0gY29sb3IxO1xuICAgICAgICAgICAgICAgICAgICBlbC5jb2xvcjIgPSBjb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNvbG9ycyA9IGNvbG9ycy5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gY29sb3JzIGF0dHJpYnV0ZSBpcyB1c2VkLCB0aGUgbWVhbmluZ3Mgb2Ygb3BhY2l0eSBhbmQgbzpvcGFjaXR5MlxuICAgICAgICAgICAgICAgICAgICAvLyBhcmUgcmV2ZXJzZWQuXG4gICAgICAgICAgICAgICAgICAgIGVsLm9wYWNpdHkgPSBvcGFjaXR5MjtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgZ19vXzpvcGFjaXR5ID9cbiAgICAgICAgICAgICAgICAgICAgZWwub3BhY2l0eTIgPSBvcGFjaXR5MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdyYWRpZW50VHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuZm9jdXNwb3NpdGlvbiA9IGZvY3VzLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBDaGFuZ2UgZnJvbSBHcmFkaWVudCBmaWxsIHRvIGNvbG9yIGZpbGxcbiAgICAgICAgICAgICAgICBzZXRDb2xvckFuZE9wYWNpdHkoZWwsIGZpbGwsIHN0eWxlLm9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVTdHJva2VOb2RlID0gZnVuY3Rpb24gKGVsLCBzdHlsZSkge1xuICAgICAgICAvLyBpZiAoc3R5bGUubGluZUpvaW4gIT0gbnVsbCkge1xuICAgICAgICAvLyAgICAgZWwuam9pbnN0eWxlID0gc3R5bGUubGluZUpvaW47XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYgKHN0eWxlLm1pdGVyTGltaXQgIT0gbnVsbCkge1xuICAgICAgICAvLyAgICAgZWwubWl0ZXJsaW1pdCA9IHN0eWxlLm1pdGVyTGltaXQgKiBaO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmIChzdHlsZS5saW5lQ2FwICE9IG51bGwpIHtcbiAgICAgICAgLy8gICAgIGVsLmVuZGNhcCA9IHN0eWxlLmxpbmVDYXA7XG4gICAgICAgIC8vIH1cbiAgICAgICAgaWYgKHN0eWxlLmxpbmVEYXNoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVsLmRhc2hzdHlsZSA9IHN0eWxlLmxpbmVEYXNoLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGUuc3Ryb2tlICE9IG51bGwgJiYgIShzdHlsZS5zdHJva2UgaW5zdGFuY2VvZiBHcmFkaWVudCkpIHtcbiAgICAgICAgICAgIHNldENvbG9yQW5kT3BhY2l0eShlbCwgc3R5bGUuc3Ryb2tlLCBzdHlsZS5vcGFjaXR5KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlRmlsbEFuZFN0cm9rZSA9IGZ1bmN0aW9uICh2bWxFbCwgdHlwZSwgc3R5bGUsIHpyRWwpIHtcbiAgICAgICAgdmFyIGlzRmlsbCA9IHR5cGUgPT0gJ2ZpbGwnO1xuICAgICAgICB2YXIgZWwgPSB2bWxFbC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0eXBlKVswXTtcbiAgICAgICAgLy8gU3Ryb2tlIG11c3QgaGF2ZSBsaW5lV2lkdGhcbiAgICAgICAgaWYgKHN0eWxlW3R5cGVdICE9IG51bGwgJiYgc3R5bGVbdHlwZV0gIT09ICdub25lJyAmJiAoaXNGaWxsIHx8ICghaXNGaWxsICYmIHN0eWxlLmxpbmVXaWR0aCkpKSB7XG4gICAgICAgICAgICB2bWxFbFtpc0ZpbGwgPyAnZmlsbGVkJyA6ICdzdHJva2VkJ10gPSAndHJ1ZSc7XG4gICAgICAgICAgICAvLyBGSVhNRSBSZW1vdmUgYmVmb3JlIHVwZGF0aW5nLCBvciBzZXQgYGNvbG9yc2Agd2lsbCB0aHJvdyBlcnJvclxuICAgICAgICAgICAgaWYgKHN0eWxlW3R5cGVdIGluc3RhbmNlb2YgR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICByZW1vdmUodm1sRWwsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgICAgICBlbCA9IHZtbENvcmUuY3JlYXRlTm9kZSh0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXNGaWxsID8gdXBkYXRlRmlsbE5vZGUoZWwsIHN0eWxlLCB6ckVsKSA6IHVwZGF0ZVN0cm9rZU5vZGUoZWwsIHN0eWxlKTtcbiAgICAgICAgICAgIGFwcGVuZCh2bWxFbCwgZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdm1sRWxbaXNGaWxsID8gJ2ZpbGxlZCcgOiAnc3Ryb2tlZCddID0gJ2ZhbHNlJztcbiAgICAgICAgICAgIHJlbW92ZSh2bWxFbCwgZWwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwb2ludHMgPSBbW10sIFtdLCBbXV07XG4gICAgdmFyIHBhdGhEYXRhVG9TdHJpbmcgPSBmdW5jdGlvbiAoZGF0YSwgbSkge1xuICAgICAgICB2YXIgTSA9IENNRC5NO1xuICAgICAgICB2YXIgQyA9IENNRC5DO1xuICAgICAgICB2YXIgTCA9IENNRC5MO1xuICAgICAgICB2YXIgQSA9IENNRC5BO1xuICAgICAgICB2YXIgUSA9IENNRC5RO1xuXG4gICAgICAgIHZhciBzdHIgPSBbXTtcbiAgICAgICAgdmFyIG5Qb2ludDtcbiAgICAgICAgdmFyIGNtZFN0cjtcbiAgICAgICAgdmFyIGNtZDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB4aTtcbiAgICAgICAgdmFyIHlpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICBjbWQgPSBkYXRhW2krK107XG4gICAgICAgICAgICBjbWRTdHIgPSAnJztcbiAgICAgICAgICAgIG5Qb2ludCA9IDA7XG4gICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgTTpcbiAgICAgICAgICAgICAgICAgICAgY21kU3RyID0gJyBtICc7XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdWzBdID0geGk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1swXVsxXSA9IHlpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEw6XG4gICAgICAgICAgICAgICAgICAgIGNtZFN0ciA9ICcgbCAnO1xuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1swXVswXSA9IHhpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF1bMV0gPSB5aTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBROlxuICAgICAgICAgICAgICAgIGNhc2UgQzpcbiAgICAgICAgICAgICAgICAgICAgY21kU3RyID0gJyBjICc7XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDIgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MiA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbWQgPT09IFEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgcXVhZHJhdGljIHRvIGN1YmljIHVzaW5nIGRlZ3JlZSBlbGV2YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHgzID0geDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MyA9IHkyO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSAoeDIgKyAyICogeDEpIC8gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0gKHkyICsgMiAqIHkxKSAvIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9ICh4aSArIDIgKiB4MSkgLyAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSAoeWkgKyAyICogeTEpIC8gMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgzID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTMgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdWzBdID0geDE7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1swXVsxXSA9IHkxO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMV1bMF0gPSB4MjtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzFdWzFdID0geTI7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1syXVswXSA9IHgzO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMl1bMV0gPSB5MztcblxuICAgICAgICAgICAgICAgICAgICB4aSA9IHgzO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IHkzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEE6XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ggPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBTUlQgZnJvbSBtYXRyaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBtWzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IG1bNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzeCA9IHNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeSA9IHNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBkYXRhW2krK10gKyBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZSArIGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgcHNpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9ja3dpc2UgPSBkYXRhW2krK107XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHgwID0gY3ggKyBjb3Moc3RhcnRBbmdsZSkgKiByeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkwID0gY3kgKyBzaW4oc3RhcnRBbmdsZSkgKiByeTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSBjeCArIGNvcyhlbmRBbmdsZSkgKiByeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0gY3kgKyBzaW4oZW5kQW5nbGUpICogcnk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBjbG9ja3dpc2UgPyAnIHdhICcgOiAnIGF0ICc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh4MCAtIHgxKSA8IDFlLTQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFIHdvbid0IHJlbmRlciBhcmNoZXMgZHJhd24gY291bnRlciBjbG9ja3dpc2UgaWYgeDAgPT0geDEuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSA+IDFlLTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPZmZzZXQgeDAgYnkgMS84MCBvZiBhIHBpeGVsLiBVc2Ugc29tZXRoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gYmluYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MCArPSAyNzAgLyBaO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIGNhc2UgZHJhdyBmdWxsIGNpcmNsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh5MCAtIGN5KSA8IDFlLTQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjbG9ja3dpc2UgJiYgeDAgPCBjeCkgfHwgKCFjbG9ja3dpc2UgJiYgeDAgPiBjeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxIC09IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MSArPSAyNzAgLyBaO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChjbG9ja3dpc2UgJiYgeTAgPCBjeSkgfHwgKCFjbG9ja3dpc2UgJiYgeTAgPiBjeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgKz0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxIC09IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0ci5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCgoY3ggLSByeCkgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoKGN5IC0gcnkpICogc3kgKyB5KSAqIFogLSBaMiksIGNvbW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91bmQoKChjeCArIHJ4KSAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCgoY3kgKyByeSkgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoeDAgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoeTAgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoeDEgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoeTEgKiBzeSArIHkpICogWiAtIFoyKVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIHhpID0geDE7XG4gICAgICAgICAgICAgICAgICAgIHlpID0geTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgIHZhciBwMCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAxID0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICAvLyB4MCwgeTBcbiAgICAgICAgICAgICAgICAgICAgcDBbMF0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHAwWzFdID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAvLyB4MSwgeTFcbiAgICAgICAgICAgICAgICAgICAgcDFbMF0gPSBwMFswXSArIGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcDFbMV0gPSBwMFsxXSArIGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAxLCBwMSwgbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwMFswXSA9IHJvdW5kKHAwWzBdICogWiAtIFoyKTtcbiAgICAgICAgICAgICAgICAgICAgcDFbMF0gPSByb3VuZChwMVswXSAqIFogLSBaMik7XG4gICAgICAgICAgICAgICAgICAgIHAwWzFdID0gcm91bmQocDBbMV0gKiBaIC0gWjIpO1xuICAgICAgICAgICAgICAgICAgICBwMVsxXSA9IHJvdW5kKHAxWzFdICogWiAtIFoyKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB4MCwgeTBcbiAgICAgICAgICAgICAgICAgICAgICAgICcgbSAnLCBwMFswXSwgY29tbWEsIHAwWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8geDEsIHkwXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGwgJywgcDFbMF0sIGNvbW1hLCBwMFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHgxLCB5MVxuICAgICAgICAgICAgICAgICAgICAgICAgJyBsICcsIHAxWzBdLCBjb21tYSwgcDFbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB4MCwgeTFcbiAgICAgICAgICAgICAgICAgICAgICAgICcgbCAnLCBwMFswXSwgY29tbWEsIHAxWzFdXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIFVwZGF0ZSB4aSwgeWlcbiAgICAgICAgICAgICAgICAgICAgc3RyLnB1c2goJyB4ICcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoblBvaW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHN0ci5wdXNoKGNtZFN0cik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuUG9pbnQ7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBvaW50c1trXTtcblxuICAgICAgICAgICAgICAgICAgICBtICYmIGFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICAgICAgICAgICAgICAvLyDkuI0gcm91bmQg5Lya6Z2e5bi45oWiXG4gICAgICAgICAgICAgICAgICAgIHN0ci5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91bmQocFswXSAqIFogLSBaMiksIGNvbW1hLCByb3VuZChwWzFdICogWiAtIFoyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPCBuUG9pbnQgLSAxID8gY29tbWEgOiAnJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIuam9pbignJyk7XG4gICAgfTtcblxuICAgIC8vIFJld3JpdGUgdGhlIG9yaWdpbmFsIHBhdGggbWV0aG9kXG4gICAgUGF0aC5wcm90b3R5cGUuYnJ1c2hWTUwgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuXG4gICAgICAgIHZhciB2bWxFbCA9IHRoaXMuX3ZtbEVsO1xuICAgICAgICBpZiAoIXZtbEVsKSB7XG4gICAgICAgICAgICB2bWxFbCA9IHZtbENvcmUuY3JlYXRlTm9kZSgnc2hhcGUnKTtcbiAgICAgICAgICAgIGluaXRSb290RWxTdHlsZSh2bWxFbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3ZtbEVsID0gdm1sRWw7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHZtbEVsLCAnZmlsbCcsIHN0eWxlLCB0aGlzKTtcbiAgICAgICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh2bWxFbCwgJ3N0cm9rZScsIHN0eWxlLCB0aGlzKTtcblxuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICB2YXIgbmVlZFRyYW5zZm9ybSA9IG0gIT0gbnVsbDtcbiAgICAgICAgdmFyIHN0cm9rZUVsID0gdm1sRWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0cm9rZScpWzBdO1xuICAgICAgICBpZiAoc3Ryb2tlRWwpIHtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGxpbmUgc2NhbGUuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmFudCBvZiB0aGlzLm1fIG1lYW5zIGhvdyBtdWNoIHRoZSBhcmVhIGlzIGVubGFyZ2VkIGJ5IHRoZVxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgICAgICAgICAgLy8gZm9yIHdpZHRoLlxuICAgICAgICAgICAgaWYgKG5lZWRUcmFuc2Zvcm0gJiYgIXN0eWxlLnN0cm9rZU5vU2NhbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGV0ID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggKj0gc3FydChhYnMoZGV0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJva2VFbC53ZWlnaHQgPSBsaW5lV2lkdGggKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICh0aGlzLl9fZGlydHlQYXRoKSB7XG4gICAgICAgICAgICBwYXRoLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSk7XG4gICAgICAgICAgICBwYXRoLnRvU3RhdGljKCk7XG4gICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2bWxFbC5wYXRoID0gcGF0aERhdGFUb1N0cmluZyhwYXRoLmRhdGEsIHRoaXMudHJhbnNmb3JtKTtcblxuICAgICAgICB2bWxFbC5zdHlsZS56SW5kZXggPSBnZXRaSW5kZXgodGhpcy56bGV2ZWwsIHRoaXMueiwgdGhpcy56Mik7XG5cbiAgICAgICAgLy8gQXBwZW5kIHRvIHJvb3RcbiAgICAgICAgYXBwZW5kKHZtbFJvb3QsIHZtbEVsKTtcblxuICAgICAgICAvLyBUZXh0XG4gICAgICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KHZtbFJvb3QsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVSZWN0VGV4dCh2bWxSb290KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBQYXRoLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHJlbW92ZSh2bWxSb290LCB0aGlzLl92bWxFbCk7XG4gICAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfTtcblxuICAgIFBhdGgucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgYXBwZW5kKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcbiAgICAgICAgdGhpcy5hcHBlbmRSZWN0VGV4dCh2bWxSb290KTtcbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIElNQUdFXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIHZhciBpc0ltYWdlID0gZnVuY3Rpb24gKGltZykge1xuICAgICAgICAvLyBGSVhNRSBpbWcgaW5zdGFuY2VvZiBJbWFnZSDlpoLmnpwgaW1nIOaYr+S4gOS4quWtl+espuS4sueahOaXtuWAme+8jElFOCDkuIvkvJrmiqXplJlcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgaW1nID09PSAnb2JqZWN0JykgJiYgaW1nLnRhZ05hbWUgJiYgaW1nLnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0lNRyc7XG4gICAgICAgIC8vIHJldHVybiBpbWcgaW5zdGFuY2VvZiBJbWFnZTtcbiAgICB9O1xuXG4gICAgLy8gUmV3cml0ZSB0aGUgb3JpZ2luYWwgcGF0aCBtZXRob2RcbiAgICBaSW1hZ2UucHJvdG90eXBlLmJydXNoVk1MID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgdmFyIGltYWdlID0gc3R5bGUuaW1hZ2U7XG5cbiAgICAgICAgLy8gSW1hZ2Ugb3JpZ2luYWwgd2lkdGgsIGhlaWdodFxuICAgICAgICB2YXIgb3c7XG4gICAgICAgIHZhciBvaDtcblxuICAgICAgICBpZiAoaXNJbWFnZShpbWFnZSkpIHtcbiAgICAgICAgICAgIHZhciBzcmMgPSBpbWFnZS5zcmM7XG4gICAgICAgICAgICBpZiAoc3JjID09PSB0aGlzLl9pbWFnZVNyYykge1xuICAgICAgICAgICAgICAgIG93ID0gdGhpcy5faW1hZ2VXaWR0aDtcbiAgICAgICAgICAgICAgICBvaCA9IHRoaXMuX2ltYWdlSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlUnVudGltZVN0eWxlID0gaW1hZ2UucnVudGltZVN0eWxlO1xuICAgICAgICAgICAgICAgIHZhciBvbGRSdW50aW1lV2lkdGggPSBpbWFnZVJ1bnRpbWVTdHlsZS53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgb2xkUnVudGltZUhlaWdodCA9IGltYWdlUnVudGltZVN0eWxlLmhlaWdodDtcbiAgICAgICAgICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS53aWR0aCA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS5oZWlnaHQgPSAnYXV0byc7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIG9yaWdpbmFsIHNpemVcbiAgICAgICAgICAgICAgICBvdyA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIG9oID0gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgLy8gYW5kIHJlbW92ZSBvdmVyaWRlc1xuICAgICAgICAgICAgICAgIGltYWdlUnVudGltZVN0eWxlLndpZHRoID0gb2xkUnVudGltZVdpZHRoO1xuICAgICAgICAgICAgICAgIGltYWdlUnVudGltZVN0eWxlLmhlaWdodCA9IG9sZFJ1bnRpbWVIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBDYWNoaW5nIGltYWdlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHQgYW5kIHNyY1xuICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlU3JjID0gc3JjO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlV2lkdGggPSBvdztcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZUhlaWdodCA9IG9oO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1hZ2UgPSBzcmM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW1hZ2UgPT09IHRoaXMuX2ltYWdlU3JjKSB7XG4gICAgICAgICAgICAgICAgb3cgPSB0aGlzLl9pbWFnZVdpZHRoO1xuICAgICAgICAgICAgICAgIG9oID0gdGhpcy5faW1hZ2VIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbWFnZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgICAgIHZhciB5ID0gc3R5bGUueSB8fCAwO1xuXG4gICAgICAgIHZhciBkdyA9IHN0eWxlLndpZHRoO1xuICAgICAgICB2YXIgZGggPSBzdHlsZS5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIHN3ID0gc3R5bGUuc1dpZHRoO1xuICAgICAgICB2YXIgc2ggPSBzdHlsZS5zSGVpZ2h0O1xuICAgICAgICB2YXIgc3ggPSBzdHlsZS5zeCB8fCAwO1xuICAgICAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuXG4gICAgICAgIHZhciBoYXNDcm9wID0gc3cgJiYgc2g7XG5cbiAgICAgICAgdmFyIHZtbEVsID0gdGhpcy5fdm1sRWw7XG4gICAgICAgIGlmICghdm1sRWwpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIOS9v+eUqCBncm91cCDlnKggbGVmdCwgdG9wIOmDveS4jeaYryAwIOeahOaXtuWAmeWwseaXoOazleaYvuekuuS6huOAglxuICAgICAgICAgICAgLy8gdm1sRWwgPSB2bWxDb3JlLmNyZWF0ZU5vZGUoJ2dyb3VwJyk7XG4gICAgICAgICAgICB2bWxFbCA9IHZtbENvcmUuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaW5pdFJvb3RFbFN0eWxlKHZtbEVsKTtcblxuICAgICAgICAgICAgdGhpcy5fdm1sRWwgPSB2bWxFbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2bWxFbFN0eWxlID0gdm1sRWwuc3R5bGU7XG4gICAgICAgIHZhciBoYXNSb3RhdGlvbiA9IGZhbHNlO1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgdmFyIHNjYWxlWCA9IDE7XG4gICAgICAgIHZhciBzY2FsZVkgPSAxO1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgICAgICBzY2FsZVkgPSBzcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuXG4gICAgICAgICAgICBoYXNSb3RhdGlvbiA9IG1bMV0gfHwgbVsyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzUm90YXRpb24pIHtcbiAgICAgICAgICAgIC8vIElmIGZpbHRlcnMgYXJlIG5lY2Vzc2FyeSAocm90YXRpb24gZXhpc3RzKSwgY3JlYXRlIHRoZW1cbiAgICAgICAgICAgIC8vIGZpbHRlcnMgYXJlIGJvZy1zbG93LCBzbyBvbmx5IGNyZWF0ZSB0aGVtIGlmIGFiYnNvbHV0ZWx5IG5lY2Vzc2FyeVxuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjaGVjayBkb2Vzbid0IGFjY291bnQgZm9yIHNrZXdzICh3aGljaCBkb24ndCBleGlzdFxuICAgICAgICAgICAgLy8gaW4gdGhlIGNhbnZhcyBzcGVjICh5ZXQpIGFueXdheS5cbiAgICAgICAgICAgIC8vIEZyb20gZXhjYW52YXNcbiAgICAgICAgICAgIHZhciBwMCA9IFt4LCB5XTtcbiAgICAgICAgICAgIHZhciBwMSA9IFt4ICsgZHcsIHldO1xuICAgICAgICAgICAgdmFyIHAyID0gW3gsIHkgKyBkaF07XG4gICAgICAgICAgICB2YXIgcDMgPSBbeCArIGR3LCB5ICsgZGhdO1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCBtKTtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAxLCBwMSwgbSk7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMiwgcDIsIG0pO1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDMsIHAzLCBtKTtcblxuICAgICAgICAgICAgdmFyIG1heFggPSBtYXRoTWF4KHAwWzBdLCBwMVswXSwgcDJbMF0sIHAzWzBdKTtcbiAgICAgICAgICAgIHZhciBtYXhZID0gbWF0aE1heChwMFsxXSwgcDFbMV0sIHAyWzFdLCBwM1sxXSk7XG5cbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1GaWx0ZXIgPSBbXTtcbiAgICAgICAgICAgIHRyYW5zZm9ybUZpbHRlci5wdXNoKCdNMTE9JywgbVswXSAvIHNjYWxlWCwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTTEyPScsIG1bMl0gLyBzY2FsZVksIGNvbW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ00yMT0nLCBtWzFdIC8gc2NhbGVYLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNMjI9JywgbVszXSAvIHNjYWxlWSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRHg9Jywgcm91bmQoeCAqIHNjYWxlWCArIG1bNF0pLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEeT0nLCByb3VuZCh5ICogc2NhbGVZICsgbVs1XSkpO1xuXG4gICAgICAgICAgICB2bWxFbFN0eWxlLnBhZGRpbmcgPSAnMCAnICsgcm91bmQobWF4WCkgKyAncHggJyArIHJvdW5kKG1heFkpICsgJ3B4IDAnO1xuICAgICAgICAgICAgLy8gRklYTUUgRFhJbWFnZVRyYW5zZm9ybSDlnKggSUUxMSDnmoTlhbzlrrnmqKHlvI/kuIvkuI3otbfkvZznlKhcbiAgICAgICAgICAgIHZtbEVsU3R5bGUuZmlsdGVyID0gaW1hZ2VUcmFuc2Zvcm1QcmVmaXggKyAnLk1hdHJpeCgnXG4gICAgICAgICAgICAgICAgKyB0cmFuc2Zvcm1GaWx0ZXIuam9pbignJykgKyAnLCBTaXppbmdNZXRob2Q9Y2xpcCknO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIHggPSB4ICogc2NhbGVYICsgbVs0XTtcbiAgICAgICAgICAgICAgICB5ID0geSAqIHNjYWxlWSArIG1bNV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2bWxFbFN0eWxlLmZpbHRlciA9ICcnO1xuICAgICAgICAgICAgdm1sRWxTdHlsZS5sZWZ0ID0gcm91bmQoeCkgKyAncHgnO1xuICAgICAgICAgICAgdm1sRWxTdHlsZS50b3AgPSByb3VuZCh5KSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW1hZ2VFbCA9IHRoaXMuX2ltYWdlRWw7XG4gICAgICAgIHZhciBjcm9wRWwgPSB0aGlzLl9jcm9wRWw7XG5cbiAgICAgICAgaWYgKCFpbWFnZUVsKSB7XG4gICAgICAgICAgICBpbWFnZUVsID0gdm1sQ29yZS5kb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9pbWFnZUVsID0gaW1hZ2VFbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW1hZ2VFTFN0eWxlID0gaW1hZ2VFbC5zdHlsZTtcbiAgICAgICAgaWYgKGhhc0Nyb3ApIHtcbiAgICAgICAgICAgIC8vIE5lZWRzIGtub3cgaW1hZ2Ugb3JpZ2luYWwgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgaWYgKCEgKG93ICYmIG9oKSkge1xuICAgICAgICAgICAgICAgIHZhciB0bXBJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB0bXBJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcEltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG93ID0gdG1wSW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIG9oID0gdG1wSW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGp1c3QgaW1hZ2Ugd2lkdGggYW5kIGhlaWdodCB0byBmaXQgdGhlIHJhdGlvIGRlc3RpbmF0aW9uU2l6ZSAvIHNvdXJjZVNpemVcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VFTFN0eWxlLndpZHRoID0gcm91bmQoc2NhbGVYICogb3cgKiBkdyAvIHN3KSArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlRUxTdHlsZS5oZWlnaHQgPSByb3VuZChzY2FsZVkgKiBvaCAqIGRoIC8gc2gpICsgJ3B4JztcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoaW5nIGltYWdlIG9yaWdpbmFsIHdpZHRoLCBoZWlnaHQgYW5kIHNyY1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9pbWFnZVdpZHRoID0gb3c7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2ltYWdlSGVpZ2h0ID0gb2g7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2ltYWdlU3JjID0gaW1hZ2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0bXBJbWFnZS5zcmMgPSBpbWFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGltYWdlRUxTdHlsZS53aWR0aCA9IHJvdW5kKHNjYWxlWCAqIG93ICogZHcgLyBzdykgKyAncHgnO1xuICAgICAgICAgICAgICAgIGltYWdlRUxTdHlsZS5oZWlnaHQgPSByb3VuZChzY2FsZVkgKiBvaCAqIGRoIC8gc2gpICsgJ3B4JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEgY3JvcEVsKSB7XG4gICAgICAgICAgICAgICAgY3JvcEVsID0gdm1sQ29yZS5kb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgY3JvcEVsLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JvcEVsID0gY3JvcEVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNyb3BFbFN0eWxlID0gY3JvcEVsLnN0eWxlO1xuICAgICAgICAgICAgY3JvcEVsU3R5bGUud2lkdGggPSByb3VuZCgoZHcgKyBzeCAqIGR3IC8gc3cpICogc2NhbGVYKTtcbiAgICAgICAgICAgIGNyb3BFbFN0eWxlLmhlaWdodCA9IHJvdW5kKChkaCArIHN5ICogZGggLyBzaCkgKiBzY2FsZVkpO1xuICAgICAgICAgICAgY3JvcEVsU3R5bGUuZmlsdGVyID0gaW1hZ2VUcmFuc2Zvcm1QcmVmaXggKyAnLk1hdHJpeChEeD0nXG4gICAgICAgICAgICAgICAgICAgICsgKC1zeCAqIGR3IC8gc3cgKiBzY2FsZVgpICsgJyxEeT0nICsgKC1zeSAqIGRoIC8gc2ggKiBzY2FsZVkpICsgJyknO1xuXG4gICAgICAgICAgICBpZiAoISBjcm9wRWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHZtbEVsLmFwcGVuZENoaWxkKGNyb3BFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW1hZ2VFbC5wYXJlbnROb2RlICE9IGNyb3BFbCkge1xuICAgICAgICAgICAgICAgIGNyb3BFbC5hcHBlbmRDaGlsZChpbWFnZUVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGltYWdlRUxTdHlsZS53aWR0aCA9IHJvdW5kKHNjYWxlWCAqIGR3KSArICdweCc7XG4gICAgICAgICAgICBpbWFnZUVMU3R5bGUuaGVpZ2h0ID0gcm91bmQoc2NhbGVZICogZGgpICsgJ3B4JztcblxuICAgICAgICAgICAgdm1sRWwuYXBwZW5kQ2hpbGQoaW1hZ2VFbCk7XG5cbiAgICAgICAgICAgIGlmIChjcm9wRWwgJiYgY3JvcEVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2bWxFbC5yZW1vdmVDaGlsZChjcm9wRWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nyb3BFbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsdGVyU3RyID0gJyc7XG4gICAgICAgIHZhciBhbHBoYSA9IHN0eWxlLm9wYWNpdHk7XG4gICAgICAgIGlmIChhbHBoYSA8IDEpIHtcbiAgICAgICAgICAgIGZpbHRlclN0ciArPSAnLkFscGhhKG9wYWNpdHk9JyArIHJvdW5kKGFscGhhICogMTAwKSArICcpICc7XG4gICAgICAgIH1cbiAgICAgICAgZmlsdGVyU3RyICs9IGltYWdlVHJhbnNmb3JtUHJlZml4ICsgJy5BbHBoYUltYWdlTG9hZGVyKHNyYz0nICsgaW1hZ2UgKyAnLCBTaXppbmdNZXRob2Q9c2NhbGUpJztcblxuICAgICAgICBpbWFnZUVMU3R5bGUuZmlsdGVyID0gZmlsdGVyU3RyO1xuXG4gICAgICAgIHZtbEVsLnN0eWxlLnpJbmRleCA9IGdldFpJbmRleCh0aGlzLnpsZXZlbCwgdGhpcy56LCB0aGlzLnoyKTtcblxuICAgICAgICAvLyBBcHBlbmQgdG8gcm9vdFxuICAgICAgICBhcHBlbmQodm1sUm9vdCwgdm1sRWwpO1xuXG4gICAgICAgIC8vIFRleHRcbiAgICAgICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQodm1sUm9vdCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgWkltYWdlLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHJlbW92ZSh2bWxSb290LCB0aGlzLl92bWxFbCk7XG5cbiAgICAgICAgdGhpcy5fdm1sRWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9jcm9wRWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbWFnZUVsID0gbnVsbDtcblxuICAgICAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH07XG5cbiAgICBaSW1hZ2UucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgYXBwZW5kKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcbiAgICAgICAgdGhpcy5hcHBlbmRSZWN0VGV4dCh2bWxSb290KTtcbiAgICB9O1xuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogVEVYVFxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIHZhciBERUZBVUxUX1NUWUxFX05PUk1BTCA9ICdub3JtYWwnO1xuXG4gICAgdmFyIGZvbnRTdHlsZUNhY2hlID0ge307XG4gICAgdmFyIGZvbnRTdHlsZUNhY2hlQ291bnQgPSAwO1xuICAgIHZhciBNQVhfRk9OVF9DQUNIRV9TSVpFID0gMTAwO1xuICAgIHZhciBmb250RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIHZhciBnZXRGb250U3R5bGUgPSBmdW5jdGlvbiAoZm9udFN0cmluZykge1xuICAgICAgICB2YXIgZm9udFN0eWxlID0gZm9udFN0eWxlQ2FjaGVbZm9udFN0cmluZ107XG4gICAgICAgIGlmICghZm9udFN0eWxlKSB7XG4gICAgICAgICAgICAvLyBDbGVhciBjYWNoZVxuICAgICAgICAgICAgaWYgKGZvbnRTdHlsZUNhY2hlQ291bnQgPiBNQVhfRk9OVF9DQUNIRV9TSVpFKSB7XG4gICAgICAgICAgICAgICAgZm9udFN0eWxlQ2FjaGVDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgZm9udFN0eWxlQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0eWxlID0gZm9udEVsLnN0eWxlO1xuICAgICAgICAgICAgdmFyIGZvbnRGYW1pbHk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0eWxlLmZvbnQgPSBmb250U3RyaW5nO1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBzdHlsZS5mb250RmFtaWx5LnNwbGl0KCcsJylbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb250U3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLmZvbnRTdHlsZSB8fCBERUZBVUxUX1NUWUxFX05PUk1BTCxcbiAgICAgICAgICAgICAgICB2YXJpYW50OiBzdHlsZS5mb250VmFyaWFudCB8fCBERUZBVUxUX1NUWUxFX05PUk1BTCxcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IHN0eWxlLmZvbnRXZWlnaHQgfHwgREVGQVVMVF9TVFlMRV9OT1JNQUwsXG4gICAgICAgICAgICAgICAgc2l6ZTogcGFyc2VGbG9hdChzdHlsZS5mb250U2l6ZSB8fCAxMikgfCAwLFxuICAgICAgICAgICAgICAgIGZhbWlseTogZm9udEZhbWlseSB8fCAnTWljcm9zb2Z0IFlhSGVpJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9udFN0eWxlQ2FjaGVbZm9udFN0cmluZ10gPSBmb250U3R5bGU7XG4gICAgICAgICAgICBmb250U3R5bGVDYWNoZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbnRTdHlsZTtcbiAgICB9O1xuXG4gICAgdmFyIHRleHRNZWFzdXJlRWw7XG4gICAgLy8gT3ZlcndyaXRlIG1lYXN1cmUgdGV4dCBtZXRob2RcbiAgICB0ZXh0Q29udGFpbi5tZWFzdXJlVGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCB0ZXh0Rm9udCkge1xuICAgICAgICB2YXIgZG9jID0gdm1sQ29yZS5kb2M7XG4gICAgICAgIGlmICghdGV4dE1lYXN1cmVFbCkge1xuICAgICAgICAgICAgdGV4dE1lYXN1cmVFbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRleHRNZWFzdXJlRWwuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTIwMDAwcHg7bGVmdDowOydcbiAgICAgICAgICAgICAgICArICdwYWRkaW5nOjA7bWFyZ2luOjA7Ym9yZGVyOm5vbmU7d2hpdGUtc3BhY2U6cHJlOyc7XG4gICAgICAgICAgICB2bWxDb3JlLmRvYy5ib2R5LmFwcGVuZENoaWxkKHRleHRNZWFzdXJlRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRleHRNZWFzdXJlRWwuc3R5bGUuZm9udCA9IHRleHRGb250O1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGZhaWx1cmVzIHRvIHNldCB0byBpbnZhbGlkIGZvbnQuXG4gICAgICAgIH1cbiAgICAgICAgdGV4dE1lYXN1cmVFbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgLy8gRG9uJ3QgdXNlIGlubmVySFRNTCBvciBpbm5lclRleHQgYmVjYXVzZSB0aGV5IGFsbG93IG1hcmt1cC93aGl0ZXNwYWNlLlxuICAgICAgICB0ZXh0TWVhc3VyZUVsLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogdGV4dE1lYXN1cmVFbC5vZmZzZXRXaWR0aFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoKTtcblxuICAgIHZhciBkcmF3UmVjdFRleHQgPSBmdW5jdGlvbiAodm1sUm9vdCwgcmVjdCwgdGV4dFJlY3QsIGZyb21UZXh0RWwpIHtcblxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7XG4gICAgICAgIC8vIENvbnZlcnQgdG8gc3RyaW5nXG4gICAgICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHg7XG4gICAgICAgIHZhciB5O1xuICAgICAgICB2YXIgYWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gICAgICAgIHZhciBmb250U3R5bGUgPSBnZXRGb250U3R5bGUoc3R5bGUudGV4dEZvbnQpO1xuICAgICAgICAvLyBGSVhNRSBlbmNvZGVIdG1sQXR0cmlidXRlID9cbiAgICAgICAgdmFyIGZvbnQgPSBmb250U3R5bGUuc3R5bGUgKyAnICcgKyBmb250U3R5bGUudmFyaWFudCArICcgJyArIGZvbnRTdHlsZS53ZWlnaHQgKyAnICdcbiAgICAgICAgICAgICsgZm9udFN0eWxlLnNpemUgKyAncHggXCInICsgZm9udFN0eWxlLmZhbWlseSArICdcIic7XG5cbiAgICAgICAgdmFyIGJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgICAgICB2YXIgdmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduO1xuXG4gICAgICAgIHRleHRSZWN0ID0gdGV4dFJlY3QgfHwgdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRleHQsIGZvbnQsIGFsaWduLCBiYXNlbGluZSk7XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtIHJlY3QgdG8gdmlldyBzcGFjZVxuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAvLyBJZ25vcmUgdHJhbnNmb3JtIGZvciB0ZXh0IGluIG90aGVyIGVsZW1lbnRcbiAgICAgICAgaWYgKG0gJiYgIWZyb21UZXh0RWwpIHtcbiAgICAgICAgICAgIHRtcFJlY3QuY29weShyZWN0KTtcbiAgICAgICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0obSk7XG4gICAgICAgICAgICByZWN0ID0gdG1wUmVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZnJvbVRleHRFbCkge1xuICAgICAgICAgICAgdmFyIHRleHRQb3NpdGlvbiA9IHN0eWxlLnRleHRQb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHN0eWxlLnRleHREaXN0YW5jZTtcbiAgICAgICAgICAgIC8vIFRleHQgcG9zaXRpb24gcmVwcmVzZW50ZWQgYnkgY29vcmRcbiAgICAgICAgICAgIGlmICh0ZXh0UG9zaXRpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHggPSByZWN0LnggKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzBdLCByZWN0LndpZHRoKTtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblsxXSwgcmVjdC5oZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgYWxpZ24gPSBhbGlnbiB8fCAnbGVmdCc7XG4gICAgICAgICAgICAgICAgYmFzZWxpbmUgPSBiYXNlbGluZSB8fCAndG9wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0UG9zaXRpb25PblJlY3QoXG4gICAgICAgICAgICAgICAgICAgIHRleHRQb3NpdGlvbiwgcmVjdCwgdGV4dFJlY3QsIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB4ID0gcmVzLng7XG4gICAgICAgICAgICAgICAgeSA9IHJlcy55O1xuXG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBhbGlnbiBhbmQgYmFzZWxpbmUgd2hlbiBoYXMgdGV4dFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgYWxpZ24gPSBhbGlnbiB8fCByZXMudGV4dEFsaWduO1xuICAgICAgICAgICAgICAgIGJhc2VsaW5lID0gYmFzZWxpbmUgfHwgcmVzLnRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHggPSByZWN0Lng7XG4gICAgICAgICAgICB5ID0gcmVjdC55O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgICAgICB5IC09IHRleHRSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgIHkgLT0gdGV4dFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyAndG9wJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWdub3JlIGJhc2VsaW5lXG4gICAgICAgICAgICBiYXNlbGluZSA9ICd0b3AnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZvbnRTaXplID0gZm9udFN0eWxlLnNpemU7XG4gICAgICAgIC8vIDEuNzUgaXMgYW4gYXJiaXRyYXJ5IG51bWJlciwgYXMgdGhlcmUgaXMgbm8gaW5mbyBhYm91dCB0aGUgdGV4dCBiYXNlbGluZVxuICAgICAgICBzd2l0Y2ggKGJhc2VsaW5lKSB7XG4gICAgICAgICAgICBjYXNlICdoYW5naW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgeSArPSBmb250U2l6ZSAvIDEuNzU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGNhc2UgbnVsbDpcbiAgICAgICAgICAgIC8vIGNhc2UgJ2FscGhhYmV0aWMnOlxuICAgICAgICAgICAgLy8gY2FzZSAnaWRlb2dyYXBoaWMnOlxuICAgICAgICAgICAgLy8gY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB5IC09IGZvbnRTaXplIC8gMi4yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgeCAtPSB0ZXh0UmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgeCAtPSB0ZXh0UmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgLy8gYWxpZ24gPSBlbGVtZW50U3R5bGUuZGlyZWN0aW9uID09ICdsdHInID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAvLyBicmVhaztcbiAgICAgICAgICAgIC8vIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgICAgICAvLyBhbGlnbiA9IGVsZW1lbnRTdHlsZS5kaXJlY3Rpb24gPT0gJ3J0bCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgICAgIC8vIGJyZWFrO1xuICAgICAgICAgICAgLy8gZGVmYXVsdDpcbiAgICAgICAgICAgIC8vICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjcmVhdGVOb2RlID0gdm1sQ29yZS5jcmVhdGVOb2RlO1xuXG4gICAgICAgIHZhciB0ZXh0Vm1sRWwgPSB0aGlzLl90ZXh0Vm1sRWw7XG4gICAgICAgIHZhciBwYXRoRWw7XG4gICAgICAgIHZhciB0ZXh0UGF0aEVsO1xuICAgICAgICB2YXIgc2tld0VsO1xuICAgICAgICBpZiAoIXRleHRWbWxFbCkge1xuICAgICAgICAgICAgdGV4dFZtbEVsID0gY3JlYXRlTm9kZSgnbGluZScpO1xuICAgICAgICAgICAgcGF0aEVsID0gY3JlYXRlTm9kZSgncGF0aCcpO1xuICAgICAgICAgICAgdGV4dFBhdGhFbCA9IGNyZWF0ZU5vZGUoJ3RleHRwYXRoJyk7XG4gICAgICAgICAgICBza2V3RWwgPSBjcmVhdGVOb2RlKCdza2V3Jyk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FIFdoeSBoZXJlIGlzIG5vdCBjYW1tZWwgY2FzZVxuICAgICAgICAgICAgLy8gQWxpZ24gJ2NlbnRlcicgc2VlbXMgd3JvbmdcbiAgICAgICAgICAgIHRleHRQYXRoRWwuc3R5bGVbJ3YtdGV4dC1hbGlnbiddID0gJ2xlZnQnO1xuXG4gICAgICAgICAgICBpbml0Um9vdEVsU3R5bGUodGV4dFZtbEVsKTtcblxuICAgICAgICAgICAgcGF0aEVsLnRleHRwYXRob2sgPSB0cnVlO1xuICAgICAgICAgICAgdGV4dFBhdGhFbC5vbiA9IHRydWU7XG5cbiAgICAgICAgICAgIHRleHRWbWxFbC5mcm9tID0gJzAgMCc7XG4gICAgICAgICAgICB0ZXh0Vm1sRWwudG8gPSAnMTAwMCAwLjA1JztcblxuICAgICAgICAgICAgYXBwZW5kKHRleHRWbWxFbCwgc2tld0VsKTtcbiAgICAgICAgICAgIGFwcGVuZCh0ZXh0Vm1sRWwsIHBhdGhFbCk7XG4gICAgICAgICAgICBhcHBlbmQodGV4dFZtbEVsLCB0ZXh0UGF0aEVsKTtcblxuICAgICAgICAgICAgdGhpcy5fdGV4dFZtbEVsID0gdGV4dFZtbEVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8g6L+Z6YeM5piv5Zyo5YmN6Z2iIGFwcGVuZENoaWxkIOS/neivgemhuuW6j+eahOWJjeaPkOS4i1xuICAgICAgICAgICAgc2tld0VsID0gdGV4dFZtbEVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBwYXRoRWwgPSBza2V3RWwubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB0ZXh0UGF0aEVsID0gcGF0aEVsLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvb3JkcyA9IFt4LCB5XTtcbiAgICAgICAgdmFyIHRleHRWbWxFbFN0eWxlID0gdGV4dFZtbEVsLnN0eWxlO1xuICAgICAgICAvLyBJZ25vcmUgdHJhbnNmb3JtIGZvciB0ZXh0IGluIG90aGVyIGVsZW1lbnRcbiAgICAgICAgaWYgKG0gJiYgZnJvbVRleHRFbCkge1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0oY29vcmRzLCBjb29yZHMsIG0pO1xuXG4gICAgICAgICAgICBza2V3RWwub24gPSB0cnVlO1xuXG4gICAgICAgICAgICBza2V3RWwubWF0cml4ID0gbVswXS50b0ZpeGVkKDMpICsgY29tbWEgKyBtWzJdLnRvRml4ZWQoMykgKyBjb21tYSArXG4gICAgICAgICAgICBtWzFdLnRvRml4ZWQoMykgKyBjb21tYSArIG1bM10udG9GaXhlZCgzKSArICcsMCwwJztcblxuICAgICAgICAgICAgLy8gVGV4dCBwb3NpdGlvblxuICAgICAgICAgICAgc2tld0VsLm9mZnNldCA9IChyb3VuZChjb29yZHNbMF0pIHx8IDApICsgJywnICsgKHJvdW5kKGNvb3Jkc1sxXSkgfHwgMCk7XG4gICAgICAgICAgICAvLyBMZWZ0IHRvcCBwb2ludCBhcyBvcmlnaW5cbiAgICAgICAgICAgIHNrZXdFbC5vcmlnaW4gPSAnMCAwJztcblxuICAgICAgICAgICAgdGV4dFZtbEVsU3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgdGV4dFZtbEVsU3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBza2V3RWwub24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRleHRWbWxFbFN0eWxlLmxlZnQgPSByb3VuZCh4KSArICdweCc7XG4gICAgICAgICAgICB0ZXh0Vm1sRWxTdHlsZS50b3AgPSByb3VuZCh5KSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0UGF0aEVsLnN0cmluZyA9IGVuY29kZUh0bWxBdHRyaWJ1dGUodGV4dCk7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRleHRQYXRoRWwuc3R5bGUuZm9udCA9IGZvbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXJyb3IgZm9udCBmb3JtYXRcbiAgICAgICAgY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh0ZXh0Vm1sRWwsICdmaWxsJywge1xuICAgICAgICAgICAgZmlsbDogZnJvbVRleHRFbCA/IHN0eWxlLmZpbGwgOiBzdHlsZS50ZXh0RmlsbCxcbiAgICAgICAgICAgIG9wYWNpdHk6IHN0eWxlLm9wYWNpdHlcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHVwZGF0ZUZpbGxBbmRTdHJva2UodGV4dFZtbEVsLCAnc3Ryb2tlJywge1xuICAgICAgICAgICAgc3Ryb2tlOiBmcm9tVGV4dEVsID8gc3R5bGUuc3Ryb2tlIDogc3R5bGUudGV4dFN0cm9rZSxcbiAgICAgICAgICAgIG9wYWNpdHk6IHN0eWxlLm9wYWNpdHksXG4gICAgICAgICAgICBsaW5lRGFzaDogc3R5bGUubGluZURhc2hcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdGV4dFZtbEVsLnN0eWxlLnpJbmRleCA9IGdldFpJbmRleCh0aGlzLnpsZXZlbCwgdGhpcy56LCB0aGlzLnoyKTtcblxuICAgICAgICAvLyBBdHRhY2hlZCB0byByb290XG4gICAgICAgIGFwcGVuZCh2bWxSb290LCB0ZXh0Vm1sRWwpO1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlUmVjdFRleHQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICByZW1vdmUodm1sUm9vdCwgdGhpcy5fdGV4dFZtbEVsKTtcbiAgICAgICAgdGhpcy5fdGV4dFZtbEVsID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGFwcGVuZFJlY3RUZXh0ID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgYXBwZW5kKHZtbFJvb3QsIHRoaXMuX3RleHRWbWxFbCk7XG4gICAgfTtcblxuICAgIHZhciBsaXN0ID0gW1JlY3RUZXh0LCBEaXNwbGF5YWJsZSwgWkltYWdlLCBQYXRoLCBUZXh0XTtcblxuICAgIC8vIEluIGNhc2UgRGlzcGxheWFibGUgaGFzIGJlZW4gbWl4ZWQgaW4gUmVjdFRleHRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3RvID0gbGlzdFtpXS5wcm90b3R5cGU7XG4gICAgICAgIHByb3RvLmRyYXdSZWN0VGV4dCA9IGRyYXdSZWN0VGV4dDtcbiAgICAgICAgcHJvdG8ucmVtb3ZlUmVjdFRleHQgPSByZW1vdmVSZWN0VGV4dDtcbiAgICAgICAgcHJvdG8uYXBwZW5kUmVjdFRleHQgPSBhcHBlbmRSZWN0VGV4dDtcbiAgICB9XG5cbiAgICBUZXh0LnByb3RvdHlwZS5icnVzaFZNTCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KHZtbFJvb3QsIHtcbiAgICAgICAgICAgICAgICB4OiBzdHlsZS54IHx8IDAsIHk6IHN0eWxlLnkgfHwgMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogMCwgaGVpZ2h0OiAwXG4gICAgICAgICAgICB9LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVGV4dC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH07XG5cbiAgICBUZXh0LnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3ZtbC9ncmFwaGljLmpzXG4gKiogbW9kdWxlIGlkID0gMTExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuaWYgKCFyZXF1aXJlKCcuLi9jb3JlL2VudicpLmNhbnZhc1N1cHBvcnRlZCkge1xuICAgIHZhciB1cm4gPSAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnO1xuXG4gICAgdmFyIGNyZWF0ZU5vZGU7XG4gICAgdmFyIHdpbiA9IHdpbmRvdztcbiAgICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuXG4gICAgdmFyIHZtbEluaXRlZCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgIWRvYy5uYW1lc3BhY2VzLnpydm1sICYmIGRvYy5uYW1lc3BhY2VzLmFkZCgnenJ2bWwnLCB1cm4pO1xuICAgICAgICBjcmVhdGVOb2RlID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2MuY3JlYXRlRWxlbWVudCgnPHpydm1sOicgKyB0YWdOYW1lICsgJyBjbGFzcz1cInpydm1sXCI+Jyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KCc8JyArIHRhZ05hbWUgKyAnIHhtbG5zPVwiJyArIHVybiArICdcIiBjbGFzcz1cInpydm1sXCI+Jyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRnJvbSByYXBoYWVsXG4gICAgdmFyIGluaXRWTUwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bWxJbml0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2bWxJbml0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHZhciBzdHlsZVNoZWV0cyA9IGRvYy5zdHlsZVNoZWV0cztcbiAgICAgICAgaWYgKHN0eWxlU2hlZXRzLmxlbmd0aCA8IDMxKSB7XG4gICAgICAgICAgICBkb2MuY3JlYXRlU3R5bGVTaGVldCgpLmFkZFJ1bGUoJy56cnZtbCcsICdiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMxMTk0JTI4VlMuODUlMjkuYXNweFxuICAgICAgICAgICAgc3R5bGVTaGVldHNbMF0uYWRkUnVsZSgnLnpydm1sJywgJ2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gTm90IHVzZWluZyByZXR1cm4gdG8gYXZvaWQgZXJyb3Igd2hlbiBjb252ZXJ0aW5nIHRvIENvbW1vbkpTIG1vZHVsZVxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBkb2M6IGRvYyxcbiAgICAgICAgaW5pdFZNTDogaW5pdFZNTCxcbiAgICAgICAgY3JlYXRlTm9kZTogY3JlYXRlTm9kZVxuICAgIH07XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi92bWwvY29yZS5qc1xuICoqIG1vZHVsZSBpZCA9IDExMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBWTUwgUGFpbnRlci5cbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvdm1sL1BhaW50ZXJcbiAqL1xuXG5cblxuICAgIHZhciB6ckxvZyA9IHJlcXVpcmUoJy4uL2NvcmUvbG9nJyk7XG4gICAgdmFyIHZtbENvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSW50MTAodmFsKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvdm1sL1BhaW50ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWTUxQYWludGVyKHJvb3QsIHN0b3JhZ2UpIHtcblxuICAgICAgICB2bWxDb3JlLmluaXRWTUwoKTtcblxuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG5cbiAgICAgICAgdmFyIHZtbFZpZXdwb3J0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgdmFyIHZtbFJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICB2bWxWaWV3cG9ydC5zdHlsZS5jc3NUZXh0ID0gJ2Rpc3BsYXk6aW5saW5lLWJsb2NrO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDozMDBweDtoZWlnaHQ6MTUwcHg7JztcblxuICAgICAgICB2bWxSb290LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowOyc7XG5cbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZCh2bWxWaWV3cG9ydCk7XG5cbiAgICAgICAgdGhpcy5fdm1sUm9vdCA9IHZtbFJvb3Q7XG4gICAgICAgIHRoaXMuX3ZtbFZpZXdwb3J0ID0gdm1sVmlld3BvcnQ7XG5cbiAgICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgICAvLyBNb2RpZnkgc3RvcmFnZVxuICAgICAgICB2YXIgb2xkRGVsRnJvbU1hcCA9IHN0b3JhZ2UuZGVsRnJvbU1hcDtcbiAgICAgICAgdmFyIG9sZEFkZFRvTWFwID0gc3RvcmFnZS5hZGRUb01hcDtcbiAgICAgICAgc3RvcmFnZS5kZWxGcm9tTWFwID0gZnVuY3Rpb24gKGVsSWQpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHN0b3JhZ2UuZ2V0KGVsSWQpO1xuXG4gICAgICAgICAgICBvbGREZWxGcm9tTWFwLmNhbGwoc3RvcmFnZSwgZWxJZCk7XG5cbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIGVsLm9uUmVtb3ZlICYmIGVsLm9uUmVtb3ZlKHZtbFJvb3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN0b3JhZ2UuYWRkVG9NYXAgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIC8vIERpc3BsYXlhYmxlIGFscmVhZHkgaGFzIGEgdm1sIG5vZGVcbiAgICAgICAgICAgIGVsLm9uQWRkICYmIGVsLm9uQWRkKHZtbFJvb3QpO1xuXG4gICAgICAgICAgICBvbGRBZGRUb01hcC5jYWxsKHN0b3JhZ2UsIGVsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9maXJzdFBhaW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBWTUxQYWludGVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogVk1MUGFpbnRlcixcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7SFRNTERpdkVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRWaWV3cG9ydFJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92bWxWaWV3cG9ydDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yi35pawXG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLl9wYWludExpc3QobGlzdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3BhaW50TGlzdDogZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICAgIHZhciB2bWxSb290ID0gdGhpcy5fdm1sUm9vdDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgaWYgKGVsLmludmlzaWJsZSB8fCBlbC5pZ25vcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbC5fX2FscmVhZHlOb3RWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5vblJlbW92ZSh2bWxSb290KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgYXMgYWxyZWFkeSBpbnZpc2libGVcbiAgICAgICAgICAgICAgICAgICAgZWwuX19hbHJlYWR5Tm90VmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuX19hbHJlYWR5Tm90VmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwub25BZGQodm1sUm9vdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWwuX19hbHJlYWR5Tm90VmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuYmVmb3JlQnJ1c2ggJiYgZWwuYmVmb3JlQnJ1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChlbC5icnVzaFZNTCB8fCBlbC5icnVzaCkuY2FsbChlbCwgdm1sUm9vdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5hZnRlckJydXNoICYmIGVsLmFmdGVyQnJ1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9maXJzdFBhaW50KSB7XG4gICAgICAgICAgICAgICAgLy8gRGV0YWNoZWQgZnJvbSBkb2N1bWVudCBhdCBmaXJzdCB0aW1lXG4gICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgcGFnZSByZWZyZXNoaW5nIHRvbyBtYW55IHRpbWVzXG5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSDlpoLmnpzmr4/mrKHpg73lhYggcmVtb3ZlQ2hpbGQg5Y+v6IO95Lya5a+86Ie05LiA5Lqb5aGr5YWF5ZKM5o+P6L6555qE5pWI5p6c5pS55Y+YXG4gICAgICAgICAgICAgICAgdGhpcy5fdm1sVmlld3BvcnQuYXBwZW5kQ2hpbGQodm1sUm9vdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyc3RQYWludCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHdpZHRoID09IG51bGwgPyB0aGlzLl9nZXRXaWR0aCgpIDogd2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gaGVpZ2h0ID09IG51bGwgPyB0aGlzLl9nZXRIZWlnaHQoKSA6IGhlaWdodDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3dpZHRoICE9IHdpZHRoIHx8IHRoaXMuX2hlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgICAgIHZhciB2bWxWaWV3cG9ydFN0eWxlID0gdGhpcy5fdm1sVmlld3BvcnQuc3R5bGU7XG4gICAgICAgICAgICAgICAgdm1sVmlld3BvcnRTdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICB2bWxWaWV3cG9ydFN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5yb290LmlubmVySFRNTCA9ICcnO1xuXG4gICAgICAgICAgICB0aGlzLl92bWxSb290ID1cbiAgICAgICAgICAgIHRoaXMuX3ZtbFZpZXdwb3J0ID1cbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92bWxWaWV3cG9ydCkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5yZW1vdmVDaGlsZCh0aGlzLl92bWxWaWV3cG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIHZhciBzdGwgPSByb290LmN1cnJlbnRTdHlsZTtcblxuICAgICAgICAgICAgcmV0dXJuICgocm9vdC5jbGllbnRXaWR0aCB8fCBwYXJzZUludDEwKHN0bC53aWR0aCkpXG4gICAgICAgICAgICAgICAgICAgIC0gcGFyc2VJbnQxMChzdGwucGFkZGluZ0xlZnQpXG4gICAgICAgICAgICAgICAgICAgIC0gcGFyc2VJbnQxMChzdGwucGFkZGluZ1JpZ2h0KSkgfCAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgICAgICAgICAgdmFyIHN0bCA9IHJvb3QuY3VycmVudFN0eWxlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChyb290LmNsaWVudEhlaWdodCB8fCBwYXJzZUludDEwKHN0bC5oZWlnaHQpKVxuICAgICAgICAgICAgICAgICAgICAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdUb3ApXG4gICAgICAgICAgICAgICAgICAgIC0gcGFyc2VJbnQxMChzdGwucGFkZGluZ0JvdHRvbSkpIHwgMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBOb3Qgc3VwcG9ydGVkIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBjcmVhdGVNZXRob2ROb3RTdXBwb3J0KG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgenJMb2coJ0luIElFOC4wIFZNTCBtb2RlIHBhaW50ZXIgbm90IHN1cHBvcnQgbWV0aG9kIFwiJyArIG1ldGhvZCArICdcIicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBub3RTdXBwb3J0ZWRNZXRob2RzID0gW1xuICAgICAgICAnZ2V0TGF5ZXInLCAnaW5zZXJ0TGF5ZXInLCAnZWFjaExheWVyJywgJ2VhY2hCdWlsdGluTGF5ZXInLCAnZWFjaE90aGVyTGF5ZXInLCAnZ2V0TGF5ZXJzJyxcbiAgICAgICAgJ21vZExheWVyJywgJ2RlbExheWVyJywgJ2NsZWFyTGF5ZXInLCAndG9EYXRhVVJMJywgJ3BhdGhUb0ltYWdlJ1xuICAgIF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdFN1cHBvcnRlZE1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBub3RTdXBwb3J0ZWRNZXRob2RzW2ldO1xuICAgICAgICBWTUxQYWludGVyLnByb3RvdHlwZVtuYW1lXSA9IGNyZWF0ZU1ldGhvZE5vdFN1cHBvcnQobmFtZSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBWTUxQYWludGVyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvdm1sL1BhaW50ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=