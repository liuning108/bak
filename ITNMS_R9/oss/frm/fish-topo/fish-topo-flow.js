(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["fishTopoFlow"] = factory();
	else
		root["fishTopoFlow"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Export fishTopo as CommonJS module
	 */
	module.exports = __webpack_require__(2);
	//兼容IE8 引入VML 如果不需要兼容IE8请删除
	__webpack_require__(136);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * fishtopo流程实例
	 * @class fish.topo.FishTopoFlow
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *      var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 */
	
	/**
	 * @event click
	 * 节点或者线段的click事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          this.fishTopo.on("click", function(event) {
	 *              console.log("点击的是：" + event.target.model.get('elementType'));
	 *          });
	 */
	
	/**
	 * @event dblclick
	 * 节点或者线段的双击事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          this.fishTopo.on("dblclick", function(event) {
	 *              console.log("双击的是：" + event.target.model.get('elementType'));
	 *          });
	 */
	
	/**
	 * @event create
	 * 节点与线段创建完毕的事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          this.fishTopo.on("create", function(e) {
	 *               if (me.fishTopo.Flow.isLink(e.target.model)) {
	 *                  console.log("线段创建完毕：" + e.target.model);
	 *               }
	 *          });
	 */
	
	/**
	 * @event delete
	 * 节点与线段创建完毕的事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          //节点删除完毕事件
	 *          this.fishTopo.on("delete", function(event) {
	 *              console.log("删除的是：" + event.target.model.get('elementType'));
	 *          });
	 */
	
	/**
	 * @event dropDrag
	 * 节点移动完成的事件
	 * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *          //节点移动结束事件
	            this.fishTopo.on("dropDrag", function(event) {
	                console.log("移动的节点是："+event.target.model.get('elementType'));
	            });
	 */
	
	
	
	
	    __webpack_require__(3);
	    var graphic = __webpack_require__(4);
	    var Minimap = __webpack_require__(64);
	    var util = __webpack_require__(65);
	    var Point = __webpack_require__(66);
	    var ExtensionAPI = __webpack_require__(68);
	    var Eventful = __webpack_require__(12);
	    var zrender = __webpack_require__(69);
	    var zrUtil = __webpack_require__(5);
	    var OperationNode = __webpack_require__(80);
	    var FlowConnectionManager = __webpack_require__(90);
	    var FlowUtil = __webpack_require__(94);
	    var Constants = __webpack_require__(93);
	    var Model = __webpack_require__(87);
	    var eventTool = __webpack_require__(74);
	    var Connector = __webpack_require__(82);
	    var LineOperationManager = __webpack_require__(122);
	    var Flow = __webpack_require__(119);
	    var flowNode = __webpack_require__(96);
	    var flowLink = __webpack_require__(117);
	    var layout = __webpack_require__(123);
	    var textContain = __webpack_require__(26);
	    var ImagePool = __webpack_require__(131);
	    var ToolTipView = __webpack_require__(132);
	    var TooltipModel = __webpack_require__(135);
	    var actions = {};
	    var keyCode = {ENTER:13, ESCAPE:27}
	    function FishTopoFlow(dom, opts) {
	        this.id;
	        this.group = null;
	        this._dom = dom;
	        this.nowZoom = 1;
	        this.canScale = true;
	        this.eagleEye = false;
	        this.eagleEyeNode = null;
	        this.initScaleRatio = 1;
	        this.operationNode = null;
	        this.selectedNode = null;
	        this.allNodes = [];
	        this.minimap = null;
	        this._api = new ExtensionAPI(this);
	        this.connectionManager = new FlowConnectionManager(this._api);
	        this.lineOperationManager = new LineOperationManager(this.connectionManager,this._api);
	        this._zr = zrender.init(dom, {
	            renderer: opts.renderer || 'canvas',
	            devicePixelRatio: opts.devicePixelRatio
	        });
	        this._tooltipView = new ToolTipView(new TooltipModel(opts.tooltip),this._api);
	        this.Shape = graphic;
	        this.model = new Model({});
	        this.model.set(Constants.ELEMENT_TYPE, "scene");
	        this.model.set(Constants.MODE, "normal");
	        this.options = opts;
	        Eventful.call(this);
	    }
	
	    var fishTopoProto = FishTopoFlow.prototype;
	
	    /**
	     * 获取 fishTopo 实例容器的 dom 节点
	     * @return {HTMLElement}
	     */
	    fishTopoProto.getDom = function () {
	        return this._dom;
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.getZr = function () {
	        return this._zr;
	    };
	    /**
	     * 获取 fishTopo 实例容器的宽度。
	     * @return {number}
	     */
	    fishTopoProto.getWidth = function () {
	        return this._zr.getWidth();
	    };
	
	    /**
	     * 获取 fishTopo 实例容器的高度。
	     * @return {number}
	     */
	    fishTopoProto.getHeight = function () {
	        return this._zr.getHeight();
	    };
	
	
	    /**
	     * 当前实例是否已经被释放。
	     * @return {boolean}
	     */
	    fishTopoProto.isDisposed = function () {
	        return this._disposed;
	    };
	
	    /**
	     * 释放 当前实例
	     */
	    fishTopoProto.dispose = function () {
	        this._disposed = true;
	
	        this._zr.dispose();
	
	        instances[this.id] = null;
	    };
	
	
	    /**
	     * 调整尺寸  在窗口大小发生改变时需要手工调用
	     * @param {number} width 宽度
	     * @param {number} height 高度
	     */
	    fishTopoProto.resize = function () {
	        this._zr.resize();
	
	    };
	
	    fishTopoProto.dispatchAction = function (payload) {
	        if(!actions[payload.type]) {
	            return;
	        }
	    }
	
	    /**
	     * @method option
	     * 修改画布的选项
	     * @param {String} key 键  如：roam linkModify  textEditable等
	     * @param {Boolean|String|Function} value 选项值
	     */
	    fishTopoProto.option = function(key,value) {
	        var model = new Model(this.options);
	        if (arguments.length === 0) {
	            return zrUtil.clone(this.options);
	        } else if (arguments.length === 1) {
	            return model.get(key);
	        } else if (arguments.length === 2) {
	            if (key === "roam") {
	                this.setRoam(value);
	            }
	            return model.set(key,value);
	        }
	    }
	
	
	    fishTopoProto.init = function () {
	        this.group = new graphic.Group();
	        this.group.isBg = true;
	
	        // 鼠标平移操作
	        if ((this.options.roam === true) || (this.options.roam === 'move')) {
	            this.zrMove();
	        }
	
	        this._zr.add(this.group);
	
	        //是否允许鼠标滚轮放大缩小
	        if ((this.options.roam === true) || (this.options.roam === 'scale')) {
	            this.zrScale();
	        }
	
	        this.connectionManager.connectors = [];
	        //mouseup 会在各个node或线的click事件之点执行  在选中节点或线前 先清空选中效果
	        this._zr.on("mouseup", function (e) { // clearSelect
	            // 1. 清空节点的选中效果
	            this._removeOperationNode();
	            // 2. 点击的线 ，则直接返回
	            var shape = e.target;
	            if (shape && shape.model && Flow.isLink(shape.model)) {
	                return;
	            }
	            if (shape && shape.connector instanceof Connector) {
	                return;
	            }
	            // 3. 清空连接线
	            this.connectionManager.clearSelectCon();
	            // 4. 点击的是线上操作按钮，则直接返回
	            if (shape && shape._isLineOperationIcon && shape._isLineOperationIcon == true) {
	                return;
	            }
	            // 5.隐藏线上操作图标
	            this.lineOperationManager.hideAllLineOperation();
	        }.bind(this));
	
	        this._zr.on("click", function (e) {
	            var nodeTarget = e.target;
	            var shape;
	            if (nodeTarget) {
	                shape = nodeTarget.model;
	            }
	            if ((nodeTarget && shape && Flow.isLink(shape)) || (nodeTarget && shape && Flow.isNode(
	                    shape))) {
	                return;
	            }
	            var params = {};
	            params.event = e;
	            params.type = "click";
	            params.target = this;
	            this._api.trigger(params.type, params);
	        }.bind(this));
	        this.on('conPointsGroup:click', function (argument) {
	            this.lineOperationManager.bindOperation(argument.lineNode);
	        }.bind(this));
	    };
	
	    fishTopoProto.setRoam = function (value) {
	        //是否允许鼠标滚轮放大缩小
	        if ((value === true) || (value === 'move')) {
	            this.zrMove();
	        }
	        if ((value === true) || (value === 'scale')) {
	            this.zrScale();
	        }
	        if (value === false ) {
	            this._zr.off("mousedown");  //禁止 拖拽画布
	            this._zr.off("mousewheel");//禁止用户缩放画布
	        }
	    }
	
	    /**
	     * @method toJson
	     * 导出json
	     * @return {Object} json对象
	     */
	    fishTopoProto.toJson = function () {
	        return FlowUtil.toJson(this.model, this.group);
	    }
	
	    /**
	     * @method fromJson
	     * 导入json
	     * @param  {Object} json对象
	     */
	    fishTopoProto.fromJson = function (json) {
	        this.clear();
	        var model = new Model(json);
	        this.setBackground(model.get(Constants.BACKGROUND));
	        var layoutRootNode = [];
	        FlowUtil.fromJson(this, this.group, model.get(Constants.CHILDS), false, layoutRootNode);
	        // for (var i = 0; i < layoutRootNode.length; i++) {
	        //     this.layoutNode("tree", {
	        //         "node": layoutRootNode[i],
	        //         "type": layoutRootNode[i].treeType
	        //     });
	        // }
	    };
	    /**
	     * 添加节点或线段到画布 同add方法
	     * @method addNode
	     * @param {Object} node createNode或createLink返回的对象
	     * @param {Object} [option] 参数对象
	     * @param {Boolean} [option.trigger] 是否触发 beforeCreate事件
	     * @returns {Object} 返回添加成功的节点 ，如被用户取消之类则 返回null
	     */
	    /**
	     * 添加节点或线段到画布 同addNode方法
	     * @method add
	     * @param {Object} node createNode或createLink返回的对象
	     * @param {Object} [option] 参数对象
	     * @param {Boolean} [option.trigger] 是否触发 beforeCreate事件
	     * @returns {Object} 返回添加成功的节点 ，如被用户取消之类则 返回null
	     */
	    fishTopoProto.add = fishTopoProto.addNode = function (node,options) {
	        if (!node) return null;
	
	        var opt = options || {};
	        if(opt.trigger !==false && (!this._trigger('beforeCreate', {target:node}))) {
	            return null;
	        }
	        if (node instanceof Connector) {
	            this.addConnectorAttrEvent(node);
	        } else {
	            if (Flow.isGroupNode(node)) {
	                node.willRender();
	                var groupOptions = node.model.get(Constants.OPTIONS);
	                if (groupOptions.mergedImage) {
	                    var groupReplaceImage = new flowNode.Image({
	                        style: {
	                            image: groupOptions.mergedImage,
	                            text: groupOptions.style.text,
	                            textPosition: 'bottom'
	                        },
	                        position: [-5000, -5000]
	                    });
	                    this.drag(groupReplaceImage);
	                    node._relationImage = groupReplaceImage;
	                    this.group.add(groupReplaceImage);
	                    setTimeout(function () {
	                        groupReplaceImage.hide();
	                    }, 300);
	                    node.on('dblclick', function () {
	                        node.merged();
	                    })
	                }
	                //遍历组中所有节点
	                node.each(function (child) {
	                        if (child instanceof Connector) {
	                            this.addConnectorAttrEvent(child);
	                        } else {
	                            this.addNodeAttrEvent(child, groupOptions.childDraggable);
	                            if (util.isUndefined(child.selectable)) {
	                                child.selectable = false;  //组内默认不可选中
	                            }
	                            if (child.relative) {
	                                this._handleRelativePostion(child)
	                            }
	                            if (child.hoverStyle) {
	                                graphic.setHoverStyle(child);
	                            }
	                        }
	                        this._trigger("create", {target:child});
	                }, this);
	            }
	            this.addNodeAttrEvent(node, true);
	        }
	        this._trigger("create", {target:node});
	
	        if (node.hoverStyle) {
	            graphic.setHoverStyle(node);
	        }
	
	        this.group.add(node);
	        if (node.relative) {  //必须在加入画布后执行
	            this._handleRelativePostion(node)
	        }
	        if (node.hoverAnimation && this.options.isAnimationEnabled) {
	            flowNode.addHoverAnimation(node);
	        }
	        return node;
	    };
	
	    fishTopoProto.addConnectorAttrEvent = function (connector) {
	        var that = this;
	        connector.options.isEdit = !!this.options.linkModify;
	        connector.on("mousedown", function () {
	            this.connectionManager.connectorForbidEdit(!this.options.linkModify);
	            this.isNode = false;
	        }.bind(this));
	        this.connectionManager.add(connector);
	        //支持双击编辑
	        connector.on("dblclick", function () {
	            if (typeof this.options.text.textEditable == "undefined") {
	                if (that.options.textEditable) {
	                    that.connectorEdit(this);
	                }
	            } else {
	                if (this.options.text.textEditable) {
	                    that.connectorEdit(this);
	                }
	            }
	        });
	    }
	
	    fishTopoProto.addNodeAttrEvent = function (node, childDraggable) {
	        var that = this;
	        if (childDraggable) {
	            this.drag(node);
	        }
	
	        node.attr("operationIcons", node.model.get('options.operationIcons'));
	
	        //侦听节点的click dblclick事件，选中，并派发出去
	        node.on('click', function (event) {
	            var targeNode = this;
	            that.nodeClickHandler(targeNode);
	
	            var params = {};
	            params.event = event;
	            params.type = 'click';
	            params.target = targeNode;
	            that._api.trigger(params.type, params);
	            event.cancelBubble = true;
	
	            //判断一下是否是组内成组的点击事件，如果是的话，那组也也派发一下
	            if (Flow.isInGroup(targeNode)) {
	                var parentNode = targeNode.parent;
	                parentNode.trigger('click', {event:event, type:'click',target:parentNode});
	            }
	        });
	        node.on('dblclick', function (e) {
	            var targeNode = this;
	            if (!targeNode.style || (typeof targeNode.style.textEditable == "undefined")) {
	                if (that.options.textEditable) {
	                    that.nodeEdit(targeNode);
	                }
	            } else {
	                if (targeNode.style.textEditable) {
	                    that.nodeEdit(targeNode);
	                }
	            }
	            var params = {};
	            params.event = e;
	            params.type = 'dblclick';
	            params.target = targeNode;
	            that._api.trigger(params.type, params);
	
	            e.cancelBubble = true;
	        });
	
	        this.allNodes.push(node);
	    }
	
	    fishTopoProto._handleRelativePostion = function(node) {
	        var parentEl = node.parent;
	        var containerInfo = parentEl === this.group
	            ? {
	                width:this._api.getWidth(),
	                height:this._api.getHeight()
	            }
	            : {
	                width:parentEl.getBoundingRect().width,
	                height:parentEl.getBoundingRect().height
	            }
	        layout.positionElement(node, node.relative, containerInfo, node.relative.padding, {boundingMode:node.relative.bounding||'all'});
	    }
	
	    fishTopoProto._getParentZr = function(node) {
	        var parentZr = null;
	        if (node && node.parent) {
	            parentZr = node.parent;
	        } else {
	            parentZr = this.group;
	        }
	        return parentZr;
	    }
	
	    fishTopoProto._removeOperationNode = function() {
	        if (this.operationNode) {
	            this.group.remove(this.operationNode);
	            this.operationNode.cleanup();
	            this.operationNode = null;
	        }
	    }
	
	    /**
	     * 清空当前实例，会移除实例中所有的节点与线
	     * @method clear
	     */
	    fishTopoProto.clear = function () {
	        for (var i = 0; i < this.allNodes.length; i++) {
	            var parentZr = this._getParentZr(this.allNodes[i]);
	            this.connectionManager.deleteSelectCon(this.allNodes[i], parentZr)
	        }
	        this.connectionManager.connectorMap.clear();
	        this.allNodes = [];
	        this.operationNode = null;
	        this.selectedNode = null;
	        this.connectionManager.connectors = [];
	        this._zr.clear();
	        this.group = new graphic.Group();
	        this.group.isBg = true;
	        this._zr.add(this.group);
	    };
	
	    /**
	     * 创建连线的小图标操作
	     * @param {string} key 小图标的名称
	     * @param {Object} options 小图标的相关参数
	     * @param {String} [options.icon] 小图标路径
	     * @param {Object} [options.lineNode] 线段实例
	     * @param {Function} [options.callback] 点击后的回调
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *                  this.fishTopo.addIcon("icon1", {
	     *                      icon: "https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_ca79a146.png",
	     *                      lineNode: lineNode,
	     *                      callback: function(event) {
	     *                          alert(JSON.stringify(event.data))
	     *                      },
	     *                  });
	     */
	    fishTopoProto.addLineIcon = fishTopoProto.addIcon = function (key, options) {
	        this.lineOperationManager.addIcon(key, options);
	    };
	
	    /**
	     * 创建连线的默认删除操作
	     * @param  {Object} lineNode 线
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.lineDefaultIcon(lineNode);
	     */
	    fishTopoProto.lineDefaultIcon = function (lineNode) {
	        this.addLineDeleteIcon(lineNode);
	        this.addLineChangeIcon(lineNode);
	    };
	
	    /**
	     * 创建连线的默认删除操作
	     * @param  {Object} lineNode 线
	     * @param {Object} [options] 连线操作的选项
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.addLineChangeIcon(lineNode);
	     */
	    fishTopoProto.addLineDeleteIcon = function (lineNode,options) {
	        //创建删除
	        this.lineOperationManager.addDeleteIcon(lineNode,options);
	    };
	
	    /**
	     * 创建连线的默认切换类型操作
	     * @param  {Object} lineNode 线
	     * @param {Object} [options] 连线操作的选项
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.addLineChangeIcon(lineNode);
	     */
	    fishTopoProto.addLineChangeIcon = function (lineNode,options) {
	        this.lineOperationManager.addChangeLineTypeIcon(lineNode,options);
	    };
	
	    /**
	     * 变更当前线的类型，如果不传则按顺序取下一个类型。先删除原来的线段 再增加一种类型的线段
	     * @param {String} lineType 欲变更线的类型
	     */
	    fishTopoProto.changeSelectConnectorType = function(lineType) {
	        var nextLineType = lineType;
	        var line = this.connectionManager.selConnector;
	        var originLineType = line.options.style.lineType;
	        if (nextLineType) {
	            if (nextLineType == originLineType) {
	                return;
	            }
	        } else {
	            var arrLineType = [Connector.TYPE_STRAIGHT, Connector.TYPE_JAGGED, Connector.TYPE_CURVE];
	            var index = zrUtil.indexOf(arrLineType, originLineType);
	            nextLineType = arrLineType[(index + 1) % arrLineType.length];
	        }
	
	        //this.remove(line, {trigger:false}); 这样会删除icons
	        this.connectionManager.deleteLine(this._getParentZr(line));
	        this.lineOperationManager.hideAllLineOperation();
	
	        zrUtil.merge(line.options.style, {lineType: nextLineType}, true);
	        var nextLine = this.createConnectorByNodes(line.startNode, line.endNode, line.options);
	        if (nextLine) {
	            nextLine.icons = line.icons;
	            nextLine.on('Connector:click', function () {
	                this.lineOperationManager.bindOperation(nextLine);
	            }.bind(this));
	        }
	    }
	
	    fishTopoProto.initOperationNode = function (node) {
	        this.operationNode = new OperationNode(node, this.group, this._api);
	
	        this.operationNode.on(OperationNode.ARROW_DRAGSTART, function (e) {
	            var x = (e.event.offsetX - this.group.position[0]) / this.nowZoom;
	            var y = (e.event.offsetY - this.group.position[1]) / this.nowZoom;
	            //拖拽开始先把 箭头图标 给隐藏
	            var arrow = e.event.target;
	            arrow.hide();
	            var rEndPoint = new Point(x, y);
	            var connector = this.connectionManager.manageTempConnector(this.selectedNode, rEndPoint,
	                arrow.lineType);
	            this.group.add(connector);
	            e.cancelBubble = true;
	        }.bind(this));
	
	        // 侦听 箭头 拖拽事件
	        this.operationNode.on(OperationNode.ARROW_DRAG, function (e) {
	            var x = (e.event.offsetX - this.group.position[0]) / this.nowZoom;
	            var y = (e.event.offsetY - this.group.position[1]) / this.nowZoom;
	            var arrow = e.event.target;
	            var rEndPoint = new Point(x, y);
	            this.connectionManager.manageTempConnector(this.selectedNode, rEndPoint, arrow.lineType);
	            e.cancelBubble = true;
	        }.bind(this));
	
	        //侦听 箭头 拖拽结束事件 画线
	        this.operationNode.on(OperationNode.ARROW_DRAGEND, function (e) {
	            e.cancelBubble = true;
	            var x = e.event.offsetX;
	            var y = e.event.offsetY;
	            var targetNode = null;
	            //拖拽结束先把 箭头图标 给显示
	            var arrow = e.event.target;
	            arrow.show();
	            //删除临时线
	            this.connectionManager.removeTempConnector(this.group);
	
	            //1.如果是子节点 内 节点拖拽 则 增加排除子节点的参数
	            targetNode = findHover(this.allNodes, x, y);
	
	            function isHover(node, x, y) {
	                return node.rectContain(x, y);
	            }
	
	            function findHover(list, x, y, excludes) {
	                for (var i = list.length - 1; i >= 0; i--) {
	                    if (isExclude(excludes, list[i]) //list[i] !== exclude
	                        // getDisplayList may include ignored item in VML mode
	                        &&
	                        !list[i].ignore && isHover(list[i], x, y)) {
	                        return list[i];
	                    }
	                }
	            }
	
	            function isExclude(excludes, node) {
	                return zrUtil.indexOf(excludes, node) == -1;
	            }
	
	            //2.如果找到目标结点 则画线
	            if (targetNode && (this.selectedNode != targetNode)) {
	                var connectOptions;
	                if (e.data) {
	                    connectOptions = e.data;
	                } else {
	                    connectOptions = {
	                        style: {
	                            lineType: arrow.lineType
	                        }
	                    }
	                }
	                if(!this._trigger('beforeCreate', {target:this.selectedNode,endNode:targetNode,connectOptions:connectOptions})) {
	                    return null;
	                }
	                this.createConnectorByNodes(this.selectedNode, targetNode, connectOptions);
	            }
	        }.bind(this));
	
	        //删除按钮点击事件
	        this.operationNode.on(OperationNode.DELETE_CLICK, function () {
	            this.removeNode(this.selectedNode);
	        }.bind(this));
	        this.group.add(this.operationNode);
	    };
	
	    /**
	     * 移除场景中的某个节点或者线段,同removeNode
	     * @method remove
	     * @param  {Object} node or link 待删除的节点或者线段
	     * @param {Object} [options] 参数
	     * @param {Boolean} [options.trigger=true] 是否触发删除事件
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.remove(peopleNode);
	     */
	
	    /**
	     * 移除场景中的某个节点或者线段,同remove
	     * @method removeNode
	     * @param  {Object} node or link 待删除的节点或者线段
	     * @param {Object} [options] 参数
	     * @param {Boolean} [options.trigger=true] 是否触发删除事件
	     *
	     *  **使用范例**：
	     *
	     *      @example
	     *      fishTopo.removeNode(peopleNode);
	     */
	    fishTopoProto.remove = fishTopoProto.removeNode = function (delNode, options) {
	        var opt = options || {};
	        if(opt.trigger !==false && (!this._trigger('beforeDelete', {target:delNode}))) {
	            return;
	        }
	        var parentZr = this._getParentZr(delNode);
	        if (delNode instanceof Connector) {
	            // 1.1 删除线段上的操作图标
	            zrUtil.each(delNode.icons, function(lineOperationIcon) {
	                parentZr.remove(lineOperationIcon);
	            })
	            // 1.2 删除当前选中线段
	            this.connectionManager.deleteByLine(delNode,parentZr);
	        } else {
	            //2.1 删除节点
	            parentZr.remove(delNode);
	            //2.2 从allNodes数组中删除
	            for (var i = 0; i < this.allNodes.length; i++) {
	                if (delNode.id == this.allNodes[i].id) {
	                    this.allNodes.splice(i, 1);
	                }
	            }
	            //2.3 删除和节点相关联的线段
	            this.connectionManager.deleteSelectCon(delNode, this.group);
	            //2.4 删除节点操作
	            this._removeOperationNode();
	        }
	
	        //3. 清空连接线上的调整位置按钮
	        this.connectionManager.clearSelectCon();
	        //4. 清空连接线上的操作按钮
	        this.lineOperationManager.hideAllLineOperation();
	        //4. 派发删除事件
	         this._trigger("delete", {target:delNode});
	    };
	
	
	    /**
	     * 根据节点创建连线
	     * @method createConnectorByNodes
	     * @param  {Object} startNode 开始节点
	     * @param  {Object} endNode   结束节点
	     * @param  {Object} options 线段选项 参见{@link fishTopoFlow.link#constructor 构造函数options参数}
	     */
	    fishTopoProto.createConnectorByNodes = function (startNode, endNode, options) {
	
	        var linkType = options.style.lineType || Connector.TYPE_STRAIGHT;
	        if (!flowLink[linkType]) {
	            return null;
	        }
	        var Link = flowLink[linkType];
	        var connector = new Link(startNode, endNode, options);
	        this.connectionManager.add(connector);
	
	        if (startNode.parent && endNode.parent) {
	            endNode.parent.add(connector);
	        } else {
	            this.group.add(connector);
	        }
	
	        connector.on("mousedown", function () {
	            this.connectionManager.connectorForbidEdit(!this.options.linkModify);
	            this.isNode = false;
	        }.bind(this));
	        connector.on("dblclick", function () {
	            if (this.options.textEditable) {
	                this.connectorEdit(this);
	            }
	        }.bind(this));
	
	        this._trigger("create", {target:connector});
	        return connector;
	    };
	
	    /**
	     * @private
	     * 派发创建完成事件  返回fales则取消
	     */
	    fishTopoProto._trigger = function(type, event, data) {
	        var callback = this.options[type];
	
	        if (data === void 0) data = {};
	        if (event === null) {
	            event = {type:type, target:this}
	        } else {
	            event.type = type;
	        }
	        event.data = data;
	        this._api.trigger(event.type, event);
	        return !(zrUtil.isFunction(callback) && callback.apply(this, [event].concat(data)) === false);
	    }
	
	
	    fishTopoProto.nodeClickHandler = function (node) {
	        // 鼠标点下 将操作框 移到对应的节点上
	        if (node.selectable === false) {
	            if (Flow.isInGroup(node)) {
	                var group = node.parent;
	                if (group.selectable === false) {
	                    return;
	                } else {
	                    node = group;   // 如果有组的话，就针对组进行处理
	                }
	            } else {
	                return;
	            }
	        }
	
	        this.selectedNode = node;
	        var shapeRect = util.getRect(node);
	        if (!this.operationNode) {
	            this.initOperationNode(node);
	        }
	        // 在存在子流程的情况下 需要把node也传递一下
	        this.operationNode.refreshPostion(node, shapeRect);
	    };
	
	    fishTopoProto._groupDragHandler = function (x, y) {
	        // flow中最外层的group移动操作
	        var nowGroupPosition = this.group.position;
	        var groupPositionX = this.group.position[0];
	        var groupPositionY = this.group.position[1];
	
	        var moveHandler = function (event) {
	            var width = this.group.getBoundingRect().width * this.nowZoom;
	            var height = this.group.getBoundingRect().height * this.nowZoom;
	            var gx = this.group.getBoundingRect().x * this.nowZoom;
	            var gy = this.group.getBoundingRect().y * this.nowZoom;
	            var min = [10 - (width + gx), 10 - (height + gy)];
	            var max = [(this._zr.getWidth() - gx) - 10, (this._zr.getHeight() - gy) - 10];
	            var sX = event.offsetX - x;
	            var sY = event.offsetY - y;
	            nowGroupPosition[0] = groupPositionX + sX;
	            nowGroupPosition[1] = groupPositionY + sY;
	            if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] <
	                min[0] || nowGroupPosition[1] < min[1]) {
	                return;
	            } else {
	                this.group.attr("position", nowGroupPosition);
	                if (this.eagleEye == true) {
	                    this.minimap.updataSelectionPosition(nowGroupPosition, this.nowZoom);
	                }
	            }
	        }.bind(this);
	        this._zr.on('mousemove', moveHandler);
	
	        var endDragHandler = function () {
	            this._zr.off('mousemove', moveHandler);
	            this._zr.off('mouseup', endDragHandler);
	            this._zr.off("globalout", endDragHandler);
	        }.bind(this);
	        this._zr.on('mouseup', endDragHandler);
	        this._zr.on("globalout", endDragHandler);
	    };
	
	    /**
	     * @private
	     * 节点的移动操作, 为何要自己实现拖动？zredner Group不支持拖动，只能自己实现
	     */
	    fishTopoProto.drag = function (node) {
	        var that = this; // zrender中的一个bug event.target不会带group 只能用that 不能用bind(this)
	        node.on("mousedown", function (event) {
	            var draggingTarget = this;
	            //如果加了属性 draggable:false 则不可以拖动
	            if (draggingTarget.isdraggable == false) {
	                return;
	            }
	            that._nodeDragHandler(draggingTarget, event.offsetX, event.offsetY);
	            event.cancelBubble = true;
	        });
	    };
	
	    fishTopoProto._nodeDragHandler = function (node, x, y) {
	        var isMove = 0;
	        var nowGroupPosition = node.position;
	        var groupPositionX = node.position[0];
	        var groupPositionY = node.position[1];
	        node._startX = x;
	        node._startY = y;
	
	        node.trigger("dragstart");
	        // 1、侦听移动事件
	
	        var moveHandler = function (event) {
	            event.cancelBubble = true;
	            var sX = (event.offsetX - node._startX) / (this.nowZoom);
	            var sY = (event.offsetY - node._startY) / (this.nowZoom);
	
	            if ((sX != 0) || (sY != 0)) {
	                isMove = 1;
	            }
	            node.trigger("drag");
	            // 1.1处理组内的情况（如果节点拖动，组也跟着变）
	            if (Flow.isInGroup(node)) {
	                //放入node现有数值，用于重绘group
	                var nodeMessage = {
	                    width: node.shape.width,
	                    height: node.shape.height,
	                    position: node.position,
	                    movePosition: [groupPositionX, groupPositionY],
	                    moveX: sX,
	                    moveY: sY,
	                    node: node
	                };
	                node.parent.modifyGroupRect(nodeMessage);
	            }
	            nowGroupPosition[0] = groupPositionX + sX;
	            nowGroupPosition[1] = groupPositionY + sY;
	            node.attr("position", nowGroupPosition);
	            // 1.2 处理告警的情况 （告警随着节点移动）
	            if (node.alarm) {
	                var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm
	                        .getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect()
	                    .height - 3
	                ];
	                node.alarm.attr("position", newAlarmPosition);
	            }
	            // 1.4 触发点击
	            this.nodeClickHandler(node);
	            // 1.5 刷新连线
	            this.connectionManager.refreshLineByNode(node);
	        }.bind(this);
	        this._zr.on('mousemove', moveHandler);
	
	
	
	        //2. 拖拽结束
	        var endDragHandler = function () {
	            if (node.model) {
	                node.model.set("options.position", FlowUtil.truncPosition(node.position));
	            }
	
	            this._zr.off('mousemove', moveHandler);
	            this._zr.off('mouseup', endDragHandler);
	            this._zr.off("globalout", endDragHandler);
	
	            //2.1 缩微图
	            if (isMove == 1) {
	                this._trigger("dropDrag", {target:node});
	                node.trigger("dragend");
	                if (this.eagleEye == true) {
	                    this.openEagleEye(this.eagleEyeNode);
	                }
	            }
	        }.bind(this);
	        this._zr.on('mouseup', endDragHandler);
	        this._zr.on('globalout', endDragHandler);
	    }
	
	
	    /**
	     * 创建节点
	     * @method createNode
	     * @param  {String} type 类型 eg. 'Rect'、'Circle'、'Image'、'Group'、'Text'等
	     * @param  {Object} opt 节点选项 详见{@link fishTopoFlow.node Config options}
	     * @param {Object} userData 用户传递的业务数据
	     * @return {Object} 创建的节点对象
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *      var rect = this.fishTopo.createNode("Rect", { //矩形
	     *          shape: {
	     *              width: 100,
	     *              height: 60,
	     *          },
	     *          style: {
	     *              text: "基本矩形",
	     *              fill: "#167CFF",
	     *              stroke: "rgb(255,255,255)",
	     *              textFont: '14px Microsoft YaHei'
	     *          },
	     *          position: [180, 100],
	     *          operationIcons: [{ name: 'DEL' },
	     *              { name: 'STRAIGHT' },
	     *              { name: 'JAGGED' },
	     *              { name: 'CURVE' },
	     *              {
	     *                  name: "custom1",
	     *                  iconPath: "img/host.png",
	     *                  callback: function(e) { alert(e.data.name + " clicked") }  //e.node是当前的节点
	     *              }
	     *          ]
	     *      });
	     */
	    fishTopoProto.createNode = fishTopoProto.creatNode = function (type, opt, userData) {
	        if (!flowNode[type]) {
	            return null;
	        }
	        var Shape = flowNode[type];
	        var node = new Shape(opt);
	
	        Flow.setUserData(node, userData);
	        return node;
	    };
	
	    /**
	     * 根据name获取节点
	     * @param  {String} name 在创建节点中  name属性设置的值
	     * @return {Object}      name对应的节点
	     */
	    fishTopoProto.childOfName = function (name) {
	        var arrResult = [];
	        var childrenNode = this.allNodes;
	        var childrenLine = this.connectionManager.connectors;
	        for (var i = 0; i < childrenNode.length; i++) {
	            if (childrenNode[i].model.get("options.name") && childrenNode[i].model.get("options.name") ==
	                name) {
	                arrResult.push(childrenNode[i]);
	            } else if (childrenNode[i].model.get("userData.name") == name) {
	                arrResult.push(childrenNode[i]);
	            }
	        }
	        for (var j = 0; j < childrenLine.length; j++) {
	            if (childrenLine[j].model.get("options.name") && childrenLine[j].model.get("options.name") ==
	                name) {
	                arrResult.push(childrenLine[j]);
	            } else if (childrenLine[j].model.get("userData.name") == name) {
	                arrResult.push(childrenLine[j]);
	            }
	        }
	        if (arrResult.length > 1) {
	            return arrResult;
	        } else {
	            return arrResult[0];
	        }
	    };
	
	    /**
	     * 查找场景中的对象   例如: x坐标大于100的节点 findElements(function(node){ return node.position[0] > 100; });
	     * @param  {Function} cb      回调函数 参数为遍历的节点
	     * @param  {Object}   context 回调函数执行的上下文
	     * @return {Array}           返回查找到的对象
	     */
	    fishTopoProto.findElements = function (cb, context) {
	        var childrenNode = this.allNodes;
	        var childrenLine = this.connectionManager.connectors;
	        var arr = [];
	        for (var i = 0; i < childrenNode.length; i++) {
	            var child = childrenNode[i];
	            if (cb.call(context, child, i)) {
	                arr.push(child);
	            }
	        }
	        for (var j = 0; j < childrenLine.length; j++) {
	            var childL = childrenLine[j];
	            if (cb.call(context, childL, j)) {
	                arr.push(childL);
	            }
	        }
	        return arr;
	    };
	
	    /**
	     * 设置背景色  或 背景图片
	     * @param {string} imageUrl 背景色  或 背景图片 eg. 'img/bg.jpg'，为‘gridLine’时网格背景
	     * @param {string} isRepeat 是否重复背景  如果重复的话，将使用css的repeat 因为canvas不支持repeat
	     */
	    fishTopoProto.setBackground = function (imageUrl, isRepeat) {
	        if (imageUrl && imageUrl.length > 0) {
	            this.model.set(Constants.BACKGROUND, imageUrl);
	            if (imageUrl.substr(0, 1) == "#" || imageUrl.substr(0, 4) == "rgba") { //如果是颜色创建rect为背景
	                if (!document.createElement('canvas').getContext) {
	                    this._dom.style.backgroundColor = imageUrl;
	                } else {
	                    var imageShape = new this.Shape.Rect({
	                        shape: {
	                            width: this._zr.getWidth(),
	                            height: this._zr.getHeight()
	                        },
	                        style: {
	                            fill: imageUrl
	                        },
	                        cursor: 'default',
	                        z: -1
	                    });
	                    this._zr.add(imageShape);
	                }
	
	            } else if (imageUrl == "gridLine") {
	                this.gridLineGroup = new graphic.Group();
	                this.gridLine(0.2);
	                this._zr.add(this.gridLineGroup);
	            } else {
	                if (!document.createElement('canvas').getContext || isRepeat) {
	                    this._dom.style.backgroundImage = "url(" + imageUrl + ")";
	                    this._dom.style.backgroundRepeat = "repeat";
	                } else {
	                    var imageShape1 = new this.Shape.Image({ //如果是图片创建image为背景
	                        position: [0, 0],
	                        scale: [1, 1],
	                        style: {
	                            x: 0,
	                            y: 0,
	                            image: imageUrl,
	                            width: this._zr.getWidth(),
	                            height: this._zr.getHeight()
	                        },
	                        cursor: 'default',
	                        z: -1
	                    });
	                    this._zr.add(imageShape1);
	                }
	            }
	        }
	    };
	
	    //背景网格线
	    fishTopoProto.gridLine = function (opacity) {
	        var pixel = 10;
	        var widthLen = parseInt(this.getWidth() / pixel);
	        for (var x = 0; x <= widthLen; x++) {
	            var lineX = new graphic.Line({
	                shape: {
	                    x1: x * pixel,
	                    y1: 0,
	                    x2: x * pixel,
	                    y2: this.getHeight()
	                },
	                style: {
	                    lineDash: [1],
	                    opacity: opacity
	                },
	                z: 0,
	                draggable: false,
	                cursor: 'default'
	            });
	            this.gridLineGroup.add(lineX);
	        }
	
	        var heightLen = parseInt(this.getHeight() / pixel, pixel);
	        for (var y = 0; y <= heightLen; y++) {
	            var lineY = new graphic.Line({
	                shape: {
	                    x1: 0,
	                    y1: y * pixel,
	                    x2: this.getWidth(),
	                    y2: y * pixel
	                },
	                style: {
	                    lineDash: [1],
	                    opacity: opacity
	                },
	                z: 0,
	                draggable: false,
	                cursor: 'default'
	            });
	            this.gridLineGroup.add(lineY);
	        }
	    };
	
	    /**
	     * 创建线段
	     * @method createLink
	     * @param  {Object} startNode 开始节点
	     * @param  {Object} endNode   结束节点
	     * @param  {Object} options 线段选项
	     * @param {Object} [options.style] 节点的样式
	     * @param {Number} [options.style.lineWidth=1] 线段的宽度
	     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	     * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	     * @param {Object} [options.symbol] 线段的箭头
	     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	     * @param {Object} [options.text] 线段上的文字
	     * @param {String} [options.text.text] 线段上的文字内容
	     * @param {String} [options.text.color] 线段上的文字颜色
	     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {String} [options.position] 指定线段位置
	     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {Object} [options.position.startOffset] 线段开始位置的偏移
	     * @param {Object} [options.position.endOffset] 线段结束位置的偏移
	     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	     * @param {Object} [options.effect] 线上动态效果
	     * @param {String} [options.effect.show] 是否显示箭头动效
	     * @param {Number} [options.effect.period] 动效移动速度
	     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	     * @param {Number} [options.z] [连线的层级，越大越在前面显示]
	     * @param {Object} userData 用户传递的业务数据
	     * @return {Object} 创建的线段对象
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *      var link = me.fishTopo.createLink(startNode, endNode, {
	     *              symbol: { type: 'arrow', size: 10, color: "rgb(0,200,255)" }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     *              style: { lineWidth: 3, stroke: "rgb(0,200,255)", lineDash: [3,3], lineType: "jagged"  }, //样式
	     *              text: {
	     *                  text: text,
	     *                  color: '#ffffff',
	     *                  textPos:textPos,//文字位置可选值 'start','center','end',默认值为center
	     *                  xOffset:10, //文字位置x偏移量
	     *              },
	     *              pos:'right,left',
	     *              effect: {
	     *                  show: true,//是否显示箭头动效
	     *                  period: 6,//箭头速度
	     *              },
	     *              position:{
	     *                    escapeDistance:[50,30],  //第一条折线的长度，最后一条折线的长度
	     *                    points:["x1,y1","x2,y2"]  不使用自动计算 指定连线的位置数组
	     *              },
	     *              z: 0
	     *          });
	     */
	    fishTopoProto.createLink = fishTopoProto.creatLink = function (startNode, endNode, options, userData) {
	        var linkType = Connector.TYPE_STRAIGHT;
	        if (options && options.style && options.style.lineType) {
	            linkType = options.style.lineType
	        }
	
	        if (!flowLink[linkType]) {
	            return null;
	        }
	        var Link = flowLink[linkType];
	        var connector = new Link(startNode, endNode, options);
	        if (userData) {
	            connector.model.set(Constants.USERDATA, zrUtil.clone(userData));
	        }
	
	        return connector;
	    };
	
	    /**
	     * 根据节点刷新节点所连的线（重新计算线的位置）
	     * @param  {Object} node [节点]
	     */
	    fishTopoProto.refreshLineByNode = function (node) {
	        this.connectionManager.refreshLineByNode(node);
	    };
	
	
	    /**
	     * @private
	     * 线上文字编辑
	     */
	    fishTopoProto.connectorEdit = function (thisConnector) {
	        var lineText = thisConnector.childOfName('lineText');
	        if (!lineText) {
	            return;
	        }
	        var textarea = this.createTextArea();
	        textarea.style.width = 1.1 * util.getRect(lineText).width * this.nowZoom + "px";
	        textarea.style.height = (util.getRect(lineText).height || 12) * this.nowZoom + "px";
	        textarea.style.border = "1px solid #000000";
	        textarea.innerHTML = lineText.style.text;
	        thisConnector.setStyle({
	            text: {
	                text: ""
	            }
	        })
	        this._dom.appendChild(textarea);
	        this._dom.style.position = "relative";
	        var textRect = textContain.getBoundingRect(lineText.style.text, lineText.style.textFont);
	        textarea.style.lineHeight = (textRect.lineHeight || 14) + "px";
	        textarea.style.top = (lineText.position[1] - util.getRect(lineText).height) * this.nowZoom + this.group
	            .position[1] + "px";
	        textarea.style.left = (lineText.position[0] - 0.05 * util.getRect(lineText).width) * this.nowZoom +
	            this.group.position[0] + "px";
	        textarea.focus();
	        textarea.select();
	        $(textarea).on("keyup", zrUtil.bind(function (e) {
	            var textRect = textContain.getBoundingRect(lineText.style.text, lineText.style.textFont);
	            this._textareaResize(textRect, textarea, e);
	        }, this));
	        $(textarea).on("focusout", function () {
	            thisConnector.setStyle({
	                text: {
	                    text: textarea.value || ""
	                }
	            })
	            textarea.remove();
	        })
	    };
	    /**
	     * @private
	     * 节点上文字编辑
	     */
	    fishTopoProto.nodeEdit = function (thisNode) {
	        var isNotSetText = false;
	        var textarea = this.createTextArea();
	        var nodeText = zrUtil.clone(thisNode.style.text);
	        var textRect = textContain.getBoundingRect(nodeText, thisNode.style.textFont);
	        textarea.style.width = 2 * textRect.width * this.nowZoom + "px";
	        textarea.style.height = (2 * textRect.height || 12) * this.nowZoom + "px";
	        var nodeRect = util.getRect(thisNode);
	        textarea.style.maxWidth = 1.2 * nodeRect.width * this.nowZoom + "px";
	        textarea.style.lineHeight = (1.2 * textRect.lineHeight || 12) + "px";
	        textarea.style.border = "1px solid #000000";
	        textarea.innerHTML = thisNode.style.text;
	        this.setStyle(thisNode, {text: ""});  //先把节点文本给清空，否则删除文本框中文字的时候，会显示出来
	        this._dom.appendChild(textarea);
	        this._dom.style.position = "relative";
	        var offestI = 1;
	        if (thisNode.style.textAlign == "left") {
	            offestI = 0;
	        }
	        if (thisNode.style.textAlign == "right") {
	            offestI = 2;
	        }
	        var offestP = 0;
	        if (thisNode.style.textPosition && thisNode.style.textPosition == "bottom") {
	            offestP = 1;
	            textarea.style.maxWidth = 3 * 1.1 * nodeRect.width * this.nowZoom + "px";
	        }
	        if (thisNode.style.textPosition && thisNode.style.textPosition == "top") {
	            offestP = -1;
	            textarea.style.maxWidth = 3 * 1.1 * nodeRect.width * this.nowZoom + "px";
	        }
	        textarea.style.top = (nodeRect.y - textRect.height / 2 + offestP * (nodeRect.height - textRect.height /
	            2)) * this.nowZoom + this.group.position[1] + "px";
	        textarea.style.left = (nodeRect.x - offestI * textRect.width / 2 - 0.05 * textRect.width) * this.nowZoom +
	            this.group.position[0] + "px";
	        textarea.focus();
	        textarea.select();
	        textarea.onkeyup = function() {
	            if (event.keyCode == keyCode.ESCAPE) {
	                isNotSetText = true;
	                textarea.blur();
	            } else {
	                var textRect = textContain.getBoundingRect(textarea.value, thisNode.style.textFont);
	                this._textareaResize(textRect, textarea, textarea.style.maxWidth);
	            }
	        }.bind(this);
	
	        textarea.onblur = function() {
	            if (!isNotSetText) {
	                var text = this.handleWrap(textarea.value, textarea.style.maxWidth);
	                this.setStyle(thisNode, {text: text});
	            } else {
	                this.setStyle(thisNode, {text: nodeText});
	            }
	            textarea.remove();
	        }.bind(this);
	    };
	
	    /**
	     * @private
	     * 创建文本域
	     */
	    fishTopoProto.createTextArea = function () {
	        var textarea = document.createElement("textarea");
	        textarea.style.position = "absolute";
	        textarea.style.padding = "6px";
	        textarea.style.resize = "none";
	        textarea.style.whiteSpace = "pre";
	        textarea.style.lineHeight = "125%";
	        textarea.style.overflow = "hidden";
	        textarea.style.border = "0";
	        textarea.spellcheck = false;
	        return textarea;
	    };
	
	    /**
	     * @private
	     * 处理textarea自动换行
	     */
	    fishTopoProto.handleWrap = function (value, width) {
	        var spanNode = document.createElement("span");
	        spanNode.style.position = "absolute";
	        spanNode.style.overflow = "hidden";
	        spanNode.style.border = "0";
	        spanNode.style.padding = "0";
	        spanNode.style.left = "0";
	        spanNode.style.top = "0";
	        this._dom.appendChild(spanNode);
	        var content = value.split("\n");
	        var result = "";
	        $.each(content, function (i, val) {
	            var valLength = val.length;
	            if (valLength == 0) {
	                //result += "\n";
	            } else {
	                var pre = "",
	                    innerVal, tempWidth, conWidth;
	                for (var innerI = 0; innerI < valLength; innerI++) {
	                    innerVal = val.charAt(innerI);
	                    $(spanNode).text($(spanNode).text() + innerVal);
	                    tempWidth = $(spanNode).width(); //获取添加字符后隐藏域的宽度
	                    conWidth = Number(width.substring(0, width.length - 2));
	                    if (tempWidth > conWidth) {
	                        result += pre; //如果追加字符后隐藏域宽度大于TextArea宽度，则表明该字符为下一行字符，
	                        result += "\n";
	                        $(spanNode).text(innerVal);
	                        pre = innerVal;
	                    } else if (innerI == valLength - 1) {
	                        result += pre + innerVal; //最后一个字符
	                        if (i < content.length - 1) {
	                            result += "\n";
	                        }
	                        $(spanNode).text("");
	                        pre = "";
	                    } else {
	                        pre += innerVal; //依次追加到pre变量中
	                    }
	
	                }
	            }
	        });
	        this._dom.removeChild(spanNode);
	        return result;
	    };
	
	    /**
	     * @private
	     * 文本域自适应高宽
	     */
	    fishTopoProto._textareaResize = function (textRect, textarea, width) {
	        var minWidth = 0;
	        textarea.style.width = 0;
	        textarea.style.width = (1.1 * textRect.width) * this.nowZoom + "px";
	        if (width < 60) {
	            minWidth = width;
	        } else {
	            minWidth = 60
	        }
	        if (textRect.width <= minWidth) {
	            textarea.style.width = minWidth + "px";
	        }
	        textarea.style.height = "0px";
	        textarea.style.height = textarea.scrollHeight + 'px';
	        if (textarea.scrollHeight <= 0) {
	            textarea.style.height = "12px";
	        }
	    }
	
	    /**
	     * @method setStyle
	     * 节点更改style里的属性
	     * @param {String} name 节点style里的某个属性名称
	     * @param {String} string 节点style里的某个属性名称对应的值
	     * **使用范例**：
	     *
	     *      @example
	     *          //节点设置文字
	     *         fishtopo.setStyle(node,{text:"例子"});
	     */
	    fishTopoProto.setStyle = function (node, options) {
	        node.setStyle(options);
	        zrUtil.merge(node.model.get("options.style"), options, true);
	    }
	
	    /**
	     * @method setShape
	     * 节点更改shape里的属性
	     * @param {String} name 节点shape里的某个属性名称
	     * @param {String} string 节点shape里的某个属性名称对应的值
	     * **使用范例**：
	     *
	     *      @example
	     *          //矩形节点设置宽
	     *         fishtopo.setShape(node,{width:100});
	     */
	    fishTopoProto.setShape = function (node, options) {
	        node.setShape(options);
	        zrUtil.merge(node.model.get("options.shape"), options, true);
	    }
	
	    /**
	     * 创建节点上面的警告
	     * @method createAlarm
	     * @param  {Object} node 节点
	     * @param  {Object} opt  选项值
	     * @param  {Object} [opt.text] 警告的文字
	     * @param  {Object} [opt.textFont] 警告的文字的字体
	     * @param  {Object} [opt.textFill] 警告的文字的颜色
	     * @param  {Object} [opt.textBackground] 警告的背景的颜色
	     * @return {Object} 返回节点上的警告
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *          this.fishTopo.createAlarm(s1,{
	     *          text:"2 W",
	     *          textFont:"4px Microsoft YaHei",
	     *          textFill:"#FFFFFF",
	     *          textBackground:"rgba(255,0,0,0.6)"
	     *      });//创建小图片和节点绑定
	     */
	    fishTopoProto.createAlarm = fishTopoProto.creatAlarm = function (node, opt) {
	        var group = this.createNode("Group", {
	            style: {
	                fill: 'rgba(0,0,0,0)',
	                stroke: 'rgba(0,0,0,0)'
	            }
	        });
	        group.isdraggable = false;
	        var text = this.createNode("Text", { //文字
	            style: {
	                text: opt.text,
	                textFont: opt.textFont,
	                fill: opt.textFill,
	                textBaseline: "top" //垂直对齐,
	            },
	            selectable: false,
	            position: [2, 0],
	            z: 2
	        });
	        text.isdraggable = false;
	        group.add(text);
	        if (Flow.isInGroup(node)) {
	            node.parent.add(group);
	        } else {
	            this.group.add(group);
	        }
	        var groupWidth = group.getBoundingRect().width + 2;
	        var groupHeight = group.getBoundingRect().height + 6;
	        var points = [
	            [0, 0],
	            [groupWidth, 0],
	            [groupWidth, groupHeight],
	            [groupWidth - 3, groupHeight],
	            [groupWidth - 6, groupHeight + 3],
	            [groupWidth - 9, groupHeight],
	            [0, groupHeight],
	            [0, 0]
	        ];
	        var Polyline = this.createNode("Polyline", {
	            shape: {
	                points: points
	            },
	            style: {
	                fill: opt.textBackground,
	                stroke: opt.textBackground
	            },
	            selectable: false,
	            z: 1
	        });
	        Polyline.isdraggable = false;
	        group.add(Polyline);
	        var groupPosition = [node.position[0] + node.getBoundingRect().width - (group.getBoundingRect().width -
	            6), node.position[1] - group.getBoundingRect().height - 3];
	        group.attr("position", groupPosition);
	        node.alarm = group;
	        //设置模型 给json序列化用
	        var model = new Model({});
	        model.set(Constants.ELEMENT_TYPE, Constants.ALARM);
	        model.set(Constants.OPTIONS, zrUtil.clone(opt));
	        model.set(Constants.RELATIONID, node.model.get(Constants.ID));
	        group.model = model;
	        return group;
	    };
	
	    /**
	     * @private
	     * 返回当前画布的数据
	     */
	    fishTopoProto.toDataURL = function (opts) {
	        return FlowUtil.toDataURL(this._zr, opts);
	    };
	
	    fishTopoProto.zrMove = function () {
	        this._zr.on("mousedown", function (e) { //点击在节点上或者线上不进行平移操作
	            if ((e.target && e.target.model) || (e.target && e.target.lineType && e.target.parent) ||
	                (e.target && e.target.connector instanceof Connector) || (e.target && e.target instanceof graphic
	                    .Circle)) {
	                return;
	            } else {
	                this._groupDragHandler(e.offsetX, e.offsetY);
	            }
	        }.bind(this));
	    }
	
	    fishTopoProto.initScale = function () {
	        var groupMaxWidth = this.group.getBoundingRect().width;
	        var groupMaxHeight = this.group.getBoundingRect().height;
	        var rangeWidth = this.getWidth();
	        var rangeHeight = this.getHeight();
	        var initRatio = 1,
	            pos = [];
	        if (groupMaxWidth / groupMaxHeight > rangeWidth / rangeHeight) {
	            if (groupMaxWidth > rangeWidth) {
	                initRatio = rangeWidth / groupMaxWidth;
	            }
	        } else {
	            if (groupMaxHeight > rangeHeight) {
	                initRatio = rangeHeight / groupMaxHeight;
	            }
	        }
	        pos[0] = Math.abs(this.group.getBoundingRect().x) * initRatio;
	        pos[1] = Math.abs(this.group.getBoundingRect().y) * initRatio;
	        this.group.attr("position", [pos[0], pos[1]]);
	        this.group.attr("scale", [initRatio, initRatio]);
	        this.initScaleRatio = initRatio;
	        var distance = [pos[0], pos[1], this.initScaleRatio, groupMaxWidth, groupMaxHeight];
	        return distance;
	    };
	
	    /**
	     * 放大或者缩小
	     * @param  {String|Number} type 当为字符串时 "enlarge"放大  "narrowing"缩小  当为数值时 缩放的比例  建议0.3-1.7
	     */
	    fishTopoProto.zrScale = function (type) {
	        if (type) {
	            if (type == "narrowing") {
	                var zoomDelta1 = -0.07;
	                this.zoom(zoomDelta1, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	            }
	            if (type == "enlarge") {
	                var zoomDelta = 0.07;
	                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	            }
	            if (!isNaN(type)) {
	                var target = this.group;
	                if (target) {
	                    var zoomScale = type;
	                    this._zoom = type;
	                    this.nowZoom = type;
	                    this.setScale(this._zr.getWidth() / 2, this._zr.getHeight() / 2, zoomScale);
	                }
	            }
	        } else {
	            this._zr.on('mousewheel', zrUtil.bind(function (e) {
	                eventTool.stop(e.event);
	                var zoomDelta = e.wheelDelta > 0 ? 0.07 : -0.07;
	                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	            }, this));
	        }
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.zoom = function (zoomDelta, zoomX, zoomY) {
	        if (this.canScale == false) {
	            return;
	        }
	        var target = this.group;
	        if (target) {
	
	            var newZoom = this._zoom = this._zoom || 1;
	            newZoom += zoomDelta;
	
	            newZoom = Number(newZoom.toFixed(2));
	            var zoomScale = newZoom / this._zoom;
	            if (newZoom > 1.7 || newZoom < 0.3) {
	                return;
	            }
	            this._zoom = newZoom;
	
	            this.nowZoom = newZoom;
	            this.setScale(zoomX, zoomY, zoomScale);
	        }
	    };
	
	    /**
	     * @private
	     */
	    fishTopoProto.setScale = function (zoomX, zoomY, zoomScale) {
	        var target = this.group;
	        var pos = target.position;
	        var scale = target.scale;
	        // Keep the mouse center when scaling
	        pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);
	        pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);
	        scale[0] *= zoomScale;
	        scale[1] *= zoomScale;
	        target.attr("position", [pos[0], pos[1]]);
	        target.attr("scale", [scale[0], scale[1]]);
	        if (this.eagleEye == true) {
	            this.minimap.updataSelection(pos[0], pos[1], zoomScale, this.nowZoom);
	        }
	    };
	
	    /**
	     * 鹰眼图
	     * @param  {HTMLElement} eagleEyeNode 显示鹰眼图的div元素
	     */
	    fishTopoProto.openEagleEye = function (eagleEyeNode) {
	        this.eagleEye = true;
	        this.eagleEyeNode = eagleEyeNode;
	        var groupPosition = zrUtil.clone(this.group.position);
	        var groupScale = zrUtil.clone(this.group.scale);
	        this.group.attr("position", [0, 0]);
	        this.group.attr("scale", [1, 1]);
	        var distance = this.initScale();
	        var imgSrc = this.toDataURL();
	        this.group.attr("position", groupPosition);
	        this.group.attr("scale", groupScale);
	        if (this.minimap) {
	            this.minimap.updataMap(imgSrc, this.group.getBoundingRect());
	        } else {
	            this.minimap = new Minimap(this, this.group.position, this.group.getBoundingRect(),
	                eagleEyeNode, distance, imgSrc);
	            setTimeout(zrUtil.bind(function () {
	                this.openEagleEye(this.eagleEyeNode)
	            }, this), 10);
	        }
	        this.minimap.selection.addEventListener("mousedown", function (e) {
	            var startX = e.clientX;
	            var startY = e.clientY;
	            var minimapLeft = Number(this.minimap.selection.style.left.substring(0, this.minimap.selection
	                .style.left.length - 2));
	            var minimapTop = Number(this.minimap.selection.style.top.substring(0, this.minimap.selection
	                .style.top.length - 2));
	            var eagleEyeMove = function (e) {
	                var offsetX = e.clientX - startX;
	                var offsetY = e.clientY - startY;
	                this.minimap.selection.style.left = minimapLeft + offsetX + "px";
	                this.minimap.selection.style.top = minimapTop + offsetY + "px";
	                this.minimap.updataGroupPosition(this.group, this.nowZoom);
	            }.bind(this);
	
	            this.minimap.selection.addEventListener("mousemove", eagleEyeMove);
	
	            var eagleEyeUp = function () {
	                this.minimap.selection.removeEventListener("mousemove", eagleEyeMove);
	                this.minimap.selection.removeEventListener("mouseup", eagleEyeUp);
	            }.bind(this);
	            this.minimap.selection.addEventListener("mouseup", eagleEyeUp);
	        }.bind(this))
	    };
	
	
	
	    zrUtil.mixin(FishTopoFlow, Eventful);
	
	    // ---------对外暴露fishTopoFlow------------------
	    var idBase = new Date() - 0;
	    var instances = {};
	    var DOM_ATTRIBUTE_KEY = '_fishTopoFlow_instance_';
	
	    /**
	     * fishTopoFlow全局对象，如果是amd方式加载，则直接返回
	     * @class fishTopoFlow
	     * @singleton
	     *
	     * **使用范例**：
	     *
	     *      @example
	     *      var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	     */
	    var fishTopoFlow = {
	        /**
	         * 版本号
	         * @type {String}
	         */
	        version: '2.2.1',
	        dependencies: {
	            zrender: '3.6.3'
	        }
	    };
	
	    /**
	     * 初始化dom元素为 flow对象
	     * @member fishTopoFlow
	     * @param {HTMLElement} dom  一个div元素
	     * @param {Object} opts  传递的选项参数
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg' or 'vml'
	     * @param {number} [opts.devicePixelRatio=1] retina 屏幕优化
	     * @param {boolean} [opts.linkModify=false] 是否允许调整线段
	     * @param {boolean} [opts.textEditable=false] 是否允许双击节点编辑文字
	     * @param {boolean} [opts.roam=true] 是否开启鼠标缩放和平移漫游。默认开启。如果只想要开启缩放或者平移，可以设置成 'scale' 或者 'move'。设置成 true 为都开启
	     * @param {Object} [opts.tooltip] tooltip配置项
	     * @param {boolean} [opts.tooltip.show] tooltip配置项:控制tooltip是否显示
	     * @param {boolean} [opts.isAnimationEnabled=true] 是否开启动画,默认为true
	     * @param {Function} [opts.beforeDelete] 删除节点或边线 之前的回调，如果返回false则不进行后续的删除操作
	     * @param {Object} [opts.beforeCreate] 创建节点或边线 之前的回调，如果返回false则不进行后续的删除操作
	     * @return {fish.topo.FishTopoFlow}
	     */
	    fishTopoFlow.init = function (dom, opts) {
	        if (!dom) {
	            throw new Error('Initialize failed: invalid dom.');
	        }
	
	        opts = opts || {};
	        // Default value
	        zrUtil.defaults(opts, {
	            type: "flow",
	            devicePixelRatio: 1,
	            linkModify: false,
	            textEditable: false,
	            roam: true,
	            tooltip: {
	                show:true
	            },  //覆盖tooltipModel
	            isAnimationEnabled: true,
	            beforeDelete: null,  // 删除之前的事件
	            beforeCreate:null   //创建节点或连线之前的事件
	        });
	
	        var fishTopoFlow = new FishTopoFlow(dom, opts);
	        fishTopoFlow.init();
	        fishTopoFlow.Flow = Flow;
	        fishTopoFlow.id = 'ft_' + idBase++;
	        instances[fishTopoFlow.id] = fishTopoFlow;
	
	        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoFlow.id);
	
	        return fishTopoFlow;
	    };
	
	
	    /**
	     * 获取 dom 容器上的实例。
	     * @member fishTopoFlow
	     * @param  {HTMLElement} dom 一个div元素
	     * @return {fish.topo.FishTopoFlow}
	     */
	    fishTopoFlow.getInstanceByDom = function (dom) {
	        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
	        return instances[key];
	    };
	
	    /**
	     * 销毁实例，实例销毁后无法再被使用。
	     *
	     * @member fishTopoFlow
	     * @param  {Object|string} chart fishTopoBpmn实例 或 fishTopoBpmn的id
	     */
	    fishTopoFlow.dispose = function (chart) {
	        var topo;
	        if (zrUtil.isDom(chart)) {
	            topo = fishTopoFlow.getInstanceByDom(chart);
	        } else if (typeof chart === 'string') {
	            topo = instances[chart];
	        }
	        if ((topo instanceof fishTopoFlow) && !topo.isDisposed()) {
	            topo.dispose();
	        }
	    };
	
	    //暴露出去的类
	    fishTopoFlow.graphic = graphic;
	    fishTopoFlow.node = FlowUtil.registerFlowNode(flowNode);
	    fishTopoFlow.link = flowLink;
	
	    fishTopoFlow.layout = layout;
	    fishTopoFlow.Flow = Flow;
	    fishTopoFlow.constants = Constants;
	    fishTopoFlow.util = util;
	    fishTopoFlow.util['initImagePool'] = ImagePool.initImagePool;
	    zrUtil.each([
	            'map', 'each', 'filter', 'indexOf', 'inherits',
	            'reduce', 'filter', 'bind', 'curry', 'isArray',
	            'isString', 'isObject', 'isFunction', 'extend',
	            'merge', "mergeAll"
	        ],
	        function (name) {
	            fishTopoFlow.util[name] = zrUtil[name];
	        }
	    );
	
	    module.exports = fishTopoFlow;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

	
	    //polyfill bind
	    if (!Function.prototype.bind) {
	        Function.prototype.bind = function(oThis) {
	            if (typeof this !== "function") {
	                // closest thing possible to the ECMAScript 5 internal IsCallable function
	                throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
	            }
	
	            var aArgs = Array.prototype.slice.call(arguments, 1),
	                fToBind = this,
	                fNOP = function() {},
	                fBound = function() {
	                    return fToBind.apply(this instanceof fNOP && oThis ? this : oThis || window,
	                        aArgs.concat(Array.prototype.slice.call(arguments)));
	                };
	
	            fNOP.prototype = this.prototype;
	            fBound.prototype = new fNOP();
	
	            return fBound;
	        };
	    }
	
	    //polyfill remove
	    if (!('remove' in Element.prototype)) {
	        Element.prototype.remove = function() {
	            if (this.parentNode) {
	                this.parentNode.removeChild(this);
	            }
	        };
	    }
	
	    if (!String.prototype.endsWith) {
	    String.prototype.endsWith = function(searchString, position) {
	        var subjectString = this.toString();
	        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
	            position = subjectString.length;
	        }
	        position -= searchString.length;
	        var lastIndex = subjectString.indexOf(searchString, position);
	        return lastIndex !== -1 && lastIndex === position;
	    };
	    }
	


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(5);
	
	    var pathTool = __webpack_require__(6);
	    var round = Math.round;
	    var Path = __webpack_require__(7);
	    var colorTool = __webpack_require__(20);
	    var matrix = __webpack_require__(14);
	    var vector = __webpack_require__(15);
	    var Gradient = __webpack_require__(42);
	    var Draggable = __webpack_require__(43);
	
	    var graphic = {};
	    graphic.Util = zrUtil;
	    graphic.Group = __webpack_require__(44);
	
	    graphic.Image = __webpack_require__(45);
	
	    graphic.Text = __webpack_require__(46);
	
	    graphic.textContain = __webpack_require__(26);
	
	    graphic.Circle = __webpack_require__(47);
	
	    graphic.Sector = __webpack_require__(48);
	
	    graphic.Ring = __webpack_require__(51);
	
	    graphic.Polygon = __webpack_require__(52);
	
	    graphic.Polyline = __webpack_require__(56);
	
	    graphic.Rect = __webpack_require__(57);
	
	    graphic.Line = __webpack_require__(58);
	
	    graphic.BezierCurve = __webpack_require__(59);
	
	    graphic.Arc = __webpack_require__(60);
	
	    graphic.LinearGradient = __webpack_require__(61);
	
	    graphic.RadialGradient = __webpack_require__(62);
	
	    graphic.BoundingRect = __webpack_require__(27);
	    graphic.States = __webpack_require__(63);
	    /**
	     * Extend shape with parameters
	     */
	    graphic.extendShape = function (opts) {
	        return Path.extend(opts);
	    };
	
	    /**
	     * Extend path
	     */
	    graphic.extendPath = function (pathData, opts) {
	        return pathTool.extendFromString(pathData, opts);
	    };
	
	    /**
	     * Create a path element from path data string
	     * @param {string} pathData
	     * @param {Object} opts
	     * @param {module:zrender/core/BoundingRect} rect
	     * @param {string} [layout=cover] 'center' or 'cover'
	     */
	    graphic.makePath = function (pathData, opts, rect, layout) {
	        var path = pathTool.createFromString(pathData, opts);
	        Draggable.call(path);
	        var boundingRect = path.getBoundingRect();
	        if (rect) {
	            var aspect = boundingRect.width / boundingRect.height;
	
	            if (layout === 'center') {
	                // Set rect to center, keep width / height ratio.
	                var width = rect.height * aspect;
	                var height;
	                if (width <= rect.width) {
	                    height = rect.height;
	                }
	                else {
	                    width = rect.width;
	                    height = width / aspect;
	                }
	                var cx = rect.x + rect.width / 2;
	                var cy = rect.y + rect.height / 2;
	
	                rect.x = cx - width / 2;
	                rect.y = cy - height / 2;
	                rect.width = width;
	                rect.height = height;
	            }
	
	            this.resizePath(path, rect);
	        }
	
	        zrUtil.inherits(path, Draggable);
	        return path;
	    };
	
	    graphic.mergePath = pathTool.mergePath;
	
	    /**
	     * Resize a path to fit the rect
	     * @param {module:zrender/graphic/Path} path
	     * @param {Object} rect
	     */
	    graphic.resizePath = function (path, rect) {
	        if (!path.applyTransform) {
	            return;
	        }
	
	        var pathRect = path.getBoundingRect();
	
	        var m = pathRect.calculateTransform(rect);
	
	        path.applyTransform(m);
	    };
	
	    /**
	     * Sub pixel optimize line for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x1]
	     * @param {number} [param.shape.y1]
	     * @param {number} [param.shape.x2]
	     * @param {number} [param.shape.y2]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeLine = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	
	        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
	            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
	        }
	        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
	            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
	        }
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize rect for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x]
	     * @param {number} [param.shape.y]
	     * @param {number} [param.shape.width]
	     * @param {number} [param.shape.height]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeRect = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	        var originX = shape.x;
	        var originY = shape.y;
	        var originWidth = shape.width;
	        var originHeight = shape.height;
	        shape.x = subPixelOptimize(shape.x, lineWidth, true);
	        shape.y = subPixelOptimize(shape.y, lineWidth, true);
	        shape.width = Math.max(
	            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,
	            originWidth === 0 ? 0 : 1
	        );
	        shape.height = Math.max(
	            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,
	            originHeight === 0 ? 0 : 1
	        );
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize for canvas
	     *
	     * @param {number} position Coordinate, such as x, y
	     * @param {number} lineWidth Should be nonnegative integer.
	     * @param {boolean=} positiveOrNegative Default false (negative).
	     * @return {number} Optimized position.
	     */
	    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {
	        // Assure that (position + lineWidth / 2) is near integer edge,
	        // otherwise line will be fuzzy in canvas.
	        var doubledPosition = round(position * 2);
	        return (doubledPosition + round(lineWidth)) % 2 === 0
	            ? doubledPosition / 2
	            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
	    };
	
	    /**
	     * @private
	     */
	    function doSingleEnterHover(el) {
	        if (el.__isHover) {
	            return;
	        }
	        if (el.__hoverStlDirty) {
	            var stroke = el.style.stroke;
	            var fill = el.style.fill;
	
	            // Create hoverStyle on mouseover
	            var hoverStyle = el.__hoverStl;
	            var lift = colorTool.lift;
	            hoverStyle.fill = hoverStyle.fill
	                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));
	            hoverStyle.stroke = hoverStyle.stroke
	                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));
	
	            var normalStyle = {};
	            for (var name in hoverStyle) {
	                if (hoverStyle.hasOwnProperty(name)) {
	                    normalStyle[name] = el.style[name];
	                }
	            }
	
	            el.__normalStl = normalStyle;
	
	            el.__hoverStlDirty = false;
	        }
	        el.setStyle(el.__hoverStl);
	        el.z2 += 1;
	
	        el.__isHover = true;
	    }
	
	    /**
	     * @inner
	     */
	    function doSingleLeaveHover(el) {
	        if (!el.__isHover) {
	            return;
	        }
	
	        var normalStl = el.__normalStl;
	        normalStl && el.setStyle(normalStl);
	        el.z2 -= 1;
	
	        el.__isHover = false;
	    }
	
	    /**
	     * @inner
	     */
	    function doEnterHover(el) {
	        (el.type === 'group' || el.type === 'GroupNode')
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleEnterHover(child);
	                }
	            })
	            : doSingleEnterHover(el);
	    }
	    graphic.doEnterHover = doEnterHover;
	    function doLeaveHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleLeaveHover(child);
	                }
	            })
	            : doSingleLeaveHover(el);
	    }
	    graphic.doLeaveHover = doLeaveHover;
	    /**
	     * @inner
	     */
	    function setElementHoverStl(el, hoverStl) {
	        // If element has sepcified hoverStyle, then use it instead of given hoverStyle
	        // Often used when item group has a label element and it's hoverStyle is different
	        el.__hoverStl = el.hoverStyle || hoverStl || {};
	        el.__hoverStlDirty = true;
	    }
	    graphic.setElementHoverStl = setElementHoverStl;
	    /**
	     * @inner
	     */
	    function onElementMouseOver() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function onElementMouseOut() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doLeaveHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function enterEmphasis() {
	        this.__isEmphasis = true;
	        doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function leaveEmphasis() {
	        this.__isEmphasis = false;
	        doLeaveHover(this);
	    }
	
	    /**
	     * Set hover style of element
	     * @param {module:zrender/Element} el
	     * @param {Object} [hoverStyle]
	     */
	    graphic.setHoverStyle = function (el, hoverStyle) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    setElementHoverStl(child, hoverStyle);
	                }
	            })
	            : setElementHoverStl(el, hoverStyle);
	        // Remove previous bound handlers
	        el.on('mouseover', onElementMouseOver)
	          .on('mouseout', onElementMouseOut);
	
	        // Emphasis, normal can be triggered manually
	        el.on('emphasis', enterEmphasis)
	          .on('normal', leaveEmphasis);
	    };
	
	    graphic.setNormalStyle = function(el, options) {
	        if (el.__normalStl) {
	            for (var name in options) {
	                if (el.__normalStl.hasOwnProperty(name)) {
	                    el.__normalStl[name] = options[name];
	                }
	            }
	        }
	    };
	
	    /**
	     * Set text option in the style
	     * @param {Object} textStyle
	     * @param {module:echarts/model/Model} labelModel
	     * @param {string} color
	     */
	    graphic.setText = function (textStyle, labelModel, color) {
	        var labelPosition = labelModel.getShallow('position') || 'inside';
	        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;
	        var textStyleModel = labelModel.getModel('textStyle');
	        zrUtil.extend(textStyle, {
	            textDistance: labelModel.getShallow('distance') || 5,
	            textFont: textStyleModel.getFont(),
	            textPosition: labelPosition,
	            textFill: textStyleModel.getTextColor() || labelColor
	        });
	    };
	
	    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {
	        var postfix = isUpdate ? 'Update' : '';
	        var duration = animatableModel
	            && animatableModel.getShallow('animationDuration' + postfix);
	        var animationEasing = animatableModel
	            && animatableModel.getShallow('animationEasing' + postfix);
	
	        animatableModel && animatableModel.getShallow('animation')
	            ? el.animateTo(props, duration, animationEasing, cb)
	            : (el.attr(props), cb && cb());
	    }
	    /**
	     * Update graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);
	
	    /**
	     * Init graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.initProps = zrUtil.curry(animateOrSetProps, false);
	
	    /**
	     * Get transform matrix of target (param target),
	     * in coordinate of its ancestor (param ancestor)
	     *
	     * @param {module:zrender/mixin/Transformable} target
	     * @param {module:zrender/mixin/Transformable} ancestor
	     */
	    graphic.getTransform = function (target, ancestor) {
	        var mat = matrix.identity([]);
	
	        while (target && target !== ancestor) {
	            matrix.mul(mat, target.getLocalTransform(), mat);
	            target = target.parent;
	        }
	
	        return mat;
	    };
	
	    /**
	     * Apply transform to an vertex.
	     * @param {Array.<number>} vertex [x, y]
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {Array.<number>} [x, y]
	     */
	    graphic.applyTransform = function (vertex, transform, invert) {
	        if (invert) {
	            transform = matrix.invert([], transform);
	        }
	        return vector.applyTransform([], vertex, transform);
	    };
	
	    /**
	     * @param {string} direction 'left' 'right' 'top' 'bottom'
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
	     */
	    graphic.transformDirection = function (direction, transform, invert) {
	
	        // Pick a base, ensure that transform result will not be (0, 0).
	        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[0]);
	        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[2]);
	
	        var vertex = [
	            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,
	            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0
	        ];
	
	        vertex = graphic.applyTransform(vertex, transform, invert);
	
	        return Math.abs(vertex[0]) > Math.abs(vertex[1])
	            ? (vertex[0] > 0 ? 'right' : 'left')
	            : (vertex[1] > 0 ? 'bottom' : 'top');
	    };
	
	    module.exports = graphic;
	


/***/ }),
/* 5 */
/***/ (function(module, exports) {

	/**
	 * @module zrender/core/util
	 */
	
	
	    // 用于处理merge时无法遍历Date等对象的问题
	    var BUILTIN_OBJECT = {
	        '[object Function]': 1,
	        '[object RegExp]': 1,
	        '[object Date]': 1,
	        '[object Error]': 1,
	        '[object CanvasGradient]': 1,
	        '[object CanvasPattern]': 1,
	        // For node-canvas
	        '[object Image]': 1,
	        '[object Canvas]': 1
	    };
	
	    var TYPED_ARRAY = {
	        '[object Int8Array]': 1,
	        '[object Uint8Array]': 1,
	        '[object Uint8ClampedArray]': 1,
	        '[object Int16Array]': 1,
	        '[object Uint16Array]': 1,
	        '[object Int32Array]': 1,
	        '[object Uint32Array]': 1,
	        '[object Float32Array]': 1,
	        '[object Float64Array]': 1
	    };
	
	    var objToString = Object.prototype.toString;
	
	    var arrayProto = Array.prototype;
	    var nativeForEach = arrayProto.forEach;
	    var nativeFilter = arrayProto.filter;
	    var nativeSlice = arrayProto.slice;
	    var nativeMap = arrayProto.map;
	    var nativeReduce = arrayProto.reduce;
	
	    /**
	     * Those data types can be cloned:
	     *     Plain object, Array, TypedArray, number, string, null, undefined.
	     * Those data types will be assgined using the orginal data:
	     *     BUILTIN_OBJECT
	     * Instance of user defined class will be cloned to a plain object, without
	     * properties in prototype.
	     * Other data types is not supported (not sure what will happen).
	     *
	     * Caution: do not support clone Date, for performance consideration.
	     * (There might be a large number of date in `series.data`).
	     * So date should not be modified in and out of echarts.
	     *
	     * @param {*} source
	     * @return {*} new
	     */
	    function clone(source) {
	        if (source == null || typeof source != 'object') {
	            return source;
	        }
	
	        var result = source;
	        var typeStr = objToString.call(source);
	
	        if (typeStr === '[object Array]') {
	            result = [];
	            for (var i = 0, len = source.length; i < len; i++) {
	                result[i] = clone(source[i]);
	            }
	        }
	        else if (TYPED_ARRAY[typeStr]) {
	            var Ctor = source.constructor;
	            if (source.constructor.from) {
	                result = Ctor.from(source);
	            }
	            else {
	                result = new Ctor(source.length);
	                for (var i = 0, len = source.length; i < len; i++) {
	                    result[i] = clone(source[i]);
	                }
	            }
	        }
	        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
	            result = {};
	            for (var key in source) {
	                if (source.hasOwnProperty(key)) {
	                    result[key] = clone(source[key]);
	                }
	            }
	        }
	
	        return result;
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} target
	     * @param {*} source
	     * @param {boolean} [overwrite=false]
	     */
	    function merge(target, source, overwrite) {
	        // We should escapse that source is string
	        // and enter for ... in ...
	        if (!isObject(source) || !isObject(target)) {
	            return overwrite ? clone(source) : target;
	        }
	
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                var targetProp = target[key];
	                var sourceProp = source[key];
	
	                if (isObject(sourceProp)
	                    && isObject(targetProp)
	                    && !isArray(sourceProp)
	                    && !isArray(targetProp)
	                    && !isDom(sourceProp)
	                    && !isDom(targetProp)
	                    && !isBuiltInObject(sourceProp)
	                    && !isBuiltInObject(targetProp)
	                    && !isPrimitive(sourceProp)
	                    && !isPrimitive(targetProp)
	                ) {
	                    // 如果需要递归覆盖，就递归调用merge
	                    merge(targetProp, sourceProp, overwrite);
	                }
	                else if (overwrite || !(key in target)) {
	                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
	                    // NOTE，在 target[key] 不存在的时候也是直接覆盖
	                    target[key] = clone(source[key], true);
	                }
	            }
	        }
	
	        return target;
	    }
	
	    /**
	     * @param {Array} targetAndSources The first item is target, and the rests are source.
	     * @param {boolean} [overwrite=false]
	     * @return {*} target
	     */
	    function mergeAll(targetAndSources, overwrite) {
	        var result = targetAndSources[0];
	        for (var i = 1, len = targetAndSources.length; i < len; i++) {
	            result = merge(result, targetAndSources[i], overwrite);
	        }
	        return result;
	    }
	
	    /**
	     * @param {*} target
	     * @param {*} source
	     * @memberOf module:zrender/core/util
	     */
	    function extend(target, source) {
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                target[key] = source[key];
	            }
	        }
	        return target;
	    }
	
	    /**
	     * @param {*} target
	     * @param {*} source
	     * @param {boolean} [overlay=false]
	     * @memberOf module:zrender/core/util
	     */
	    function defaults(target, source, overlay) {
	        for (var key in source) {
	            if (source.hasOwnProperty(key)
	                && (overlay ? source[key] != null : target[key] == null)
	            ) {
	                target[key] = source[key];
	            }
	        }
	        return target;
	    }
	
	    function createCanvas() {
	        return document.createElement('canvas');
	    }
	    // FIXME
	    var _ctx;
	    function getContext() {
	        if (!_ctx) {
	            // Use util.createCanvas instead of createCanvas
	            // because createCanvas may be overwritten in different environment
	            _ctx = util.createCanvas().getContext('2d');
	        }
	        return _ctx;
	    }
	
	    /**
	     * 查询数组中元素的index
	     * @memberOf module:zrender/core/util
	     */
	    function indexOf(array, value) {
	        if (array) {
	            if (array.indexOf) {
	                return array.indexOf(value);
	            }
	            for (var i = 0, len = array.length; i < len; i++) {
	                if (array[i] === value) {
	                    return i;
	                }
	            }
	        }
	        return -1;
	    }
	
	    /**
	     * 构造类继承关系
	     *
	     * @memberOf module:zrender/core/util
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
	    function inherits(clazz, baseClazz) {
	        var clazzPrototype = clazz.prototype;
	        function F() {}
	        F.prototype = baseClazz.prototype;
	        clazz.prototype = new F();
	
	        for (var prop in clazzPrototype) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	        clazz.prototype.constructor = clazz;
	        clazz.superClass = baseClazz;
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Object|Function} target
	     * @param {Object|Function} sorce
	     * @param {boolean} overlay
	     */
	    function mixin(target, source, overlay) {
	        target = 'prototype' in target ? target.prototype : target;
	        source = 'prototype' in source ? source.prototype : source;
	
	        defaults(target, source, overlay);
	    }
	
	    /**
	     * Consider typed array.
	     * @param {Array|TypedArray} data
	     */
	    function isArrayLike(data) {
	        if (! data) {
	            return;
	        }
	        if (typeof data == 'string') {
	            return false;
	        }
	        return typeof data.length == 'number';
	    }
	
	    /**
	     * 数组或对象遍历
	     * @memberOf module:zrender/core/util
	     * @param {Object|Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     */
	    function each(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.forEach && obj.forEach === nativeForEach) {
	            obj.forEach(cb, context);
	        }
	        else if (obj.length === +obj.length) {
	            for (var i = 0, len = obj.length; i < len; i++) {
	                cb.call(context, obj[i], i, obj);
	            }
	        }
	        else {
	            for (var key in obj) {
	                if (obj.hasOwnProperty(key)) {
	                    cb.call(context, obj[key], key, obj);
	                }
	            }
	        }
	    }
	
	    /**
	     * 数组映射
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function map(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.map && obj.map === nativeMap) {
	            return obj.map(cb, context);
	        }
	        else {
	            var result = [];
	            for (var i = 0, len = obj.length; i < len; i++) {
	                result.push(cb.call(context, obj[i], i, obj));
	            }
	            return result;
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {Object} [memo]
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function reduce(obj, cb, memo, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.reduce && obj.reduce === nativeReduce) {
	            return obj.reduce(cb, memo, context);
	        }
	        else {
	            for (var i = 0, len = obj.length; i < len; i++) {
	                memo = cb.call(context, memo, obj[i], i, obj);
	            }
	            return memo;
	        }
	    }
	
	    /**
	     * 数组过滤
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function filter(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.filter && obj.filter === nativeFilter) {
	            return obj.filter(cb, context);
	        }
	        else {
	            var result = [];
	            for (var i = 0, len = obj.length; i < len; i++) {
	                if (cb.call(context, obj[i], i, obj)) {
	                    result.push(obj[i]);
	                }
	            }
	            return result;
	        }
	    }
	
	    /**
	     * 数组项查找
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function find(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        for (var i = 0, len = obj.length; i < len; i++) {
	            if (cb.call(context, obj[i], i, obj)) {
	                return obj[i];
	            }
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Function} func
	     * @param {*} context
	     * @return {Function}
	     */
	    function bind(func, context) {
	        var args = nativeSlice.call(arguments, 2);
	        return function () {
	            return func.apply(context, args.concat(nativeSlice.call(arguments)));
	        };
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Function} func
	     * @return {Function}
	     */
	    function curry(func) {
	        var args = nativeSlice.call(arguments, 1);
	        return function () {
	            return func.apply(this, args.concat(nativeSlice.call(arguments)));
	        };
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isArray(value) {
	        return objToString.call(value) === '[object Array]';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isFunction(value) {
	        return typeof value === 'function';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isString(value) {
	        return objToString.call(value) === '[object String]';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isObject(value) {
	        // Avoid a V8 JIT bug in Chrome 19-20.
	        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	        var type = typeof value;
	        return type === 'function' || (!!value && type == 'object');
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isBuiltInObject(value) {
	        return !!BUILTIN_OBJECT[objToString.call(value)];
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isDom(value) {
	        return typeof value === 'object'
	            && typeof value.nodeType === 'number'
	            && typeof value.ownerDocument === 'object';
	    }
	
	    /**
	     * Whether is exactly NaN. Notice isNaN('a') returns true.
	     * @param {*} value
	     * @return {boolean}
	     */
	    function eqNaN(value) {
	        return value !== value;
	    }
	
	    /**
	     * If value1 is not null, then return value1, otherwise judget rest of values.
	     * Low performance.
	     * @memberOf module:zrender/core/util
	     * @return {*} Final value
	     */
	    function retrieve(values) {
	        for (var i = 0, len = arguments.length; i < len; i++) {
	            if (arguments[i] != null) {
	                return arguments[i];
	            }
	        }
	    }
	
	    function retrieve2(value0, value1) {
	        return value0 != null
	            ? value0
	            : value1;
	    }
	
	    function retrieve3(value0, value1, value2) {
	        return value0 != null
	            ? value0
	            : value1 != null
	            ? value1
	            : value2;
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Array} arr
	     * @param {number} startIndex
	     * @param {number} endIndex
	     * @return {Array}
	     */
	    function slice() {
	        return Function.call.apply(nativeSlice, arguments);
	    }
	
	    /**
	     * Normalize css liked array configuration
	     * e.g.
	     *  3 => [3, 3, 3, 3]
	     *  [4, 2] => [4, 2, 4, 2]
	     *  [4, 3, 2] => [4, 3, 2, 3]
	     * @param {number|Array.<number>} val
	     * @return {Array.<number>}
	     */
	    function normalizeCssArray(val) {
	        if (typeof (val) === 'number') {
	            return [val, val, val, val];
	        }
	        var len = val.length;
	        if (len === 2) {
	            // vertical | horizontal
	            return [val[0], val[1], val[0], val[1]];
	        }
	        else if (len === 3) {
	            // top | horizontal | bottom
	            return [val[0], val[1], val[2], val[1]];
	        }
	        return val;
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {boolean} condition
	     * @param {string} message
	     */
	    function assert(condition, message) {
	        if (!condition) {
	            throw new Error(message);
	        }
	    }
	
	    var primitiveKey = '__ec_primitive__';
	    /**
	     * Set an object as primitive to be ignored traversing children in clone or merge
	     */
	    function setAsPrimitive(obj) {
	        obj[primitiveKey] = true;
	    }
	
	    function isPrimitive(obj) {
	        return obj[primitiveKey];
	    }
	
	    /**
	     * @constructor
	     * @param {Object} obj Only apply `ownProperty`.
	     */
	    function HashMap(obj) {
	        obj && each(obj, function (value, key) {
	            this.set(key, value);
	        }, this);
	    }
	
	    // Add prefix to avoid conflict with Object.prototype.
	    var HASH_MAP_PREFIX = '_ec_';
	    var HASH_MAP_PREFIX_LENGTH = 4;
	
	    HashMap.prototype = {
	        constructor: HashMap,
	        // Do not provide `has` method to avoid defining what is `has`.
	        // (We usually treat `null` and `undefined` as the same, different
	        // from ES6 Map).
	        get: function (key) {
	            return this[HASH_MAP_PREFIX + key];
	        },
	        set: function (key, value) {
	            this[HASH_MAP_PREFIX + key] = value;
	            // Comparing with invocation chaining, `return value` is more commonly
	            // used in this case: `var someVal = map.set('a', genVal());`
	            return value;
	        },
	        // Although util.each can be performed on this hashMap directly, user
	        // should not use the exposed keys, who are prefixed.
	        each: function (cb, context) {
	            context !== void 0 && (cb = bind(cb, context));
	            for (var prefixedKey in this) {
	                this.hasOwnProperty(prefixedKey)
	                    && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));
	            }
	        },
	        // Do not use this method if performance sensitive.
	        removeKey: function (key) {
	            delete this[HASH_MAP_PREFIX + key];
	        }
	    };
	
	    function createHashMap(obj) {
	        return new HashMap(obj);
	    }
	
	    var util = {
	        inherits: inherits,
	        mixin: mixin,
	        clone: clone,
	        merge: merge,
	        mergeAll: mergeAll,
	        extend: extend,
	        defaults: defaults,
	        getContext: getContext,
	        createCanvas: createCanvas,
	        indexOf: indexOf,
	        slice: slice,
	        find: find,
	        isArrayLike: isArrayLike,
	        each: each,
	        map: map,
	        reduce: reduce,
	        filter: filter,
	        bind: bind,
	        curry: curry,
	        isArray: isArray,
	        isString: isString,
	        isObject: isObject,
	        isFunction: isFunction,
	        isBuiltInObject: isBuiltInObject,
	        isDom: isDom,
	        eqNaN: eqNaN,
	        retrieve: retrieve,
	        retrieve2: retrieve2,
	        retrieve3: retrieve3,
	        assert: assert,
	        setAsPrimitive: setAsPrimitive,
	        createHashMap: createHashMap,
	        normalizeCssArray: normalizeCssArray,
	        noop: function () {}
	    };
	    module.exports = util;
	


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var Path = __webpack_require__(7);
	    var PathProxy = __webpack_require__(30);
	    var transformPath = __webpack_require__(41);
	
	    // command chars
	    var cc = [
	        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',
	        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'
	    ];
	
	    var mathSqrt = Math.sqrt;
	    var mathSin = Math.sin;
	    var mathCos = Math.cos;
	    var PI = Math.PI;
	
	    var vMag = function(v) {
	        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	    };
	    var vRatio = function(u, v) {
	        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
	    };
	    var vAngle = function(u, v) {
	        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)
	                * Math.acos(vRatio(u, v));
	    };
	
	    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
	        var psi = psiDeg * (PI / 180.0);
	        var xp = mathCos(psi) * (x1 - x2) / 2.0
	                 + mathSin(psi) * (y1 - y2) / 2.0;
	        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0
	                 + mathCos(psi) * (y1 - y2) / 2.0;
	
	        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
	
	        if (lambda > 1) {
	            rx *= mathSqrt(lambda);
	            ry *= mathSqrt(lambda);
	        }
	
	        var f = (fa === fs ? -1 : 1)
	            * mathSqrt((((rx * rx) * (ry * ry))
	                    - ((rx * rx) * (yp * yp))
	                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)
	                    + (ry * ry) * (xp * xp))
	                ) || 0;
	
	        var cxp = f * rx * yp / ry;
	        var cyp = f * -ry * xp / rx;
	
	        var cx = (x1 + x2) / 2.0
	                 + mathCos(psi) * cxp
	                 - mathSin(psi) * cyp;
	        var cy = (y1 + y2) / 2.0
	                + mathSin(psi) * cxp
	                + mathCos(psi) * cyp;
	
	        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);
	        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];
	        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];
	        var dTheta = vAngle(u, v);
	
	        if (vRatio(u, v) <= -1) {
	            dTheta = PI;
	        }
	        if (vRatio(u, v) >= 1) {
	            dTheta = 0;
	        }
	        if (fs === 0 && dTheta > 0) {
	            dTheta = dTheta - 2 * PI;
	        }
	        if (fs === 1 && dTheta < 0) {
	            dTheta = dTheta + 2 * PI;
	        }
	
	        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
	    }
	
	    function createPathProxyFromString(data) {
	        if (!data) {
	            return [];
	        }
	
	        // command string
	        var cs = data.replace(/-/g, ' -')
	            .replace(/  /g, ' ')
	            .replace(/ /g, ',')
	            .replace(/,,/g, ',');
	
	        var n;
	        // create pipes so that we can split the data
	        for (n = 0; n < cc.length; n++) {
	            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
	        }
	
	        // create array
	        var arr = cs.split('|');
	        // init context point
	        var cpx = 0;
	        var cpy = 0;
	
	        var path = new PathProxy();
	        var CMD = PathProxy.CMD;
	
	        var prevCmd;
	        for (n = 1; n < arr.length; n++) {
	            var str = arr[n];
	            var c = str.charAt(0);
	            var off = 0;
	            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
	            var cmd;
	
	            if (p.length > 0 && p[0] === '') {
	                p.shift();
	            }
	
	            for (var i = 0; i < p.length; i++) {
	                p[i] = parseFloat(p[i]);
	            }
	            while (off < p.length && !isNaN(p[off])) {
	                if (isNaN(p[0])) {
	                    break;
	                }
	                var ctlPtx;
	                var ctlPty;
	
	                var rx;
	                var ry;
	                var psi;
	                var fa;
	                var fs;
	
	                var x1 = cpx;
	                var y1 = cpy;
	
	                // convert l, H, h, V, and v to L
	                switch (c) {
	                    case 'l':
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'L':
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'm':
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.M;
	                        path.addData(cmd, cpx, cpy);
	                        c = 'l';
	                        break;
	                    case 'M':
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.M;
	                        path.addData(cmd, cpx, cpy);
	                        c = 'L';
	                        break;
	                    case 'h':
	                        cpx += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'H':
	                        cpx = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'v':
	                        cpy += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'V':
	                        cpy = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'C':
	                        cmd = CMD.C;
	                        path.addData(
	                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]
	                        );
	                        cpx = p[off - 2];
	                        cpy = p[off - 1];
	                        break;
	                    case 'c':
	                        cmd = CMD.C;
	                        path.addData(
	                            cmd,
	                            p[off++] + cpx, p[off++] + cpy,
	                            p[off++] + cpx, p[off++] + cpy,
	                            p[off++] + cpx, p[off++] + cpy
	                        );
	                        cpx += p[off - 2];
	                        cpy += p[off - 1];
	                        break;
	                    case 'S':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.C) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cmd = CMD.C;
	                        x1 = p[off++];
	                        y1 = p[off++];
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	                        break;
	                    case 's':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.C) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cmd = CMD.C;
	                        x1 = cpx + p[off++];
	                        y1 = cpy + p[off++];
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	                        break;
	                    case 'Q':
	                        x1 = p[off++];
	                        y1 = p[off++];
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, x1, y1, cpx, cpy);
	                        break;
	                    case 'q':
	                        x1 = p[off++] + cpx;
	                        y1 = p[off++] + cpy;
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, x1, y1, cpx, cpy);
	                        break;
	                    case 'T':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.Q) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 't':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.Q) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 'A':
	                        rx = p[off++];
	                        ry = p[off++];
	                        psi = p[off++];
	                        fa = p[off++];
	                        fs = p[off++];
	
	                        x1 = cpx, y1 = cpy;
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.A;
	                        processArc(
	                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path
	                        );
	                        break;
	                    case 'a':
	                        rx = p[off++];
	                        ry = p[off++];
	                        psi = p[off++];
	                        fa = p[off++];
	                        fs = p[off++];
	
	                        x1 = cpx, y1 = cpy;
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.A;
	                        processArc(
	                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path
	                        );
	                        break;
	                }
	            }
	
	            if (c === 'z' || c === 'Z') {
	                cmd = CMD.Z;
	                path.addData(cmd);
	            }
	
	            prevCmd = cmd;
	        }
	
	        path.toStatic();
	
	        return path;
	    }
	
	    // TODO Optimize double memory cost problem
	    function createPathOptions(str, opts) {
	        var pathProxy = createPathProxyFromString(str);
	        opts = opts || {};
	        opts.buildPath = function (path) {
	            if (path.setData) {
	                path.setData(pathProxy.data);
	                // Svg and vml renderer don't have context
	                var ctx = path.getContext();
	                if (ctx) {
	                    path.rebuildPath(ctx);
	                }
	            }
	            else {
	                var ctx = path;
	                pathProxy.rebuildPath(ctx);
	            }
	        };
	
	        opts.applyTransform = function (m) {
	            transformPath(pathProxy, m);
	
	            this.dirty(true);
	        };
	
	        return opts;
	    }
	
	    module.exports = {
	        /**
	         * Create a Path object from path string data
	         * http://www.w3.org/TR/SVG/paths.html#PathData
	         * @param  {Object} opts Other options
	         */
	        createFromString: function (str, opts) {
	            return new Path(createPathOptions(str, opts));
	        },
	
	        /**
	         * Create a Path class from path string data
	         * @param  {string} str
	         * @param  {Object} opts Other options
	         */
	        extendFromString: function (str, opts) {
	            return Path.extend(createPathOptions(str, opts));
	        },
	
	        /**
	         * Merge multiple paths
	         */
	        // TODO Apply transform
	        // TODO stroke dash
	        // TODO Optimize double memory cost problem
	        mergePath: function (pathEls, opts) {
	            var pathList = [];
	            var len = pathEls.length;
	            for (var i = 0; i < len; i++) {
	                var pathEl = pathEls[i];
	                if (!pathEl.path) {
	                    pathEl.createPathProxy();
	                }
	                if (pathEl.__dirtyPath) {
	                    pathEl.buildPath(pathEl.path, pathEl.shape, true);
	                }
	                pathList.push(pathEl.path);
	            }
	
	            var pathBundle = new Path(opts);
	            // Need path proxy.
	            pathBundle.createPathProxy();
	            pathBundle.buildPath = function (path) {
	                path.appendPath(pathList);
	                // Svg and vml renderer don't have context
	                var ctx = path.getContext();
	                if (ctx) {
	                    path.rebuildPath(ctx);
	                }
	            };
	
	            return pathBundle;
	        }
	    };


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Path element
	 * @module zrender/graphic/Path
	 */
	
	
	
	    var Displayable = __webpack_require__(8);
	    var zrUtil = __webpack_require__(5);
	    var PathProxy = __webpack_require__(30);
	    var pathContain = __webpack_require__(33);
	
	    var Pattern = __webpack_require__(40);
	    var getCanvasPattern = Pattern.prototype.getCanvasPattern;
	
	    var abs = Math.abs;
	
	    var pathProxyForDraw = new PathProxy(true);
	    /**
	     * @alias module:zrender/graphic/Path
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    function Path(opts) {
	        Displayable.call(this, opts);
	
	        /**
	         * @type {module:zrender/core/PathProxy}
	         * @readOnly
	         */
	        this.path = null;
	    }
	
	    Path.prototype = {
	
	        constructor: Path,
	
	        type: 'path',
	
	        __dirtyPath: true,
	
	        strokeContainThreshold: 5,
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var path = this.path || pathProxyForDraw;
	            var hasStroke = style.hasStroke();
	            var hasFill = style.hasFill();
	            var fill = style.fill;
	            var stroke = style.stroke;
	            var hasFillGradient = hasFill && !!(fill.colorStops);
	            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);
	            var hasFillPattern = hasFill && !!(fill.image);
	            var hasStrokePattern = hasStroke && !!(stroke.image);
	
	            style.bind(ctx, this, prevEl);
	            this.setTransform(ctx);
	
	            if (this.__dirty) {
	                var rect;
	                // Update gradient because bounding rect may changed
	                if (hasFillGradient) {
	                    rect = rect || this.getBoundingRect();
	                    this._fillGradient = style.getGradient(ctx, fill, rect);
	                }
	                if (hasStrokeGradient) {
	                    rect = rect || this.getBoundingRect();
	                    this._strokeGradient = style.getGradient(ctx, stroke, rect);
	                }
	            }
	            // Use the gradient or pattern
	            if (hasFillGradient) {
	                // PENDING If may have affect the state
	                ctx.fillStyle = this._fillGradient;
	            }
	            else if (hasFillPattern) {
	                ctx.fillStyle = getCanvasPattern.call(fill, ctx);
	            }
	            if (hasStrokeGradient) {
	                ctx.strokeStyle = this._strokeGradient;
	            }
	            else if (hasStrokePattern) {
	                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
	            }
	
	            var lineDash = style.lineDash;
	            var lineDashOffset = style.lineDashOffset;
	
	            var ctxLineDash = !!ctx.setLineDash;
	
	            // Update path sx, sy
	            var scale = this.getGlobalScale();
	            path.setScale(scale[0], scale[1]);
	
	            // Proxy context
	            // Rebuild path in following 2 cases
	            // 1. Path is dirty
	            // 2. Path needs javascript implemented lineDash stroking.
	            //    In this case, lineDash information will not be saved in PathProxy
	            if (this.__dirtyPath
	                || (lineDash && !ctxLineDash && hasStroke)
	            ) {
	                path.beginPath(ctx);
	
	                // Setting line dash before build path
	                if (lineDash && !ctxLineDash) {
	                    path.setLineDash(lineDash);
	                    path.setLineDashOffset(lineDashOffset);
	                }
	
	                this.buildPath(path, this.shape, false);
	
	                // Clear path dirty flag
	                if (this.path) {
	                    this.__dirtyPath = false;
	                }
	            }
	            else {
	                // Replay path building
	                ctx.beginPath();
	                this.path.rebuildPath(ctx);
	            }
	
	            hasFill && path.fill(ctx);
	
	            if (lineDash && ctxLineDash) {
	                ctx.setLineDash(lineDash);
	                ctx.lineDashOffset = lineDashOffset;
	            }
	
	            hasStroke && path.stroke(ctx);
	
	            if (lineDash && ctxLineDash) {
	                // PENDING
	                // Remove lineDash
	                ctx.setLineDash([]);
	            }
	
	            this.restoreTransform(ctx);
	
	            // Draw rect text
	            if (style.text != null) {
	                this.drawRectText(ctx, this.getBoundingRect());
	            }
	        },
	
	        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
	        // Like in circle
	        buildPath: function (ctx, shapeCfg, inBundle) {},
	
	        createPathProxy: function () {
	            this.path = new PathProxy();
	        },
	
	        getBoundingRect: function () {
	            var rect = this._rect;
	            var style = this.style;
	            var needsUpdateRect = !rect;
	            if (needsUpdateRect) {
	                var path = this.path;
	                if (!path) {
	                    // Create path on demand.
	                    path = this.path = new PathProxy();
	                }
	                if (this.__dirtyPath) {
	                    path.beginPath();
	                    this.buildPath(path, this.shape, false);
	                }
	                rect = path.getBoundingRect();
	            }
	            this._rect = rect;
	
	            if (style.hasStroke()) {
	                // Needs update rect with stroke lineWidth when
	                // 1. Element changes scale or lineWidth
	                // 2. Shape is changed
	                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
	                if (this.__dirty || needsUpdateRect) {
	                    rectWithStroke.copy(rect);
	                    // FIXME Must after updateTransform
	                    var w = style.lineWidth;
	                    // PENDING, Min line width is needed when line is horizontal or vertical
	                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
	
	                    // Only add extra hover lineWidth when there are no fill
	                    if (!style.hasFill()) {
	                        w = Math.max(w, this.strokeContainThreshold || 4);
	                    }
	                    // Consider line width
	                    // Line scale can't be 0;
	                    if (lineScale > 1e-10) {
	                        rectWithStroke.width += w / lineScale;
	                        rectWithStroke.height += w / lineScale;
	                        rectWithStroke.x -= w / lineScale / 2;
	                        rectWithStroke.y -= w / lineScale / 2;
	                    }
	                }
	
	                // Return rect with stroke
	                return rectWithStroke;
	            }
	
	            return rect;
	        },
	
	        contain: function (x, y) {
	            var localPos = this.transformCoordToLocal(x, y);
	            var rect = this.getBoundingRect();
	            var style = this.style;
	            x = localPos[0];
	            y = localPos[1];
	
	            if (rect.contain(x, y)) {
	                var pathData = this.path.data;
	                if (style.hasStroke()) {
	                    var lineWidth = style.lineWidth;
	                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
	                    // Line scale can't be 0;
	                    if (lineScale > 1e-10) {
	                        // Only add extra hover lineWidth when there are no fill
	                        if (!style.hasFill()) {
	                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
	                        }
	                        if (pathContain.containStroke(
	                            pathData, lineWidth / lineScale, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                }
	                if (style.hasFill()) {
	                    return pathContain.contain(pathData, x, y);
	                }
	            }
	            return false;
	        },
	
	        /**
	         * @param  {boolean} dirtyPath
	         */
	        dirty: function (dirtyPath) {
	            if (dirtyPath == null) {
	                dirtyPath = true;
	            }
	            // Only mark dirty, not mark clean
	            if (dirtyPath) {
	                this.__dirtyPath = dirtyPath;
	                this._rect = null;
	            }
	
	            this.__dirty = true;
	
	            this.__zr && this.__zr.refresh();
	
	            // Used as a clipping path
	            if (this.__clipTarget) {
	                this.__clipTarget.dirty();
	            }
	        },
	
	        /**
	         * Alias for animate('shape')
	         * @param {boolean} loop
	         */
	        animateShape: function (loop) {
	            return this.animate('shape', loop);
	        },
	
	        // Overwrite attrKV
	        attrKV: function (key, value) {
	            // FIXME
	            if (key === 'shape') {
	                this.setShape(value);
	                this.__dirtyPath = true;
	                this._rect = null;
	            }
	            else {
	                Displayable.prototype.attrKV.call(this, key, value);
	            }
	        },
	
	        /**
	         * @param {Object|string} key
	         * @param {*} value
	         */
	        setShape: function (key, value) {
	            var shape = this.shape;
	            // Path from string may not have shape
	            if (shape) {
	                if (zrUtil.isObject(key)) {
	                    for (var name in key) {
	                        if (key.hasOwnProperty(name)) {
	                            shape[name] = key[name];
	                        }
	                    }
	                }
	                else {
	                    shape[key] = value;
	                }
	                this.dirty(true);
	            }
	            return this;
	        },
	
	        getLineScale: function () {
	            var m = this.transform;
	            // Get the line scale.
	            // Determinant of `m` means how much the area is enlarged by the
	            // transformation. So its square root can be used as a scale factor
	            // for width.
	            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10
	                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))
	                : 1;
	        }
	    };
	
	    /**
	     * 扩展一个 Path element, 比如星形，圆等。
	     * Extend a path element
	     * @param {Object} props
	     * @param {string} props.type Path type
	     * @param {Function} props.init Initialize
	     * @param {Function} props.buildPath Overwrite buildPath method
	     * @param {Object} [props.style] Extended default style config
	     * @param {Object} [props.shape] Extended default shape config
	     */
	    Path.extend = function (defaults) {
	        var Sub = function (opts) {
	            Path.call(this, opts);
	
	            if (defaults.style) {
	                // Extend default style
	                this.style.extendFrom(defaults.style, false);
	            }
	
	            // Extend default shape
	            var defaultShape = defaults.shape;
	            if (defaultShape) {
	                this.shape = this.shape || {};
	                var thisShape = this.shape;
	                for (var name in defaultShape) {
	                    if (
	                        ! thisShape.hasOwnProperty(name)
	                        && defaultShape.hasOwnProperty(name)
	                    ) {
	                        thisShape[name] = defaultShape[name];
	                    }
	                }
	            }
	
	            defaults.init && defaults.init.call(this, opts);
	        };
	
	        zrUtil.inherits(Sub, Path);
	
	        // FIXME 不能 extend position, rotation 等引用对象
	        for (var name in defaults) {
	            // Extending prototype values and methods
	            if (name !== 'style' && name !== 'shape') {
	                Sub.prototype[name] = defaults[name];
	            }
	        }
	
	        return Sub;
	    };
	
	    zrUtil.inherits(Path, Displayable);
	
	    module.exports = Path;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 可绘制的图形基类
	 * Base class of all displayable graphic objects
	 * @module zrender/graphic/Displayable
	 */
	
	
	
	    var zrUtil = __webpack_require__(5);
	
	    var Style = __webpack_require__(9);
	
	    var Element = __webpack_require__(10);
	    var RectText = __webpack_require__(24);
	    // var Stateful = require('./mixin/Stateful');
	
	    /**
	     * @alias module:zrender/graphic/Displayable
	     * @extends module:zrender/Element
	     * @extends module:zrender/graphic/mixin/RectText
	     */
	    function Displayable(opts) {
	
	        opts = opts || {};
	
	        Element.call(this, opts);
	
	        // Extend properties
	        for (var name in opts) {
	            if (
	                opts.hasOwnProperty(name) &&
	                name !== 'style'
	            ) {
	                this[name] = opts[name];
	            }
	        }
	
	        /**
	         * @type {module:zrender/graphic/Style}
	         */
	        this.style = new Style(opts.style, this);
	
	        this._rect = null;
	        // Shapes for cascade clipping.
	        this.__clipPaths = [];
	
	        // FIXME Stateful must be mixined after style is setted
	        // Stateful.call(this, opts);
	    }
	
	    Displayable.prototype = {
	
	        constructor: Displayable,
	
	        type: 'displayable',
	
	        /**
	         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
	         * Dirty flag. From which painter will determine if this displayable object needs brush
	         * @name module:zrender/graphic/Displayable#__dirty
	         * @type {boolean}
	         */
	        __dirty: true,
	
	        /**
	         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
	         * If ignore drawing of the displayable object. Mouse event will still be triggered
	         * @name module:/zrender/graphic/Displayable#invisible
	         * @type {boolean}
	         * @default false
	         */
	        invisible: false,
	
	        /**
	         * @name module:/zrender/graphic/Displayable#z
	         * @type {number}
	         * @default 0
	         */
	        z: 0,
	
	        /**
	         * @name module:/zrender/graphic/Displayable#z
	         * @type {number}
	         * @default 0
	         */
	        z2: 0,
	
	        /**
	         * z层level，决定绘画在哪层canvas中
	         * @name module:/zrender/graphic/Displayable#zlevel
	         * @type {number}
	         * @default 0
	         */
	        zlevel: 0,
	
	        /**
	         * 是否可拖拽
	         * @name module:/zrender/graphic/Displayable#draggable
	         * @type {boolean}
	         * @default false
	         */
	        draggable: false,
	
	        /**
	         * 是否正在拖拽
	         * @name module:/zrender/graphic/Displayable#draggable
	         * @type {boolean}
	         * @default false
	         */
	        dragging: false,
	
	        /**
	         * 是否相应鼠标事件
	         * @name module:/zrender/graphic/Displayable#silent
	         * @type {boolean}
	         * @default false
	         */
	        silent: false,
	
	        /**
	         * If enable culling
	         * @type {boolean}
	         * @default false
	         */
	        culling: false,
	
	        /**
	         * Mouse cursor when hovered
	         * @name module:/zrender/graphic/Displayable#cursor
	         * @type {string}
	         */
	        cursor: 'pointer',
	
	        /**
	         * If hover area is bounding rect
	         * @name module:/zrender/graphic/Displayable#rectHover
	         * @type {string}
	         */
	        rectHover: false,
	
	        /**
	         * Render the element progressively when the value >= 0,
	         * usefull for large data.
	         * @type {number}
	         */
	        progressive: -1,
	
	        beforeBrush: function (ctx) {},
	
	        afterBrush: function (ctx) {},
	
	        /**
	         * 图形绘制方法
	         * @param {CanvasRenderingContext2D} ctx
	         */
	        // Interface
	        brush: function (ctx, prevEl) {},
	
	        /**
	         * 获取最小包围盒
	         * @return {module:zrender/core/BoundingRect}
	         */
	        // Interface
	        getBoundingRect: function () {},
	
	        /**
	         * 判断坐标 x, y 是否在图形上
	         * If displayable element contain coord x, y
	         * @param  {number} x
	         * @param  {number} y
	         * @return {boolean}
	         */
	        contain: function (x, y) {
	            return this.rectContain(x, y);
	        },
	
	        /**
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {
	            cb.call(context, this);
	        },
	
	        /**
	         * 判断坐标 x, y 是否在图形的包围盒上
	         * If bounding rect of element contain coord x, y
	         * @param  {number} x
	         * @param  {number} y
	         * @return {boolean}
	         */
	        rectContain: function (x, y) {
	            var coord = this.transformCoordToLocal(x, y);
	            var rect = this.getBoundingRect();
	            return rect.contain(coord[0], coord[1]);
	        },
	
	        /**
	         * 标记图形元素为脏，并且在下一帧重绘
	         * Mark displayable element dirty and refresh next frame
	         */
	        dirty: function () {
	            this.__dirty = true;
	
	            this._rect = null;
	
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * 图形是否会触发事件
	         * If displayable object binded any event
	         * @return {boolean}
	         */
	        // TODO, 通过 bind 绑定的事件
	        // isSilent: function () {
	        //     return !(
	        //         this.hoverable || this.draggable
	        //         || this.onmousemove || this.onmouseover || this.onmouseout
	        //         || this.onmousedown || this.onmouseup || this.onclick
	        //         || this.ondragenter || this.ondragover || this.ondragleave
	        //         || this.ondrop
	        //     );
	        // },
	        /**
	         * Alias for animate('style')
	         * @param {boolean} loop
	         */
	        animateStyle: function (loop) {
	            return this.animate('style', loop);
	        },
	
	        attrKV: function (key, value) {
	            if (key !== 'style') {
	                Element.prototype.attrKV.call(this, key, value);
	            }
	            else {
	                this.style.set(value);
	            }
	        },
	
	        /**
	         * @param {Object|string} key
	         * @param {*} value
	         */
	        setStyle: function (key, value) {
	            this.style.set(key, value);
	            this.dirty(false);
	            return this;
	        },
	
	        /**
	         * Use given style object
	         * @param  {Object} obj
	         */
	        useStyle: function (obj) {
	            this.style = new Style(obj, this);
	            this.dirty(false);
	            return this;
	        }
	    };
	
	    zrUtil.inherits(Displayable, Element);
	
	    zrUtil.mixin(Displayable, RectText);
	    // zrUtil.mixin(Displayable, Stateful);
	
	    module.exports = Displayable;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

	/**
	 * @module zrender/graphic/Style
	 */
	
	
	    var STYLE_COMMON_PROPS = [
	        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],
	        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]
	    ];
	
	    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
	    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);
	
	    var Style = function (opts, host) {
	        this.extendFrom(opts, false);
	        this.host = host;
	    };
	
	    function createLinearGradient(ctx, obj, rect) {
	        var x = obj.x == null ? 0 : obj.x;
	        var x2 = obj.x2 == null ? 1 : obj.x2;
	        var y = obj.y == null ? 0 : obj.y;
	        var y2 = obj.y2 == null ? 0 : obj.y2;
	
	        if (!obj.global) {
	            x = x * rect.width + rect.x;
	            x2 = x2 * rect.width + rect.x;
	            y = y * rect.height + rect.y;
	            y2 = y2 * rect.height + rect.y;
	        }
	
	        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
	
	        return canvasGradient;
	    }
	
	    function createRadialGradient(ctx, obj, rect) {
	        var width = rect.width;
	        var height = rect.height;
	        var min = Math.min(width, height);
	
	        var x = obj.x == null ? 0.5 : obj.x;
	        var y = obj.y == null ? 0.5 : obj.y;
	        var r = obj.r == null ? 0.5 : obj.r;
	        if (!obj.global) {
	            x = x * width + rect.x;
	            y = y * height + rect.y;
	            r = r * min;
	        }
	
	        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
	
	        return canvasGradient;
	    }
	
	
	    Style.prototype = {
	
	        constructor: Style,
	
	        /**
	         * @type {module:zrender/graphic/Displayable}
	         */
	        host: null,
	
	        /**
	         * @type {string}
	         */
	        fill: '#000',
	
	        /**
	         * @type {string}
	         */
	        stroke: null,
	
	        /**
	         * @type {number}
	         */
	        opacity: 1,
	
	        /**
	         * @type {Array.<number>}
	         */
	        lineDash: null,
	
	        /**
	         * @type {number}
	         */
	        lineDashOffset: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowBlur: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowOffsetX: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowOffsetY: 0,
	
	        /**
	         * @type {number}
	         */
	        lineWidth: 1,
	
	        /**
	         * If stroke ignore scale
	         * @type {Boolean}
	         */
	        strokeNoScale: false,
	
	        // Bounding rect text configuration
	        // Not affected by element transform
	        /**
	         * @type {string}
	         */
	        text: null,
	
	        /**
	         * If `fontSize` or `fontFamily` exists, `font` will be reset by
	         * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
	         * So do not visit it directly in upper application (like echarts),
	         * but use `contain/text#makeFont` instead.
	         * @type {string}
	         */
	        font: null,
	
	        /**
	         * The same as font. Use font please.
	         * @deprecated
	         * @type {string}
	         */
	        textFont: null,
	
	        /**
	         * It helps merging respectively, rather than parsing an entire font string.
	         * @type {string}
	         */
	        fontStyle: null,
	
	        /**
	         * It helps merging respectively, rather than parsing an entire font string.
	         * @type {string}
	         */
	        fontWeight: null,
	
	        /**
	         * It helps merging respectively, rather than parsing an entire font string.
	         * Should be 12 but not '12px'.
	         * @type {number}
	         */
	        fontSize: null,
	
	        /**
	         * It helps merging respectively, rather than parsing an entire font string.
	         * @type {string}
	         */
	        fontFamily: null,
	
	        /**
	         * Reserved for special functinality, like 'hr'.
	         * @type {string}
	         */
	        textTag: null,
	
	        /**
	         * @type {string}
	         */
	        textFill: '#000',
	
	        /**
	         * @type {string}
	         */
	        textStroke: null,
	
	        /**
	         * @type {number}
	         */
	        textWidth: null,
	
	        /**
	         * Only for textBackground.
	         * @type {number}
	         */
	        textHeight: null,
	
	        /**
	         * textStroke may be set as some color as a default
	         * value in upper applicaion, where the default value
	         * of textStrokeWidth should be 0 to make sure that
	         * user can choose to do not use text stroke.
	         * @type {number}
	         */
	        textStrokeWidth: 0,
	
	        /**
	         * @type {number}
	         */
	        textLineHeight: null,
	
	        /**
	         * 'inside', 'left', 'right', 'top', 'bottom'
	         * [x, y]
	         * Based on x, y of rect.
	         * @type {string|Array.<number>}
	         * @default 'inside'
	         */
	        textPosition: 'inside',
	
	        /**
	         * If not specified, use the boundingRect of a `displayable`.
	         * @type {Object}
	         */
	        textRect: null,
	
	        /**
	         * [x, y]
	         * @type {Array.<number>}
	         */
	        textOffset: null,
	
	        /**
	         * @type {string}
	         */
	        textAlign: null,
	
	        /**
	         * @type {string}
	         */
	        textVerticalAlign: null,
	
	        /**
	         * @type {number}
	         */
	        textDistance: 5,
	
	        /**
	         * @type {string}
	         */
	        textShadowColor: 'transparent',
	
	        /**
	         * @type {number}
	         */
	        textShadowBlur: 0,
	
	        /**
	         * @type {number}
	         */
	        textShadowOffsetX: 0,
	
	        /**
	         * @type {number}
	         */
	        textShadowOffsetY: 0,
	
	        /**
	         * @type {string}
	         */
	        textBoxShadowColor: 'transparent',
	
	        /**
	         * @type {number}
	         */
	        textBoxShadowBlur: 0,
	
	        /**
	         * @type {number}
	         */
	        textBoxShadowOffsetX: 0,
	
	        /**
	         * @type {number}
	         */
	        textBoxShadowOffsetY: 0,
	
	        /**
	         * Whether transform text.
	         * Only useful in Path and Image element
	         * @type {boolean}
	         */
	        transformText: false,
	
	        /**
	         * Text rotate around position of Path or Image
	         * Only useful in Path and Image element and transformText is false.
	         */
	        textRotation: 0,
	
	        /**
	         * Text origin of text rotation, like [10, 40].
	         * Based on x, y of rect.
	         * Useful in label rotation of circular symbol.
	         * By default, this origin is textPosition.
	         * Can be 'center'.
	         * @type {string|Array.<number>}
	         */
	        textOrigin: null,
	
	        /**
	         * @type {string}
	         */
	        textBackgroundColor: null,
	
	        /**
	         * @type {string}
	         */
	        textBorderColor: null,
	
	        /**
	         * @type {number}
	         */
	        textBorderWidth: 0,
	
	        /**
	         * @type {number}
	         */
	        textBorderRadius: 0,
	
	        /**
	         * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
	         * @type {number|Array.<number>}
	         */
	        textPadding: null,
	
	        /**
	         * Text styles for rich text.
	         * @type {Object}
	         */
	        rich: null,
	
	        /**
	         * {outerWidth, outerHeight, ellipsis, placeholder}
	         * @type {Object}
	         */
	        truncate: null,
	
	        /**
	         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
	         * @type {string}
	         */
	        blend: null,
	
	        /**
	         * @param {CanvasRenderingContext2D} ctx
	         */
	        bind: function (ctx, el, prevEl) {
	            var style = this;
	            var prevStyle = prevEl && prevEl.style;
	            var firstDraw = !prevStyle;
	
	            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	                var prop = STYLE_COMMON_PROPS[i];
	                var styleName = prop[0];
	
	                if (firstDraw || style[styleName] !== prevStyle[styleName]) {
	                    // FIXME Invalid property value will cause style leak from previous element.
	                    ctx[styleName] = style[styleName] || prop[1];
	                }
	            }
	
	            if ((firstDraw || style.fill !== prevStyle.fill)) {
	                ctx.fillStyle = style.fill;
	            }
	            if ((firstDraw || style.stroke !== prevStyle.stroke)) {
	                ctx.strokeStyle = style.stroke;
	            }
	            if ((firstDraw || style.opacity !== prevStyle.opacity)) {
	                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
	            }
	
	            if ((firstDraw || style.blend !== prevStyle.blend)) {
	                ctx.globalCompositeOperation = style.blend || 'source-over';
	            }
	            if (this.hasStroke()) {
	                var lineWidth = style.lineWidth;
	                ctx.lineWidth = lineWidth / (
	                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1
	                );
	            }
	        },
	
	        hasFill: function () {
	            var fill = this.fill;
	            return fill != null && fill !== 'none';
	        },
	
	        hasStroke: function () {
	            var stroke = this.stroke;
	            return stroke != null && stroke !== 'none' && this.lineWidth > 0;
	        },
	
	        /**
	         * Extend from other style
	         * @param {zrender/graphic/Style} otherStyle
	         * @param {boolean} overwrite true: overwrirte any way.
	         *                            false: overwrite only when !target.hasOwnProperty
	         *                            others: overwrite when property is not null/undefined.
	         */
	        extendFrom: function (otherStyle, overwrite) {
	            if (otherStyle) {
	                for (var name in otherStyle) {
	                    if (otherStyle.hasOwnProperty(name)
	                        && (overwrite === true
	                            || (
	                                overwrite === false
	                                    ? !this.hasOwnProperty(name)
	                                    : otherStyle[name] != null
	                            )
	                        )
	                    ) {
	                        this[name] = otherStyle[name];
	                    }
	                }
	            }
	        },
	
	        /**
	         * Batch setting style with a given object
	         * @param {Object|string} obj
	         * @param {*} [obj]
	         */
	        set: function (obj, value) {
	            if (typeof obj === 'string') {
	                this[obj] = value;
	            }
	            else {
	                this.extendFrom(obj, true);
	            }
	        },
	
	        /**
	         * Clone
	         * @return {zrender/graphic/Style} [description]
	         */
	        clone: function () {
	            var newStyle = new this.constructor();
	            newStyle.extendFrom(this, true);
	            return newStyle;
	        },
	
	        getGradient: function (ctx, obj, rect) {
	            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
	            var canvasGradient = method(ctx, obj, rect);
	            var colorStops = obj.colorStops;
	            for (var i = 0; i < colorStops.length; i++) {
	                canvasGradient.addColorStop(
	                    colorStops[i].offset, colorStops[i].color
	                );
	            }
	            return canvasGradient;
	        }
	
	    };
	
	    var styleProto = Style.prototype;
	    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	        var prop = STYLE_COMMON_PROPS[i];
	        if (!(prop[0] in styleProto)) {
	            styleProto[prop[0]] = prop[1];
	        }
	    }
	
	    // Provide for others
	    Style.getGradient = styleProto.getGradient;
	
	    module.exports = Style;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module zrender/Element
	 */
	
	
	    var guid = __webpack_require__(11);
	    var Eventful = __webpack_require__(12);
	    var Transformable = __webpack_require__(13);
	    var Animatable = __webpack_require__(16);
	    var zrUtil = __webpack_require__(5);
	
	    /**
	     * @alias module:zrender/Element
	     * @constructor
	     * @extends {module:zrender/mixin/Animatable}
	     * @extends {module:zrender/mixin/Transformable}
	     * @extends {module:zrender/mixin/Eventful}
	     */
	    var Element = function (opts) {
	
	        Transformable.call(this, opts);
	        Eventful.call(this, opts);
	        Animatable.call(this, opts);
	
	        /**
	         * 画布元素ID
	         * @type {string}
	         */
	        this.id = opts.id || guid();
	    };
	
	    Element.prototype = {
	
	        /**
	         * 元素类型
	         * Element type
	         * @type {string}
	         */
	        type: 'element',
	
	        /**
	         * 元素名字
	         * Element name
	         * @type {string}
	         */
	        name: '',
	
	        /**
	         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
	         * ZRender instance will be assigned when element is associated with zrender
	         * @name module:/zrender/Element#__zr
	         * @type {module:zrender/ZRender}
	         */
	        __zr: null,
	
	        /**
	         * 图形是否忽略，为true时忽略图形的绘制以及事件触发
	         * If ignore drawing and events of the element object
	         * @name module:/zrender/Element#ignore
	         * @type {boolean}
	         * @default false
	         */
	        ignore: false,
	
	        /**
	         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
	         * 该路径会继承被裁减对象的变换
	         * @type {module:zrender/graphic/Path}
	         * @see http://www.w3.org/TR/2dcontext/#clipping-region
	         * @readOnly
	         */
	        clipPath: null,
	
	        /**
	         * Drift element
	         * @param  {number} dx dx on the global space
	         * @param  {number} dy dy on the global space
	         */
	        drift: function (dx, dy) {
	            switch (this.draggable) {
	                case 'horizontal':
	                    dy = 0;
	                    break;
	                case 'vertical':
	                    dx = 0;
	                    break;
	            }
	
	            var m = this.transform;
	            if (!m) {
	                m = this.transform = [1, 0, 0, 1, 0, 0];
	            }
	            m[4] += dx;
	            m[5] += dy;
	
	            this.decomposeTransform();
	            this.dirty(false);
	        },
	
	        /**
	         * Hook before update
	         */
	        beforeUpdate: function () {},
	        /**
	         * Hook after update
	         */
	        afterUpdate: function () {},
	        /**
	         * Update each frame
	         */
	        update: function () {
	            this.updateTransform();
	        },
	
	        /**
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {},
	
	        /**
	         * @protected
	         */
	        attrKV: function (key, value) {
	            if (key === 'position' || key === 'scale' || key === 'origin') {
	                // Copy the array
	                if (value) {
	                    var target = this[key];
	                    if (!target) {
	                        target = this[key] = [];
	                    }
	                    target[0] = value[0];
	                    target[1] = value[1];
	                }
	            }
	            else {
	                this[key] = value;
	            }
	        },
	
	        /**
	         * Hide the element
	         */
	        hide: function () {
	            this.ignore = true;
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * Show the element
	         */
	        show: function () {
	            this.ignore = false;
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * @param {string|Object} key
	         * @param {*} value
	         */
	        attr: function (key, value) {
	            if (typeof key === 'string') {
	                this.attrKV(key, value);
	            }
	            else if (zrUtil.isObject(key)) {
	                for (var name in key) {
	                    if (key.hasOwnProperty(name)) {
	                        this.attrKV(name, key[name]);
	                    }
	                }
	            }
	
	            this.dirty(false);
	
	            return this;
	        },
	
	        /**
	         * @param {module:zrender/graphic/Path} clipPath
	         */
	        setClipPath: function (clipPath) {
	            var zr = this.__zr;
	            if (zr) {
	                clipPath.addSelfToZr(zr);
	            }
	
	            // Remove previous clip path
	            if (this.clipPath && this.clipPath !== clipPath) {
	                this.removeClipPath();
	            }
	
	            this.clipPath = clipPath;
	            clipPath.__zr = zr;
	            clipPath.__clipTarget = this;
	
	            this.dirty(false);
	        },
	
	        /**
	         */
	        removeClipPath: function () {
	            var clipPath = this.clipPath;
	            if (clipPath) {
	                if (clipPath.__zr) {
	                    clipPath.removeSelfFromZr(clipPath.__zr);
	                }
	
	                clipPath.__zr = null;
	                clipPath.__clipTarget = null;
	                this.clipPath = null;
	
	                this.dirty(false);
	            }
	        },
	
	        /**
	         * Add self from zrender instance.
	         * Not recursively because it will be invoked when element added to storage.
	         * @param {module:zrender/ZRender} zr
	         */
	        addSelfToZr: function (zr) {
	            this.__zr = zr;
	            // 添加动画
	            var animators = this.animators;
	            if (animators) {
	                for (var i = 0; i < animators.length; i++) {
	                    zr.animation.addAnimator(animators[i]);
	                }
	            }
	
	            if (this.clipPath) {
	                this.clipPath.addSelfToZr(zr);
	            }
	        },
	
	        /**
	         * Remove self from zrender instance.
	         * Not recursively because it will be invoked when element added to storage.
	         * @param {module:zrender/ZRender} zr
	         */
	        removeSelfFromZr: function (zr) {
	            this.__zr = null;
	            // 移除动画
	            var animators = this.animators;
	            if (animators) {
	                for (var i = 0; i < animators.length; i++) {
	                    zr.animation.removeAnimator(animators[i]);
	                }
	            }
	
	            if (this.clipPath) {
	                this.clipPath.removeSelfFromZr(zr);
	            }
	        }
	    };
	
	    zrUtil.mixin(Element, Animatable);
	    zrUtil.mixin(Element, Transformable);
	    zrUtil.mixin(Element, Eventful);
	
	    module.exports = Element;


/***/ }),
/* 11 */
/***/ (function(module, exports) {

	/**
	 * zrender: 生成唯一id
	 *
	 * @author errorrik (errorrik@gmail.com)
	 */
	
	
	    var idStart = 0x0907;
	
	    module.exports = function () {
	        return idStart++;
	    };
	


/***/ }),
/* 12 */
/***/ (function(module, exports) {

	/**
	 * 事件扩展
	 * @module zrender/mixin/Eventful
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	
	
	    var arrySlice = Array.prototype.slice;
	
	    /**
	     * 事件分发器
	     * @alias module:zrender/mixin/Eventful
	     * @constructor
	     */
	    var Eventful = function () {
	        this._$handlers = {};
	    };
	
	    Eventful.prototype = {
	
	        constructor: Eventful,
	
	        /**
	         * 单次触发绑定，trigger后销毁
	         *
	         * @param {string} event 事件名
	         * @param {Function} handler 响应函数
	         * @param {Object} context
	         */
	        one: function (event, handler, context) {
	            var _h = this._$handlers;
	
	            if (!handler || !event) {
	                return this;
	            }
	
	            if (!_h[event]) {
	                _h[event] = [];
	            }
	
	            for (var i = 0; i < _h[event].length; i++) {
	                if (_h[event][i].h === handler) {
	                    return this;
	                }
	            }
	
	            _h[event].push({
	                h: handler,
	                one: true,
	                ctx: context || this
	            });
	
	            return this;
	        },
	
	        /**
	         * 绑定事件
	         * @param {string} event 事件名
	         * @param {Function} handler 事件处理函数
	         * @param {Object} [context]
	         */
	        on: function (event, handler, context) {
	            var _h = this._$handlers;
	
	            if (!handler || !event) {
	                return this;
	            }
	
	            if (!_h[event]) {
	                _h[event] = [];
	            }
	
	            for (var i = 0; i < _h[event].length; i++) {
	                if (_h[event][i].h === handler) {
	                    return this;
	                }
	            }
	
	            _h[event].push({
	                h: handler,
	                one: false,
	                ctx: context || this
	            });
	
	            return this;
	        },
	
	        /**
	         * 是否绑定了事件
	         * @param  {string}  event
	         * @return {boolean}
	         */
	        isSilent: function (event) {
	            var _h = this._$handlers;
	            return _h[event] && _h[event].length;
	        },
	
	        /**
	         * 解绑事件
	         * @param {string} event 事件名
	         * @param {Function} [handler] 事件处理函数
	         */
	        off: function (event, handler) {
	            var _h = this._$handlers;
	
	            if (!event) {
	                this._$handlers = {};
	                return this;
	            }
	
	            if (handler) {
	                if (_h[event]) {
	                    var newList = [];
	                    for (var i = 0, l = _h[event].length; i < l; i++) {
	                        if (_h[event][i]['h'] != handler) {
	                            newList.push(_h[event][i]);
	                        }
	                    }
	                    _h[event] = newList;
	                }
	
	                if (_h[event] && _h[event].length === 0) {
	                    delete _h[event];
	                }
	            }
	            else {
	                delete _h[event];
	            }
	
	            return this;
	        },
	
	        /**
	         * 事件分发
	         *
	         * @param {string} type 事件类型
	         */
	        trigger: function (type) {
	            if (this._$handlers[type]) {
	                var args = arguments;
	                var argLen = args.length;
	
	                if (argLen > 3) {
	                    args = arrySlice.call(args, 1);
	                }
	
	                var _h = this._$handlers[type];
	                var len = _h.length;
	                for (var i = 0; i < len;) {
	                    // Optimize advise from backbone
	                    switch (argLen) {
	                        case 1:
	                            _h[i]['h'].call(_h[i]['ctx']);
	                            break;
	                        case 2:
	                            _h[i]['h'].call(_h[i]['ctx'], args[1]);
	                            break;
	                        case 3:
	                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
	                            break;
	                        default:
	                            // have more than 2 given arguments
	                            _h[i]['h'].apply(_h[i]['ctx'], args);
	                            break;
	                    }
	
	                    if (_h[i]['one']) {
	                        _h.splice(i, 1);
	                        len--;
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	
	            return this;
	        },
	
	        /**
	         * 带有context的事件分发, 最后一个参数是事件回调的context
	         * @param {string} type 事件类型
	         */
	        triggerWithContext: function (type) {
	            if (this._$handlers[type]) {
	                var args = arguments;
	                var argLen = args.length;
	
	                if (argLen > 4) {
	                    args = arrySlice.call(args, 1, args.length - 1);
	                }
	                var ctx = args[args.length - 1];
	
	                var _h = this._$handlers[type];
	                var len = _h.length;
	                for (var i = 0; i < len;) {
	                    // Optimize advise from backbone
	                    switch (argLen) {
	                        case 1:
	                            _h[i]['h'].call(ctx);
	                            break;
	                        case 2:
	                            _h[i]['h'].call(ctx, args[1]);
	                            break;
	                        case 3:
	                            _h[i]['h'].call(ctx, args[1], args[2]);
	                            break;
	                        default:
	                            // have more than 2 given arguments
	                            _h[i]['h'].apply(ctx, args);
	                            break;
	                    }
	
	                    if (_h[i]['one']) {
	                        _h.splice(i, 1);
	                        len--;
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	
	            return this;
	        }
	    };
	
	    // 对象可以通过 onxxxx 绑定事件
	    /**
	     * @event module:zrender/mixin/Eventful#onclick
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseover
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseout
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousemove
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousewheel
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousedown
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseup
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondrag
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragstart
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragend
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragenter
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragleave
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragover
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondrop
	     * @type {Function}
	     * @default null
	     */
	
	    module.exports = Eventful;
	


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 提供变换扩展
	 * @module zrender/mixin/Transformable
	 * @author pissang (https://www.github.com/pissang)
	 */
	
	
	    var matrix = __webpack_require__(14);
	    var vector = __webpack_require__(15);
	    var mIdentity = matrix.identity;
	
	    var EPSILON = 5e-5;
	
	    function isNotAroundZero(val) {
	        return val > EPSILON || val < -EPSILON;
	    }
	
	    /**
	     * @alias module:zrender/mixin/Transformable
	     * @constructor
	     */
	    var Transformable = function (opts) {
	        opts = opts || {};
	        // If there are no given position, rotation, scale
	        if (!opts.position) {
	            /**
	             * 平移
	             * @type {Array.<number>}
	             * @default [0, 0]
	             */
	            this.position = [0, 0];
	        }
	        if (opts.rotation == null) {
	            /**
	             * 旋转
	             * @type {Array.<number>}
	             * @default 0
	             */
	            this.rotation = 0;
	        }
	        if (!opts.scale) {
	            /**
	             * 缩放
	             * @type {Array.<number>}
	             * @default [1, 1]
	             */
	            this.scale = [1, 1];
	        }
	        /**
	         * 旋转和缩放的原点
	         * @type {Array.<number>}
	         * @default null
	         */
	        this.origin = this.origin || null;
	    };
	
	    var transformableProto = Transformable.prototype;
	    transformableProto.transform = null;
	
	    /**
	     * 判断是否需要有坐标变换
	     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
	     */
	    transformableProto.needLocalTransform = function () {
	        return isNotAroundZero(this.rotation)
	            || isNotAroundZero(this.position[0])
	            || isNotAroundZero(this.position[1])
	            || isNotAroundZero(this.scale[0] - 1)
	            || isNotAroundZero(this.scale[1] - 1);
	    };
	
	    transformableProto.updateTransform = function () {
	        var parent = this.parent;
	        var parentHasTransform = parent && parent.transform;
	        var needLocalTransform = this.needLocalTransform();
	
	        var m = this.transform;
	        if (!(needLocalTransform || parentHasTransform)) {
	            m && mIdentity(m);
	            return;
	        }
	
	        m = m || matrix.create();
	
	        if (needLocalTransform) {
	            this.getLocalTransform(m);
	        }
	        else {
	            mIdentity(m);
	        }
	
	        // 应用父节点变换
	        if (parentHasTransform) {
	            if (needLocalTransform) {
	                matrix.mul(m, parent.transform, m);
	            }
	            else {
	                matrix.copy(m, parent.transform);
	            }
	        }
	        // 保存这个变换矩阵
	        this.transform = m;
	
	        this.invTransform = this.invTransform || matrix.create();
	        matrix.invert(this.invTransform, m);
	    };
	
	    transformableProto.getLocalTransform = function (m) {
	        return Transformable.getLocalTransform(this, m);
	    };
	
	    /**
	     * 将自己的transform应用到context上
	     * @param {CanvasRenderingContext2D} ctx
	     */
	    transformableProto.setTransform = function (ctx) {        
	        var m = this.transform;
	        var dpr = ctx.dpr || 1;
	        if (m) {
	            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
	        }
	        else {
	            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	        }
	    };
	
	    transformableProto.restoreTransform = function (ctx) {
	        var dpr = ctx.dpr || 1;
	        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	    };
	
	    var tmpTransform = [];
	
	    /**
	     * 分解`transform`矩阵到`position`, `rotation`, `scale`
	     */
	    transformableProto.decomposeTransform = function () {
	        if (!this.transform) {
	            return;
	        }
	        var parent = this.parent;
	        var m = this.transform;
	        if (parent && parent.transform) {
	            // Get local transform and decompose them to position, scale, rotation
	            matrix.mul(tmpTransform, parent.invTransform, m);
	            m = tmpTransform;
	        }
	        var sx = m[0] * m[0] + m[1] * m[1];
	        var sy = m[2] * m[2] + m[3] * m[3];
	        var position = this.position;
	        var scale = this.scale;
	        if (isNotAroundZero(sx - 1)) {
	            sx = Math.sqrt(sx);
	        }
	        if (isNotAroundZero(sy - 1)) {
	            sy = Math.sqrt(sy);
	        }
	        if (m[0] < 0) {
	            sx = -sx;
	        }
	        if (m[3] < 0) {
	            sy = -sy;
	        }
	        position[0] = m[4];
	        position[1] = m[5];
	        scale[0] = sx;
	        scale[1] = sy;
	        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
	    };
	
	    /**
	     * Get global scale
	     * @return {Array.<number>}
	     */
	    transformableProto.getGlobalScale = function () {
	        var m = this.transform;
	        if (!m) {
	            return [1, 1];
	        }
	        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
	        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
	        if (m[0] < 0) {
	            sx = -sx;
	        }
	        if (m[3] < 0) {
	            sy = -sy;
	        }
	        return [sx, sy];
	    };
	    /**
	     * 变换坐标位置到 shape 的局部坐标空间
	     * @method
	     * @param {number} x
	     * @param {number} y
	     * @return {Array.<number>}
	     */
	    transformableProto.transformCoordToLocal = function (x, y) {
	        var v2 = [x, y];
	        var invTransform = this.invTransform;
	        if (invTransform) {
	            vector.applyTransform(v2, v2, invTransform);
	        }
	        return v2;
	    };
	
	    /**
	     * 变换局部坐标位置到全局坐标空间
	     * @method
	     * @param {number} x
	     * @param {number} y
	     * @return {Array.<number>}
	     */
	    transformableProto.transformCoordToGlobal = function (x, y) {
	        var v2 = [x, y];
	        var transform = this.transform;
	        if (transform) {
	            vector.applyTransform(v2, v2, transform);
	        }
	        return v2;
	    };
	
	    /**
	     * @static
	     * @param {Object} target
	     * @param {Array.<number>} target.origin
	     * @param {number} target.rotation
	     * @param {Array.<number>} target.position
	     * @param {Array.<number>} [m]
	     */
	    Transformable.getLocalTransform = function (target, m) {
	        m = m || [];
	        mIdentity(m);
	
	        var origin = target.origin;
	        var scale = target.scale || [1, 1];
	        var rotation = target.rotation || 0;
	        var position = target.position || [0, 0];
	
	        if (origin) {
	            // Translate to origin
	            m[4] -= origin[0];
	            m[5] -= origin[1];
	        }
	        matrix.scale(m, m, scale);
	        if (rotation) {
	            matrix.rotate(m, m, rotation);
	        }
	        if (origin) {
	            // Translate back from origin
	            m[4] += origin[0];
	            m[5] += origin[1];
	        }
	
	        m[4] += position[0];
	        m[5] += position[1];
	
	        return m;
	    };
	
	    module.exports = Transformable;
	


/***/ }),
/* 14 */
/***/ (function(module, exports) {

	
	    var ArrayCtor = typeof Float32Array === 'undefined'
	        ? Array
	        : Float32Array;
	    /**
	     * 3x2矩阵操作类
	     * @exports zrender/tool/matrix
	     */
	    var matrix = {
	        /**
	         * 创建一个单位矩阵
	         * @return {Float32Array|Array.<number>}
	         */
	        create : function() {
	            var out = new ArrayCtor(6);
	            matrix.identity(out);
	
	            return out;
	        },
	        /**
	         * 设置矩阵为单位矩阵
	         * @param {Float32Array|Array.<number>} out
	         */
	        identity : function(out) {
	            out[0] = 1;
	            out[1] = 0;
	            out[2] = 0;
	            out[3] = 1;
	            out[4] = 0;
	            out[5] = 0;
	            return out;
	        },
	        /**
	         * 复制矩阵
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} m
	         */
	        copy: function(out, m) {
	            out[0] = m[0];
	            out[1] = m[1];
	            out[2] = m[2];
	            out[3] = m[3];
	            out[4] = m[4];
	            out[5] = m[5];
	            return out;
	        },
	        /**
	         * 矩阵相乘
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} m1
	         * @param {Float32Array|Array.<number>} m2
	         */
	        mul : function (out, m1, m2) {
	            // Consider matrix.mul(m, m2, m);
	            // where out is the same as m2.
	            // So use temp variable to escape error.
	            var out0 = m1[0] * m2[0] + m1[2] * m2[1];
	            var out1 = m1[1] * m2[0] + m1[3] * m2[1];
	            var out2 = m1[0] * m2[2] + m1[2] * m2[3];
	            var out3 = m1[1] * m2[2] + m1[3] * m2[3];
	            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
	            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
	            out[0] = out0;
	            out[1] = out1;
	            out[2] = out2;
	            out[3] = out3;
	            out[4] = out4;
	            out[5] = out5;
	            return out;
	        },
	        /**
	         * 平移变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {Float32Array|Array.<number>} v
	         */
	        translate : function(out, a, v) {
	            out[0] = a[0];
	            out[1] = a[1];
	            out[2] = a[2];
	            out[3] = a[3];
	            out[4] = a[4] + v[0];
	            out[5] = a[5] + v[1];
	            return out;
	        },
	        /**
	         * 旋转变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {number} rad
	         */
	        rotate : function(out, a, rad) {
	            var aa = a[0];
	            var ac = a[2];
	            var atx = a[4];
	            var ab = a[1];
	            var ad = a[3];
	            var aty = a[5];
	            var st = Math.sin(rad);
	            var ct = Math.cos(rad);
	
	            out[0] = aa * ct + ab * st;
	            out[1] = -aa * st + ab * ct;
	            out[2] = ac * ct + ad * st;
	            out[3] = -ac * st + ct * ad;
	            out[4] = ct * atx + st * aty;
	            out[5] = ct * aty - st * atx;
	            return out;
	        },
	        /**
	         * 缩放变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {Float32Array|Array.<number>} v
	         */
	        scale : function(out, a, v) {
	            var vx = v[0];
	            var vy = v[1];
	            out[0] = a[0] * vx;
	            out[1] = a[1] * vy;
	            out[2] = a[2] * vx;
	            out[3] = a[3] * vy;
	            out[4] = a[4] * vx;
	            out[5] = a[5] * vy;
	            return out;
	        },
	        /**
	         * 求逆矩阵
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         */
	        invert : function(out, a) {
	
	            var aa = a[0];
	            var ac = a[2];
	            var atx = a[4];
	            var ab = a[1];
	            var ad = a[3];
	            var aty = a[5];
	
	            var det = aa * ad - ab * ac;
	            if (!det) {
	                return null;
	            }
	            det = 1.0 / det;
	
	            out[0] = ad * det;
	            out[1] = -ab * det;
	            out[2] = -ac * det;
	            out[3] = aa * det;
	            out[4] = (ac * aty - ad * atx) * det;
	            out[5] = (ab * atx - aa * aty) * det;
	            return out;
	        }
	    };
	
	    module.exports = matrix;
	


/***/ }),
/* 15 */
/***/ (function(module, exports) {

	
	    var ArrayCtor = typeof Float32Array === 'undefined'
	        ? Array
	        : Float32Array;
	
	    /**
	     * @typedef {Float32Array|Array.<number>} Vector2
	     */
	    /**
	     * 二维向量类
	     * @exports zrender/tool/vector
	     */
	    var vector = {
	        /**
	         * 创建一个向量
	         * @param {number} [x=0]
	         * @param {number} [y=0]
	         * @return {Vector2}
	         */
	        create: function (x, y) {
	            var out = new ArrayCtor(2);
	            if (x == null) {
	                x = 0;
	            }
	            if (y == null) {
	                y = 0;
	            }
	            out[0] = x;
	            out[1] = y;
	            return out;
	        },
	
	        /**
	         * 复制向量数据
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @return {Vector2}
	         */
	        copy: function (out, v) {
	            out[0] = v[0];
	            out[1] = v[1];
	            return out;
	        },
	
	        /**
	         * 克隆一个向量
	         * @param {Vector2} v
	         * @return {Vector2}
	         */
	        clone: function (v) {
	            var out = new ArrayCtor(2);
	            out[0] = v[0];
	            out[1] = v[1];
	            return out;
	        },
	
	        /**
	         * 设置向量的两个项
	         * @param {Vector2} out
	         * @param {number} a
	         * @param {number} b
	         * @return {Vector2} 结果
	         */
	        set: function (out, a, b) {
	            out[0] = a;
	            out[1] = b;
	            return out;
	        },
	
	        /**
	         * 向量相加
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        add: function (out, v1, v2) {
	            out[0] = v1[0] + v2[0];
	            out[1] = v1[1] + v2[1];
	            return out;
	        },
	
	        /**
	         * 向量缩放后相加
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @param {number} a
	         */
	        scaleAndAdd: function (out, v1, v2, a) {
	            out[0] = v1[0] + v2[0] * a;
	            out[1] = v1[1] + v2[1] * a;
	            return out;
	        },
	
	        /**
	         * 向量相减
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        sub: function (out, v1, v2) {
	            out[0] = v1[0] - v2[0];
	            out[1] = v1[1] - v2[1];
	            return out;
	        },
	
	        /**
	         * 向量长度
	         * @param {Vector2} v
	         * @return {number}
	         */
	        len: function (v) {
	            return Math.sqrt(this.lenSquare(v));
	        },
	
	        /**
	         * 向量长度平方
	         * @param {Vector2} v
	         * @return {number}
	         */
	        lenSquare: function (v) {
	            return v[0] * v[0] + v[1] * v[1];
	        },
	
	        /**
	         * 向量乘法
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        mul: function (out, v1, v2) {
	            out[0] = v1[0] * v2[0];
	            out[1] = v1[1] * v2[1];
	            return out;
	        },
	
	        /**
	         * 向量除法
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        div: function (out, v1, v2) {
	            out[0] = v1[0] / v2[0];
	            out[1] = v1[1] / v2[1];
	            return out;
	        },
	
	        /**
	         * 向量点乘
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        dot: function (v1, v2) {
	            return v1[0] * v2[0] + v1[1] * v2[1];
	        },
	
	        /**
	         * 向量缩放
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @param {number} s
	         */
	        scale: function (out, v, s) {
	            out[0] = v[0] * s;
	            out[1] = v[1] * s;
	            return out;
	        },
	
	        /**
	         * 向量归一化
	         * @param {Vector2} out
	         * @param {Vector2} v
	         */
	        normalize: function (out, v) {
	            var d = vector.len(v);
	            if (d === 0) {
	                out[0] = 0;
	                out[1] = 0;
	            }
	            else {
	                out[0] = v[0] / d;
	                out[1] = v[1] / d;
	            }
	            return out;
	        },
	
	        /**
	         * 计算向量间距离
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        distance: function (v1, v2) {
	            return Math.sqrt(
	                (v1[0] - v2[0]) * (v1[0] - v2[0])
	                + (v1[1] - v2[1]) * (v1[1] - v2[1])
	            );
	        },
	
	        /**
	         * 向量距离平方
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        distanceSquare: function (v1, v2) {
	            return (v1[0] - v2[0]) * (v1[0] - v2[0])
	                + (v1[1] - v2[1]) * (v1[1] - v2[1]);
	        },
	
	        /**
	         * 求负向量
	         * @param {Vector2} out
	         * @param {Vector2} v
	         */
	        negate: function (out, v) {
	            out[0] = -v[0];
	            out[1] = -v[1];
	            return out;
	        },
	
	        /**
	         * 插值两个点
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @param {number} t
	         */
	        lerp: function (out, v1, v2, t) {
	            out[0] = v1[0] + t * (v2[0] - v1[0]);
	            out[1] = v1[1] + t * (v2[1] - v1[1]);
	            return out;
	        },
	
	        /**
	         * 矩阵左乘向量
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @param {Vector2} m
	         */
	        applyTransform: function (out, v, m) {
	            var x = v[0];
	            var y = v[1];
	            out[0] = m[0] * x + m[2] * y + m[4];
	            out[1] = m[1] * x + m[3] * y + m[5];
	            return out;
	        },
	        /**
	         * 求两个向量最小值
	         * @param  {Vector2} out
	         * @param  {Vector2} v1
	         * @param  {Vector2} v2
	         */
	        min: function (out, v1, v2) {
	            out[0] = Math.min(v1[0], v2[0]);
	            out[1] = Math.min(v1[1], v2[1]);
	            return out;
	        },
	        /**
	         * 求两个向量最大值
	         * @param  {Vector2} out
	         * @param  {Vector2} v1
	         * @param  {Vector2} v2
	         */
	        max: function (out, v1, v2) {
	            out[0] = Math.max(v1[0], v2[0]);
	            out[1] = Math.max(v1[1], v2[1]);
	            return out;
	        }
	    };
	
	    vector.length = vector.len;
	    vector.lengthSquare = vector.lenSquare;
	    vector.dist = vector.distance;
	    vector.distSquare = vector.distanceSquare;
	
	    module.exports = vector;
	


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module zrender/mixin/Animatable
	 */
	
	
	    var Animator = __webpack_require__(17);
	    var util = __webpack_require__(5);
	    var isString = util.isString;
	    var isFunction = util.isFunction;
	    var isObject = util.isObject;
	    var log = __webpack_require__(22);
	
	    /**
	     * @alias modue:zrender/mixin/Animatable
	     * @constructor
	     */
	    var Animatable = function () {
	
	        /**
	         * @type {Array.<module:zrender/animation/Animator>}
	         * @readOnly
	         */
	        this.animators = [];
	    };
	
	    Animatable.prototype = {
	
	        constructor: Animatable,
	
	        /**
	         * 动画
	         *
	         * @param {string} path The path to fetch value from object, like 'a.b.c'.
	         * @param {boolean} [loop] Whether to loop animation.
	         * @return {module:zrender/animation/Animator}
	         * @example:
	         *     el.animate('style', false)
	         *         .when(1000, {x: 10} )
	         *         .done(function(){ // Animation done })
	         *         .start()
	         */
	        animate: function (path, loop) {
	            var target;
	            var animatingShape = false;
	            var el = this;
	            var zr = this.__zr;
	            if (path) {
	                var pathSplitted = path.split('.');
	                var prop = el;
	                // If animating shape
	                animatingShape = pathSplitted[0] === 'shape';
	                for (var i = 0, l = pathSplitted.length; i < l; i++) {
	                    if (!prop) {
	                        continue;
	                    }
	                    prop = prop[pathSplitted[i]];
	                }
	                if (prop) {
	                    target = prop;
	                }
	            }
	            else {
	                target = el;
	            }
	
	            if (!target) {
	                log(
	                    'Property "'
	                    + path
	                    + '" is not existed in element '
	                    + el.id
	                );
	                return;
	            }
	
	            var animators = el.animators;
	
	            var animator = new Animator(target, loop);
	
	            animator.during(function (target) {
	                el.dirty(animatingShape);
	            })
	            .done(function () {
	                // FIXME Animator will not be removed if use `Animator#stop` to stop animation
	                animators.splice(util.indexOf(animators, animator), 1);
	            });
	
	            animators.push(animator);
	
	            // If animate after added to the zrender
	            if (zr) {
	                zr.animation.addAnimator(animator);
	            }
	
	            return animator;
	        },
	
	        /**
	         * 停止动画
	         * @param {boolean} forwardToLast If move to last frame before stop
	         */
	        stopAnimation: function (forwardToLast) {
	            var animators = this.animators;
	            var len = animators.length;
	            for (var i = 0; i < len; i++) {
	                animators[i].stop(forwardToLast);
	            }
	            animators.length = 0;
	
	            return this;
	        },
	
	        /**
	         * Caution: this method will stop previous animation.
	         * So do not use this method to one element twice before
	         * animation starts, unless you know what you are doing.
	         * @param {Object} target
	         * @param {number} [time=500] Time in ms
	         * @param {string} [easing='linear']
	         * @param {number} [delay=0]
	         * @param {Function} [callback]
	         * @param {Function} [forceAnimate] Prevent stop animation and callback
	         *        immediently when target values are the same as current values.
	         *
	         * @example
	         *  // Animate position
	         *  el.animateTo({
	         *      position: [10, 10]
	         *  }, function () { // done })
	         *
	         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
	         *  el.animateTo({
	         *      shape: {
	         *          width: 500
	         *      },
	         *      style: {
	         *          fill: 'red'
	         *      }
	         *      position: [10, 10]
	         *  }, 100, 100, 'cubicOut', function () { // done })
	         */
	         // TODO Return animation key
	        animateTo: function (target, time, delay, easing, callback, forceAnimate) {
	            // animateTo(target, time, easing, callback);
	            if (isString(delay)) {
	                callback = easing;
	                easing = delay;
	                delay = 0;
	            }
	            // animateTo(target, time, delay, callback);
	            else if (isFunction(easing)) {
	                callback = easing;
	                easing = 'linear';
	                delay = 0;
	            }
	            // animateTo(target, time, callback);
	            else if (isFunction(delay)) {
	                callback = delay;
	                delay = 0;
	            }
	            // animateTo(target, callback)
	            else if (isFunction(time)) {
	                callback = time;
	                time = 500;
	            }
	            // animateTo(target)
	            else if (!time) {
	                time = 500;
	            }
	            // Stop all previous animations
	            this.stopAnimation();
	            this._animateToShallow('', this, target, time, delay, easing, callback);
	
	            // Animators may be removed immediately after start
	            // if there is nothing to animate
	            var animators = this.animators.slice();
	            var count = animators.length;
	            function done() {
	                count--;
	                if (!count) {
	                    callback && callback();
	                }
	            }
	
	            // No animators. This should be checked before animators[i].start(),
	            // because 'done' may be executed immediately if no need to animate.
	            if (!count) {
	                callback && callback();
	            }
	            // Start after all animators created
	            // Incase any animator is done immediately when all animation properties are not changed
	            for (var i = 0; i < animators.length; i++) {
	                animators[i]
	                    .done(done)
	                    .start(easing, forceAnimate);
	            }
	        },
	
	        /**
	         * @private
	         * @param {string} path=''
	         * @param {Object} source=this
	         * @param {Object} target
	         * @param {number} [time=500]
	         * @param {number} [delay=0]
	         *
	         * @example
	         *  // Animate position
	         *  el._animateToShallow({
	         *      position: [10, 10]
	         *  })
	         *
	         *  // Animate shape, style and position in 100ms, delayed 100ms
	         *  el._animateToShallow({
	         *      shape: {
	         *          width: 500
	         *      },
	         *      style: {
	         *          fill: 'red'
	         *      }
	         *      position: [10, 10]
	         *  }, 100, 100)
	         */
	        _animateToShallow: function (path, source, target, time, delay) {
	            var objShallow = {};
	            var propertyCount = 0;
	            for (var name in target) {
	                if (!target.hasOwnProperty(name)) {
	                    continue;
	                }
	
	                if (source[name] != null) {
	                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {
	                        this._animateToShallow(
	                            path ? path + '.' + name : name,
	                            source[name],
	                            target[name],
	                            time,
	                            delay
	                        );
	                    }
	                    else {
	                        objShallow[name] = target[name];
	                        propertyCount++;
	                    }
	                }
	                else if (target[name] != null) {
	                    // Attr directly if not has property
	                    // FIXME, if some property not needed for element ?
	                    if (!path) {
	                        this.attr(name, target[name]);
	                    }
	                    else {  // Shape or style
	                        var props = {};
	                        props[path] = {};
	                        props[path][name] = target[name];
	                        this.attr(props);
	                    }
	                }
	            }
	
	            if (propertyCount > 0) {
	                this.animate(path, false)
	                    .when(time == null ? 500 : time, objShallow)
	                    .delay(delay || 0);
	            }
	
	            return this;
	        }
	    };
	
	    module.exports = Animatable;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @module echarts/animation/Animator
	 */
	
	
	    var Clip = __webpack_require__(18);
	    var color = __webpack_require__(20);
	    var util = __webpack_require__(5);
	    var isArrayLike = util.isArrayLike;
	
	    var arraySlice = Array.prototype.slice;
	
	    function defaultGetter(target, key) {
	        return target[key];
	    }
	
	    function defaultSetter(target, key, value) {
	        target[key] = value;
	    }
	
	    /**
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} percent
	     * @return {number}
	     */
	    function interpolateNumber(p0, p1, percent) {
	        return (p1 - p0) * percent + p0;
	    }
	
	    /**
	     * @param  {string} p0
	     * @param  {string} p1
	     * @param  {number} percent
	     * @return {string}
	     */
	    function interpolateString(p0, p1, percent) {
	        return percent > 0.5 ? p1 : p0;
	    }
	
	    /**
	     * @param  {Array} p0
	     * @param  {Array} p1
	     * @param  {number} percent
	     * @param  {Array} out
	     * @param  {number} arrDim
	     */
	    function interpolateArray(p0, p1, percent, out, arrDim) {
	        var len = p0.length;
	        if (arrDim == 1) {
	            for (var i = 0; i < len; i++) {
	                out[i] = interpolateNumber(p0[i], p1[i], percent);
	            }
	        }
	        else {
	            var len2 = len && p0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    out[i][j] = interpolateNumber(
	                        p0[i][j], p1[i][j], percent
	                    );
	                }
	            }
	        }
	    }
	
	    // arr0 is source array, arr1 is target array.
	    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1
	    function fillArr(arr0, arr1, arrDim) {
	        var arr0Len = arr0.length;
	        var arr1Len = arr1.length;
	        if (arr0Len !== arr1Len) {
	            // FIXME Not work for TypedArray
	            var isPreviousLarger = arr0Len > arr1Len;
	            if (isPreviousLarger) {
	                // Cut the previous
	                arr0.length = arr1Len;
	            }
	            else {
	                // Fill the previous
	                for (var i = arr0Len; i < arr1Len; i++) {
	                    arr0.push(
	                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])
	                    );
	                }
	            }
	        }
	        // Handling NaN value
	        var len2 = arr0[0] && arr0[0].length;
	        for (var i = 0; i < arr0.length; i++) {
	            if (arrDim === 1) {
	                if (isNaN(arr0[i])) {
	                    arr0[i] = arr1[i];
	                }
	            }
	            else {
	                for (var j = 0; j < len2; j++) {
	                    if (isNaN(arr0[i][j])) {
	                        arr0[i][j] = arr1[i][j];
	                    }
	                }
	            }
	        }
	    }
	
	    /**
	     * @param  {Array} arr0
	     * @param  {Array} arr1
	     * @param  {number} arrDim
	     * @return {boolean}
	     */
	    function isArraySame(arr0, arr1, arrDim) {
	        if (arr0 === arr1) {
	            return true;
	        }
	        var len = arr0.length;
	        if (len !== arr1.length) {
	            return false;
	        }
	        if (arrDim === 1) {
	            for (var i = 0; i < len; i++) {
	                if (arr0[i] !== arr1[i]) {
	                    return false;
	                }
	            }
	        }
	        else {
	            var len2 = arr0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    if (arr0[i][j] !== arr1[i][j]) {
	                        return false;
	                    }
	                }
	            }
	        }
	        return true;
	    }
	
	    /**
	     * Catmull Rom interpolate array
	     * @param  {Array} p0
	     * @param  {Array} p1
	     * @param  {Array} p2
	     * @param  {Array} p3
	     * @param  {number} t
	     * @param  {number} t2
	     * @param  {number} t3
	     * @param  {Array} out
	     * @param  {number} arrDim
	     */
	    function catmullRomInterpolateArray(
	        p0, p1, p2, p3, t, t2, t3, out, arrDim
	    ) {
	        var len = p0.length;
	        if (arrDim == 1) {
	            for (var i = 0; i < len; i++) {
	                out[i] = catmullRomInterpolate(
	                    p0[i], p1[i], p2[i], p3[i], t, t2, t3
	                );
	            }
	        }
	        else {
	            var len2 = p0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    out[i][j] = catmullRomInterpolate(
	                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],
	                        t, t2, t3
	                    );
	                }
	            }
	        }
	    }
	
	    /**
	     * Catmull Rom interpolate number
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @param  {number} t2
	     * @param  {number} t3
	     * @return {number}
	     */
	    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
	        var v0 = (p2 - p0) * 0.5;
	        var v1 = (p3 - p1) * 0.5;
	        return (2 * (p1 - p2) + v0 + v1) * t3
	                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
	                + v0 * t + p1;
	    }
	
	    function cloneValue(value) {
	        if (isArrayLike(value)) {
	            var len = value.length;
	            if (isArrayLike(value[0])) {
	                var ret = [];
	                for (var i = 0; i < len; i++) {
	                    ret.push(arraySlice.call(value[i]));
	                }
	                return ret;
	            }
	
	            return arraySlice.call(value);
	        }
	
	        return value;
	    }
	
	    function rgba2String(rgba) {
	        rgba[0] = Math.floor(rgba[0]);
	        rgba[1] = Math.floor(rgba[1]);
	        rgba[2] = Math.floor(rgba[2]);
	
	        return 'rgba(' + rgba.join(',') + ')';
	    }
	
	    function getArrayDim(keyframes) {
	        var lastValue = keyframes[keyframes.length - 1].value;
	        return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;
	    }
	
	    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
	        var getter = animator._getter;
	        var setter = animator._setter;
	        var useSpline = easing === 'spline';
	
	        var trackLen = keyframes.length;
	        if (!trackLen) {
	            return;
	        }
	        // Guess data type
	        var firstVal = keyframes[0].value;
	        var isValueArray = isArrayLike(firstVal);
	        var isValueColor = false;
	        var isValueString = false;
	
	        // For vertices morphing
	        var arrDim = isValueArray ? getArrayDim(keyframes) : 0;
	
	        var trackMaxTime;
	        // Sort keyframe as ascending
	        keyframes.sort(function(a, b) {
	            return a.time - b.time;
	        });
	
	        trackMaxTime = keyframes[trackLen - 1].time;
	        // Percents of each keyframe
	        var kfPercents = [];
	        // Value of each keyframe
	        var kfValues = [];
	        var prevValue = keyframes[0].value;
	        var isAllValueEqual = true;
	        for (var i = 0; i < trackLen; i++) {
	            kfPercents.push(keyframes[i].time / trackMaxTime);
	            // Assume value is a color when it is a string
	            var value = keyframes[i].value;
	
	            // Check if value is equal, deep check if value is array
	            if (!((isValueArray && isArraySame(value, prevValue, arrDim))
	                || (!isValueArray && value === prevValue))) {
	                isAllValueEqual = false;
	            }
	            prevValue = value;
	
	            // Try converting a string to a color array
	            if (typeof value == 'string') {
	                var colorArray = color.parse(value);
	                if (colorArray) {
	                    value = colorArray;
	                    isValueColor = true;
	                }
	                else {
	                    isValueString = true;
	                }
	            }
	            kfValues.push(value);
	        }
	        if (!forceAnimate && isAllValueEqual) {
	            return;
	        }
	
	        var lastValue = kfValues[trackLen - 1];
	        // Polyfill array and NaN value
	        for (var i = 0; i < trackLen - 1; i++) {
	            if (isValueArray) {
	                fillArr(kfValues[i], lastValue, arrDim);
	            }
	            else {
	                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
	                    kfValues[i] = lastValue;
	                }
	            }
	        }
	        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);
	
	        // Cache the key of last frame to speed up when
	        // animation playback is sequency
	        var lastFrame = 0;
	        var lastFramePercent = 0;
	        var start;
	        var w;
	        var p0;
	        var p1;
	        var p2;
	        var p3;
	
	        if (isValueColor) {
	            var rgba = [0, 0, 0, 0];
	        }
	
	        var onframe = function (target, percent) {
	            // Find the range keyframes
	            // kf1-----kf2---------current--------kf3
	            // find kf2 and kf3 and do interpolation
	            var frame;
	            // In the easing function like elasticOut, percent may less than 0
	            if (percent < 0) {
	                frame = 0;
	            }
	            else if (percent < lastFramePercent) {
	                // Start from next key
	                // PENDING start from lastFrame ?
	                start = Math.min(lastFrame + 1, trackLen - 1);
	                for (frame = start; frame >= 0; frame--) {
	                    if (kfPercents[frame] <= percent) {
	                        break;
	                    }
	                }
	                // PENDING really need to do this ?
	                frame = Math.min(frame, trackLen - 2);
	            }
	            else {
	                for (frame = lastFrame; frame < trackLen; frame++) {
	                    if (kfPercents[frame] > percent) {
	                        break;
	                    }
	                }
	                frame = Math.min(frame - 1, trackLen - 2);
	            }
	            lastFrame = frame;
	            lastFramePercent = percent;
	
	            var range = (kfPercents[frame + 1] - kfPercents[frame]);
	            if (range === 0) {
	                return;
	            }
	            else {
	                w = (percent - kfPercents[frame]) / range;
	            }
	            if (useSpline) {
	                p1 = kfValues[frame];
	                p0 = kfValues[frame === 0 ? frame : frame - 1];
	                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
	                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
	                if (isValueArray) {
	                    catmullRomInterpolateArray(
	                        p0, p1, p2, p3, w, w * w, w * w * w,
	                        getter(target, propName),
	                        arrDim
	                    );
	                }
	                else {
	                    var value;
	                    if (isValueColor) {
	                        value = catmullRomInterpolateArray(
	                            p0, p1, p2, p3, w, w * w, w * w * w,
	                            rgba, 1
	                        );
	                        value = rgba2String(rgba);
	                    }
	                    else if (isValueString) {
	                        // String is step(0.5)
	                        return interpolateString(p1, p2, w);
	                    }
	                    else {
	                        value = catmullRomInterpolate(
	                            p0, p1, p2, p3, w, w * w, w * w * w
	                        );
	                    }
	                    setter(
	                        target,
	                        propName,
	                        value
	                    );
	                }
	            }
	            else {
	                if (isValueArray) {
	                    interpolateArray(
	                        kfValues[frame], kfValues[frame + 1], w,
	                        getter(target, propName),
	                        arrDim
	                    );
	                }
	                else {
	                    var value;
	                    if (isValueColor) {
	                        interpolateArray(
	                            kfValues[frame], kfValues[frame + 1], w,
	                            rgba, 1
	                        );
	                        value = rgba2String(rgba);
	                    }
	                    else if (isValueString) {
	                        // String is step(0.5)
	                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);
	                    }
	                    else {
	                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
	                    }
	                    setter(
	                        target,
	                        propName,
	                        value
	                    );
	                }
	            }
	        };
	
	        var clip = new Clip({
	            target: animator._target,
	            life: trackMaxTime,
	            loop: animator._loop,
	            delay: animator._delay,
	            onframe: onframe,
	            ondestroy: oneTrackDone
	        });
	
	        if (easing && easing !== 'spline') {
	            clip.easing = easing;
	        }
	
	        return clip;
	    }
	
	    /**
	     * @alias module:zrender/animation/Animator
	     * @constructor
	     * @param {Object} target
	     * @param {boolean} loop
	     * @param {Function} getter
	     * @param {Function} setter
	     */
	    var Animator = function(target, loop, getter, setter) {
	        this._tracks = {};
	        this._target = target;
	
	        this._loop = loop || false;
	
	        this._getter = getter || defaultGetter;
	        this._setter = setter || defaultSetter;
	
	        this._clipCount = 0;
	
	        this._delay = 0;
	
	        this._doneList = [];
	
	        this._onframeList = [];
	
	        this._clipList = [];
	    };
	
	    Animator.prototype = {
	        /**
	         * 设置动画关键帧
	         * @param  {number} time 关键帧时间，单位是ms
	         * @param  {Object} props 关键帧的属性值，key-value表示
	         * @return {module:zrender/animation/Animator}
	         */
	        when: function(time /* ms */, props) {
	            var tracks = this._tracks;
	            for (var propName in props) {
	                if (!props.hasOwnProperty(propName)) {
	                    continue;
	                }
	
	                if (!tracks[propName]) {
	                    tracks[propName] = [];
	                    // Invalid value
	                    var value = this._getter(this._target, propName);
	                    if (value == null) {
	                        // zrLog('Invalid property ' + propName);
	                        continue;
	                    }
	                    // If time is 0
	                    //  Then props is given initialize value
	                    // Else
	                    //  Initialize value from current prop value
	                    if (time !== 0) {
	                        tracks[propName].push({
	                            time: 0,
	                            value: cloneValue(value)
	                        });
	                    }
	                }
	                tracks[propName].push({
	                    time: time,
	                    value: props[propName]
	                });
	            }
	            return this;
	        },
	        /**
	         * 添加动画每一帧的回调函数
	         * @param  {Function} callback
	         * @return {module:zrender/animation/Animator}
	         */
	        during: function (callback) {
	            this._onframeList.push(callback);
	            return this;
	        },
	
	        pause: function () {
	            for (var i = 0; i < this._clipList.length; i++) {
	                this._clipList[i].pause();
	            }
	            this._paused = true;
	        },
	
	        resume: function () {
	            for (var i = 0; i < this._clipList.length; i++) {
	                this._clipList[i].resume();
	            }
	            this._paused = false;
	        },
	
	        isPaused: function () {
	            return !!this._paused;
	        },
	
	        _doneCallback: function () {
	            // Clear all tracks
	            this._tracks = {};
	            // Clear all clips
	            this._clipList.length = 0;
	
	            var doneList = this._doneList;
	            var len = doneList.length;
	            for (var i = 0; i < len; i++) {
	                doneList[i].call(this);
	            }
	        },
	        /**
	         * 开始执行动画
	         * @param  {string|Function} [easing]
	         *         动画缓动函数，详见{@link module:zrender/animation/easing}
	         * @param  {boolean} forceAnimate
	         * @return {module:zrender/animation/Animator}
	         */
	        start: function (easing, forceAnimate) {
	
	            var self = this;
	            var clipCount = 0;
	
	            var oneTrackDone = function() {
	                clipCount--;
	                if (!clipCount) {
	                    self._doneCallback();
	                }
	            };
	
	            var lastClip;
	            for (var propName in this._tracks) {
	                if (!this._tracks.hasOwnProperty(propName)) {
	                    continue;
	                }
	                var clip = createTrackClip(
	                    this, easing, oneTrackDone,
	                    this._tracks[propName], propName, forceAnimate
	                );
	                if (clip) {
	                    this._clipList.push(clip);
	                    clipCount++;
	
	                    // If start after added to animation
	                    if (this.animation) {
	                        this.animation.addClip(clip);
	                    }
	
	                    lastClip = clip;
	                }
	            }
	
	            // Add during callback on the last clip
	            if (lastClip) {
	                var oldOnFrame = lastClip.onframe;
	                lastClip.onframe = function (target, percent) {
	                    oldOnFrame(target, percent);
	
	                    for (var i = 0; i < self._onframeList.length; i++) {
	                        self._onframeList[i](target, percent);
	                    }
	                };
	            }
	
	            // This optimization will help the case that in the upper application
	            // the view may be refreshed frequently, where animation will be
	            // called repeatly but nothing changed.
	            if (!clipCount) {
	                this._doneCallback();
	            }
	            return this;
	        },
	        /**
	         * 停止动画
	         * @param {boolean} forwardToLast If move to last frame before stop
	         */
	        stop: function (forwardToLast) {
	            var clipList = this._clipList;
	            var animation = this.animation;
	            for (var i = 0; i < clipList.length; i++) {
	                var clip = clipList[i];
	                if (forwardToLast) {
	                    // Move to last frame before stop
	                    clip.onframe(this._target, 1);
	                }
	                animation && animation.removeClip(clip);
	            }
	            clipList.length = 0;
	        },
	        /**
	         * 设置动画延迟开始的时间
	         * @param  {number} time 单位ms
	         * @return {module:zrender/animation/Animator}
	         */
	        delay: function (time) {
	            this._delay = time;
	            return this;
	        },
	        /**
	         * 添加动画结束的回调
	         * @param  {Function} cb
	         * @return {module:zrender/animation/Animator}
	         */
	        done: function(cb) {
	            if (cb) {
	                this._doneList.push(cb);
	            }
	            return this;
	        },
	
	        /**
	         * @return {Array.<module:zrender/animation/Clip>}
	         */
	        getClips: function () {
	            return this._clipList;
	        }
	    };
	
	    module.exports = Animator;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 动画主控制器
	 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
	 * @config life(1000) 动画时长
	 * @config delay(0) 动画延迟时间
	 * @config loop(true)
	 * @config gap(0) 循环的间隔时间
	 * @config onframe
	 * @config easing(optional)
	 * @config ondestroy(optional)
	 * @config onrestart(optional)
	 *
	 * TODO pause
	 */
	
	
	    var easingFuncs = __webpack_require__(19);
	
	    function Clip(options) {
	
	        this._target = options.target;
	
	        // 生命周期
	        this._life = options.life || 1000;
	        // 延时
	        this._delay = options.delay || 0;
	        // 开始时间
	        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒
	        this._initialized = false;
	
	        // 是否循环
	        this.loop = options.loop == null ? false : options.loop;
	
	        this.gap = options.gap || 0;
	
	        this.easing = options.easing || 'Linear';
	
	        this.onframe = options.onframe;
	        this.ondestroy = options.ondestroy;
	        this.onrestart = options.onrestart;
	
	        this._pausedTime = 0;
	        this._paused = false;
	    }
	
	    Clip.prototype = {
	
	        constructor: Clip,
	
	        step: function (globalTime, deltaTime) {
	            // Set startTime on first step, or _startTime may has milleseconds different between clips
	            // PENDING
	            if (!this._initialized) {
	                this._startTime = globalTime + this._delay;
	                this._initialized = true;
	            }
	
	            if (this._paused) {
	                this._pausedTime += deltaTime;
	                return;
	            }
	
	            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;
	
	            // 还没开始
	            if (percent < 0) {
	                return;
	            }
	
	            percent = Math.min(percent, 1);
	
	            var easing = this.easing;
	            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
	            var schedule = typeof easingFunc === 'function'
	                ? easingFunc(percent)
	                : percent;
	
	            this.fire('frame', schedule);
	
	            // 结束
	            if (percent == 1) {
	                if (this.loop) {
	                    this.restart (globalTime);
	                    // 重新开始周期
	                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
	                    return 'restart';
	                }
	
	                // 动画完成将这个控制器标识为待删除
	                // 在Animation.update中进行批量删除
	                this._needsRemove = true;
	                return 'destroy';
	            }
	
	            return null;
	        },
	
	        restart: function (globalTime) {
	            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
	            this._startTime = globalTime - remainder + this.gap;
	            this._pausedTime = 0;
	
	            this._needsRemove = false;
	        },
	
	        fire: function (eventType, arg) {
	            eventType = 'on' + eventType;
	            if (this[eventType]) {
	                this[eventType](this._target, arg);
	            }
	        },
	
	        pause: function () {
	            this._paused = true;
	        },
	
	        resume: function () {
	            this._paused = false;
	        }
	    };
	
	    module.exports = Clip;
	


/***/ }),
/* 19 */
/***/ (function(module, exports) {

	/**
	 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
	 * @see http://sole.github.io/tween.js/examples/03_graphs.html
	 * @exports zrender/animation/easing
	 */
	
	    var easing = {
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        linear: function (k) {
	            return k;
	        },
	
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticIn: function (k) {
	            return k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticOut: function (k) {
	            return k * (2 - k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k;
	            }
	            return -0.5 * (--k * (k - 2) - 1);
	        },
	
	        // 三次方的缓动（t^3）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicIn: function (k) {
	            return k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicOut: function (k) {
	            return --k * k * k + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k;
	            }
	            return 0.5 * ((k -= 2) * k * k + 2);
	        },
	
	        // 四次方的缓动（t^4）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticIn: function (k) {
	            return k * k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticOut: function (k) {
	            return 1 - (--k * k * k * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k * k;
	            }
	            return -0.5 * ((k -= 2) * k * k * k - 2);
	        },
	
	        // 五次方的缓动（t^5）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticIn: function (k) {
	            return k * k * k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticOut: function (k) {
	            return --k * k * k * k * k + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k * k * k;
	            }
	            return 0.5 * ((k -= 2) * k * k * k * k + 2);
	        },
	
	        // 正弦曲线的缓动（sin(t)）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalIn: function (k) {
	            return 1 - Math.cos(k * Math.PI / 2);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalOut: function (k) {
	            return Math.sin(k * Math.PI / 2);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalInOut: function (k) {
	            return 0.5 * (1 - Math.cos(Math.PI * k));
	        },
	
	        // 指数曲线的缓动（2^t）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialIn: function (k) {
	            return k === 0 ? 0 : Math.pow(1024, k - 1);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialOut: function (k) {
	            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialInOut: function (k) {
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if ((k *= 2) < 1) {
	                return 0.5 * Math.pow(1024, k - 1);
	            }
	            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
	        },
	
	        // 圆形曲线的缓动（sqrt(1-t^2)）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularIn: function (k) {
	            return 1 - Math.sqrt(1 - k * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularOut: function (k) {
	            return Math.sqrt(1 - (--k * k));
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return -0.5 * (Math.sqrt(1 - k * k) - 1);
	            }
	            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	        },
	
	        // 创建类似于弹簧在停止前来回振荡的动画
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticIn: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            return -(a * Math.pow(2, 10 * (k -= 1)) *
	                        Math.sin((k - s) * (2 * Math.PI) / p));
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticOut: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            return (a * Math.pow(2, -10 * k) *
	                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticInOut: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            if ((k *= 2) < 1) {
	                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))
	                    * Math.sin((k - s) * (2 * Math.PI) / p));
	            }
	            return a * Math.pow(2, -10 * (k -= 1))
	                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
	
	        },
	
	        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backIn: function (k) {
	            var s = 1.70158;
	            return k * k * ((s + 1) * k - s);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backOut: function (k) {
	            var s = 1.70158;
	            return --k * k * ((s + 1) * k + s) + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backInOut: function (k) {
	            var s = 1.70158 * 1.525;
	            if ((k *= 2) < 1) {
	                return 0.5 * (k * k * ((s + 1) * k - s));
	            }
	            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	        },
	
	        // 创建弹跳效果
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceIn: function (k) {
	            return 1 - easing.bounceOut(1 - k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceOut: function (k) {
	            if (k < (1 / 2.75)) {
	                return 7.5625 * k * k;
	            }
	            else if (k < (2 / 2.75)) {
	                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
	            }
	            else if (k < (2.5 / 2.75)) {
	                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
	            }
	            else {
	                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
	            }
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceInOut: function (k) {
	            if (k < 0.5) {
	                return easing.bounceIn(k * 2) * 0.5;
	            }
	            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
	        }
	    };
	
	    module.exports = easing;
	
	


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @module zrender/tool/color
	 */
	
	
	    var LRU = __webpack_require__(21);
	
	    var kCSSColorTable = {
	        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],
	        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],
	        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],
	        'beige': [245,245,220,1], 'bisque': [255,228,196,1],
	        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],
	        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],
	        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],
	        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],
	        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],
	        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],
	        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],
	        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],
	        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],
	        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],
	        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],
	        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],
	        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],
	        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],
	        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],
	        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],
	        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],
	        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],
	        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],
	        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],
	        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],
	        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],
	        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],
	        'gray': [128,128,128,1], 'green': [0,128,0,1],
	        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],
	        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],
	        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],
	        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],
	        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],
	        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],
	        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],
	        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],
	        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],
	        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],
	        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],
	        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],
	        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],
	        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],
	        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],
	        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],
	        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],
	        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],
	        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],
	        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],
	        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],
	        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],
	        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],
	        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],
	        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],
	        'orange': [255,165,0,1], 'orangered': [255,69,0,1],
	        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],
	        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],
	        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],
	        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],
	        'pink': [255,192,203,1], 'plum': [221,160,221,1],
	        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],
	        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],
	        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],
	        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],
	        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],
	        'sienna': [160,82,45,1], 'silver': [192,192,192,1],
	        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],
	        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],
	        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],
	        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],
	        'teal': [0,128,128,1], 'thistle': [216,191,216,1],
	        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],
	        'violet': [238,130,238,1], 'wheat': [245,222,179,1],
	        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],
	        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]
	    };
	
	    function clampCssByte(i) {  // Clamp to integer 0 .. 255.
	        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
	        return i < 0 ? 0 : i > 255 ? 255 : i;
	    }
	
	    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.
	        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
	        return i < 0 ? 0 : i > 360 ? 360 : i;
	    }
	
	    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.
	        return f < 0 ? 0 : f > 1 ? 1 : f;
	    }
	
	    function parseCssInt(str) {  // int or percentage.
	        if (str.length && str.charAt(str.length - 1) === '%') {
	            return clampCssByte(parseFloat(str) / 100 * 255);
	        }
	        return clampCssByte(parseInt(str, 10));
	    }
	
	    function parseCssFloat(str) {  // float or percentage.
	        if (str.length && str.charAt(str.length - 1) === '%') {
	            return clampCssFloat(parseFloat(str) / 100);
	        }
	        return clampCssFloat(parseFloat(str));
	    }
	
	    function cssHueToRgb(m1, m2, h) {
	        if (h < 0) {
	            h += 1;
	        }
	        else if (h > 1) {
	            h -= 1;
	        }
	
	        if (h * 6 < 1) {
	            return m1 + (m2 - m1) * h * 6;
	        }
	        if (h * 2 < 1) {
	            return m2;
	        }
	        if (h * 3 < 2) {
	            return m1 + (m2 - m1) * (2/3 - h) * 6;
	        }
	        return m1;
	    }
	
	    function lerpNumber(a, b, p) {
	        return a + (b - a) * p;
	    }
	
	    function setRgba(out, r, g, b, a) {
	        out[0] = r; out[1] = g; out[2] = b; out[3] = a;
	        return out;
	    }
	    function copyRgba(out, a) {
	        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
	        return out;
	    }
	    var colorCache = new LRU(20);
	    var lastRemovedArr = null;
	    function putToCache(colorStr, rgbaArr) {
	        // Reuse removed array
	        if (lastRemovedArr) {
	            copyRgba(lastRemovedArr, rgbaArr);
	        }
	        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));
	    }
	    /**
	     * @param {string} colorStr
	     * @param {Array.<number>} out
	     * @return {Array.<number>}
	     * @memberOf module:zrender/util/color
	     */
	    function parse(colorStr, rgbaArr) {
	        if (!colorStr) {
	            return;
	        }
	        rgbaArr = rgbaArr || [];
	
	        var cached = colorCache.get(colorStr);
	        if (cached) {
	            return copyRgba(rgbaArr, cached);
	        }
	
	        // colorStr may be not string
	        colorStr = colorStr + '';
	        // Remove all whitespace, not compliant, but should just be more accepting.
	        var str = colorStr.replace(/ /g, '').toLowerCase();
	
	        // Color keywords (and transparent) lookup.
	        if (str in kCSSColorTable) {
	            copyRgba(rgbaArr, kCSSColorTable[str]);
	            putToCache(colorStr, rgbaArr);
	            return rgbaArr;
	        }
	
	        // #abc and #abc123 syntax.
	        if (str.charAt(0) === '#') {
	            if (str.length === 4) {
	                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
	                if (!(iv >= 0 && iv <= 0xfff)) {
	                    setRgba(rgbaArr, 0, 0, 0, 1);
	                    return;  // Covers NaN.
	                }
	                setRgba(rgbaArr,
	                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
	                    (iv & 0xf0) | ((iv & 0xf0) >> 4),
	                    (iv & 0xf) | ((iv & 0xf) << 4),
	                    1
	                );
	                putToCache(colorStr, rgbaArr);
	                return rgbaArr;
	            }
	            else if (str.length === 7) {
	                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
	                if (!(iv >= 0 && iv <= 0xffffff)) {
	                    setRgba(rgbaArr, 0, 0, 0, 1);
	                    return;  // Covers NaN.
	                }
	                setRgba(rgbaArr,
	                    (iv & 0xff0000) >> 16,
	                    (iv & 0xff00) >> 8,
	                    iv & 0xff,
	                    1
	                );
	                putToCache(colorStr, rgbaArr);
	                return rgbaArr;
	            }
	
	            return;
	        }
	        var op = str.indexOf('('), ep = str.indexOf(')');
	        if (op !== -1 && ep + 1 === str.length) {
	            var fname = str.substr(0, op);
	            var params = str.substr(op + 1, ep - (op + 1)).split(',');
	            var alpha = 1;  // To allow case fallthrough.
	            switch (fname) {
	                case 'rgba':
	                    if (params.length !== 4) {
	                        setRgba(rgbaArr, 0, 0, 0, 1);
	                        return;
	                    }
	                    alpha = parseCssFloat(params.pop()); // jshint ignore:line
	                // Fall through.
	                case 'rgb':
	                    if (params.length !== 3) {
	                        setRgba(rgbaArr, 0, 0, 0, 1);
	                        return;
	                    }
	                    setRgba(rgbaArr,
	                        parseCssInt(params[0]),
	                        parseCssInt(params[1]),
	                        parseCssInt(params[2]),
	                        alpha
	                    );
	                    putToCache(colorStr, rgbaArr);
	                    return rgbaArr;
	                case 'hsla':
	                    if (params.length !== 4) {
	                        setRgba(rgbaArr, 0, 0, 0, 1);
	                        return;
	                    }
	                    params[3] = parseCssFloat(params[3]);
	                    hsla2rgba(params, rgbaArr);
	                    putToCache(colorStr, rgbaArr);
	                    return rgbaArr;
	                case 'hsl':
	                    if (params.length !== 3) {
	                        setRgba(rgbaArr, 0, 0, 0, 1);
	                        return;
	                    }
	                    hsla2rgba(params, rgbaArr);
	                    putToCache(colorStr, rgbaArr);
	                    return rgbaArr;
	                default:
	                    return;
	            }
	        }
	
	        setRgba(rgbaArr, 0, 0, 0, 1);
	        return;
	    }
	
	    /**
	     * @param {Array.<number>} hsla
	     * @param {Array.<number>} rgba
	     * @return {Array.<number>} rgba
	     */
	    function hsla2rgba(hsla, rgba) {
	        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
	        // NOTE(deanm): According to the CSS spec s/l should only be
	        // percentages, but we don't bother and let float or percentage.
	        var s = parseCssFloat(hsla[1]);
	        var l = parseCssFloat(hsla[2]);
	        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	        var m1 = l * 2 - m2;
	
	        rgba = rgba || [];
	        setRgba(rgba,
	            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),
	            clampCssByte(cssHueToRgb(m1, m2, h) * 255),
	            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),
	            1
	        );
	
	        if (hsla.length === 4) {
	            rgba[3] = hsla[3];
	        }
	
	        return rgba;
	    }
	
	    /**
	     * @param {Array.<number>} rgba
	     * @return {Array.<number>} hsla
	     */
	    function rgba2hsla(rgba) {
	        if (!rgba) {
	            return;
	        }
	
	        // RGB from 0 to 255
	        var R = rgba[0] / 255;
	        var G = rgba[1] / 255;
	        var B = rgba[2] / 255;
	
	        var vMin = Math.min(R, G, B); // Min. value of RGB
	        var vMax = Math.max(R, G, B); // Max. value of RGB
	        var delta = vMax - vMin; // Delta RGB value
	
	        var L = (vMax + vMin) / 2;
	        var H;
	        var S;
	        // HSL results from 0 to 1
	        if (delta === 0) {
	            H = 0;
	            S = 0;
	        }
	        else {
	            if (L < 0.5) {
	                S = delta / (vMax + vMin);
	            }
	            else {
	                S = delta / (2 - vMax - vMin);
	            }
	
	            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
	            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
	            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;
	
	            if (R === vMax) {
	                H = deltaB - deltaG;
	            }
	            else if (G === vMax) {
	                H = (1 / 3) + deltaR - deltaB;
	            }
	            else if (B === vMax) {
	                H = (2 / 3) + deltaG - deltaR;
	            }
	
	            if (H < 0) {
	                H += 1;
	            }
	
	            if (H > 1) {
	                H -= 1;
	            }
	        }
	
	        var hsla = [H * 360, S, L];
	
	        if (rgba[3] != null) {
	            hsla.push(rgba[3]);
	        }
	
	        return hsla;
	    }
	
	    /**
	     * @param {string} color
	     * @param {number} level
	     * @return {string}
	     * @memberOf module:zrender/util/color
	     */
	    function lift(color, level) {
	        var colorArr = parse(color);
	        if (colorArr) {
	            for (var i = 0; i < 3; i++) {
	                if (level < 0) {
	                    colorArr[i] = colorArr[i] * (1 - level) | 0;
	                }
	                else {
	                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;
	                }
	            }
	            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
	        }
	    }
	
	    /**
	     * @param {string} color
	     * @return {string}
	     * @memberOf module:zrender/util/color
	     */
	    function toHex(color, level) {
	        var colorArr = parse(color);
	        if (colorArr) {
	            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);
	        }
	    }
	
	    /**
	     * Map value to color. Faster than lerp methods because color is represented by rgba array.
	     * @param {number} normalizedValue A float between 0 and 1.
	     * @param {Array.<Array.<number>>} colors List of rgba color array
	     * @param {Array.<number>} [out] Mapped gba color array
	     * @return {Array.<number>} will be null/undefined if input illegal.
	     */
	    function fastLerp(normalizedValue, colors, out) {
	        if (!(colors && colors.length)
	            || !(normalizedValue >= 0 && normalizedValue <= 1)
	        ) {
	            return;
	        }
	
	        out = out || [];
	
	        var value = normalizedValue * (colors.length - 1);
	        var leftIndex = Math.floor(value);
	        var rightIndex = Math.ceil(value);
	        var leftColor = colors[leftIndex];
	        var rightColor = colors[rightIndex];
	        var dv = value - leftIndex;
	        out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
	        out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
	        out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
	        out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
	
	        return out;
	    }
	
	    /**
	     * @param {number} normalizedValue A float between 0 and 1.
	     * @param {Array.<string>} colors Color list.
	     * @param {boolean=} fullOutput Default false.
	     * @return {(string|Object)} Result color. If fullOutput,
	     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
	     * @memberOf module:zrender/util/color
	     */
	    function lerp(normalizedValue, colors, fullOutput) {
	        if (!(colors && colors.length)
	            || !(normalizedValue >= 0 && normalizedValue <= 1)
	        ) {
	            return;
	        }
	
	        var value = normalizedValue * (colors.length - 1);
	        var leftIndex = Math.floor(value);
	        var rightIndex = Math.ceil(value);
	        var leftColor = parse(colors[leftIndex]);
	        var rightColor = parse(colors[rightIndex]);
	        var dv = value - leftIndex;
	
	        var color = stringify(
	            [
	                clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),
	                clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),
	                clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),
	                clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
	            ],
	            'rgba'
	        );
	
	        return fullOutput
	            ? {
	                color: color,
	                leftIndex: leftIndex,
	                rightIndex: rightIndex,
	                value: value
	            }
	            : color;
	    }
	
	    /**
	     * @param {string} color
	     * @param {number=} h 0 ~ 360, ignore when null.
	     * @param {number=} s 0 ~ 1, ignore when null.
	     * @param {number=} l 0 ~ 1, ignore when null.
	     * @return {string} Color string in rgba format.
	     * @memberOf module:zrender/util/color
	     */
	    function modifyHSL(color, h, s, l) {
	        color = parse(color);
	
	        if (color) {
	            color = rgba2hsla(color);
	            h != null && (color[0] = clampCssAngle(h));
	            s != null && (color[1] = parseCssFloat(s));
	            l != null && (color[2] = parseCssFloat(l));
	
	            return stringify(hsla2rgba(color), 'rgba');
	        }
	    }
	
	    /**
	     * @param {string} color
	     * @param {number=} alpha 0 ~ 1
	     * @return {string} Color string in rgba format.
	     * @memberOf module:zrender/util/color
	     */
	    function modifyAlpha(color, alpha) {
	        color = parse(color);
	
	        if (color && alpha != null) {
	            color[3] = clampCssFloat(alpha);
	            return stringify(color, 'rgba');
	        }
	    }
	
	    /**
	     * @param {Array.<number>} arrColor like [12,33,44,0.4]
	     * @param {string} type 'rgba', 'hsva', ...
	     * @return {string} Result color. (If input illegal, return undefined).
	     */
	    function stringify(arrColor, type) {
	        if (!arrColor || !arrColor.length) {
	            return;
	        }
	        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
	        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
	            colorStr += ',' + arrColor[3];
	        }
	        return type + '(' + colorStr + ')';
	    }
	
	    module.exports = {
	        parse: parse,
	        lift: lift,
	        toHex: toHex,
	        fastLerp: fastLerp,
	        fastMapToColor: fastLerp, // Deprecated
	        lerp: lerp,
	        mapToColor: lerp, // Deprecated
	        modifyHSL: modifyHSL,
	        modifyAlpha: modifyAlpha,
	        stringify: stringify
	    };
	
	


/***/ }),
/* 21 */
/***/ (function(module, exports) {

	// Simple LRU cache use doubly linked list
	// @module zrender/core/LRU
	
	
	    /**
	     * Simple double linked list. Compared with array, it has O(1) remove operation.
	     * @constructor
	     */
	    var LinkedList = function () {
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.head = null;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.tail = null;
	
	        this._len = 0;
	    };
	
	    var linkedListProto = LinkedList.prototype;
	    /**
	     * Insert a new value at the tail
	     * @param  {} val
	     * @return {module:zrender/core/LRU~Entry}
	     */
	    linkedListProto.insert = function (val) {
	        var entry = new Entry(val);
	        this.insertEntry(entry);
	        return entry;
	    };
	
	    /**
	     * Insert an entry at the tail
	     * @param  {module:zrender/core/LRU~Entry} entry
	     */
	    linkedListProto.insertEntry = function (entry) {
	        if (!this.head) {
	            this.head = this.tail = entry;
	        }
	        else {
	            this.tail.next = entry;
	            entry.prev = this.tail;
	            entry.next = null;
	            this.tail = entry;
	        }
	        this._len++;
	    };
	
	    /**
	     * Remove entry.
	     * @param  {module:zrender/core/LRU~Entry} entry
	     */
	    linkedListProto.remove = function (entry) {
	        var prev = entry.prev;
	        var next = entry.next;
	        if (prev) {
	            prev.next = next;
	        }
	        else {
	            // Is head
	            this.head = next;
	        }
	        if (next) {
	            next.prev = prev;
	        }
	        else {
	            // Is tail
	            this.tail = prev;
	        }
	        entry.next = entry.prev = null;
	        this._len--;
	    };
	
	    /**
	     * @return {number}
	     */
	    linkedListProto.len = function () {
	        return this._len;
	    };
	
	    /**
	     * Clear list
	     */
	    linkedListProto.clear = function () {
	        this.head = this.tail = null;
	        this._len = 0;
	    };
	
	    /**
	     * @constructor
	     * @param {} val
	     */
	    var Entry = function (val) {
	        /**
	         * @type {}
	         */
	        this.value = val;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.next;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.prev;
	    };
	
	    /**
	     * LRU Cache
	     * @constructor
	     * @alias module:zrender/core/LRU
	     */
	    var LRU = function (maxSize) {
	
	        this._list = new LinkedList();
	
	        this._map = {};
	
	        this._maxSize = maxSize || 10;
	
	        this._lastRemovedEntry = null;
	    };
	
	    var LRUProto = LRU.prototype;
	
	    /**
	     * @param  {string} key
	     * @param  {} value
	     * @return {} Removed value
	     */
	    LRUProto.put = function (key, value) {
	        var list = this._list;
	        var map = this._map;
	        var removed = null;
	        if (map[key] == null) {
	            var len = list.len();
	            // Reuse last removed entry
	            var entry = this._lastRemovedEntry;
	
	            if (len >= this._maxSize && len > 0) {
	                // Remove the least recently used
	                var leastUsedEntry = list.head;
	                list.remove(leastUsedEntry);
	                delete map[leastUsedEntry.key];
	
	                removed = leastUsedEntry.value;
	                this._lastRemovedEntry = leastUsedEntry;
	            }
	
	            if (entry) {
	                entry.value = value;
	            }
	            else {
	                entry = new Entry(value);
	            }
	            entry.key = key;
	            list.insertEntry(entry);
	            map[key] = entry;
	        }
	
	        return removed;
	    };
	
	    /**
	     * @param  {string} key
	     * @return {}
	     */
	    LRUProto.get = function (key) {
	        var entry = this._map[key];
	        var list = this._list;
	        if (entry != null) {
	            // Put the latest used entry in the tail
	            if (entry !== list.tail) {
	                list.remove(entry);
	                list.insertEntry(entry);
	            }
	
	            return entry.value;
	        }
	    };
	
	    /**
	     * Clear the cache
	     */
	    LRUProto.clear = function () {
	        this._list.clear();
	        this._map = {};
	    };
	
	    module.exports = LRU;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	
	        var config = __webpack_require__(23);
	
	        /**
	         * @exports zrender/tool/log
	         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	         */
	        module.exports = function() {
	            if (config.debugMode === 0) {
	                return;
	            }
	            else if (config.debugMode == 1) {
	                for (var k in arguments) {
	                    throw new Error(arguments[k]);
	                }
	            }
	            else if (config.debugMode > 1) {
	                for (var k in arguments) {
	                    console.log(arguments[k]);
	                }
	            }
	        };
	
	        /* for debug
	        return function(mes) {
	            document.getElementById('wrong-message').innerHTML =
	                mes + ' ' + (new Date() - 0)
	                + '<br/>'
	                + document.getElementById('wrong-message').innerHTML;
	        };
	        */
	    


/***/ }),
/* 23 */
/***/ (function(module, exports) {

	
	    var dpr = 1;
	    // If in browser environment
	    if (typeof window !== 'undefined') {
	        dpr = Math.max(window.devicePixelRatio || 1, 1);
	    }
	    /**
	     * config默认配置项
	     * @exports zrender/config
	     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	     */
	    var config = {
	        /**
	         * debug日志选项：catchBrushException为true下有效
	         * 0 : 不生成debug数据，发布用
	         * 1 : 异常抛出，调试用
	         * 2 : 控制台输出，调试用
	         */
	        debugMode: 0,
	
	        // retina 屏幕优化
	        devicePixelRatio: dpr
	    };
	    module.exports = config;
	
	


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Mixin for drawing text in a element bounding rect
	 * @module zrender/mixin/RectText
	 */
	
	
	
	    var textHelper = __webpack_require__(25);
	    var BoundingRect = __webpack_require__(27);
	
	    var tmpRect = new BoundingRect();
	
	    var RectText = function () {};
	
	    RectText.prototype = {
	
	        constructor: RectText,
	
	        /**
	         * Draw text in a rect with specified position.
	         * @param  {CanvasRenderingContext2D} ctx
	         * @param  {Object} rect Displayable rect
	         */
	        drawRectText: function (ctx, rect) {
	            var style = this.style;
	
	            rect = style.textRect || rect;
	
	            // Optimize, avoid normalize every time.
	            this.__dirty && textHelper.normalizeTextStyle(style, true);
	
	            var text = style.text;
	
	            // Convert to string
	            text != null && (text += '');
	
	            if (!textHelper.needDrawText(text, style)) {
	                return;
	            }
	
	            // FIXME
	            ctx.save();
	
	            // Transform rect to view space
	            var transform = this.transform;
	            if (!style.transformText) {
	                if (transform) {
	                    tmpRect.copy(rect);
	                    tmpRect.applyTransform(transform);
	                    rect = tmpRect;
	                }
	            }
	            else {
	                this.setTransform(ctx);
	            }
	
	            // transformText and textRotation can not be used at the same time.
	            textHelper.renderText(this, ctx, text, style, rect);
	
	            ctx.restore();
	        }
	    };
	
	    module.exports = RectText;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var textContain = __webpack_require__(26);
	    var util = __webpack_require__(5);
	    var roundRectHelper = __webpack_require__(29);
	    var imageHelper = __webpack_require__(28);
	
	    var retrieve3 = util.retrieve3;
	    var retrieve2 = util.retrieve2;
	
	    // TODO: Have not support 'start', 'end' yet.
	    var VALID_TEXT_ALIGN = {left: 1, right: 1, center: 1};
	    var VALID_TEXT_VERTICAL_ALIGN = {top: 1, bottom: 1, middle: 1};
	
	    var helper = {};
	
	    /**
	     * @param {module:zrender/graphic/Style} style
	     * @return {module:zrender/graphic/Style} The input style.
	     */
	    helper.normalizeTextStyle = function (style) {
	        normalizeStyle(style);
	        util.each(style.rich, normalizeStyle);
	        return style;
	    };
	
	    function normalizeStyle(style) {
	        if (style) {
	
	            style.font = textContain.makeFont(style);
	
	            var textAlign = style.textAlign;
	            textAlign === 'middle' && (textAlign = 'center');
	            style.textAlign = (
	                textAlign == null || VALID_TEXT_ALIGN[textAlign]
	            ) ? textAlign : 'left';
	
	            // Compatible with textBaseline.
	            var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
	            textVerticalAlign === 'center' && (textVerticalAlign = 'middle');
	            style.textVerticalAlign = (
	                textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign]
	            ) ? textVerticalAlign : 'top';
	
	            var textPadding = style.textPadding;
	            if (textPadding) {
	                style.textPadding = util.normalizeCssArray(style.textPadding);
	            }
	        }
	    }
	
	    /**
	     * @param {CanvasRenderingContext2D} ctx
	     * @param {string} text
	     * @param {module:zrender/graphic/Style} style
	     * @param {Object|boolean} [rect] {x, y, width, height}
	     *                  If set false, rect text is not used.
	     */
	    helper.renderText = function (hostEl, ctx, text, style, rect) {
	        style.rich
	            ? renderRichText(hostEl, ctx, text, style, rect)
	            : renderPlainText(hostEl, ctx, text, style, rect);
	    };
	
	    function renderPlainText(hostEl, ctx, text, style, rect) {
	        var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);
	
	        var textPadding = style.textPadding;
	
	        var contentBlock = hostEl.__textCotentBlock;
	        if (!contentBlock || hostEl.__dirty) {
	            contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(
	                text, font, textPadding, style.truncate
	            );
	        }
	
	        var outerHeight = contentBlock.outerHeight;
	
	        var textLines = contentBlock.lines;
	        var lineHeight = contentBlock.lineHeight;
	
	        var boxPos = getBoxPosition(outerHeight, style, rect);
	        var baseX = boxPos.baseX;
	        var baseY = boxPos.baseY;
	        var textAlign = boxPos.textAlign;
	        var textVerticalAlign = boxPos.textVerticalAlign;
	
	        // Origin of textRotation should be the base point of text drawing.
	        applyTextRotation(ctx, style, rect, baseX, baseY);
	
	        var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
	        var textX = baseX;
	        var textY = boxY;
	
	        var needDrawBg = needDrawBackground(style);
	        if (needDrawBg || textPadding) {
	            // Consider performance, do not call getTextWidth util necessary.
	            var textWidth = textContain.getWidth(text, font);
	            var outerWidth = textWidth;
	            textPadding && (outerWidth += textPadding[1] + textPadding[3]);
	            var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
	
	            needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
	
	            if (textPadding) {
	                textX = getTextXForPadding(baseX, textAlign, textPadding);
	                textY += textPadding[0];
	            }
	        }
	
	        setCtx(ctx, 'textAlign', textAlign || 'left');
	        // Force baseline to be "middle". Otherwise, if using "top", the
	        // text will offset downward a little bit in font "Microsoft YaHei".
	        setCtx(ctx, 'textBaseline', 'middle');
	
	        // Always set shadowBlur and shadowOffset to avoid leak from displayable.
	        setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);
	        setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');
	        setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);
	        setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0);
	
	        // `textBaseline` is set as 'middle'.
	        textY += lineHeight / 2;
	
	        var textStrokeWidth = style.textStrokeWidth;
	        var textStroke = getStroke(style.textStroke, textStrokeWidth);
	        var textFill = getFill(style.textFill);
	
	        if (textStroke) {
	            setCtx(ctx, 'lineWidth', textStrokeWidth);
	            setCtx(ctx, 'strokeStyle', textStroke);
	        }
	        if (textFill) {
	            setCtx(ctx, 'fillStyle', textFill);
	        }
	
	        for (var i = 0; i < textLines.length; i++) {
	            // Fill after stroke so the outline will not cover the main part.
	            textStroke && ctx.strokeText(textLines[i], textX, textY);
	            textFill && ctx.fillText(textLines[i], textX, textY);
	            textY += lineHeight;
	        }
	    }
	
	    function renderRichText(hostEl, ctx, text, style, rect) {
	        var contentBlock = hostEl.__textCotentBlock;
	
	        if (!contentBlock || hostEl.__dirty) {
	            contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);
	        }
	
	        drawRichText(hostEl, ctx, contentBlock, style, rect);
	    }
	
	    function drawRichText(hostEl, ctx, contentBlock, style, rect) {
	        var contentWidth = contentBlock.width;
	        var outerWidth = contentBlock.outerWidth;
	        var outerHeight = contentBlock.outerHeight;
	        var textPadding = style.textPadding;
	
	        var boxPos = getBoxPosition(outerHeight, style, rect);
	        var baseX = boxPos.baseX;
	        var baseY = boxPos.baseY;
	        var textAlign = boxPos.textAlign;
	        var textVerticalAlign = boxPos.textVerticalAlign;
	
	        // Origin of textRotation should be the base point of text drawing.
	        applyTextRotation(ctx, style, rect, baseX, baseY);
	
	        var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
	        var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
	        var xLeft = boxX;
	        var lineTop = boxY;
	        if (textPadding) {
	            xLeft += textPadding[3];
	            lineTop += textPadding[0];
	        }
	        var xRight = xLeft + contentWidth;
	
	        needDrawBackground(style) && drawBackground(
	            hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight
	        );
	
	        for (var i = 0; i < contentBlock.lines.length; i++) {
	            var line = contentBlock.lines[i];
	            var tokens = line.tokens;
	            var tokenCount = tokens.length;
	            var lineHeight = line.lineHeight;
	            var usedWidth = line.width;
	
	            var leftIndex = 0;
	            var lineXLeft = xLeft;
	            var lineXRight = xRight;
	            var rightIndex = tokenCount - 1;
	            var token;
	
	            while (
	                leftIndex < tokenCount
	                && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')
	            ) {
	                placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');
	                usedWidth -= token.width;
	                lineXLeft += token.width;
	                leftIndex++;
	            }
	
	            while (
	                rightIndex >= 0
	                && (token = tokens[rightIndex], token.textAlign === 'right')
	            ) {
	                placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');
	                usedWidth -= token.width;
	                lineXRight -= token.width;
	                rightIndex--;
	            }
	
	            // The other tokens are placed as textAlign 'center' if there is enough space.
	            lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;
	            while (leftIndex <= rightIndex) {
	                token = tokens[leftIndex];
	                // Consider width specified by user, use 'center' rather than 'left'.
	                placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');
	                lineXLeft += token.width;
	                leftIndex++;
	            }
	
	            lineTop += lineHeight;
	        }
	    }
	
	    function applyTextRotation(ctx, style, rect, x, y) {
	        // textRotation only apply in RectText.
	        if (rect && style.textRotation) {
	            var origin = style.textOrigin;
	            if (origin === 'center') {
	                x = rect.width / 2 + rect.x;
	                y = rect.height / 2 + rect.y;
	            }
	            else if (origin) {
	                x = origin[0] + rect.x;
	                y = origin[1] + rect.y;
	            }
	
	            ctx.translate(x, y);
	            // Positive: anticlockwise
	            ctx.rotate(-style.textRotation);
	            ctx.translate(-x, -y);
	        }
	    }
	
	    function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
	        var tokenStyle = style.rich[token.styleName] || {};
	
	        // 'ctx.textBaseline' is always set as 'middle', for sake of
	        // the bias of "Microsoft YaHei".
	        var textVerticalAlign = token.textVerticalAlign;
	        var y = lineTop + lineHeight / 2;
	        if (textVerticalAlign === 'top') {
	            y = lineTop + token.height / 2;
	        }
	        else if (textVerticalAlign === 'bottom') {
	            y = lineTop + lineHeight - token.height / 2;
	        }
	
	        !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(
	            hostEl,
	            ctx,
	            tokenStyle,
	            textAlign === 'right'
	                ? x - token.width
	                : textAlign === 'center'
	                ? x - token.width / 2
	                : x,
	            y - token.height / 2,
	            token.width,
	            token.height
	        );
	
	        var textPadding = token.textPadding;
	        if (textPadding) {
	            x = getTextXForPadding(x, textAlign, textPadding);
	            y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
	        }
	
	        setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
	        setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');
	        setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
	        setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));
	
	        setCtx(ctx, 'textAlign', textAlign);
	        // Force baseline to be "middle". Otherwise, if using "top", the
	        // text will offset downward a little bit in font "Microsoft YaHei".
	        setCtx(ctx, 'textBaseline', 'middle');
	
	        setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);
	
	        var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
	        var textFill = getFill(tokenStyle.textFill || style.textFill);
	        var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth);
	
	        // Fill after stroke so the outline will not cover the main part.
	        if (textStroke) {
	            setCtx(ctx, 'lineWidth', textStrokeWidth);
	            setCtx(ctx, 'strokeStyle', textStroke);
	            ctx.strokeText(token.text, x, y);
	        }
	        if (textFill) {
	            setCtx(ctx, 'fillStyle', textFill);
	            ctx.fillText(token.text, x, y);
	        }
	    }
	
	    function needDrawBackground(style) {
	        return style.textBackgroundColor
	            || (style.textBorderWidth && style.textBorderColor);
	    }
	
	    // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}
	    // shape: {x, y, width, height}
	    function drawBackground(hostEl, ctx, style, x, y, width, height) {
	        var textBackgroundColor = style.textBackgroundColor;
	        var textBorderWidth = style.textBorderWidth;
	        var textBorderColor = style.textBorderColor;
	        var isPlainBg = util.isString(textBackgroundColor);
	
	        setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);
	        setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');
	        setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);
	        setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);
	
	        if (isPlainBg || (textBorderWidth && textBorderColor)) {
	            ctx.beginPath();
	            var textBorderRadius = style.textBorderRadius;
	            if (!textBorderRadius) {
	                ctx.rect(x, y, width, height);
	            }
	            else {
	                roundRectHelper.buildPath(ctx, {
	                    x: x, y: y, width: width, height: height, r: textBorderRadius
	                });
	            }
	            ctx.closePath();
	        }
	
	        if (isPlainBg) {
	            setCtx(ctx, 'fillStyle', textBackgroundColor);
	            ctx.fill();
	        }
	        else if (util.isObject(textBackgroundColor)) {
	            var image = textBackgroundColor.image;
	
	            image = imageHelper.createOrUpdateImage(
	                image, null, hostEl, onBgImageLoaded, textBackgroundColor
	            );
	            if (image && imageHelper.isImageReady(image)) {
	                ctx.drawImage(image, x, y, width, height);
	            }
	        }
	
	        if (textBorderWidth && textBorderColor) {
	            setCtx(ctx, 'lineWidth', textBorderWidth);
	            setCtx(ctx, 'strokeStyle', textBorderColor);
	            ctx.stroke();
	        }
	    }
	
	    function onBgImageLoaded(image, textBackgroundColor) {
	        // Replace image, so that `contain/text.js#parseRichText`
	        // will get correct result in next tick.
	        textBackgroundColor.image = image;
	    }
	
	    function getBoxPosition(blockHeiht, style, rect) {
	        var baseX = style.x || 0;
	        var baseY = style.y || 0;
	        var textAlign = style.textAlign;
	        var textVerticalAlign = style.textVerticalAlign;
	
	        // Text position represented by coord
	        if (rect) {
	            var textPosition = style.textPosition;
	            if (textPosition instanceof Array) {
	                // Percent
	                baseX = rect.x + parsePercent(textPosition[0], rect.width);
	                baseY = rect.y + parsePercent(textPosition[1], rect.height);
	            }
	            else {
	                var res = textContain.adjustTextPositionOnRect(
	                    textPosition, rect, style.textDistance
	                );
	                baseX = res.x;
	                baseY = res.y;
	                // Default align and baseline when has textPosition
	                textAlign = textAlign || res.textAlign;
	                textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
	            }
	
	            // textOffset is only support in RectText, otherwise
	            // we have to adjust boundingRect for textOffset.
	            var textOffset = style.textOffset;
	            if (textOffset) {
	                baseX += textOffset[0];
	                baseY += textOffset[1];
	            }
	        }
	
	        return {
	            baseX: baseX,
	            baseY: baseY,
	            textAlign: textAlign,
	            textVerticalAlign: textVerticalAlign
	        };
	    }
	
	    function setCtx(ctx, prop, value) {
	        // FIXME ??? performance try
	        // if (ctx.__currentValues[prop] !== value) {
	            // ctx[prop] = ctx.__currentValues[prop] = value;
	        ctx[prop] = value;
	        // }
	        return ctx[prop];
	    }
	
	    /**
	     * @param {string} [stroke] If specified, do not check style.textStroke.
	     * @param {string} [lineWidth] If specified, do not check style.textStroke.
	     * @param {number} style
	     */
	    var getStroke = helper.getStroke = function (stroke, lineWidth) {
	        return (stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none')
	            ? null
	            // TODO pattern and gradient?
	            : (stroke.image || stroke.colorStops)
	            ? '#000'
	            : stroke;
	    };
	
	    var getFill = helper.getFill = function (fill) {
	        return (fill == null || fill === 'none')
	            ? null
	            // TODO pattern and gradient?
	            : (fill.image || fill.colorStops)
	            ? '#000'
	            : fill;
	    };
	
	    function parsePercent(value, maxValue) {
	        if (typeof value === 'string') {
	            if (value.lastIndexOf('%') >= 0) {
	                return parseFloat(value) / 100 * maxValue;
	            }
	            return parseFloat(value);
	        }
	        return value;
	    }
	
	    function getTextXForPadding(x, textAlign, textPadding) {
	        return textAlign === 'right'
	            ? (x - textPadding[1])
	            : textAlign === 'center'
	            ? (x + textPadding[3] / 2 - textPadding[1] / 2)
	            : (x + textPadding[3]);
	    }
	
	    /**
	     * @param {string} text
	     * @param {module:zrender/Style} style
	     * @return {boolean}
	     */
	    helper.needDrawText = function (text, style) {
	        return text != null
	            && (text
	                || style.textBackgroundColor
	                || (style.textBorderWidth && style.textBorderColor)
	                || style.textPadding
	            );
	    };
	
	    module.exports = helper;
	
	


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var util = __webpack_require__(5);
	    var BoundingRect = __webpack_require__(27);
	    var imageHelper = __webpack_require__(28);
	
	    var textWidthCache = {};
	    var textWidthCacheCounter = 0;
	
	    var TEXT_CACHE_MAX = 5000;
	    var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
	    var DEFAULT_FONT = '12px sans-serif';
	
	    var retrieve2 = util.retrieve2;
	    var retrieve3 = util.retrieve3;
	
	    /**
	     * @public
	     * @param {string} text
	     * @param {string} font
	     * @return {number} width
	     */
	    function getTextWidth(text, font) {
	        font = font || DEFAULT_FONT;
	        var key = text + ':' + font;
	        if (textWidthCache[key]) {
	            return textWidthCache[key];
	        }
	
	        var textLines = (text + '').split('\n');
	        var width = 0;
	
	        for (var i = 0, l = textLines.length; i < l; i++) {
	            // textContain.measureText may be overrided in SVG or VML
	            width = Math.max(textContain.measureText(textLines[i], font).width, width);
	        }
	
	        if (textWidthCacheCounter > TEXT_CACHE_MAX) {
	            textWidthCacheCounter = 0;
	            textWidthCache = {};
	        }
	        textWidthCacheCounter++;
	        textWidthCache[key] = width;
	
	        return width;
	    }
	
	    /**
	     * @public
	     * @param {string} text
	     * @param {string} font
	     * @param {string} [textAlign='left']
	     * @param {string} [textVerticalAlign='top']
	     * @param {Array.<number>} [textPadding]
	     * @param {Object} [rich]
	     * @param {Object} [truncate]
	     * @return {Object} {x, y, width, height, lineHeight}
	     */
	    function getTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
	        return rich
	            ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate)
	            : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);
	    }
	
	    function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {
	        var contentBlock = parsePlainText(text, font, textPadding, truncate);
	        var outerWidth = getTextWidth(text, font);
	        if (textPadding) {
	            outerWidth += textPadding[1] + textPadding[3];
	        }
	        var outerHeight = contentBlock.outerHeight;
	
	        var x = adjustTextX(0, outerWidth, textAlign);
	        var y = adjustTextY(0, outerHeight, textVerticalAlign);
	
	        var rect = new BoundingRect(x, y, outerWidth, outerHeight);
	        rect.lineHeight = contentBlock.lineHeight;
	
	        return rect;
	    }
	
	    function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
	        var contentBlock = parseRichText(text, {
	            rich: rich,
	            truncate: truncate,
	            font: font,
	            textAlign: textAlign,
	            textPadding: textPadding
	        });
	        var outerWidth = contentBlock.outerWidth;
	        var outerHeight = contentBlock.outerHeight;
	
	        var x = adjustTextX(0, outerWidth, textAlign);
	        var y = adjustTextY(0, outerHeight, textVerticalAlign);
	
	        return new BoundingRect(x, y, outerWidth, outerHeight);
	    }
	
	    /**
	     * @public
	     * @param {number} x
	     * @param {number} width
	     * @param {string} [textAlign='left']
	     * @return {number} Adjusted x.
	     */
	    function adjustTextX(x, width, textAlign) {
	        // FIXME Right to left language
	        if (textAlign === 'right') {
	            x -= width;
	        }
	        else if (textAlign === 'center') {
	            x -= width / 2;
	        }
	        return x;
	    }
	
	    /**
	     * @public
	     * @param {number} y
	     * @param {number} height
	     * @param {string} [textVerticalAlign='top']
	     * @return {number} Adjusted y.
	     */
	    function adjustTextY(y, height, textVerticalAlign) {
	        if (textVerticalAlign === 'middle') {
	            y -= height / 2;
	        }
	        else if (textVerticalAlign === 'bottom') {
	            y -= height;
	        }
	        return y;
	    }
	
	    /**
	     * @public
	     * @param {stirng} textPosition
	     * @param {Object} rect {x, y, width, height}
	     * @param {number} distance
	     * @return {Object} {x, y, textAlign, textVerticalAlign}
	     */
	    function adjustTextPositionOnRect(textPosition, rect, distance) {
	
	        var x = rect.x;
	        var y = rect.y;
	
	        var height = rect.height;
	        var width = rect.width;
	        var halfHeight = height / 2;
	
	        var textAlign = 'left';
	        var textVerticalAlign = 'top';
	
	        switch (textPosition) {
	            case 'left':
	                x -= distance;
	                y += halfHeight;
	                textAlign = 'right';
	                textVerticalAlign = 'middle';
	                break;
	            case 'right':
	                x += distance + width;
	                y += halfHeight;
	                textVerticalAlign = 'middle';
	                break;
	            case 'top':
	                x += width / 2;
	                y -= distance;
	                textAlign = 'center';
	                textVerticalAlign = 'bottom';
	                break;
	            case 'bottom':
	                x += width / 2;
	                y += height + distance;
	                textAlign = 'center';
	                break;
	            case 'inside':
	                x += width / 2;
	                y += halfHeight;
	                textAlign = 'center';
	                textVerticalAlign = 'middle';
	                break;
	            case 'insideLeft':
	                x += distance;
	                y += halfHeight;
	                textVerticalAlign = 'middle';
	                break;
	            case 'insideRight':
	                x += width - distance;
	                y += halfHeight;
	                textAlign = 'right';
	                textVerticalAlign = 'middle';
	                break;
	            case 'insideTop':
	                x += width / 2;
	                y += distance;
	                textAlign = 'center';
	                break;
	            case 'insideBottom':
	                x += width / 2;
	                y += height - distance;
	                textAlign = 'center';
	                textVerticalAlign = 'bottom';
	                break;
	            case 'insideTopLeft':
	                x += distance;
	                y += distance;
	                break;
	            case 'insideTopRight':
	                x += width - distance;
	                y += distance;
	                textAlign = 'right';
	                break;
	            case 'insideBottomLeft':
	                x += distance;
	                y += height - distance;
	                textVerticalAlign = 'bottom';
	                break;
	            case 'insideBottomRight':
	                x += width - distance;
	                y += height - distance;
	                textAlign = 'right';
	                textVerticalAlign = 'bottom';
	                break;
	        }
	
	        return {
	            x: x,
	            y: y,
	            textAlign: textAlign,
	            textVerticalAlign: textVerticalAlign
	        };
	    }
	
	    /**
	     * Show ellipsis if overflow.
	     *
	     * @public
	     * @param  {string} text
	     * @param  {string} containerWidth
	     * @param  {string} font
	     * @param  {number} [ellipsis='...']
	     * @param  {Object} [options]
	     * @param  {number} [options.maxIterations=3]
	     * @param  {number} [options.minChar=0] If truncate result are less
	     *                  then minChar, ellipsis will not show, which is
	     *                  better for user hint in some cases.
	     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
	     * @return {string}
	     */
	    function truncateText(text, containerWidth, font, ellipsis, options) {
	        if (!containerWidth) {
	            return '';
	        }
	
	        var textLines = (text + '').split('\n');
	        options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
	
	        // FIXME
	        // It is not appropriate that every line has '...' when truncate multiple lines.
	        for (var i = 0, len = textLines.length; i < len; i++) {
	            textLines[i] = truncateSingleLine(textLines[i], options);
	        }
	
	        return textLines.join('\n');
	    }
	
	    function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
	        options = util.extend({}, options);
	
	        options.font = font;
	        var ellipsis = retrieve2(ellipsis, '...');
	        options.maxIterations = retrieve2(options.maxIterations, 2);
	        var minChar = options.minChar = retrieve2(options.minChar, 0);
	        // FIXME
	        // Other languages?
	        options.cnCharWidth = getTextWidth('国', font);
	        // FIXME
	        // Consider proportional font?
	        var ascCharWidth = options.ascCharWidth = getTextWidth('a', font);
	        options.placeholder = retrieve2(options.placeholder, '');
	
	        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
	        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.
	        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.
	        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
	            contentWidth -= ascCharWidth;
	        }
	
	        var ellipsisWidth = getTextWidth(ellipsis);
	        if (ellipsisWidth > contentWidth) {
	            ellipsis = '';
	            ellipsisWidth = 0;
	        }
	
	        contentWidth = containerWidth - ellipsisWidth;
	
	        options.ellipsis = ellipsis;
	        options.ellipsisWidth = ellipsisWidth;
	        options.contentWidth = contentWidth;
	        options.containerWidth = containerWidth;
	
	        return options;
	    }
	
	    function truncateSingleLine(textLine, options) {
	        var containerWidth = options.containerWidth;
	        var font = options.font;
	        var contentWidth = options.contentWidth;
	
	        if (!containerWidth) {
	            return '';
	        }
	
	        var lineWidth = getTextWidth(textLine, font);
	
	        if (lineWidth <= containerWidth) {
	            return textLine;
	        }
	
	        for (var j = 0;; j++) {
	            if (lineWidth <= contentWidth || j >= options.maxIterations) {
	                textLine += options.ellipsis;
	                break;
	            }
	
	            var subLength = j === 0
	                ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth)
	                : lineWidth > 0
	                ? Math.floor(textLine.length * contentWidth / lineWidth)
	                : 0;
	
	            textLine = textLine.substr(0, subLength);
	            lineWidth = getTextWidth(textLine, font);
	        }
	
	        if (textLine === '') {
	            textLine = options.placeholder;
	        }
	
	        return textLine;
	    }
	
	    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
	        var width = 0;
	        var i = 0;
	        for (var len = text.length; i < len && width < contentWidth; i++) {
	            var charCode = text.charCodeAt(i);
	            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;
	        }
	        return i;
	    }
	
	    /**
	     * @public
	     * @param {string} font
	     * @return {number} line height
	     */
	    function getLineHeight(font) {
	        // FIXME A rough approach.
	        return getTextWidth('国', font);
	    }
	
	    /**
	     * @public
	     * @param {string} text
	     * @param {string} font
	     * @return {Object} width
	     */
	    function measureText(text, font) {
	        var ctx = util.getContext();
	        ctx.font = font || DEFAULT_FONT;
	        return ctx.measureText(text);
	    }
	
	    /**
	     * @public
	     * @param {string} text
	     * @param {string} font
	     * @param {Object} [truncate]
	     * @return {Object} block: {lineHeight, lines, height, outerHeight}
	     *  Notice: for performance, do not calculate outerWidth util needed.
	     */
	    function parsePlainText(text, font, padding, truncate) {
	        text != null && (text += '');
	
	        var lineHeight = getLineHeight(font);
	        var lines = text ? text.split('\n') : [];
	        var height = lines.length * lineHeight;
	        var outerHeight = height;
	
	        if (padding) {
	            outerHeight += padding[0] + padding[2];
	        }
	
	        if (text && truncate) {
	            var truncOuterHeight = truncate.outerHeight;
	            var truncOuterWidth = truncate.outerWidth;
	            if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
	                text = '';
	                lines = [];
	            }
	            else if (truncOuterWidth != null) {
	                var options = prepareTruncateOptions(
	                    truncOuterWidth - (padding ? padding[1] + padding[3] : 0),
	                    font,
	                    truncate.ellipsis,
	                    {minChar: truncate.minChar, placeholder: truncate.placeholder}
	                );
	
	                // FIXME
	                // It is not appropriate that every line has '...' when truncate multiple lines.
	                for (var i = 0, len = lines.length; i < len; i++) {
	                    lines[i] = truncateSingleLine(lines[i], options);
	                }
	            }
	        }
	
	        return {
	            lines: lines,
	            height: height,
	            outerHeight: outerHeight,
	            lineHeight: lineHeight
	        };
	    }
	
	    /**
	     * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'
	     * Also consider 'bbbb{a|xxx\nzzz}xxxx\naaaa'.
	     *
	     * @public
	     * @param {string} text
	     * @param {Object} style
	     * @return {Object} block
	     * {
	     *      width,
	     *      height,
	     *      lines: [{
	     *          lineHeight,
	     *          width,
	     *          tokens: [[{
	     *              styleName,
	     *              text,
	     *              width,      // include textPadding
	     *              height,     // include textPadding
	     *              textWidth, // pure text width
	     *              textHeight, // pure text height
	     *              lineHeihgt,
	     *              font,
	     *              textAlign,
	     *              textVerticalAlign
	     *          }], [...], ...]
	     *      }, ...]
	     * }
	     * If styleName is undefined, it is plain text.
	     */
	    function parseRichText(text, style) {
	        var contentBlock = {lines: [], width: 0, height: 0};
	
	        text != null && (text += '');
	        if (!text) {
	            return contentBlock;
	        }
	
	        var lastIndex = STYLE_REG.lastIndex = 0;
	        var result;
	        while ((result = STYLE_REG.exec(text)) != null)  {
	            var matchedIndex = result.index;
	            if (matchedIndex > lastIndex) {
	                pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
	            }
	            pushTokens(contentBlock, result[2], result[1]);
	            lastIndex = STYLE_REG.lastIndex;
	        }
	
	        if (lastIndex < text.length) {
	            pushTokens(contentBlock, text.substring(lastIndex, text.length));
	        }
	
	        var lines = contentBlock.lines;
	        var contentHeight = 0;
	        var contentWidth = 0;
	        // For `textWidth: 100%`
	        var pendingList = [];
	
	        var stlPadding = style.textPadding;
	
	        var truncate = style.truncate;
	        var truncateWidth = truncate && truncate.outerWidth;
	        var truncateHeight = truncate && truncate.outerHeight;
	        if (stlPadding) {
	            truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
	            truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
	        }
	
	        // Calculate layout info of tokens.
	        for (var i = 0; i < lines.length; i++) {
	            var line = lines[i];
	            var lineHeight = 0;
	            var lineWidth = 0;
	
	            for (var j = 0; j < line.tokens.length; j++) {
	                var token = line.tokens[j];
	                var tokenStyle = token.styleName && style.rich[token.styleName] || {};
	                // textPadding should not inherit from style.
	                var textPadding = token.textPadding = tokenStyle.textPadding;
	
	                // textFont has been asigned to font by `normalizeStyle`.
	                var font = token.font = tokenStyle.font || style.font;
	
	                // textHeight can be used when textVerticalAlign is specified in token.
	                var tokenHeight = token.textHeight = retrieve2(
	                    // textHeight should not be inherited, consider it can be specified
	                    // as box height of the block.
	                    tokenStyle.textHeight, textContain.getLineHeight(font)
	                );
	                textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
	                token.height = tokenHeight;
	                token.lineHeight = retrieve3(
	                    tokenStyle.textLineHeight, style.textLineHeight, tokenHeight
	                );
	
	                token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
	                token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';
	
	                if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
	                    return {lines: [], width: 0, height: 0};
	                }
	
	                token.textWidth = textContain.getWidth(token.text, font);
	                var tokenWidth = tokenStyle.textWidth;
	                var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto';
	
	                // Percent width, can be `100%`, can be used in drawing separate
	                // line when box width is needed to be auto.
	                if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {
	                    token.percentWidth = tokenWidth;
	                    pendingList.push(token);
	                    tokenWidth = 0;
	                    // Do not truncate in this case, because there is no user case
	                    // and it is too complicated.
	                }
	                else {
	                    if (tokenWidthNotSpecified) {
	                        tokenWidth = token.textWidth;
	
	                        // FIXME: If image is not loaded and textWidth is not specified, calling
	                        // `getBoundingRect()` will not get correct result.
	                        var textBackgroundColor = tokenStyle.textBackgroundColor;
	                        var bgImg = textBackgroundColor && textBackgroundColor.image;
	
	                        // Use cases:
	                        // (1) If image is not loaded, it will be loaded at render phase and call
	                        // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded
	                        // image, and then the right size will be calculated here at the next tick.
	                        // See `graphic/helper/text.js`.
	                        // (2) If image loaded, and `textBackgroundColor.image` is image src string,
	                        // use `imageHelper.findExistImage` to find cached image.
	                        // `imageHelper.findExistImage` will always be called here before
	                        // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`
	                        // which ensures that image will not be rendered before correct size calcualted.
	                        if (bgImg) {
	                            bgImg = imageHelper.findExistImage(bgImg);
	                            if (imageHelper.isImageReady(bgImg)) {
	                                tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
	                            }
	                        }
	                    }
	
	                    var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
	                    tokenWidth += paddingW;
	
	                    var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;
	
	                    if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
	                        if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
	                            token.text = '';
	                            token.textWidth = tokenWidth = 0;
	                        }
	                        else {
	                            token.text = truncateText(
	                                token.text, remianTruncWidth - paddingW, font, truncate.ellipsis,
	                                {minChar: truncate.minChar}
	                            );
	                            token.textWidth = textContain.getWidth(token.text, font);
	                            tokenWidth = token.textWidth + paddingW;
	                        }
	                    }
	                }
	
	                lineWidth += (token.width = tokenWidth);
	                tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
	            }
	
	            line.width = lineWidth;
	            line.lineHeight = lineHeight;
	            contentHeight += lineHeight;
	            contentWidth = Math.max(contentWidth, lineWidth);
	        }
	
	        contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);
	        contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);
	
	        if (stlPadding) {
	            contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
	            contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
	        }
	
	        for (var i = 0; i < pendingList.length; i++) {
	            var token = pendingList[i];
	            var percentWidth = token.percentWidth;
	            // Should not base on outerWidth, because token can not be placed out of padding.
	            token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
	        }
	
	        return contentBlock;
	    }
	
	    function pushTokens(block, str, styleName) {
	        var isEmptyStr = str === '';
	        var strs = str.split('\n');
	        var lines = block.lines;
	
	        for (var i = 0; i < strs.length; i++) {
	            var text = strs[i];
	            var token = {
	                styleName: styleName,
	                text: text,
	                isLineHolder: !text && !isEmptyStr
	            };
	
	            // The first token should be appended to the last line.
	            if (!i) {
	                var tokens = (lines[lines.length - 1] || (lines[0] = {tokens: []})).tokens;
	
	                // Consider cases:
	                // (1) ''.split('\n') => ['', '\n', ''], the '' at the first item
	                // (which is a placeholder) should be replaced by new token.
	                // (2) A image backage, where token likes {a|}.
	                // (3) A redundant '' will affect textAlign in line.
	                // (4) tokens with the same tplName should not be merged, because
	                // they should be displayed in different box (with border and padding).
	                var tokensLen = tokens.length;
	                (tokensLen === 1 && tokens[0].isLineHolder)
	                    ? (tokens[0] = token)
	                    // Consider text is '', only insert when it is the "lineHolder" or
	                    // "emptyStr". Otherwise a redundant '' will affect textAlign in line.
	                    : ((text || !tokensLen || isEmptyStr) && tokens.push(token));
	            }
	            // Other tokens always start a new line.
	            else {
	                // If there is '', insert it as a placeholder.
	                lines.push({tokens: [token]});
	            }
	        }
	    }
	
	    function makeFont(style) {
	        // FIXME in node-canvas fontWeight is before fontStyle
	        // Use `fontSize` `fontFamily` to check whether font properties are defined.
	        return (style.fontSize || style.fontFamily) && [
	            style.fontStyle,
	            style.fontWeight,
	            (style.fontSize || 12) + 'px',
	            // If font properties are defined, `fontFamily` should not be ignored.
	            style.fontFamily || 'sans-serif'
	        ].join(' ') || style.textFont || style.font;
	    }
	
	    var textContain = {
	
	        getWidth: getTextWidth,
	
	        getBoundingRect: getTextRect,
	
	        adjustTextPositionOnRect: adjustTextPositionOnRect,
	
	        truncateText: truncateText,
	
	        measureText: measureText,
	
	        getLineHeight: getLineHeight,
	
	        parsePlainText: parsePlainText,
	
	        parseRichText: parseRichText,
	
	        adjustTextX: adjustTextX,
	
	        adjustTextY: adjustTextY,
	
	        makeFont: makeFont,
	
	        DEFAULT_FONT: DEFAULT_FONT
	    };
	
	    module.exports = textContain;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module echarts/core/BoundingRect
	 */
	
	
	    var vec2 = __webpack_require__(15);
	    var matrix = __webpack_require__(14);
	
	    var v2ApplyTransform = vec2.applyTransform;
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    /**
	     * @alias module:echarts/core/BoundingRect
	     */
	    function BoundingRect(x, y, width, height) {
	
	        if (width < 0) {
	            x = x + width;
	            width = -width;
	        }
	        if (height < 0) {
	            y = y + height;
	            height = -height;
	        }
	
	        /**
	         * @type {number}
	         */
	        this.x = x;
	        /**
	         * @type {number}
	         */
	        this.y = y;
	        /**
	         * @type {number}
	         */
	        this.width = width;
	        /**
	         * @type {number}
	         */
	        this.height = height;
	    }
	
	    BoundingRect.prototype = {
	
	        constructor: BoundingRect,
	
	        /**
	         * @param {module:echarts/core/BoundingRect} other
	         */
	        union: function (other) {
	            var x = mathMin(other.x, this.x);
	            var y = mathMin(other.y, this.y);
	
	            this.width = mathMax(
	                    other.x + other.width,
	                    this.x + this.width
	                ) - x;
	            this.height = mathMax(
	                    other.y + other.height,
	                    this.y + this.height
	                ) - y;
	            this.x = x;
	            this.y = y;
	        },
	
	        /**
	         * @param {Array.<number>} m
	         * @methods
	         */
	        applyTransform: (function () {
	            var lt = [];
	            var rb = [];
	            var lb = [];
	            var rt = [];
	            return function (m) {
	                // In case usage like this
	                // el.getBoundingRect().applyTransform(el.transform)
	                // And element has no transform
	                if (!m) {
	                    return;
	                }
	                lt[0] = lb[0] = this.x;
	                lt[1] = rt[1] = this.y;
	                rb[0] = rt[0] = this.x + this.width;
	                rb[1] = lb[1] = this.y + this.height;
	
	                v2ApplyTransform(lt, lt, m);
	                v2ApplyTransform(rb, rb, m);
	                v2ApplyTransform(lb, lb, m);
	                v2ApplyTransform(rt, rt, m);
	
	                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
	                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
	                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
	                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
	                this.width = maxX - this.x;
	                this.height = maxY - this.y;
	            };
	        })(),
	
	        /**
	         * Calculate matrix of transforming from self to target rect
	         * @param  {module:zrender/core/BoundingRect} b
	         * @return {Array.<number>}
	         */
	        calculateTransform: function (b) {
	            var a = this;
	            var sx = b.width / a.width;
	            var sy = b.height / a.height;
	
	            var m = matrix.create();
	
	            // 矩阵右乘
	            matrix.translate(m, m, [-a.x, -a.y]);
	            matrix.scale(m, m, [sx, sy]);
	            matrix.translate(m, m, [b.x, b.y]);
	
	            return m;
	        },
	
	        /**
	         * @param {(module:echarts/core/BoundingRect|Object)} b
	         * @return {boolean}
	         */
	        intersect: function (b) {
	            if (!b) {
	                return false;
	            }
	
	            if (!(b instanceof BoundingRect)) {
	                // Normalize negative width/height.
	                b = BoundingRect.create(b);
	            }
	
	            var a = this;
	            var ax0 = a.x;
	            var ax1 = a.x + a.width;
	            var ay0 = a.y;
	            var ay1 = a.y + a.height;
	
	            var bx0 = b.x;
	            var bx1 = b.x + b.width;
	            var by0 = b.y;
	            var by1 = b.y + b.height;
	
	            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
	        },
	
	        contain: function (x, y) {
	            var rect = this;
	            return x >= rect.x
	                && x <= (rect.x + rect.width)
	                && y >= rect.y
	                && y <= (rect.y + rect.height);
	        },
	
	        /**
	         * @return {module:echarts/core/BoundingRect}
	         */
	        clone: function () {
	            return new BoundingRect(this.x, this.y, this.width, this.height);
	        },
	
	        /**
	         * Copy from another rect
	         */
	        copy: function (other) {
	            this.x = other.x;
	            this.y = other.y;
	            this.width = other.width;
	            this.height = other.height;
	        },
	
	        plain: function () {
	            return {
	                x: this.x,
	                y: this.y,
	                width: this.width,
	                height: this.height
	            };
	        }
	    };
	
	    /**
	     * @param {Object|module:zrender/core/BoundingRect} rect
	     * @param {number} rect.x
	     * @param {number} rect.y
	     * @param {number} rect.width
	     * @param {number} rect.height
	     * @return {module:zrender/core/BoundingRect}
	     */
	    BoundingRect.create = function (rect) {
	        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
	    };
	
	    module.exports = BoundingRect;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var LRU = __webpack_require__(21);
	    var globalImageCache = new LRU(50);
	
	    var helper = {};
	
	    /**
	     * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
	     * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
	     */
	    helper.findExistImage = function (newImageOrSrc) {
	        if (typeof newImageOrSrc === 'string') {
	            var cachedImgObj = globalImageCache.get(newImageOrSrc);
	            return cachedImgObj && cachedImgObj.image;
	        }
	        else {
	            return newImageOrSrc;
	        }
	    };
	
	    /**
	     * Caution: User should cache loaded images, but not just count on LRU.
	     * Consider if required images more than LRU size, will dead loop occur?
	     *
	     * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
	     * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.
	     * @param {module:zrender/Element} [hostEl] For calling `dirty`.
	     * @param {Function} [cb] params: (image, cbPayload)
	     * @param {Object} [cbPayload] Payload on cb calling.
	     * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
	     */
	    helper.createOrUpdateImage = function (newImageOrSrc, image, hostEl, cb, cbPayload) {
	        if (!newImageOrSrc) {
	            return image;
	        }
	        else if (typeof newImageOrSrc === 'string') {
	
	            // Image should not be loaded repeatly.
	            if ((image && image.__zrImageSrc === newImageOrSrc) || !hostEl) {
	                return image;
	            }
	
	            // Only when there is no existent image or existent image src
	            // is different, this method is responsible for load.
	            var cachedImgObj = globalImageCache.get(newImageOrSrc);
	
	            var pendingWrap = {hostEl: hostEl, cb: cb, cbPayload: cbPayload};
	
	            if (cachedImgObj) {
	                image = cachedImgObj.image;
	                !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
	            }
	            else {
	                !image && (image = new Image());
	                image.onload = imageOnLoad;
	
	                globalImageCache.put(
	                    newImageOrSrc,
	                    image.__cachedImgObj = {
	                        image: image,
	                        pending: [pendingWrap]
	                    }
	                );
	
	                image.src = image.__zrImageSrc = newImageOrSrc;
	            }
	
	            return image;
	        }
	        // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas
	        else {
	            return newImageOrSrc;
	        }
	    };
	
	    function imageOnLoad() {
	        var cachedImgObj = this.__cachedImgObj;
	        this.onload = this.__cachedImgObj = null;
	
	        for (var i = 0; i < cachedImgObj.pending.length; i++) {
	            var pendingWrap = cachedImgObj.pending[i];
	            var cb = pendingWrap.cb;
	            cb && cb(this, pendingWrap.cbPayload);
	            pendingWrap.hostEl.dirty();
	        }
	        cachedImgObj.pending.length = 0;
	    }
	
	    var isImageReady = helper.isImageReady = function (image) {
	        return image && image.width && image.height;
	    };
	
	    module.exports = helper;
	


/***/ }),
/* 29 */
/***/ (function(module, exports) {

	
	
	    module.exports = {
	        buildPath: function (ctx, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var width = shape.width;
	            var height = shape.height;
	            var r = shape.r;
	            var r1;
	            var r2;
	            var r3;
	            var r4;
	
	            // Convert width and height to positive for better borderRadius
	            if (width < 0) {
	                x = x + width;
	                width = -width;
	            }
	            if (height < 0) {
	                y = y + height;
	                height = -height;
	            }
	
	            if (typeof r === 'number') {
	                r1 = r2 = r3 = r4 = r;
	            }
	            else if (r instanceof Array) {
	                if (r.length === 1) {
	                    r1 = r2 = r3 = r4 = r[0];
	                }
	                else if (r.length === 2) {
	                    r1 = r3 = r[0];
	                    r2 = r4 = r[1];
	                }
	                else if (r.length === 3) {
	                    r1 = r[0];
	                    r2 = r4 = r[1];
	                    r3 = r[2];
	                }
	                else {
	                    r1 = r[0];
	                    r2 = r[1];
	                    r3 = r[2];
	                    r4 = r[3];
	                }
	            }
	            else {
	                r1 = r2 = r3 = r4 = 0;
	            }
	
	            var total;
	            if (r1 + r2 > width) {
	                total = r1 + r2;
	                r1 *= width / total;
	                r2 *= width / total;
	            }
	            if (r3 + r4 > width) {
	                total = r3 + r4;
	                r3 *= width / total;
	                r4 *= width / total;
	            }
	            if (r2 + r3 > height) {
	                total = r2 + r3;
	                r2 *= height / total;
	                r3 *= height / total;
	            }
	            if (r1 + r4 > height) {
	                total = r1 + r4;
	                r1 *= height / total;
	                r4 *= height / total;
	            }
	            ctx.moveTo(x + r1, y);
	            ctx.lineTo(x + width - r2, y);
	            r2 !== 0 && ctx.quadraticCurveTo(
	                x + width, y, x + width, y + r2
	            );
	            ctx.lineTo(x + width, y + height - r3);
	            r3 !== 0 && ctx.quadraticCurveTo(
	                x + width, y + height, x + width - r3, y + height
	            );
	            ctx.lineTo(x + r4, y + height);
	            r4 !== 0 && ctx.quadraticCurveTo(
	                x, y + height, x, y + height - r4
	            );
	            ctx.lineTo(x, y + r1);
	            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
	        }
	    };


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
	 * 可以用于 isInsidePath 判断以及获取boundingRect
	 *
	 * @module zrender/core/PathProxy
	 * @author Yi Shen (http://www.github.com/pissang)
	 */
	
	 // TODO getTotalLength, getPointAtLength
	
	
	    var curve = __webpack_require__(31);
	    var vec2 = __webpack_require__(15);
	    var bbox = __webpack_require__(32);
	    var BoundingRect = __webpack_require__(27);
	    var dpr = __webpack_require__(23).devicePixelRatio;
	
	    var CMD = {
	        M: 1,
	        L: 2,
	        C: 3,
	        Q: 4,
	        A: 5,
	        Z: 6,
	        // Rect
	        R: 7
	    };
	
	    // var CMD_MEM_SIZE = {
	    //     M: 3,
	    //     L: 3,
	    //     C: 7,
	    //     Q: 5,
	    //     A: 9,
	    //     R: 5,
	    //     Z: 1
	    // };
	
	    var min = [];
	    var max = [];
	    var min2 = [];
	    var max2 = [];
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    var mathCos = Math.cos;
	    var mathSin = Math.sin;
	    var mathSqrt = Math.sqrt;
	    var mathAbs = Math.abs;
	
	    var hasTypedArray = typeof Float32Array != 'undefined';
	
	    /**
	     * @alias module:zrender/core/PathProxy
	     * @constructor
	     */
	    var PathProxy = function (notSaveData) {
	
	        this._saveData = !(notSaveData || false);
	
	        if (this._saveData) {
	            /**
	             * Path data. Stored as flat array
	             * @type {Array.<Object>}
	             */
	            this.data = [];
	        }
	
	        this._ctx = null;
	    };
	
	    /**
	     * 快速计算Path包围盒（并不是最小包围盒）
	     * @return {Object}
	     */
	    PathProxy.prototype = {
	
	        constructor: PathProxy,
	
	        _xi: 0,
	        _yi: 0,
	
	        _x0: 0,
	        _y0: 0,
	        // Unit x, Unit y. Provide for avoiding drawing that too short line segment
	        _ux: 0,
	        _uy: 0,
	
	        _len: 0,
	
	        _lineDash: null,
	
	        _dashOffset: 0,
	
	        _dashIdx: 0,
	
	        _dashSum: 0,
	
	        /**
	         * @readOnly
	         */
	        setScale: function (sx, sy) {
	            this._ux = mathAbs(1 / dpr / sx) || 0;
	            this._uy = mathAbs(1 / dpr / sy) || 0;
	        },
	
	        getContext: function () {
	            return this._ctx;
	        },
	
	        /**
	         * @param  {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        beginPath: function (ctx) {
	
	            this._ctx = ctx;
	
	            ctx && ctx.beginPath();
	
	            ctx && (this.dpr = ctx.dpr);
	
	            // Reset
	            if (this._saveData) {
	                this._len = 0;
	            }
	
	            if (this._lineDash) {
	                this._lineDash = null;
	
	                this._dashOffset = 0;
	            }
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x
	         * @param  {number} y
	         * @return {module:zrender/core/PathProxy}
	         */
	        moveTo: function (x, y) {
	            this.addData(CMD.M, x, y);
	            this._ctx && this._ctx.moveTo(x, y);
	
	            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
	            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
	            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
	            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持
	            this._x0 = x;
	            this._y0 = y;
	
	            this._xi = x;
	            this._yi = y;
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x
	         * @param  {number} y
	         * @return {module:zrender/core/PathProxy}
	         */
	        lineTo: function (x, y) {
	            var exceedUnit = mathAbs(x - this._xi) > this._ux
	                || mathAbs(y - this._yi) > this._uy
	                // Force draw the first segment
	                || this._len < 5;
	
	            this.addData(CMD.L, x, y);
	
	            if (this._ctx && exceedUnit) {
	                this._needsDash() ? this._dashedLineTo(x, y)
	                    : this._ctx.lineTo(x, y);
	            }
	            if (exceedUnit) {
	                this._xi = x;
	                this._yi = y;
	            }
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x1
	         * @param  {number} y1
	         * @param  {number} x2
	         * @param  {number} y2
	         * @param  {number} x3
	         * @param  {number} y3
	         * @return {module:zrender/core/PathProxy}
	         */
	        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
	            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
	            if (this._ctx) {
	                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)
	                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
	            }
	            this._xi = x3;
	            this._yi = y3;
	            return this;
	        },
	
	        /**
	         * @param  {number} x1
	         * @param  {number} y1
	         * @param  {number} x2
	         * @param  {number} y2
	         * @return {module:zrender/core/PathProxy}
	         */
	        quadraticCurveTo: function (x1, y1, x2, y2) {
	            this.addData(CMD.Q, x1, y1, x2, y2);
	            if (this._ctx) {
	                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)
	                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
	            }
	            this._xi = x2;
	            this._yi = y2;
	            return this;
	        },
	
	        /**
	         * @param  {number} cx
	         * @param  {number} cy
	         * @param  {number} r
	         * @param  {number} startAngle
	         * @param  {number} endAngle
	         * @param  {boolean} anticlockwise
	         * @return {module:zrender/core/PathProxy}
	         */
	        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
	            this.addData(
	                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1
	            );
	            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
	
	            this._xi = mathCos(endAngle) * r + cx;
	            this._yi = mathSin(endAngle) * r + cx;
	            return this;
	        },
	
	        // TODO
	        arcTo: function (x1, y1, x2, y2, radius) {
	            if (this._ctx) {
	                this._ctx.arcTo(x1, y1, x2, y2, radius);
	            }
	            return this;
	        },
	
	        // TODO
	        rect: function (x, y, w, h) {
	            this._ctx && this._ctx.rect(x, y, w, h);
	            this.addData(CMD.R, x, y, w, h);
	            return this;
	        },
	
	        /**
	         * @return {module:zrender/core/PathProxy}
	         */
	        closePath: function () {
	            this.addData(CMD.Z);
	
	            var ctx = this._ctx;
	            var x0 = this._x0;
	            var y0 = this._y0;
	            if (ctx) {
	                this._needsDash() && this._dashedLineTo(x0, y0);
	                ctx.closePath();
	            }
	
	            this._xi = x0;
	            this._yi = y0;
	            return this;
	        },
	
	        /**
	         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
	         * stroke 同样
	         * @param {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        fill: function (ctx) {
	            ctx && ctx.fill();
	            this.toStatic();
	        },
	
	        /**
	         * @param {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        stroke: function (ctx) {
	            ctx && ctx.stroke();
	            this.toStatic();
	        },
	
	        /**
	         * 必须在其它绘制命令前调用
	         * Must be invoked before all other path drawing methods
	         * @return {module:zrender/core/PathProxy}
	         */
	        setLineDash: function (lineDash) {
	            if (lineDash instanceof Array) {
	                this._lineDash = lineDash;
	
	                this._dashIdx = 0;
	
	                var lineDashSum = 0;
	                for (var i = 0; i < lineDash.length; i++) {
	                    lineDashSum += lineDash[i];
	                }
	                this._dashSum = lineDashSum;
	            }
	            return this;
	        },
	
	        /**
	         * 必须在其它绘制命令前调用
	         * Must be invoked before all other path drawing methods
	         * @return {module:zrender/core/PathProxy}
	         */
	        setLineDashOffset: function (offset) {
	            this._dashOffset = offset;
	            return this;
	        },
	
	        /**
	         *
	         * @return {boolean}
	         */
	        len: function () {
	            return this._len;
	        },
	
	        /**
	         * 直接设置 Path 数据
	         */
	        setData: function (data) {
	
	            var len = data.length;
	
	            if (! (this.data && this.data.length == len) && hasTypedArray) {
	                this.data = new Float32Array(len);
	            }
	
	            for (var i = 0; i < len; i++) {
	                this.data[i] = data[i];
	            }
	
	            this._len = len;
	        },
	
	        /**
	         * 添加子路径
	         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
	         */
	        appendPath: function (path) {
	            if (!(path instanceof Array)) {
	                path = [path];
	            }
	            var len = path.length;
	            var appendSize = 0;
	            var offset = this._len;
	            for (var i = 0; i < len; i++) {
	                appendSize += path[i].len();
	            }
	            if (hasTypedArray && (this.data instanceof Float32Array)) {
	                this.data = new Float32Array(offset + appendSize);
	            }
	            for (var i = 0; i < len; i++) {
	                var appendPathData = path[i].data;
	                for (var k = 0; k < appendPathData.length; k++) {
	                    this.data[offset++] = appendPathData[k];
	                }
	            }
	            this._len = offset;
	        },
	
	        /**
	         * 填充 Path 数据。
	         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
	         */
	        addData: function (cmd) {
	            if (!this._saveData) {
	                return;
	            }
	
	            var data = this.data;
	            if (this._len + arguments.length > data.length) {
	                // 因为之前的数组已经转换成静态的 Float32Array
	                // 所以不够用时需要扩展一个新的动态数组
	                this._expandData();
	                data = this.data;
	            }
	            for (var i = 0; i < arguments.length; i++) {
	                data[this._len++] = arguments[i];
	            }
	
	            this._prevCmd = cmd;
	        },
	
	        _expandData: function () {
	            // Only if data is Float32Array
	            if (!(this.data instanceof Array)) {
	                var newData = [];
	                for (var i = 0; i < this._len; i++) {
	                    newData[i] = this.data[i];
	                }
	                this.data = newData;
	            }
	        },
	
	        /**
	         * If needs js implemented dashed line
	         * @return {boolean}
	         * @private
	         */
	        _needsDash: function () {
	            return this._lineDash;
	        },
	
	        _dashedLineTo: function (x1, y1) {
	            var dashSum = this._dashSum;
	            var offset = this._dashOffset;
	            var lineDash = this._lineDash;
	            var ctx = this._ctx;
	
	            var x0 = this._xi;
	            var y0 = this._yi;
	            var dx = x1 - x0;
	            var dy = y1 - y0;
	            var dist = mathSqrt(dx * dx + dy * dy);
	            var x = x0;
	            var y = y0;
	            var dash;
	            var nDash = lineDash.length;
	            var idx;
	            dx /= dist;
	            dy /= dist;
	
	            if (offset < 0) {
	                // Convert to positive offset
	                offset = dashSum + offset;
	            }
	            offset %= dashSum;
	            x -= offset * dx;
	            y -= offset * dy;
	
	            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)
	            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {
	                idx = this._dashIdx;
	                dash = lineDash[idx];
	                x += dx * dash;
	                y += dy * dash;
	                this._dashIdx = (idx + 1) % nDash;
	                // Skip positive offset
	                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {
	                    continue;
	                }
	                ctx[idx % 2 ? 'moveTo' : 'lineTo'](
	                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),
	                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)
	                );
	            }
	            // Offset for next lineTo
	            dx = x - x1;
	            dy = y - y1;
	            this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	        },
	
	        // Not accurate dashed line to
	        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
	            var dashSum = this._dashSum;
	            var offset = this._dashOffset;
	            var lineDash = this._lineDash;
	            var ctx = this._ctx;
	
	            var x0 = this._xi;
	            var y0 = this._yi;
	            var t;
	            var dx;
	            var dy;
	            var cubicAt = curve.cubicAt;
	            var bezierLen = 0;
	            var idx = this._dashIdx;
	            var nDash = lineDash.length;
	
	            var x;
	            var y;
	
	            var tmpLen = 0;
	
	            if (offset < 0) {
	                // Convert to positive offset
	                offset = dashSum + offset;
	            }
	            offset %= dashSum;
	            // Bezier approx length
	            for (t = 0; t < 1; t += 0.1) {
	                dx = cubicAt(x0, x1, x2, x3, t + 0.1)
	                    - cubicAt(x0, x1, x2, x3, t);
	                dy = cubicAt(y0, y1, y2, y3, t + 0.1)
	                    - cubicAt(y0, y1, y2, y3, t);
	                bezierLen += mathSqrt(dx * dx + dy * dy);
	            }
	
	            // Find idx after add offset
	            for (; idx < nDash; idx++) {
	                tmpLen += lineDash[idx];
	                if (tmpLen > offset) {
	                    break;
	                }
	            }
	            t = (tmpLen - offset) / bezierLen;
	
	            while (t <= 1) {
	
	                x = cubicAt(x0, x1, x2, x3, t);
	                y = cubicAt(y0, y1, y2, y3, t);
	
	                // Use line to approximate dashed bezier
	                // Bad result if dash is long
	                idx % 2 ? ctx.moveTo(x, y)
	                    : ctx.lineTo(x, y);
	
	                t += lineDash[idx] / bezierLen;
	
	                idx = (idx + 1) % nDash;
	            }
	
	            // Finish the last segment and calculate the new offset
	            (idx % 2 !== 0) && ctx.lineTo(x3, y3);
	            dx = x3 - x;
	            dy = y3 - y;
	            this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	        },
	
	        _dashedQuadraticTo: function (x1, y1, x2, y2) {
	            // Convert quadratic to cubic using degree elevation
	            var x3 = x2;
	            var y3 = y2;
	            x2 = (x2 + 2 * x1) / 3;
	            y2 = (y2 + 2 * y1) / 3;
	            x1 = (this._xi + 2 * x1) / 3;
	            y1 = (this._yi + 2 * y1) / 3;
	
	            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
	        },
	
	        /**
	         * 转成静态的 Float32Array 减少堆内存占用
	         * Convert dynamic array to static Float32Array
	         */
	        toStatic: function () {
	            var data = this.data;
	            if (data instanceof Array) {
	                data.length = this._len;
	                if (hasTypedArray) {
	                    this.data = new Float32Array(data);
	                }
	            }
	        },
	
	        /**
	         * @return {module:zrender/core/BoundingRect}
	         */
	        getBoundingRect: function () {
	            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
	            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
	
	            var data = this.data;
	            var xi = 0;
	            var yi = 0;
	            var x0 = 0;
	            var y0 = 0;
	
	            for (var i = 0; i < data.length;) {
	                var cmd = data[i++];
	
	                if (i == 1) {
	                    // 如果第一个命令是 L, C, Q
	                    // 则 previous point 同绘制命令的第一个 point
	                    //
	                    // 第一个命令为 Arc 的情况下会在后面特殊处理
	                    xi = data[i];
	                    yi = data[i + 1];
	
	                    x0 = xi;
	                    y0 = yi;
	                }
	
	                switch (cmd) {
	                    case CMD.M:
	                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	                        // 在 closePath 的时候使用
	                        x0 = data[i++];
	                        y0 = data[i++];
	                        xi = x0;
	                        yi = y0;
	                        min2[0] = x0;
	                        min2[1] = y0;
	                        max2[0] = x0;
	                        max2[1] = y0;
	                        break;
	                    case CMD.L:
	                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.C:
	                        bbox.fromCubic(
	                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            min2, max2
	                        );
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.Q:
	                        bbox.fromQuadratic(
	                            xi, yi, data[i++], data[i++], data[i], data[i + 1],
	                            min2, max2
	                        );
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.A:
	                        // TODO Arc 判断的开销比较大
	                        var cx = data[i++];
	                        var cy = data[i++];
	                        var rx = data[i++];
	                        var ry = data[i++];
	                        var startAngle = data[i++];
	                        var endAngle = data[i++] + startAngle;
	                        // TODO Arc 旋转
	                        var psi = data[i++];
	                        var anticlockwise = 1 - data[i++];
	
	                        if (i == 1) {
	                            // 直接使用 arc 命令
	                            // 第一个命令起点还未定义
	                            x0 = mathCos(startAngle) * rx + cx;
	                            y0 = mathSin(startAngle) * ry + cy;
	                        }
	
	                        bbox.fromArc(
	                            cx, cy, rx, ry, startAngle, endAngle,
	                            anticlockwise, min2, max2
	                        );
	
	                        xi = mathCos(endAngle) * rx + cx;
	                        yi = mathSin(endAngle) * ry + cy;
	                        break;
	                    case CMD.R:
	                        x0 = xi = data[i++];
	                        y0 = yi = data[i++];
	                        var width = data[i++];
	                        var height = data[i++];
	                        // Use fromLine
	                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
	                        break;
	                    case CMD.Z:
	                        xi = x0;
	                        yi = y0;
	                        break;
	                }
	
	                // Union
	                vec2.min(min, min, min2);
	                vec2.max(max, max, max2);
	            }
	
	            // No data
	            if (i === 0) {
	                min[0] = min[1] = max[0] = max[1] = 0;
	            }
	
	            return new BoundingRect(
	                min[0], min[1], max[0] - min[0], max[1] - min[1]
	            );
	        },
	
	        /**
	         * Rebuild path from current data
	         * Rebuild path will not consider javascript implemented line dash.
	         * @param {CanvasRenderingContext2D} ctx
	         */
	        rebuildPath: function (ctx) {
	            var d = this.data;
	            var x0, y0;
	            var xi, yi;
	            var x, y;
	            var ux = this._ux;
	            var uy = this._uy;
	            var len = this._len;
	            for (var i = 0; i < len;) {
	                var cmd = d[i++];
	
	                if (i == 1) {
	                    // 如果第一个命令是 L, C, Q
	                    // 则 previous point 同绘制命令的第一个 point
	                    //
	                    // 第一个命令为 Arc 的情况下会在后面特殊处理
	                    xi = d[i];
	                    yi = d[i + 1];
	
	                    x0 = xi;
	                    y0 = yi;
	                }
	                switch (cmd) {
	                    case CMD.M:
	                        x0 = xi = d[i++];
	                        y0 = yi = d[i++];
	                        ctx.moveTo(xi, yi);
	                        break;
	                    case CMD.L:
	                        x = d[i++];
	                        y = d[i++];
	                        // Not draw too small seg between
	                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
	                            ctx.lineTo(x, y);
	                            xi = x;
	                            yi = y;
	                        }
	                        break;
	                    case CMD.C:
	                        ctx.bezierCurveTo(
	                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]
	                        );
	                        xi = d[i - 2];
	                        yi = d[i - 1];
	                        break;
	                    case CMD.Q:
	                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
	                        xi = d[i - 2];
	                        yi = d[i - 1];
	                        break;
	                    case CMD.A:
	                        var cx = d[i++];
	                        var cy = d[i++];
	                        var rx = d[i++];
	                        var ry = d[i++];
	                        var theta = d[i++];
	                        var dTheta = d[i++];
	                        var psi = d[i++];
	                        var fs = d[i++];
	                        var r = (rx > ry) ? rx : ry;
	                        var scaleX = (rx > ry) ? 1 : rx / ry;
	                        var scaleY = (rx > ry) ? ry / rx : 1;
	                        var isEllipse = Math.abs(rx - ry) > 1e-3;
	                        var endAngle = theta + dTheta;
	                        if (isEllipse) {
	                            ctx.translate(cx, cy);
	                            ctx.rotate(psi);
	                            ctx.scale(scaleX, scaleY);
	                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
	                            ctx.scale(1 / scaleX, 1 / scaleY);
	                            ctx.rotate(-psi);
	                            ctx.translate(-cx, -cy);
	                        }
	                        else {
	                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
	                        }
	
	                        if (i == 1) {
	                            // 直接使用 arc 命令
	                            // 第一个命令起点还未定义
	                            x0 = mathCos(theta) * rx + cx;
	                            y0 = mathSin(theta) * ry + cy;
	                        }
	                        xi = mathCos(endAngle) * rx + cx;
	                        yi = mathSin(endAngle) * ry + cy;
	                        break;
	                    case CMD.R:
	                        x0 = xi = d[i];
	                        y0 = yi = d[i + 1];
	                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);
	                        break;
	                    case CMD.Z:
	                        ctx.closePath();
	                        xi = x0;
	                        yi = y0;
	                }
	            }
	        }
	    };
	
	    PathProxy.CMD = CMD;
	
	    module.exports = PathProxy;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 曲线辅助模块
	 * @module zrender/core/curve
	 * @author pissang(https://www.github.com/pissang)
	 */
	
	
	    var vec2 = __webpack_require__(15);
	    var v2Create = vec2.create;
	    var v2DistSquare = vec2.distSquare;
	    var mathPow = Math.pow;
	    var mathSqrt = Math.sqrt;
	
	    var EPSILON = 1e-8;
	    var EPSILON_NUMERIC = 1e-4;
	
	    var THREE_SQRT = mathSqrt(3);
	    var ONE_THIRD = 1 / 3;
	
	    // 临时变量
	    var _v0 = v2Create();
	    var _v1 = v2Create();
	    var _v2 = v2Create();
	    // var _v3 = vec2.create();
	
	    function isAroundZero(val) {
	        return val > -EPSILON && val < EPSILON;
	    }
	    function isNotAroundZero(val) {
	        return val > EPSILON || val < -EPSILON;
	    }
	    /**
	     * 计算三次贝塞尔值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @return {number}
	     */
	    function cubicAt(p0, p1, p2, p3, t) {
	        var onet = 1 - t;
	        return onet * onet * (onet * p0 + 3 * t * p1)
	             + t * t * (t * p3 + 3 * onet * p2);
	    }
	
	    /**
	     * 计算三次贝塞尔导数值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @return {number}
	     */
	    function cubicDerivativeAt(p0, p1, p2, p3, t) {
	        var onet = 1 - t;
	        return 3 * (
	            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet
	            + (p3 - p2) * t * t
	        );
	    }
	
	    /**
	     * 计算三次贝塞尔方程根，使用盛金公式
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} val
	     * @param  {Array.<number>} roots
	     * @return {number} 有效根数目
	     */
	    function cubicRootAt(p0, p1, p2, p3, val, roots) {
	        // Evaluate roots of cubic functions
	        var a = p3 + 3 * (p1 - p2) - p0;
	        var b = 3 * (p2 - p1 * 2 + p0);
	        var c = 3 * (p1  - p0);
	        var d = p0 - val;
	
	        var A = b * b - 3 * a * c;
	        var B = b * c - 9 * a * d;
	        var C = c * c - 3 * b * d;
	
	        var n = 0;
	
	        if (isAroundZero(A) && isAroundZero(B)) {
	            if (isAroundZero(b)) {
	                roots[0] = 0;
	            }
	            else {
	                var t1 = -c / b;  //t1, t2, t3, b is not zero
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = B * B - 4 * A * C;
	
	            if (isAroundZero(disc)) {
	                var K = B / A;
	                var t1 = -b / a + K;  // t1, a is not zero
	                var t2 = -K / 2;  // t2, t3
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var Y1 = A * b + 1.5 * a * (-B + discSqrt);
	                var Y2 = A * b + 1.5 * a * (-B - discSqrt);
	                if (Y1 < 0) {
	                    Y1 = -mathPow(-Y1, ONE_THIRD);
	                }
	                else {
	                    Y1 = mathPow(Y1, ONE_THIRD);
	                }
	                if (Y2 < 0) {
	                    Y2 = -mathPow(-Y2, ONE_THIRD);
	                }
	                else {
	                    Y2 = mathPow(Y2, ONE_THIRD);
	                }
	                var t1 = (-b - (Y1 + Y2)) / (3 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	            else {
	                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
	                var theta = Math.acos(T) / 3;
	                var ASqrt = mathSqrt(A);
	                var tmp = Math.cos(theta);
	
	                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
	                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
	                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	                if (t3 >= 0 && t3 <= 1) {
	                    roots[n++] = t3;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 计算三次贝塞尔方程极限值的位置
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {Array.<number>} extrema
	     * @return {number} 有效数目
	     */
	    function cubicExtrema(p0, p1, p2, p3, extrema) {
	        var b = 6 * p2 - 12 * p1 + 6 * p0;
	        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
	        var c = 3 * p1 - 3 * p0;
	
	        var n = 0;
	        if (isAroundZero(a)) {
	            if (isNotAroundZero(b)) {
	                var t1 = -c / b;
	                if (t1 >= 0 && t1 <=1) {
	                    extrema[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = b * b - 4 * a * c;
	            if (isAroundZero(disc)) {
	                extrema[0] = -b / (2 * a);
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var t1 = (-b + discSqrt) / (2 * a);
	                var t2 = (-b - discSqrt) / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    extrema[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    extrema[n++] = t2;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 细分三次贝塞尔曲线
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @param  {Array.<number>} out
	     */
	    function cubicSubdivide(p0, p1, p2, p3, t, out) {
	        var p01 = (p1 - p0) * t + p0;
	        var p12 = (p2 - p1) * t + p1;
	        var p23 = (p3 - p2) * t + p2;
	
	        var p012 = (p12 - p01) * t + p01;
	        var p123 = (p23 - p12) * t + p12;
	
	        var p0123 = (p123 - p012) * t + p012;
	        // Seg0
	        out[0] = p0;
	        out[1] = p01;
	        out[2] = p012;
	        out[3] = p0123;
	        // Seg1
	        out[4] = p0123;
	        out[5] = p123;
	        out[6] = p23;
	        out[7] = p3;
	    }
	
	    /**
	     * 投射点到三次贝塞尔曲线上，返回投射距离。
	     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x3
	     * @param {number} y3
	     * @param {number} x
	     * @param {number} y
	     * @param {Array.<number>} [out] 投射点
	     * @return {number}
	     */
	    function cubicProjectPoint(
	        x0, y0, x1, y1, x2, y2, x3, y3,
	        x, y, out
	    ) {
	        // http://pomax.github.io/bezierinfo/#projections
	        var t;
	        var interval = 0.005;
	        var d = Infinity;
	        var prev;
	        var next;
	        var d1;
	        var d2;
	
	        _v0[0] = x;
	        _v0[1] = y;
	
	        // 先粗略估计一下可能的最小距离的 t 值
	        // PENDING
	        for (var _t = 0; _t < 1; _t += 0.05) {
	            _v1[0] = cubicAt(x0, x1, x2, x3, _t);
	            _v1[1] = cubicAt(y0, y1, y2, y3, _t);
	            d1 = v2DistSquare(_v0, _v1);
	            if (d1 < d) {
	                t = _t;
	                d = d1;
	            }
	        }
	        d = Infinity;
	
	        // At most 32 iteration
	        for (var i = 0; i < 32; i++) {
	            if (interval < EPSILON_NUMERIC) {
	                break;
	            }
	            prev = t - interval;
	            next = t + interval;
	            // t - interval
	            _v1[0] = cubicAt(x0, x1, x2, x3, prev);
	            _v1[1] = cubicAt(y0, y1, y2, y3, prev);
	
	            d1 = v2DistSquare(_v1, _v0);
	
	            if (prev >= 0 && d1 < d) {
	                t = prev;
	                d = d1;
	            }
	            else {
	                // t + interval
	                _v2[0] = cubicAt(x0, x1, x2, x3, next);
	                _v2[1] = cubicAt(y0, y1, y2, y3, next);
	                d2 = v2DistSquare(_v2, _v0);
	
	                if (next <= 1 && d2 < d) {
	                    t = next;
	                    d = d2;
	                }
	                else {
	                    interval *= 0.5;
	                }
	            }
	        }
	        // t
	        if (out) {
	            out[0] = cubicAt(x0, x1, x2, x3, t);
	            out[1] = cubicAt(y0, y1, y2, y3, t);
	        }
	        // console.log(interval, i);
	        return mathSqrt(d);
	    }
	
	    /**
	     * 计算二次方贝塞尔值
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @return {number}
	     */
	    function quadraticAt(p0, p1, p2, t) {
	        var onet = 1 - t;
	        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
	    }
	
	    /**
	     * 计算二次方贝塞尔导数值
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @return {number}
	     */
	    function quadraticDerivativeAt(p0, p1, p2, t) {
	        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
	    }
	
	    /**
	     * 计算二次方贝塞尔方程根
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @param  {Array.<number>} roots
	     * @return {number} 有效根数目
	     */
	    function quadraticRootAt(p0, p1, p2, val, roots) {
	        var a = p0 - 2 * p1 + p2;
	        var b = 2 * (p1 - p0);
	        var c = p0 - val;
	
	        var n = 0;
	        if (isAroundZero(a)) {
	            if (isNotAroundZero(b)) {
	                var t1 = -c / b;
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = b * b - 4 * a * c;
	            if (isAroundZero(disc)) {
	                var t1 = -b / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var t1 = (-b + discSqrt) / (2 * a);
	                var t2 = (-b - discSqrt) / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 计算二次贝塞尔方程极限值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @return {number}
	     */
	    function quadraticExtremum(p0, p1, p2) {
	        var divider = p0 + p2 - 2 * p1;
	        if (divider === 0) {
	            // p1 is center of p0 and p2
	            return 0.5;
	        }
	        else {
	            return (p0 - p1) / divider;
	        }
	    }
	
	    /**
	     * 细分二次贝塞尔曲线
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @param  {Array.<number>} out
	     */
	    function quadraticSubdivide(p0, p1, p2, t, out) {
	        var p01 = (p1 - p0) * t + p0;
	        var p12 = (p2 - p1) * t + p1;
	        var p012 = (p12 - p01) * t + p01;
	
	        // Seg0
	        out[0] = p0;
	        out[1] = p01;
	        out[2] = p012;
	
	        // Seg1
	        out[3] = p012;
	        out[4] = p12;
	        out[5] = p2;
	    }
	
	    /**
	     * 投射点到二次贝塞尔曲线上，返回投射距离。
	     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x
	     * @param {number} y
	     * @param {Array.<number>} out 投射点
	     * @return {number}
	     */
	    function quadraticProjectPoint(
	        x0, y0, x1, y1, x2, y2,
	        x, y, out
	    ) {
	        // http://pomax.github.io/bezierinfo/#projections
	        var t;
	        var interval = 0.005;
	        var d = Infinity;
	
	        _v0[0] = x;
	        _v0[1] = y;
	
	        // 先粗略估计一下可能的最小距离的 t 值
	        // PENDING
	        for (var _t = 0; _t < 1; _t += 0.05) {
	            _v1[0] = quadraticAt(x0, x1, x2, _t);
	            _v1[1] = quadraticAt(y0, y1, y2, _t);
	            var d1 = v2DistSquare(_v0, _v1);
	            if (d1 < d) {
	                t = _t;
	                d = d1;
	            }
	        }
	        d = Infinity;
	
	        // At most 32 iteration
	        for (var i = 0; i < 32; i++) {
	            if (interval < EPSILON_NUMERIC) {
	                break;
	            }
	            var prev = t - interval;
	            var next = t + interval;
	            // t - interval
	            _v1[0] = quadraticAt(x0, x1, x2, prev);
	            _v1[1] = quadraticAt(y0, y1, y2, prev);
	
	            var d1 = v2DistSquare(_v1, _v0);
	
	            if (prev >= 0 && d1 < d) {
	                t = prev;
	                d = d1;
	            }
	            else {
	                // t + interval
	                _v2[0] = quadraticAt(x0, x1, x2, next);
	                _v2[1] = quadraticAt(y0, y1, y2, next);
	                var d2 = v2DistSquare(_v2, _v0);
	                if (next <= 1 && d2 < d) {
	                    t = next;
	                    d = d2;
	                }
	                else {
	                    interval *= 0.5;
	                }
	            }
	        }
	        // t
	        if (out) {
	            out[0] = quadraticAt(x0, x1, x2, t);
	            out[1] = quadraticAt(y0, y1, y2, t);
	        }
	        // console.log(interval, i);
	        return mathSqrt(d);
	    }
	
	    module.exports = {
	
	        cubicAt: cubicAt,
	
	        cubicDerivativeAt: cubicDerivativeAt,
	
	        cubicRootAt: cubicRootAt,
	
	        cubicExtrema: cubicExtrema,
	
	        cubicSubdivide: cubicSubdivide,
	
	        cubicProjectPoint: cubicProjectPoint,
	
	        quadraticAt: quadraticAt,
	
	        quadraticDerivativeAt: quadraticDerivativeAt,
	
	        quadraticRootAt: quadraticRootAt,
	
	        quadraticExtremum: quadraticExtremum,
	
	        quadraticSubdivide: quadraticSubdivide,
	
	        quadraticProjectPoint: quadraticProjectPoint
	    };


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @author Yi Shen(https://github.com/pissang)
	 */
	
	
	    var vec2 = __webpack_require__(15);
	    var curve = __webpack_require__(31);
	
	    var bbox = {};
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    var mathSin = Math.sin;
	    var mathCos = Math.cos;
	
	    var start = vec2.create();
	    var end = vec2.create();
	    var extremity = vec2.create();
	
	    var PI2 = Math.PI * 2;
	    /**
	     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
	     * @module zrender/core/bbox
	     * @param {Array<Object>} points 顶点数组
	     * @param {number} min
	     * @param {number} max
	     */
	    bbox.fromPoints = function(points, min, max) {
	        if (points.length === 0) {
	            return;
	        }
	        var p = points[0];
	        var left = p[0];
	        var right = p[0];
	        var top = p[1];
	        var bottom = p[1];
	        var i;
	
	        for (i = 1; i < points.length; i++) {
	            p = points[i];
	            left = mathMin(left, p[0]);
	            right = mathMax(right, p[0]);
	            top = mathMin(top, p[1]);
	            bottom = mathMax(bottom, p[1]);
	        }
	
	        min[0] = left;
	        min[1] = top;
	        max[0] = right;
	        max[1] = bottom;
	    };
	
	    /**
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromLine = function (x0, y0, x1, y1, min, max) {
	        min[0] = mathMin(x0, x1);
	        min[1] = mathMin(y0, y1);
	        max[0] = mathMax(x0, x1);
	        max[1] = mathMax(y0, y1);
	    };
	
	    var xDim = [];
	    var yDim = [];
	    /**
	     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x3
	     * @param {number} y3
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromCubic = function(
	        x0, y0, x1, y1, x2, y2, x3, y3, min, max
	    ) {
	        var cubicExtrema = curve.cubicExtrema;
	        var cubicAt = curve.cubicAt;
	        var i;
	        var n = cubicExtrema(x0, x1, x2, x3, xDim);
	        min[0] = Infinity;
	        min[1] = Infinity;
	        max[0] = -Infinity;
	        max[1] = -Infinity;
	
	        for (i = 0; i < n; i++) {
	            var x = cubicAt(x0, x1, x2, x3, xDim[i]);
	            min[0] = mathMin(x, min[0]);
	            max[0] = mathMax(x, max[0]);
	        }
	        n = cubicExtrema(y0, y1, y2, y3, yDim);
	        for (i = 0; i < n; i++) {
	            var y = cubicAt(y0, y1, y2, y3, yDim[i]);
	            min[1] = mathMin(y, min[1]);
	            max[1] = mathMax(y, max[1]);
	        }
	
	        min[0] = mathMin(x0, min[0]);
	        max[0] = mathMax(x0, max[0]);
	        min[0] = mathMin(x3, min[0]);
	        max[0] = mathMax(x3, max[0]);
	
	        min[1] = mathMin(y0, min[1]);
	        max[1] = mathMax(y0, max[1]);
	        min[1] = mathMin(y3, min[1]);
	        max[1] = mathMax(y3, max[1]);
	    };
	
	    /**
	     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {
	        var quadraticExtremum = curve.quadraticExtremum;
	        var quadraticAt = curve.quadraticAt;
	        // Find extremities, where derivative in x dim or y dim is zero
	        var tx =
	            mathMax(
	                mathMin(quadraticExtremum(x0, x1, x2), 1), 0
	            );
	        var ty =
	            mathMax(
	                mathMin(quadraticExtremum(y0, y1, y2), 1), 0
	            );
	
	        var x = quadraticAt(x0, x1, x2, tx);
	        var y = quadraticAt(y0, y1, y2, ty);
	
	        min[0] = mathMin(x0, x2, x);
	        min[1] = mathMin(y0, y2, y);
	        max[0] = mathMax(x0, x2, x);
	        max[1] = mathMax(y0, y2, y);
	    };
	
	    /**
	     * 从圆弧中计算出最小包围盒，写入`min`和`max`中
	     * @method
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x
	     * @param {number} y
	     * @param {number} rx
	     * @param {number} ry
	     * @param {number} startAngle
	     * @param {number} endAngle
	     * @param {number} anticlockwise
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromArc = function (
	        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max
	    ) {
	        var vec2Min = vec2.min;
	        var vec2Max = vec2.max;
	
	        var diff = Math.abs(startAngle - endAngle);
	
	
	        if (diff % PI2 < 1e-4 && diff > 1e-4) {
	            // Is a circle
	            min[0] = x - rx;
	            min[1] = y - ry;
	            max[0] = x + rx;
	            max[1] = y + ry;
	            return;
	        }
	
	        start[0] = mathCos(startAngle) * rx + x;
	        start[1] = mathSin(startAngle) * ry + y;
	
	        end[0] = mathCos(endAngle) * rx + x;
	        end[1] = mathSin(endAngle) * ry + y;
	
	        vec2Min(min, start, end);
	        vec2Max(max, start, end);
	
	        // Thresh to [0, Math.PI * 2]
	        startAngle = startAngle % (PI2);
	        if (startAngle < 0) {
	            startAngle = startAngle + PI2;
	        }
	        endAngle = endAngle % (PI2);
	        if (endAngle < 0) {
	            endAngle = endAngle + PI2;
	        }
	
	        if (startAngle > endAngle && !anticlockwise) {
	            endAngle += PI2;
	        }
	        else if (startAngle < endAngle && anticlockwise) {
	            startAngle += PI2;
	        }
	        if (anticlockwise) {
	            var tmp = endAngle;
	            endAngle = startAngle;
	            startAngle = tmp;
	        }
	
	        // var number = 0;
	        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
	        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
	            if (angle > startAngle) {
	                extremity[0] = mathCos(angle) * rx + x;
	                extremity[1] = mathSin(angle) * ry + y;
	
	                vec2Min(min, extremity, min);
	                vec2Max(max, extremity, max);
	            }
	        }
	    };
	
	    module.exports = bbox;
	


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var CMD = __webpack_require__(30).CMD;
	    var line = __webpack_require__(34);
	    var cubic = __webpack_require__(35);
	    var quadratic = __webpack_require__(36);
	    var arc = __webpack_require__(37);
	    var normalizeRadian = __webpack_require__(38).normalizeRadian;
	    var curve = __webpack_require__(31);
	
	    var windingLine = __webpack_require__(39);
	
	    var containStroke = line.containStroke;
	
	    var PI2 = Math.PI * 2;
	
	    var EPSILON = 1e-4;
	
	    function isAroundEqual(a, b) {
	        return Math.abs(a - b) < EPSILON;
	    }
	
	    // 临时数组
	    var roots = [-1, -1, -1];
	    var extrema = [-1, -1];
	
	    function swapExtrema() {
	        var tmp = extrema[0];
	        extrema[0] = extrema[1];
	        extrema[1] = tmp;
	    }
	
	    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
	        // Quick reject
	        if (
	            (y > y0 && y > y1 && y > y2 && y > y3)
	            || (y < y0 && y < y1 && y < y2 && y < y3)
	        ) {
	            return 0;
	        }
	        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
	        if (nRoots === 0) {
	            return 0;
	        }
	        else {
	            var w = 0;
	            var nExtrema = -1;
	            var y0_, y1_;
	            for (var i = 0; i < nRoots; i++) {
	                var t = roots[i];
	
	                // Avoid winding error when intersection point is the connect point of two line of polygon
	                var unit = (t === 0 || t === 1) ? 0.5 : 1;
	
	                var x_ = curve.cubicAt(x0, x1, x2, x3, t);
	                if (x_ < x) { // Quick reject
	                    continue;
	                }
	                if (nExtrema < 0) {
	                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
	                    if (extrema[1] < extrema[0] && nExtrema > 1) {
	                        swapExtrema();
	                    }
	                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
	                    if (nExtrema > 1) {
	                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
	                    }
	                }
	                if (nExtrema == 2) {
	                    // 分成三段单调函数
	                    if (t < extrema[0]) {
	                        w += y0_ < y0 ? unit : -unit;
	                    }
	                    else if (t < extrema[1]) {
	                        w += y1_ < y0_ ? unit : -unit;
	                    }
	                    else {
	                        w += y3 < y1_ ? unit : -unit;
	                    }
	                }
	                else {
	                    // 分成两段单调函数
	                    if (t < extrema[0]) {
	                        w += y0_ < y0 ? unit : -unit;
	                    }
	                    else {
	                        w += y3 < y0_ ? unit : -unit;
	                    }
	                }
	            }
	            return w;
	        }
	    }
	
	    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
	        // Quick reject
	        if (
	            (y > y0 && y > y1 && y > y2)
	            || (y < y0 && y < y1 && y < y2)
	        ) {
	            return 0;
	        }
	        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
	        if (nRoots === 0) {
	            return 0;
	        }
	        else {
	            var t = curve.quadraticExtremum(y0, y1, y2);
	            if (t >= 0 && t <= 1) {
	                var w = 0;
	                var y_ = curve.quadraticAt(y0, y1, y2, t);
	                for (var i = 0; i < nRoots; i++) {
	                    // Remove one endpoint.
	                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;
	
	                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
	                    if (x_ < x) {   // Quick reject
	                        continue;
	                    }
	                    if (roots[i] < t) {
	                        w += y_ < y0 ? unit : -unit;
	                    }
	                    else {
	                        w += y2 < y_ ? unit : -unit;
	                    }
	                }
	                return w;
	            }
	            else {
	                // Remove one endpoint.
	                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;
	
	                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
	                if (x_ < x) {   // Quick reject
	                    return 0;
	                }
	                return y2 < y0 ? unit : -unit;
	            }
	        }
	    }
	
	    // TODO
	    // Arc 旋转
	    function windingArc(
	        cx, cy, r, startAngle, endAngle, anticlockwise, x, y
	    ) {
	        y -= cy;
	        if (y > r || y < -r) {
	            return 0;
	        }
	        var tmp = Math.sqrt(r * r - y * y);
	        roots[0] = -tmp;
	        roots[1] = tmp;
	
	        var diff = Math.abs(startAngle - endAngle);
	        if (diff < 1e-4) {
	            return 0;
	        }
	        if (diff % PI2 < 1e-4) {
	            // Is a circle
	            startAngle = 0;
	            endAngle = PI2;
	            var dir = anticlockwise ? 1 : -1;
	            if (x >= roots[0] + cx && x <= roots[1] + cx) {
	                return dir;
	            } else {
	                return 0;
	            }
	        }
	
	        if (anticlockwise) {
	            var tmp = startAngle;
	            startAngle = normalizeRadian(endAngle);
	            endAngle = normalizeRadian(tmp);
	        }
	        else {
	            startAngle = normalizeRadian(startAngle);
	            endAngle = normalizeRadian(endAngle);
	        }
	        if (startAngle > endAngle) {
	            endAngle += PI2;
	        }
	
	        var w = 0;
	        for (var i = 0; i < 2; i++) {
	            var x_ = roots[i];
	            if (x_ + cx > x) {
	                var angle = Math.atan2(y, x_);
	                var dir = anticlockwise ? 1 : -1;
	                if (angle < 0) {
	                    angle = PI2 + angle;
	                }
	                if (
	                    (angle >= startAngle && angle <= endAngle)
	                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)
	                ) {
	                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
	                        dir = -dir;
	                    }
	                    w += dir;
	                }
	            }
	        }
	        return w;
	    }
	
	    function containPath(data, lineWidth, isStroke, x, y) {
	        var w = 0;
	        var xi = 0;
	        var yi = 0;
	        var x0 = 0;
	        var y0 = 0;
	
	        for (var i = 0; i < data.length;) {
	            var cmd = data[i++];
	            // Begin a new subpath
	            if (cmd === CMD.M && i > 1) {
	                // Close previous subpath
	                if (!isStroke) {
	                    w += windingLine(xi, yi, x0, y0, x, y);
	                }
	                // 如果被任何一个 subpath 包含
	                // if (w !== 0) {
	                //     return true;
	                // }
	            }
	
	            if (i == 1) {
	                // 如果第一个命令是 L, C, Q
	                // 则 previous point 同绘制命令的第一个 point
	                //
	                // 第一个命令为 Arc 的情况下会在后面特殊处理
	                xi = data[i];
	                yi = data[i + 1];
	
	                x0 = xi;
	                y0 = yi;
	            }
	
	            switch (cmd) {
	                case CMD.M:
	                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	                    // 在 closePath 的时候使用
	                    x0 = data[i++];
	                    y0 = data[i++];
	                    xi = x0;
	                    yi = y0;
	                    break;
	                case CMD.L:
	                    if (isStroke) {
	                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
	                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.C:
	                    if (isStroke) {
	                        if (cubic.containStroke(xi, yi,
	                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingCubic(
	                            xi, yi,
	                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            x, y
	                        ) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.Q:
	                    if (isStroke) {
	                        if (quadratic.containStroke(xi, yi,
	                            data[i++], data[i++], data[i], data[i + 1],
	                            lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingQuadratic(
	                            xi, yi,
	                            data[i++], data[i++], data[i], data[i + 1],
	                            x, y
	                        ) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.A:
	                    // TODO Arc 判断的开销比较大
	                    var cx = data[i++];
	                    var cy = data[i++];
	                    var rx = data[i++];
	                    var ry = data[i++];
	                    var theta = data[i++];
	                    var dTheta = data[i++];
	                    // TODO Arc 旋转
	                    var psi = data[i++];
	                    var anticlockwise = 1 - data[i++];
	                    var x1 = Math.cos(theta) * rx + cx;
	                    var y1 = Math.sin(theta) * ry + cy;
	                    // 不是直接使用 arc 命令
	                    if (i > 1) {
	                        w += windingLine(xi, yi, x1, y1, x, y);
	                    }
	                    else {
	                        // 第一个命令起点还未定义
	                        x0 = x1;
	                        y0 = y1;
	                    }
	                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
	                    var _x = (x - cx) * ry / rx + cx;
	                    if (isStroke) {
	                        if (arc.containStroke(
	                            cx, cy, ry, theta, theta + dTheta, anticlockwise,
	                            lineWidth, _x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingArc(
	                            cx, cy, ry, theta, theta + dTheta, anticlockwise,
	                            _x, y
	                        );
	                    }
	                    xi = Math.cos(theta + dTheta) * rx + cx;
	                    yi = Math.sin(theta + dTheta) * ry + cy;
	                    break;
	                case CMD.R:
	                    x0 = xi = data[i++];
	                    y0 = yi = data[i++];
	                    var width = data[i++];
	                    var height = data[i++];
	                    var x1 = x0 + width;
	                    var y1 = y0 + height;
	                    if (isStroke) {
	                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)
	                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)
	                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)
	                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)
	                        ) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // FIXME Clockwise ?
	                        w += windingLine(x1, y0, x1, y1, x, y);
	                        w += windingLine(x0, y1, x0, y0, x, y);
	                    }
	                    break;
	                case CMD.Z:
	                    if (isStroke) {
	                        if (containStroke(
	                            xi, yi, x0, y0, lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // Close a subpath
	                        w += windingLine(xi, yi, x0, y0, x, y);
	                        // 如果被任何一个 subpath 包含
	                        // FIXME subpaths may overlap
	                        // if (w !== 0) {
	                        //     return true;
	                        // }
	                    }
	                    xi = x0;
	                    yi = y0;
	                    break;
	            }
	        }
	        if (!isStroke && !isAroundEqual(yi, y0)) {
	            w += windingLine(xi, yi, x0, y0, x, y) || 0;
	        }
	        return w !== 0;
	    }
	
	    module.exports = {
	        contain: function (pathData, x, y) {
	            return containPath(pathData, 0, false, x, y);
	        },
	
	        containStroke: function (pathData, lineWidth, x, y) {
	            return containPath(pathData, lineWidth, true, x, y);
	        }
	    };


/***/ }),
/* 34 */
/***/ (function(module, exports) {

	
	    module.exports = {
	        /**
	         * 线段包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            var _a = 0;
	            var _b = x0;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l)
	                || (y < y0 - _l && y < y1 - _l)
	                || (x > x0 + _l && x > x1 + _l)
	                || (x < x0 - _l && x < x1 - _l)
	            ) {
	                return false;
	            }
	
	            if (x0 !== x1) {
	                _a = (y0 - y1) / (x0 - x1);
	                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;
	            }
	            else {
	                return Math.abs(x - x0) <= _l / 2;
	            }
	            var tmp = _a * x - y + _b;
	            var _s = tmp * tmp / (_a * _a + 1);
	            return _s <= _l / 2 * _l / 2;
	        }
	    };


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var curve = __webpack_require__(31);
	
	    module.exports = {
	        /**
	         * 三次贝塞尔曲线描边包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  x2
	         * @param  {number}  y2
	         * @param  {number}  x3
	         * @param  {number}  y3
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)
	                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)
	                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)
	                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)
	            ) {
	                return false;
	            }
	            var d = curve.cubicProjectPoint(
	                x0, y0, x1, y1, x2, y2, x3, y3,
	                x, y, null
	            );
	            return d <= _l / 2;
	        }
	    };


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var curve = __webpack_require__(31);
	
	    module.exports = {
	        /**
	         * 二次贝塞尔曲线描边包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  x2
	         * @param  {number}  y2
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l && y > y2 + _l)
	                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)
	                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)
	                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)
	            ) {
	                return false;
	            }
	            var d = curve.quadraticProjectPoint(
	                x0, y0, x1, y1, x2, y2,
	                x, y, null
	            );
	            return d <= _l / 2;
	        }
	    };


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var normalizeRadian = __webpack_require__(38).normalizeRadian;
	    var PI2 = Math.PI * 2;
	
	    module.exports = {
	        /**
	         * 圆弧描边包含判断
	         * @param  {number}  cx
	         * @param  {number}  cy
	         * @param  {number}  r
	         * @param  {number}  startAngle
	         * @param  {number}  endAngle
	         * @param  {boolean}  anticlockwise
	         * @param  {number} lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {Boolean}
	         */
	        containStroke: function (
	            cx, cy, r, startAngle, endAngle, anticlockwise,
	            lineWidth, x, y
	        ) {
	
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	
	            x -= cx;
	            y -= cy;
	            var d = Math.sqrt(x * x + y * y);
	
	            if ((d - _l > r) || (d + _l < r)) {
	                return false;
	            }
	            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
	                // Is a circle
	                return true;
	            }
	            if (anticlockwise) {
	                var tmp = startAngle;
	                startAngle = normalizeRadian(endAngle);
	                endAngle = normalizeRadian(tmp);
	            } else {
	                startAngle = normalizeRadian(startAngle);
	                endAngle = normalizeRadian(endAngle);
	            }
	            if (startAngle > endAngle) {
	                endAngle += PI2;
	            }
	
	            var angle = Math.atan2(y, x);
	            if (angle < 0) {
	                angle += PI2;
	            }
	            return (angle >= startAngle && angle <= endAngle)
	                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);
	        }
	    };


/***/ }),
/* 38 */
/***/ (function(module, exports) {

	
	
	    var PI2 = Math.PI * 2;
	    module.exports = {
	        normalizeRadian: function(angle) {
	            angle %= PI2;
	            if (angle < 0) {
	                angle += PI2;
	            }
	            return angle;
	        }
	    };


/***/ }),
/* 39 */
/***/ (function(module, exports) {

	
	    module.exports = function windingLine(x0, y0, x1, y1, x, y) {
	        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
	            return 0;
	        }
	        // Ignore horizontal line
	        if (y1 === y0) {
	            return 0;
	        }
	        var dir = y1 < y0 ? 1 : -1;
	        var t = (y - y0) / (y1 - y0);
	
	        // Avoid winding error when intersection point is the connect point of two line of polygon
	        if (t === 1 || t === 0) {
	            dir = y1 < y0 ? 0.5 : -0.5;
	        }
	
	        var x_ = t * (x1 - x0) + x0;
	
	        return x_ > x ? dir : 0;
	    };


/***/ }),
/* 40 */
/***/ (function(module, exports) {

	
	
	    var Pattern = function (image, repeat) {
	        // Should do nothing more in this constructor. Because gradient can be
	        // declard by `color: {image: ...}`, where this constructor will not be called.
	
	        this.image = image;
	        this.repeat = repeat;
	
	        // Can be cloned
	        this.type = 'pattern';
	    };
	
	    Pattern.prototype.getCanvasPattern = function (ctx) {
	        return ctx.createPattern(this.image, this.repeat || 'repeat');
	    };
	
	    module.exports = Pattern;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var CMD = __webpack_require__(30).CMD;
	    var vec2 = __webpack_require__(15);
	    var v2ApplyTransform = vec2.applyTransform;
	
	    var points = [[], [], []];
	    var mathSqrt = Math.sqrt;
	    var mathAtan2 = Math.atan2;
	    function transformPath(path, m) {
	        var data = path.data;
	        var cmd;
	        var nPoint;
	        var i;
	        var j;
	        var k;
	        var p;
	
	        var M = CMD.M;
	        var C = CMD.C;
	        var L = CMD.L;
	        var R = CMD.R;
	        var A = CMD.A;
	        var Q = CMD.Q;
	
	        for (i = 0, j = 0; i < data.length;) {
	            cmd = data[i++];
	            j = i;
	            nPoint = 0;
	
	            switch (cmd) {
	                case M:
	                    nPoint = 1;
	                    break;
	                case L:
	                    nPoint = 1;
	                    break;
	                case C:
	                    nPoint = 3;
	                    break;
	                case Q:
	                    nPoint = 2;
	                    break;
	                case A:
	                    var x = m[4];
	                    var y = m[5];
	                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
	                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
	                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);
	                    // cx
	                    data[i] *= sx;
	                    data[i++] += x;
	                    // cy
	                    data[i] *= sy;
	                    data[i++] += y;
	                    // Scale rx and ry
	                    // FIXME Assume psi is 0 here
	                    data[i++] *= sx;
	                    data[i++] *= sy;
	
	                    // Start angle
	                    data[i++] += angle;
	                    // end angle
	                    data[i++] += angle;
	                    // FIXME psi
	                    i += 2;
	                    j = i;
	                    break;
	                case R:
	                    // x0, y0
	                    p[0] = data[i++];
	                    p[1] = data[i++];
	                    v2ApplyTransform(p, p, m);
	                    data[j++] = p[0];
	                    data[j++] = p[1];
	                    // x1, y1
	                    p[0] += data[i++];
	                    p[1] += data[i++];
	                    v2ApplyTransform(p, p, m);
	                    data[j++] = p[0];
	                    data[j++] = p[1];
	            }
	
	            for (k = 0; k < nPoint; k++) {
	                var p = points[k];
	                p[0] = data[i++];
	                p[1] = data[i++];
	
	                v2ApplyTransform(p, p, m);
	                // Write back
	                data[j++] = p[0];
	                data[j++] = p[1];
	            }
	        }
	    }
	
	    module.exports = transformPath;


/***/ }),
/* 42 */
/***/ (function(module, exports) {

	
	
	    /**
	     * @param {Array.<Object>} colorStops
	     */
	    var Gradient = function (colorStops) {
	
	        this.colorStops = colorStops || [];
	
	    };
	
	    Gradient.prototype = {
	
	        constructor: Gradient,
	
	        addColorStop: function (offset, color) {
	            this.colorStops.push({
	
	                offset: offset,
	
	                color: color
	            });
	        }
	
	    };
	
	    module.exports = Gradient;


/***/ }),
/* 43 */
/***/ (function(module, exports) {

	// TODO Draggable for group
	// FIXME Draggable on element which has parent rotation or scale
	
	    function Draggable() {
	
	        this.on('mousedown', this._dragStart, this);
	        this.on('mousemove', this._drag, this);
	        this.on('mouseup', this._dragEnd, this);
	        this.on('globalout', this._dragEnd, this);
	        // this._dropTarget = null;
	        // this._draggingTarget = null;
	
	        // this._x = 0;
	        // this._y = 0;
	    }
	
	    Draggable.prototype = {
	
	        constructor: Draggable,
	
	        _dragStart: function (e) {
	            var draggingTarget = e.target;
	            if (draggingTarget && draggingTarget.draggable) {
	                this._draggingTarget = draggingTarget;
	                draggingTarget.dragging = true;
	                this._x = e.offsetX;
	                this._y = e.offsetY;
	
	                this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);
	            }
	        },
	
	        _drag: function (e) {
	            var draggingTarget = this._draggingTarget;
	            if (draggingTarget) {
	
	                var x = e.offsetX;
	                var y = e.offsetY;
	
	                var dx = x - this._x;
	                var dy = y - this._y;
	                this._x = x;
	                this._y = y;
	
	                draggingTarget.drift(dx, dy, e);
	                this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);
	
	                var dropTarget = this.findHover(x, y, draggingTarget).target;
	                var lastDropTarget = this._dropTarget;
	                this._dropTarget = dropTarget;
	
	                if (draggingTarget !== dropTarget) {
	                    if (lastDropTarget && dropTarget !== lastDropTarget) {
	                        this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);
	                    }
	                    if (dropTarget && dropTarget !== lastDropTarget) {
	                        this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);
	                    }
	                }
	            }
	        },
	
	        _dragEnd: function (e) {
	            var draggingTarget = this._draggingTarget;
	
	            if (draggingTarget) {
	                draggingTarget.dragging = false;
	            }
	
	            this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);
	
	            if (this._dropTarget) {
	                this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);
	            }
	
	            this._draggingTarget = null;
	            this._dropTarget = null;
	        }
	
	    };
	
	    function param(target, e) {
	        return {target: target, topTarget: e && e.topTarget};
	    }
	
	    module.exports = Draggable;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
	 * @module zrender/graphic/Group
	 * @example
	 *     var Group = require('zrender/lib/container/Group');
	 *     var Circle = require('zrender/lib/graphic/shape/Circle');
	 *     var g = new Group();
	 *     g.position[0] = 100;
	 *     g.position[1] = 100;
	 *     g.add(new Circle({
	 *         style: {
	 *             x: 100,
	 *             y: 100,
	 *             r: 20,
	 *         }
	 *     }));
	 *     zr.add(g);
	 */
	
	
	    var zrUtil = __webpack_require__(5);
	    var Element = __webpack_require__(10);
	    var BoundingRect = __webpack_require__(27);
	
	    /**
	     * @alias module:zrender/graphic/Group
	     * @constructor
	     * @extends module:zrender/mixin/Transformable
	     * @extends module:zrender/mixin/Eventful
	     */
	    var Group = function (opts) {
	
	        opts = opts || {};
	
	        Element.call(this, opts);
	
	        for (var key in opts) {
	            if (opts.hasOwnProperty(key)) {
	                this[key] = opts[key];
	            }
	        }
	
	        this._children = [];
	
	        this.__storage = null;
	
	        this.__dirty = true;
	    };
	
	    Group.prototype = {
	
	        constructor: Group,
	
	        isGroup: true,
	
	        /**
	         * @type {string}
	         */
	        type: 'group',
	
	        /**
	         * 所有子孙元素是否响应鼠标事件
	         * @name module:/zrender/container/Group#silent
	         * @type {boolean}
	         * @default false
	         */
	        silent: false,
	
	        /**
	         * @return {Array.<module:zrender/Element>}
	         */
	        children: function () {
	            return this._children.slice();
	        },
	
	        /**
	         * 获取指定 index 的儿子节点
	         * @param  {number} idx
	         * @return {module:zrender/Element}
	         */
	        childAt: function (idx) {
	            return this._children[idx];
	        },
	
	        /**
	         * 获取指定名字的儿子节点
	         * @param  {string} name
	         * @return {module:zrender/Element}
	         */
	        childOfName: function (name) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                if (children[i].name === name) {
	                    return children[i];
	                }
	             }
	        },
	
	        /**
	         * @return {number}
	         */
	        childCount: function () {
	            return this._children.length;
	        },
	
	        /**
	         * 添加子节点到最后
	         * @param {module:zrender/Element} child
	         */
	        add: function (child) {
	            if (child && child !== this && child.parent !== this) {
	
	                this._children.push(child);
	
	                this._doAdd(child);
	            }
	
	            return this;
	        },
	
	        /**
	         * 添加子节点在 nextSibling 之前
	         * @param {module:zrender/Element} child
	         * @param {module:zrender/Element} nextSibling
	         */
	        addBefore: function (child, nextSibling) {
	            if (child && child !== this && child.parent !== this
	                && nextSibling && nextSibling.parent === this) {
	
	                var children = this._children;
	                var idx = children.indexOf(nextSibling);
	
	                if (idx >= 0) {
	                    children.splice(idx, 0, child);
	                    this._doAdd(child);
	                }
	            }
	
	            return this;
	        },
	
	        _doAdd: function (child) {
	            if (child.parent) {
	                child.parent.remove(child);
	            }
	
	            child.parent = this;
	
	            var storage = this.__storage;
	            var zr = this.__zr;
	            if (storage && storage !== child.__storage) {
	
	                storage.addToStorage(child);
	
	                if (child instanceof Group) {
	                    child.addChildrenToStorage(storage);
	                }
	            }
	
	            zr && zr.refresh();
	        },
	
	        /**
	         * 移除子节点
	         * @param {module:zrender/Element} child
	         */
	        remove: function (child) {
	            var zr = this.__zr;
	            var storage = this.__storage;
	            var children = this._children;
	
	            var idx = zrUtil.indexOf(children, child);
	            if (idx < 0) {
	                return this;
	            }
	            children.splice(idx, 1);
	
	            child.parent = null;
	
	            if (storage) {
	
	                storage.delFromStorage(child);
	
	                if (child instanceof Group) {
	                    child.delChildrenFromStorage(storage);
	                }
	            }
	
	            zr && zr.refresh();
	
	            return this;
	        },
	
	        /**
	         * 移除所有子节点
	         */
	        removeAll: function () {
	            var children = this._children;
	            var storage = this.__storage;
	            var child;
	            var i;
	            for (i = 0; i < children.length; i++) {
	                child = children[i];
	                if (storage) {
	                    storage.delFromStorage(child);
	                    if (child instanceof Group) {
	                        child.delChildrenFromStorage(storage);
	                    }
	                }
	                child.parent = null;
	            }
	            children.length = 0;
	
	            return this;
	        },
	
	        /**
	         * 遍历所有子节点
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        eachChild: function (cb, context) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                cb.call(context, child, i);
	            }
	            return this;
	        },
	
	        /**
	         * 深度优先遍历所有子孙节点
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                cb.call(context, child);
	
	                if (child.type === 'group') {
	                    child.traverse(cb, context);
	                }
	            }
	            return this;
	        },
	
	        addChildrenToStorage: function (storage) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                storage.addToStorage(child);
	                if (child instanceof Group) {
	                    child.addChildrenToStorage(storage);
	                }
	            }
	        },
	
	        delChildrenFromStorage: function (storage) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                storage.delFromStorage(child);
	                if (child instanceof Group) {
	                    child.delChildrenFromStorage(storage);
	                }
	            }
	        },
	
	        dirty: function () {
	            this.__dirty = true;
	            this.__zr && this.__zr.refresh();
	            return this;
	        },
	
	        /**
	         * @return {module:zrender/core/BoundingRect}
	         */
	        getBoundingRect: function (includeChildren) {
	            // TODO Caching
	            var rect = null;
	            var tmpRect = new BoundingRect(0, 0, 0, 0);
	            var children = includeChildren || this._children;
	            var tmpMat = [];
	
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                if (child.ignore || child.invisible) {
	                    continue;
	                }
	
	                var childRect = child.getBoundingRect();
	                var transform = child.getLocalTransform(tmpMat);
	                // TODO
	                // The boundingRect cacluated by transforming original
	                // rect may be bigger than the actual bundingRect when rotation
	                // is used. (Consider a circle rotated aginst its center, where
	                // the actual boundingRect should be the same as that not be
	                // rotated.) But we can not find better approach to calculate
	                // actual boundingRect yet, considering performance.
	                if (transform) {
	                    tmpRect.copy(childRect);
	                    tmpRect.applyTransform(transform);
	                    rect = rect || tmpRect.clone();
	                    rect.union(tmpRect);
	                }
	                else {
	                    rect = rect || childRect.clone();
	                    rect.union(childRect);
	                }
	            }
	            return rect || tmpRect;
	        }
	    };
	
	    zrUtil.inherits(Group, Element);
	
	    module.exports = Group;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Image element
	 * @module zrender/graphic/Image
	 */
	
	
	
	    var Displayable = __webpack_require__(8);
	    var BoundingRect = __webpack_require__(27);
	    var zrUtil = __webpack_require__(5);
	    var imageHelper = __webpack_require__(28);
	
	    /**
	     * @alias zrender/graphic/Image
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    function ZImage(opts) {
	        Displayable.call(this, opts);
	    }
	
	    ZImage.prototype = {
	
	        constructor: ZImage,
	
	        type: 'image',
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var src = style.image;
	
	            // Must bind each time
	            style.bind(ctx, this, prevEl);
	
	            var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this);
	
	            if (!image || !imageHelper.isImageReady(image)) {
	                return;
	            }
	
	            // 图片已经加载完成
	            // if (image.nodeName.toUpperCase() == 'IMG') {
	            //     if (!image.complete) {
	            //         return;
	            //     }
	            // }
	            // Else is canvas
	
	            var x = style.x || 0;
	            var y = style.y || 0;
	            var width = style.width;
	            var height = style.height;
	            var aspect = image.width / image.height;
	            if (width == null && height != null) {
	                // Keep image/height ratio
	                width = height * aspect;
	            }
	            else if (height == null && width != null) {
	                height = width / aspect;
	            }
	            else if (width == null && height == null) {
	                width = image.width;
	                height = image.height;
	            }
	
	            // 设置transform
	            this.setTransform(ctx);
	
	            if (style.sWidth && style.sHeight) {
	                var sx = style.sx || 0;
	                var sy = style.sy || 0;
	                ctx.drawImage(
	                    image,
	                    sx, sy, style.sWidth, style.sHeight,
	                    x, y, width, height
	                );
	            }
	            else if (style.sx && style.sy) {
	                var sx = style.sx;
	                var sy = style.sy;
	                var sWidth = width - sx;
	                var sHeight = height - sy;
	                ctx.drawImage(
	                    image,
	                    sx, sy, sWidth, sHeight,
	                    x, y, width, height
	                );
	            }
	            else {
	                ctx.drawImage(image, x, y, width, height);
	            }
	
	            this.restoreTransform(ctx);
	
	            // Draw rect text
	            if (style.text != null) {
	                this.drawRectText(ctx, this.getBoundingRect());
	            }
	        },
	
	        getBoundingRect: function () {
	            var style = this.style;
	            if (! this._rect) {
	                this._rect = new BoundingRect(
	                    style.x || 0, style.y || 0, style.width || 0, style.height || 0
	                );
	            }
	            return this._rect;
	        }
	    };
	
	    zrUtil.inherits(ZImage, Displayable);
	
	    module.exports = ZImage;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Text element
	 * @module zrender/graphic/Text
	 *
	 * TODO Wrapping
	 *
	 * Text not support gradient
	 */
	
	
	
	    var Displayable = __webpack_require__(8);
	    var zrUtil = __webpack_require__(5);
	    var textContain = __webpack_require__(26);
	    var textHelper = __webpack_require__(25);
	
	    /**
	     * @alias zrender/graphic/Text
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    var Text = function (opts) {
	        Displayable.call(this, opts);
	    };
	
	    Text.prototype = {
	
	        constructor: Text,
	
	        type: 'text',
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	
	            // Optimize, avoid normalize every time.
	            this.__dirty && textHelper.normalizeTextStyle(style, true);
	
	            // Use props with prefix 'text'.
	            style.fill = style.stroke = style.shadowBlur = style.shadowColor =
	                style.shadowOffsetX = style.shadowOffsetY = null;
	
	            var text = style.text;
	            // Convert to string
	            text != null && (text += '');
	
	            // Always bind style
	            style.bind(ctx, this, prevEl);
	
	            if (!textHelper.needDrawText(text, style)) {
	                return;
	            }
	
	            this.setTransform(ctx);
	
	            textHelper.renderText(this, ctx, text, style);
	
	            this.restoreTransform(ctx);
	        },
	
	        getBoundingRect: function () {
	            var style = this.style;
	
	            // Optimize, avoid normalize every time.
	            this.__dirty && textHelper.normalizeTextStyle(style, true);
	
	            if (!this._rect) {
	                var text = style.text;
	                text != null ? (text += '') : (text = '');
	
	                var rect = textContain.getBoundingRect(
	                    style.text + '',
	                    style.font,
	                    style.textAlign,
	                    style.textVerticalAlign,
	                    style.textPadding,
	                    style.rich
	                );
	
	                rect.x += style.x || 0;
	                rect.y += style.y || 0;
	
	                if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {
	                    var w = style.textStrokeWidth;
	                    rect.x -= w / 2;
	                    rect.y -= w / 2;
	                    rect.width += w;
	                    rect.height += w;
	                }
	
	                this._rect = rect;
	            }
	
	            return this._rect;
	        }
	    };
	
	    zrUtil.inherits(Text, Displayable);
	
	    module.exports = Text;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 圆形
	 * @module zrender/shape/Circle
	 */
	
	
	
	    module.exports = __webpack_require__(7).extend({
	
	        type: 'circle',
	
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0
	        },
	
	
	        buildPath : function (ctx, shape, inBundle) {
	            // Better stroking in ShapeBundle
	            // Always do it may have performence issue ( fill may be 2x more cost)
	            if (inBundle) {
	                ctx.moveTo(shape.cx + shape.r, shape.cy);
	            }
	            // else {
	            //     if (ctx.allocate && !ctx.data.length) {
	            //         ctx.allocate(ctx.CMD_MEM_SIZE.A);
	            //     }
	            // }
	            // Better stroking in ShapeBundle
	            // ctx.moveTo(shape.cx + shape.r, shape.cy);
	            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
	        }
	    });
	


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 扇形
	 * @module zrender/graphic/shape/Sector
	 */
	
	
	
	    var Path = __webpack_require__(7);
	    var fixClipWithShadow = __webpack_require__(49);
	
	    module.exports = Path.extend({
	
	        type: 'sector',
	
	        shape: {
	
	            cx: 0,
	
	            cy: 0,
	
	            r0: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        brush: fixClipWithShadow(Path.prototype.brush),
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r0 = Math.max(shape.r0 || 0, 0);
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
	
	            ctx.lineTo(unitX * r + x, unitY * r + y);
	
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	
	            ctx.lineTo(
	                Math.cos(endAngle) * r0 + x,
	                Math.sin(endAngle) * r0 + y
	            );
	
	            if (r0 !== 0) {
	                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
	            }
	
	            ctx.closePath();
	        }
	    });
	


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var env = __webpack_require__(50);
	
	    // Fix weird bug in some version of IE11 (like 11.0.9600.178**),
	    // where exception "unexpected call to method or property access"
	    // might be thrown when calling ctx.fill or ctx.stroke after a path
	    // whose area size is zero is drawn and ctx.clip() is called and
	    // shadowBlur is set. See #4572, #3112, #5777.
	    // (e.g.,
	    //  ctx.moveTo(10, 10);
	    //  ctx.lineTo(20, 10);
	    //  ctx.closePath();
	    //  ctx.clip();
	    //  ctx.shadowBlur = 10;
	    //  ...
	    //  ctx.fill();
	    // )
	
	    var shadowTemp = [
	        ['shadowBlur', 0],
	        ['shadowColor', '#000'],
	        ['shadowOffsetX', 0],
	        ['shadowOffsetY', 0]
	    ];
	
	    module.exports = function (orignalBrush) {
	
	        // version string can be: '11.0'
	        return (env.browser.ie && env.browser.version >= 11)
	
	            ? function () {
	                var clipPaths = this.__clipPaths;
	                var style = this.style;
	                var modified;
	
	                if (clipPaths) {
	                    for (var i = 0; i < clipPaths.length; i++) {
	                        var clipPath = clipPaths[i];
	                        var shape = clipPath && clipPath.shape;
	                        var type = clipPath && clipPath.type;
	
	                        if (shape && (
	                            (type === 'sector' && shape.startAngle === shape.endAngle)
	                            || (type === 'rect' && (!shape.width || !shape.height))
	                        )) {
	                            for (var j = 0; j < shadowTemp.length; j++) {
	                                // It is save to put shadowTemp static, because shadowTemp
	                                // will be all modified each item brush called.
	                                shadowTemp[j][2] = style[shadowTemp[j][0]];
	                                style[shadowTemp[j][0]] = shadowTemp[j][1];
	                            }
	                            modified = true;
	                            break;
	                        }
	                    }
	                }
	
	                orignalBrush.apply(this, arguments);
	
	                if (modified) {
	                    for (var j = 0; j < shadowTemp.length; j++) {
	                        style[shadowTemp[j][0]] = shadowTemp[j][2];
	                    }
	                }
	            }
	
	            : orignalBrush;
	    };
	


/***/ }),
/* 50 */
/***/ (function(module, exports) {

	/**
	 * echarts设备环境识别
	 *
	 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
	 * @author firede[firede@firede.us]
	 * @desc thanks zepto.
	 */
	
	    var env = {};
	    if (typeof navigator === 'undefined') {
	        // In node
	        env = {
	            browser: {},
	            os: {},
	            node: true,
	            // Assume canvas is supported
	            canvasSupported: true
	        };
	    }
	    else {
	        env = detect(navigator.userAgent);
	    }
	
	    module.exports = env;
	
	    // Zepto.js
	    // (c) 2010-2013 Thomas Fuchs
	    // Zepto.js may be freely distributed under the MIT license.
	
	    function detect(ua) {
	        var os = {};
	        var browser = {};
	        // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
	        // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
	        // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	        // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	        // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
	        // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
	        // var touchpad = webos && ua.match(/TouchPad/);
	        // var kindle = ua.match(/Kindle\/([\d.]+)/);
	        // var silk = ua.match(/Silk\/([\d._]+)/);
	        // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
	        // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
	        // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
	        // var playbook = ua.match(/PlayBook/);
	        // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
	        var firefox = ua.match(/Firefox\/([\d.]+)/);
	        // var safari = webkit && ua.match(/Mobile\//) && !chrome;
	        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
	        var ie = ua.match(/MSIE\s([\d.]+)/)
	            // IE 11 Trident/7.0; rv:11.0
	            || ua.match(/Trident\/.+?rv:(([\d.]+))/);
	        var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+
	
	        var weChat = (/micromessenger/i).test(ua);
	
	        // Todo: clean this up with a better OS/browser seperation:
	        // - discern (more) between multiple browsers on android
	        // - decide if kindle fire in silk mode is android or not
	        // - Firefox on Android doesn't specify the Android version
	        // - possibly devide in os, device and browser hashes
	
	        // if (browser.webkit = !!webkit) browser.version = webkit[1];
	
	        // if (android) os.android = true, os.version = android[2];
	        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
	        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
	        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
	        // if (webos) os.webos = true, os.version = webos[2];
	        // if (touchpad) os.touchpad = true;
	        // if (blackberry) os.blackberry = true, os.version = blackberry[2];
	        // if (bb10) os.bb10 = true, os.version = bb10[2];
	        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
	        // if (playbook) browser.playbook = true;
	        // if (kindle) os.kindle = true, os.version = kindle[1];
	        // if (silk) browser.silk = true, browser.version = silk[1];
	        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
	        // if (chrome) browser.chrome = true, browser.version = chrome[1];
	        if (firefox) {
	            browser.firefox = true;
	            browser.version = firefox[1];
	        }
	        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
	        // if (webview) browser.webview = true;
	
	        if (ie) {
	            browser.ie = true;
	            browser.version = ie[1];
	        }
	
	        if (edge) {
	            browser.edge = true;
	            browser.version = edge[1];
	        }
	
	        // It is difficult to detect WeChat in Win Phone precisely, because ua can
	        // not be set on win phone. So we do not consider Win Phone.
	        if (weChat) {
	            browser.weChat = true;
	        }
	
	        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
	        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
	        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
	        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
	        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));
	
	        return {
	            browser: browser,
	            os: os,
	            node: false,
	            // 原生canvas支持，改极端点了
	            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
	            canvasSupported : document.createElement('canvas').getContext ? true : false,
	            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
	            // works on most browsers
	            // IE10/11 does not support touch event, and MS Edge supports them but not by
	            // default, so we dont check navigator.maxTouchPoints for them here.
	            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
	            // <http://caniuse.com/#search=pointer%20event>.
	            pointerEventsSupported: 'onpointerdown' in window
	                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer
	                // events currently. So we dont use that on other browsers unless tested sufficiently.
	                // Although IE 10 supports pointer event, it use old style and is different from the
	                // standard. So we exclude that. (IE 10 is hardly used on touch device)
	                && (browser.edge || (browser.ie && browser.version >= 11))
	        };
	    }


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 圆环
	 * @module zrender/graphic/shape/Ring
	 */
	
	
	    module.exports = __webpack_require__(7).extend({
	
	        type: 'ring',
	
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0,
	            r0: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.cx;
	            var y = shape.cy;
	            var PI2 = Math.PI * 2;
	            ctx.moveTo(x + shape.r, y);
	            ctx.arc(x, y, shape.r, 0, PI2, false);
	            ctx.moveTo(x + shape.r0, y);
	            ctx.arc(x, y, shape.r0, 0, PI2, true);
	        }
	    });
	


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 多边形
	 * @module zrender/shape/Polygon
	 */
	
	
	    var polyHelper = __webpack_require__(53);
	
	    module.exports = __webpack_require__(7).extend({
	        
	        type: 'polygon',
	
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, true);
	        }
	    });


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var smoothSpline = __webpack_require__(54);
	    var smoothBezier = __webpack_require__(55);
	
	    module.exports = {
	        buildPath: function (ctx, shape, closePath) {
	            var points = shape.points;
	            var smooth = shape.smooth;
	            if (points && points.length >= 2) {
	                if (smooth && smooth !== 'spline') {
	                    var controlPoints = smoothBezier(
	                        points, smooth, closePath, shape.smoothConstraint
	                    );
	
	                    ctx.moveTo(points[0][0], points[0][1]);
	                    var len = points.length;
	                    for (var i = 0; i < (closePath ? len : len - 1); i++) {
	                        var cp1 = controlPoints[i * 2];
	                        var cp2 = controlPoints[i * 2 + 1];
	                        var p = points[(i + 1) % len];
	                        ctx.bezierCurveTo(
	                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
	                        );
	                    }
	                }
	                else {
	                    if (smooth === 'spline') {
	                        points = smoothSpline(points, closePath);
	                    }
	
	                    ctx.moveTo(points[0][0], points[0][1]);
	                    for (var i = 1, l = points.length; i < l; i++) {
	                        ctx.lineTo(points[i][0], points[i][1]);
	                    }
	                }
	
	                closePath && ctx.closePath();
	            }
	        }
	    };


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Catmull-Rom spline 插值折线
	 * @module zrender/shape/util/smoothSpline
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	    var vec2 = __webpack_require__(15);
	
	    /**
	     * @inner
	     */
	    function interpolate(p0, p1, p2, p3, t, t2, t3) {
	        var v0 = (p2 - p0) * 0.5;
	        var v1 = (p3 - p1) * 0.5;
	        return (2 * (p1 - p2) + v0 + v1) * t3
	                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
	                + v0 * t + p1;
	    }
	
	    /**
	     * @alias module:zrender/shape/util/smoothSpline
	     * @param {Array} points 线段顶点数组
	     * @param {boolean} isLoop
	     * @return {Array}
	     */
	    module.exports = function (points, isLoop) {
	        var len = points.length;
	        var ret = [];
	
	        var distance = 0;
	        for (var i = 1; i < len; i++) {
	            distance += vec2.distance(points[i - 1], points[i]);
	        }
	
	        var segs = distance / 2;
	        segs = segs < len ? len : segs;
	        for (var i = 0; i < segs; i++) {
	            var pos = i / (segs - 1) * (isLoop ? len : len - 1);
	            var idx = Math.floor(pos);
	
	            var w = pos - idx;
	
	            var p0;
	            var p1 = points[idx % len];
	            var p2;
	            var p3;
	            if (!isLoop) {
	                p0 = points[idx === 0 ? idx : idx - 1];
	                p2 = points[idx > len - 2 ? len - 1 : idx + 1];
	                p3 = points[idx > len - 3 ? len - 1 : idx + 2];
	            }
	            else {
	                p0 = points[(idx - 1 + len) % len];
	                p2 = points[(idx + 1) % len];
	                p3 = points[(idx + 2) % len];
	            }
	
	            var w2 = w * w;
	            var w3 = w * w2;
	
	            ret.push([
	                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),
	                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)
	            ]);
	        }
	        return ret;
	    };
	


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 贝塞尔平滑曲线
	 * @module zrender/shape/util/smoothBezier
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	
	    var vec2 = __webpack_require__(15);
	    var v2Min = vec2.min;
	    var v2Max = vec2.max;
	    var v2Scale = vec2.scale;
	    var v2Distance = vec2.distance;
	    var v2Add = vec2.add;
	
	    /**
	     * 贝塞尔平滑曲线
	     * @alias module:zrender/shape/util/smoothBezier
	     * @param {Array} points 线段顶点数组
	     * @param {number} smooth 平滑等级, 0-1
	     * @param {boolean} isLoop
	     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
	     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
	     *                           整个折线的包围盒做一个并集用来约束控制点。
	     * @param {Array} 计算出来的控制点数组
	     */
	    module.exports = function (points, smooth, isLoop, constraint) {
	        var cps = [];
	
	        var v = [];
	        var v1 = [];
	        var v2 = [];
	        var prevPoint;
	        var nextPoint;
	
	        var min, max;
	        if (constraint) {
	            min = [Infinity, Infinity];
	            max = [-Infinity, -Infinity];
	            for (var i = 0, len = points.length; i < len; i++) {
	                v2Min(min, min, points[i]);
	                v2Max(max, max, points[i]);
	            }
	            // 与指定的包围盒做并集
	            v2Min(min, min, constraint[0]);
	            v2Max(max, max, constraint[1]);
	        }
	
	        for (var i = 0, len = points.length; i < len; i++) {
	            var point = points[i];
	
	            if (isLoop) {
	                prevPoint = points[i ? i - 1 : len - 1];
	                nextPoint = points[(i + 1) % len];
	            }
	            else {
	                if (i === 0 || i === len - 1) {
	                    cps.push(vec2.clone(points[i]));
	                    continue;
	                }
	                else {
	                    prevPoint = points[i - 1];
	                    nextPoint = points[i + 1];
	                }
	            }
	
	            vec2.sub(v, nextPoint, prevPoint);
	
	            // use degree to scale the handle length
	            v2Scale(v, v, smooth);
	
	            var d0 = v2Distance(point, prevPoint);
	            var d1 = v2Distance(point, nextPoint);
	            var sum = d0 + d1;
	            if (sum !== 0) {
	                d0 /= sum;
	                d1 /= sum;
	            }
	
	            v2Scale(v1, v, -d0);
	            v2Scale(v2, v, d1);
	            var cp0 = v2Add([], point, v1);
	            var cp1 = v2Add([], point, v2);
	            if (constraint) {
	                v2Max(cp0, cp0, min);
	                v2Min(cp0, cp0, max);
	                v2Max(cp1, cp1, min);
	                v2Min(cp1, cp1, max);
	            }
	            cps.push(cp0);
	            cps.push(cp1);
	        }
	
	        if (isLoop) {
	            cps.push(cps.shift());
	        }
	
	        return cps;
	    };
	


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @module zrender/graphic/shape/Polyline
	 */
	
	
	    var polyHelper = __webpack_require__(53);
	
	    module.exports = __webpack_require__(7).extend({
	        
	        type: 'polyline',
	
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        style: {
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, false);
	        }
	    });


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 矩形
	 * @module zrender/graphic/shape/Rect
	 */
	
	
	    var roundRectHelper = __webpack_require__(29);
	
	    module.exports = __webpack_require__(7).extend({
	
	        type: 'rect',
	
	        shape: {
	            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
	            // r缩写为1         相当于 [1, 1, 1, 1]
	            // r缩写为[1]       相当于 [1, 1, 1, 1]
	            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
	            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
	            r: 0,
	
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var width = shape.width;
	            var height = shape.height;
	            if (!shape.r) {
	                ctx.rect(x, y, width, height);
	            }
	            else {
	                roundRectHelper.buildPath(ctx, shape);
	            }
	            ctx.closePath();
	            return;
	        }
	    });
	


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 直线
	 * @module zrender/graphic/shape/Line
	 */
	
	    module.exports = __webpack_require__(7).extend({
	
	        type: 'line',
	
	        shape: {
	            // Start point
	            x1: 0,
	            y1: 0,
	            // End point
	            x2: 0,
	            y2: 0,
	
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var percent = shape.percent;
	
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (percent < 1) {
	                x2 = x1 * (1 - percent) + x2 * percent;
	                y2 = y1 * (1 - percent) + y2 * percent;
	            }
	            ctx.lineTo(x2, y2);
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} percent
	         * @return {Array.<number>}
	         */
	        pointAt: function (p) {
	            var shape = this.shape;
	            return [
	                shape.x1 * (1 - p) + shape.x2 * p,
	                shape.y1 * (1 - p) + shape.y2 * p
	            ];
	        }
	    });
	


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 贝塞尔曲线
	 * @module zrender/shape/BezierCurve
	 */
	
	
	    var curveTool = __webpack_require__(31);
	    var vec2 = __webpack_require__(15);
	    var quadraticSubdivide = curveTool.quadraticSubdivide;
	    var cubicSubdivide = curveTool.cubicSubdivide;
	    var quadraticAt = curveTool.quadraticAt;
	    var cubicAt = curveTool.cubicAt;
	    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;
	    var cubicDerivativeAt = curveTool.cubicDerivativeAt;
	
	    var out = [];
	
	    function someVectorAt(shape, t, isTangent) {
	        var cpx2 = shape.cpx2;
	        var cpy2 = shape.cpy2;
	        if (cpx2 === null || cpy2 === null) {
	            return [
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
	            ];
	        }
	        else {
	            return [
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
	            ];
	        }
	    }
	    module.exports = __webpack_require__(7).extend({
	
	        type: 'bezier-curve',
	
	        shape: {
	            x1: 0,
	            y1: 0,
	            x2: 0,
	            y2: 0,
	            cpx1: 0,
	            cpy1: 0,
	            // cpx2: 0,
	            // cpy2: 0
	
	            // Curve show percent, for animating
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var cpx1 = shape.cpx1;
	            var cpy1 = shape.cpy1;
	            var cpx2 = shape.cpx2;
	            var cpy2 = shape.cpy2;
	            var percent = shape.percent;
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (cpx2 == null || cpy2 == null) {
	                if (percent < 1) {
	                    quadraticSubdivide(
	                        x1, cpx1, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    x2 = out[2];
	                    quadraticSubdivide(
	                        y1, cpy1, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    y2 = out[2];
	                }
	
	                ctx.quadraticCurveTo(
	                    cpx1, cpy1,
	                    x2, y2
	                );
	            }
	            else {
	                if (percent < 1) {
	                    cubicSubdivide(
	                        x1, cpx1, cpx2, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    cpx2 = out[2];
	                    x2 = out[3];
	                    cubicSubdivide(
	                        y1, cpy1, cpy2, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    cpy2 = out[2];
	                    y2 = out[3];
	                }
	                ctx.bezierCurveTo(
	                    cpx1, cpy1,
	                    cpx2, cpy2,
	                    x2, y2
	                );
	            }
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        pointAt: function (t) {
	            return someVectorAt(this.shape, t, false);
	        },
	
	        /**
	         * Get tangent at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        tangentAt: function (t) {
	            var p = someVectorAt(this.shape, t, true);
	            return vec2.normalize(p, p);
	        }
	    });
	


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 圆弧
	 * @module zrender/graphic/shape/Arc
	 */
	 
	
	    module.exports = __webpack_require__(7).extend({
	
	        type: 'arc',
	
	        shape: {
	
	            cx: 0,
	
	            cy: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        style: {
	
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r + x, unitY * r + y);
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	        }
	    });


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(5);
	
	    var Gradient = __webpack_require__(42);
	
	    /**
	     * x, y, x2, y2 are all percent from 0 to 1
	     * @param {number} [x=0]
	     * @param {number} [y=0]
	     * @param {number} [x2=1]
	     * @param {number} [y2=0]
	     * @param {Array.<Object>} colorStops
	     * @param {boolean} [globalCoord=false]
	     */
	    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
	        // Should do nothing more in this constructor. Because gradient can be
	        // declard by `color: {type: 'linear', colorStops: ...}`, where
	        // this constructor will not be called.
	
	        this.x = x == null ? 0 : x;
	
	        this.y = y == null ? 0 : y;
	
	        this.x2 = x2 == null ? 1 : x2;
	
	        this.y2 = y2 == null ? 0 : y2;
	
	        // Can be cloned
	        this.type = 'linear';
	
	        // If use global coord
	        this.global = globalCoord || false;
	
	        Gradient.call(this, colorStops);
	    };
	
	    LinearGradient.prototype = {
	
	        constructor: LinearGradient
	    };
	
	    zrUtil.inherits(LinearGradient, Gradient);
	
	    module.exports = LinearGradient;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(5);
	
	    var Gradient = __webpack_require__(42);
	
	    /**
	     * x, y, r are all percent from 0 to 1
	     * @param {number} [x=0.5]
	     * @param {number} [y=0.5]
	     * @param {number} [r=0.5]
	     * @param {Array.<Object>} [colorStops]
	     * @param {boolean} [globalCoord=false]
	     */
	    var RadialGradient = function (x, y, r, colorStops, globalCoord) {
	        // Should do nothing more in this constructor. Because gradient can be
	        // declard by `color: {type: 'radial', colorStops: ...}`, where
	        // this constructor will not be called.
	
	        this.x = x == null ? 0.5 : x;
	
	        this.y = y == null ? 0.5 : y;
	
	        this.r = r == null ? 0.5 : r;
	
	        // Can be cloned
	        this.type = 'radial';
	
	        // If use global coord
	        this.global = globalCoord || false;
	
	        Gradient.call(this, colorStops);
	    };
	
	    RadialGradient.prototype = {
	
	        constructor: RadialGradient
	    };
	
	    zrUtil.inherits(RadialGradient, Gradient);
	
	    module.exports = RadialGradient;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * States machine for managing graphic states
	 */
	
	
	
	    /**
	     * @typedef {Object} IGraphicState
	     * @property {number} [zlevel]
	     * @property {number} [z]
	     * @property {Array.<number>} {position}
	     * @property {Array.<number>|number} {rotation}
	     * @property {Array.<number>} {scale}
	     * @property {Object} style
	     *
	     * @property {Function} onenter
	     * @property {Function} onleave
	     * @property {Function} ontransition
	     * @property {Array.<IGraphicStateTransition|string>} transition
	     *           Transition object or a string descriptor like '* 30 0 Linear'
	     */
	
	    var zrUtil = __webpack_require__(5);
	    var Style = __webpack_require__(9);
	    var vec2Copy = __webpack_require__(15).copy;
	
	    var transitionProperties = ['position', 'rotation', 'scale', 'style', 'shape'];
	    /**
	     * @module zrender/graphic/States~TransitionObject
	     */
	    var TransitionObject = function (opts) {
	        if (typeof opts == 'string') {
	            this._fromStr(opts);
	        }
	        else if (opts) {
	            opts.property && (this.property = opts.property);
	            opts.duration != null && (this.duration = opts.duration);
	            opts.easing && (this.easing = opts.easing);
	            opts.delay && (this.delay = opts.delay);
	        }
	        if (this.property !== '*') {
	            this.property = this.property.split(',');
	        }
	        else {
	            this.property = transitionProperties;
	        }
	    };
	
	    TransitionObject.prototype = {
	
	        constructor: TransitionObject,
	
	        /**
	         * List of all transition properties. Splitted by comma. Must not have spaces in the string.
	         * e.g. 'position,style.color'. '*' will match all the valid properties.
	         * @type {string}
	         * @default *
	         */
	        property: '*',
	
	        /**
	         * @type {string}
	         * @default 'Linear'
	         */
	        easing: 'Linear',
	
	        /**
	         * @type {number}
	         * @default 'number'
	         */
	        duration: 500,
	
	        /**
	         * @type {number}
	         */
	        delay: 0,
	
	        _fromStr: function (str) {
	            var arr = str.split(/\s+/g);
	            this.property = arr[0];
	            this.duration = +arr[1];
	            this.delay = +arr[2];
	            this.easing = arr[3];
	        }
	    };
	
	
	    /**
	     * @alias module:zrender/graphic/States
	     */
	    var GraphicStates = function (opts) {
	
	        opts = opts || {};
	
	        this._states = {};
	
	        /**
	         * Target element
	         * @type {zrender/graphic/Displayable|zrender/container/Group}
	         */
	        this._el = opts.el;
	
	        this._subStates = [];
	
	        this._transitionAnimators = [];
	
	        if (opts.initialState) {
	            this._initialState = opts.initialState;
	        }
	
	        var optsStates = opts.states;
	        if (optsStates) {
	            for (var name in optsStates) {
	                if (optsStates.hasOwnProperty(name)) {
	                    var state = optsStates[name];
	                    this._addState(name, state);
	                }
	            }
	        }
	
	        this.setState(this._initialState);
	    };
	
	    GraphicStates.prototype = {
	
	        constructor: GraphicStates,
	
	        /**
	         * All other state will be extended from initial state
	         * @type {string}
	         * @private
	         */
	        _initialState: 'normal',
	
	        /**
	         * Current state
	         * @type {string}
	         * @private
	         */
	        _currentState: '',
	
	        el: function () {
	            return this._el;
	        },
	
	        _addState: function (name, state) {
	            this._states[name] = state;
	
	            if (state.transition) {
	                state.transition = new TransitionObject(state.transition);
	            }
	
	            // Extend from initial state
	            if (name !== this._initialState) {
	                this._extendFromInitial(state);
	            }
	            else {
	                var el = this._el;
	                // setState 的时候自带的 style 和 shape 都会被直接覆盖
	                // 所以这边先把自带的 style 和 shape 扩展到初始状态中
	                zrUtil.merge(state.style, el.style, false, false);
	                if (state.shape) {
	                    zrUtil.merge(state.shape, el.shape, false, true);
	                }
	                else {
	                    state.shape = zrUtil.clone(el.shape, true);
	                }
	
	                for (var name in this._states) {
	                    if (this._states.hasOwnProperty(name)) {
	                        this._extendFromInitial(this._states[name]);
	                    }
	                }
	            }
	        },
	
	        _extendFromInitial: function (state) {
	            var initialState = this._states[this._initialState];
	            if (initialState && state !== initialState) {
	                zrUtil.merge(state, initialState, false, true);
	            }
	        },
	
	        setState: function (name, silent) {
	            if (name === this._currentState
	                && ! this.transiting()
	            ) {
	                return;
	            }
	
	            var state = this._states[name];
	
	            if (state) {
	                this._stopTransition();
	
	                if (! silent) {
	                    var prevState = this._states[this._currentState];
	                    if (prevState) {
	                        prevState.onleave && prevState.onleave.call(this);
	                    }
	
	                    state.onenter && state.onenter.call(this);
	                }
	
	                this._currentState = name;
	
	                if (this._el) {
	                    var el = this._el;
	
	                    // Setting attributes
	                    if (state.zlevel != null) {
	                        el.zlevel = state.zlevel;
	                    }
	                    if (state.z != null) {
	                        el.z = state.z;
	                    }
	
	                    // SRT
	                    state.position && vec2Copy(el.position, state.position);
	                    state.scale && vec2Copy(el.scale, state.scale);
	                    if (state.rotation != null) {
	                        el.rotation = state.rotation;
	                    }
	
	                    // Style
	                    if (state.style) {
	                        var initialState = this._states[this._initialState];
	                        el.style = new Style();
	                        if (initialState) {
	                            el.style.extendFrom(initialState.style, false);
	                        }
	                        if (
	                            // Not initial state
	                            name != this._initialState
	                            // Not copied from initial state in _extendFromInitial method
	                            && initialState.style !== state.style
	                        ) {
	                            el.style.extendFrom(state.style, true);
	                        }
	                    }
	                    if (state.shape) {
	                        el.shape = zrUtil.clone(state.shape, true);
	                    }
	
	                    el.dirty();
	                }
	            }
	
	            for (var i = 0; i < this._subStates.length; i++) {
	                this._subStates.setState(name);
	            }
	        },
	
	        getState: function () {
	            return this._currentState;
	        },
	
	        transitionState: function (target, done) {
	            if (
	                target === this._currentState
	                && ! this.transiting()
	            ) {
	                return;
	            }
	
	            var state = this._states[target];
	            var styleShapeReg = /$[style|shape]\./;
	            var self = this;
	
	            // Animation 去重
	            var propPathMap = {};
	
	            if (state) {
	
	                self._stopTransition();
	
	                var el = self._el;
	
	                if (state.transition && el && el.__zr) {// El can be animated
	                    var transitionCfg = state.transition;
	                    var property = transitionCfg.property;
	
	                    var animatingCount = 0;
	                    var animationDone = function () {
	                        animatingCount--;
	                        if (animatingCount === 0) {
	                            self.setState(target);
	                            done && done();
	                        }
	                    };
	                    for (var i = 0; i < property.length; i++) {
	                        var propName = property[i];
	
	                        // Animating all the properties in style or shape
	                        if (propName === 'style' || propName === 'shape') {
	                            if (state[propName]) {
	                                for (var key in state[propName]) {
	                                    if (!state[propName].hasOwnProperty(key)) {
	                                        continue;
	                                    }
	                                    var path = propName + '.' + key;
	                                    if (propPathMap[path]) {
	                                        continue;
	                                    }
	                                    propPathMap[path] = 1;
	                                    animatingCount += self._animProp(
	                                        state, propName, key, transitionCfg, animationDone
	                                    );
	                                }
	                            }
	                        }
	                        else {
	                            if (propPathMap[propName]) {
	                                continue;
	                            }
	                            propPathMap[propName] = 1;
	                            // Animating particular property in style or style
	                            if (propName.match(styleShapeReg)) {
	                                // remove 'style.', 'shape.' prefix
	                                var subProp = propName.slice(0, 5);
	                                propName = propName.slice(6);
	                                animatingCount += self._animProp(
	                                    state, subProp, propName, transitionCfg, animationDone
	                                );
	                            }
	                            else {
	                                animatingCount += self._animProp(
	                                    state, '', propName, transitionCfg, animationDone
	                                );
	                            }
	
	                        }
	                    }
	                    // No transition properties
	                    if (animatingCount === 0) {
	                        self.setState(target);
	                        done && done();
	                    }
	                }
	                else {
	                    self.setState(target);
	                    done && done();
	                }
	            }
	
	            var subStates = self._subStates;
	            for (var i = 0; i < subStates.length; i++) {
	                subStates.transitionState(target);
	            }
	        },
	
	        /**
	         * Do transition animation of particular property
	         * @param {Object} state
	         * @param {string} subPropKey
	         * @param {string} key
	         * @param {Object} transitionCfg
	         * @param {Function} done
	         * @private
	         */
	        _animProp: function (state, subPropKey, key, transitionCfg, done) {
	            var el = this._el;
	            var stateObj = subPropKey ? state[subPropKey] : state;
	            var elObj = subPropKey ? el[subPropKey] : el;
	            var availableProp = stateObj && (key in stateObj)
	                && elObj && (key in elObj);
	
	            var transitionAnimators = this._transitionAnimators;
	            if (availableProp) {
	                var obj = {};
	                if (stateObj[key] === elObj[key]) {
	                    return 0;
	                }
	                obj[key] = stateObj[key];
	
	                var animator = el.animate(subPropKey)
	                    .when(transitionCfg.duration, obj)
	                    .delay(transitionCfg.dealy)
	                    .done(function () {
	                        var idx = zrUtil.indexOf(transitionAnimators, 1);
	                        if (idx > 0) {
	                            transitionAnimators.splice(idx, 1);
	                        }
	                        done();
	                    })
	                    .start(transitionCfg.easing);
	                transitionAnimators.push(animator);
	
	                return 1;
	            }
	            return 0;
	        },
	
	        _stopTransition: function () {
	            var transitionAnimators = this._transitionAnimators;
	            for (var i = 0; i < transitionAnimators.length; i++) {
	                transitionAnimators[i].stop();
	            }
	            transitionAnimators.length = 0;
	        },
	
	        transiting: function () {
	            return this._transitionAnimators.length > 0;
	        },
	
	        addSubStates: function (states) {
	            this._subStates.push(states);
	        },
	
	        removeSubStates: function (states) {
	            var idx = zrUtil.indexOf(this._subStates, states);
	            if (idx >= 0) {
	                this._subStates.splice(states, 1);
	            }
	        }
	    };
	
	    module.exports = GraphicStates;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var zrUtil = __webpack_require__(5);
	    var BoundingRect = __webpack_require__(27);
	    function Minimap(bigCanvas,groupPosition, group,eagleEyeNode,distance,imgSrc) {
	
	        this.bigCanvas = bigCanvas;
	        this.eagleEyeNode = eagleEyeNode;
	        this.distance = distance;
	        this.imgSrc = imgSrc;
	        this.ratio;
	        this.groupRatio;
	        this.group = group;
	        this.img = document.createElement("img");
	        this.selection = document.createElement('div');
	        this.groupPosition = zrUtil.clone(groupPosition);
	        this.selectPosition = [0,0];
	        this.render();
	    }
	
	    Minimap.prototype.render = function() {
	        var that = this;
	        that.ratio = 0.12;
	        var eagleEyeNodeWidth = that.group.width  * that.ratio;
	        var eagleEyeNodeHeight = that.group.height  * that.ratio;
	        that.eagleEyeNode.style.width = eagleEyeNodeWidth+"px";
	        that.eagleEyeNode.style.height = eagleEyeNodeHeight+"px";
	        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+"px";
	        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+"px";
	        that.eagleEyeNode.style.position="relative";
	        that.eagleEyeNode.style.background = "url("+that.imgSrc+") no-repeat";
	        that.eagleEyeNode.style.backgroundSize = eagleEyeNodeWidth/(that.group.width*that.distance[2]/that.bigCanvas.getWidth())+"px";
	        that.backgroundSize = zrUtil.clone(that.eagleEyeNode.style.backgroundSize);
	        that.eagleEyeNode.innerHTML = "";
	        that.selection.style.border = "1px solid #ff0000";
	        that.selection.style.cursor = "pointer";
	        that.selection.style.width = that.bigCanvas.getWidth()/that.group.width*eagleEyeNodeWidth+"px";
	        that.selection.style.height = that.bigCanvas.getHeight()/that.group.height*eagleEyeNodeHeight+"px";
	        that.selectWidth = that.selection.style.width;
	        that.selectHeight = that.selection.style.height;
	        that.selection.style.position="absolute";
	        that.selection.style.top = 0+"px";
	        that.selection.style.left = 0+"px";
	        that.eagleEyeNode.appendChild(this.selection);
	    };
	    Minimap.prototype.updataSelection = function(offectLeft,offectTop,zoomScale,nowZoom){
	        var that = this;
	        that.zoomScale = zoomScale;
	        this.selection.style.width = this.selection.style.width.replace("px","")/zoomScale+"px";
	        this.selection.style.height = this.selection.style.height.replace("px","")/zoomScale+"px";
	        that.selectPosition[0] = zrUtil.clone(offectLeft)*that.ratio/nowZoom;
	        that.selectPosition[1] = zrUtil.clone(offectTop)*that.ratio/nowZoom;
	        this.selection.style.left = -that.selectPosition[0]+"px";
	        this.selection.style.top = -that.selectPosition[1]+"px";
	    };
	    Minimap.prototype.updataMap = function(imgSrc,newGroup){
	        var that = this;
	        that.eagleEyeNode.style.backgroundImage = "url("+imgSrc+")";
	        var eagleEyeNodeWidth = newGroup.width  * that.ratio;
	        var eagleEyeNodeHeight = newGroup.height  * that.ratio;
	        that.eagleEyeNode.style.width = eagleEyeNodeWidth+"px";
	        that.eagleEyeNode.style.height = eagleEyeNodeHeight+"px";
	        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+"px";
	        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+"px";
	    };
	    Minimap.prototype.updataSelectionPosition = function(nowGroupPosition,nowZoom){
	        var that = this;
	        that.selectPosition[0] = zrUtil.clone(nowGroupPosition[0])*that.ratio/nowZoom;
	        that.selectPosition[1] = zrUtil.clone(nowGroupPosition[1])*that.ratio/nowZoom;
	        this.selection.style.left = -that.selectPosition[0]+"px";
	        this.selection.style.top = -that.selectPosition[1]+"px";
	    };
	    Minimap.prototype.updataGroupPosition = function(group,nowZoom){
	        var that = this;
	        var positionX = -Number(that.selection.style.left.substring(0,that.selection.style.left.length-2))/that.ratio*nowZoom;
	        var positionY = -Number(that.selection.style.top.substring(0,that.selection.style.top.length-2))/that.ratio*nowZoom;
	        group.attr("position",[positionX,positionY]);
	    };
	
	    module.exports = Minimap;
	


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 工具方法类
	 * @author wang.xiaohu
	 */
	
	    var Point = __webpack_require__(66);
	    var Line = __webpack_require__(67);
	    var BoundingRect = __webpack_require__(27);
	    var zrUtil = __webpack_require__(5);
	    /**
	     * 构造类继承关系
	     *
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
	    function inherits(clazz, baseClazz) {
	        var clazzPrototype = clazz.prototype;
	
	        function F() {}
	        F.prototype = baseClazz.prototype;
	        clazz.prototype = new F();
	
	        for (var prop in clazzPrototype) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	        clazz.prototype.constructor = clazz;
	        clazz.superClass = baseClazz;
	    }
	
	    function getUUID() {
	        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),
	            uuid = new Array(36),
	            rnd = 0,
	            r;
	        for (var i = 0; i < 36; i++) {
	            if (i == 8 || i == 13 || i == 18 || i == 23) {
	                uuid[i] = '-';
	            } else if (i == 14) {
	                uuid[i] = '4';
	            } else {
	                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
	                r = rnd & 0xf;
	                rnd = rnd >> 4;
	                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
	            }
	        }
	        return "sid-" + uuid.join('');
	    }
	
	
	    /**
	     * 计算两点之间的距离
	     *@param {Point} p1 - first {Point}
	     *@param {Point} p2 - second {Point}
	     *@return {Number} - the distance between those 2 points. It is always positive.
	     **/
	    function distance(p1, p2) {
	        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
	    }
	
	    /**
	     * 返回一条折线 最长的两个点
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    function getMaxLineLength(points) {
	        var m = distance(points[0], points[1]);
	        var result = [points[0], points[1]];
	        for (var i = 1; i < points.length - 1; i++) {
	
	            if (m < distance(points[i], points[i + 1])) {
	                m = distance(points[i], points[i + 1])
	                result = [points[i], points[i + 1]];
	            }
	        }
	
	        return result;
	    }
	
	    /**Returns the length of a Polyline that would be created with a set of points
	     *@param {Array} v - an {Array} of {Points}
	     *@return {Number} - a positive number equal with total length*/
	    function getPolylineLength(v) {
	        var l = 0;
	        for (var i = 0; i < v.length - 1; i++) {
	            l += distance(v[i], v[i + 1]);
	        }
	
	        return l;
	    }
	
	
	    /**Returns the max of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the maximum number from the vector or NaN if vector is empty
	     **/
	    function max(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m < v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	
	    /**Returns the min of a vector
	     *@param {Array} v - vector of {Number}s
	     *@return {Number} - the minimum number from the vector or NaN if vector is empty
	     *@author alex@scriptoid.com
	     **/
	    function min(v) {
	        if (v.lenght == 0) {
	            return NaN;
	        } else {
	            var m = v[0];
	            for (var i = 0; i < v.length; i++) {
	                if (m > v[i]) {
	                    m = v[i];
	                }
	            }
	
	            return m;
	        }
	    }
	
	    /**
	     * 判断 点数组 是否正交直线路径
	     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function orthogonalPath(v) {
	        if (v.length <= 1) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 1; i++) {
	            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	
	
	    /**
	     *Test to see if 2 {Line}s intersects. They are considered finite segments
	     *and not the infinite lines from geometry
	     *@param {Line} l1 - fist line/segment
	     *@param {Line} l2 - last line/segment
	     *@return {Boolean} true - if the lines intersect or false if not
	     **/
	    function lineIntersectsLine(l1, l2) {
	        // check for two vertical lines
	        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {
	            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,
	                // then check segment bounds for overlapping
	                l1.contains(l2.startPoint.x, l2.startPoint.y) ||
	                l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                // lines are paralel
	                false;
	        }
	        // if one line is vertical, and another line is not vertical
	        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {
	            // let assume l2 is vertical, otherwise exchange them
	            if (l1.startPoint.x == l1.endPoint.x) {
	                var l = l1;
	                l1 = l2;
	                l2 = l;
	            }
	            // finding intersection of 'infinite' lines
	            // equation of the first line is y = ax + b, second: x = c
	            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b = l1.startPoint.y - a * l1.startPoint.x;
	            var x0 = l2.startPoint.x;
	            var y0 = a * x0 + b;
	            return l1.contains(x0, y0) && l2.contains(x0, y0);
	        }
	
	        // check normal case - both lines are not vertical
	        else {
	            //line equation is : y = a*x + b, b = y - a * x
	            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);
	            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;
	
	            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);
	            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;
	
	            if (a1 == a2) { //paralel lines
	                return b1 == b2 ?
	                    // for coincide lines, check for segment bounds overlapping
	                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :
	                    // not coincide paralel lines have no chance to intersect
	                    false;
	            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment
	
	                /*
	                 * if one of the lines are vertical, then x0 is equal to their x,
	                 * otherwise:
	                 * y1 = a1 * x + b1
	                 * y2 = a2 * x + b2
	                 * => x0 = (b2 - b1) / (a1 - a2)
	                 * => y0 = a1 * x0 + b1
	                 **/
	                x0 = (b2 - b1) / (a1 - a2);
	                y0 = a1 * x0 + b1;
	                return l1.contains(x0, y0) && l2.contains(x0, y0);
	            }
	        }
	    }
	
	    /**
	     *
	     *Tests if a a polyline defined by a set of points intersects a rectangle
	     *@param {Array} points - and {Array} of {Point}s
	     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)
	     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false
	     *
	     *@return true - if line intersects the rectangle, false - if not
	     **/
	    function polylineIntersectsRectangle(points, bounds, closedPolyline) {
	
	
	        //get the 4 lines/segments represented by the bounds
	        var lines = [];
	        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));
	        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));
	        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));
	        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));
	
	        for (var k = 0; k < points.length - 1; k++) {
	            //create a line out of each 2 consecutive points
	            var tempLine = new Line(points[k], points[k + 1]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var i = 0; i < lines.length; i++) {
	                if (lineIntersectsLine(tempLine, lines[i])) {
	                    return true;
	                }
	            }
	        }
	
	        //check the closed figure - that is last point connected to the first
	        if (closedPolyline) {
	            //create a line out of each 2 consecutive points
	            var tempLine1 = new Line(points[points.length - 1], points[0]);
	
	            //see if that line intersect any of the line on bounds border
	            for (var j = 0; j < lines.length; j++) {
	                if (lineIntersectsLine(tempLine1, lines[j])) {
	                    return true;
	                }
	            }
	        }
	
	        return false;
	    }
	
	    /**
	     * 计算路径的分数
	     * Score a ortogonal path made out of Points
	     *Iterates over a set of points (minimum 3)
	     *For each 3 points (i, i+1, i+2) :
	     *  - if the 3rd one is after the 2nd on the same line we add +1
	     *  - if the 3rd is up or down related to the 2nd we do not do anything +0
	     *  - if the 3rd goes back we imediatelly return -1
	     *@param {Array} v - an array of {Point}s
	     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine
	     *  The bigger the number the smooth the path is
	     **/
	    function scorePath(v) {
	        if (v.length <= 2) {
	            return -1;
	        }
	
	        var score = 0;
	        for (var i = 1; i < v.length - 1; i++) {
	            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction
	                    score++;
	                } else { //going back - no good
	                    return -1;
	                }
	            } else { //not on same vertical nor horizontal
	                score--;
	            }
	        }
	
	        return score;
	    }
	
	    /**
	     * 返回数字符号（+ -)
	     * Returns the sign of a number
	     *@param {Number} x - the number
	     *@returns {Number}
	     *@see <a href="http://en.wikipedia.org/wiki/Sign_function">http://en.wikipedia.org/wiki/Sign_function</a>
	     **/
	    function signum(x) {
	        if (x > 0)
	            return 1;
	        else if (x < 0)
	            return -1;
	        else
	            return 0;
	    }
	
	    /**
	     * 判断 点数组 是不是有效路径（没有回路）
	     *Tests if a vector of points is a valid path (not going back)
	     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that
	     *@param {Array} v - an {Array} of {Point}s
	     *@return {Boolean} - true if path is valid, false otherwise
	     **/
	    function forwardPath(v) {
	        if (v.length <= 2) {
	            return true;
	        }
	
	        for (var i = 0; i < v.length - 2; i++) {
	            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical
	                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal
	                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path
	                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)
	                        return false;
	                    }
	                }
	            }
	        }
	
	        return true;
	    }
	
	    /**
	     * 将[x:0,y:0]转化为[0, 0]  给zrender使用
	     * @param  {[type]} points [description]
	     * @param  {[type]} isRevert [description]
	     * @return {[type]}        [description]
	     */
	    function traslatePoints(points, isRevert) {
	        var newPoints = [];
	        if (isRevert) {
	            for (var i = 0; i < points.length; i++) {
	                var point = points[i];
	                newPoints.push(new Point(point[0], point[1]));
	            }
	            return newPoints;
	        } else {
	            for (var j = 0; j < points.length; j++) {
	                var point1 = points[j];
	                newPoints.push([point1.x, point1.y]);
	            }
	            return newPoints;
	        }
	
	
	    }
	
	    function rotationMatrix(angle) {
	        var mReturn = [
	            [Math.cos(angle), -Math.sin(angle), 0],
	            [Math.sin(angle), Math.cos(angle), 0],
	            [0, 0, 1]
	        ];
	        return mReturn;
	    }
	
	    function translationMatrix(dx, dy) {
	        return [
	            [1, 0, dx],
	            [0, 1, dy],
	            [0, 0, 1]
	        ];
	    }
	
	    function scaleMatrix(sx, sy) {
	        if (sy == null) {
	            sy = sx;
	        }
	        return [
	            [sx, 0, 0],
	            [0, sy, 0],
	            [0, 0, 1]
	        ];
	    }
	
	    /** It will return the end point of a line on a given angle (clockwise).
	     * @param {Point} startPoint - the start of the line
	     * @param {Number} length - the length of the line
	     * @param {Number} angle - the angle of the line in radians
	     * @return {Point} - the endPoint of the line
	     */
	    function getEndPoint(startPoint, length, angle) {
	        var endPoint = startPoint.clone();
	        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));
	        endPoint.y -= length;
	        endPoint.transform(rotationMatrix(angle));
	        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));
	        return endPoint;
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getConnectorPoints(node) {
	        return {
	            left: new Point(node.x, node.y + node.height / 2), //矩形 左中的位置
	            top: new Point(node.x + node.width / 2, node.y), //矩形 上中的位置
	            right: new Point(node.x + node.width, node.y + node.height / 2), //矩形 右中的位置
	            bottom: new Point(node.x + node.width / 2, node.y + node.height), //矩形 下中的位置
	            center: new Point(node.x + node.width / 2, node.y + node.height / 2) //中间位置
	
	        };
	    }
	
	    /**
	     * 获取获取两个图形的外面四个连接点
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    function getSoltPoints(node) {
	        return [
	            //top
	            [Math.round(node.getRect().width / 3 /10)*10, 0 ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],
	            //right
	            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],
	            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],
	            //bottom
	            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],
	            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],
	            //left
	            [0, Math.round(node.getRect().height / 3 /10)*10 ],
	            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]
	
	        ]
	    }
	
	    /**
	     * 计算 p1 p2两点所连接的直线的角度
	     * @param  {[type]} p1 [description]
	     * @param  {[type]} p2 [description]
	     * @return {[type]}    [description]
	     */
	    function tangentRotation(p1, p2) {
	        return -Math.PI / 2 - Math.atan2(
	            p2.y - p1.y, p2.x - p1.x
	        );
	    }
	
	    /**
	     * 判断3点是否在一条直线上
	     * Tests if 3 points are coliniar with matrix determinants.
	     * If the determinat of matrix
	     * /         \
	     * | x1 y1 1 |
	     * | x2 y2 1 |
	     * | x3 y3 1 |
	     * \         /
	     * is zero it means that the points are colinear
	     *@param {Point} p1 - first point
	     *@param {Point} p2 - second point
	     *@param {Point} p3 - third point
	     * @param {Number} precission
	     *@return {Boolean} - true if coliniar and false if not
	     *@author Alex
	     *@see http://en.wikipedia.org/wiki/Determinant
	     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html
	     **/
	    function collinearity(p1, p2, p3, precission) {
	        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);
	
	        if (precission) {
	            return Math.abs(determinant) <= precission;
	        } else {
	            return determinant === 0;
	        }
	    }
	
	
	    /**
	     * 四舍五入 保存decimals的小数
	     **/
	    function enhancedRound(number, decimals) {
	        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	    }
	
	    /**
	     * 获取两点之间的长度
	     **/
	    function getLength(startPoint, endPoint) {
	        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));
	    }
	
	    /**
	     * 获取角度
	     * @param  {[type]} centerPoint  [description]
	     * @param  {[type]} outsidePoint [description]
	     * @param  {[type]} round        [description]
	     * @return {[type]}              [description]
	     */
	    function getAngle(centerPoint, outsidePoint, round) {
	        centerPoint.x = enhancedRound(centerPoint.x, 5);
	        centerPoint.y = enhancedRound(centerPoint.y, 5);
	        outsidePoint.x = enhancedRound(outsidePoint.x, 5);
	        outsidePoint.y = enhancedRound(outsidePoint.y, 5);
	        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));
	        angle = -angle;
	
	        //endAngle+=90;
	        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {
	            angle += Math.PI;
	        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {
	            angle += Math.PI * 2;
	        }
	        while (angle >= Math.PI * 2) {
	            angle -= Math.PI * 2;
	        }
	        if (isNaN(angle)) { //Nan
	            angle = 0; //we are at center point;
	        }
	        if (round) {
	            angle = Math.round(angle / round) * round
	        }
	        return angle;
	    }
	
	    function getRect(node, isCalcParent) {
	        var boundingRect = node.getBoundingRect();
	        //创建最小包围盒虚线
	        var points = [];
	        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];
	        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];
	        points[2] = [boundingRect.width / 2, boundingRect.height / 2];
	        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];
	        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];
	
	        var positionX = node.position[0];
	        var positionY = node.position[1];
	        //这里要循环判断一把 有没有父节点 并且父节点不是根节点 然后进行相加
	        if (node.parent.type === "GroupNode" && isCalcParent) {
	            positionX = positionX + node.parent.position[0];
	            positionY = positionY + node.parent.position[1];
	        }
	
	        var boundRect = new BoundingRect(
	                Number(positionX + boundingRect.x),   //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半
	                Number(positionY + boundingRect.y),
	                Number(boundingRect.width),
	                Number(boundingRect.height)
	            );
	        //中心点
	        var cx = Number(node.position[0]) + Number(boundingRect.width) / 2 + Number(boundingRect.x);
	        var cy = Number(node.position[1]) + Number(boundingRect.height) / 2 + Number(boundingRect.y);
	        return {
	            x: Number(cx),
	            y: Number(cy),
	            width: Number(boundingRect.width),
	            height: Number(boundingRect.height),
	            points: points,
	            boundingRect: boundRect
	        };
	    }
	
	    var StackedMap = {
	        createNew: function() {
	            var stack = [];
	
	            return {
	                add: function(key, value) {
	                    var arrKey = this.get(key);
	                    arrKey.push(value)
	
	                },
	                get: function(key) {
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            return stack[i].value;
	                        }
	                    }
	                    //如果没有找到的话，则创建一个新的数组
	                    var value = [];
	                    stack.push({ key: key, value: value });
	                    return value;
	                },
	                keys: function() {
	                    var keys = [];
	                    for (var i = 0; i < stack.length; i++) {
	                        keys.push(stack[i].key);
	                    }
	                    return keys;
	                },
	                top: function() {
	                    return stack[stack.length - 1];
	                },
	                remove: function(key) {
	                    var idx = -1;
	                    for (var i = 0; i < stack.length; i++) {
	                        if (key == stack[i].key) {
	                            idx = i;
	                            break;
	                        }
	                    }
	                    return stack.splice(idx, 1)[0];
	                },
	                removeItem: function(key, item) {
	                    var arrKey = this.get(key);
	                    var index = zrUtil.indexOf(arrKey, item);
	                    arrKey.splice(index, 1);
	
	                },
	                removeTop: function() {
	                    return stack.splice(stack.length - 1, 1)[0];
	                },
	                length: function() {
	                    return stack.length;
	                },
	                clear: function() {
	                    stack.splice(0, stack.length);
	                }
	            };
	        }
	    };
	
	    function randomColor() {
	        var arrHex = ["0", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d"],
	            strHex = "#",
	            index;
	        for (var i = 0; i < 6; i++) {
	            index = Math.round(Math.random() * 15);
	            strHex += arrHex[index];
	        }
	        return strHex;
	    }
	
	    function isUndefined(obj) {
	        return obj === void 0;
	    }
	
	    function collinearReduction (v) {
	        var r = [];
	
	        if(v.length < 3){
	            return Point.cloneArray(v);
	        }
	
	        r.push( v[0].clone() );
	        for(var i=1; i < v.length-1; i++){
	            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )
	            {
	                continue;
	            }
	            else{
	                r.push( v[i].clone() );
	            }
	        }
	        r.push( v[v.length-1].clone() );
	
	        return r;
	    }
	
	    // By default, Underscore uses ERB-style template delimiters, change the
	    // following template settings to use alternative delimiters.
	    var templateSettings = {
	        evaluate: /<%([\s\S]+?)%>/g,
	        interpolate: /<%=([\s\S]+?)%>/g,
	        escape: /<%-([\s\S]+?)%>/g
	    };
	
	    // When customizing `templateSettings`, if you don't want to define an
	    // interpolation, evaluation or escaping regex, we need one that is
	    // guaranteed not to match.
	    var noMatch = /(.)^/;
	
	    // Certain characters need to be escaped so that they can be put into a
	    // string literal.
	    var escapes = {
	        "'": "'",
	        '\\': '\\',
	        '\r': 'r',
	        '\n': 'n',
	        '\u2028': 'u2028',
	        '\u2029': 'u2029'
	    };
	
	    var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
	
	    var escapeChar = function(match) {
	        return '\\' + escapes[match];
	    };
	
	    // JavaScript micro-templating, similar to John Resig's implementation.
	    // Underscore templating handles arbitrary delimiters, preserves whitespace,
	    // and correctly escapes quotes within interpolated code.
	    // NB: `oldSettings` only exists for backwards compatibility.
	    function template(text, settings, oldSettings) {
	        if (!settings && oldSettings) settings = oldSettings;
	        settings = settings || {};
	        settings = zrUtil.defaults(settings, templateSettings, true);
	
	        // Combine delimiters into one regular expression via alternation.
	        var matcher = RegExp([
	            (settings.escape || noMatch).source,
	            (settings.interpolate || noMatch).source,
	            (settings.evaluate || noMatch).source
	        ].join('|') + '|$', 'g');
	
	        // Compile the template source, escaping string literals appropriately.
	        var index = 0;
	        var source = "__p+='";
	        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	            source += text.slice(index, offset).replace(escaper, escapeChar);
	            index = offset + match.length;
	
	            if (escape) {
	                source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	            } else if (interpolate) {
	                source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	            } else if (evaluate) {
	                source += "';\n" + evaluate + "\n__p+='";
	            }
	
	            // Adobe VMs need the match returned to produce the correct offest.
	            return match;
	        });
	        source += "';\n";
	
	        // If a variable is not specified, place data values in local scope.
	        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
	
	        source = "var __t,__p='',__j=Array.prototype.join," +
	            "print=function(){__p+=__j.call(arguments,'');};\n" +
	            source + 'return __p;\n';
	
	        try {
	            var render = new Function(settings.variable || 'obj', source);
	        } catch (e) {
	            e.source = source;
	            throw e;
	        }
	
	        var template = function(data) {
	            return render.call(this, data);
	        };
	
	        // Provide the compiled source as a convenience for precompilation.
	        var argument = settings.variable || 'obj';
	        template.source = 'function(' + argument + '){\n' + source + '}';
	
	        return template;
	    }
	
	    function isEmpty(obj) {
	        if (obj == null) return true;
	        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;
	    }
	    function Class() {}
	    Class.extend = function(proto) {
	        var base = function() {},
	            member,
	            that = this,
	            subclass = proto && proto.init ? proto.init : function () {
	                that.apply(this, arguments);
	            },
	            fn;
	
	        base.prototype = that.prototype;
	        fn = subclass.fn = subclass.prototype = new base();
	
	        for (member in proto) {
	            if (proto[member] != null && proto[member].constructor === Object) {
	                // Merge object members
	                fn[member] = zrUtil.mergeAll([{}, base.prototype[member], proto[member]],true);
	            } else {
	                fn[member] = proto[member];
	            }
	        }
	
	        fn.constructor = subclass;
	        subclass.extend = that.extend;
	
	        return subclass;
	    };
	
	    module.exports = {
	        inherits: inherits,
	        getUUID: getUUID,
	        distance: distance,
	        getPolylineLength: getPolylineLength,
	        max: max,
	        min: min,
	        isEmpty: isEmpty,
	        orthogonalPath: orthogonalPath,
	        polylineIntersectsRectangle: polylineIntersectsRectangle,
	        scorePath: scorePath,
	        forwardPath: forwardPath,
	        traslatePoints: traslatePoints,
	        getEndPoint: getEndPoint,
	        getConnectorPoints: getConnectorPoints,
	        tangentRotation: tangentRotation,
	        collinearity: collinearity,
	        translationMatrix: translationMatrix,
	        scaleMatrix: scaleMatrix,
	        round: enhancedRound,
	        getLength: getLength,
	        getAngle: getAngle,
	        getRect: getRect,
	        StackedMap: StackedMap,
	        getMaxLineLength: getMaxLineLength,
	        randomColor: randomColor,
	        template: template,
	        isUndefined: isUndefined,
	        getSoltPoints:getSoltPoints,
	        collinearReduction: collinearReduction,
	        Class:Class
	    };
	


/***/ }),
/* 66 */
/***/ (function(module, exports) {

	
	
	    /**
	      * Creates an instance of Point
	      *
	      *
	      * @constructor
	      * @this {Point}
	      * @param {Number} x The x coordinate of point.
	      * @param {Number} y The y coordinate of point.
	      * Note: Even if it is named Point this class should be named Dot as Dot is closer
	      * then Point from math perspective.
	      **/
	    function Point(x, y){
	        /**The x coordinate of point*/
	        this.x = x;
	
	        /**The y coordinate of point*/
	        this.y = y;
	
	
	    }
	
	    /**Creates a {Point} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Point} a newly constructed Point
	     **/
	    Point.load = function(o){
	        var newPoint = new Point(Number(o.x), Number(o.y));
	        return newPoint;
	    };
	
	
	    /**Creates an array of points from an array of {JSONObject}s
	     *@param {Array} v - the array of JSONObjects
	     *@return an {Array} of {Point}s
	     **/
	    Point.loadArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(Point.load(v[i]));
	        }
	        return newPoints;
	    };
	
	
	    /**Clones an array of points
	     *@param {Array} v - the array of {Point}s
	     *@return an {Array} of {Point}s
	     **/
	    Point.cloneArray = function(v){
	        var newPoints = [];
	        for(var i=0; i< v.length; i++){
	            newPoints.push(v[i].clone());
	        }
	        return newPoints;
	    };
	
	    Point.prototype = {
	        constructor : Point,
	
	        transform:function(matrix){
	            var oldX = this.x;
	            var oldY = this.y;
	            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];
	            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];
	        },
	
	        /**Tests if this point is similar to other point
	         *@param {Point} anotherPoint - the other point
	         **/
	        equals:function(anotherPoint){
	            if(! (anotherPoint instanceof Point) ){
	                return false;
	            }
	            return (this.x == anotherPoint.x)
	            && (this.y == anotherPoint.y)
	        },
	
	        /**Clone current Point
	         **/
	        clone: function(){
	            var newPoint = new Point(this.x, this.y);
	            return newPoint;
	        },
	
	        add: function(point) {
	            this.x = this.x + point.x;
	            this.y = this.y + point.y;
	            return this;
	        },
	
	        /**Tests to see if a point (x, y) is within a range of current Point
	         *@param {Numeric} x - the x coordinate of tested point
	         *@param {Numeric} y - the x coordinate of tested point
	         *@param {Numeric} radius - the radius of the vicinity
	         **/
	        near:function(x, y, radius){
	            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));
	
	            return (distance <= radius);
	        },
	
	        contains: function(x,y){
	            return this.x == x && this.y == y;
	        },
	
	        toString:function(){
	            return '[' + this.x + ',' + this.y + ']';
	        },
	
	        getPoints:function(){
	            return [this];
	        }
	    };
	    module.exports = Point;


/***/ }),
/* 67 */
/***/ (function(module, exports) {

	
	
	    /**
	      * Creates an instance of a Line. A Line is actually a segment and not a pure
	      * geometrical Line
	      *
	      * @constructor
	      * @this {Line}
	      * @param {Point} startPoint - starting point of the line
	      * @param {Point} endPoint - the ending point of the line
	      **/
	    function Line(startPoint, endPoint){
	        /**Starting {@link Point} of the line*/
	        this.startPoint = startPoint;
	
	        /**Ending {@link Point} of the line*/
	        this.endPoint = endPoint;
	
	        /**Serialization type*/
	        this.oType = 'Line'; //object type used for JSON deserialization
	    }
	
	    /**Creates a {Line} out of JSON parsed object
	     *@param {JSONObject} o - the JSON parsed object
	     *@return {Line} a newly constructed Line
	     **/
	    Line.load = function(o){
	        var newLine = new Line(
	            Point.load(o.startPoint),
	            Point.load(o.endPoint)
	        );
	
	        return newLine;
	    };
	
	    Line.prototype = {
	        contructor: Line,
	
	
	
	        clone:function(){
	            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());
	            return ret;
	        },
	
	        equals:function(anotherLine){
	            if(!anotherLine instanceof Line){
	                return false;
	            }
	            return this.startPoint.equals(anotherLine.startPoint)
	            && this.endPoint.equals(anotherLine.endPoint)
	        },
	
	        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)
	         * Algorithm: Compute line's equation and see if (x, y) verifies it.
	         * @param {Number} x - the X coordinates
	         * @param {Number} y - the Y coordinates
	         **/
	        contains: function(x, y){
	            // if the point is inside rectangle bounds of the segment
	            if (Math.min(this.startPoint.x, this.endPoint.x) <= x
	                && x <= Math.max(this.startPoint.x, this.endPoint.x)
	                && Math.min(this.startPoint.y, this.endPoint.y) <= y
	                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {
	
	                // check for vertical line
	                if (this.startPoint.x == this.endPoint.x) {
	                    return x == this.startPoint.x;
	                } else { // usual (not vertical) line can be represented as y = a * x + b
	                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);
	                    var b = this.startPoint.y - a * this.startPoint.x;
	                    return y == a * x + b;
	                }
	            } else {
	                return false;
	            }
	        },
	
	        /*
	         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)
	         *@param {Number} x - the x coordinates
	         *@param {Number} y - the y coordinates
	         *@param {Number} radius - the radius to search for
	         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	         *@see "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	         **/
	        near:function(x,y,radius){
	
	            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle
	                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)
	                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))
	                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;
	            }
	
	            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle
	                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)
	                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))
	                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;
	            }
	
	
	            var startX = Math.min(this.endPoint.x,this.startPoint.x);
	            var startY = Math.min(this.endPoint.y,this.startPoint.y);
	            var endX = Math.max(this.endPoint.x,this.startPoint.x);
	            var endY = Math.max(this.endPoint.y,this.startPoint.y);
	
	            /*We will compute the distance from point to the line
	             * by using the algorithm from
	             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
	             * */
	
	            //First we need to find a,b,c of the line equation ax + by + c = 0
	            var a = this.endPoint.y - this.startPoint.y;
	            var b = this.startPoint.x - this.endPoint.x;
	            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);
	
	            //Secondly we get the distance "Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227"
	            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );
	
	            //Thirdly we get coordinates of closest line's point to target point
	            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates
	            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );
	
	            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment
	                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment
	
	            return  r;
	
	        },
	
	        /**we need to create a new array each time, or we will affect the actual shape*/
	        getPoints:function(){
	            var points = [];
	            points.push(this.startPoint);
	            points.push(this.endPoint);
	            return points;
	        },
	
	        /**Return the {Point} corresponding the t certain t value
	         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/
	        getPoint: function(t){
	            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;
	            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;
	
	            return new Point(Xp, Yp);
	        },
	
	        // /**
	        //  * Returns the middle of the line
	        //  * @return {Point} the middle point
	        //  * */
	        // getMiddle : function(){
	        //     return Util.getMiddle(this.startPoint, this.endPoint);
	        // },
	
	
	        // getLength : function(){
	        //     return Util.getLength(this.startPoint, this.endPoint);
	        // },
	
	        // /**
	        //  *Get bounds for this line
	        //  *@author Alex Gheorghiu <alex@scriptoid.com>
	        //  **/
	        // getBounds:function(){
	        //     return Util.getBounds(this.getPoints());
	        // },
	
	        /**String representation*/
	        toString:function(){
	            return 'line(' + this.startPoint + ',' + this.endPoint + ')';
	        }
	    };
	    module.exports = Line;
	
	


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(5);
	
	    var apiList = [
	        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',
	        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',
	        "remove", "_getParentZr", "changeSelectConnectorType"
	    ];
	
	    function ExtensionAPI(instance) {
	        zrUtil.each(apiList, function (name) {
	            this[name] = zrUtil.bind(instance[name], instance);
	        }, this);
	    }
	
	    module.exports = ExtensionAPI;
	


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * ZRender, a high performance 2d drawing library.
	 *
	 * Copyright (c) 2013, Baidu Inc.
	 * All rights reserved.
	 *
	 * LICENSE
	 * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	 */
	// Global defines
	
	    var guid = __webpack_require__(11);
	    var env = __webpack_require__(50);
	    var zrUtil = __webpack_require__(5);
	
	    var Handler = __webpack_require__(70);
	    var Storage = __webpack_require__(71);
	    var Animation = __webpack_require__(73);
	    var HandlerProxy = __webpack_require__(76);
	
	    var useVML = !env.canvasSupported;
	
	    var painterCtors = {
	        canvas: __webpack_require__(78)
	    };
	
	    var instances = {};    // ZRender实例map索引
	
	    var zrender = {};
	
	    /**
	     * @type {string}
	     */
	    zrender.version = '3.6.3';
	
	    /**
	     * Initializing a zrender instance
	     * @param {HTMLElement} dom
	     * @param {Object} opts
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	     * @param {number} [opts.devicePixelRatio]
	     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
	     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
	     * @return {module:zrender/ZRender}
	     */
	    zrender.init = function (dom, opts) {
	        var zr = new ZRender(guid(), dom, opts);
	        instances[zr.id] = zr;
	        return zr;
	    };
	
	    /**
	     * Dispose zrender instance
	     * @param {module:zrender/ZRender} zr
	     */
	    zrender.dispose = function (zr) {
	        if (zr) {
	            zr.dispose();
	        }
	        else {
	            for (var key in instances) {
	                if (instances.hasOwnProperty(key)) {
	                    instances[key].dispose();
	                }
	            }
	            instances = {};
	        }
	
	        return zrender;
	    };
	
	    /**
	     * Get zrender instance by id
	     * @param {string} id zrender instance id
	     * @return {module:zrender/ZRender}
	     */
	    zrender.getInstance = function (id) {
	        return instances[id];
	    };
	
	    zrender.registerPainter = function (name, Ctor) {
	        painterCtors[name] = Ctor;
	    };
	
	    function delInstance(id) {
	        delete instances[id];
	    }
	
	    /**
	     * @module zrender/ZRender
	     */
	    /**
	     * @constructor
	     * @alias module:zrender/ZRender
	     * @param {string} id
	     * @param {HTMLElement} dom
	     * @param {Object} opts
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	     * @param {number} [opts.devicePixelRatio]
	     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
	     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
	     */
	    var ZRender = function (id, dom, opts) {
	
	        opts = opts || {};
	
	        /**
	         * @type {HTMLDomElement}
	         */
	        this.dom = dom;
	
	        /**
	         * @type {string}
	         */
	        this.id = id;
	
	        var self = this;
	        var storage = new Storage();
	
	        var rendererType = opts.renderer;
	        // TODO WebGL
	        if (useVML) {
	            if (!painterCtors.vml) {
	                throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
	            }
	            rendererType = 'vml';
	        }
	        else if (!rendererType || !painterCtors[rendererType]) {
	            rendererType = 'canvas';
	        }
	        var painter = new painterCtors[rendererType](dom, storage, opts);
	
	        this.storage = storage;
	        this.painter = painter;
	
	        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;
	        this.handler = new Handler(storage, painter, handerProxy, painter.root);
	
	        /**
	         * @type {module:zrender/animation/Animation}
	         */
	        this.animation = new Animation({
	            stage: {
	                update: zrUtil.bind(this.flush, this)
	            }
	        });
	        this.animation.start();
	
	        /**
	         * @type {boolean}
	         * @private
	         */
	        this._needsRefresh;
	
	        // 修改 storage.delFromStorage, 每次删除元素之前删除动画
	        // FIXME 有点ugly
	        var oldDelFromStorage = storage.delFromStorage;
	        var oldAddToStorage = storage.addToStorage;
	
	        storage.delFromStorage = function (el) {
	            oldDelFromStorage.call(storage, el);
	
	            el && el.removeSelfFromZr(self);
	        };
	
	        storage.addToStorage = function (el) {
	            oldAddToStorage.call(storage, el);
	
	            el.addSelfToZr(self);
	        };
	    };
	
	    ZRender.prototype = {
	
	        constructor: ZRender,
	        /**
	         * 获取实例唯一标识
	         * @return {string}
	         */
	        getId: function () {
	            return this.id;
	        },
	
	        /**
	         * 添加元素
	         * @param  {module:zrender/Element} el
	         */
	        add: function (el) {
	            this.storage.addRoot(el);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * 删除元素
	         * @param  {module:zrender/Element} el
	         */
	        remove: function (el) {
	            this.storage.delRoot(el);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Change configuration of layer
	         * @param {string} zLevel
	         * @param {Object} config
	         * @param {string} [config.clearColor=0] Clear color
	         * @param {string} [config.motionBlur=false] If enable motion blur
	         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
	        */
	        configLayer: function (zLevel, config) {
	            this.painter.configLayer(zLevel, config);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Repaint the canvas immediately
	         */
	        refreshImmediately: function () {
	            // var start = new Date();
	            // Clear needsRefresh ahead to avoid something wrong happens in refresh
	            // Or it will cause zrender refreshes again and again.
	            this._needsRefresh = false;
	            this.painter.refresh();
	            /**
	             * Avoid trigger zr.refresh in Element#beforeUpdate hook
	             */
	            this._needsRefresh = false;
	            // var end = new Date();
	
	            // var log = document.getElementById('log');
	            // if (log) {
	            //     log.innerHTML = log.innerHTML + '<br>' + (end - start);
	            // }
	        },
	
	        /**
	         * Mark and repaint the canvas in the next frame of browser
	         */
	        refresh: function() {
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Perform all refresh
	         */
	        flush: function () {
	            if (this._needsRefresh) {
	                this.refreshImmediately();
	            }
	            if (this._needsRefreshHover) {
	                this.refreshHoverImmediately();
	            }
	        },
	
	        /**
	         * Add element to hover layer
	         * @param  {module:zrender/Element} el
	         * @param {Object} style
	         */
	        addHover: function (el, style) {
	            if (this.painter.addHover) {
	                this.painter.addHover(el, style);
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Add element from hover layer
	         * @param  {module:zrender/Element} el
	         */
	        removeHover: function (el) {
	            if (this.painter.removeHover) {
	                this.painter.removeHover(el);
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Clear all hover elements in hover layer
	         * @param  {module:zrender/Element} el
	         */
	        clearHover: function () {
	            if (this.painter.clearHover) {
	                this.painter.clearHover();
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Refresh hover in next frame
	         */
	        refreshHover: function () {
	            this._needsRefreshHover = true;
	        },
	
	        /**
	         * Refresh hover immediately
	         */
	        refreshHoverImmediately: function () {
	            this._needsRefreshHover = false;
	            this.painter.refreshHover && this.painter.refreshHover();
	        },
	
	        /**
	         * Resize the canvas.
	         * Should be invoked when container size is changed
	         * @param {Object} [opts]
	         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
	         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
	         */
	        resize: function(opts) {
	            opts = opts || {};
	            this.painter.resize(opts.width, opts.height);
	            this.handler.resize();
	        },
	
	        /**
	         * Stop and clear all animation immediately
	         */
	        clearAnimation: function () {
	            this.animation.clear();
	        },
	
	        /**
	         * Get container width
	         */
	        getWidth: function() {
	            return this.painter.getWidth();
	        },
	
	        /**
	         * Get container height
	         */
	        getHeight: function() {
	            return this.painter.getHeight();
	        },
	
	        /**
	         * Export the canvas as Base64 URL
	         * @param {string} type
	         * @param {string} [backgroundColor='#fff']
	         * @return {string} Base64 URL
	         */
	        // toDataURL: function(type, backgroundColor) {
	        //     return this.painter.getRenderedCanvas({
	        //         backgroundColor: backgroundColor
	        //     }).toDataURL(type);
	        // },
	
	        /**
	         * Converting a path to image.
	         * It has much better performance of drawing image rather than drawing a vector path.
	         * @param {module:zrender/graphic/Path} e
	         * @param {number} width
	         * @param {number} height
	         */
	        pathToImage: function(e, dpr) {
	            return this.painter.pathToImage(e, dpr);
	        },
	
	        /**
	         * Set default cursor
	         * @param {string} [cursorStyle='default'] 例如 crosshair
	         */
	        setCursorStyle: function (cursorStyle) {
	            this.handler.setCursorStyle(cursorStyle);
	        },
	
	        /**
	         * Find hovered element
	         * @param {number} x
	         * @param {number} y
	         * @return {Object} {target, topTarget}
	         */
	        findHover: function (x, y) {
	            return this.handler.findHover(x, y);
	        },
	
	        /**
	         * Bind event
	         *
	         * @param {string} eventName Event name
	         * @param {Function} eventHandler Handler function
	         * @param {Object} [context] Context object
	         */
	        on: function(eventName, eventHandler, context) {
	            this.handler.on(eventName, eventHandler, context);
	        },
	
	        /**
	         * Unbind event
	         * @param {string} eventName Event name
	         * @param {Function} [eventHandler] Handler function
	         */
	        off: function(eventName, eventHandler) {
	            this.handler.off(eventName, eventHandler);
	        },
	
	        /**
	         * Trigger event manually
	         *
	         * @param {string} eventName Event name
	         * @param {event=} event Event object
	         */
	        trigger: function (eventName, event) {
	            this.handler.trigger(eventName, event);
	        },
	
	
	        /**
	         * Clear all objects and the canvas.
	         */
	        clear: function () {
	            this.storage.delRoot();
	            this.painter.clear();
	        },
	
	        /**
	         * Dispose self.
	         */
	        dispose: function () {
	            this.animation.stop();
	
	            this.clear();
	            this.storage.dispose();
	            this.painter.dispose();
	            this.handler.dispose();
	
	            this.animation =
	            this.storage =
	            this.painter =
	            this.handler = null;
	
	            delInstance(this.id);
	        }
	    };
	
	    module.exports = zrender;
	


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Handler
	 * @module zrender/Handler
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (shenyi.914@gmail.com)
	 */
	
	
	    var util = __webpack_require__(5);
	    var vec2 = __webpack_require__(15);
	    var Draggable = __webpack_require__(43);
	
	    var Eventful = __webpack_require__(12);
	
	    var SILENT = 'silent';
	
	    function makeEventPacket(eveType, targetInfo, event) {
	        return {
	            type: eveType,
	            event: event,
	            // target can only be an element that is not silent.
	            target: targetInfo.target,
	            // topTarget can be a silent element.
	            topTarget: targetInfo.topTarget,
	            cancelBubble: false,
	            offsetX: event.zrX,
	            offsetY: event.zrY,
	            gestureEvent: event.gestureEvent,
	            pinchX: event.pinchX,
	            pinchY: event.pinchY,
	            pinchScale: event.pinchScale,
	            wheelDelta: event.zrDelta,
	            zrByTouch: event.zrByTouch,
	            which: event.which
	        };
	    }
	
	    function EmptyProxy () {}
	    EmptyProxy.prototype.dispose = function () {};
	
	    var handlerNames = [
	        'click', 'dblclick', 'mousewheel', 'mouseout',
	        'mouseup', 'mousedown', 'mousemove', 'contextmenu'
	    ];
	    /**
	     * @alias module:zrender/Handler
	     * @constructor
	     * @extends module:zrender/mixin/Eventful
	     * @param {module:zrender/Storage} storage Storage instance.
	     * @param {module:zrender/Painter} painter Painter instance.
	     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
	     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
	     */
	    var Handler = function(storage, painter, proxy, painterRoot) {
	        Eventful.call(this);
	
	        this.storage = storage;
	
	        this.painter = painter;
	
	        this.painterRoot = painterRoot;
	
	        proxy = proxy || new EmptyProxy();
	
	        /**
	         * Proxy of event. can be Dom, WebGLSurface, etc.
	         */
	        this.proxy = proxy;
	
	        // Attach handler
	        proxy.handler = this;
	
	        /**
	         * {target, topTarget, x, y}
	         * @private
	         * @type {Object}
	         */
	        this._hovered = {};
	
	        /**
	         * @private
	         * @type {Date}
	         */
	        this._lastTouchMoment;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._lastX;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._lastY;
	
	
	        Draggable.call(this);
	
	        util.each(handlerNames, function (name) {
	            proxy.on && proxy.on(name, this[name], this);
	        }, this);
	    };
	
	    Handler.prototype = {
	
	        constructor: Handler,
	
	        mousemove: function (event) {
	            var x = event.zrX;
	            var y = event.zrY;
	
	            var lastHovered = this._hovered;
	            var lastHoveredTarget = lastHovered.target;
	
	            // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call
	            // (like 'setOption' or 'dispatchAction') in event handlers, we should find
	            // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.
	            // See #6198.
	            if (lastHoveredTarget && !lastHoveredTarget.__zr) {
	                lastHovered = this.findHover(lastHovered.x, lastHovered.y);
	                lastHoveredTarget = lastHovered.target;
	            }
	
	            var hovered = this._hovered = this.findHover(x, y);
	            var hoveredTarget = hovered.target;
	
	            var proxy = this.proxy;
	            proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');
	
	            // Mouse out on previous hovered element
	            if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
	                this.dispatchToElement(lastHovered, 'mouseout', event);
	            }
	
	            // Mouse moving on one element
	            this.dispatchToElement(hovered, 'mousemove', event);
	
	            // Mouse over on a new element
	            if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
	                this.dispatchToElement(hovered, 'mouseover', event);
	            }
	        },
	
	        mouseout: function (event) {
	            this.dispatchToElement(this._hovered, 'mouseout', event);
	
	            // There might be some doms created by upper layer application
	            // at the same level of painter.getViewportRoot() (e.g., tooltip
	            // dom created by echarts), where 'globalout' event should not
	            // be triggered when mouse enters these doms. (But 'mouseout'
	            // should be triggered at the original hovered element as usual).
	            var element = event.toElement || event.relatedTarget;
	            var innerDom;
	            do {
	                element = element && element.parentNode;
	            }
	            while (element && element.nodeType != 9 && !(
	                innerDom = element === this.painterRoot
	            ));
	
	            !innerDom && this.trigger('globalout', {event: event});
	        },
	
	        /**
	         * Resize
	         */
	        resize: function (event) {
	            this._hovered = {};
	        },
	
	        /**
	         * Dispatch event
	         * @param {string} eventName
	         * @param {event=} eventArgs
	         */
	        dispatch: function (eventName, eventArgs) {
	            var handler = this[eventName];
	            handler && handler.call(this, eventArgs);
	        },
	
	        /**
	         * Dispose
	         */
	        dispose: function () {
	
	            this.proxy.dispose();
	
	            this.storage =
	            this.proxy =
	            this.painter = null;
	        },
	
	        /**
	         * 设置默认的cursor style
	         * @param {string} [cursorStyle='default'] 例如 crosshair
	         */
	        setCursorStyle: function (cursorStyle) {
	            var proxy = this.proxy;
	            proxy.setCursor && proxy.setCursor(cursorStyle);
	        },
	
	        /**
	         * 事件分发代理
	         *
	         * @private
	         * @param {Object} targetInfo {target, topTarget} 目标图形元素
	         * @param {string} eventName 事件名称
	         * @param {Object} event 事件对象
	         */
	        dispatchToElement: function (targetInfo, eventName, event) {
	            targetInfo = targetInfo || {};
	            var el = targetInfo.target;
	            if (el && el.silent) {
	                return;
	            }
	            var eventHandler = 'on' + eventName;
	            var eventPacket = makeEventPacket(eventName, targetInfo, event);
	
	            while (el) {
	                el[eventHandler]
	                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
	
	                el.trigger(eventName, eventPacket);
	
	                el = el.parent;
	
	                if (eventPacket.cancelBubble) {
	                    break;
	                }
	            }
	
	            if (!eventPacket.cancelBubble) {
	                // 冒泡到顶级 zrender 对象
	                this.trigger(eventName, eventPacket);
	                // 分发事件到用户自定义层
	                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在
	                this.painter && this.painter.eachOtherLayer(function (layer) {
	                    if (typeof(layer[eventHandler]) == 'function') {
	                        layer[eventHandler].call(layer, eventPacket);
	                    }
	                    if (layer.trigger) {
	                        layer.trigger(eventName, eventPacket);
	                    }
	                });
	            }
	        },
	
	        /**
	         * @private
	         * @param {number} x
	         * @param {number} y
	         * @param {module:zrender/graphic/Displayable} exclude
	         * @return {model:zrender/Element}
	         * @method
	         */
	        findHover: function(x, y, exclude) {
	            var list = this.storage.getDisplayList();
	            var out = {x: x, y: y};
	
	            for (var i = list.length - 1; i >= 0 ; i--) {
	                var hoverCheckResult;
	                if (list[i] !== exclude
	                    // getDisplayList may include ignored item in VML mode
	                    && !list[i].ignore
	                    && (hoverCheckResult = isHover(list[i], x, y))
	                ) {
	                    !out.topTarget && (out.topTarget = list[i]);
	                    if (hoverCheckResult !== SILENT) {
	                        out.target = list[i];
	                        break;
	                    }
	                }
	            }
	
	            return out;
	        }
	    };
	
	    // Common handlers
	    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
	        Handler.prototype[name] = function (event) {
	            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
	            var hovered = this.findHover(event.zrX, event.zrY);
	            var hoveredTarget = hovered.target;
	
	            if (name === 'mousedown') {
	                this._downEl = hoveredTarget;
	                this._downPoint = [event.zrX, event.zrY];
	                // In case click triggered before mouseup
	                this._upEl = hoveredTarget;
	            }
	            else if (name === 'mosueup') {
	                this._upEl = hoveredTarget;
	            }
	            else if (name === 'click') {
	                if (this._downEl !== this._upEl
	                    // Original click event is triggered on the whole canvas element,
	                    // including the case that `mousedown` - `mousemove` - `mouseup`,
	                    // which should be filtered, otherwise it will bring trouble to
	                    // pan and zoom.
	                    || !this._downPoint
	                    // Arbitrary value
	                    || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4
	                ) {
	                    return;
	                }
	                this._downPoint = null;
	            }
	
	            this.dispatchToElement(hovered, name, event);
	        };
	    });
	
	    function isHover(displayable, x, y) {
	        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
	            var el = displayable;
	            var isSilent;
	            while (el) {
	                // If clipped by ancestor.
	                // FIXME: If clipPath has neither stroke nor fill,
	                // el.clipPath.contain(x, y) will always return false.
	                if (el.clipPath && !el.clipPath.contain(x, y))  {
	                    return false;
	                }
	                if (el.silent) {
	                    isSilent = true;
	                }
	                el = el.parent;
	            }
	            return isSilent ? SILENT : true;
	        }
	
	        return false;
	    }
	
	    util.mixin(Handler, Eventful);
	    util.mixin(Handler, Draggable);
	
	    module.exports = Handler;
	


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Storage内容仓库模块
	 * @module zrender/Storage
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 * @author errorrik (errorrik@gmail.com)
	 * @author pissang (https://github.com/pissang/)
	 */
	
	
	    var util = __webpack_require__(5);
	    var env = __webpack_require__(50);
	
	    var Group = __webpack_require__(44);
	
	    // Use timsort because in most case elements are partially sorted
	    // https://jsfiddle.net/pissang/jr4x7mdm/8/
	    var timsort = __webpack_require__(72);
	
	    function shapeCompareFunc(a, b) {
	        if (a.zlevel === b.zlevel) {
	            if (a.z === b.z) {
	                // if (a.z2 === b.z2) {
	                //     // FIXME Slow has renderidx compare
	                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
	                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
	                //     return a.__renderidx - b.__renderidx;
	                // }
	                return a.z2 - b.z2;
	            }
	            return a.z - b.z;
	        }
	        return a.zlevel - b.zlevel;
	    }
	    /**
	     * 内容仓库 (M)
	     * @alias module:zrender/Storage
	     * @constructor
	     */
	    var Storage = function () {
	        this._roots = [];
	
	        this._displayList = [];
	
	        this._displayListLen = 0;
	    };
	
	    Storage.prototype = {
	
	        constructor: Storage,
	
	        /**
	         * @param  {Function} cb
	         *
	         */
	        traverse: function (cb, context) {
	            for (var i = 0; i < this._roots.length; i++) {
	                this._roots[i].traverse(cb, context);
	            }
	        },
	
	        /**
	         * 返回所有图形的绘制队列
	         * @param {boolean} [update=false] 是否在返回前更新该数组
	         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
	         *
	         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
	         * @return {Array.<module:zrender/graphic/Displayable>}
	         */
	        getDisplayList: function (update, includeIgnore) {
	            includeIgnore = includeIgnore || false;
	            if (update) {
	                this.updateDisplayList(includeIgnore);
	            }
	            return this._displayList;
	        },
	
	        /**
	         * 更新图形的绘制队列。
	         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
	         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
	         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
	         */
	        updateDisplayList: function (includeIgnore) {
	            this._displayListLen = 0;
	            var roots = this._roots;
	            var displayList = this._displayList;
	            for (var i = 0, len = roots.length; i < len; i++) {
	                this._updateAndAddDisplayable(roots[i], null, includeIgnore);
	            }
	            displayList.length = this._displayListLen;
	
	            // for (var i = 0, len = displayList.length; i < len; i++) {
	            //     displayList[i].__renderidx = i;
	            // }
	
	            // displayList.sort(shapeCompareFunc);
	            env.canvasSupported && timsort(displayList, shapeCompareFunc);
	        },
	
	        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
	
	            if (el.ignore && !includeIgnore) {
	                return;
	            }
	
	            el.beforeUpdate();
	
	            if (el.__dirty) {
	
	                el.update();
	
	            }
	
	            el.afterUpdate();
	
	            var userSetClipPath = el.clipPath;
	            if (userSetClipPath) {
	
	                // FIXME 效率影响
	                if (clipPaths) {
	                    clipPaths = clipPaths.slice();
	                }
	                else {
	                    clipPaths = [];
	                }
	
	                var currentClipPath = userSetClipPath;
	                var parentClipPath = el;
	                // Recursively add clip path
	                while (currentClipPath) {
	                    // clipPath 的变换是基于使用这个 clipPath 的元素
	                    currentClipPath.parent = parentClipPath;
	                    currentClipPath.updateTransform();
	
	                    clipPaths.push(currentClipPath);
	
	                    parentClipPath = currentClipPath;
	                    currentClipPath = currentClipPath.clipPath;
	                }
	            }
	
	            if (el.isGroup) {
	                var children = el._children;
	
	                for (var i = 0; i < children.length; i++) {
	                    var child = children[i];
	
	                    // Force to mark as dirty if group is dirty
	                    // FIXME __dirtyPath ?
	                    if (el.__dirty) {
	                        child.__dirty = true;
	                    }
	
	                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
	                }
	
	                // Mark group clean here
	                el.__dirty = false;
	
	            }
	            else {
	                el.__clipPaths = clipPaths;
	
	                this._displayList[this._displayListLen++] = el;
	            }
	        },
	
	        /**
	         * 添加图形(Shape)或者组(Group)到根节点
	         * @param {module:zrender/Element} el
	         */
	        addRoot: function (el) {
	            if (el.__storage === this) {
	                return;
	            }
	
	            if (el instanceof Group) {
	                el.addChildrenToStorage(this);
	            }
	
	            this.addToStorage(el);
	            this._roots.push(el);
	        },
	
	        /**
	         * 删除指定的图形(Shape)或者组(Group)
	         * @param {string|Array.<string>} [el] 如果为空清空整个Storage
	         */
	        delRoot: function (el) {
	            if (el == null) {
	                // 不指定el清空
	                for (var i = 0; i < this._roots.length; i++) {
	                    var root = this._roots[i];
	                    if (root instanceof Group) {
	                        root.delChildrenFromStorage(this);
	                    }
	                }
	
	                this._roots = [];
	                this._displayList = [];
	                this._displayListLen = 0;
	
	                return;
	            }
	
	            if (el instanceof Array) {
	                for (var i = 0, l = el.length; i < l; i++) {
	                    this.delRoot(el[i]);
	                }
	                return;
	            }
	
	
	            var idx = util.indexOf(this._roots, el);
	            if (idx >= 0) {
	                this.delFromStorage(el);
	                this._roots.splice(idx, 1);
	                if (el instanceof Group) {
	                    el.delChildrenFromStorage(this);
	                }
	            }
	        },
	
	        addToStorage: function (el) {
	            el.__storage = this;
	            el.dirty(false);
	
	            return this;
	        },
	
	        delFromStorage: function (el) {
	            if (el) {
	                el.__storage = null;
	            }
	
	            return this;
	        },
	
	        /**
	         * 清空并且释放Storage
	         */
	        dispose: function () {
	            this._renderList =
	            this._roots = null;
	        },
	
	        displayableSortFunc: shapeCompareFunc
	    };
	
	    module.exports = Storage;
	


/***/ }),
/* 72 */
/***/ (function(module, exports) {

	// https://github.com/mziccard/node-timsort
	
	    var DEFAULT_MIN_MERGE = 32;
	
	    var DEFAULT_MIN_GALLOPING = 7;
	
	    var DEFAULT_TMP_STORAGE_LENGTH = 256;
	
	    function minRunLength(n) {
	        var r = 0;
	
	        while (n >= DEFAULT_MIN_MERGE) {
	            r |= n & 1;
	            n >>= 1;
	        }
	
	        return n + r;
	    }
	
	    function makeAscendingRun(array, lo, hi, compare) {
	        var runHi = lo + 1;
	
	        if (runHi === hi) {
	            return 1;
	        }
	
	        if (compare(array[runHi++], array[lo]) < 0) {
	            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
	                runHi++;
	            }
	
	            reverseRun(array, lo, runHi);
	        }
	        else {
	            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
	                runHi++;
	            }
	        }
	
	        return runHi - lo;
	    }
	
	    function reverseRun(array, lo, hi) {
	        hi--;
	
	        while (lo < hi) {
	            var t = array[lo];
	            array[lo++] = array[hi];
	            array[hi--] = t;
	        }
	    }
	
	    function binaryInsertionSort(array, lo, hi, start, compare) {
	        if (start === lo) {
	            start++;
	        }
	
	        for (; start < hi; start++) {
	            var pivot = array[start];
	
	            var left = lo;
	            var right = start;
	            var mid;
	
	            while (left < right) {
	                mid = left + right >>> 1;
	
	                if (compare(pivot, array[mid]) < 0) {
	                    right = mid;
	                }
	                else {
	                    left = mid + 1;
	                }
	            }
	
	            var n = start - left;
	
	            switch (n) {
	                case 3:
	                    array[left + 3] = array[left + 2];
	
	                case 2:
	                    array[left + 2] = array[left + 1];
	
	                case 1:
	                    array[left + 1] = array[left];
	                    break;
	                default:
	                    while (n > 0) {
	                        array[left + n] = array[left + n - 1];
	                        n--;
	                    }
	            }
	
	            array[left] = pivot;
	        }
	    }
	
	    function gallopLeft(value, array, start, length, hint, compare) {
	        var lastOffset = 0;
	        var maxOffset = 0;
	        var offset = 1;
	
	        if (compare(value, array[start + hint]) > 0) {
	            maxOffset = length - hint;
	
	            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            lastOffset += hint;
	            offset += hint;
	        }
	        else {
	            maxOffset = hint + 1;
	            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            var tmp = lastOffset;
	            lastOffset = hint - offset;
	            offset = hint - tmp;
	        }
	
	        lastOffset++;
	        while (lastOffset < offset) {
	            var m = lastOffset + (offset - lastOffset >>> 1);
	
	            if (compare(value, array[start + m]) > 0) {
	                lastOffset = m + 1;
	            }
	            else {
	                offset = m;
	            }
	        }
	        return offset;
	    }
	
	    function gallopRight(value, array, start, length, hint, compare) {
	        var lastOffset = 0;
	        var maxOffset = 0;
	        var offset = 1;
	
	        if (compare(value, array[start + hint]) < 0) {
	            maxOffset = hint + 1;
	
	            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            var tmp = lastOffset;
	            lastOffset = hint - offset;
	            offset = hint - tmp;
	        }
	        else {
	            maxOffset = length - hint;
	
	            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            lastOffset += hint;
	            offset += hint;
	        }
	
	        lastOffset++;
	
	        while (lastOffset < offset) {
	            var m = lastOffset + (offset - lastOffset >>> 1);
	
	            if (compare(value, array[start + m]) < 0) {
	                offset = m;
	            }
	            else {
	                lastOffset = m + 1;
	            }
	        }
	
	        return offset;
	    }
	
	    function TimSort(array, compare) {
	        var minGallop = DEFAULT_MIN_GALLOPING;
	        var length = 0;
	        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
	        var stackLength = 0;
	        var runStart;
	        var runLength;
	        var stackSize = 0;
	
	        length = array.length;
	
	        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
	            tmpStorageLength = length >>> 1;
	        }
	
	        var tmp = [];
	
	        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
	
	        runStart = [];
	        runLength = [];
	
	        function pushRun(_runStart, _runLength) {
	            runStart[stackSize] = _runStart;
	            runLength[stackSize] = _runLength;
	            stackSize += 1;
	        }
	
	        function mergeRuns() {
	            while (stackSize > 1) {
	                var n = stackSize - 2;
	
	                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
	                    if (runLength[n - 1] < runLength[n + 1]) {
	                        n--;
	                    }
	                }
	                else if (runLength[n] > runLength[n + 1]) {
	                    break;
	                }
	                mergeAt(n);
	            }
	        }
	
	        function forceMergeRuns() {
	            while (stackSize > 1) {
	                var n = stackSize - 2;
	
	                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
	                    n--;
	                }
	
	                mergeAt(n);
	            }
	        }
	
	        function mergeAt(i) {
	            var start1 = runStart[i];
	            var length1 = runLength[i];
	            var start2 = runStart[i + 1];
	            var length2 = runLength[i + 1];
	
	            runLength[i] = length1 + length2;
	
	            if (i === stackSize - 3) {
	                runStart[i + 1] = runStart[i + 2];
	                runLength[i + 1] = runLength[i + 2];
	            }
	
	            stackSize--;
	
	            var k = gallopRight(array[start2], array, start1, length1, 0, compare);
	            start1 += k;
	            length1 -= k;
	
	            if (length1 === 0) {
	                return;
	            }
	
	            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
	
	            if (length2 === 0) {
	                return;
	            }
	
	            if (length1 <= length2) {
	                mergeLow(start1, length1, start2, length2);
	            }
	            else {
	                mergeHigh(start1, length1, start2, length2);
	            }
	        }
	
	        function mergeLow(start1, length1, start2, length2) {
	            var i = 0;
	
	            for (i = 0; i < length1; i++) {
	                tmp[i] = array[start1 + i];
	            }
	
	            var cursor1 = 0;
	            var cursor2 = start2;
	            var dest = start1;
	
	            array[dest++] = array[cursor2++];
	
	            if (--length2 === 0) {
	                for (i = 0; i < length1; i++) {
	                    array[dest + i] = tmp[cursor1 + i];
	                }
	                return;
	            }
	
	            if (length1 === 1) {
	                for (i = 0; i < length2; i++) {
	                    array[dest + i] = array[cursor2 + i];
	                }
	                array[dest + length2] = tmp[cursor1];
	                return;
	            }
	
	            var _minGallop = minGallop;
	            var count1, count2, exit;
	
	            while (1) {
	                count1 = 0;
	                count2 = 0;
	                exit = false;
	
	                do {
	                    if (compare(array[cursor2], tmp[cursor1]) < 0) {
	                        array[dest++] = array[cursor2++];
	                        count2++;
	                        count1 = 0;
	
	                        if (--length2 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    else {
	                        array[dest++] = tmp[cursor1++];
	                        count1++;
	                        count2 = 0;
	                        if (--length1 === 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                } while ((count1 | count2) < _minGallop);
	
	                if (exit) {
	                    break;
	                }
	
	                do {
	                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
	
	                    if (count1 !== 0) {
	                        for (i = 0; i < count1; i++) {
	                            array[dest + i] = tmp[cursor1 + i];
	                        }
	
	                        dest += count1;
	                        cursor1 += count1;
	                        length1 -= count1;
	                        if (length1 <= 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest++] = array[cursor2++];
	
	                    if (--length2 === 0) {
	                        exit = true;
	                        break;
	                    }
	
	                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
	
	                    if (count2 !== 0) {
	                        for (i = 0; i < count2; i++) {
	                            array[dest + i] = array[cursor2 + i];
	                        }
	
	                        dest += count2;
	                        cursor2 += count2;
	                        length2 -= count2;
	
	                        if (length2 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    array[dest++] = tmp[cursor1++];
	
	                    if (--length1 === 1) {
	                        exit = true;
	                        break;
	                    }
	
	                    _minGallop--;
	                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	                if (exit) {
	                    break;
	                }
	
	                if (_minGallop < 0) {
	                    _minGallop = 0;
	                }
	
	                _minGallop += 2;
	            }
	
	            minGallop = _minGallop;
	
	            minGallop < 1 && (minGallop = 1);
	
	            if (length1 === 1) {
	                for (i = 0; i < length2; i++) {
	                    array[dest + i] = array[cursor2 + i];
	                }
	                array[dest + length2] = tmp[cursor1];
	            }
	            else if (length1 === 0) {
	                throw new Error();
	                // throw new Error('mergeLow preconditions were not respected');
	            }
	            else {
	                for (i = 0; i < length1; i++) {
	                    array[dest + i] = tmp[cursor1 + i];
	                }
	            }
	        }
	
	        function mergeHigh (start1, length1, start2, length2) {
	            var i = 0;
	
	            for (i = 0; i < length2; i++) {
	                tmp[i] = array[start2 + i];
	            }
	
	            var cursor1 = start1 + length1 - 1;
	            var cursor2 = length2 - 1;
	            var dest = start2 + length2 - 1;
	            var customCursor = 0;
	            var customDest = 0;
	
	            array[dest--] = array[cursor1--];
	
	            if (--length1 === 0) {
	                customCursor = dest - (length2 - 1);
	
	                for (i = 0; i < length2; i++) {
	                    array[customCursor + i] = tmp[i];
	                }
	
	                return;
	            }
	
	            if (length2 === 1) {
	                dest -= length1;
	                cursor1 -= length1;
	                customDest = dest + 1;
	                customCursor = cursor1 + 1;
	
	                for (i = length1 - 1; i >= 0; i--) {
	                    array[customDest + i] = array[customCursor + i];
	                }
	
	                array[dest] = tmp[cursor2];
	                return;
	            }
	
	            var _minGallop = minGallop;
	
	            while (true) {
	                var count1 = 0;
	                var count2 = 0;
	                var exit = false;
	
	                do {
	                    if (compare(tmp[cursor2], array[cursor1]) < 0) {
	                        array[dest--] = array[cursor1--];
	                        count1++;
	                        count2 = 0;
	                        if (--length1 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    else {
	                        array[dest--] = tmp[cursor2--];
	                        count2++;
	                        count1 = 0;
	                        if (--length2 === 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                } while ((count1 | count2) < _minGallop);
	
	                if (exit) {
	                    break;
	                }
	
	                do {
	                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
	
	                    if (count1 !== 0) {
	                        dest -= count1;
	                        cursor1 -= count1;
	                        length1 -= count1;
	                        customDest = dest + 1;
	                        customCursor = cursor1 + 1;
	
	                        for (i = count1 - 1; i >= 0; i--) {
	                            array[customDest + i] = array[customCursor + i];
	                        }
	
	                        if (length1 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest--] = tmp[cursor2--];
	
	                    if (--length2 === 1) {
	                        exit = true;
	                        break;
	                    }
	
	                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
	
	                    if (count2 !== 0) {
	                        dest -= count2;
	                        cursor2 -= count2;
	                        length2 -= count2;
	                        customDest = dest + 1;
	                        customCursor = cursor2 + 1;
	
	                        for (i = 0; i < count2; i++) {
	                            array[customDest + i] = tmp[customCursor + i];
	                        }
	
	                        if (length2 <= 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest--] = array[cursor1--];
	
	                    if (--length1 === 0) {
	                        exit = true;
	                        break;
	                    }
	
	                    _minGallop--;
	                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	                if (exit) {
	                    break;
	                }
	
	                if (_minGallop < 0) {
	                    _minGallop = 0;
	                }
	
	                _minGallop += 2;
	            }
	
	            minGallop = _minGallop;
	
	            if (minGallop < 1) {
	                minGallop = 1;
	            }
	
	            if (length2 === 1) {
	                dest -= length1;
	                cursor1 -= length1;
	                customDest = dest + 1;
	                customCursor = cursor1 + 1;
	
	                for (i = length1 - 1; i >= 0; i--) {
	                    array[customDest + i] = array[customCursor + i];
	                }
	
	                array[dest] = tmp[cursor2];
	            }
	            else if (length2 === 0) {
	                throw new Error();
	                // throw new Error('mergeHigh preconditions were not respected');
	            }
	            else {
	                customCursor = dest - (length2 - 1);
	                for (i = 0; i < length2; i++) {
	                    array[customCursor + i] = tmp[i];
	                }
	            }
	        }
	
	        this.mergeRuns = mergeRuns;
	        this.forceMergeRuns = forceMergeRuns;
	        this.pushRun = pushRun;
	    }
	
	    function sort(array, compare, lo, hi) {
	        if (!lo) {
	            lo = 0;
	        }
	        if (!hi) {
	            hi = array.length;
	        }
	
	        var remaining = hi - lo;
	
	        if (remaining < 2) {
	            return;
	        }
	
	        var runLength = 0;
	
	        if (remaining < DEFAULT_MIN_MERGE) {
	            runLength = makeAscendingRun(array, lo, hi, compare);
	            binaryInsertionSort(array, lo, hi, lo + runLength, compare);
	            return;
	        }
	
	        var ts = new TimSort(array, compare);
	
	        var minRun = minRunLength(remaining);
	
	        do {
	            runLength = makeAscendingRun(array, lo, hi, compare);
	            if (runLength < minRun) {
	                var force = remaining;
	                if (force > minRun) {
	                    force = minRun;
	                }
	
	                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
	                runLength = force;
	            }
	
	            ts.pushRun(lo, runLength);
	            ts.mergeRuns();
	
	            remaining -= runLength;
	            lo += runLength;
	        } while (remaining !== 0);
	
	        ts.forceMergeRuns();
	    }
	
	    module.exports = sort;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 动画主类, 调度和管理所有动画控制器
	 *
	 * @module zrender/animation/Animation
	 * @author pissang(https://github.com/pissang)
	 */
	// TODO Additive animation
	// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
	// https://developer.apple.com/videos/wwdc2014/#236
	
	
	    var util = __webpack_require__(5);
	    var Dispatcher = __webpack_require__(74).Dispatcher;
	
	    var requestAnimationFrame = __webpack_require__(75);
	
	    var Animator = __webpack_require__(17);
	    /**
	     * @typedef {Object} IZRenderStage
	     * @property {Function} update
	     */
	
	    /**
	     * @alias module:zrender/animation/Animation
	     * @constructor
	     * @param {Object} [options]
	     * @param {Function} [options.onframe]
	     * @param {IZRenderStage} [options.stage]
	     * @example
	     *     var animation = new Animation();
	     *     var obj = {
	     *         x: 100,
	     *         y: 100
	     *     };
	     *     animation.animate(node.position)
	     *         .when(1000, {
	     *             x: 500,
	     *             y: 500
	     *         })
	     *         .when(2000, {
	     *             x: 100,
	     *             y: 100
	     *         })
	     *         .start('spline');
	     */
	    var Animation = function (options) {
	
	        options = options || {};
	
	        this.stage = options.stage || {};
	
	        this.onframe = options.onframe || function() {};
	
	        // private properties
	        this._clips = [];
	
	        this._running = false;
	
	        this._time;
	
	        this._pausedTime;
	
	        this._pauseStart;
	
	        this._paused = false;
	
	        Dispatcher.call(this);
	    };
	
	    Animation.prototype = {
	
	        constructor: Animation,
	        /**
	         * 添加 clip
	         * @param {module:zrender/animation/Clip} clip
	         */
	        addClip: function (clip) {
	            this._clips.push(clip);
	        },
	        /**
	         * 添加 animator
	         * @param {module:zrender/animation/Animator} animator
	         */
	        addAnimator: function (animator) {
	            animator.animation = this;
	            var clips = animator.getClips();
	            for (var i = 0; i < clips.length; i++) {
	                this.addClip(clips[i]);
	            }
	        },
	        /**
	         * 删除动画片段
	         * @param {module:zrender/animation/Clip} clip
	         */
	        removeClip: function(clip) {
	            var idx = util.indexOf(this._clips, clip);
	            if (idx >= 0) {
	                this._clips.splice(idx, 1);
	            }
	        },
	
	        /**
	         * 删除动画片段
	         * @param {module:zrender/animation/Animator} animator
	         */
	        removeAnimator: function (animator) {
	            var clips = animator.getClips();
	            for (var i = 0; i < clips.length; i++) {
	                this.removeClip(clips[i]);
	            }
	            animator.animation = null;
	        },
	
	        _update: function() {
	
	            var time = new Date().getTime() - this._pausedTime;
	            var delta = time - this._time;
	            var clips = this._clips;
	            var len = clips.length;
	
	            var deferredEvents = [];
	            var deferredClips = [];
	            for (var i = 0; i < len; i++) {
	                var clip = clips[i];
	                var e = clip.step(time, delta);
	                // Throw out the events need to be called after
	                // stage.update, like destroy
	                if (e) {
	                    deferredEvents.push(e);
	                    deferredClips.push(clip);
	                }
	            }
	
	            // Remove the finished clip
	            for (var i = 0; i < len;) {
	                if (clips[i]._needsRemove) {
	                    clips[i] = clips[len - 1];
	                    clips.pop();
	                    len--;
	                }
	                else {
	                    i++;
	                }
	            }
	
	            len = deferredEvents.length;
	            for (var i = 0; i < len; i++) {
	                deferredClips[i].fire(deferredEvents[i]);
	            }
	
	            this._time = time;
	
	            this.onframe(delta);
	
	            this.trigger('frame', delta);
	
	            if (this.stage.update) {
	                this.stage.update();
	            }
	        },
	
	        _startLoop: function () {
	            var self = this;
	
	            this._running = true;
	
	            function step() {
	                if (self._running) {
	
	                    requestAnimationFrame(step);
	
	                    !self._paused && self._update();
	                }
	            }
	
	            requestAnimationFrame(step);
	        },
	
	        /**
	         * 开始运行动画
	         */
	        start: function () {
	
	            this._time = new Date().getTime();
	            this._pausedTime = 0;
	
	            this._startLoop();
	        },
	        /**
	         * 停止运行动画
	         */
	        stop: function () {
	            this._running = false;
	        },
	
	        /**
	         * Pause
	         */
	        pause: function () {
	            if (!this._paused) {
	                this._pauseStart = new Date().getTime();
	                this._paused = true;
	            }
	        },
	
	        /**
	         * Resume
	         */
	        resume: function () {
	            if (this._paused) {
	                this._pausedTime += (new Date().getTime()) - this._pauseStart;
	                this._paused = false;
	            }
	        },
	
	        /**
	         * 清除所有动画片段
	         */
	        clear: function () {
	            this._clips = [];
	        },
	        /**
	         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
	         * @param  {Object} target
	         * @param  {Object} options
	         * @param  {boolean} [options.loop=false] 是否循环播放动画
	         * @param  {Function} [options.getter=null]
	         *         如果指定getter函数，会通过getter函数取属性值
	         * @param  {Function} [options.setter=null]
	         *         如果指定setter函数，会通过setter函数设置属性值
	         * @return {module:zrender/animation/Animation~Animator}
	         */
	        // TODO Gap
	        animate: function (target, options) {
	            options = options || {};
	
	            var animator = new Animator(
	                target,
	                options.loop,
	                options.getter,
	                options.setter
	            );
	
	            this.addAnimator(animator);
	
	            return animator;
	        }
	    };
	
	    util.mixin(Animation, Dispatcher);
	
	    module.exports = Animation;
	


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 事件辅助类
	 * @module zrender/core/event
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	
	
	    var Eventful = __webpack_require__(12);
	    var env = __webpack_require__(50);
	
	    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;
	
	    var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
	
	    function getBoundingClientRect(el) {
	        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
	        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};
	    }
	
	    // `calculate` is optional, default false
	    function clientToLocal(el, e, out, calculate) {
	        out = out || {};
	
	        // According to the W3C Working Draft, offsetX and offsetY should be relative
	        // to the padding edge of the target element. The only browser using this convention
	        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
	        // not support the properties.
	        // (see http://www.jacklmoore.com/notes/mouse-position/)
	        // In zr painter.dom, padding edge equals to border edge.
	
	        // FIXME
	        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and
	        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y
	        // is too complex. So css-transfrom dont support in this case temporarily.
	        if (calculate || !env.canvasSupported) {
	            defaultGetZrXY(el, e, out);
	        }
	        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
	        // ancestor element, so we should make sure el is positioned (e.g., not position:static).
	        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add
	        // zoom-factor, overflow / opacity layers, transforms ...)
	        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
	        // <https://bugs.jquery.com/ticket/8523#comment:14>
	        // BTW3, In ff, offsetX/offsetY is always 0.
	        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
	            out.zrX = e.layerX;
	            out.zrY = e.layerY;
	        }
	        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)
	        else if (e.offsetX != null) {
	            out.zrX = e.offsetX;
	            out.zrY = e.offsetY;
	        }
	        // For some other device, e.g., IOS safari.
	        else {
	            defaultGetZrXY(el, e, out);
	        }
	
	        return out;
	    }
	
	    function defaultGetZrXY(el, e, out) {
	        // This well-known method below does not support css transform.
	        var box = getBoundingClientRect(el);
	        out.zrX = e.clientX - box.left;
	        out.zrY = e.clientY - box.top;
	    }
	
	    /**
	     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.
	     * `calculate` is optional, default false.
	     */
	    function normalizeEvent(el, e, calculate) {
	
	        e = e || window.event;
	
	        if (e.zrX != null) {
	            return e;
	        }
	
	        var eventType = e.type;
	        var isTouch = eventType && eventType.indexOf('touch') >= 0;
	
	        if (!isTouch) {
	            clientToLocal(el, e, e, calculate);
	            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
	        }
	        else {
	            var touch = eventType != 'touchend'
	                ? e.targetTouches[0]
	                : e.changedTouches[0];
	            touch && clientToLocal(el, touch, e, calculate);
	        }
	
	        // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;
	        // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js
	        // If e.which has been defined, if may be readonly,
	        // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which
	        var button = e.button;
	        if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
	            e.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
	        }
	
	        return e;
	    }
	
	    function addEventListener(el, name, handler) {
	        if (isDomLevel2) {
	            el.addEventListener(name, handler);
	        }
	        else {
	            el.attachEvent('on' + name, handler);
	        }
	    }
	
	    function removeEventListener(el, name, handler) {
	        if (isDomLevel2) {
	            el.removeEventListener(name, handler);
	        }
	        else {
	            el.detachEvent('on' + name, handler);
	        }
	    }
	
	    /**
	     * preventDefault and stopPropagation.
	     * Notice: do not do that in zrender. Upper application
	     * do that if necessary.
	     *
	     * @memberOf module:zrender/core/event
	     * @method
	     * @param {Event} e : event对象
	     */
	    var stop = isDomLevel2
	        ? function (e) {
	            e.preventDefault();
	            e.stopPropagation();
	            e.cancelBubble = true;
	        }
	        : function (e) {
	            e.returnValue = false;
	            e.cancelBubble = true;
	        };
	
	    function notLeftMouse(e) {
	        // If e.which is undefined, considered as left mouse event.
	        return e.which > 1;
	    }
	
	    module.exports = {
	        clientToLocal: clientToLocal,
	        normalizeEvent: normalizeEvent,
	        addEventListener: addEventListener,
	        removeEventListener: removeEventListener,
	        notLeftMouse: notLeftMouse,
	
	        stop: stop,
	        // 做向上兼容
	        Dispatcher: Eventful
	    };
	


/***/ }),
/* 75 */
/***/ (function(module, exports) {

	
	
	    module.exports = (typeof window !== 'undefined' &&
	                ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window))
	                // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
	                || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))
	                || window.mozRequestAnimationFrame
	                || window.webkitRequestAnimationFrame)
	            )
	            || function (func) {
	                setTimeout(func, 16);
	            };
	


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var eventTool = __webpack_require__(74);
	    var zrUtil = __webpack_require__(5);
	    var Eventful = __webpack_require__(12);
	    var env = __webpack_require__(50);
	    var GestureMgr = __webpack_require__(77);
	
	    var addEventListener = eventTool.addEventListener;
	    var removeEventListener = eventTool.removeEventListener;
	    var normalizeEvent = eventTool.normalizeEvent;
	
	    var TOUCH_CLICK_DELAY = 300;
	
	    var mouseHandlerNames = [
	        'click', 'dblclick', 'mousewheel', 'mouseout',
	        'mouseup', 'mousedown', 'mousemove', 'contextmenu'
	    ];
	
	    var touchHandlerNames = [
	        'touchstart', 'touchend', 'touchmove'
	    ];
	
	    var pointerEventNames = {
	        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1
	    };
	
	    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {
	        var nm = name.replace('mouse', 'pointer');
	        return pointerEventNames[nm] ? nm : name;
	    });
	
	    function eventNameFix(name) {
	        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;
	    }
	
	    function processGesture(proxy, event, stage) {
	        var gestureMgr = proxy._gestureMgr;
	
	        stage === 'start' && gestureMgr.clear();
	
	        var gestureInfo = gestureMgr.recognize(
	            event,
	            proxy.handler.findHover(event.zrX, event.zrY, null).target,
	            proxy.dom
	        );
	
	        stage === 'end' && gestureMgr.clear();
	
	        // Do not do any preventDefault here. Upper application do that if necessary.
	        if (gestureInfo) {
	            var type = gestureInfo.type;
	            event.gestureEvent = type;
	
	            proxy.handler.dispatchToElement({target: gestureInfo.target}, type, gestureInfo.event);
	        }
	    }
	
	    // function onMSGestureChange(proxy, event) {
	    //     if (event.translationX || event.translationY) {
	    //         // mousemove is carried by MSGesture to reduce the sensitivity.
	    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);
	    //     }
	    //     if (event.scale !== 1) {
	    //         event.pinchX = event.offsetX;
	    //         event.pinchY = event.offsetY;
	    //         event.pinchScale = event.scale;
	    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);
	    //     }
	    // }
	
	    /**
	     * Prevent mouse event from being dispatched after Touch Events action
	     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
	     * 1. Mobile browsers dispatch mouse events 300ms after touchend.
	     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
	     * Result: Blocking Mouse Events for 700ms.
	     */
	    function setTouchTimer(instance) {
	        instance._touching = true;
	        clearTimeout(instance._touchTimer);
	        instance._touchTimer = setTimeout(function () {
	            instance._touching = false;
	        }, 700);
	    }
	
	
	    var domHandlers = {
	        /**
	         * Mouse move handler
	         * @inner
	         * @param {Event} event
	         */
	        mousemove: function (event) {
	            event = normalizeEvent(this.dom, event);
	
	            this.trigger('mousemove', event);
	        },
	
	        /**
	         * Mouse out handler
	         * @inner
	         * @param {Event} event
	         */
	        mouseout: function (event) {
	            event = normalizeEvent(this.dom, event);
	
	            var element = event.toElement || event.relatedTarget;
	            if (element != this.dom) {
	                while (element && element.nodeType != 9) {
	                    // 忽略包含在root中的dom引起的mouseOut
	                    if (element === this.dom) {
	                        return;
	                    }
	
	                    element = element.parentNode;
	                }
	            }
	
	            this.trigger('mouseout', event);
	        },
	
	        /**
	         * Touch开始响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchstart: function (event) {
	            // Default mouse behaviour should not be disabled here.
	            // For example, page may needs to be slided.
	            event = normalizeEvent(this.dom, event);
	
	            // Mark touch, which is useful in distinguish touch and
	            // mouse event in upper applicatoin.
	            event.zrByTouch = true;
	
	            this._lastTouchMoment = new Date();
	
	            processGesture(this, event, 'start');
	
	            // In touch device, trigger `mousemove`(`mouseover`) should
	            // be triggered, and must before `mousedown` triggered.
	            domHandlers.mousemove.call(this, event);
	
	            domHandlers.mousedown.call(this, event);
	
	            setTouchTimer(this);
	        },
	
	        /**
	         * Touch移动响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchmove: function (event) {
	
	            event = normalizeEvent(this.dom, event);
	
	            // Mark touch, which is useful in distinguish touch and
	            // mouse event in upper applicatoin.
	            event.zrByTouch = true;
	
	            processGesture(this, event, 'change');
	
	            // Mouse move should always be triggered no matter whether
	            // there is gestrue event, because mouse move and pinch may
	            // be used at the same time.
	            domHandlers.mousemove.call(this, event);
	
	            setTouchTimer(this);
	        },
	
	        /**
	         * Touch结束响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchend: function (event) {
	
	            event = normalizeEvent(this.dom, event);
	
	            // Mark touch, which is useful in distinguish touch and
	            // mouse event in upper applicatoin.
	            event.zrByTouch = true;
	
	            processGesture(this, event, 'end');
	
	            domHandlers.mouseup.call(this, event);
	
	            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
	            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,
	            // we can conveniently implement "hover style" in both PC and touch device just
	            // by listening to `mouseover` to add "hover style" and listening to `mouseout`
	            // to remove "hover style" on an element, without any additional code for
	            // compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
	            // style" will remain for user view)
	
	            // click event should always be triggered no matter whether
	            // there is gestrue event. System click can not be prevented.
	            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
	                domHandlers.click.call(this, event);
	            }
	
	            setTouchTimer(this);
	        },
	
	        pointerdown: function (event) {
	            domHandlers.mousedown.call(this, event);
	
	            // if (useMSGuesture(this, event)) {
	            //     this._msGesture.addPointer(event.pointerId);
	            // }
	        },
	
	        pointermove: function (event) {
	            // FIXME
	            // pointermove is so sensitive that it always triggered when
	            // tap(click) on touch screen, which affect some judgement in
	            // upper application. So, we dont support mousemove on MS touch
	            // device yet.
	            if (!isPointerFromTouch(event)) {
	                domHandlers.mousemove.call(this, event);
	            }
	        },
	
	        pointerup: function (event) {
	            domHandlers.mouseup.call(this, event);
	        },
	
	        pointerout: function (event) {
	            // pointerout will be triggered when tap on touch screen
	            // (IE11+/Edge on MS Surface) after click event triggered,
	            // which is inconsistent with the mousout behavior we defined
	            // in touchend. So we unify them.
	            // (check domHandlers.touchend for detailed explanation)
	            if (!isPointerFromTouch(event)) {
	                domHandlers.mouseout.call(this, event);
	            }
	        }
	    };
	
	    function isPointerFromTouch(event) {
	        var pointerType = event.pointerType;
	        return pointerType === 'pen' || pointerType === 'touch';
	    }
	
	    // function useMSGuesture(handlerProxy, event) {
	    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;
	    // }
	
	    // Common handlers
	    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
	        domHandlers[name] = function (event) {
	            event = normalizeEvent(this.dom, event);
	            this.trigger(name, event);
	        };
	    });
	
	    /**
	     * 为控制类实例初始化dom 事件处理函数
	     *
	     * @inner
	     * @param {module:zrender/Handler} instance 控制类实例
	     */
	    function initDomHandler(instance) {
	        zrUtil.each(touchHandlerNames, function (name) {
	            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	        });
	
	        zrUtil.each(pointerHandlerNames, function (name) {
	            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	        });
	
	        zrUtil.each(mouseHandlerNames, function (name) {
	            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
	        });
	
	        function makeMouseHandler(fn, instance) {
	            return function () {
	                if (instance._touching) {
	                    return;
	                }
	                return fn.apply(instance, arguments);
	            };
	        }
	    }
	
	
	    function HandlerDomProxy(dom) {
	        Eventful.call(this);
	
	        this.dom = dom;
	
	        /**
	         * @private
	         * @type {boolean}
	         */
	        this._touching = false;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._touchTimer;
	
	        /**
	         * @private
	         * @type {module:zrender/core/GestureMgr}
	         */
	        this._gestureMgr = new GestureMgr();
	
	        this._handlers = {};
	
	        initDomHandler(this);
	
	        if (env.pointerEventsSupported) { // Only IE11+/Edge
	            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),
	            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event
	            // at the same time.
	            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on
	            // screen, which do not occurs in pointer event.
	            // So we use pointer event to both detect touch gesture and mouse behavior.
	            mountHandlers(pointerHandlerNames, this);
	
	            // FIXME
	            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,
	            // which does not prevent defuault behavior occasionally (which may cause view port
	            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.
	            // So we have to not to use MSGesture and not to support touchmove and pinch on MS
	            // touch screen. And we only support click behavior on MS touch screen now.
	
	            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.
	            // We dont support touch on IE on win7.
	            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>
	            // if (typeof MSGesture === 'function') {
	            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line
	            //     dom.addEventListener('MSGestureChange', onMSGestureChange);
	            // }
	        }
	        else {
	            if (env.touchEventsSupported) {
	                mountHandlers(touchHandlerNames, this);
	                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
	                // addEventListener(root, 'mouseout', this._mouseoutHandler);
	            }
	
	            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface
	            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
	            // mouse event can not be handle in those devices.
	            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent
	            // mouseevent after touch event triggered, see `setTouchTimer`.
	            mountHandlers(mouseHandlerNames, this);
	        }
	
	        function mountHandlers(handlerNames, instance) {
	            zrUtil.each(handlerNames, function (name) {
	                addEventListener(dom, eventNameFix(name), instance._handlers[name]);
	            }, instance);
	        }
	    }
	
	    var handlerDomProxyProto = HandlerDomProxy.prototype;
	    handlerDomProxyProto.dispose = function () {
	        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);
	
	        for (var i = 0; i < handlerNames.length; i++) {
	            var name = handlerNames[i];
	            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
	        }
	    };
	
	    handlerDomProxyProto.setCursor = function (cursorStyle) {
	        this.dom.style.cursor = cursorStyle || 'default';
	    };
	
	    zrUtil.mixin(HandlerDomProxy, Eventful);
	
	    module.exports = HandlerDomProxy;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Only implements needed gestures for mobile.
	 */
	
	
	    var eventUtil = __webpack_require__(74);
	
	    var GestureMgr = function () {
	
	        /**
	         * @private
	         * @type {Array.<Object>}
	         */
	        this._track = [];
	    };
	
	    GestureMgr.prototype = {
	
	        constructor: GestureMgr,
	
	        recognize: function (event, target, root) {
	            this._doTrack(event, target, root);
	            return this._recognize(event);
	        },
	
	        clear: function () {
	            this._track.length = 0;
	            return this;
	        },
	
	        _doTrack: function (event, target, root) {
	            var touches = event.touches;
	
	            if (!touches) {
	                return;
	            }
	
	            var trackItem = {
	                points: [],
	                touches: [],
	                target: target,
	                event: event
	            };
	
	            for (var i = 0, len = touches.length; i < len; i++) {
	                var touch = touches[i];
	                var pos = eventUtil.clientToLocal(root, touch, {});
	                trackItem.points.push([pos.zrX, pos.zrY]);
	                trackItem.touches.push(touch);
	            }
	
	            this._track.push(trackItem);
	        },
	
	        _recognize: function (event) {
	            for (var eventName in recognizers) {
	                if (recognizers.hasOwnProperty(eventName)) {
	                    var gestureInfo = recognizers[eventName](this._track, event);
	                    if (gestureInfo) {
	                        return gestureInfo;
	                    }
	                }
	            }
	        }
	    };
	
	    function dist(pointPair) {
	        var dx = pointPair[1][0] - pointPair[0][0];
	        var dy = pointPair[1][1] - pointPair[0][1];
	
	        return Math.sqrt(dx * dx + dy * dy);
	    }
	
	    function center(pointPair) {
	        return [
	            (pointPair[0][0] + pointPair[1][0]) / 2,
	            (pointPair[0][1] + pointPair[1][1]) / 2
	        ];
	    }
	
	    var recognizers = {
	
	        pinch: function (track, event) {
	            var trackLen = track.length;
	
	            if (!trackLen) {
	                return;
	            }
	
	            var pinchEnd = (track[trackLen - 1] || {}).points;
	            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
	
	            if (pinchPre
	                && pinchPre.length > 1
	                && pinchEnd
	                && pinchEnd.length > 1
	            ) {
	                var pinchScale = dist(pinchEnd) / dist(pinchPre);
	                !isFinite(pinchScale) && (pinchScale = 1);
	
	                event.pinchScale = pinchScale;
	
	                var pinchCenter = center(pinchEnd);
	                event.pinchX = pinchCenter[0];
	                event.pinchY = pinchCenter[1];
	
	                return {
	                    type: 'pinch',
	                    target: track[0].target,
	                    event: event
	                };
	            }
	        }
	
	        // Only pinch currently.
	    };
	
	    module.exports = GestureMgr;
	


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Default canvas painter
	 * @module zrender/Painter
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	 
	
	    var config = __webpack_require__(23);
	    var util = __webpack_require__(5);
	    var log = __webpack_require__(22);
	    var BoundingRect = __webpack_require__(27);
	    var timsort = __webpack_require__(72);
	
	    var Layer = __webpack_require__(79);
	
	    var requestAnimationFrame = __webpack_require__(75);
	
	    // PENDIGN
	    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.
	    //
	    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.
	    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;
	
	    function parseInt10(val) {
	        return parseInt(val, 10);
	    }
	
	    function isLayerValid(layer) {
	        if (!layer) {
	            return false;
	        }
	
	        if (layer.__builtin__) {
	            return true;
	        }
	
	        if (typeof(layer.resize) !== 'function'
	            || typeof(layer.refresh) !== 'function'
	        ) {
	            return false;
	        }
	
	        return true;
	    }
	
	    function preProcessLayer(layer) {
	        layer.__unusedCount++;
	    }
	
	    function postProcessLayer(layer) {
	        if (layer.__unusedCount == 1) {
	            layer.clear();
	        }
	    }
	
	    var tmpRect = new BoundingRect(0, 0, 0, 0);
	    var viewRect = new BoundingRect(0, 0, 0, 0);
	    function isDisplayableCulled(el, width, height) {
	        tmpRect.copy(el.getBoundingRect());
	        if (el.transform) {
	            tmpRect.applyTransform(el.transform);
	        }
	        viewRect.width = width;
	        viewRect.height = height;
	        return !tmpRect.intersect(viewRect);
	    }
	
	    function isClipPathChanged(clipPaths, prevClipPaths) {
	        if (clipPaths == prevClipPaths) { // Can both be null or undefined
	            return false;
	        }
	
	        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {
	            return true;
	        }
	        for (var i = 0; i < clipPaths.length; i++) {
	            if (clipPaths[i] !== prevClipPaths[i]) {
	                return true;
	            }
	        }
	    }
	
	    function doClip(clipPaths, ctx) {
	        for (var i = 0; i < clipPaths.length; i++) {
	            var clipPath = clipPaths[i];
	
	            clipPath.setTransform(ctx);
	            ctx.beginPath();
	            clipPath.buildPath(ctx, clipPath.shape);
	            ctx.clip();
	            // Transform back
	            clipPath.restoreTransform(ctx);
	        }
	    }
	
	    function createRoot(width, height) {
	        var domRoot = document.createElement('div');
	
	        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
	        domRoot.style.cssText = [
	            'position:relative',
	            'overflow:hidden',
	            'width:' + width + 'px',
	            'height:' + height + 'px',
	            'padding:0',
	            'margin:0',
	            'border-width:0'
	        ].join(';') + ';';
	
	        return domRoot;
	    }
	
	    /**
	     * @alias module:zrender/Painter
	     * @constructor
	     * @param {HTMLElement} root 绘图容器
	     * @param {module:zrender/Storage} storage
	     * @param {Object} opts
	     */
	    var Painter = function (root, storage, opts) {
	
	        this.type = 'canvas';
	
	        // In node environment using node-canvas
	        var singleCanvas = !root.nodeName // In node ?
	            || root.nodeName.toUpperCase() === 'CANVAS';
	
	        this._opts = opts = util.extend({}, opts || {});
	
	        /**
	         * @type {number}
	         */
	        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;
	        /**
	         * @type {boolean}
	         * @private
	         */
	        this._singleCanvas = singleCanvas;
	        /**
	         * 绘图容器
	         * @type {HTMLElement}
	         */
	        this.root = root;
	
	        var rootStyle = root.style;
	
	        if (rootStyle) {
	            rootStyle['-webkit-tap-highlight-color'] = 'transparent';
	            rootStyle['-webkit-user-select'] =
	            rootStyle['user-select'] =
	            rootStyle['-webkit-touch-callout'] = 'none';
	
	            root.innerHTML = '';
	        }
	
	        /**
	         * @type {module:zrender/Storage}
	         */
	        this.storage = storage;
	
	        /**
	         * @type {Array.<number>}
	         * @private
	         */
	        var zlevelList = this._zlevelList = [];
	
	        /**
	         * @type {Object.<string, module:zrender/Layer>}
	         * @private
	         */
	        var layers = this._layers = {};
	
	        /**
	         * @type {Object.<string, Object>}
	         * @type {private}
	         */
	        this._layerConfig = {};
	
	        if (!singleCanvas) {
	            this._width = this._getSize(0);
	            this._height = this._getSize(1);
	
	            var domRoot = this._domRoot = createRoot(
	                this._width, this._height
	            );
	            root.appendChild(domRoot);
	        }
	        else {
	            if (opts.width != null) {
	                root.width = opts.width;
	            }
	            if (opts.height != null) {
	                root.height = opts.height;
	            }
	            // Use canvas width and height directly
	            var width = root.width;
	            var height = root.height;
	            this._width = width;
	            this._height = height;
	
	            // Create layer if only one given canvas
	            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height
	            var mainLayer = new Layer(root, this, 1);
	            mainLayer.initContext();
	            // FIXME Use canvas width and height
	            // mainLayer.resize(width, height);
	            layers[0] = mainLayer;
	            zlevelList.push(0);
	
	            this._domRoot = root;
	        }
	
	        // Layers for progressive rendering
	        this._progressiveLayers = [];
	
	        /**
	         * @type {module:zrender/Layer}
	         * @private
	         */
	        this._hoverlayer;
	
	        this._hoverElements = [];
	    };
	
	    Painter.prototype = {
	
	        constructor: Painter,
	
	        getType: function () {
	            return 'canvas';
	        },
	
	        /**
	         * If painter use a single canvas
	         * @return {boolean}
	         */
	        isSingleCanvas: function () {
	            return this._singleCanvas;
	        },
	        /**
	         * @return {HTMLDivElement}
	         */
	        getViewportRoot: function () {
	            return this._domRoot;
	        },
	
	        getViewportRootOffset: function () {
	            var viewportRoot = this.getViewportRoot();
	            if (viewportRoot) {
	                return {
	                    offsetLeft: viewportRoot.offsetLeft || 0,
	                    offsetTop: viewportRoot.offsetTop || 0
	                };
	            }
	        },
	
	        /**
	         * 刷新
	         * @param {boolean} [paintAll=false] 强制绘制所有displayable
	         */
	        refresh: function (paintAll) {
	
	            var list = this.storage.getDisplayList(true);
	
	            var zlevelList = this._zlevelList;
	
	            this._paintList(list, paintAll);
	
	            // Paint custum layers
	            for (var i = 0; i < zlevelList.length; i++) {
	                var z = zlevelList[i];
	                var layer = this._layers[z];
	                if (!layer.__builtin__ && layer.refresh) {
	                    layer.refresh();
	                }
	            }
	
	            this.refreshHover();
	
	            if (this._progressiveLayers.length) {
	                this._startProgessive();
	            }
	
	            return this;
	        },
	
	        addHover: function (el, hoverStyle) {
	            if (el.__hoverMir) {
	                return;
	            }
	            var elMirror = new el.constructor({
	                style: el.style,
	                shape: el.shape
	            });
	            elMirror.__from = el;
	            el.__hoverMir = elMirror;
	            elMirror.setStyle(hoverStyle);
	            this._hoverElements.push(elMirror);
	        },
	
	        removeHover: function (el) {
	            var elMirror = el.__hoverMir;
	            var hoverElements = this._hoverElements;
	            var idx = util.indexOf(hoverElements, elMirror);
	            if (idx >= 0) {
	                hoverElements.splice(idx, 1);
	            }
	            el.__hoverMir = null;
	        },
	
	        clearHover: function (el) {
	            var hoverElements = this._hoverElements;
	            for (var i = 0; i < hoverElements.length; i++) {
	                var from = hoverElements[i].__from;
	                if (from) {
	                    from.__hoverMir = null;
	                }
	            }
	            hoverElements.length = 0;
	        },
	
	        refreshHover: function () {
	            var hoverElements = this._hoverElements;
	            var len = hoverElements.length;
	            var hoverLayer = this._hoverlayer;
	            hoverLayer && hoverLayer.clear();
	
	            if (!len) {
	                return;
	            }
	            timsort(hoverElements, this.storage.displayableSortFunc);
	
	            // Use a extream large zlevel
	            // FIXME?
	            if (!hoverLayer) {
	                hoverLayer = this._hoverlayer = this.getLayer(1e5);
	            }
	
	            var scope = {};
	            hoverLayer.ctx.save();
	            for (var i = 0; i < len;) {
	                var el = hoverElements[i];
	                var originalEl = el.__from;
	                // Original el is removed
	                // PENDING
	                if (!(originalEl && originalEl.__zr)) {
	                    hoverElements.splice(i, 1);
	                    originalEl.__hoverMir = null;
	                    len--;
	                    continue;
	                }
	                i++;
	
	                // Use transform
	                // FIXME style and shape ?
	                if (!originalEl.invisible) {
	                    el.transform = originalEl.transform;
	                    el.invTransform = originalEl.invTransform;
	                    el.__clipPaths = originalEl.__clipPaths;
	                    // el.
	                    this._doPaintEl(el, hoverLayer, true, scope);
	                }
	            }
	            hoverLayer.ctx.restore();
	        },
	
	        _startProgessive: function () {
	            var self = this;
	
	            if (!self._furtherProgressive) {
	                return;
	            }
	
	            // Use a token to stop progress steps triggered by
	            // previous zr.refresh calling.
	            var token = self._progressiveToken = +new Date();
	
	            self._progress++;
	            requestAnimationFrame(step);
	
	            function step() {
	                // In case refreshed or disposed
	                if (token === self._progressiveToken && self.storage) {
	
	                    self._doPaintList(self.storage.getDisplayList());
	
	                    if (self._furtherProgressive) {
	                        self._progress++;
	                        requestAnimationFrame(step);
	                    }
	                    else {
	                        self._progressiveToken = -1;
	                    }
	                }
	            }
	        },
	
	        _clearProgressive: function () {
	            this._progressiveToken = -1;
	            this._progress = 0;
	            util.each(this._progressiveLayers, function (layer) {
	                layer.__dirty && layer.clear();
	            });
	        },
	
	        _paintList: function (list, paintAll) {
	
	            if (paintAll == null) {
	                paintAll = false;
	            }
	
	            this._updateLayerStatus(list);
	
	            this._clearProgressive();
	
	            this.eachBuiltinLayer(preProcessLayer);
	
	            this._doPaintList(list, paintAll);
	
	            this.eachBuiltinLayer(postProcessLayer);
	        },
	
	        _doPaintList: function (list, paintAll) {
	            var currentLayer;
	            var currentZLevel;
	            var ctx;
	
	            // var invTransform = [];
	            var scope;
	
	            var progressiveLayerIdx = 0;
	            var currentProgressiveLayer;
	
	            var width = this._width;
	            var height = this._height;
	            var layerProgress;
	            var frame = this._progress;
	            function flushProgressiveLayer(layer) {
	                var dpr = ctx.dpr || 1;
	                ctx.save();
	                ctx.globalAlpha = 1;
	                ctx.shadowBlur = 0;
	                // Avoid layer don't clear in next progressive frame
	                currentLayer.__dirty = true;
	                ctx.setTransform(1, 0, 0, 1, 0, 0);
	                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);
	                ctx.restore();
	            }
	
	            for (var i = 0, l = list.length; i < l; i++) {
	                var el = list[i];
	                var elZLevel = this._singleCanvas ? 0 : el.zlevel;
	
	                var elFrame = el.__frame;
	
	                // Flush at current context
	                // PENDING
	                if (elFrame < 0 && currentProgressiveLayer) {
	                    flushProgressiveLayer(currentProgressiveLayer);
	                    currentProgressiveLayer = null;
	                }
	
	                // Change draw layer
	                if (currentZLevel !== elZLevel) {
	                    if (ctx) {
	                        ctx.restore();
	                    }
	
	                    // Reset scope
	                    scope = {};
	
	                    // Only 0 zlevel if only has one canvas
	                    currentZLevel = elZLevel;
	                    currentLayer = this.getLayer(currentZLevel);
	
	                    if (!currentLayer.__builtin__) {
	                        log(
	                            'ZLevel ' + currentZLevel
	                            + ' has been used by unkown layer ' + currentLayer.id
	                        );
	                    }
	
	                    ctx = currentLayer.ctx;
	                    ctx.save();
	
	                    // Reset the count
	                    currentLayer.__unusedCount = 0;
	
	                    if (currentLayer.__dirty || paintAll) {
	                        currentLayer.clear();
	                    }
	                }
	
	                if (!(currentLayer.__dirty || paintAll)) {
	                    continue;
	                }
	
	                if (elFrame >= 0) {
	                    // Progressive layer changed
	                    if (!currentProgressiveLayer) {
	                        currentProgressiveLayer = this._progressiveLayers[
	                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)
	                        ];
	
	                        currentProgressiveLayer.ctx.save();
	                        currentProgressiveLayer.renderScope = {};
	
	                        if (currentProgressiveLayer
	                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)
	                        ) {
	                            // flushProgressiveLayer(currentProgressiveLayer);
	                            // Quick jump all progressive elements
	                            // All progressive element are not dirty, jump over and flush directly
	                            i = currentProgressiveLayer.__nextIdxNotProg - 1;
	                            // currentProgressiveLayer = null;
	                            continue;
	                        }
	
	                        layerProgress = currentProgressiveLayer.__progress;
	
	                        if (!currentProgressiveLayer.__dirty) {
	                            // Keep rendering
	                            frame = layerProgress;
	                        }
	
	                        currentProgressiveLayer.__progress = frame + 1;
	                    }
	
	                    if (elFrame === frame) {
	                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
	                    }
	                }
	                else {
	                    this._doPaintEl(el, currentLayer, paintAll, scope);
	                }
	
	                el.__dirty = false;
	            }
	
	            if (currentProgressiveLayer) {
	                flushProgressiveLayer(currentProgressiveLayer);
	            }
	
	            // Restore the lastLayer ctx
	            ctx && ctx.restore();
	            // If still has clipping state
	            // if (scope.prevElClipPaths) {
	            //     ctx.restore();
	            // }
	
	            this._furtherProgressive = false;
	            util.each(this._progressiveLayers, function (layer) {
	                if (layer.__maxProgress >= layer.__progress) {
	                    this._furtherProgressive = true;
	                }
	            }, this);
	        },
	
	        _doPaintEl: function (el, currentLayer, forcePaint, scope) {
	            var ctx = currentLayer.ctx;
	            var m = el.transform;
	            if (
	                (currentLayer.__dirty || forcePaint)
	                // Ignore invisible element
	                && !el.invisible
	                // Ignore transparent element
	                && el.style.opacity !== 0
	                // Ignore scale 0 element, in some environment like node-canvas
	                // Draw a scale 0 element can cause all following draw wrong
	                // And setTransform with scale 0 will cause set back transform failed.
	                && !(m && !m[0] && !m[3])
	                // Ignore culled element
	                && !(el.culling && isDisplayableCulled(el, this._width, this._height))
	            ) {
	
	                var clipPaths = el.__clipPaths;
	
	                // Optimize when clipping on group with several elements
	                if (scope.prevClipLayer !== currentLayer
	                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)
	                ) {
	                    // If has previous clipping state, restore from it
	                    if (scope.prevElClipPaths) {
	                        scope.prevClipLayer.ctx.restore();
	                        scope.prevClipLayer = scope.prevElClipPaths = null;
	
	                        // Reset prevEl since context has been restored
	                        scope.prevEl = null;
	                    }
	                    // New clipping state
	                    if (clipPaths) {
	                        ctx.save();
	                        doClip(clipPaths, ctx);
	                        scope.prevClipLayer = currentLayer;
	                        scope.prevElClipPaths = clipPaths;
	                    }
	                }
	                el.beforeBrush && el.beforeBrush(ctx);
	
	                el.brush(ctx, scope.prevEl || null);
	                scope.prevEl = el;
	
	                el.afterBrush && el.afterBrush(ctx);
	            }
	        },
	
	        /**
	         * 获取 zlevel 所在层，如果不存在则会创建一个新的层
	         * @param {number} zlevel
	         * @return {module:zrender/Layer}
	         */
	        getLayer: function (zlevel) {
	            if (this._singleCanvas) {
	                return this._layers[0];
	            }
	
	            var layer = this._layers[zlevel];
	            if (!layer) {
	                // Create a new layer
	                layer = new Layer('zr_' + zlevel, this, this.dpr);
	                layer.__builtin__ = true;
	
	                if (this._layerConfig[zlevel]) {
	                    util.merge(layer, this._layerConfig[zlevel], true);
	                }
	
	                this.insertLayer(zlevel, layer);
	
	                // Context is created after dom inserted to document
	                // Or excanvas will get 0px clientWidth and clientHeight
	                layer.initContext();
	            }
	
	            return layer;
	        },
	
	        insertLayer: function (zlevel, layer) {
	
	            var layersMap = this._layers;
	            var zlevelList = this._zlevelList;
	            var len = zlevelList.length;
	            var prevLayer = null;
	            var i = -1;
	            var domRoot = this._domRoot;
	
	            if (layersMap[zlevel]) {
	                log('ZLevel ' + zlevel + ' has been used already');
	                return;
	            }
	            // Check if is a valid layer
	            if (!isLayerValid(layer)) {
	                log('Layer of zlevel ' + zlevel + ' is not valid');
	                return;
	            }
	
	            if (len > 0 && zlevel > zlevelList[0]) {
	                for (i = 0; i < len - 1; i++) {
	                    if (
	                        zlevelList[i] < zlevel
	                        && zlevelList[i + 1] > zlevel
	                    ) {
	                        break;
	                    }
	                }
	                prevLayer = layersMap[zlevelList[i]];
	            }
	            zlevelList.splice(i + 1, 0, zlevel);
	
	            layersMap[zlevel] = layer;
	
	            // Vitual layer will not directly show on the screen.
	            // (It can be a WebGL layer and assigned to a ZImage element)
	            // But it still under management of zrender.
	            if (!layer.virtual) {
	                if (prevLayer) {
	                    var prevDom = prevLayer.dom;
	                    if (prevDom.nextSibling) {
	                        domRoot.insertBefore(
	                            layer.dom,
	                            prevDom.nextSibling
	                        );
	                    }
	                    else {
	                        domRoot.appendChild(layer.dom);
	                    }
	                }
	                else {
	                    if (domRoot.firstChild) {
	                        domRoot.insertBefore(layer.dom, domRoot.firstChild);
	                    }
	                    else {
	                        domRoot.appendChild(layer.dom);
	                    }
	                }
	            }
	        },
	
	        // Iterate each layer
	        eachLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                cb.call(context, this._layers[z], z);
	            }
	        },
	
	        // Iterate each buildin layer
	        eachBuiltinLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var layer;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                layer = this._layers[z];
	                if (layer.__builtin__) {
	                    cb.call(context, layer, z);
	                }
	            }
	        },
	
	        // Iterate each other layer except buildin layer
	        eachOtherLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var layer;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                layer = this._layers[z];
	                if (!layer.__builtin__) {
	                    cb.call(context, layer, z);
	                }
	            }
	        },
	
	        /**
	         * 获取所有已创建的层
	         * @param {Array.<module:zrender/Layer>} [prevLayer]
	         */
	        getLayers: function () {
	            return this._layers;
	        },
	
	        _updateLayerStatus: function (list) {
	
	            var layers = this._layers;
	            var progressiveLayers = this._progressiveLayers;
	
	            var elCountsLastFrame = {};
	            var progressiveElCountsLastFrame = {};
	
	            this.eachBuiltinLayer(function (layer, z) {
	                elCountsLastFrame[z] = layer.elCount;
	                layer.elCount = 0;
	                layer.__dirty = false;
	            });
	
	            util.each(progressiveLayers, function (layer, idx) {
	                progressiveElCountsLastFrame[idx] = layer.elCount;
	                layer.elCount = 0;
	                layer.__dirty = false;
	            });
	
	            var progressiveLayerCount = 0;
	            var currentProgressiveLayer;
	            var lastProgressiveKey;
	            var frameCount = 0;
	            for (var i = 0, l = list.length; i < l; i++) {
	                var el = list[i];
	                var zlevel = this._singleCanvas ? 0 : el.zlevel;
	                var layer = layers[zlevel];
	                var elProgress = el.progressive;
	                if (layer) {
	                    layer.elCount++;
	                    layer.__dirty = layer.__dirty || el.__dirty;
	                }
	
	                /////// Update progressive
	                if (elProgress >= 0) {
	                    // Fix wrong progressive sequence problem.
	                    if (lastProgressiveKey !== elProgress) {
	                        lastProgressiveKey = elProgress;
	                        frameCount++;
	                    }
	                    var elFrame = el.__frame = frameCount - 1;
	                    if (!currentProgressiveLayer) {
	                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
	                        currentProgressiveLayer = progressiveLayers[idx];
	                        if (!currentProgressiveLayer) {
	                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(
	                                'progressive', this, this.dpr
	                            );
	                            currentProgressiveLayer.initContext();
	                        }
	                        currentProgressiveLayer.__maxProgress = 0;
	                    }
	                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
	                    currentProgressiveLayer.elCount++;
	
	                    currentProgressiveLayer.__maxProgress = Math.max(
	                        currentProgressiveLayer.__maxProgress, elFrame
	                    );
	
	                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
	                        // Should keep rendering this  layer because progressive rendering is not finished yet
	                        layer.__dirty = true;
	                    }
	                }
	                else {
	                    el.__frame = -1;
	
	                    if (currentProgressiveLayer) {
	                        currentProgressiveLayer.__nextIdxNotProg = i;
	                        progressiveLayerCount++;
	                        currentProgressiveLayer = null;
	                    }
	                }
	            }
	
	            if (currentProgressiveLayer) {
	                progressiveLayerCount++;
	                currentProgressiveLayer.__nextIdxNotProg = i;
	            }
	
	            // 层中的元素数量有发生变化
	            this.eachBuiltinLayer(function (layer, z) {
	                if (elCountsLastFrame[z] !== layer.elCount) {
	                    layer.__dirty = true;
	                }
	            });
	
	            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
	            util.each(progressiveLayers, function (layer, idx) {
	                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
	                    el.__dirty = true;
	                }
	                if (layer.__dirty) {
	                    layer.__progress = 0;
	                }
	            });
	        },
	
	        /**
	         * 清除hover层外所有内容
	         */
	        clear: function () {
	            this.eachBuiltinLayer(this._clearLayer);
	            return this;
	        },
	
	        _clearLayer: function (layer) {
	            layer.clear();
	        },
	
	        /**
	         * 修改指定zlevel的绘制参数
	         *
	         * @param {string} zlevel
	         * @param {Object} config 配置对象
	         * @param {string} [config.clearColor=0] 每次清空画布的颜色
	         * @param {string} [config.motionBlur=false] 是否开启动态模糊
	         * @param {number} [config.lastFrameAlpha=0.7]
	         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	         */
	        configLayer: function (zlevel, config) {
	            if (config) {
	                var layerConfig = this._layerConfig;
	                if (!layerConfig[zlevel]) {
	                    layerConfig[zlevel] = config;
	                }
	                else {
	                    util.merge(layerConfig[zlevel], config, true);
	                }
	
	                var layer = this._layers[zlevel];
	
	                if (layer) {
	                    util.merge(layer, layerConfig[zlevel], true);
	                }
	            }
	        },
	
	        /**
	         * 删除指定层
	         * @param {number} zlevel 层所在的zlevel
	         */
	        delLayer: function (zlevel) {
	            var layers = this._layers;
	            var zlevelList = this._zlevelList;
	            var layer = layers[zlevel];
	            if (!layer) {
	                return;
	            }
	            layer.dom.parentNode.removeChild(layer.dom);
	            delete layers[zlevel];
	
	            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
	        },
	
	        /**
	         * 区域大小变化后重绘
	         */
	        resize: function (width, height) {
	            var domRoot = this._domRoot;
	            // FIXME Why ?
	            domRoot.style.display = 'none';
	
	            // Save input w/h
	            var opts = this._opts;
	            width != null && (opts.width = width);
	            height != null && (opts.height = height);
	
	            width = this._getSize(0);
	            height = this._getSize(1);
	
	            domRoot.style.display = '';
	
	            // 优化没有实际改变的resize
	            if (this._width != width || height != this._height) {
	                domRoot.style.width = width + 'px';
	                domRoot.style.height = height + 'px';
	
	                for (var id in this._layers) {
	                    if (this._layers.hasOwnProperty(id)) {
	                        this._layers[id].resize(width, height);
	                    }
	                }
	                util.each(this._progressiveLayers, function (layer) {
	                    layer.resize(width, height);
	                });
	
	                this.refresh(true);
	            }
	
	            this._width = width;
	            this._height = height;
	
	            return this;
	        },
	
	        /**
	         * 清除单独的一个层
	         * @param {number} zlevel
	         */
	        clearLayer: function (zlevel) {
	            var layer = this._layers[zlevel];
	            if (layer) {
	                layer.clear();
	            }
	        },
	
	        /**
	         * 释放
	         */
	        dispose: function () {
	            this.root.innerHTML = '';
	
	            this.root =
	            this.storage =
	
	            this._domRoot =
	            this._layers = null;
	        },
	
	        /**
	         * Get canvas which has all thing rendered
	         * @param {Object} opts
	         * @param {string} [opts.backgroundColor]
	         */
	        getRenderedCanvas: function (opts) {
	            opts = opts || {};
	            if (this._singleCanvas) {
	                return this._layers[0].dom;
	            }
	
	            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
	            imageLayer.initContext();
	
	            imageLayer.clearColor = opts.backgroundColor;
	            imageLayer.clear();
	
	            var displayList = this.storage.getDisplayList(true);
	
	            var scope = {};
	            var zlevel;
	
	            var self = this;
	            function findAndDrawOtherLayer(smaller, larger) {
	                var zlevelList = self._zlevelList;
	                if (smaller == null) {
	                    smaller = -Infinity;
	                }
	                var intermediateLayer;
	                for (var i = 0; i < zlevelList.length; i++) {
	                    var z = zlevelList[i];
	                    var layer = self._layers[z];
	                    if (!layer.__builtin__ && z > smaller && z < larger) {
	                        intermediateLayer = layer;
	                        break;
	                    }
	                }
	                if (intermediateLayer && intermediateLayer.renderToCanvas) {
	                    imageLayer.ctx.save();
	                    intermediateLayer.renderToCanvas(imageLayer.ctx);
	                    imageLayer.ctx.restore();
	                }
	            }
	            for (var i = 0; i < displayList.length; i++) {
	                var el = displayList[i];
	
	                if (el.zlevel !== zlevel) {
	                    findAndDrawOtherLayer(zlevel, el.zlevel);
	                    zlevel = el.zlevel;
	                }
	                this._doPaintEl(el, imageLayer, true, scope);
	            }
	
	            findAndDrawOtherLayer(zlevel, Infinity);
	
	            return imageLayer.dom;
	        },
	        /**
	         * 获取绘图区域宽度
	         */
	        getWidth: function () {
	            return this._width;
	        },
	
	        /**
	         * 获取绘图区域高度
	         */
	        getHeight: function () {
	            return this._height;
	        },
	
	        _getSize: function (whIdx) {
	            var opts = this._opts;
	            var wh = ['width', 'height'][whIdx];
	            var cwh = ['clientWidth', 'clientHeight'][whIdx];
	            var plt = ['paddingLeft', 'paddingTop'][whIdx];
	            var prb = ['paddingRight', 'paddingBottom'][whIdx];
	
	            if (opts[wh] != null && opts[wh] !== 'auto') {
	                return parseFloat(opts[wh]);
	            }
	
	            var root = this.root;
	            // IE8 does not support getComputedStyle, but it use VML.
	            var stl = document.defaultView.getComputedStyle(root);
	
	            return (
	                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))
	                - (parseInt10(stl[plt]) || 0)
	                - (parseInt10(stl[prb]) || 0)
	            ) | 0;
	        },
	
	        pathToImage: function (path, dpr) {
	            dpr = dpr || this.dpr;
	
	            var canvas = document.createElement('canvas');
	            var ctx = canvas.getContext('2d');
	            var rect = path.getBoundingRect();
	            var style = path.style;
	            var shadowBlurSize = style.shadowBlur;
	            var shadowOffsetX = style.shadowOffsetX;
	            var shadowOffsetY = style.shadowOffsetY;
	            var lineWidth = style.hasStroke() ? style.lineWidth : 0;
	
	            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
	            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
	            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
	            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
	            var width = rect.width + leftMargin + rightMargin;
	            var height = rect.height + topMargin + bottomMargin;
	
	            canvas.width = width * dpr;
	            canvas.height = height * dpr;
	
	            ctx.scale(dpr, dpr);
	            ctx.clearRect(0, 0, width, height);
	            ctx.dpr = dpr;
	
	            var pathTransform = {
	                position: path.position,
	                rotation: path.rotation,
	                scale: path.scale
	            };
	            path.position = [leftMargin - rect.x, topMargin - rect.y];
	            path.rotation = 0;
	            path.scale = [1, 1];
	            path.updateTransform();
	            if (path) {
	                path.brush(ctx);
	            }
	
	            var ImageShape = __webpack_require__(45);
	            var imgShape = new ImageShape({
	                style: {
	                    x: 0,
	                    y: 0,
	                    image: canvas
	                }
	            });
	
	            if (pathTransform.position != null) {
	                imgShape.position = path.position = pathTransform.position;
	            }
	
	            if (pathTransform.rotation != null) {
	                imgShape.rotation = path.rotation = pathTransform.rotation;
	            }
	
	            if (pathTransform.scale != null) {
	                imgShape.scale = path.scale = pathTransform.scale;
	            }
	
	            return imgShape;
	        }
	    };
	
	    module.exports = Painter;
	


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @module zrender/Layer
	 * @author pissang(https://www.github.com/pissang)
	 */
	
	
	    var util = __webpack_require__(5);
	    var config = __webpack_require__(23);
	    var Style = __webpack_require__(9);
	    var Pattern = __webpack_require__(40);
	
	    function returnFalse() {
	        return false;
	    }
	
	    /**
	     * 创建dom
	     *
	     * @inner
	     * @param {string} id dom id 待用
	     * @param {string} type dom type，such as canvas, div etc.
	     * @param {Painter} painter painter instance
	     * @param {number} number
	     */
	    function createDom(id, type, painter, dpr) {
	        var newDom = document.createElement(type);
	        var width = painter.getWidth();
	        var height = painter.getHeight();
	
	        var newDomStyle = newDom.style;
	        // 没append呢，请原谅我这样写，清晰~
	        newDomStyle.position = 'absolute';
	        newDomStyle.left = 0;
	        newDomStyle.top = 0;
	        newDomStyle.width = width + 'px';
	        newDomStyle.height = height + 'px';
	        newDom.width = width * dpr;
	        newDom.height = height * dpr;
	
	        // id不作为索引用，避免可能造成的重名，定义为私有属性
	        newDom.setAttribute('data-zr-dom-id', id);
	        return newDom;
	    }
	
	    /**
	     * @alias module:zrender/Layer
	     * @constructor
	     * @extends module:zrender/mixin/Transformable
	     * @param {string} id
	     * @param {module:zrender/Painter} painter
	     * @param {number} [dpr]
	     */
	    var Layer = function(id, painter, dpr) {
	        var dom;
	        dpr = dpr || config.devicePixelRatio;
	        if (typeof id === 'string') {
	            dom = createDom(id, 'canvas', painter, dpr);
	        }
	        // Not using isDom because in node it will return false
	        else if (util.isObject(id)) {
	            dom = id;
	            id = dom.id;
	        }
	        this.id = id;
	        this.dom = dom;
	
	        var domStyle = dom.style;
	        if (domStyle) { // Not in node
	            dom.onselectstart = returnFalse; // 避免页面选中的尴尬
	            domStyle['-webkit-user-select'] = 'none';
	            domStyle['user-select'] = 'none';
	            domStyle['-webkit-touch-callout'] = 'none';
	            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
	            domStyle['padding'] = 0;
	            domStyle['margin'] = 0;
	            domStyle['border-width'] = 0;
	        }
	
	        this.domBack = null;
	        this.ctxBack = null;
	
	        this.painter = painter;
	
	        this.config = null;
	
	        // Configs
	        /**
	         * 每次清空画布的颜色
	         * @type {string}
	         * @default 0
	         */
	        this.clearColor = 0;
	        /**
	         * 是否开启动态模糊
	         * @type {boolean}
	         * @default false
	         */
	        this.motionBlur = false;
	        /**
	         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	         * @type {number}
	         * @default 0.7
	         */
	        this.lastFrameAlpha = 0.7;
	
	        /**
	         * Layer dpr
	         * @type {number}
	         */
	        this.dpr = dpr;
	    };
	
	    Layer.prototype = {
	
	        constructor: Layer,
	
	        elCount: 0,
	
	        __dirty: true,
	
	        initContext: function () {
	            this.ctx = this.dom.getContext('2d');
	            this.ctx.__currentValues = {};
	            this.ctx.dpr = this.dpr;
	        },
	
	        createBackBuffer: function () {
	            var dpr = this.dpr;
	
	            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);
	            this.ctxBack = this.domBack.getContext('2d');
	            this.ctxBack.__currentValues = {};
	
	            if (dpr != 1) {
	                this.ctxBack.scale(dpr, dpr);
	            }
	        },
	
	        /**
	         * @param  {number} width
	         * @param  {number} height
	         */
	        resize: function (width, height) {
	            var dpr = this.dpr;
	
	            var dom = this.dom;
	            var domStyle = dom.style;
	            var domBack = this.domBack;
	
	            domStyle.width = width + 'px';
	            domStyle.height = height + 'px';
	
	            dom.width = width * dpr;
	            dom.height = height * dpr;
	
	            if (domBack) {
	                domBack.width = width * dpr;
	                domBack.height = height * dpr;
	
	                if (dpr != 1) {
	                    this.ctxBack.scale(dpr, dpr);
	                }
	            }
	        },
	
	        /**
	         * 清空该层画布
	         * @param {boolean} clearAll Clear all with out motion blur
	         */
	        clear: function (clearAll) {
	            var dom = this.dom;
	            var ctx = this.ctx;
	            var width = dom.width;
	            var height = dom.height;
	
	            var clearColor = this.clearColor;
	            var haveMotionBLur = this.motionBlur && !clearAll;
	            var lastFrameAlpha = this.lastFrameAlpha;
	
	            var dpr = this.dpr;
	
	            if (haveMotionBLur) {
	                if (!this.domBack) {
	                    this.createBackBuffer();
	                }
	
	                this.ctxBack.globalCompositeOperation = 'copy';
	                this.ctxBack.drawImage(
	                    dom, 0, 0,
	                    width / dpr,
	                    height / dpr
	                );
	            }
	
	            ctx.clearRect(0, 0, width, height);
	            if (clearColor) {
	                var clearColorGradientOrPattern;
	                // Gradient
	                if (clearColor.colorStops) {
	                    // Cache canvas gradient
	                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
	                        x: 0,
	                        y: 0,
	                        width: width,
	                        height: height
	                    });
	
	                    clearColor.__canvasGradient = clearColorGradientOrPattern;
	                }
	                // Pattern
	                else if (clearColor.image) {
	                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
	                }
	                ctx.save();
	                ctx.fillStyle = clearColorGradientOrPattern || clearColor;
	                ctx.fillRect(0, 0, width, height);
	                ctx.restore();
	            }
	
	            if (haveMotionBLur) {
	                var domBack = this.domBack;
	                ctx.save();
	                ctx.globalAlpha = lastFrameAlpha;
	                ctx.drawImage(domBack, 0, 0, width, height);
	                ctx.restore();
	            }
	        }
	    };
	
	    module.exports = Layer;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 选中节点后，出现的操作框及按钮
	 * @author wang.xiaohu
	 */
	
	    var Node = __webpack_require__(81);
	    var zrUtil = __webpack_require__(5);
	    var graphic = __webpack_require__(4);
	    var Connector = __webpack_require__(82);
	    var env = __webpack_require__(50);
	    var icon = __webpack_require__(89);
	    var symbolUtil = __webpack_require__(83);
	    function OperationNode(node, zr, api,forbidEdit) {
	        Node.call(this);
	        this.node = node;
	        this.zr = zr;
	        this.forbidEdit = forbidEdit;
	        this._api = api;
	        this.render();
	    }
	
	    //事件
	    OperationNode.ARROW_DRAGEND = "OperationNode:dragendArrow";
	    OperationNode.ARROW_DRAG = "OperationNode:dragArrow";
	    OperationNode.ARROW_DRAGSTART = "OperationNode:dragstartArrow";
	    OperationNode.DELETE_CLICK = "OperationNode:deleteClick";
	    OperationNode.DEL = "DEL";
	    if(!env.canvasSupported) {//IE8不支持canvas 以及base64  此处是为了兼容IE8. 实际都可以用SVG图标,但没有找到好的SVG图标, 如果有的话那就没有必要用这些base64了
	        //内置操作图标的图像
	        OperationNode.opicons = {
	            STRAIGHT: icon.STRAIGHT_SVG,
	            JAGGED: icon.JAGGED_SVG,
	            CURVE: icon.CURVE_SVG,
	            DEL: icon.DEL_SVG
	        };
	    }else{
	        OperationNode.opicons = {
	            STRAIGHT: icon.STRAIGHT_IMG,
	            JAGGED: icon.JAGGED_IMG,
	            CURVE: icon.CURVE_IMG,
	            DEL: icon.DEL_SVG
	        };
	    }
	
	    OperationNode.prototype.render = function() {
	        this.renderBase();
	        if (!this.forbidEdit) {
	            this.renderOther();
	        }
	    };
	
	    OperationNode.prototype.renderBase = function() {
	        this.createOperation();
	    };
	
	    OperationNode.prototype.createOperation = function() {
	        var me = this;
	        if (!this.node.selectStyle) {
	            this.virtualRect = new graphic.Polyline({ style: { lineDash: [2] } });
	            this.virtualRect.isSelfComputePos = true;  // 自己计算位置
	            this.add(this.virtualRect);
	        } else {
	            this._api.getZr().addHover(this.node, this.node.selectStyle);
	        }
	
	        if (this.node.operationIcons) {
	            zrUtil.each(this.node.operationIcons, function(item) {
	                //检查是否是内置图标
	                var opIconInstance = null;
	                var operationIcon = OperationNode.opicons[item.name.toUpperCase() + ""]
	                if (operationIcon) {
	
	                    if (this.forbidEdit) {
	                        return;
	                    }
	                    if (item.name == OperationNode.DEL) {
	                        //垃圾桶
	                        opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#000000' },z:me.node.z+1,rectHover: true }, { x: 0, y: 0, width: 10, height: 15 });
	                        if(item.iconPath) {
	                            opIconInstance = new graphic.Image({
	                                style: {
	                                    image:item.iconPath,
	                                    width:15,
	                                    height:15
	                                },
	                                z: me.node.z + 2 //zIndex 置为 节点+2 节点+1为组
	                            });
	                        }
	
	                        if(item.callback){
	                            opIconInstance.on("click", function(e) {
	                                e.data = item;
	                                e.node = me.node;  // 将所附的节点也传递出去
	                                if (item.callback) {
	                                    item.callback(e);
	                                }
	                            });
	                        }else{
	                            opIconInstance.on("click", function(e) {
	                                var params = {};
	                                params.event = e;
	                                params.target = this;
	                                params.type = OperationNode.DELETE_CLICK;
	                                me.trigger(params.type, params);
	                            });
	                        }
	
	
	                    } else {
	                        if(!env.canvasSupported){
	                            var rect = { x: 0, y: 0, width: 15, height: 15 };
	                            opIconInstance = graphic.makePath(operationIcon, { style: { fill: '#000000' },draggable:true,z:me.node.z+2,lineType: Connector["TYPE_" + item.name.toUpperCase()],rectHover: true }, rect);
	                        }else{
	                            var imageUrl = document.createElement('img');
	                            imageUrl.src = item.iconPath || operationIcon;
	                            opIconInstance = new graphic.Image({
	                                style: {
	                                    image:imageUrl,
	                                    width:15,
	                                    height:15
	                                },
	                                draggable: true,
	                                z: me.node.z + 2, //zIndex 置为 节点+2 节点+1为组
	                                lineType: Connector["TYPE_" + item.name.toUpperCase()] //区分不同的线段
	                            });
	                        }
	
	                        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];
	                        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	                            opIconInstance.on(eveName, function(e) {
	                                var params = {};
	                                params.event = e;
	                                params.data = item.options
	                                params.type = "OperationNode:" + eveName + "Arrow";
	                                me.trigger(params.type, params);
	                            });
	                        });
	                    }
	
	                } else {
	                    opIconInstance = symbolUtil.createSymbol(item.iconPath, 0, 0, item.width || 15, item.height || 15, me.node.z+1, item.color||'#000');
	                    opIconInstance.on("click", function(e) {
	                        e.data = item;
	                        e.node = me.node;  // 将所附的节点也传递出去
	                        if (item.callback) {
	                            item.callback(e);
	                        }
	                        var param = {event:e, type:"OperationNode:" + item.name + "Click"};
	                        me._api.trigger(param.type, param);
	                    });
	                }
	                opIconInstance.name = item.name;
	                me.add(opIconInstance);
	            });
	        }
	    };
	
	    OperationNode.prototype.refreshPostion = function(node,nodeRect) {
	        var i = 0;
	        var rbPoint = nodeRect.points[2]; //取右下角坐标
	        //1.定位虚框
	        this.virtualRect && this.virtualRect.setShape({ points: nodeRect.points });
	        //2.定位每个小图标
	        this.eachChild(function(nodeItem) {
	            if (!nodeItem.isSelfComputePos) {
	                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离
	                nodeItem.attr("position", [rbPoint[0] + 8 + (i++ * 20), rbPoint[1] - 10]);
	            }
	        });
	
	        this.refreshPositionOther(node,nodeRect);
	    };
	
	    OperationNode.prototype.renderOther = function() {
	        //留给扩展使用
	    };
	    OperationNode.prototype.refreshPositionOther = function(node,nodeRect) {
	        //留给扩展使用
	        //3.定位整个operationNode
	        if (node.parent && node.parent.isBg && node.parent.isBg == true) {
	            this.attr("position", [nodeRect.x, nodeRect.y])
	        } else {
	            var nodeShapeX = node.shape? node.shape.x:0;
	            var nodeSahpeY = node.shape? node.shape.y:0;
	            this.attr("position", [nodeRect.x + node.parent.position[0]+nodeShapeX, nodeRect.y + node.parent.position[1]+nodeSahpeY])
	        }
	    };
	
	    OperationNode.prototype.cleanup = function() {
	        if(this.node.selectStyle) {
	            this._api.getZr().removeHover(this.node);
	        }
	    };
	
	    zrUtil.inherits(OperationNode, Node);
	    module.exports = OperationNode;
	


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var graphic = __webpack_require__(4);
	    var util = __webpack_require__(65)
	    //创建Node类 所有形状都继承Node  包括fromJSON toJSON
	    function Node() {
	        this.resourceId = util.getUUID(); // 生成节点ID
	        graphic.Group.call(this);
	    }
	
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.render = function() {};
	
	    /**
	     * 由父类实现
	     * @param  {[type]} json [description]
	     * @return {[type]}      [description]
	     */
	    Node.prototype.getRect = function(json) {};
	
	    /**
	     * drawText
	     * @description 画一个文本
	     * @param {string} name
	     * @param {string} color
	     */
	    Node.prototype.drawText = function(name,color) {
	        var textName = this.bpmnInfo.name;
	        if(name != null){
	            textName = name;
	        }
	        var text = new graphic.Text({
	            style: {
	                text: textName,
	                color: color ? color : this.options.text.color,
	                textFont: '12px Microsoft YaHei'
	            },
	            zlevel: 20
	        });
	        //文字绘制的位置  
	        //x = 中心点.x - 起始位置.x - 文字宽度的一半
	        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	        //y = 中心点.y - 起始位置.y + 节点高度的一半 + 偏移值（6）
	        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;
	        text.attr("style", { x: x, y: y });
	        return {
	            text: text,
	            rect: text.getBoundingRect()
	        };
	    };
	    /**
	     * refreshText
	     * @description 刷新文本
	     */
	    Node.prototype.refreshText = function() {
	        var text = this.childOfName("Title");
	        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;
	        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;
	        text.attr("style", { x: x, y: y });
	    };
	    /**
	     * 由父类实现
	     * @return {[type]} [description]
	     */
	    Node.prototype.toJSON = function() {};
	
	    graphic.Util.inherits(Node, graphic.Group);
	    module.exports = Node;
	


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连接线
	 * @author wang.xiaohu
	 */
	
	    var Util = __webpack_require__(65);
	    var zrUtil = __webpack_require__(5);
	    var graphic = __webpack_require__(4);
	    var Node = __webpack_require__(81);
	    var symbolUtil = __webpack_require__(83);
	    var Handle = __webpack_require__(84);
	    var EffectLine = __webpack_require__(85);
	    var ConnectionPoint = __webpack_require__(86);
	    var Point = __webpack_require__(66);
	    var Model = __webpack_require__(87);
	
	    Connector.TYPE_STRAIGHT = 'straight';
	    Connector.TYPE_JAGGED = 'jagged';
	    Connector.TYPE_CURVE = 'curve';
	    Connector.RADIUS = 3;
	    Connector.START_NODE = "startNode";
	    Connector.END_NODE = "endNode";
	    Connector.LEFT = "left";
	    Connector.RIGHT = "right";
	    Connector.TOP = "top";
	    Connector.BOTTOM = "bottom";
	    Connector.BOTTOM = "bottom";
	    Connector.SEPERATOR = "-";
	    Connector.NORMAL_COLOR = "#BBBBBB";
	    Connector.SELECTED_COLOR = '#74B7E0';
	    /**
	     * 构造函数
	     * @param {[type]} options [description]
	     */
	    function Connector(options) {
	        Node.call(this);
	        var opt = options || {};
	        if (opt.model) {
	            this.resourceId = opt.model.get("resourceId");
	            this.model = opt.model;
	        } else {
	            this.resourceId = Util.getUUID(); // 生成节点ID
	            this.model = new Model({});
	        }
	        var defaultOptions = {
	            symbol: { type: "arrow", size: 10, color: Connector.NORMAL_COLOR, both:false }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	            style: { lineWidth: 1, stroke: Connector.NORMAL_COLOR, lineType: Connector.TYPE_STRAIGHT }, //样式
	            hoverStyle: { lineWidth: 2, stroke: Connector.SELECTED_COLOR }, //移上去的样式
	            arrowHoverStyle: { fill: Connector.SELECTED_COLOR},
	            shape: { points: null, smooth: false, smoothConstraint: null }, //形状
	            position: { startPos:null, endPos:null,  //指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	                        startOffset:[0,0],  // 起始线段离节点的偏移
	                        endOffset:[0,0],    // 终止线段离节点的偏移
	                        escapeDistance:[30,30], // 第一条折线的长度，最后一条折线的长度
	                        points:null    //不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	                    },
	            autoChangePosition: false,
	            isEdit: true, //是否可编辑
	            text: {
	                text: "",
	                color: '#000000', // 文本颜色
	                textFont: '12px Microsoft YaHei',
	                textPos: 'center'
	            },
	            z: 0
	        }
	
	        this.options = zrUtil.merge(defaultOptions, opt, true);
	        this.handles = [];
	        this.conPointsGroup = new graphic.Group();
	        this.startNode = null;
	        this.endNode = null;
	        this.line = null;
	        this.groupCurve = new graphic.Group();
	        this.icons = []; // 用于存储线段上面的操作图标
	        this.render();
	    }
	
	
	    /**
	     * 重新画线，如果传空则根据turningPoints 重新画线
	     * @param  {[type]} points [description]
	     * @return {[type]}        [description]
	     */
	    Connector.prototype.refresh = function(arrPoints) {
	        if (arrPoints) {
	            this.turningPoints = arrPoints;
	        }
	        //将[x:0,y:0]转化为[0, 0]  给zrender使用
	        var points = Util.traslatePoints(this.turningPoints);
	
	        if ((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {
	            this.modifyCurve(this.turningPoints);
	        } else {
	            this.line.attr('shape', { points: points });
	        }
	
	        var lineText = this.childOfName('lineText');
	        //开始没有创建文本，后来传进来text了，需要先创建文本
	        if (!lineText && this.options.text.text) {
	            var text = this.drawText("lineText", this.options.text.text, 0, 0);
	            this.add(text.text);
	            lineText = this.childOfName('lineText');
	        }
	        if (lineText) {
	            lineText.setStyle("text", this.options.text.text);
	
	            var textPoint = this.getTextPostion(this.options.text);
	
	            // if (this.options.style.lineType == Connector.TYPE_STRAIGHT ) {
	            //     lineText.attr('rotation', this.getTextRotation(textPoint));
	            // }
	
	            lineText.attr("position", textPoint);
	        }
	
	        this.refreshFromToSymbol(points);
	    };
	    /**
	     * 渲染
	     * @return {[type]} [description]
	     */
	    Connector.prototype.render = function() {
	        var that = this;
	        //1.创建箭头
	        this.renderFromToSymbol();
	
	        //2.创建线
	        this.curveLine = new graphic.BezierCurve({
	            //position: this.options.position,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.groupCurve.add(this.curveLine);
	        this.add(this.groupCurve);
	        this.add(this.conPointsGroup);
	
	        this.polyLine = new graphic.Polyline({
	            //position: this.options.position,
	            shape: this.options.shape,
	            style: this.options.style,
	            z: this.options.z
	        });
	        this.add(this.polyLine);
	
	        if ((this.options.style.lineType == Connector.TYPE_CURVE)) {
	            this.line = this.groupCurve;
	            this.createHoverStyle(this.curveLine);
	            this.polyLine.hide();
	        } else {
	            this.line = this.polyLine;
	            this.createHoverStyle(this.polyLine);
	            this.curveLine.hide();
	        }
	
	        //3.侦听线事件
	        var MOUSE_EVENT_NAMES = ['dblclick', 'click']; //'click', 'dblclick', 'mouseover', 'mouseout'
	        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	            this.line.on(eveName, zrUtil.bind(function(e) {
	                e.cancelBubble = true;
	                var params = {};
	                params.event = e;
	                params.type = "Connector:" + eveName;
	                params.target = that;
	                this.trigger(params.type, params);
	                this.setStyle({color:Connector.SELECTED_COLOR});
	                if (this.options.isEdit == false) {
	                    return; }
	
	                if (this.options.isEdit && this.turningPoints.length >= 2) {
	                    this.createAllconnectionPoint()
	                }
	                if (this.handles.length < 1) {
	                    this.shapeSetHandle();
	                }
	
	            }, this));
	        }, this);
	
	        //4.创建线上文本
	        if (this.options.text.text) {
	            var text = this.drawText("lineText", this.options.text.text, 0, 0);
	            this.add(text.text);
	        }
	    };
	
	    Connector.prototype.renderFromToSymbol = function(options) {
	        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle
	        if (symbolTo) {
	            this.add(symbolTo);
	        }
	        //如果双向箭头 则再创建首箭头
	        if (this.options.symbol.both) {
	            var symbolFrom = this.createSymbol('fromSymbol', this.options); //arrow,triangle
	            if (symbolFrom) {
	                this.add(symbolFrom);
	            }
	        }
	    }
	
	    Connector.prototype.refreshFromToSymbol = function(points) {
	        var symbolTo = this.childOfName('toSymbol');
	        var symbolFrom = this.childOfName('fromSymbol');
	        if (symbolTo) {
	            if (this.options.effect && this.options.effect.show) {
	                new EffectLine(symbolTo, this.options, this.groupCurve, this.polyLine);
	            } else {
	                symbolTo.attr('position', points[points.length - 1]);
	                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]));
	            }
	        }
	
	        if (symbolFrom) {
	            symbolFrom.attr('position', points[0]);
	            symbolFrom.attr('rotation', Util.tangentRotation(this.turningPoints[1], this.turningPoints[0]));
	        }
	    }
	    //设置style
	    Connector.prototype.setStyle = function(options) {
	        var symbolTo = null;
	        if (options.color) {
	            if (this.options.style.lineType == Connector.TYPE_CURVE) {
	                this.groupCurve.eachChild(function(curve) {
	                    curve.attr("style", { stroke: options.color });
	                    graphic.setNormalStyle(curve, { stroke: options.color });
	                });
	            } else {
	                this.polyLine.attr("style", { stroke: options.color });
	                graphic.setNormalStyle(this.polyLine, { stroke: options.color });
	            }
	            symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) {
	                symbolTo.attr("style", { fill: options.color });
	                graphic.setNormalStyle(symbolTo, { fill: options.color });
	            }
	            this.options.style.stroke = options.color;
	            this.model.set("options.style.stroke", options.color);
	            this.model.set("options.symbol.color", options.color);
	            this.options.symbol.color = options.color;
	        }
	
	        if (options.text) {
	            var lineText = this.childOfName('lineText');
	            //开始没有创建文本，后来传进来text了，需要先创建文本
	            if (!lineText && options.text.text) {
	                var text = this.drawText("lineText", options.text.text, 0, 0);
	                this.add(text.text);
	                lineText = this.childOfName('lineText');
	            }
	
	            if (options.text.text || options.text.text == "") {
	                lineText.setStyle("text", options.text.text);
	                this.options.text.text = options.text.text;
	            }
	            var textPoint = this.getTextPostion(options.text);
	            lineText.attr("position", textPoint);
	            if (options.text.textPos) {
	                this.options.text.textPos = options.text.textPos;
	            }
	
	            if (options.text.color) {
	                lineText.attr("style", {
	                    fill: options.text.color
	                });
	                this.options.text.color = options.text.color;
	            }
	            this.model.set("options.text", options.text);
	        }
	
	        if (options.symbol) {
	            if (options.symbol.type) {
	                this.options.symbol.type = options.symbol.type;
	                this.model.set("options.symbol.type", options.symbol.type);
	            }
	            if (options.symbol.size) {
	                this.options.symbol.size = options.symbol.size;
	                this.model.set("options.symbol.size", options.symbol.size);
	            }
	            if (options.symbol.color) {
	                this.options.symbol.color = options.symbol.color;
	                this.model.set("options.symbol.color", options.symbol.color);
	            }
	            if (options.symbol.z) {
	                this.options.symbol.z = options.symbol.z;
	                this.model.set("options.symbol.z", options.symbol.z);
	            }
	
	            symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) {
	                this.remove(symbolTo);
	            }
	            var symbol = this.createSymbol("toSymbol", this.model.get("options"))
	            if (symbol) {
	                this.add(symbol);
	            }
	            this.refresh();
	        }
	    };
	
	    /**
	     * 获取线段的位置
	     * @param  {Object} text {text:'', color:'', textPos:''}
	     * @return {Object}      {x,y}
	     */
	    Connector.prototype.getTextPostion = function(text) {
	        var textPostion = [];
	        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	        if (text && text.textPos) {
	            var offset = text.offset || 0;
	            var arrOffset = offset;
	            if (!zrUtil.isArray(offset)) {
	                arrOffset = [offset, 0];
	            }
	            if (text.textPos == 'start') {
	                textPostion = [this.turningPoints[0].x + arrOffset[0], this.turningPoints[0].y + arrOffset[1]];
	            } else if (text.textPos == 'end') {
	                var points = Util.getMaxLineLength([this.turningPoints[this.turningPoints.length - 2], this.turningPoints[this.turningPoints.length - 1]]);
	                var angle = Util.getAngle(points[0], points[1]);
	                var length = Util.distance(points[0], points[1]) - textWidth;
	                var newPoint = Util.getEndPoint(points[0], length, angle);
	                textPostion = [newPoint.x + arrOffset[0], newPoint.y + arrOffset[1]];
	            } else {
	                var midPoint = this.middle(text);
	                textPostion = [midPoint[0] + arrOffset[0], midPoint[1] + arrOffset[1]];
	            }
	        } else {
	            var position = this.middle(text);
	            textPostion = [position[0] - textWidth / 2, position[1]];
	        }
	
	        return textPostion;
	    };
	
	    /**
	     * 获取线段的旋转角度
	     * @param  {Object} textPostion {x,y}
	     * @return {Number}             角度值
	     */
	    Connector.prototype.getTextRotation = function(textPostion) {
	        //计算出极坐标的角度
	        var points = Util.getMaxLineLength(this.turningPoints);
	        var angle = -Math.atan2(points[1].y - textPostion[1], points[1].x - textPostion[0]); //,Math.PI/2
	        return angle;
	    };
	
	    Connector.prototype.createHoverStyle = function(el) {
	        if (this.options.hoverStyle) {
	            graphic.setElementHoverStl(el, this.options.hoverStyle);
	
	            var symbolTo = this.childOfName('toSymbol');
	            if (symbolTo) { graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle); }
	
	            el.on('mouseover', zrUtil.bind(function() {
	                    graphic.doEnterHover(el);
	                    if (symbolTo) { graphic.doEnterHover(symbolTo); }
	
	                    this.groupCurve.eachChild(function(line) {
	                        graphic.doEnterHover(line);
	                    });
	                }, this))
	                .on('mouseout', zrUtil.bind(function() {
	                    graphic.doLeaveHover(el);
	                    if (symbolTo) { graphic.doLeaveHover(symbolTo); }
	                    this.groupCurve.eachChild(function(line) {
	                        graphic.doLeaveHover(line);
	                    });
	                }, this));
	        }
	    };
	    /**
	     * 创建Node的连接点
	     * @private
	     *
	     * @return {[type]} [description]
	     */
	    Connector.prototype.createAllconnectionPoint = function() {
	        var sRect = this.startNode.getRect ? this.startNode.getRect().boundingRect : Util.getRect(this.startNode).boundingRect;
	
	        var eRect = this.endNode.getRect ? this.endNode.getRect().boundingRect : Util.getRect(this.endNode).boundingRect;
	
	        var sConnectorPoint = Util.getConnectorPoints(sRect);
	        var eConnectorPoint = Util.getConnectorPoints(eRect);
	
	        this.connectionPointCreate(this.startNode, sConnectorPoint.left, Connector.START_NODE + Connector.SEPERATOR + Connector.LEFT);
	        this.connectionPointCreate(this.startNode, sConnectorPoint.right, Connector.START_NODE + Connector.SEPERATOR + Connector.RIGHT);
	        this.connectionPointCreate(this.startNode, sConnectorPoint.top, Connector.START_NODE + Connector.SEPERATOR + Connector.TOP);
	        this.connectionPointCreate(this.startNode, sConnectorPoint.bottom, Connector.START_NODE + Connector.SEPERATOR + Connector.BOTTOM);
	
	        this.connectionPointCreate(this.endNode, eConnectorPoint.left, Connector.END_NODE + Connector.SEPERATOR + Connector.LEFT);
	        this.connectionPointCreate(this.endNode, eConnectorPoint.right, Connector.END_NODE + Connector.SEPERATOR + Connector.RIGHT);
	        this.connectionPointCreate(this.endNode, eConnectorPoint.top, Connector.END_NODE + Connector.SEPERATOR + Connector.TOP);
	        this.connectionPointCreate(this.endNode, eConnectorPoint.bottom, Connector.END_NODE + Connector.SEPERATOR + Connector.BOTTOM);
	
	
	        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);
	
	        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length - 1].clone(), ConnectionPoint.TYPE_CONNECTOR);
	    };
	
	    /**
	     * 创建连接点
	     * @private
	     * @param  {[type]} shape [description]
	     * @param  {[type]} point [description]
	     * @param  {[type]} type  [description]
	     * @return {[type]}       [description]
	     */
	    Connector.prototype.connectionPointCreate = function(shape, point, type) {
	        var conPoint = new ConnectionPoint(this, point, type, this.options);
	        this.conPointsGroup.add(conPoint.shape);
	    };
	
	    /**
	     * 清空控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.clearHandles = function() {
	        for (var i = 0; i < this.handles.length; i++) {
	            this.remove(this.handles[i].handleShape);
	        }
	        this.handles = [];
	        if (this.conPointsGroup) {
	            this.conPointsGroup.removeAll();
	        }
	        //恢复原来的颜色
	        this.setStyle({color:this.options.style.stroke});
	    };
	
	    /**
	     * 创建拆线 线断的控制点
	     * @return {[type]} [description]
	     */
	    Connector.prototype.shapeSetHandle = function() {
	        for (var i = 1; i < this.turningPoints.length - 2; i++) {
	            var h;
	            var x, y;
	            //是否在一条线上
	            var isCollineaityFirst = Util.collinearity(this.turningPoints[i - 1], this.turningPoints[i], this.turningPoints[i + 1]);
	            var isCollineaitySecond = Util.collinearity(this.turningPoints[i], this.turningPoints[i + 1], this.turningPoints[i + 2]);
	            if ((!isCollineaityFirst && (!isCollineaitySecond || this.turningPoints[i + 1].equals(this.turningPoints[i + 2]))) || ((!isCollineaityFirst || this.turningPoints[i - 1].equals(this.turningPoints[i])) && !isCollineaitySecond)) {
	
	                if (this.turningPoints[i].x === this.turningPoints[i + 1].x) { //same vertical
	                    x = this.turningPoints[i].x;
	                    y = (this.turningPoints[i].y + this.turningPoints[i + 1].y) / 2;
	
	                    h = new Handle('h', x, y, this);
	
	
	                } else if (this.turningPoints[i].y === this.turningPoints[i + 1].y) { // same horizontal
	                    x = (this.turningPoints[i].x + this.turningPoints[i + 1].x) / 2;
	                    y = this.turningPoints[i].y;
	                    h = new Handle('v', x, y, this);
	                }
	                if (h) {
	                    this.add(h.handleShape);
	                    this.handles.push(h);
	                }
	
	            }
	        }
	    };
	
	
	    /**
	     * 创建箭头
	     * @param  {[type]} name       [description]
	     * @param  {[type]} options [description]
	     * @return {[type]}            [description]
	     */
	    Connector.prototype.createSymbol = function(name, options) {
	        var symbolType = options.symbol.type;
	        var symbolSize = options.symbol.size;
	        if (symbolType === 'none') {
	            return;
	        }
	
	        if (!zrUtil.isArray(symbolSize)) {
	            symbolSize = [symbolSize, symbolSize];
	        }
	
	        var symbolZIndex = options.z;
	
	        if (options.symbol.z) { symbolZIndex = options.symbol.z }
	
	        var symbolPath = symbolUtil.createSymbol(
	            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,
	            symbolSize[0], symbolSize[1], symbolZIndex, options.symbol.color
	        );
	        symbolPath.name = name;
	
	        return symbolPath;
	    };
	
	    /**
	     * 绘制线段上的文本
	     * @param  {[type]} content [description]
	     * @param  {[type]} name [description]
	     * @param  {[type]} x       [description]
	     * @param  {[type]} y       [description]
	     * @param  {[type]} color   [description]
	     * @return {[type]}         [description]
	     */
	    Connector.prototype.drawText = function(name, content, x, y, color) {
	        var textStyle = zrUtil.defaults(this.options.text, {text:content, x:x, y:y, fill:color}, true);
	        var text = new graphic.Text({
	            style: textStyle,
	            zlevel: 20,
	            name : name
	        });
	        return {
	            text: text,
	            rect: text.getBoundingRect()
	        };
	    };
	
	    /**
	     * 获取线段的中间值
	     * @return {[type]} text
	     */
	    Connector.prototype.middle = function() {
	
	        if (this.options.style.lineType == Connector.TYPE_STRAIGHT) {
	            var points = Util.getMaxLineLength(this.turningPoints);
	            //如果是求线段上的文字的中间值
	            // if(text) {
	            //     //取出字的长度，计算角度，
	            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);
	            //     var angle = Util.getAngle(points[0],points[1]);
	            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;
	            //     var newPoint = Util.getEndPoint(points[0], length, angle);
	            //     return [newPoint.x, newPoint.y];
	            // } else {
	            //     var middleX = (points[0].x + points[1].x)/2;
	            //     var middleY = (points[0].y + points[1].y) /2;
	            //     return [middleX, middleY];
	            // }
	            var middleX = (points[0].x + points[1].x) / 2;
	            var middleY = (points[0].y + points[1].y) / 2;
	            return [middleX, middleY];
	        } else if (this.options.style.lineType == Connector.TYPE_JAGGED) {
	
	            //find total distance
	            var distance = this.getLength();
	
	            //find between what turning points the half distance is
	            var index = -1;
	            var ellapsedDistance = 0;
	            for (var i = 0; i < this.turningPoints.length - 1; i++) {
	                index = i;
	                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);
	                if (ellapsedDistance + segment < distance / 2) {
	                    ellapsedDistance += segment;
	                } else {
	                    break;
	                }
	            }
	
	            //we have the middle distance somewhere between i(ndex) and i(ndex)+1
	            if (index != -1) {
	                var missingDistance = distance / 2 - ellapsedDistance;
	                if (Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3)) { //vertical segment (same x)
	                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];
	                } else if (Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3)) { //horizontal segment (same y)
	                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];
	                } else {
	                    console.error("Connector:middle() - this should never happen " + this.turningPoints[index] + " " + this.turningPoints[index + 1] + " nr of points " + this.turningPoints.length);
	                }
	
	            }
	        } else if (this.options.style.lineType == Connector.TYPE_CURVE) {
	            var t = 0.5;
	            var l = this.getLength();
	
	            var walked = 0;
	            for (var j = 0; j < this.turningPoints.length - 1; j++) {
	                if (walked + Util.distance(this.turningPoints[j], this.turningPoints[j + 1]) > l * t) {
	                    break;
	                }
	
	                walked += Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);
	            }
	
	            var rest = l * t - walked;
	            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j + 1]);
	
	            //find the position/ration of the middle of Polyline on current segment
	            var segmentPercent = rest / currentSegmentLength;
	
	            var Xp = segmentPercent * (this.turningPoints[j + 1].x - this.turningPoints[j].x) + this.turningPoints[j].x;
	            var Yp = segmentPercent * (this.turningPoints[j + 1].y - this.turningPoints[j].y) + this.turningPoints[j].y;
	
	            return [Xp, Yp];
	
	        }
	
	        return null;
	    };
	
	    /**
	     * find total distance
	     * @return {Number} [description]
	     */
	    Connector.prototype.getLength = function() {
	        //find total distance
	        var distance = 0;
	        for (var i = 0; i < this.turningPoints.length - 1; i++) {
	            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i + 1]);
	        }
	        return distance;
	    };
	
	    /**
	     * 转JSON对象 bpmn使用
	     * @return {[type]} [description]
	     */
	    Connector.prototype.toJSON = function() {
	
	        this.model.set("resourceId", this.resourceId);
	        this.model.set("properties.type", 14);
	
	        this.model.set("bounds.upperLeft.x", this.position[0]);
	        this.model.set("bounds.upperLeft.y", this.position[1]);
	        this.model.set("bounds.lowerRight.x", parseInt(this.position[0] + this.getBoundingRect().width));
	        this.model.set("bounds.lowerRight.y", parseInt(this.position[1] + this.getBoundingRect().height));
	        this.model.set("style.sPos", this.options.position.startPos);
	        this.model.set("style.ePos", this.options.position.endPos);
	        this.model.set("dockers", this.turningPoints);
	        return this.model.option;
	    };
	
	    /**
	     * refreshModel  flow当序列化的时候调用 更新线段的位置 及线上的icons
	     * @return {[type]} [description]
	     */
	    Connector.prototype.refreshModel = function() {
	        this.model.set("options", zrUtil.clone(this.options));
	        this.model.set("options.dockers", this.turningPoints);
	        var icons = [];
	        for (var i = 0; i < this.icons.length; i++) {
	            var iconNode = this.icons[i];
	            var option = [iconNode.key, {
	                icon: iconNode.style.image,
	                width: iconNode.style.width,
	                height: iconNode.style.height
	            }];
	            icons.push(option);
	        }
	        this.model.set("icons", icons);
	    };
	
	    /**
	     * 调整曲线的形状
	     * @param  {array} points 点数组
	     * @return {void}
	     */
	    Connector.prototype.modifyCurve = function(points) {
	        var sol = this.getCurvePoint(points);
	
	        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段
	        var willDelCurves = [];
	        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve; j++) {
	            willDelCurves.push(this.groupCurve.childAt(j));
	        }
	        zrUtil.each(willDelCurves, function(curve) {
	            this.groupCurve.remove(curve);
	        }, this);
	        // 2. 遍历曲线   如果存在则直接设置形状，否则创建
	        for (var i = 0; i < sol.length; i++) {
	            var line = this.groupCurve.childAt(i);
	            if (line) {
	                line.attr('shape', sol[i]);
	            } else {
	                var cure = new graphic.BezierCurve({
	                   // position: this.options.position,
	                    style: this.options.style,
	                    shape: sol[i],
	                    z: this.options.z
	                });
	                this.groupCurve.add(cure);
	                this.createHoverStyle(cure);
	            }
	        }
	    };
	
	
	    /**
	     * 根据传入的点数组计算曲线的点
	     * @param  {array} P 点数组
	     * @return {object}        曲线的点数组
	     */
	    Connector.prototype.getCurvePoint = function(P) {
	        var n = P.length;
	        var sol = [];
	        if (n === 3) {
	            sol.push({
	                x1: P[0].x,
	                y1: P[0].y,
	                cpx1: P[1].x,
	                cpy1: P[1].y,
	                x2: P[2].x,
	                y2: P[2].y
	            });
	            return sol;
	        } else if (n === 4) {
	            sol.push({
	                x1: P[0].x,
	                y1: P[0].y,
	                cpx1: P[1].x,
	                cpy1: P[1].y,
	                cpx2: P[2].x,
	                cpy2: P[2].y,
	                x2: P[3].x,
	                y2: P[3].y
	            });
	            return sol;
	        }
	
	
	        /**Computes the sum between two point
	         *@param p1 - {Point}
	         *@param p2 - {Point}
	         *@return {Point} the sum of initial points
	         **/
	        function sum(p1, p2) {
	            return new Point(p1.x + p2.x, p1.y + p2.y);
	        }
	
	
	        /**Computes the division of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function divide(p, nr) {
	            if (nr == 0) {
	                throw "Division by zero not allowed (yet :) " + this.callee;
	            }
	            return new Point(p.x / nr, p.y / nr);
	        }
	
	        /**Computes the multiplication of a {Point} by a number
	         *@param p - {Point}
	         *@param nr - {Number}
	         *@return {Point}
	         **/
	        function multiply(p, nr) {
	            return new Point(p.x * nr, p.y * nr);
	        }
	
	
	
	
	        /*
	         *I do not get why first 4 must be 0 and last 3 of same value.....
	         *but otherwise we will get division by zero
	         */
	        var k = [0, 0, 0];
	
	        var j;
	        for (j = 0; j <= n - 3; j++) {
	            k.push(j);
	        }
	
	        k.push(n - 3, n - 3);
	
	
	
	        for (var i = 1; i <= n - 3; i++) {
	            //q1 - compute start point
	            var q1 = divide(sum(multiply(P[i], k[i + 4] - k[i + 2]), multiply(P[i + 1], k[i + 2] - k[i + 1])), k[i + 4] - k[i + 1]);
	
	            //q0 - compute 1st controll point
	            var q_01 = (k[i + 3] - k[i + 2]) / (k[i + 3] - k[i + 1]);
	            var q_02 = divide(sum(multiply(P[i - 1], k[i + 3] - k[i + 2]), multiply(P[i], k[i + 2] - k[i])), k[i + 3] - k[i]);
	            var q_03 = multiply(q1, (k[i + 2] - k[i + 1]) / (k[i + 3] - k[i + 1]));
	            var q0 = sum(multiply(q_02, q_01), q_03);
	
	            //q2 - compute 2nd controll point
	            var q2 = divide(sum(multiply(P[i], k[i + 4] - k[i + 3]), multiply(P[i + 1], k[i + 3] - k[i + 1])), k[i + 4] - k[i + 1]);
	
	            //q3 - compute end point
	            var q_31 = (k[i + 3] - k[i + 2]) / (k[i + 4] - k[i + 2]);
	            var q_32 = divide(sum(multiply(P[i + 1], k[i + 5] - k[i + 3]), multiply(P[i + 2], k[i + 3] - k[i + 2])), k[i + 5] - k[i + 2]);
	            var q_33 = multiply(q2, (k[i + 4] - k[i + 3]) / (k[i + 4] - k[i + 2]));
	            var q3 = sum(multiply(q_32, q_31), q_33);
	
	            //store solution
	            //
	            sol.push({
	                x1: q0.x,
	                y1: q0.y,
	                cpx1: q1.x,
	                cpy1: q1.y,
	                cpx2: q2.x,
	                cpy2: q2.y,
	                x2: q3.x,
	                y2: q3.y
	            });
	        }
	
	        return sol;
	    };
	
	
	    Util.inherits(Connector, Node);
	
	    module.exports = Connector;
	
	


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// Symbol factory
	
	
	    var graphic = __webpack_require__(4);
	    var BoundingRect = __webpack_require__(27);
	    /**
	     * Triangle shape
	     * @inner
	     */
	    var Triangle = graphic.extendShape({
	        type: 'triangle',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy + height);
	            path.lineTo(cx - width, cy + height);
	            path.closePath();
	        }
	    });
	    /**
	     * Diamond shape
	     * @inner
	     */
	    var Diamond = graphic.extendShape({
	        type: 'diamond',
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	        buildPath: function (path, shape) {
	            var cx = shape.cx;
	            var cy = shape.cy;
	            var width = shape.width / 2;
	            var height = shape.height / 2;
	            path.moveTo(cx, cy - height);
	            path.lineTo(cx + width, cy);
	            path.lineTo(cx, cy + height);
	            path.lineTo(cx - width, cy);
	            path.closePath();
	        }
	    });
	
	    /**
	     * Pin shape
	     * @inner
	     */
	    var Pin = graphic.extendShape({
	        type: 'pin',
	        shape: {
	            // x, y on the cusp
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (path, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var w = shape.width / 5 * 3;
	            // Height must be larger than width
	            var h = Math.max(w, shape.height);
	            var r = w / 2;
	
	            // Dist on y with tangent point and circle center
	            var dy = r * r / (h - r);
	            var cy = y - h + r + dy;
	            var angle = Math.asin(dy / r);
	            // Dist on x with tangent point and circle center
	            var dx = Math.cos(angle) * r;
	
	            var tanX = Math.sin(angle);
	            var tanY = Math.cos(angle);
	
	            path.arc(
	                x, cy, r,
	                Math.PI - angle,
	                Math.PI * 2 + angle
	            );
	
	            var cpLen = r * 0.6;
	            var cpLen2 = r * 0.7;
	            path.bezierCurveTo(
	                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,
	                x, y - cpLen2,
	                x, y
	            );
	            path.bezierCurveTo(
	                x, y - cpLen2,
	                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,
	                x - dx, cy + dy
	            );
	            path.closePath();
	        }
	    });
	
	    /**
	     * Arrow shape
	     * @inner
	     */
	    var Arrow = graphic.extendShape({
	
	        type: 'arrow',
	
	        shape: {
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var height = shape.height;
	            var width = shape.width;
	            var x = shape.x;
	            var y = shape.y;
	            var dx = width / 3 * 2;
	            ctx.moveTo(x, y);
	            ctx.lineTo(x + dx, y + height);
	            ctx.lineTo(x, y + height / 4 * 3);
	            ctx.lineTo(x - dx, y + height);
	            ctx.lineTo(x, y);
	            ctx.closePath();
	        }
	    });
	
	    /**
	     * Map of path contructors
	     * @type {Object.<string, module:zrender/graphic/Path>}
	     */
	    var symbolCtors = {
	        line: graphic.Line,
	
	        rect: graphic.Rect,
	
	        roundRect: graphic.Rect,
	
	        square: graphic.Rect,
	
	        circle: graphic.Circle,
	
	        diamond: Diamond,
	
	        pin: Pin,
	
	        arrow: Arrow,
	
	        triangle: Triangle
	    };
	
	    var symbolShapeMakers = {
	
	        line: function (x, y, w, h, shape) {
	            // FIXME
	            shape.x1 = x;
	            shape.y1 = y + h / 2;
	            shape.x2 = x + w;
	            shape.y2 = y + h / 2;
	        },
	
	        rect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        roundRect: function (x, y, w, h, shape) {
	            shape.x = x;
	            shape.y = y;
	            shape.width = w;
	            shape.height = h;
	            shape.r = Math.min(w, h) / 4;
	        },
	
	        square: function (x, y, w, h, shape) {
	            var size = Math.min(w, h);
	            shape.x = x;
	            shape.y = y;
	            shape.width = size;
	            shape.height = size;
	        },
	
	        circle: function (x, y, w, h, shape) {
	            // Put circle in the center of square
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.r = Math.min(w, h) / 2;
	        },
	
	        diamond: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        pin: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        arrow: function (x, y, w, h, shape) {
	            shape.x = x + w / 2;
	            shape.y = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        },
	
	        triangle: function (x, y, w, h, shape) {
	            shape.cx = x + w / 2;
	            shape.cy = y + h / 2;
	            shape.width = w;
	            shape.height = h;
	        }
	    };
	
	    var symbolBuildProxies = {};
	    for (var name in symbolCtors) {
	        symbolBuildProxies[name] = new symbolCtors[name]();
	    }
	
	    var Symbol = graphic.extendShape({
	
	        type: 'symbol',
	
	        shape: {
	            symbolType: '',
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        beforeBrush: function () {
	            var style = this.style;
	            var shape = this.shape;
	            // FIXME
	            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {
	                style.textPosition = ['50%', '40%'];
	                style.textAlign = 'center';
	                style.textVerticalAlign = 'middle';
	            }
	        },
	
	        buildPath: function (ctx, shape) {
	            var symbolType = shape.symbolType;
	            var proxySymbol = symbolBuildProxies[symbolType];
	            if (shape.symbolType !== 'none') {
	                if (!proxySymbol) {
	                    // Default rect
	                    symbolType = 'rect';
	                    proxySymbol = symbolBuildProxies[symbolType];
	                }
	                symbolShapeMakers[symbolType](
	                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape
	                );
	                proxySymbol.buildPath(ctx, proxySymbol.shape);
	            }
	        }
	    });
	
	    // Provide setColor helper method to avoid determine if set the fill or stroke outside
	    var symbolPathSetColor = function (color) {
	        if (this.type !== 'image') {
	            var symbolStyle = this.style;
	            var symbolShape = this.shape;
	            if (symbolShape && symbolShape.symbolType === 'line') {
	                symbolStyle.stroke = color;
	            }
	            else if (this.__isEmptyBrush) {
	                symbolStyle.stroke = color;
	                symbolStyle.fill = '#fff';
	            }
	            else {
	                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?
	                symbolStyle.fill && (symbolStyle.fill = color);
	                symbolStyle.stroke && (symbolStyle.stroke = color);
	            }
	            this.dirty();
	        }
	    };
	
	    var symbolUtil = {
	        /**
	         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
	         * @param {string} symbolType
	         * @param {number} x
	         * @param {number} y
	         * @param {number} w
	         * @param {number} h
	         * @param {number} z
	         * @param {string} color
	         */
	        createSymbol: function (symbolType, x, y, w, h, z, color) {
	            var isEmpty = symbolType.indexOf('empty') === 0;
	            if (isEmpty) {
	                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
	            }
	            var symbolPath;
	
	            if (symbolType.indexOf('image://') === 0) {
	                symbolPath = new graphic.Image({
	                    style: {
	                        image: symbolType.slice(8),
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	            else if (symbolType.indexOf('path://') === 0) {
	                symbolPath = graphic.makePath(symbolType.slice(7), {z: z, rectHover: true}, new BoundingRect(x, y, w, h));
	            }
	            else {
	                symbolPath = new Symbol({
	                    shape: {
	                        symbolType: symbolType,
	                        x: x,
	                        y: y,
	                        width: w,
	                        height: h
	                    },
	                    z: z
	                });
	            }
	
	            symbolPath.__isEmptyBrush = isEmpty;
	
	            symbolPath.setColor = symbolPathSetColor;
	
	            symbolPath.setColor(color);
	
	            return symbolPath;
	        }
	    };
	
	    module.exports = symbolUtil;
	


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 画句柄
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(4);
	    var Util = __webpack_require__(65);
	    function Handle(type, x, y, connector){
	        this.type = type;
	
	        this.x = x;
	
	        this.y = y;
	
	        this.visible = true;
	
	        this.connector = connector;
	
	        this.handleShape = new graphic.Circle({
	            shape: {
	                cx: x,
	                cy: y,
	                r: Handle.RADIUS
	            },
	
	            style: {
	                fill: "rgb(0,255,0)",
	                stroke:"rgb(0,0,0)"
	            },
	            z : connector.options.z + 2,  //节点Z为1 线段为0;
	            draggable:true
	        });
	
	        var that = this;
	        this.handleShape.on("drag", function(e) {
	            that.actionConnector(e.offsetX,e.offsetY);
	        });
	       // return this.circle;
	    }
	
	    Handle.RADIUS = 4;
	
	    Handle.prototype = {
	
	        constructor : Handle,
	
	        equals : function(anotherHandle){
	            if(!anotherHandle instanceof Handle){
	                return false;
	            }
	
	            return this.type == anotherHandle.type
	            && this.x == anotherHandle.x
	            && this.y == anotherHandle.y
	            && this.visible == anotherHandle.visible;
	        },
	
	        /**
	         * 移动句柄
	         * @param  {[type]} newX [description]
	         * @param  {[type]} newY [description]
	         * @return {[type]}      [description]
	         */
	        actionConnector: function(newX, newY){
	            switch(this.type){
	                case 'v':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y
	                            && this.connector.turningPoints[i].y == this.y
	                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x
	                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)
	                        {
	                            index = i;
	                        }
	                    }
	                    var deltaY = newY - this.y;
	                    var translationMatrix = Util.translationMatrix(0, deltaY);
	
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	                    this.y = newY;  //将句柄新的位置赋值给y
	
	                    break;
	
	                case 'h':
	                    var index;
	                    // 找出两个转折点（可移动句柄在这两个转折点中间）
	                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){
	                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x
	                            && this.connector.turningPoints[i].x == this.x
	                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y
	                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)
	                            {
	                            index = i;
	                        }
	                    }
	                    var deltaX = newX-this.x;
	                    var translationMatrix = Util.translationMatrix(deltaX, 0);
	                    this.connector.turningPoints[index-1].transform(translationMatrix);
	                    this.connector.turningPoints[index].transform(translationMatrix);
	                    this.connector.refresh();
	                    this.x = newX; //将句柄新的位置赋值给x
	
	                    break;
	            }
	           //. this.shape.updateMiddleText();
	        }
	    };
	    module.exports = Handle;
	
	
	


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连线动态效果
	 * @author miao.cunzhi
	 */
	
	    var zrUtil = __webpack_require__(5);
	    var vec2 = __webpack_require__(15);
	    var curveUtil = __webpack_require__(31);
	    var symbolUtil = __webpack_require__(83);
	
	    function EffectLine(symbol, options, groupCurve, polyLine) {
	        this._lastFrame = 0;
	        this._lastFramePercent = 0;
	        this.symbol = symbol;
	        this.groupCurve = groupCurve;
	        this.initSymbol(options, polyLine);
	    }
	    var EffectLineProto = EffectLine.prototype;
	
	    EffectLineProto.initSymbol = function(options, polyLine) {
	        var that = this;
	        this.symbol.z2 = 100;
	        this.symbol.culling = true;
	        var period = options.effect.period * 1000;
	        this.symbol.__t = 0;
	        this.symbol.stopAnimation();
	        if ((options.style.lineType == "curve")) {
	            if (this.groupCurve) {
	                var i = 0;
	                period = period / this.groupCurve._children.length;
	                this.groupCurveAnimate(this.groupCurve._children[0], i, period);
	            }
	
	        } else {
	            this.symbol.animate('', true)
	                .when(period, {
	                    __t: 1
	                })
	                .delay(0)
	                .during(function() {
	                    that.updateSymbolPositionPolyline();
	                })
	                .start();
	            this.setAnimationPointsPolyline(polyLine.shape.points);
	        }
	
	    };
	
	    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {
	        var that = this;
	        if (curveLine == undefined) {
	            curveLine = this.groupCurve._children[0];
	            i = 0;
	        }
	        var points;
	        var pos = curveLine.shape;
	        points = [
	            [pos.x1, pos.y1],
	            [pos.x2, pos.y2],
	            [pos.cpx1, pos.cpy1],
	            [pos.cpx2, pos.cpy2]
	        ];
	        this.setAnimationPointsBezierCurve(points);
	        this.symbol.animate('')
	            .when(period, {
	                __t: 1
	            })
	            .delay(0)
	            .during(function() {
	                that.updateSymbolPositionBezierCurve();
	            })
	            .done(function() {
	                that.symbol.__t = 0;
	                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);
	            })
	            .start();
	
	    };
	
	
	    EffectLineProto.setAnimationPointsBezierCurve = function(points) {
	        this.symbol.__p1 = points[0];
	        this.symbol.__p2 = points[1];
	        this.symbol.__cp1 = points[2] || [
	            (points[0][0] + points[1][0]) / 2,
	            (points[0][1] + points[1][1]) / 2
	        ];
	        this.symbol.__cp2 = points[3];
	    };
	
	    EffectLineProto.updateSymbolPositionBezierCurve = function() {
	        var p1 = this.symbol.__p1;
	        var p2 = this.symbol.__p2;
	        var cp1 = this.symbol.__cp1;
	        var cp2 = this.symbol.__cp2;
	        var t = this.symbol.__t;
	        var pos = this.symbol.position;
	        var tx, ty;
	        if (cp2[0] != undefined) {
	            var cubicAt = curveUtil.cubicAt;
	            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;
	            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);
	            // Tangent
	            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);
	            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);
	        } else {
	            var quadraticAt = curveUtil.quadraticAt;
	            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;
	            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);
	            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);
	            // Tangent
	            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);
	            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);
	        }
	        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
	
	        this.symbol.ignore = false;
	    };
	
	    EffectLineProto.setAnimationPointsPolyline = function(points) {
	        this._points = points;
	        var accLenArr = [0];
	        var len = 0;
	        for (var i = 1; i < points.length; i++) {
	            var p1 = points[i - 1];
	            var p2 = points[i];
	            len += vec2.dist(p1, p2);
	            accLenArr.push(len);
	        }
	        if (len === 0) {
	            return;
	        }
	
	        for (var j = 0; j < accLenArr.length; j++) {
	            accLenArr[j] /= len;
	        }
	        this._offsets = accLenArr;
	        this._length = len;
	        this.symbol._lastFrame = 0;
	        this.symbol.__lastFramePercent = 0;
	    };
	
	    EffectLineProto.updateSymbolPositionPolyline = function() {
	        var t = this.symbol.__t;
	        var points = this._points;
	        var offsets = this._offsets;
	        var len = points.length;
	
	        if (!offsets) {
	            // Has length 0
	            return;
	        }
	
	        var lastFrame = this._lastFrame;
	        var frame;
	
	        if (t < this._lastFramePercent) {
	            // Start from the next frame
	            // PENDING start from lastFrame ?
	            var start = Math.min(lastFrame + 1, len - 1);
	            for (frame = start; frame >= 0; frame--) {
	                if (offsets[frame] <= t) {
	                    break;
	                }
	            }
	            // PENDING really need to do this ?
	            frame = Math.min(frame, len - 2);
	        } else {
	            for (var frame = lastFrame; frame < len; frame++) {
	                if (offsets[frame] > t) {
	                    break;
	                }
	            }
	            frame = Math.min(frame - 1, len - 2);
	        }
	        vec2.lerp(
	            this.symbol.position, points[frame], points[frame + 1],
	            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])
	        );
	
	        this._lastFrame = frame;
	        this._lastFramePercent = t;
	        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);
	        this.symbol.rotation = angle - Math.PI / 2;
	        this.symbol.ignore = false;
	    };
	    module.exports = EffectLine;
	


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 控制点
	 * @author wang.xiaohu
	 */
	
	    var graphic = __webpack_require__(4);
	    function ConnectionPoint(connector, point, type, options){
	        this.connector = connector;
	
	        this.point = point.clone();
	
	        this.type = type;
	
	        this.color = ConnectionPoint.NORMAL_COLOR;
	
	        this.oType = 'ConnectionPoint';
	
	        this.shape = new graphic.Circle({
	            shape: {
	                cx: this.point.x,
	                cy: this.point.y,
	                r: ConnectionPoint.RADIUS
	            },
	
	            style: {
	                fill: this.color,
	                stroke:'#000000'
	            },
	            z : options.z + 2  //节点Z为1 线段为0;
	        });
	        this.shape.type =  this.type;
	
	        this.shape.connector = connector;
	        //return this.circle;
	    }
	
	    ConnectionPoint.NORMAL_COLOR = "#FFFF33"; //yellow.
	
	    ConnectionPoint.OVER_COLOR = "#FF9900"; //orange
	
	    ConnectionPoint.CONNECTED_COLOR = "#ff0000"; //red
	
	    ConnectionPoint.RADIUS = 4;
	
	    ConnectionPoint.TYPE_FIGURE = 'figure';
	
	    ConnectionPoint.TYPE_CONNECTOR = 'connector';
	
	    ConnectionPoint.prototype = {
	
	        constructor : ConnectionPoint,
	
	        equals : function(anotherConnectionPoint){
	            return this.point.equals(anotherConnectionPoint.point)
	            && this.connector == anotherConnectionPoint.connector
	            && this.type == anotherConnectionPoint.type
	            && this.color == anotherConnectionPoint.color
	            && this.radius == anotherConnectionPoint.radius;
	        }
	
	
	    };
	    module.exports = ConnectionPoint;
	
	
	


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 节点等的模型
	 * 里面存的数据用来处理序列化和反序列化
	 * @class fish.topo.model
	 */
	
	
	    var zrUtil = __webpack_require__(5);
	    var clazzUtil = __webpack_require__(88);
	
	    function Model(option, parentModel,  extraOpt) {
	        this.parentModel = parentModel;
	        this.option = option;
	
	        // Simple optimization
	        if (this.init) {
	            if (arguments.length <= 3) {
	                this.init(option, parentModel,  extraOpt);
	            }
	            else {
	                this.init.apply(this, arguments);
	            }
	        }
	    }
	
	    Model.prototype = {
	
	        constructor: Model,
	
	        /**
	         * Model 的初始化函数
	         * @private
	         * @param {Object} option
	         */
	        init: function (option) {
	            zrUtil.merge(option, this.getDefaultOption());
	        },
	
	        getDefaultOption: function () {
	            if (!this.hasOwnProperty('__defaultOption')) {
	                var optList = [];
	                var Class = this.constructor;
	                while (Class) {
	                    var opt = Class.prototype.defaultOption;
	                    opt && optList.push(opt);
	                    Class = Class.superClass;
	                }
	
	                var defaultOption = {};
	                for (var i = optList.length - 1; i >= 0; i--) {
	                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);
	                }
	                this.__defaultOption = defaultOption;
	            }
	            return this.__defaultOption;
	        },
	
	        /**
	         * @private
	         */
	        mergeOption: function (option) {
	            zrUtil.merge(this.option, option, true);
	        },
	
	        /**
	         * 获取model的某个属性的值
	         * @param {string} path model中的属性
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.get("options.text");
	         */
	        get: function (path, ignoreParent) {
	            if (!path) {
	                return this.option;
	            }
	
	            if (typeof path === 'string') {
	                path = path.split('.');
	            }
	
	            var obj = this.option;
	            var parentModel = this.parentModel;
	            for (var i = 0; i < path.length; i++) {
	                // obj could be number/string/... (like 0)
	                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;
	                if (obj == null) {
	                    break;
	                }
	            }
	            if (obj == null && parentModel && !ignoreParent) {
	                obj = parentModel.get(path);
	            }
	            return obj;
	        },
	
	        /**
	         * 设置model的某个属性的值
	         * @param {string} path model中的属性
	         * @param {String} value 所需要设置的值
	         * @return {String}
	         *
	         * **使用范例**：
	         *
	         *      @example
	         *          node.model.set("options.text","例子");
	         */
	        set: function (path, value) {
	            var obj = this.option;
	
	            if (path.indexOf(".") == -1) {
	                obj[path] = value;
	            } else {
	                var fieldArray  = path.split('.');
	                var n = fieldArray.length;
	                var currentRef = obj;
	                var fieldName;
	
	                for (var i = 0; i < n - 1; i++) {
	                    fieldName = fieldArray[i];
	                    if(currentRef[fieldName] == null) {
	                        currentRef[fieldName] = {};
	                    }
	                    currentRef = currentRef[fieldName];
	                }
	                fieldName = fieldArray[n-1];
	                currentRef[fieldName] = value;
	            }
	        },
	
	        /**
	         * @private
	         */
	        getShallow: function (key, ignoreParent) {
	            var option = this.option;
	            var val = option && option[key];
	            var parentModel = this.parentModel;
	            if (val == null && parentModel && !ignoreParent) {
	                val = parentModel.getShallow(key);
	            }
	            return val;
	        },
	
	        /**
	         * @private
	         */
	        getModel: function (path, parentModel) {
	            var obj = this.get(path, true);
	            var thisParentModel = this.parentModel;
	            var model = new Model(
	                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))
	            );
	            return model;
	        },
	
	        /**
	         *清空model的option
	         * @private
	         */
	        isEmpty: function () {
	            return this.option == null;
	        },
	
	        restoreData: function () {},
	
	        /**
	         * @private
	         */
	        clone: function () {
	            var Ctor = this.constructor;
	            return new Ctor(zrUtil.clone(this.option));
	        }
	    };
	
	    // Enable Model.extend.
	    clazzUtil.enableClassExtend(Model);
	
	    module.exports = Model;
	


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var zrUtil = __webpack_require__(5);
	
	    var clazz = {};
	
	    var TYPE_DELIMITER = '.';
	    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';
	    /**
	     * @public
	     */
	    var parseClassType = clazz.parseClassType = function (componentType) {
	        var ret = {main: '', sub: ''};
	        if (componentType) {
	            componentType = componentType.split(TYPE_DELIMITER);
	            ret.main = componentType[0] || '';
	            ret.sub = componentType[1] || '';
	        }
	        return ret;
	    };
	    /**
	     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数
	     */
	    clazz.enableClassExtend = function (RootClass, preConstruct) {
	        RootClass.extend = function (proto) {
	            var ExtendedClass = function () {
	                preConstruct && preConstruct.apply(this, arguments);
	                RootClass.apply(this, arguments);
	            };
	
	            zrUtil.extend(ExtendedClass.prototype, proto);
	
	            ExtendedClass.extend = this.extend;
	            ExtendedClass.superCall = superCall;
	            ExtendedClass.superApply = superApply;
	            zrUtil.inherits(ExtendedClass, this);
	            ExtendedClass.superClass = this;
	
	            return ExtendedClass;
	        };
	    };
	
	    // superCall should have class info, which can not be fetch from 'this'.
	    // Consider this case:
	    // class A has method f,
	    // class B inherits class A, overrides method f, f call superApply('f'),
	    // class C inherits class B, do not overrides method f,
	    // then when method of class C is called, dead loop occured.
	    function superCall(context, methodName) {
	        var args = zrUtil.slice(arguments, 2);
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    function superApply(context, methodName, args) {
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    /**
	     * @param {Object} entity
	     * @param {Object} options
	     * @param {boolean} [options.registerWhenExtend]
	     * @public
	     */
	    clazz.enableClassManagement = function (entity, options) {
	        options = options || {};
	
	        /**
	         * Component model classes
	         * key: componentType,
	         * value:
	         *     componentClass, when componentType is 'xxx'
	         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
	         * @type {Object}
	         */
	        var storage = {};
	
	        entity.registerClass = function (Clazz, componentType) {
	            if (componentType) {
	                componentType = parseClassType(componentType);
	
	                if (!componentType.sub) {
	                    if (storage[componentType.main]) {
	                        //已经注册过了，直接返回
	                        return;
	                    }
	                    storage[componentType.main] = Clazz;
	                }
	                else if (componentType.sub !== IS_CONTAINER) {
	                    var container = makeContainer(componentType);
	                    container[componentType.sub] = Clazz;
	                }
	            }
	            return Clazz;
	        };
	
	        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {
	            var Clazz = storage[componentTypeMain];
	
	            if (Clazz && Clazz[IS_CONTAINER]) {
	                Clazz = subType ? Clazz[subType] : null;
	            }
	
	            if (throwWhenNotFound && !Clazz) {
	                throw new Error(
	                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'
	                );
	            }
	
	            return Clazz;
	        };
	
	        entity.getClassesByMainType = function (componentType) {
	            componentType = parseClassType(componentType);
	
	            var result = [];
	            var obj = storage[componentType.main];
	
	            if (obj && obj[IS_CONTAINER]) {
	                zrUtil.each(obj, function (o, type) {
	                    type !== IS_CONTAINER && result.push(o);
	                });
	            }
	            else {
	                result.push(obj);
	            }
	
	            return result;
	        };
	
	        entity.hasClass = function (componentType) {
	            // Just consider componentType.main.
	            componentType = parseClassType(componentType);
	            return !!storage[componentType.main];
	        };
	
	        /**
	         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
	         */
	        entity.getAllClassMainTypes = function () {
	            var types = [];
	            zrUtil.each(storage, function (obj, type) {
	                types.push(type);
	            });
	            return types;
	        };
	
	        /**
	         * If a main type is container and has sub types
	         * @param  {string}  componentType
	         * @return {boolean}
	         */
	        entity.hasSubTypes = function (componentType) {
	            componentType = parseClassType(componentType);
	            var obj = storage[componentType.main];
	            return obj && obj[IS_CONTAINER];
	        };
	
	        entity.parseClassType = parseClassType;
	
	        function makeContainer(componentType) {
	            var container = storage[componentType.main];
	            if (!container || !container[IS_CONTAINER]) {
	                container = storage[componentType.main] = {};
	                container[IS_CONTAINER] = true;
	            }
	            return container;
	        }
	
	        if (options.registerWhenExtend) {
	            var originalExtend = entity.extend;
	            if (originalExtend) {
	                entity.extend = function (proto) {
	                    var ExtendedClass = originalExtend.call(this, proto);
	                    return entity.registerClass(ExtendedClass, proto.type);
	                };
	            }
	        }
	
	        return entity;
	    };
	
	    module.exports = clazz;
	


/***/ }),
/* 89 */
/***/ (function(module, exports) {

	/**
	 * 操作图标类
	 * @author wang.xiaohu
	 */
	
	
	    var IconOperation = {
	        STRAIGHT_SVG: 'M13.961,2.309c-0.051-0.122-0.148-0.22-0.27-0.27L13.5,2h-5C8.224,2,8,2.224,8,2.5S8.224,3,8.5,3h3.793L2.146,13.146c-0.195,0.195-0.195,0.512,0,0.707s0.512,0.195,0.707,0L13,3.707V7.5C13,7.776,13.225,8,13.5,8S14,7.776,14,7.5v-5L13.961,2.309z',
	        JAGGED_SVG: 'M653.604571 440.905143l289.499429 339.529143 414.134857-538.404572v195.803429h104.155429V0l-381.805715 144.969143 37.083429 97.426286 153.526857-58.294858-331.190857 430.738286-279.698286-327.753143-657.846857 663.552L75.483429 1024z',
	        CURVE_SVG: 'M956.9 67.6h-240v240h92.5c1.6 22.6 3.6 68.3-0.8 116.7C803.3 483 787.5 558 742.4 582c-45.5 24.2-121.1-6.6-218.7-89-57.5-48.5-109.5-80.6-154.3-95.3-43.7-14.3-82.3-13-114.6 4-53.6 28.2-86.2 96.8-96.7 204-4.3 43.5-4 84.2-2.9 111.5H68.3v240h240v-240H205.2c-1.1-25.6-1.5-65 2.6-106.6 6.1-61.5 23.1-140 70.2-164.7 45.3-23.8 119.1 5.7 213.5 85.3 59.4 50.1 112.7 83.3 158.5 98.5 44.5 14.9 83.5 13.6 116-3.6 52.2-27.7 83.3-94.4 92.6-198.1 4.4-49.5 2.7-95.2 1.1-120.4h97.4v-240zM258.3 907.2h-140v-140h140v140z m648.6-649.6h-140v-140h140v140z',
	        DEL_SVG: 'M73.641,45.957l-0.021,0.252c0,0.032,0.021,0.06,0.021,0.088c0,0.065-0.022,0.126-0.026,0.191l-2.685,54.878H70.91c-0.231,4.304-5.166,10.81-31.748,10.81c-26.58,0-31.509-6.506-31.746-10.81H7.41L4.731,46.488c-0.009-0.06-0.028-0.126-0.028-0.191c0-0.032,0.01-0.06,0.01-0.088l-0.01-0.252h0.028c0.099-0.466,0.364-0.919,0.784-1.353c3.439,3.477,17.191,4.051,33.646,4.051s30.221-0.574,33.642-4.051c0.426,0.434,0.711,0.887,0.784,1.353H73.641z M78.335,25.102v6.407c0,1.316-1.34,2.567-3.715,3.696c-6.266,2.936-19.777,4.975-35.459,4.975c-15.666,0-29.189-2.039-35.442-4.975C1.33,34.075,0,32.825,0,31.509v-6.407c0-3.374,8.681-6.286,21.359-7.724V3.929c0-2.16,1.768-3.929,3.93-3.929h26.314c2.164,0,3.938,1.773,3.938,3.938v13.296C68.98,18.606,78.333,21.611,78.335,25.102z M48.416,11.395c0-2.348-0.321-4.27-0.715-4.27c-0.393,0-2.641,0-4.979,0h-8.545c-2.352,0-4.592,0-4.989,0c-0.388,0-0.714,1.922-0.714,4.27v5.367l1.083-0.065c3.067-0.173,6.286-0.27,9.595-0.271c3.202,0,6.292,0.098,9.264,0.252V11.395z',
	        STRAIGHT_IMG: 'data:image/png;base64,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',
	        JAGGED_IMG: 'data:image/png;base64,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',
	        CURVE_IMG: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAACaSURBVHjajNA9DgEBEIbhZ0UUoheRKF1Bq3UeF1iVQqVQaSQO4gCi5AISjUYphNEsySa7dieZYr7M+82PiFCWSBG5/AcUQQ3V0cb7W9QBurhgBs0awAiniEiTJFG1/zDbffrTKoAN7uhVAphkxy5yeknzGDcc0CoFMMASTxzRLzAzxxp7vPDACp2i6Unmds0cd9hGxLnsx58BAG8c3pZpbM8/AAAAAElFTkSuQmCC',
	        DEL_IMG: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAOBAMAAADpk+DfAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAtUExURQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGgKD4AAAAPdFJOUwDH/g+agESj4Y6zUiRnh7lnwbkAAABLSURBVAjXY2BgYDZgAIEnnkCa7a5cYGwCwwklIOhhMBEEgmIGnlAgOMDAprhQUGgDA5vWdJciXJRGR0dTAgPzQ0FBSaBpzMbGBgwAIoUW3sQ2EdkAAAAASUVORK5CYII=',
	        CHANGE_LINE_TYPE_IMG: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAPBAMAAAD9gUllAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAqUExURQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoTzogAAAAOdFJOUwD+CC3uuR7gVXeeFEnMRIEDJwAAAGRJREFUCNdjYOCZwIAA7YuUQADM1nQsDQWBBBBnoSAYiBiAOGeROWwLIzpAYANEE7JpDBtQKAiYqQCmlI1BYOFqMMfcBQQERcEGmkBMFwwAcWzLQcBRCuwItTQQWD4JybQ5DAwAO74b0S83OyMAAAAASUVORK5CYII='
	    }
	    module.exports = IconOperation;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * flow连线管理类
	 * @author miao.cunzhi
	 */
	
	    var zrUtil = __webpack_require__(5);
	    var ConnectionManager = __webpack_require__(91);
	    var Connector = __webpack_require__(82);
	    var Util = __webpack_require__(65);
	    var Point = __webpack_require__(66);
	    var Constants = __webpack_require__(93);
	
	    function FlowConnectionManager(api) {
	        ConnectionManager.call(this);
	        this.bundleOffset = 30; //多线段的偏移
	        this.bundleGap = 20; // 多线段的间隔
	        this.connectorMap = Util.StackedMap.createNew(); //存放多线段
	        this._api = api;
	    }
	
	    FlowConnectionManager.prototype.add = function(connector) {
	        this.connectors.push(connector);
	        //1.处理事件
	        this.handleConnectorEvent(connector);
	        //2.判断是否两节点相联
	        if(connector.startNode && connector.endNode) {
	            var key = this.getTwoNodeId(connector.startNode, connector.endNode);
	            this.connectorMap.add(key, connector);
	
	            this.handleConnectorShrink(connector);
	
	            this.bundleOffset = connector.options.bundleOffset || this.bundleOffset;
	            this.bundleGap = connector.options.bundleGap || this.bundleGap;
	            //2. 获取这个key对应的线段数组
	            var arrCons = this.connectorMap.get(key);
	            if (arrCons.length == 1) {
	                //两个节点只有一个连线的情况
	                //判断一下 model里有没有dockers，如果有则调用构造point数组  或者调用refreshConnector计算如何画线
	                var dockers = connector.options.dockers;
	                var points = [];
	                if (dockers && dockers.length >= 2) {
	                    points = Point.loadArray(dockers);
	                    connector.refresh(points);
	                } else {
	                    if (connector.options.position.points) {
	                        var arrStartEndPoint = this.getStartEndPoint(connector);
	                        points = connector.options.position.points;
	                        points.unshift(arrStartEndPoint[0]);
	                        points.push(arrStartEndPoint[1]);
	                        connector.refresh(points);
	                    } else {
	                        this.refreshConnector(arrCons[0], true);
	                    }
	                }
	            } else if (arrCons.length > 1) {
	                //两个节点有多个连线的情况
	                this.refreshCons(arrCons);
	            }
	        } else {
	            //处理没有 起始节点与终止节点时的连线
	            this.handleConnectorPoints(connector)
	        }
	
	        //3.设置模型
	        this.handleConnectorModel(connector);
	        return connector;
	    }
	
	    FlowConnectionManager.prototype.handleConnectorEvent = function(connector) {
	        if (connector.conPointsGroup) {
	            connector.conPointsGroup.on("click", function(e) {
	                var arrSplit = e.target.type.split(Connector.SEPERATOR);
	                var connector = e.target.connector;
	                if (arrSplit[0] === Connector.START_NODE) {
	                    connector.options.position.startPos = arrSplit[1];
	                } else if (arrSplit[0] === Connector.END_NODE) {
	                    connector.options.position.endPos = arrSplit[1];
	                }
	                this.refreshConnector(connector, true);
	                e.cancelBubble = true;
	                var params = {};
	                params.event = e;
	                params.type = "conPointsGroup:click";
	                params.lineNode = this.selConnector;
	                this._api.trigger(params.type, params);
	            }.bind(this));
	        }
	
	
	        var MOUSE_EVENT_NAMES = ['click', 'dblclick'];
	        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {
	            connector.on("Connector:" + eveName, function(e) {
	                var selected = e.target;
	                if (this.selConnector !== selected) {
	                    this.selConnector && this.refreshConnector(this.selConnector);
	                    this.selConnector = selected;
	                }
	                e.cancelBubble = true;
	                var params = {};
	                params.event = e;
	                params.type = eveName;
	                params.target = this.selConnector;
	                this._api.trigger(params.type, params);
	            }.bind(this));
	        }.bind(this));
	    }
	
	    FlowConnectionManager.prototype.handleConnectorModel = function(connector) {
	        connector.model.set(Constants.ELEMENT_TYPE, Constants.CONNECTION);
	        if(connector.startNode && connector.endNode) {
	            connector.model.set(Constants.START_ID, connector.startNode.id);
	            connector.model.set(Constants.END_ID, connector.endNode.id);
	        }
	        connector.model.set(Constants.OPTIONS, zrUtil.clone(connector.options));
	    }
	
	    FlowConnectionManager.prototype.handleConnectorShrink = function(connector) {
	        var that = this;
	        //双击收紧为一条线
	        connector.line.on("dblclick", function() {
	            if (connector.options.isShrink == false) {
	                return;
	            }
	            var con = this.parent;
	            var startNode = con.startNode;
	            var endNode = con.endNode;
	            //1.获取所有的线段
	            var key = that.getTwoNodeId(startNode, endNode);
	            var cons = that.connectorMap.get(key);
	            if (cons.length == 1) {
	                return
	            }
	            //2.判断线是否处于隐藏状态
	            //2.将除中间的一条线进行隐藏
	            var half = parseInt(cons.length / 2);
	            for (var i = 0; i < cons.length; i++) {
	                if (i != (half)) {
	                    if (cons[i].ignore) {
	                        cons[i].show();
	                    } else {
	                        cons[i].hide();
	                    }
	                }
	            }
	        })
	    }
	
	    //处理没有 起始节点与终止节点时的连线
	    FlowConnectionManager.prototype.handleConnectorPoints = function(connector) {
	        var options = connector.options;
	        var dockers = connector.options.dockers;
	        if (dockers && dockers.length >= 2) {
	            var points = Point.loadArray(dockers);
	            connector.refresh(points);
	        } else {
	            if (options.position && options.position.points) {
	                var oPoints = options.position.points;
	                connector.refresh(oPoints);
	            }
	        }
	    }
	
	    FlowConnectionManager.prototype.getTwoNodeId = function(startNode, endNode) {
	            return startNode.id + "," + endNode.id;
	    }
	        //处理多条线段
	    FlowConnectionManager.prototype.refreshCons = function(arrCons) {
	        //如果是折线的话
	        if (arrCons[0].options.style.lineType == Connector.TYPE_JAGGED) {
	            for (var i = 0; i < arrCons.length; i++) {
	                this.refreshConnector(arrCons[i], true);
	            }
	        } else {
	            this.refreshConsStraight(arrCons);
	        }
	    }
	
	    //处理多条线段(直线)
	    FlowConnectionManager.prototype.refreshConsStraight = function(arrCons) {
	        var half = parseInt(arrCons.length / 2);
	        var arrConnectResult = []
	
	        var startNode = arrCons[0].startNode;
	        var endNode = arrCons[0].endNode;
	        var sRect = Util.getRect(startNode).boundingRect;
	        var eRect = Util.getRect(endNode).boundingRect;
	        var sConnectorPoint = Util.getConnectorPoints(sRect);
	        var eConnectorPoint = Util.getConnectorPoints(eRect);
	        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	        var position = arrCons[0].options.position;
	        if (!position.startPos || !position.endPos) {
	            if (sRect.x < eRect.x) {
	                position.startPos = "right";
	                position.endPos = "left";
	            } else {
	                position.startPos = "left";
	                position.endPos = "right";
	            }
	        }
	
	        var startPoint = sConnectorPoint[position.startPos];
	        var endPoint = eConnectorPoint[position.endPos];
	        var angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);
	        var points = [];
	        for (var i = half; i >= 1; i--) {
	            points = []; //var points = [];
	            points.push(startPoint); //
	            // points.push(new Point(startPoint.x + bundleOffset , startPoint.y + i * bundleGap));
	            // points.push(new Point(endPoint.x - bundleOffset , startPoint.y + i * bundleGap)); //startPoint.x + bundleOffset
	            var secondPoint = startPoint.clone();
	
	            //secondPoint.x =  secondPoint.x + this.bundleOffset;
	            secondPoint.transform(Util.translationMatrix(0, this.bundleGap * i));
	            //secondPoint = this.boundOffsetXY(secondPoint, true);
	            //
	            //直角坐标 x, 和 y, 计算出极坐标
	
	
	            //从极坐标计算出直角坐标
	            secondPoint.x = secondPoint.x + this.bundleOffset * Math.cos(angle);
	            secondPoint.y = secondPoint.y + this.bundleOffset * Math.sin(angle);
	
	
	
	            //secondPoint.transform(Util.scaleMatrix(0.5));
	            points.push(secondPoint);
	
	            var thirdPoint = endPoint.clone();
	            //thirdPoint.x =  thirdPoint.x - this.bundleOffset;
	
	
	
	            thirdPoint.transform(Util.translationMatrix(0, this.bundleGap * i));
	            //thirdPoint = this.boundOffsetXY(thirdPoint, false);
	            //secondPoint.transform(Util.scaleMatrix(0.5));
	            //
	            //直角坐标 x, 和 y, 计算出极坐标
	
	            //从极坐标计算出直角坐标
	            thirdPoint.x = thirdPoint.x - this.bundleOffset * Math.cos(angle);
	            thirdPoint.y = thirdPoint.y - this.bundleOffset * Math.sin(angle);
	
	            points.push(thirdPoint);
	
	            points.push(endPoint);
	            arrConnectResult.push(points);
	        }
	
	        arrConnectResult.push([startPoint, endPoint]);
	
	        var upHalf = Math.ceil(arrCons.length / 2);
	        for (i = 1; i < upHalf; i++) {
	            points = []; //var points = [];
	            points.push(startPoint);
	            var secPoint = startPoint.clone();
	            //secPoint.x =  secPoint.x + this.bundleOffset;
	            secPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));
	            secPoint.x = secPoint.x + this.bundleOffset * Math.cos(angle);
	            secPoint.y = secPoint.y + this.bundleOffset * Math.sin(angle);
	            points.push(secPoint);
	
	            var thdPoint = endPoint.clone();
	            //thdPoint.x =  thdPoint.x - this.bundleOffset;
	            thdPoint.transform(Util.translationMatrix(0, -this.bundleGap * i));
	            //从极坐标计算出直角坐标
	            thdPoint.x = thdPoint.x - this.bundleOffset * Math.cos(angle);
	            thdPoint.y = thdPoint.y - this.bundleOffset * Math.sin(angle);
	            //secondPoint.transform(Util.scaleMatrix(0.5));
	            points.push(thdPoint);
	
	            points.push(endPoint);
	            arrConnectResult.push(points);
	        }
	
	
	        for (i = 0; i < arrConnectResult.length; i++) {
	            arrCons[i].refresh(arrConnectResult[i]);
	        }
	
	    }
	
	    FlowConnectionManager.prototype.boundOffsetXY = function(point, isPositive) {
	        var resultPoint = point.clone();
	        //直角坐标 x, 和 y, 计算出极坐标
	        var angle = Math.atan2(resultPoint.y, resultPoint.x);
	        var r = Math.sqrt(Math.pow(resultPoint.x, 2) + Math.pow(resultPoint.y, 2));
	        if (isPositive) {
	            r = r + this.bundleOffset;
	        } else {
	            r = r - this.bundleOffset;
	        }
	
	
	        //从极坐标计算出直角坐标
	        resultPoint.x = r * Math.cos(angle);
	        resultPoint.y = r * Math.sin(angle);
	        return resultPoint;
	    }
	
	    /**
	     * 设置线段的模型数据  (类型 文字)
	     * @param {[type]} connector [description]
	     * @param {[type]} option    [description]
	     */
	    FlowConnectionManager.prototype.setModel = function(connector, option) {
	        var originLineType = connector.model.get("style.lineType");
	        connector.model.mergeOption(option);
	        zrUtil.merge(connector.model.get("options"), option, true);
	        if (originLineType !== option.style.lineType) {
	            this.refreshConnector(connector, true);
	        }
	    }
	
	    /**
	     * 删除指定的线
	     * @param connector 欲删除的连线
	     * @param _zr zr
	     */
	    ConnectionManager.prototype.deleteByLine = function (connector,_zr) {
	        //1.将线 所联的startNode的outgoing数据删除
	        if(connector.startNode){
	            var startNodeOutgoing = connector.startNode.model.get("outgoing");
	            index = zrUtil.indexOf(startNodeOutgoing, connector.resourceId);
	            if (index != -1) {
	                startNodeOutgoing.splice(index, 1);
	            }
	
	            if (this.connectorMap) {
	                var key = this.getTwoNodeId(connector.startNode, connector.endNode);
	                this.connectorMap.removeItem(key, connector);
	            }
	        }
	
	
	        //2.从_zr上删除
	        _zr.remove(connector);
	
	
	        //3.从线数据中删除
	        var index = zrUtil.indexOf(this.connectors, connector);
	        if (index != -1) {
	            this.connectors.splice(index, 1);
	        }
	        if (this.selConnector === connector) {
	            this.selConnector = null;
	        }
	    }
	    /**
	     * 刷新连接线
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    FlowConnectionManager.prototype.refreshLineByNode = function(node) {
	        // 判断这个节点是否有多条线段
	        var keys = this.connectorMap.keys();
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (key.indexOf(node.id) != -1) {
	                var arrCons = this.connectorMap.get(key);
	                this.countLinePos(arrCons)
	                if (arrCons.length == 1) {
	                    //两个节点只有一个连线的情况
	                    this.refreshConnector(arrCons[0], true);
	                } else if (arrCons.length > 1) {
	                    //两个节点有多个连线的情况
	                    this.refreshCons(arrCons);
	                }
	            }
	        }
	    }
	
	    /**
	     * 刷新连接线
	     * @param  {[type]} node [description]
	     * @return {[type]}      [description]
	     */
	    FlowConnectionManager.prototype.toggleLineByNode = function(node, isShow) {
	        // 判断这个节点是否有多条线段
	        var keys = this.connectorMap.keys();
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (key.indexOf(node.id) != -1) {
	                var arrCons = this.connectorMap.get(key);
	
	                zrUtil.each(arrCons, function(connection) {
	                    if(isShow) {
	                        connection.show();
	                    } else {
	                        connection.hide();
	                    }
	                })
	            }
	        }
	    }
	    /**
	     * 重新调整线的位置
	     */
	    FlowConnectionManager.prototype.countLinePos = function(arrCons) {
	        zrUtil.each(arrCons, function(connector) {
	            var options = connector.options;
	            if (options.autoChangePosition == true) {
	                var sRect = Util.getRect(connector.startNode).boundingRect;
	                var eRect = Util.getRect(connector.endNode).boundingRect;
	                var startPos = options.position.startPos;
	                var endPos = options.position.endPos;
	                var startPosNow = this.posIsChange(startPos, sRect, eRect, "startNode");
	                var endPosNow = this.posIsChange(endPos, sRect, eRect, "endNode");
	                if (startPos != startPosNow || endPos != endPosNow) {
	                    options.position.startPos = startPosNow;
	                    options.position.endPos = endPosNow;
	                }
	            }
	        },this);
	    }
	
	    FlowConnectionManager.prototype.posIsChange = function(pos, sRect, eRect, nodeType) {
	        var newPos
	        if (pos.indexOf("top") != -1 || pos.indexOf("bottom") != -1) {
	            if (sRect.y + sRect.height < eRect.y) {
	                if (nodeType == "startNode") {
	                    newPos = pos.replace(/(top|bottom)/g, "bottom");
	                } else {
	                    newPos = pos.replace(/(top|bottom)/g, "top");
	                }
	            } else if (eRect.y + eRect.height < sRect.y) {
	                if (nodeType == "endNode") {
	                    newPos = pos.replace(/(top|bottom)/g, "bottom");
	                } else {
	                    newPos = pos.replace(/(top|bottom)/g, "top");
	                }
	            } else {
	                newPos = pos;
	            }
	        } else if (pos.indexOf("left") != -1 || pos.indexOf("right") != -1) {
	            if (sRect.x + sRect.width < eRect.x) {
	                if (nodeType == "startNode") {
	                    newPos = pos.replace(/(right|left)/g, "right");
	                } else {
	                    newPos = pos.replace(/(right|left)/g, "left");
	                }
	            } else if (eRect.x + eRect.width < sRect.x) {
	                if (nodeType == "endNode") {
	                    newPos = pos.replace(/(right|left)/g, "right");
	                } else {
	                    newPos = pos.replace(/(right|left)/g, "left");
	                }
	            } else {
	                newPos = pos;
	            }
	        } else {
	            newPos = pos;
	        }
	        return newPos;
	    }
	
	
	    zrUtil.inherits(FlowConnectionManager, ConnectionManager);
	    module.exports = FlowConnectionManager;
	


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连线管理类
	 * @author wang.xiaohu
	 */
	
	    var Util = __webpack_require__(65);
	    var Point = __webpack_require__(66);
	    var Connector = __webpack_require__(82);
	    var Log = __webpack_require__(92);
	    var zrUtil = __webpack_require__(5);
	
	    function ConnectionManager() {
	        this.connectors = []; //当前画布所有的线段
	        this.selConnector = null; //当前选中的线段
	        this.tempConnector = null; //临时线段
	    }
	
	    /**
	     * 设置线的不可编辑
	     * @param  {[type]} forbidEdit [description]
	     * @return {[type]}            [description]
	     */
	    ConnectionManager.prototype.connectorForbidEdit = function (forbidEdit) {
	        for (var i = 0; i < this.connectors.length; i++) {
	            this.connectors[i].options.isEdit = !forbidEdit;
	        }
	    }
	
	
	    /**
	     * 清空连接线上的调整位置按钮
	     * @return {[type]} [description]
	     */
	    ConnectionManager.prototype.clearSelectCon = function () {
	        if (this.selConnector != null) {
	            this.refreshConnector(this.selConnector);
	        }
	    }
	    /**
	     * 删除和节点相关联的连接线
	     * @return {[type]} [description]
	     */
	    ConnectionManager.prototype.deleteSelectCon = function (node, _zr) {
	        for (var i = 0; i < this.connectors.length; i++) {
	            if (this.connectors[i].startNode == node || this.connectors[i].endNode == node) {
	                //1.将线 所联的startNode的outgoing数据删除
	                var startNodeOutgoing = this.connectors[i].startNode.model.get("outgoing");
	                var index = zrUtil.indexOf(startNodeOutgoing, this.connectors[i].resourceId);
	                if (index != -1) {
	                    startNodeOutgoing.splice(index, 1);
	                }
	                //2.从_zr上删除
	                _zr.remove(this.connectors[i]);
	                this.connectors.splice(i, 1);
	                i--;
	                this.selConnector = null;
	            }
	        }
	    }
	    /**
	     * 删除选定的线
	     * @return {[type]} [description]
	     */
	    ConnectionManager.prototype.deleteLine = function (_zr) {
	        //1.将线 所联的startNode的outgoing数据删除
	        if(this.selConnector.startNode){
	            var startNodeOutgoing = this.selConnector.startNode.model.get("outgoing");
	            index = zrUtil.indexOf(startNodeOutgoing, this.selConnector.resourceId);
	            if (index != -1) {
	                startNodeOutgoing.splice(index, 1);
	            }
	
	            if (this.connectorMap) {
	                var key = this.getTwoNodeId(this.selConnector.startNode, this.selConnector.endNode);
	                this.connectorMap.removeItem(key, this.selConnector);
	            }
	        }
	
	
	        //2.从_zr上删除
	        _zr.remove(this.selConnector);
	
	
	        //3.从线数据中删除
	        var index = zrUtil.indexOf(this.connectors, this.selConnector);
	        if (index != -1) {
	            this.connectors.splice(index, 1);
	        }
	        this.selConnector = null;
	    }
	
	    /**
	     * 重新画线
	     * @param  {[type]} connector          [description]
	     * @param  {[type]} force
	     * @return {[type]}                    [description]
	     */
	    ConnectionManager.prototype.refreshConnector = function (connector, force) {
	        // 只有需要强制刷新  或者 连线为空（<2)时 才进行重新计算重绘
	        if (force || (!connector.turningPoints) || (connector.turningPoints.length < 2)) {
	            if (connector.model && connector.model.get("style.lineType")) {
	                connector.options.style.lineType = connector.model.get("style.lineType");
	            }
	            var arrStartEndPoint = this.getStartEndPoint(connector);
	            var escapeDistance = null;
	            if (connector.options.position && connector.options.position.escapeDistance) {
	                escapeDistance = connector.options.position.escapeDistance;
	            }
	            var solutions = this.connector2Points(connector.options.style.lineType, arrStartEndPoint[0],
	                arrStartEndPoint[1],
	                arrStartEndPoint[2], arrStartEndPoint[3], escapeDistance); // TYPE_STRAIGHT TYPE_JAGGED
	
	            connector.refresh(solutions[0][2]);
	        }
	
	        connector.clearHandles(); //清空handle
	    }
	
	
	    ConnectionManager.prototype.getStartEndPoint = function (connector) {
	        var startNode = connector.startNode;
	        var endNode = connector.endNode;
	
	        var isNotInSameGroup = startNode.parent !== endNode.parent;
	
	        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode, isNotInSameGroup).boundingRect;
	        var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(
	            sRect.y) + Number(sRect.height)];
	
	        var eRect = endNode.getRect ? endNode.getRect().boundingRect : Util.getRect(endNode, isNotInSameGroup).boundingRect;
	        var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(
	            eRect.y) + Number(eRect.height)];
	
	
	        var sConnectorPoint = Util.getConnectorPoints(sRect);
	        var eConnectorPoint = Util.getConnectorPoints(eRect);
	
	        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	        var position = connector.options.position;
	        if (!position.startPos || !position.endPos) {
	            if (sRect.x < eRect.x) {
	                position.startPos = "right";
	                position.endPos = "left";
	            } else {
	                position.startPos = "left";
	                position.endPos = "right";
	            }
	        }
	        var startPoint = this.calcPointExpression(position.startPos, sConnectorPoint);
	        var endPoint = this.calcPointExpression(position.endPos, eConnectorPoint);
	        startPoint.add(new Point(position.startOffset[0], position.startOffset[1]));
	        endPoint.add(new Point(position.endOffset[0], position.endOffset[1]));
	        return [startPoint, endPoint, sBounds, eBounds];
	    }
	
	    ConnectionManager.prototype.calcPointExpression = function (pos, point) {
	        var variable = {
	            top: point.top.x,
	            left: point.left.y,
	            right: point.right.y,
	            bottom: point.bottom.x,
	            center: point.center.x
	        };
	
	        var expression = "<% print(" + pos + ") %>";
	        var val = parseInt(Util.template(expression)(variable));
	        if (pos.indexOf("top") != -1) {
	            return new Point(val, point.top.y);
	        } else if (pos.indexOf("left") != -1) {
	            return new Point(point.left.x, val);
	        } else if (pos.indexOf("right") != -1) {
	            return new Point(point.right.x, val);
	        } else if (pos.indexOf("bottom") != -1) {
	            return new Point(val, point.bottom.y);
	        } else if (pos.indexOf("center") != -1) {
	            return new Point(val, point.bottom.y);
	        } else {
	            throw new Error("pos参数错误");
	        }
	    }
	
	    /**
	     * 创建或修改临时线
	     * @param  {[type]} startNode             [description]
	     * @param  {[type]} rEndPoint             [description]
	     * @param  {[type]} lineType [description]
	     * @return {[type]}                       [description]
	     */
	    ConnectionManager.prototype.manageTempConnector = function (startNode, rEndPoint, lineType) {
	
	        var sRect = startNode.getRect ? startNode.getRect().boundingRect : Util.getRect(startNode).boundingRect;
	
	        var sBounds = [sRect.x, sRect.y, sRect.x + sRect.width, sRect.y + sRect.height];
	        var sConnectorPoint = Util.getConnectorPoints(sRect);
	
	        if (!this.tempConnector) {
	            this.tempConnector = new Connector({
	                isEdit: false,
	                style: {
	                    lineType: lineType
	                }
	            });
	        }
	
	        var connector = this.tempConnector;
	        //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right
	        var position = connector.options.position;
	        if (sRect.x < rEndPoint.x) {
	            position.startPos = "right";
	            position.endPos = "left";
	        } else {
	            position.startPos = "left";
	            position.endPos = "right";
	        }
	
	        connector.options.style.lineType = lineType;
	        var solutions = this.connector2Points(lineType, sConnectorPoint[position.startPos], rEndPoint,
	            sBounds, null); // TYPE_STRAIGHT TYPE_JAGGED
	
	        connector.refresh(solutions[0][2]);
	        return connector;
	    }
	
	    /**
	     * 删除临时线
	     * @param  {[type]} zr             [description]
	     */
	    ConnectionManager.prototype.removeTempConnector = function (zr) {
	        if (this.tempConnector) {
	            zr.remove(this.tempConnector);
	            this.tempConnector = null;
	        }
	    }
	
	
	    /**
	     * 算出 两个节点 指定两个点如何联线
	     * @param  {[type]} type       [description]
	     * @param  {[type]} startPoint [description]
	     * @param  {[type]} endPoint   [description]
	     * @param  {[type]} sBounds    [description]
	     * @param  {[type]} eBounds    [description]
	     * @return {[type]}            [description]
	     */
	    ConnectionManager.prototype.connector2Points = function (type, startPoint, endPoint, sBounds, eBounds,
	        escapeDistance) {
	        var figureEscapeDistance = [30, 30];
	        if (escapeDistance) {
	            if (!zrUtil.isArray(escapeDistance)) {
	                figureEscapeDistance = [escapeDistance, escapeDistance];
	            } else {
	                figureEscapeDistance = escapeDistance;
	            }
	        }
	
	        Log.group("connectionManager: connector2Points");
	
	
	        Log.info("ConnectionManager: connector2Points (" + type + ", " + startPoint + ", " + endPoint +
	            ", " + sBounds + ", " + eBounds + ')');
	        var solutions = [];
	
	
	
	        switch (type) {
	            case Connector.TYPE_STRAIGHT: //直线
	                var points = [startPoint.clone(), endPoint.clone()];
	                solutions.push(['straight', 'straight', points]);
	                break;
	
	            case Connector.TYPE_CURVE: //曲线
	
	            case Connector.TYPE_JAGGED: //折线
	                var startExitPoint = null;
	                var endExitPoint = null;
	
	                //find start exit point  寻找开始出口
	                if (sBounds != null) {
	                    var potentialExits = [];
	
	                    potentialExits.push(new Point(startPoint.x, sBounds[1] - figureEscapeDistance[0])); //north 北
	                    potentialExits.push(new Point(sBounds[2] + figureEscapeDistance[0], startPoint.y)); //east  东
	                    potentialExits.push(new Point(startPoint.x, sBounds[3] + figureEscapeDistance[0])); //south  南
	                    potentialExits.push(new Point(sBounds[0] - figureEscapeDistance[0], startPoint.y)); //west  西
	
	                    //pick closest exit point  寻找与 startPoint 最靠近的出口点
	                    startExitPoint = potentialExits[0];
	                    for (var i = 1; i < potentialExits.length; i++) {
	                        if (Util.distance(startPoint, potentialExits[i]) < Util.distance(startPoint,
	                                startExitPoint)) {
	                            startExitPoint = potentialExits[i];
	                        }
	                    }
	                }
	
	
	                //find end exit point  寻找结束出口
	                if (eBounds != null) {
	                    var potentialExits = [];
	
	                    potentialExits.push(new Point(endPoint.x, eBounds[1] - figureEscapeDistance[1])); //north
	                    potentialExits.push(new Point(eBounds[2] + figureEscapeDistance[1], endPoint.y)); //east
	                    potentialExits.push(new Point(endPoint.x, eBounds[3] + figureEscapeDistance[1])); //south
	                    potentialExits.push(new Point(eBounds[0] - figureEscapeDistance[1], endPoint.y)); //west
	
	                    //pick closest exit point  寻找与 endPoint 最靠近的出口点
	                    endExitPoint = potentialExits[0];
	                    for (var i = 1; i < potentialExits.length; i++) {
	                        if (Util.distance(endPoint, potentialExits[i]) < Util.distance(endPoint,
	                                endExitPoint)) {
	                            endExitPoint = potentialExits[i];
	                        }
	                    }
	                }
	
	                //Basic solution 最基本的解决方案   为其他解决方案做准备
	                var s = [startPoint];
	                var gapIndex = 0; //the index of the gap (where do we need to insert new points) DO NOT CHANGE IT
	                if (startExitPoint) {
	                    s.push(startExitPoint);
	                    gapIndex = 1;
	                }
	                if (endExitPoint) {
	                    s.push(endExitPoint);
	                }
	                s.push(endPoint);
	
	
	
	                //SO - no additional points     S0 解决方案 不添加任何点  基本不会被采用
	                var s0 = Point.cloneArray(s);
	                solutions.push(['s0', 's0', s0]);
	
	
	
	                //S1   S1 解决方案  只有一个折点
	                var s1 = Point.cloneArray(s);
	
	                //first variant   第一个变体 s1 s1_1方案  折线点在 startExitPoint的X 与 endExitPoint的 Y位置
	                var s1_1 = Point.cloneArray(s1);
	                s1_1.splice(gapIndex + 1, 0, new Point(s1_1[gapIndex].x, s1_1[gapIndex + 1].y));
	                solutions.push(['s1', 's1_1', s1_1]);
	
	                //second variant  第二变体 s1 s1-2方案  折线点在 endExitPoint的X 与  startExitPoint的Y位置
	                var s1_2 = Point.cloneArray(s1);
	                s1_2.splice(gapIndex + 1, 0, new Point(s1_2[gapIndex + 1].x, s1_2[gapIndex].y));
	                solutions.push(['s1', 's1_2', s1_2]);
	
	
	                //S2  S2 解决方案  添加两个折点
	
	                //Variant I   s2_1方案
	                var s2_1 = Point.cloneArray(s);
	                var s2_1_1 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex].y);
	                var s2_1_2 = new Point((s2_1[gapIndex].x + s2_1[gapIndex + 1].x) / 2, s2_1[gapIndex + 1].y);
	                s2_1.splice(gapIndex + 1, 0, s2_1_1, s2_1_2);
	                solutions.push(['s2', 's2_1', s2_1]);
	
	
	                //Variant II  s2_1方案  1折线点 x: startExitPoint的X 位置 y: startExitPoint的y+endExitPoint的y/2
	                //1折线点 x:endExitPoint的x  y:startExitPoint的y+endExitPoint的y/2
	                var s2_2 = Point.cloneArray(s);
	                var s2_2_1 = new Point(s2_2[gapIndex].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);
	                var s2_2_2 = new Point(s2_2[gapIndex + 1].x, (s2_2[gapIndex].y + s2_2[gapIndex + 1].y) / 2);
	                s2_2.splice(gapIndex + 1, 0, s2_2_1, s2_2_2);
	                solutions.push(['s2', 's2_2', s2_2]);
	
	
	                //Variant III
	                var s2_3 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move right so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var eastExits = [s2_3[gapIndex].x + 20, s2_3[gapIndex + 1].x + 20]; //add points X coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    eastExits.push(sBounds[2] + 20);
	                }
	
	                if (eBounds) {
	                    eastExits.push(eBounds[2] + 20);
	                }
	
	                var eastExit = Util.max(eastExits);
	                var s2_3_1 = new Point(eastExit, s2_3[gapIndex].y);
	                var s2_3_2 = new Point(eastExit, s2_3[gapIndex + 1].y);
	                s2_3.splice(gapIndex + 1, 0, s2_3_1, s2_3_2);
	                solutions.push(['s2', 's2_3', s2_3]);
	
	
	                //Variant IV  s2_4方案
	                var s2_4 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move up so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var northExits = [s2_4[gapIndex].y - 20, s2_4[gapIndex + 1].y - 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    northExits.push(sBounds[1] - 20);
	                }
	
	                if (eBounds) {
	                    northExits.push(eBounds[1] - 20);
	                }
	
	                var northExit = Util.min(northExits);
	                var s2_4_1 = new Point(s2_4[gapIndex].x, northExit);
	                var s2_4_2 = new Point(s2_4[gapIndex + 1].x, northExit);
	                s2_4.splice(gapIndex + 1, 0, s2_4_1, s2_4_2);
	                solutions.push(['s2', 's2_4', s2_4]);
	
	
	                //Variant V
	                var s2_5 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move left so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var westExits = [s2_5[gapIndex].x - 20, s2_5[gapIndex + 1].x - 20]; //add points x coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    westExits.push(sBounds[0] - 20);
	                }
	
	                if (eBounds) {
	                    westExits.push(eBounds[0] - 20);
	                }
	
	                var westExit = Util.min(westExits);
	                var s2_5_1 = new Point(westExit, s2_5[gapIndex].y);
	                var s2_5_2 = new Point(westExit, s2_5[gapIndex + 1].y);
	                s2_5.splice(gapIndex + 1, 0, s2_5_1, s2_5_2);
	                solutions.push(['s2', 's2_5', s2_5]);
	
	
	                //Variant VI
	                var s2_6 = Point.cloneArray(s);
	                //find the amount (stored in delta) of pixels we need to move down so no intersection with a figure will be present
	                //!See:  /documents/specs/connected_figures_deltas.jpg file
	
	                var southExits = [s2_6[gapIndex].y + 20, s2_6[gapIndex + 1].y + 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p
	
	                if (sBounds) {
	                    southExits.push(sBounds[3] + 20);
	                }
	
	                if (eBounds) {
	                    southExits.push(eBounds[3] + 20);
	                }
	
	                var southExit = Util.max(southExits);
	                var s2_6_1 = new Point(s2_6[gapIndex].x, southExit);
	                var s2_6_2 = new Point(s2_6[gapIndex + 1].x, southExit);
	                s2_6.splice(gapIndex + 1, 0, s2_6_1, s2_6_2);
	                solutions.push(['s2', 's2_6', s2_6]);
	
	
	
	                //FILTER solutions
	
	                /*Algorithm
	                 * 0. solutions are ordered from minimmun nr of points to maximum >:)
	                 * 1. remove all solutions that are not orthogonal (mainly s0 solution)
	                 * 2. remove all solutions that go backward (we will not need them ever)
	                 * 3. remove all solutions with intersections
	                 * 4. pick first class of solutions with same nr of points (ex: 2)
	                 * 5. pick the first solution with 90 degree angles (less turnarounds)
	                 * (not interesteted) sort by length :p
	                 */
	
	                //1. filter non ortogonal solutions 删除不是正交直线的方案
	                Log.info("Filter orthogonal solutions. Initial number of solutions = " + solutions.length);
	                var orthogonalSolution = [];
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    if (Util.orthogonalPath(solution)) {
	                        orthogonalSolution.push(solutions[l]);
	                    }
	                }
	                solutions = orthogonalSolution;
	                Log.info("\n\tOrthogonalSolutions = " + solutions.length);
	
	                //2. filter backward solutions  过滤 倒退的方案
	                //do not allow start and end points to coincide - ignore them
	                if (startPoint.equals(endPoint)) {
	                    Log.info(
	                        "Start and end point coincide...skip backward solution. I think we will just fall on s0 :)"
	                    );
	                } else {
	                    Log.info("Filter backward solutions. Initial number of solutions = " + solutions.length);
	                    var forwardSolutions = [];
	                    var temp = '';
	                    for (var l = 0; l < solutions.length; l++) {
	                        var solution = solutions[l][2];
	                        if (Util.forwardPath(solution)) {
	                            forwardSolutions.push(solutions[l]);
	                        } else {
	                            temp = temp + "\n\t" + solution;
	                        }
	                    }
	                    solutions = forwardSolutions;
	                    Log.info("\n\t ForwardSolutions = " + solutions.length);
	                    if (solutions.length == 0) {
	                        Log.info("Discarded solutions: " + temp);
	                    }
	                }
	
	
	                //3. Filter non intersecting solutions  去除没有交集()的方案
	                Log.info("Filter non intersecting solutions. Initial number of solutions = " + solutions.length);
	                var nonIntersectionSolutions = []
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    //Log.info("Solution id= " + solutions[l][1] + ' nr points = ' + solution.length + ", points = " + solution);
	                    var intersect = false;
	
	                    var innerLines = solution.slice(); //just a shallow copy
	
	                    /*If any bounds just trim the solution. So we avoid the strange case when a connection
	                     *startes from a point on a figure and ends inside of the same figure, but not on a connection point*/
	                    if (eBounds || sBounds) {
	                        //i0nnerLines = innerLines.slice(0, innerLines.length - 1);
	                        innerLines = innerLines.slice(1, innerLines.length - 1);
	                        //Log.info("\t eBounds present,innerLines nr. points = " + innerLines.length + ", points = " + innerLines);
	                    }
	
	
	
	                    //now test for intersection
	                    if (sBounds) {
	                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, sBounds);
	                    }
	                    if (eBounds) {
	                        intersect = intersect || Util.polylineIntersectsRectangle(innerLines, eBounds);
	                    }
	
	                    if (!intersect) {
	                        nonIntersectionSolutions.push(solutions[l]);
	                    }
	                }
	
	                //If all solutions intersect than this is destiny  :) and just ignore the intersection filter
	                if (nonIntersectionSolutions.length != 0) {
	                    //reasign to solutions
	                    solutions = nonIntersectionSolutions;
	                }
	
	                Log.info("\n\t nonIntersectionSolutions = " + solutions.length);
	
	
	                //4. get first class of solutions with same nr of points 选择与第一个方案点数一样多的方案（因为第一个方案点数最少）
	                Log.info("Get first class of solutions with same nr of points");
	                if (solutions.length == 0) {
	                    Log.info("This is not possible");
	                }
	
	                var firstSolution = solutions[0][2]; //pick first solution
	                var nrOfPoints = firstSolution.length;
	                var sameNrPointsSolution = [];
	
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    if (solution.length == nrOfPoints) {
	                        sameNrPointsSolution.push(solutions[l]);
	                    }
	                }
	
	                solutions = sameNrPointsSolution;
	
	
	
	
	                /*5.  计算路径分数 ，取最分数高的
	                 Pick the first solution with 90 degree angles (less turnarounds)
	                 *in case we have more than one solution in our class
	                 */
	                Log.info("pick the first solution with 90 degree angles (less turnarounds)");
	                var solIndex = 0;
	                for (var l = 0; l < solutions.length; l++) {
	                    var solution = solutions[l][2];
	                    if (Util.scorePath(solutions[solIndex][2]) < Util.scorePath(solutions[l][2])) {
	                        solIndex = l;
	                    }
	                }
	                solutions = [solutions[solIndex]];
	
	
	                break;
	        }
	
	        //SMOOTHING curve
	        if (type === Connector.TYPE_CURVE) {
	            this.smoothCurve(solutions);
	        }
	        //END SMOOTHING curve
	
	        Log.groupEnd();
	
	        return solutions;
	    }
	
	    ConnectionManager.prototype.smoothCurve = function (solutions) {
	        var option = 3;
	
	        switch (option) {
	            case 0:
	                //do nothing
	                break;
	
	            case 1: //add intermediate points
	                //Add the middle point for start and end segment so that we "force" the
	                //curve to both come "perpendicular" on bounds and also make the curve
	                //"flee" more from bounds (on exit)
	                for (var s = 0; s < solutions.length; s++) {
	                    var solTurningPoints = solutions[s][2];
	
	                    //first segment
	                    var a1 = solTurningPoints[0];
	                    var a2 = solTurningPoints[1];
	                    var startMiddlePoint = Util.getMiddle(a1, a2);
	                    solTurningPoints.splice(1, 0, startMiddlePoint);
	
	                    //last segment
	                    var a3 = solTurningPoints[solTurningPoints.length - 2];
	                    var a4 = solTurningPoints[solTurningPoints.length - 1];
	                    var endMiddlePoint = Util.getMiddle(a3, a4);
	                    solTurningPoints.splice(solTurningPoints.length - 1, 0, endMiddlePoint);
	                }
	                break;
	
	            case 2: //remove points
	
	                zrUtil.each(solutions, function(solution) {
	                    var solType = solution[0];
	                    if (solType == 's1' || solType == 's2') {
	                        var solTurningPoints = solution[2];
	                        solTurningPoints.splice(1, 1);
	                        solTurningPoints.splice(solTurningPoints.length - 2, 1);
	                    }
	                });
	                break;
	
	            case 3:
	                /*remove colinear point for s1 as it seems that more colinear points do not look good
	                 * on organic solutions >:D*/
	                zrUtil.each(solutions, function(solution) {
	                    var solType = solution[0];
	                    if (solType == 's1') {
	                        var solTurningPoints = solution[2];
	                        var reducedSolution = Util.collinearReduction(solTurningPoints);
	                        solution[2] = reducedSolution;
	                    }
	                });
	                break;
	        } //end switch
	
	    }
	
	    module.exports = ConnectionManager;


/***/ }),
/* 92 */
/***/ (function(module, exports) {

	/**
	 * 日志类
	 * @author wang.xiaohu
	 */
	
	
	    var Log  = {
	        LOG_LEVEL_NONE  : 0,
	
	        LOG_LEVEL_DEBUG : 1,
	
	        LOG_LEVEL_INFO : 2,
	
	        LOG_LEVEL_ERROR : 3,
	
	        level : this.LOG_LEVEL_ERROR,
	        
	        /**
	        * The less important of all messages
	        * @param {String} message - the message to be logged
	        **/
	        debug: function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_DEBUG){
	                    
	                    //in FF is debug
	                    if(typeof console.debug == 'function'){
	                        console.debug(message);
	                    }
	                    else{//TODO: in IE is log
	    //                    console.info(message);
	                    }
	                }
	            }
	        },
	
	
	        /**
	        * The commonly used log message
	        * @param {String} message - the message to be logged
	        **/
	        info : function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_INFO){
	                    console.info(message);
	                }
	            }
	        },
	
	        /**
	        * The worse kind of message. Usually a crash
	        * @param {String} message - the message to be logged
	        **/
	        error : function (message){
	            if(typeof console !== 'undefined'){
	                if(this.level <= this.LOG_LEVEL_ERROR){
	                    console.error(message);
	                }
	            }
	        },
	
	        /**
	         *Start grouping the log messages
	         *@param {String} title - the title of the group
	         *@see <a href="http://getfirebug.com/logging">http://getfirebug.com/logging</a>
	         **/
	        group : function(title){
	            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info
	                if(typeof console !== 'undefined'){           
	                    /**If we do not test for group() function you will get an error in Opera
	                     *as Opera has it's own console...which does not have a group() function*/
	                    if(typeof console.group === 'function'){
	                        console.group(title);
	                    }
	                }
	            }
	        },
	
	        /**Ends current message grouping*/
	        groupEnd : function(){
	            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info
	                if(typeof console !== 'undefined'){
	                    /**If we do not test for groupEnd() function you will get an error in Opera
	                     *as Opera has it's own console...which does not have a group() function*/
	                    if(typeof console.groupEnd === 'function'){
	                        console.groupEnd();
	                    }
	                }
	            }
	        }
	
	    };
	
	    //Log.level = Log.LOG_LEVEL_DEBUG; 
	    Log.level = Log.LOG_LEVEL_ERROR; 
	    //Log.level = Log.LOG_LEVEL_ERROR;
	    //Log.level = Log.LOG_LEVEL_NONE;
	    module.exports = Log;
	    


/***/ }),
/* 93 */
/***/ (function(module, exports) {

	/**
	 * 常量定义
	 */
	
		module.exports = 	{
			ELEMENT_TYPE: "elementType",
			MODE: "mode",
			BACKGROUND: "backgroud",
			OPTIONS: "options",
			USERDATA: "userData",
			ID: "id",
			START_ID: "startNodeId",
			END_ID: "endNodeId",
			ALARM: "Alarm",
			RELATIONID:"relationId",
			RELATION_IMAGE:"relationImage",
			GROUP: "Group",
			CONNECTION: "connection",
			CHILDS: "childs",
			TREE_ROOT: "treeRoot",
			DOCKERS:"options.dockers",
			STYLE_LINETYPE:"style.lineType",
			LINEOPERATIONICON:"LineOperationIcon",
			DEL:"DEL",
			LINK:"straight",
			FOLD:"jagged",
			CURVE:"curve"
		};
	


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Flow工具类
	 * @author wang.xiaohu9
	 */
	
	    var Constants = __webpack_require__(93);
	    var zrUtil = __webpack_require__(5);
	    var GroupNode = __webpack_require__(95);
	    var Rect = __webpack_require__(97);
	    var Circle = __webpack_require__(98);
	    var Image = __webpack_require__(99);
	    var Text = __webpack_require__(100);
	    var Sector = __webpack_require__(101);
	    var Ring = __webpack_require__(102);
	    var Ellipse = __webpack_require__(103);
	    var Heart = __webpack_require__(104);
	    var Droplet = __webpack_require__(105);
	    var Rose = __webpack_require__(106);
	    var Isogon = __webpack_require__(107);
	    var Polygon = __webpack_require__(108);
	    var Line = __webpack_require__(109);
	    var Polyline = __webpack_require__(110);
	    var BezierCurve = __webpack_require__(111);
	    var Arc = __webpack_require__(112);
	    var Star = __webpack_require__(113);
	    var Trochoid = __webpack_require__(114);
	    var Path = __webpack_require__(115);
	    var IconButton = __webpack_require__(116);
	    var Connector = __webpack_require__(82);
	    var flowLink = __webpack_require__(117);
	    /**
	     * 根据结点数组 导出JSON格式的数据
	     *
	     * @param {Array} model 总的模型
	     * @return {JSON} JSON格式的数据
	     */
	    function toJson(model, group) {
	        var jsonArr = [];
	        group.eachChild(function (node) {
	            if (node.model) {
	                //如果是组的话
	                if (node instanceof GroupNode) {
	                    var childArr = [];
	                    node.eachChild(function (childNode) {
	                        if (childNode.model) {
	                            childArr.push(childNode.model.option);
	                        }
	                    });
	                    node.model.set(Constants.CHILDS, childArr);
	                }
	                if (node instanceof Connector) {
	                    node.refreshModel();
	                }
	                jsonArr.push(node.model.option);
	
	            }
	
	
	        })
	        model.set(Constants.CHILDS, jsonArr);
	        return model.option;
	    }
	
	    /**
	     * 根据 JSON 生成节点
	     * @param  {[type]} fishTopoflow [description]
	     * @param  {[type]} json         [description]
	     * @return {[type]}              [description]
	     */
	    function fromJson(fishTopoflow, group, childShapes, isChild, layoutRootNode) {
	        var connectors = [];
	        // 1.先创建节点  遍历形状 获取模型
	        for (var i = 0; i < childShapes.length; i++) {
	            var shape = childShapes[i];
	            if (shape.elementType === Constants.CONNECTION) {
	                connectors.push(shape);
	            } else if (shape.elementType === Constants.ALARM) {
	                var relationNode = findNodeById(fishTopoflow.group, shape.relationId);
	                fishTopoflow.createAlarm(relationNode, shape.options);
	            } else if (shape.elementType === Constants.GROUP) {
	                shape.options.id = shape.id;
	                var createdGroup = fishTopoflow.createNode(shape.elementType, shape.options, shape.userData);
	                fromJson(fishTopoflow, createdGroup, shape.childs, true, layoutRootNode);
	
	                fishTopoflow.addNode(createdGroup);
	
	
	            } else {
	                // 根据options创建节点
	                var node = fishTopoflow.createNode(shape.elementType, shape.options, shape.userData);
	                if (isChild) {
	                    group.add(node);
	                } else {
	                    fishTopoflow.addNode(node);
	                }
	
	                if (shape.options.layout) {
	                    if (shape.options.layout.layout === Constants.TREE_ROOT) {
	                        var nodeForLayout = findNodeById(group, shape.id)
	                        layoutRootNode.push(nodeForLayout);
	                        //  fishTopo.layoutNode("tree",{"node":node});
	                    }
	                }
	
	            }
	        }
	
	        // 2. 再创建线
	        zrUtil.each(connectors, function (line) {
	            var startNode = findNodeById(group, line.startNodeId);
	            var endNode = findNodeById(group, line.endNodeId);
	            if (startNode && endNode) {
	                var link = fishTopoflow.createLink(startNode, endNode, line.options, line.userData);
	                if (isChild) {
	                    group.add(link);
	                } else {
	                    fishTopoflow.addNode(link);
	                }
	            }else{
	                var thisLink = flowLink.Link.createByPoint(line.options,line.userData);
	                if (isChild) {
	                    group.add(thisLink);
	                } else {
	                    fishTopoflow.addNode(thisLink);
	                }
	            }
	        })
	    }
	
	    /**
	     * 根据id在group中查找
	     * @param  {[type]} group  [description]
	     * @param  {[type]} nodeId [description]
	     * @return {[type]}        [description]
	     */
	    function findNodeById(group, nodeId) {
	        var retNode = null;
	        group.eachChild(function (node) {
	            if (node.id === nodeId) {
	                retNode = node;
	            }
	        })
	        return retNode;
	    }
	
	
	    /**
	     * Get canvas which has all thing rendered
	     * @param {Object} opts
	     * @param {string} [opts.backgroundColor]
	     */
	    function getRenderedCanvas(zr, opts) {
	        opts = opts || {};
	        opts.pixelRatio = opts.pixelRatio || 1;
	        opts.backgroundColor = opts.backgroundColor ||
	            "#FFFFFF";
	        var list = zr.storage.getDisplayList();
	        // Stop animations
	        zrUtil.each(list, function (el) {
	            el.stopAnimation(true);
	        });
	        return zr.painter.getRenderedCanvas(opts);
	    }
	
	    function toDataURL(zr, opts) {
	        opts = opts || {};
	        var url = getRenderedCanvas(zr, opts).toDataURL(
	            'image/' + (opts && opts.type || 'png')
	        );
	        return url;
	    }
	
	    function truncPosition(position) {
	        var x = parseInt(position[0], 10);
	        var y = parseInt(position[1], 10);
	        if (x < 0) {
	            x = 0
	        }
	        if (y < 0) {
	            y = 0
	        }
	        return [x, y];
	    }
	
	    function registerFlowNode(flowNode) {
	        var nodeCtors = {
	            Rect: Rect,
	            Circle: Circle,
	            Image: Image,
	            Text: Text,
	            Sector: Sector,
	            Ring: Ring,
	            Ellipse: Ellipse,
	            Heart: Heart,
	            Droplet: Droplet,
	            Rose: Rose,
	            Isogon: Isogon,
	            Polygon: Polygon,
	            Line: Line,
	            Polyline: Polyline,
	            BezierCurve: BezierCurve,
	            Arc: Arc,
	            Star: Star,
	            Trochoid: Trochoid,
	            Path: Path,
	            Group: GroupNode,
	            IconButton: IconButton
	        }
	        for (var name in nodeCtors) {
	            flowNode[name] = nodeCtors[name]
	        }
	        return flowNode;
	    }
	
	    /**
	     * Normalize css liked array configuration
	     * e.g.
	     *  3 => [3, 3, 3, 3]
	     *  [4, 2] => [4, 2, 4, 2]
	     *  [4, 3, 2] => [4, 3, 2, 3]
	     * @param {number|Array.<number>} val
	     */
	    function normalizeCssArray(val) {
	        var len = val.length;
	        if (typeof (val) === 'number') {
	            return [val, val, val, val];
	        } else if (len === 2) {
	            // vertical | horizontal
	            return [val[0], val[1], val[0], val[1]];
	        } else if (len === 3) {
	            // top | horizontal | bottom
	            return [val[0], val[1], val[2], val[1]];
	        }
	        return val;
	    }
	
	    function _trim(str) {
	        return str.replace(/^\s+/, '').replace(/\s+$/, '');
	    }
	
	    function parsePercent(percent, all) {
	        switch (percent) {
	            case 'center':
	            case 'middle':
	                percent = '50%';
	                break;
	            case 'left':
	            case 'top':
	                percent = '0%';
	                break;
	            case 'right':
	            case 'bottom':
	                percent = '100%';
	                break;
	        }
	        if (typeof percent === 'string') {
	            if (_trim(percent).match(/%$/)) {
	                return parseFloat(percent) / 100 * all;
	            }
	
	            return parseFloat(percent);
	        }
	
	        return percent == null ? NaN : +percent;
	    }
	
	
	
	    /**
	     * @param {string} str
	     * @param {boolean} [upperCaseFirst=false]
	     * @return {string} str
	     */
	    function toCamelCase(str, upperCaseFirst) {
	        str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {
	            return group1.toUpperCase();
	        });
	
	        if (upperCaseFirst && str) {
	            str = str.charAt(0).toUpperCase() + str.slice(1);
	        }
	
	        return str;
	    }
	    /**
	     * Enable property storage to any host object.
	     * Notice: Serialization is not supported.
	     *
	     * For example:
	     * var get = modelUitl.makeGetter();
	     *
	     * function some(hostObj) {
	     *      get(hostObj)._someProperty = 1212;
	     *      ...
	     * }
	     *
	     * @return {Function}
	     */
	    var makeGetter = (function () {
	        var index = 0;
	        return function () {
	            var key = '\0__topo_prop_getter_' + index++;
	            return function (hostObj) {
	                return hostObj[key] || (hostObj[key] = {});
	            };
	        };
	    })();
	    var encodeHTML = function (source) {
	        return String(source)
	            .replace(/&/g, '&amp;')
	            .replace(/</g, '&lt;')
	            .replace(/>/g, '&gt;')
	            .replace(/"/g, '&quot;')
	            .replace(/'/g, '&#39;');
	    };
	
	    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
	
	    var wrapVar = function (varName, seriesIdx) {
	        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';
	    };
	    /**
	     * Template formatter
	     * @param {string} tpl
	     * @param {Array.<Object>|Object} paramsList
	     * @param {boolean} [encode=false]
	     * @return {string}
	     */
	    function formatTpl(tpl, paramsList, encode) {
	        if (!zrUtil.isArray(paramsList)) {
	            paramsList = [paramsList];
	        }
	        var seriesLen = paramsList.length;
	        if (!seriesLen) {
	            return '';
	        }
	
	        var $vars = paramsList[0].$vars || [];
	        for (var i = 0; i < $vars.length; i++) {
	            var alias = TPL_VAR_ALIAS[i];
	            var val = wrapVar(alias, 0);
	            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);
	        }
	        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
	            for (var k = 0; k < $vars.length; k++) {
	                var ret = paramsList[seriesIdx][$vars[k]];
	                tpl = tpl.replace(
	                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),
	                    encode ? encodeHTML(ret) : ret
	                );
	            }
	        }
	
	        return tpl;
	    }
	
	
	    module.exports = {
	        toJson: toJson,
	        fromJson: fromJson,
	        toDataURL: toDataURL,
	        truncPosition: truncPosition,
	        registerFlowNode: registerFlowNode,
	        normalizeCssArray: normalizeCssArray,
	        parsePercent: parsePercent,
	        toCamelCase: toCamelCase,
	        makeGetter: makeGetter,
	        formatTpl: formatTpl,
	        findNodeById: findNodeById
	    };


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 组， 组中元素的坐标都是相对于这个组的<br>
	 * @class fishTopoFlow.node.GroupNode
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var group1 = new node.Group({
	 *           position:[60,50]
	 *       });
	 *
	 *       var rect1 = new node.Rect({
	 *           shape:{width:120,height:30},
	 *           style:{text:"标题", fill:"#FFB90F",stroke:"#bbbbbb"},
	 *           position:[0,0],
	 *           selectable:false
	 *       });
	 *
	 *       var rect2 = new node.Rect({
	 *           shape:{width:120,height:60},
	 *           style:{text:"内容", fill:"#FFFFFF",stroke:"#bbbbbb"},
	 *           position:[0,30],
	 *           selectable:false
	 *       });
	 *
	 *       group1.add(rect1);
	 *       group1.add(rect2);
	 *       fishTopo.add(group1);
	 */
	
	
	
	    var zrUtil = __webpack_require__(5);
	    var BoundingRect = __webpack_require__(27);
	    var graphic = __webpack_require__(4);
	    var util = __webpack_require__(65);
	    var Connector = __webpack_require__(82);
	    var flowNode =__webpack_require__(96);
	
	    function GroupNode(opts) {
	        this.model = flowNode.genModel("GroupNode", opts);
	        graphic.Group.call(this, opts);
	
	        var defaultOptions = {
	            shape: {
	                width: 5,
	                height: 5,
	                r: 5
	            },
	            style: {
	                fill: 'rgba(0,0,0,0)',//'#f9f9f9',
	                stroke: 'rgba(0,0,0,0)'//'#bbbbbb'
	            },
	            position: [0, 0]
	        };
	        this.options = zrUtil.merge(defaultOptions, opts, true);
	        //函数无法clone 原型clone不上
	        this.options.layout = opts.layout;
	        this.max = [1024, 960];
	        this.render(this.options);
	    }
	    GroupNode.RECT_NAME = "GROUP_RECT_NAME";
	    GroupNode.prototype = {
	        constructor: GroupNode,
	        type: "GroupNode",
	        render: function (model) {
	            var rect = new graphic.Rect({
	                shape: model.shape,
	                style: model.style,
	                //silent:true, //加上后 拖动 组中没有子元素的地方 无法手动了
	                z2:-1
	            });
	            rect.name = GroupNode.RECT_NAME;
	            this.add(rect);
	            this.position = model.position;
	            this.mergedImage = model.mergedImage;
	        },
	        rectContain: function (x, y) {
	            var rect = util.getRect(this);
	            return rect.boundingRect.contain(x, y);
	        },
	
	        /**
	         * 遍历组中每一个子节点
	         * @param  {Function} cb 回调函数cb
	         * @param  {Object} context   上下文context
	         */
	        each: function (cb, context) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                if (child.name != GroupNode.RECT_NAME) {
	                    cb.call(context, child, i);
	                }
	            }
	            return this;
	        },
	        // 设置 group中框形大小为 group的包围和
	        willRender:function () {
	            if (this.options.layout) {
	                this.setLayout(this.options.layout);
	            }
	            this.setProperties({
	                shape: {
	                    width: this.getBoundingRect().width,
	                    height: this.getBoundingRect().height
	                }
	            });
	        },
	
	        setLayout: function(Layout) {
	            Layout.run(this);
	        },
	
	        getRect: function () {
	            var boundingRect = this.getBoundingRect();
	            //创建最小包围盒虚线
	            var points = [];
	            points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];
	            points[1] = [boundingRect.width / 2, -boundingRect.height / 2];
	            points[2] = [boundingRect.width / 2, boundingRect.height / 2];
	            points[3] = [-boundingRect.width / 2, boundingRect.height / 2];
	            points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];
	
	            var boundRect = new BoundingRect(this.position[0],
	                this.position[1],
	                boundingRect.width, boundingRect.height);
	            return {
	                x: this.position[0] + boundingRect.width / 2,
	                y: this.position[1] + boundingRect.height / 2,
	                width: boundingRect.width,
	                height: boundingRect.height,
	                points: points,
	                boundingRect: boundRect
	            };
	        },
	        /**
	         * 拖拽组内节点的时候，动态更改背景rect的大小
	         * @param nodeMessage 拖拽的组内节点的信息
	         */
	        modifyGroupRect: function (nodeMessage) {
	            //1.重置背景rect 的长宽
	            var minLength = this.options.shape.r;
	            this.setProperties({
	                shape: {
	                    width: minLength,
	                    height: minLength,
	                    r: minLength
	                }
	            });
	
	            var rect = this.childOfName(GroupNode.RECT_NAME);
	            var boundingRect = this.getBoundingRect();
	            var width = boundingRect.width;
	            var height = boundingRect.height;
	            var rx = rect.position[0],//rect.shape.x,
	                ry = rect.position[1];//rect.shape.y;
	            //2.取group中所有节点最靠上边和最高左边的值，不包括背景rect的值
	            var minX = this._children[1].position[0],
	                minY = this._children[1].position[1];
	            var maxX = this._children[1].position[0],
	                maxY = this._children[1].position[1];
	            var nowNodePosition = zrUtil.clone(nodeMessage.position);
	            for (var i = 1; i < this._children.length; i++) {
	                if (this._children[i] instanceof Connector || this._children[i].isIcon == true) {
	                    continue;
	                } else {
	                    if (minX > this._children[i].position[0]) {
	                        minX = this._children[i].position[0];
	                    }
	                    if (maxX < this._children[i].position[0]) {
	                        maxX = this._children[i].position[0];
	                    }
	                    if (minY > this._children[i].position[1]) {
	                        minY = this._children[i].position[1];
	                    }
	                    if (maxY < this._children[i].position[1]) {
	                        maxY = this._children[i].position[1];
	                    }
	                }
	            }
	
	            // 3. 宽度大于最大宽度
	            if (width > this.max[0]) {
	                width = this.max[0] - 2;
	                if (nodeMessage.position[0] > minX) {
	                    nowNodePosition[0] = minX + this.max[0] - nodeMessage.width;
	                } else {
	                    nowNodePosition[0] = maxX - this.max[0] + nodeMessage.width;
	                }
	            } else {
	                //移动节点改变group中背景rect的x位置，不超过最小的值
	                rx = rect.position[0] + nodeMessage.position[0];
	                if (rx > minX) {
	                    rx = minX;
	                }
	                nowNodePosition[0] = nodeMessage.movePosition[0] + nodeMessage.moveX;
	                if (nodeMessage.position[0] > minX) {
	                    if (nowNodePosition[0] > minX + this.max[0] - nodeMessage.width) {
	                        nowNodePosition[0] = minX + this.max[0] - nodeMessage.width;
	                    }
	                } else {
	                    if (nowNodePosition[0] < maxX - this.max[0] + nodeMessage.width) {
	                        nowNodePosition[0] = maxX - this.max[0] + nodeMessage.width
	                    }
	                }
	            }
	            if (height > this.max[1]) {
	                height = this.max[1] - 2;
	                if (nodeMessage.position[1] > minY) {
	                    nowNodePosition[1] = minY + this.max[1] - nodeMessage.height;
	                } else {
	                    nowNodePosition[1] = maxY - this.max[1] + nodeMessage.height;
	                }
	            } else {
	                //移动节点改变group中背景rect的y位置，不超过最小的值
	                ry = rect.position[1] + (nodeMessage.position[1]);
	                if (ry > minY) {
	                    ry = minY;
	                }
	                nowNodePosition[1] = nodeMessage.movePosition[1] + nodeMessage.moveY;
	                if (nodeMessage.position[1] > minY) {
	                    if (nowNodePosition[1] > minY + this.max[1] - nodeMessage.height) {
	                        nowNodePosition[1] = minY + this.max[1] - nodeMessage.height;
	                    }
	                } else {
	                    if (nowNodePosition[1] < maxY - this.max[1] + nodeMessage.height) {
	                        nowNodePosition[1] = maxY - this.max[1] + nodeMessage.height
	                    }
	                }
	            }
	            if (nodeMessage.node.alarm) {
	                var newAlarmPosition = [nowNodePosition[0] + nodeMessage.node.getBoundingRect().width - (nodeMessage.node.alarm
	                        .getBoundingRect().width - 6), nowNodePosition[1] - nodeMessage.node.alarm.getBoundingRect()
	                    .height - 3
	                ];
	                nodeMessage.node.alarm.attr("position", newAlarmPosition);
	            }
	            //改变背景rect的长宽和位置
	            this.setProperties({
	                shape: {
	                    width: width,
	                    height: height,
	                    x: rx,
	                    y: ry
	                }
	            });
	
	        },
	
	        setProperties: function (opt) {
	            var rect = this.childOfName(GroupNode.RECT_NAME);
	            rect.setShape(opt.shape);
	           // rect.attr("style", opt.style);
	            rect.attr('position', opt.position);
	           // this.attr("shape", opt.shape);
	        },
	
	        merged: function () {
	            var that = this;
	            //保留group的初始位置
	            var groupPosition = zrUtil.clone(this.position);
	            //给小图片设置属性，隐藏group
	            var width = this._relationImage.getBoundingRect().width;
	            var height = this._relationImage.getBoundingRect().height;
	            //计算合并后的小图片的position
	            var relationImagePosition = [this.position[0] + this.childOfName(GroupNode.RECT_NAME).shape.x + (this.getBoundingRect()
	                    .width / 2 - width / 2), this.position[1] + this.childOfName(GroupNode.RECT_NAME).shape.y +
	                (this.getBoundingRect().height / 2 - height / 2)
	            ];
	            //将小图片的位置保留下来
	            var cloneImagePosition = zrUtil.clone(relationImagePosition);
	            this._relationImage.attr("style", {
	                image: this.mergedImage,
	                width: width,
	                height: height
	            });
	            this._relationImage.attr("position", relationImagePosition);
	            if (width > 0 && height > 0) {
	                this.hide();
	                this._relationImage.show();
	            }
	
	            //双击图片放出组
	            this._relationImage.on("dblclick", function () {
	                //设置组的位置根据小图片的偏移量来计算
	                that.attr('position',[groupPosition[0] + (this.position[0] -cloneImagePosition[0]),
	                    groupPosition[1] + (this.position[1] - cloneImagePosition[1])]);
	                this.hide();
	                that.show();
	            });
	            return this._relationImage;
	        }
	    }
	
	    zrUtil.inherits(GroupNode, graphic.Group);
	    module.exports = GroupNode;
	
	/**
	 * @method add
	 * 将节点加入到这个组中最后
	 * @param {Object} node 欲添加到组的节点
	 */
	/**
	 * @method removeAll
	 * 移除所有子节点
	 */
	
	/**
	 * @method remove
	 * 移除所有子节点
	 * @param {Object} child 子节点
	 */
	/**
	 * @method childOfName
	 * 获取指定名字的儿子节点
	 * @param {String} name
	 * @return {Object} 节点
	 */
	/**
	 * @method traverse
	 * 深度优先遍历所有子孙节点（each只遍历子节点）
	 * @param {String} name
	 * @return {Object} 节点
	 */
	
	/**
	 * @cfg {String} mergedImage=''  控制当双击时 组可以缩小为指定的图形。
	 */
	
	/**
	 * @cfg {Boolean} childDraggable=false  控制组内成员是否可以拖动
	 */
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * fishTopoFlow的node对象，框架提供的节点都放在这个对象下。通过extend方法创建自定义节点<br>
	 * @class fishTopoFlow.node
	 * @abstract
	 *
	    * **使用范例**：
	    *
	    *      @example
	    *       var node = fishTopoFlow.node;
	    *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	    *      var Diamond = node.extend({
	    *          type: 'Diamond',
	    *          shape: {
	    *              width: 0,
	    *              height: 0
	    *          },
	    *          buildPath: function (path, shape) {
	    *              var cx = 0;
	    *              var cy = 0;
	    *              var width = shape.width / 2;
	    *              var height = shape.height / 2;
	    *              path.moveTo(cx, cy - height);
	    *              path.lineTo(cx + width, cy);
	    *              path.lineTo(cx, cy + height);
	    *              path.lineTo(cx - width, cy);
	    *              path.closePath();
	    *          }
	    *      });
	    *        var diamod = new Diamond({
	    *            shape: {
	    *                width:50,
	    *                height:50
	    *            },
	    *            position:[60,60]
	    *        })
	    *        fishTopo.add(diamod);
	 */
	
	    var Path = __webpack_require__(7);
	    var Constants = __webpack_require__(93);
	    var zrUtil = __webpack_require__(5);
	    var util = __webpack_require__(65);
	    var Model = __webpack_require__(87);
	    var flowNode = {};
	    /**
	     * 构造模型
	     * @private
	     */
	    flowNode.genModel = function (type, opts) {
	        var model = new Model({});
	        // 没有id的时候，缺少给一个UUID。创建节点或者反序列化的时候 节点的ID取的是opts.id
			if (!opts.id) {
				opts.id = util.getUUID();
			}
	        model.set(Constants.ELEMENT_TYPE, type);
	        // 防止 new el.constructor({ style: el.style,shape: el.shape }); zrUtil.clone报错
	        if (opts.style && opts.style.host) {
	            delete opts.style.host;
	        }
	        model.set(Constants.OPTIONS, zrUtil.clone(opts));
	        if ("draggable" in opts) {
	            opts.isdraggable = opts.draggable;
	            delete opts.draggable;
	        }
	        if (!opts.z) {
	            opts.z = 1; //节点默认为1，线段0;
	        }
	
	        if (util.isUndefined(opts.hoverAnimation)) {
	            opts.hoverAnimation = false;
	        }
	
	        if (util.isUndefined(opts.selectable)) {
	            opts.selectable = true;  //默认可以选中
	        }
	        return model;
	    }
	
	    flowNode.addHoverAnimation = function(node) {
	        var scale = zrUtil.clone(node.scale) || [1,1];
	        var onEmphasis = function() {
	            this.animateTo({
	                scale: [scale[0] * 1.1, scale[1] * 1.1]
	            }, 400, 'elasticOut');
	        };
	        var onNormal = function() {
	            this.animateTo({
	                scale: scale
	            }, 400, 'elasticOut');
	        };
	        node.on('mouseover', onEmphasis)
	            .on('mouseout', onNormal)
	            .on('emphasis', onEmphasis)
	            .on('normal', onNormal);
	    }
	    /**
	     * @method extend
	     * 扩展一个 自定义节点, 比如钻石形等。
	     * @param {Object} props
	     * @param {string} props.type 自定义结节的名称 Path type
	     * @param {Function} [props.init] 初始化 Initialize
	     * @param {Function} props.buildPath 进行构建节点 Overwrite buildPath method
	     * @param {Object} [props.style] 缺省样式 Extended default style config
	     * @param {Object} [props.shape] 缺省节点参数 Extended default shape config
	     *
	     */
	    flowNode.extend = function (defaults) {
	        var Sub = function (opts) {
	            this.model = flowNode.genModel(defaults.type, opts);
	            Path.call(this, opts);
	
	            if (defaults.style) {
	                // Extend default style
	                this.style.extendFrom(defaults.style, false);
	            }
	
	            // Extend default shape
	            var defaultShape = defaults.shape;
	            if (defaultShape) {
	                this.shape = this.shape || {};
	                var thisShape = this.shape;
	                for (var name in defaultShape) {
	                    if (
	                        !thisShape.hasOwnProperty(name)
	                        && defaultShape.hasOwnProperty(name)
	                    ) {
	                        thisShape[name] = defaultShape[name];
	                    }
	                }
	            }
	
	            defaults.init && defaults.init.call(this, opts);
	
	        };
	
	        zrUtil.inherits(Sub, Path);
	
	        // FIXME 不能 extend position, rotation 等引用对象
	        for (var name in defaults) {
	            // Extending prototype values and methods
	            if (name !== 'style' && name !== 'shape') {
	                Sub.prototype[name] = defaults[name];
	            }
	        }
	
	        return Sub;
	    };
	
	    module.exports = flowNode;
	
	
	/**
	 * @cfg {Array} position 节点的位置,统一使用position进行定位[x,y] eg. [100,100]
	 */
	
	/**
	 * @cfg {Object} style 样式参数
	 * @cfg {string} style.fill=#000 填充色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red | gradient
	 * @cfg {string} style.stroke=null 笔画颜色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red | gradient
	 * @cfg {number} style.lineWidth=1 笔画宽度
	 * @cfg {Array} style.lineDash=null 笔画的虚线间隔，参数为交替绘制线段和间距长度的数字 参见[lineDashOffset](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/setLineDash) eg. lineDash:[6,10]
	 * @cfg {number} style.lineDashOffset=0  笔画的虚线偏移量 参见[lineDashOffset](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset)
	 * @cfg {string} style.text="" 节点上显示的文本,可以使用 \n 来换行
	 * @cfg {string} style.textFont='12px sans-serif' 字体大小、字体类型、粗细、字体样式。格式参见[css font](https://developer.mozilla.org/en-US/docs/Web/CSS/font) eg.textFont: 'italic bolder 14px Microsoft YaHei'
	 * @cfg {string} style.fontStyle=null 字体样式
	 * @cfg {string} style.fontWeight=#000 字体粗细
	 * @cfg {number} style.fontSize=null 字体大小
	 * @cfg {string} style.fontFamily=null 字体类型
	 * @cfg {string} style.textFill=#000 节点上文本的填充色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red
	 * @cfg {string} style.textStoke=null 节点上文本的描边色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red
	 * @cfg {string|Array} style.textPosition="" 文本在节点中的位置left|right|top|bottom|inside|insideLeft|insideRight|insideTop|insideBottom|insideTopLeft|insideTopRight|insideBottomLeft|insideBottomRight|[x,y]|[%,%]
	 * @cfg {string} style.textBaseline="alphabetic" 当前文本基线的属性 "top" || "hanging" || "middle" || "alphabetic" || "ideographic" || "bottom" 参见[css font](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/textBaseline)
	 * @cfg {Array} style.textOffset=null 文本在节点的偏移值[x,y] eg. [10,10]
	 * @cfg {string} style.textAlign="" 文本在节点中的对齐方式 left | center | right
	 * @cfg {string} style.textVerticalAlign=null 文本在节点中的垂直对齐方式 top | middle | bottom
	 * @cfg {number} style.textDistance=5 文字的相对textPos的偏移量 eg. textPosition='left' textDistance=5 则文字的x坐标的值为 (left的坐标x值) -5
	 * @cfg {string} style.textShadowColor='transparent' 文字阴影颜色
	 * @cfg {number} style.textShadowBlur=0 文本阴影宽度 参见[shadowBlur](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowBlur)
	 * @cfg {number} style.textShadowOffsetX=0 文本阴影 X 方向偏移 参见shadowOffsetX[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX]
	 * @cfg {number} style.textShadowOffsetY=0 文本阴影 Y 方向偏移 参见shadowOffsetY[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY]
	 * @cfg {number} style.textRotation=0 文本旋转的角度
	 * @cfg {number} style.textBorderWidth=0 文字描边宽度
	 * @cfg {string} style.textBorderColor=null 文字描边颜色
	 * @cfg {number} style.textBorderRadius=0 文字描边半径
	 * @cfg {string|Object} style.textBackgroundColor=null 文字背景(颜色或图片) eg. '#333' | {image:'./asset/img/clund.png'}
	 * @cfg {number|Array} style.textPadding=null 文字padding  eg. `2` or `[2, 4]` or `[2, 3, 4, 5]`
	 * @cfg {Object} style.rich=null 富文本样式属性
	 * @cfg {number} style.textLineHeight=0 文字的行高
	 * @cfg {number} style.opacity=1 图形透明度。支持从 0 到 1 的数字，为 0 时不绘制该图形。
	 * @cfg {number} style.shadowBlur=0 阴影宽度 参见[shadowBlur](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowBlur)
	 * @cfg {number} style.shadowOffsetX=0 阴影 X 方向偏移 参见shadowOffsetX[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetX]
	 * @cfg {number} style.shadowOffsetY=0 阴影 Y 方向偏移 参见shadowOffsetY[https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowOffsetY]
	 * @cfg {string} style.shadowColor='#000' 阴影颜色 eg.#5C9AD3 | rgb(0,200,255) | rgba(0,200,255,0.6) | red 参见[shadowColor](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/shadowColor)
	 * @cfg {string} style.image="" 图片的路径 用于Image
	 * @cfg {number} style.width 图片的宽度 用于Image
	 * @cfg {number} style.height 图片的高度 用于Image
	 */
	
	 /**
	 * @cfg {Object} hoverStyle hover样式, 参数见style
	  */
	 /**
	 * @cfg {Object} selectStyle 选中节点的样式, 参数见style;  默认是一个虚的边框;  设为空对象则不显示选中边框;
	*/
	/**
	 * @cfg {Boolean} draggable=true 是否可以被拖拽。
	 */
	
	/**
	 * @cfg {Boolean} selectable=true 节点是否可选中，默认是true
	 */
	
	/**
	 * @cfg {String} id 为了避免重复，目前由系统自动生成，如果不需要用可以忽略。建议使用nmae
	 */
	
	/**
	 *  @cfg {Boolean} hoverAnimation=false 是否开启 hover 在节点上的提示动画效果。，默认是false
	 */
	
	/**
	 * @cfg {String} name 指定节点的name, 可以使用childOfName等函数根据name查找节点
	 */
	
	/**
	 * @cfg {String} tooltip 节点的tooltip 内容可以包括HTML标签
	 */
	
	/**
	 * @cfg {Object} relative relative描述怎么根据父元素进行定位，设置了relative属性 就不需要设置position。支持：left、right、top、bottom
	 * @cfg {Number|String} relative.left  距离父元素左边的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.left 和 right 只有一个可以生效。
	 * @cfg {Number|String} relative.right  距离父元素右边的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.left 和 right 只有一个可以生效。
	 * @cfg {Number|String} relative.top  距离父元素顶部的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.top 和 bottom 只有一个可以生效。
	 * @cfg {Number|String} relative.bottom  距离父元素底部的位置。值的类型可以是：1.number：表示像素值；2.百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。3.'center'：表示自动居中。4.top 和 bottom 只有一个可以生效。
	 * @cfg {String} [bounding='all'] 决定此图形元素在定位时，对自身的包围盒计算方式。 1.'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。2.'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。
	 */
	
	/**
	 * @cfg {Array} scale 节点的缩放因子, [x,y] 水平与垂直方向的 eg. [1,1]
	 */
	
	/**
	 * @cfg {number} rotation 节点的旋转因子, 单位是角度 eg. 0.5* Math.PI
	 */
	
	/**
	 * @cfg {Array} origin 旋转和缩放的原点, [x,y] eg. [75,75]
	 */
	
	/**
	 * @cfg {number} z=0  z方向的高度，决定层叠关系。类似css zIndex
	 */
	
	/**
	 * @cfg {number} zlevel=0  决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。
	 */
	
	/**
	 * @cfg {Boolean} silent=false  是否不响应鼠标以及触摸事件。
	 */
	/**
	 * @cfg {Boolean} invisible=false  节点是否可见。
	 */
	
	/**
	 * @cfg {Object} parent  节点的父元素
	 */
	/**
	 * @cfg {Object} operationIcons  节点操作为选中的节点，提供默认操作或用户自定操作。 默认提供的操作：{ name: constants.DEL } 删除节点, { constants.LINK} 直线, { constants.FOLD} 折线, { constants.CURVE } 曲线。也可以自定义操作
	 * **使用范例**：
	 *
	 *      @example
	 *       var image1 = new node.Image({
	 *           style: {
	 *               image: "img/img-cic/icon-send-sms.svg",
	 *               width:120,
	 *               height:70,
	 *               text:"操作:线段",
	 *               textPosition:"insideBottom"
	 *           },
	 *           position:[60,60],
	 *           operationIcons: [
	 *               { name: constants.LINK} ,
	 *               { name: constants.FOLD },
	 *               { name: constants.CURVE }
	 *           ]
	 *       });
	 */
	
	/**
	 * @property {Object} states
	 * 用于设置节点的状态
	 */
	
	
	/**
	 * @property {Object} model
	 * 节点的模型，用于存储序列化数据 以及用户自定义数据
	 */
	
	/**
	 * @method setStyle
	 * 创建节点后，设置节点的样式（style属性）
	 * @param {String} key 键名
	 * @param {*} value 键值
	 * @return {Object} 返回节点对象自身
	 */
	
	/**
	 * @method setShape
	 * 创建节点后，设置节点的形状（shape属性）
	 * @param {String} key 键名
	 * @param {*} value 键值
	 * @return {Object} 返回节点对象自身
	 */
	
	/**
	 * @method hide
	 * 隐藏节点
	 */
	
	/**
	 * @method show
	 * 显示节点
	 */
	
	
	/**
	 * @method on
	 * 绑定事件
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 * @param {Object} [context] 上下文
	 */
	
	/**
	 * @method off
	 * 解绑事件
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 */
	
	/**
	 * @method one
	 * 单次触发绑定,trigger后销毁
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 * @param {Object} [context] 上下文
	 */
	
	/**
	 * @method trigger
	 * 事件分发
	 * @param {String} type 事件类型
	 */
	
	/**
	 * @method isSilent
	 * 是否绑定了事件
	 * @param {String} event 事件名
	 * @return {boolean}
	 */
	
	/**
	 * @method animate
	 * 动画
	 * @param {String} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性
	 * @param {Boolean} [loop] 动画是否循环
	 * @return {Object} 返回Animator对象
	 * **使用范例**：
	 *
	 *      @example
	 *      el.animate('style', false)
	 *         .when(1000, {x: 10} )
	 *         .done(function(){ // Animation done })
	 *         .start()
	 */
	
	/**
	 * @method stopAnimation
	 * 停止动画
	 * @param {boolean} forwardToLast 是否在停止前移动到最后一帧
	 */
	
	/**
	 * @method animateTo
	 * 从一动属性过渡到另一种属性的动画
	 * @param {Object} target 目前属性
	 * @param {number} [time=500] 动画时间 单位ms
	 * @param {string} [easing='linear'] 动画函数 参见[缓动示例](http://echarts.baidu.com/gallery/editor.html?c=line-easing)
	 * @param {number} [delay=0] 延时时间
	 * @param {Function} [callback] 动画结束回调
	 * **使用范例**：
	 *
	 *      @example
	 *          // Animate position
	 *          el.animateTo({
	 *              position: [10, 10]
	 *          }, function () { // done })
	 *
	 *          // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
	 *          el.animateTo({
	 *              shape: {
	 *                  width: 500
	 *              },
	 *              style: {
	 *                  fill: 'red'
	 *              }
	 *              position: [10, 10]
	 *          }, 100, 100, 'cubicOut', function () { // done })
	 */
	
	/**
	 * @event click
	 * 单击事件
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('click', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event dblclick
	 * 当双击元素时，会发生 dblclick 事件。
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('dblclick', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event mouseover
	 * 当鼠标指针位于元素上方时，会发生 mouseover 事件
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mouseover', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event mouseout
	 * 当鼠标指针从元素上移开时，发生 mouseout 事件。
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mouseout', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	
	/**
	 * @event mousemove
	 * 当鼠标指针在指定的元素中移动时，就会发生 mousemove 事件
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mousemove', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	
	/**
	 * @event mousewheel
	 * 当用户在指定的元素时滚动鼠标滑轮时,就会发生 mousewheel事件
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mousewheel', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	
	/**
	 * @event mousedown
	 * 当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mousedown', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	
	/**
	 * @event mouseup
	 * 当在元素上放松鼠标按钮时，会发生 mouseup 事件。
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象
	 * <pre>
	 * node.on('mouseup', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event contextmenu
	 * 当在元素上点击鼠标右键时，会发生 contextmenu 事件。
	 * @param {Object} event 事件
	 * @param {Object} event.target 目标对象
	 * @param {Object} event.event 实际的浏览器事件对象，如果想阻止默认的浏览器右键菜单请使用 event.event.preventDefault(); event.event.stopPropagation();
	
	 * <pre>
	 * node.on('contextmenu', function(event) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event dragstart
	 * 当开始拖动节点的时候，会发生 dragstart 事件。
	 *
	 * <pre>
	 * node.on('dragstart', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	
	/**
	 * @event drag
	 * 当拖动节点的时候，会发生 drag 事件。
	 *
	 * <pre>
	 * node.on('drag', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event dragend
	 * 当拖动节点结束的时候，会发生 dragend 事件。
	 *
	 * <pre>
	 * node.on('dragend', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 矩形<br>
	 * @class fishTopoFlow.node.Rect
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var rect = new node.Rect({
	 *           shape:{width:100,height:60},
	 *           position:[20,20]
	 *       });
	 *       fishTopo.add(rect);
	 */
	
	    var roundRectHelper = __webpack_require__(29);
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Rect',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Array} shape.points=null 拆线点的坐标 可以从AI中获取。
	         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑
	         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效
	         */
	        shape: {
	            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
	            // r缩写为1         相当于 [1, 1, 1, 1]
	            // r缩写为[1]       相当于 [1, 1, 1, 1]
	            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
	            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
	            x: 0,
	            y: 0,
	            r: 0,
	            width: 50,
	            height: 50
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = 0;
	            var y = 0;
	            var width = shape.width;
	            var height = shape.height;
	            if (!shape.r) {
	                ctx.rect(x, y, width, height);
	            }
	            else {
	                roundRectHelper.buildPath(ctx, shape);
	            }
	            ctx.closePath();
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 圆形<br>
	 * @class fishTopoFlow.node.Circle
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var circle = new node.Circle({
	 *           shape:{r:24},
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(circle);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Circle',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=20 半径。
	         */
	        shape: {
	            r: 20
	        },
	
	        buildPath : function (ctx, shape, inBundle) {
	            // Better stroking in ShapeBundle
	            // Always do it may have performence issue ( fill may be 2x more cost)
	            if (inBundle) {
	                ctx.moveTo(shape.r, 0);
	            }
	            // Better stroking in ShapeBundle
	            // ctx.moveTo(shape.cx + shape.r, shape.cy);
	            ctx.arc(0, 0, shape.r, 0, Math.PI * 2, true);
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 图片节点<br>
	 * @class fishTopoFlow.node.Image
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var image = new node.Image({
	 *           style: {
	 *               image: "../../examples/flow/img/img-cic/start.svg",
	 *               width:120,
	 *               height:70,
	 *               text:"Event Name"
	 *           },
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(image);
	 */
	
	
	    var Displayable = __webpack_require__(8);
	    var BoundingRect = __webpack_require__(27);
	    var zrUtil = __webpack_require__(5);
	    var flowNode = __webpack_require__(96);
	    var LRU = __webpack_require__(21);
	    var globalImageCache = new LRU(50);
	
	
	    function ZImage(opts) {
	        this.model = flowNode.genModel("Image", opts);
	        Displayable.call(this, opts);
	
	        if (window.jQuery) {   //判断jQuery是否存在
	            this.resultDeferrd = jQuery.Deferred();
	            this.result = this.resultDeferrd.promise();
	        }
	    }
	
	    ZImage.prototype = {
	
	        constructor: ZImage,
	
	        type: 'Image',
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var src = style.image;
	            var image;
	
	            // Must bind each time
	            style.bind(ctx, this, prevEl);
	            // style.image is a url string
	            if (typeof src === 'string') {
	                image = this._image;
	            }
	            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas
	            else {
	                image = src;
	                image.isLoaded = true;
	            }
	            // FIXME Case create many images with src
	            if (!image && src) {
	                // Try get from global image cache
	                var cachedImgObj = globalImageCache.get(src);
	                if (!cachedImgObj) {
	                    // Create a new image
	                    image = new Image();
	                    image.isLoaded = false;
	                    image.onload = function () {
	                        image.isLoaded = true;
	                        image.onload = null;
	                        for (var i = 0; i < cachedImgObj.pending.length; i++) {
	                            cachedImgObj.pending[i].dirty();
	                        }
	                    };
	                    cachedImgObj = {
	                        image: image,
	                        pending: [this]
	                    };
	                    image.src = src;
	                    globalImageCache.put(src, cachedImgObj);
	                    this._image = image;
	                    return;
	                }
	                else {
	                    image = cachedImgObj.image;
	                    this._image = image;
	                    // Image is not complete finish, add to pending list  如果使用的svg图片, IE11下就算加载成功image.width, image.height也都是为0
	                    if ((!image.width || !image.height) && (!image.src.endsWith("svg"))) {
	                        cachedImgObj.pending.push(this);
	                        return;
	                    }
	                }
	            }
	
	            if (image) {
	                // 图片已经加载完成
	                // if (image.nodeName.toUpperCase() == 'IMG') {
	                //     if (!image.complete) {
	                //         return;
	                //     }
	                // }
	                // Else is canvas
	
	                var x = style.x || 0;
	                var y = style.y || 0;
	                // 如果使用的svg图片, IE11下就算加载成功image.width, image.height也都是为0
	                //此处如不注释, 会导致IE11下svg图片无法使用
	                // 图片加载失败
	                // if (!image.width || !image.height) {
	                //     return;
	                // }
	                if (!image.isLoaded) {
	                    if (window.jQuery) {
	                        this.resultDeferrd.reject(image);
	                    }
	                    return;
	                }
	
	                var width = style.width;
	                var height = style.height;
	                var aspect = image.width / image.height;
	                if (width == null && height != null) {
	                    // Keep image/height ratio
	                    width = height * aspect;
	                }
	                else if (height == null && width != null) {
	                    height = width / aspect;
	                }
	                else if (width == null && height == null) {
	                    width = image.width;
	                    height = image.height;
	                }
	
	                // 设置transform
	                this.setTransform(ctx);
	
	                if (style.sWidth && style.sHeight) {
	                    var sx = style.sx || 0;
	                    var sy = style.sy || 0;
	                    ctx.drawImage(
	                        image,
	                        sx, sy, style.sWidth, style.sHeight,
	                        x, y, width, height
	                    );
	                }
	                else if (style.sx && style.sy) {
	                    var sx2 = style.sx;
	                    var sy2 = style.sy;
	                    var sWidth = width - sx2;
	                    var sHeight = height - sy2;
	                    ctx.drawImage(
	                        image,
	                        sx2, sy2, sWidth, sHeight,
	                        x, y, width, height
	                    );
	                }
	                else {
	                    ctx.drawImage(image, x, y, width, height);
	                }
	                // 如果没设置宽和高的话自动根据图片宽高设置
	                if (style.width == null) {
	                    style.width = width;
	                }
	                if (style.height == null) {
	                    style.height = height;
	                }
	
	                this.restoreTransform(ctx);
	
	                // Draw rect text
	                if (style.text != null) {
	                    this.drawRectText(ctx, this.getBoundingRect());
	                }
	                if (window.jQuery) {
	                    this.resultDeferrd.resolve(image);
	                }
	            }
	        },
	
	        getBoundingRect: function () {
	            var style = this.style;
	            if (! this._rect) {
	                this._rect = new BoundingRect(
	                    style.x || 0, style.y || 0, style.width || 0, style.height || 0
	                );
	            }
	            return this._rect;
	        }
	    };
	
	    zrUtil.inherits(ZImage, Displayable);
	
	    module.exports = ZImage;
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 文本<br>
	 * @class fishTopoFlow.node.Text
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var text = new node.Text({
	 *           style:{text:"文本也可以作为独立的节点进行拖拽",fill:"#ff0000", textFont:"16px Microsoft YaHei"},
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(text);
	 */
	
	    var Text = __webpack_require__(46);
	    var zrUtil = __webpack_require__(5);
	    var flowNode = __webpack_require__(96);
	    function ZText(opts) {
	        var defaultOptions = {
	            style:{textBaseline:"top"}   // 默认值  这样选中时的框才正确
	        };
	        var options = zrUtil.merge(defaultOptions, opts, true);
	        this.model = flowNode.genModel("Text", opts);
	        Text.call(this, options);
	    }
	    zrUtil.inherits(ZText, Text);
	    module.exports = ZText;
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 扇形<br>
	 * @class fishTopoFlow.node.Sector
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var sector = new node.Sector({
	 *           shape: {r:30, startAngle:0, endAngle:Math.PI * 0.5}, // startAngle\endAngle是弧度单位
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(sector);
	 */
	
	    var env = __webpack_require__(50);
	    var Path = __webpack_require__(7);
	
	    var shadowTemp = [
	        ['shadowBlur', 0],
	        ['shadowColor', '#000'],
	        ['shadowOffsetX', 0],
	        ['shadowOffsetY', 0]
	    ];
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Sector',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=0 外半径。
	         * @cfg {Number} shape.r0=0 内半径。
	         * @cfg {Number} shape.startAngle=0 开始弧度。
	         * @cfg {Number} shape.endAngle=Math.PI * 2  结束弧度。
	         * @cfg {Boolean} shape.clockwise=true 是否顺时针。
	         */
	        shape: {
	            cx: 0,
	
	            cy: 0,
	
	            r0: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'
	            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),
	            // where exception "unexpected call to method or property access"
	            // might be thrown when calling ctx.fill after a path whose area size
	            // is zero is drawn and ctx.clip() is called and shadowBlur is set.
	            // (e.g.,
	            //  ctx.moveTo(10, 10);
	            //  ctx.lineTo(20, 10);
	            //  ctx.closePath();
	            //  ctx.clip();
	            //  ctx.shadowBlur = 10;
	            //  ...
	            //  ctx.fill();
	            // )
	            ? function () {
	                var clipPaths = this.__clipPaths;
	                var style = this.style;
	                var modified;
	
	                if (clipPaths) {
	                    for (var i = 0; i < clipPaths.length; i++) {
	                        var shape = clipPaths[i] && clipPaths[i].shape;
	                        if (shape && shape.startAngle === shape.endAngle) {
	                            for (var j = 0; j < shadowTemp.length; j++) {
	                                shadowTemp[j][2] = style[shadowTemp[j][0]];
	                                style[shadowTemp[j][0]] = shadowTemp[j][1];
	                            }
	                            modified = true;
	                            break;
	                        }
	                    }
	                }
	
	                Path.prototype.brush.apply(this, arguments);
	
	                if (modified) {
	                    for (var k = 0; k < shadowTemp.length; k++) {
	                        style[shadowTemp[k][0]] = shadowTemp[k][2];
	                    }
	                }
	            }
	            : Path.prototype.brush,
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r0 = Math.max(shape.r0 || 0, 0);
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
	
	            ctx.lineTo(unitX * r + x, unitY * r + y);
	
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	
	            ctx.lineTo(
	                Math.cos(endAngle) * r0 + x,
	                Math.sin(endAngle) * r0 + y
	            );
	
	            if (r0 !== 0) {
	                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
	            }
	
	            ctx.closePath();
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 环形<br>
	 * @class fishTopoFlow.node.Ring
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var ring = new node.Ring({
	 *           shape: {r:30,  r0:10},  // r0 内半径
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(ring);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	         type: 'Ring',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=0 外半径。
	         * @cfg {Number} shape.r0=0 内半径。
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0,
	            r0: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.cx;
	            var y = shape.cy;
	            var PI2 = Math.PI * 2;
	            ctx.moveTo(x + shape.r, y);
	            ctx.arc(x, y, shape.r, 0, PI2, false);
	            ctx.moveTo(x + shape.r0, y);
	            ctx.arc(x, y, shape.r0, 0, PI2, true);
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 椭圆<br>
	 * @class fishTopoFlow.node.Droplet
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var ellipse = new node.Ellipse({
	 *           shape: {rx:70,  ry:30},  // rx:椭圆横半轴长 ry:椭圆纵半轴长
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(ellipse);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Ellipse',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.rx=0 椭圆横半轴长
	         * @cfg {Number} shape.ry=0 椭圆纵半轴长
	         */
	        shape: {
	            rx: 0, ry: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var k = 0.5522848;
	            var x = 0;
	            var y = 0;
	            var a = shape.rx;
	            var b = shape.ry;
	            var ox = a * k; // 水平控制点偏移量
	            var oy = b * k; // 垂直控制点偏移量
	            // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线
	            ctx.moveTo(x - a, y);
	            ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
	            ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
	            ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
	            ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
	            ctx.closePath();
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 心形<br>
	 * @class fishTopoFlow.node.Heart
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var heart  = new node.Heart({
	 *           shape: {width:40,  height:50},
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(heart );
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Heart',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.cx=0 中心在父节点坐标系（以父节点左上角为原点）中的横坐标值。
	         * @cfg {Number} shape.cy=0 中心在父节点坐标系（以父节点左上角为原点）中的纵坐标值。
	         * @cfg {Number} shape.width=0 宽度。
	         * @cfg {Number} shape.height=0 高度。
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.cx;
	            var y = shape.cy;
	            var a = shape.width;
	            var b = shape.height;
	            ctx.moveTo(x, y);
	            ctx.bezierCurveTo(
	                x + a / 2, y - b * 2 / 3,
	                x + a * 2, y + b / 3,
	                x, y + b
	            );
	            ctx.bezierCurveTo(
	                x - a *  2, y + b / 3,
	                x - a / 2, y - b * 2 / 3,
	                x, y
	            );
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 水滴形<br>
	 * @class fishTopoFlow.node.Droplet
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var droplet = new node.Droplet({
	 *           shape: {width:10,  height:30},
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(droplet);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Droplet',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.width=0 宽度。
	         * @cfg {Number} shape.height=0 高度。
	         */
	        shape: {
	            cx: 0, cy: 0,
	            width: 0, height: 0
	        },
	
	        buildPath : function (ctx, shape) {
	            var x = shape.cx;
	            var y = shape.cy;
	            var a = shape.width;
	            var b = shape.height;
	
	            ctx.moveTo(x, y + a);
	            ctx.bezierCurveTo(
	                x + a,
	                y + a,
	                x + a * 3 / 2,
	                y - a / 3,
	                x,
	                y - b
	            );
	            ctx.bezierCurveTo(
	                x - a * 3 / 2,
	                y - a / 3,
	                x - a,
	                y + a,
	                x,
	                y + a
	            );
	            ctx.closePath();
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 玫瑰形<br>
	 * @class fishTopoFlow.node.Rose
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var rose = new node.Rose({
	 *           shape: {r:[35], k:7, n:4},
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(rose);
	 */
	
	    var sin = Math.sin;
	    var cos = Math.cos;
	    var radian = Math.PI / 180;
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Rose',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Array} shape.r=[]
	         * @cfg {Number} shape.k=0
	         * @cfg {Number} shape.n=1
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: [],
	            k: 0,
	            n: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null,
	            lineWidth: 2
	        },
	
	        buildPath: function (ctx, shape) {
	            var x;
	            var y;
	            var R = shape.r;
	            var r;
	            var k = shape.k;
	            var n = shape.n;
	
	            var x0 = shape.cx;
	            var y0 = shape.cy;
	
	            ctx.moveTo(x0, y0);
	
	            for (var i = 0, len = R.length; i < len ; i++) {
	                r = R[i];
	
	                for (var j = 0; j <= 360 * n; j++) {
	                    x = r
	                         * sin(k / n * j % 360 * radian)
	                         * cos(j * radian)
	                         + x0;
	                    y = r
	                         * sin(k / n * j % 360 * radian)
	                         * sin(j * radian)
	                         + y0;
	                    ctx.lineTo(x, y);
	                }
	            }
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 正多边形<br>
	 * @class fishTopoFlow.node.Isogon
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var isogon = new node.Isogon({
	 *           shape: {r:40,  n:9},  // r半径 n几个边
	 *           position:[60,50]
	 *       });
	 *       fishTopo.add(isogon);
	 */
	
	    var PI = Math.PI;
	    var sin = Math.sin;
	    var cos = Math.cos;
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Isogon',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=0 半径
	         * @cfg {Number} shape.n=0 几个边
	         */
	       shape: {
	            x: 0, y: 0,
	            r: 0, n: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var n = shape.n;
	            if (!n || n < 2) {
	                return;
	            }
	
	            var x = shape.x;
	            var y = shape.y;
	            var r = shape.r;
	
	            var dStep = 2 * PI / n;
	            var deg = -PI / 2;
	
	            ctx.moveTo(x + r * cos(deg), y + r * sin(deg));
	            for (var i = 0, end = n - 1; i < end; i++) {
	                deg += dStep;
	                ctx.lineTo(x + r * cos(deg), y + r * sin(deg));
	            }
	
	            ctx.closePath();
	
	            return;
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 多边形<br>
	 * @class fishTopoFlow.node.Polygon
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var polygon = new node.Polygon({
	 *           shape: {points:[[85.275,0], [100,25.41], [85.275,50.821], [14.138,50.821], [0,25.41], [14.138,0]]},  // r半径 n几个边
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(polygon);
	 */
	
	    var polyHelper = __webpack_require__(53);
	
	    module.exports = __webpack_require__(96).extend({
	
	       type: 'Polygon',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Array} shape.points=null 多边形点的坐标 可以从AI中获取。
	         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑
	         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效
	         */
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, true);
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 直线<br>
	 * @class fishTopoFlow.node.Line
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var line = new node.Line({
	 *           shape: {x1:60,  y1:60, x2:100, y2:100},  // x 起点 y终点
	 *           style: {lineWidth:3}
	 *       });
	 *       fishTopo.add(line);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Line',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.x1=0 起始点的横坐标值。
	         * @cfg {Number} shape.y1=0 起始点的纵坐标值。
	         * @cfg {Number} shape.x2=0 终止点的横坐标值。
	         * @cfg {Number} shape.y2=0 终止点的纵坐标值。
	         */
	        shape: {
	            // Start point
	            x1: 0,
	            y1: 0,
	            // End point
	            x2: 0,
	            y2: 0,
	
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var percent = shape.percent;
	
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (percent < 1) {
	                x2 = x1 * (1 - percent) + x2 * percent;
	                y2 = y1 * (1 - percent) + y2 * percent;
	            }
	            ctx.lineTo(x2, y2);
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} percent
	         * @return {Array.<number>}
	         */
	        pointAt: function (p) {
	            var shape = this.shape;
	            return [
	                shape.x1 * (1 - p) + shape.x2 * p,
	                shape.y1 * (1 - p) + shape.y2 * p
	            ];
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 拆线<br>
	 * @class fishTopoFlow.node.Polyline
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var polyline = new node.Polyline({
	 *           shape: {points:[[57,138],[95,184],[115,166],[151,184] ]}
	 *       });
	 *       fishTopo.add(polyline);
	 */
	
	    var polyHelper = __webpack_require__(53);
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Polyline',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Array} shape.points=null 拆线点的坐标 可以从AI中获取。
	         * @cfg {Number|String|Boolean} [shape.smooth=false] 是否平滑曲线显示。如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1];如果为 'spline'：表示 Catmull-Rom spline 差值平滑
	         * @cfg {Number} shape.smoothConstraint=null 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效
	         */
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        style: {
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, false);
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 贝塞尔曲线<br>
	 * @class fishTopoFlow.node.BezierCurve
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var bezierCurve = new node.BezierCurve({
	 *           shape: {x1:0, y1:100, cpx1:0, cpy1:0, cpx2:0, cpy2:0, x2:100, y2:0},
	 *           position: [60, 60]
	 *       });
	 *       fishTopo.add(bezierCurve);
	 */
	
	
	    var curveTool = __webpack_require__(31);
	    var vec2 = __webpack_require__(15);
	    var quadraticSubdivide = curveTool.quadraticSubdivide;
	    var cubicSubdivide = curveTool.cubicSubdivide;
	    var quadraticAt = curveTool.quadraticAt;
	    var cubicAt = curveTool.cubicAt;
	    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;
	    var cubicDerivativeAt = curveTool.cubicDerivativeAt;
	
	    var out = [];
	
	    function someVectorAt(shape, t, isTangent) {
	        var cpx2 = shape.cpx2;
	        var cpy2 = shape.cpy2;
	        if (cpx2 === null || cpy2 === null) {
	            return [
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
	            ];
	        }
	        else {
	            return [
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
	            ];
	        }
	    }
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'BezierCurve',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.x1=0 起始点的横坐标值。
	         * @cfg {Number} shape.y1=0 起始点的纵坐标值。
	         * @cfg {Number} shape.x2=0 终止点的横坐标值。
	         * @cfg {Number} shape.y2=0 终止点的纵坐标值。
	         * @cfg {Number} shape.cpx1=0 控制点的横坐标值。
	         * @cfg {Boolean} shape.cpx2=0 控制点的纵坐标值。
	         */
	        shape: {
	            x1: 0,
	            y1: 0,
	            x2: 0,
	            y2: 0,
	            cpx1: 0,
	            cpy1: 0,
	
	            // Curve show percent, for animating
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var cpx1 = shape.cpx1;
	            var cpy1 = shape.cpy1;
	            var cpx2 = shape.cpx2;
	            var cpy2 = shape.cpy2;
	            var percent = shape.percent;
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (cpx2 == null || cpy2 == null) {
	                if (percent < 1) {
	                    quadraticSubdivide(
	                        x1, cpx1, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    x2 = out[2];
	                    quadraticSubdivide(
	                        y1, cpy1, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    y2 = out[2];
	                }
	
	                ctx.quadraticCurveTo(
	                    cpx1, cpy1,
	                    x2, y2
	                );
	            }
	            else {
	                if (percent < 1) {
	                    cubicSubdivide(
	                        x1, cpx1, cpx2, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    cpx2 = out[2];
	                    x2 = out[3];
	                    cubicSubdivide(
	                        y1, cpy1, cpy2, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    cpy2 = out[2];
	                    y2 = out[3];
	                }
	                ctx.bezierCurveTo(
	                    cpx1, cpy1,
	                    cpx2, cpy2,
	                    x2, y2
	                );
	            }
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        pointAt: function (t) {
	            return someVectorAt(this.shape, t, false);
	        },
	
	        /**
	         * Get tangent at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        tangentAt: function (t) {
	            var p = someVectorAt(this.shape, t, true);
	            return vec2.normalize(p, p);
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 圆弧<br>
	 * @class fishTopoFlow.node.Arc
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var arc = new node.Arc({
	 *           shape: {r:50, startAngle:0, endAngle:1.2*Math.PI},
	 *           position: [60, 60]
	 *       });
	 *       fishTopo.add(arc);
	 */
	
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Arc',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=0 半径。
	         * @cfg {Number} shape.startAngle=0 开始弧度。
	         * @cfg {Number} shape.endAngle=Math.PI * 2  结束弧度。
	         * @cfg {Boolean} shape.clockwise=true 是否顺时针。
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0,
	            startAngle: 0,
	            endAngle: Math.PI * 2,
	            clockwise: true
	        },
	
	        style: {
	
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r + x, unitY * r + y);
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 星形<br>
	 * @class fishTopoFlow.node.Star
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var star = new node.Star({
	 *           shape: {n:7, r:30},  //r半径 n几个角
	 *           position:[60,60]
	 *       });
	 *       fishTopo.add(star);
	 */
	
	    var PI = Math.PI;
	
	    var cos = Math.cos;
	    var sin = Math.sin;
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Star',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.n=3 几个角。
	         * @cfg {Number} shape.r=0 外半径。
	         * @cfg {Number} shape.r0=0 内半径。
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            n: 3,
	            r0: null,
	            r: 0
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var n = shape.n;
	            if (!n || n < 2) {
	                return;
	            }
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r = shape.r;
	            var r0 = shape.r0;
	
	            // 如果未指定内部顶点外接圆半径，则自动计算
	            if (r0 == null) {
	                r0 = n > 4
	                    // 相隔的外部顶点的连线的交点，
	                    // 被取为内部交点，以此计算r0
	                    ? r * cos(2 * PI / n) / cos(PI / n)
	                    // 二三四角星的特殊处理
	                    : r / 3;
	            }
	
	            var dStep = PI / n;
	            var deg = -PI / 2;
	            var xStart = x + r * cos(deg);
	            var yStart = y + r * sin(deg);
	            deg += dStep;
	
	            // 记录边界点，用于判断inside
	            ctx.moveTo(xStart, yStart);
	            for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {
	                ri = i % 2 === 0 ? r0 : r;
	                ctx.lineTo(x + ri * cos(deg), y + ri * sin(deg));
	                deg += dStep;
	            }
	
	            ctx.closePath();
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 旋轮曲线<br>
	 * @class fishTopoFlow.node.Trochoid
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       var trochoid = new node.Trochoid({
	 *           shape: {r:50, r0:35, d:30, location:null},  //r半径 n几个角
	 *           position:[60,60],
	 *           tooltip: "旋轮曲线"
	 *       });
	 *       fishTopo.add(trochoid);
	 */
	
	
	    var cos = Math.cos;
	    var sin = Math.sin;
	    module.exports = __webpack_require__(96).extend({
	
	        type: 'Trochoid',
	        /**
	         * @cfg {Object} shape 形状参数
	         * @cfg {Number} shape.r=0 外半径。
	         * @cfg {Number} shape.r0=0 内半径。
	         * @cfg {Number} shape.d=0
	         * @cfg {Number} shape.location='out'
	         */
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0,
	            r0: 0,
	            d: 0,
	            location: 'out'
	        },
	
	        style: {
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1;
	            var y1;
	            var x2;
	            var y2;
	            var R = shape.r;
	            var r = shape.r0;
	            var d = shape.d;
	            var offsetX = shape.cx;
	            var offsetY = shape.cy;
	            var delta = shape.location == 'out' ? 1 : -1;
	
	            if (shape.location && R <= r) {
	                return;
	            }
	
	            var num = 0;
	            var i = 1;
	            var theta;
	
	            x1 = (R + delta * r) * cos(0)
	                - delta * d * cos(0) + offsetX;
	            y1 = (R + delta * r) * sin(0)
	                - d * sin(0) + offsetY;
	
	            ctx.moveTo(x1, y1);
	
	            // 计算结束时的i
	            do {
	                num++;
	            }
	            while ((r * num) % (R + delta * r) !== 0);
	
	            do {
	                theta = Math.PI / 180 * i;
	                x2 = (R + delta * r) * cos(theta)
	                     - delta * d * cos((R / r +  delta) * theta)
	                     + offsetX;
	                y2 = (R + delta * r) * sin(theta)
	                     - d * sin((R / r + delta) * theta)
	                     + offsetY;
	                ctx.lineTo(x2, y2);
	                i++;
	            }
	            while (i <= (r * num) / (R + delta * r) * 360);
	
	        }
	    });
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 路径<br>
	 * @class fishTopoFlow.node.Path
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var path = new node.Path({
	 *           pathData: 'M9 0l8 8-17 17 7 7 17-17 8 8v-23h-23z',
	 *           rect: {x:0,y:0,width:30,height:30},
	 *           position: [60,60]
	 *       });
	 *       fishTopo.add(path);
	 */
	
	    var pathTool = __webpack_require__(6);
	    var Draggable = __webpack_require__(43);
	    var zrUtil = __webpack_require__(5);
	    var flowNode = __webpack_require__(96);
	
	    function ZPath(opts) {
	        /**
	         * @cfg {Object} options 参数
	         * @cfg {String} options.pathData path数据。
	         * @cfg {Object} options.rect 图形的大小。
	         * @cfg {Object} options.rect.width 图形的宽度。
	         * @cfg {Object} options.rect.height 图形的高度。
	         * @cfg {Number} [options.layout=null] 默认为null  仅支持"center"
	         *
	         */
	        var defaultOptions = {
	            style:{ fill: 'none',stroke: '#2c2c2c'},
	            rect:{x:0,y:0,width:0,height:0},
	            rectHover: true
	        }
	
	        var pathData = opts.pathData;
	        var model = flowNode.genModel("Path", opts);
	        delete opts.pathData;
	        this.options = zrUtil.merge(defaultOptions, opts, true);
	        var path = pathTool.createFromString(pathData, this.options);
	        path.model = model;
	        Draggable.call(path);
	        var boundingRect = path.getBoundingRect();
	        var rect = this.options.rect;
	        var layout = opts.layout;
	        if (rect) {
	            var aspect = boundingRect.width / boundingRect.height;
	
	            if (layout === 'center') {
	                // Set rect to center, keep width / height ratio.
	                var width = rect.height * aspect;
	                var height;
	                if (width <= rect.width) {
	                    height = rect.height;
	                }
	                else {
	                    width = rect.width;
	                    height = width / aspect;
	                }
	                var cx = rect.x + rect.width / 2;
	                var cy = rect.y + rect.height / 2;
	
	                rect.x = cx - width / 2;
	                rect.y = cy - height / 2;
	                rect.width = width;
	                rect.height = height;
	            }
	
	            this.resizePath(path, rect);
	        }
	
	        return path;
	    }
	
	    ZPath.prototype = {
	
	        constructor: ZPath,
	
	        type: 'Path',
	        /**
	         * Resize a path to fit the rect
	         */
	        resizePath: function (path, rect) {
	                if (!path.applyTransform) {
	                    return;
	                }
	
	                var pathRect = path.getBoundingRect();
	
	                var m = pathRect.calculateTransform(rect);
	
	                path.applyTransform(m);
	        }
	    }
	    zrUtil.inherits(ZPath, Draggable);
	    module.exports = ZPath;
	
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 图形按钮<br>
	 * @class fishTopoFlow.node.IconButton
	 * @extends fishTopoFlow.node
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       var iconButton   = new node.IconButton({
	 *          title:'IconButton',
	 *          icon:'path://M432.45,595.444c0,2.177-4.661,6.82-11.305,6.82c-6.475,0-11.306-4.567-11.306-6.82s4.852-6.812,11.306-6.812C427.841,588.632,432.452,593.191,432.45,595.444L432.45,595.444z M421.155,589.876c-3.009,0-5.448,2.495-5.448,5.572s2.439,5.572,5.448,5.572c3.01,0,5.449-2.495,5.449-5.572C426.604,592.371,424.165,589.876,421.155,589.876L421.155,589.876z M421.146,591.891c-1.916,0-3.47,1.589-3.47,3.549c0,1.959,1.554,3.548,3.47,3.548s3.469-1.589,3.469-3.548C424.614,593.479,423.062,591.891,421.146,591.891L421.146,591.891zM421.146,591.891',
	 *          itemSize:50,
	 *          position:[60,60]
	 *       });
	 *       fishTopo.add(iconButton);
	 */
	
	
	
	    var zrUtil = __webpack_require__(5);
	    var graphic = __webpack_require__(4);
	    var flowNode = __webpack_require__(96);
	
	    function IconButton(opts) {
	
	        /**
	         * @cfg {Object} options 构造参数
	         * @cfg {String} options.title="" 鼠标移上去显示的文字
	         * @cfg {String} options.icon="" Icon 的 path 字符串，支持使用自定义的 svg path 作为 icon，格式参见 [SVG PathData](https://www.w3.org/TR/SVG/paths.html#PathData)。可以从 Adobe Illustrator 等工具编辑导出。
	         * @cfg {Number} options.itemSize=15  icon 的大小
	         * @cfg {Object} options.iconStyle  图标样式
	         * @cfg {Object} options.iconStyle.normal 正常的样式
	         * @cfg {Number} options.iconStyle.normal.stroke='#666' 正常的样式（描边色）
	         * @cfg {Number} options.iconStyle.normal.fill='none' 正常的样式（填充色）
	         * @cfg {Object} options.iconStyle.emphasis 高亮状态下的样式
	         * @cfg {Number} options.iconStyle.emphasis.stroke='#666' 高亮状态下的样式（描边色）
	         * @cfg {Number} options.iconStyle.emphasis.fill='none' 高亮状态下的样式（填充色）
	         */
	        var defaultOptions = {
	            backgroundColor: 'transparent',
	            borderColor: '#ccc',
	            draggable:false,
	            selectable:false,
	            borderWidth: 0,
	            itemSize: 15,
	            showTitle: true,
	            icon:"",  //Icon 的 path 字符串，支持使用自定义的 svg path 作为 icon，格式参见 SVG PathData。可以从 Adobe Illustrator 等工具编辑导出。
	            iconStyle: {
	                normal: {
	                    stroke: '#666',
	                    fill: 'none'
	                },
	                emphasis: {
	                    stroke: '#3E98c5'
	                }
	            }
	        };
	        this.options = zrUtil.merge(defaultOptions, opts, true);
	
	        this.model = flowNode.genModel("IconButton", this.options);
	        graphic.Group.call(this, this.options);
	        this.render();
	    }
	    IconButton.prototype = {
	        constructor: IconButton,
	        type: "IconButton",
	        render: function () {
	            var normalStyle = this.options.iconStyle.normal;
	            var hoverStyle = this.options.iconStyle.emphasis;
	            var itemSize = this.options.itemSize;
	            var icon = this.options.icon;
	            var style = {
	                x: -itemSize / 2,
	                y: -itemSize / 2,
	                width: itemSize,
	                height: itemSize
	            };
	            var path = icon.indexOf('image://') === 0 ?
	                (
	                    style.image = icon.slice(8),
	                    new graphic.Image({
	                        style: style
	                    })
	                ) :
	                graphic.makePath(
	                    icon.replace('path://', ''), {
	                        style: normalStyle,
	                        hoverStyle: hoverStyle,
	                        rectHover: true
	                    },
	                    style,
	                    'center'
	                );
	
	            graphic.setHoverStyle(path);
	
	            if (this.options.showTitle) {
	                path.__title = this.options.title;
	                path.on('mouseover', function () {
	                        // Should not reuse above hoverStyle, which might be modified.
	                        path.setStyle({
	                            text: this.options.title,
	                            textPosition: hoverStyle.textPosition || 'bottom',
	                            textFill: hoverStyle.fill || hoverStyle.stroke || '#000',
	                            textAlign: hoverStyle.textAlign || 'center'
	                        });
	                    }.bind(this))
	                    .on('mouseout', function () {
	                        path.setStyle({
	                            textFill: null
	                        });
	                    });
	            }
	
	            path.trigger('normal');
	            this.add(path);
	        }
	    }
	
	    zrUtil.inherits(IconButton, graphic.Group);
	    module.exports = IconButton;
	
	/**
	 * @method extend
	 * @hide
	 */

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * fishTopoFlow的link对象，框架提供的连线都放在这个对象下。
	 * @class fishTopoFlow.link
	 * @abstract
	 */
	
	    var Link = __webpack_require__(118);
	    var Fold = __webpack_require__(120);
	    var Curve = __webpack_require__(121);
	    var Connector = __webpack_require__(82);
	    var flowLink = {};
	    flowLink.Link = flowLink[Connector.TYPE_STRAIGHT] = Link;
	    flowLink.Fold = flowLink[Connector.TYPE_JAGGED] = Fold;
	    flowLink.Curve = flowLink[Connector.TYPE_CURVE] = Curve;
	    module.exports = flowLink;
	
	
	/**
	 * @method constructor
	 * 连线的构造函数
	 * @param  {Object} startNode 开始节点
	 * @param  {Object} endNode   结束节点
	 * @param  {Object} options 线段选项
	 * @param {Object} [options.style] 节点的样式
	 * @param {Number} [options.style.lineWidth=1] 线段的宽度
	 * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	 * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	 * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	 * @param {Object} [options.symbol] 线段的箭头
	 * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	 * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	 * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	 * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	 * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]
	 * @param {Object} [options.text] 线段上的文字
	 * @param {String} [options.text.text] 线段上的文字内容
	 * @param {String} [options.text.color] 线段上的文字颜色
	 * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	 * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	 * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	 * @param {String} [options.position] 指定线段位置
	 * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	 * @param {Object} [options.position.startOffset] 线段开始位置的偏移
	 * @param {Object} [options.position.endOffset] 线段结束位置的偏移
	 * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	 * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	 * @param {Object} [options.effect] 线上动态效果
	 * @param {String} [options.effect.show] 是否显示箭头动效
	 * @param {Number} [options.effect.period] 动效移动速度
	 * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	 * @param {Number} [options.z] 连线的层级，越大越在前面显示
	 * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)
	 * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)
	 * @return {Object} 返回创建成功的连线对象
	 */
	
	
	/**
	 * @method setStyle
	 * 创建连线后，设置连线的样式
	 * @param {Object} options 对应创建节点，传递的options参数
	 */
	/**
	 * @method on
	 * 绑定事件
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 * @param {Object} [context] 上下文
	 */
	
	/**
	 * @method off
	 * 解绑事件
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 */
	
	/**
	 * @method one
	 * 单次触发绑定,trigger后销毁
	 * @param {String} event 事件名
	 * @param {Function} handler 事件处理函数
	 * @param {Object} [context] 上下文
	 */
	
	/**
	 * @method trigger
	 * 事件分发
	 * @param {String} type 事件类型
	 */
	/**
	 * @event click
	 * 单击事件
	 *
	 * <pre>
	 * flink.on('Connector:click', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */
	
	/**
	 * @event dblclick
	 * 当双击元素时，会发生 dblclick 事件。
	 *
	 * <pre>
	 * flink.on('Connector:dblclick', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 直线<br>
	 * @class fishTopoFlow.link.Link
	 * @extends fishTopoFlow.link
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var link = fishTopoFlow.link;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       //节点
	 *       function newNode(x, y, w, h) {
	 *           var rect = new node.Rect({
	 *               shape: {width: w,height: h},
	 *               position: [x, y],
	 *               style: {fill: "#167CFF"}
	 *           });
	 *           fishTopo.add(rect);
	 *           return rect;
	 *       }
	 *       //简单连线
	 *       function newLink(startNode, endNode, text, dashedPattern) {
	 *           var slink = new link.Link(startNode, endNode, {
	 *               style: {lineDash: [dashedPattern]},
	 *               text: {text: text}
	 *           })
	 *           fishTopo.add(slink);
	 *           return slink;
	 *       }
	 *       var from = newNode(100, 60, 30, 30);
	 *       var to = newNode(300, 60, 30, 30);
	 *       newLink(from, to, '虚线带箭头', 5);
	 */
	
	    var Connector = __webpack_require__(82);
	    var Flow = __webpack_require__(119);
	
	    function Link(startNode,endNode,options) {
	        var opt = Flow.translateLinkOptions(options);
	        //默认就是直线
	        var connector = new Connector(opt);
	        connector.startNode = startNode;
	        connector.endNode = endNode;
	
	        return connector;
	    }
	    /**
	     * @method createByPoint
	     * 用户指定连线的点，来进行画线
	     * @param  {Object} options 线段选项
	     * @param {Object} [options.style] 节点的样式
	     * @param {Number} [options.style.lineWidth=1] 线段的宽度
	     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	     * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	     * @param {Object} [options.symbol] 线段的箭头
	     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]
	     * @param {Object} [options.text] 线段上的文字
	     * @param {String} [options.text.text] 线段上的文字内容
	     * @param {String} [options.text.color] 线段上的文字颜色
	     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {String} [options.position] 指定线段位置
	     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {Object} [options.position.startOffset] 线段开始位置的偏移
	     * @param {Object} [options.position.endOffset] 线段结束位置的偏移
	     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	     * @param {Object} [options.effect] 线上动态效果
	     * @param {String} [options.effect.show] 是否显示箭头动效
	     * @param {Number} [options.effect.period] 动效移动速度
	     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	     * @param {Number} [options.z] 连线的层级，越大越在前面显示
	     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)
	     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)
	     */
	    Link.createByPoint = function(options) {
	        var opt = Flow.translateLinkOptions(options);
	        //默认就是直线
	        var connector = new Connector(opt);
	        return connector;
	    }
	
	    module.exports = Link;
	
	


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Flow静态方法类
	 * @class fish.topo.FishTopoFlow.Flow
	 */
	
	
	    var Constants = __webpack_require__(93);
	    var GroupNode = __webpack_require__(95);
	    var Flow = {
	        FLOW_TYPE: "elementType",
	        LINK: "connection",
	        RECT: "Rect",
	        Group: 'Group',
	        IMAGE: 'Image',
	        TEXT: 'Text',
	        CIRCLE: 'Circle',
	        SECTOR: 'Sector',
	        RING: 'Ring',
	        POLYGON: 'Polygon',
	        POLYLINE: 'Polyline',
	        LINE: 'Line',
	        BEZIERCURVE: 'Beziercurve',
	        ARC: 'Arc',
	        SCENE:'scene',
	
	        /**
	         * @method setUserData
	         * 设置用户数据
	         * @param {Object} node 需要设置数据的节点
	         * @param {Object} obj 数据
	         * **使用范例**：
	         *
	         *      @example
	         *      //设置自定义数据
	         *      this.fishTopo.Flow.setUserData(rect, { customObj: "rect" });
	         */
	        setUserData: function(node, obj) {
	            node.model.set(Constants.USERDATA, obj);
	        },
	        /**
	         * 获取设置的用户数据
	         * @param {Object} node 需要获取数据的节点
	         * @return {String}      数据
	         * **使用范例**：
	         *
	         *      @example
	         *      //获取自定义数据
	         *      this.fishTopo.Flow.getUserData(rect);
	         */
	        getUserData: function(node) {
	            return node.model.get(Constants.USERDATA);
	        },
	        /**
	         * 判断是否是连线
	         * @param {Object} model 对象的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是连线
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isLink(nodeModel)) { return true;}
	         */
	        isLink: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType == Flow.LINK;
	        },
	        /**
	         * 判断是否是节点
	         * @param {Object} model 对象的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isNode(nodeModel)) { return true;}
	         */
	
	        isNode: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            var isNode;
	            if(elementType !=  Flow.LINK && elementType !=  Flow.SCENE){
	                isNode = true;
	            }else{
	                isNode = false;
	            }
	            return isNode;
	        },
	
	        isInGroup: function(node) {
	            return node.parent && node.parent instanceof GroupNode;
	        },
	
	        isGroupNode: function(node) {
	            return node instanceof GroupNode;
	        },
	
	        /**
	         * 判断节点是否是矩形节点
	         * @param {Object} model 节点的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是矩形节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isRect(nodeModel)) { return true;}
	         */
	        isRect: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return  elementType == Flow.RECT;
	        },
	        /**
	         * 判断节点是否是图片节点
	         * @param {Object} model 节点的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是图片节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isImage(nodeModel)) { return true;}
	         */
	        isImage: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType == Flow.IMAGE;
	        },
	        /**
	         * 判断节点是否是文字节点
	         * @param {Object} model 节点的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是文字节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isText(nodeModel)) { return true;}
	         */
	        isText: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType == Flow.TEXT;
	        },
	        /**
	         * 判断节点是否是圆形节点
	         * @param {Object} model 节点的model
	         * @return {Boolean}      是 否
	         * **使用范例**：
	         *
	         *      @example
	         *      //判断是否是圆形节点
	         *      var nodeModel = e.target.model;
	         *      if (this.fishTopo.Flow.isCircle(nodeModel)) { return true;}
	         */
	        isCircle: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType == Flow.CIRCLE;
	        },
	        /**
	         * 获取节点的类型
	         * @param {Object} model 节点的model
	         * **使用范例**：
	         *
	         *      @example
	         *      //获取节点类型
	         *      var nodeModel = e.target.model;
	         *      return this.fishTopo.Flow.getType(nodeModel);
	         */
	        getType: function(model) {
	            var elementType = model.get(Flow.FLOW_TYPE);
	            return elementType;
	        },
	        translateLinkOptions: function(options) {
	            if (options && options.pos) {
	                var arrPos = options.pos.split(",");
	                if (arrPos.length >= 2) {
	                    if (!options.position) {
	                        options.position = {};
	                    }
	                    options.position.startPos = arrPos[0];
	                    options.position.endPos = arrPos[1];
	                }
	            }
	            return options;
	        }
	    };
	
	    module.exports = Flow;
	


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 折线<br>
	 * @class fishTopoFlow.link.Fold
	 * @extends fishTopoFlow.link
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var link = fishTopoFlow.link;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       //节点
	 *       function newNode(x, y, w, h) {
	 *           var rect = new node.Rect({
	 *               shape: {width: w,height: h},
	 *               position: [x, y],
	 *               style: {fill: "#167CFF"}
	 *           });
	 *           fishTopo.add(rect);
	 *           return rect;
	 *       }
	 *       //折线
	 *       function newFoldLink(startNode, endNode, text, direction, dashedPattern) {
	 *           var flink = new link.Fold(startNode, endNode, {
	 *               style: {lineDash: [dashedPattern]},
	 *               text: {text: text},
	 *               pos: direction
	 *           })
	 *           fishTopo.add(flink);
	 *           return flink;
	 *       }
	 *       var from = newNode(100, 40, 30, 30);
	 *       var to = newNode(300, 80, 30, 30);
	 *       newFoldLink(from, to, '折线');
	 */
	
	    var Connector = __webpack_require__(82);
	    var zrUtil = __webpack_require__(5);
	    var Flow = __webpack_require__(119);
	
	    function Fold(startNode,endNode,options) {
	        //折线
	        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_JAGGED}}, options, true);
	        opt = Flow.translateLinkOptions(opt);
	        var connector = new Connector(opt);
	        connector.startNode = startNode;
	        connector.endNode = endNode;
	
	        return connector;
	    }
	
	    /**
	     * @method createByPoint
	     * 用户指定连线的点，来进行画线
	     * @param  {Object} options 线段选项
	     * @param {Object} [options.style] 节点的样式
	     * @param {Number} [options.style.lineWidth=1] 线段的宽度
	     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	     * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	     * @param {Object} [options.symbol] 线段的箭头
	     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]
	     * @param {Object} [options.text] 线段上的文字
	     * @param {String} [options.text.text] 线段上的文字内容
	     * @param {String} [options.text.color] 线段上的文字颜色
	     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {String} [options.position] 指定线段位置
	     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {Object} [options.position.startOffset] 线段开始位置的偏移
	     * @param {Object} [options.position.endOffset] 线段结束位置的偏移
	     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	     * @param {Object} [options.effect] 线上动态效果
	     * @param {String} [options.effect.show] 是否显示箭头动效
	     * @param {Number} [options.effect.period] 动效移动速度
	     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	     * @param {Number} [options.z] 连线的层级，越大越在前面显示
	     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)
	     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)
	     */
	    Fold.createByPoint = function(options) {
	        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_JAGGED}}, options, true);
	        opt = Flow.translateLinkOptions(opt);
	        var connector = new Connector(opt);
	        return connector;
	    }
	    module.exports = Fold;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 曲线<br>
	 * @class fishTopoFlow.link.Curve
	 * @extends fishTopoFlow.link
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var link = fishTopoFlow.link;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       //节点
	 *       function newNode(x, y, w, h) {
	 *           var rect = new node.Rect({
	 *               shape: {width: w,height: h},
	 *               position: [x, y],
	 *               style: {fill: "#167CFF"}
	 *           });
	 *           fishTopo.add(rect);
	 *           return rect;
	 *       }
	 *       //曲线
	 *       function newCurveLink(startNode, endNode, text, direction, dashedPattern) {
	 *           var clink = new link.Curve(startNode, endNode, {
	 *               style: {lineDash: [dashedPattern]},
	 *               text: {text: text},
	 *               pos: direction
	 *           })
	 *           fishTopo.add(clink);
	 *           return clink;
	 *       }
	 *       var from = newNode(100, 40, 30, 30);
	 *       var to = newNode(300, 80, 30, 30);
	 *       newCurveLink(from, to, '曲线');
	 */
	
	    var Connector = __webpack_require__(82);
	    var zrUtil = __webpack_require__(5);
	    var Flow = __webpack_require__(119);
	    function Curve(startNode,endNode,options) {
	        //曲线
	        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_CURVE}}, options, true);
	        opt = Flow.translateLinkOptions(opt);
	
	        var connector = new Connector(opt);
	        connector.startNode = startNode;
	        connector.endNode = endNode;
	
	        return connector;
	    }
	    /**
	     * @method createByPoint
	     * 用户指定连线的点，来进行画线
	     * @param  {Object} options 线段选项
	     * @param {Object} [options.style] 节点的样式
	     * @param {Number} [options.style.lineWidth=1] 线段的宽度
	     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'
	     * @param {String} [options.style.stroke="#000000"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'
	     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]
	     * @param {Object} [options.symbol] 线段的箭头
	     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'
	     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸
	     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色
	     * @param {String} [options.symbol.z] [箭头的层级，越大越在前面显示]
	     * @param {Boolean} [options.symbol.both] [指定是否在连线的首与尾都画箭头 默认是false]
	     * @param {Object} [options.text] 线段上的文字
	     * @param {String} [options.text.text] 线段上的文字内容
	     * @param {String} [options.text.color] 线段上的文字颜色
	     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center
	     * @param {Number|Array} [options.text.offset] 文字位置偏移量,为number则是x偏移 array则为[x,y]
	     * @param {String} [options.pos] 保留 请使用options.position.direction 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {String} [options.position] 指定线段位置
	     * @param {Object} [options.position.direction] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 "left+10,top"
	     * @param {Object} [options.position.startOffset] 线段开始位置的偏移
	     * @param {Object} [options.position.endOffset] 线段结束位置的偏移
	     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度，默认值为[30, 30]
	     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组，首尾可以使用left,right,top,bottom
	     * @param {Object} [options.effect] 线上动态效果
	     * @param {String} [options.effect.show] 是否显示箭头动效
	     * @param {Number} [options.effect.period] 动效移动速度
	     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase
	     * @param {Number} [options.z] 连线的层级，越大越在前面显示
	     * @param {Number} [options.bundleOffset=30] 拆线拐角处的长度(用于连线组)
	     * @param {Number} [options.bundleGap=20] 多线段的间隔(用于连线组)
	     */
	    Curve.createByPoint = function(options) {
	        var opt = zrUtil.merge({style:{lineType: Connector.TYPE_CURVE}}, options, true);
	        opt = Flow.translateLinkOptions(opt);
	        var connector = new Connector(opt);
	        return connector;
	    }
	    module.exports = Curve;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 连线操作类
	 * @author miao.cunzhi
	 */
	
	    var symbolUtil = __webpack_require__(83);
	    var zrUtil = __webpack_require__(5);
	    var icon = __webpack_require__(89);
	    function LineOperationManager(connectionManager, api) {
	        this.lineOperations = [],
	        this.isEdit = true;
	        this.connectionManager = connectionManager;
	        this._api = api;
	    }
	
	    /**
	     *  this.lineOperationManager.addIcon(key, options);
	     */
	    LineOperationManager.prototype.addIcon = function(key, options) {
	        //判断是小图标否存在 ，存在则直接返回
	        var lineOperationIcon = zrUtil.find(options.lineNode.icons, function(icon) {
	            return icon.key === key;
	        });
	
	        if (lineOperationIcon) {
	            this.bindOperation(options.lineNode);
	            return;
	        }else {
	            var lineOperation = this.creatOperation(key, options);
	            this._api._getParentZr().add(lineOperation);
	            this.bindOperation(options.lineNode);
	            return lineOperation;
	        }
	    }
	
	
	    LineOperationManager.prototype.creatOperation = function(key, options) {
	        var lineOperation = symbolUtil.createSymbol(options.iconPath, 0, 0, options.width || 15, options.height || 15, 0, options.color||'#000');
	        lineOperation.key = key;
	        lineOperation._width =  options.width || 15;  // path情况下无法计算
	        lineOperation._isLineOperationIcon = true;
	        lineOperation.hide();
	        options.lineNode.icons.push(lineOperation);
	        this.lineOperations.push(lineOperation);
	
	        //小图标 点击事件  如果有回调则调用回调，否则派发事件
	        lineOperation.on("click", function(event) {
	            if (options.callback) {
	                event.data = options;
	                event.lineNode = options.lineNode;
	                options.callback(event);
	            } else {
	                var params = {};
	                params.event = event;
	                params.type = "click";
	                params.elementType = "LineOperationIcon";
	                this._api.trigger(params.type, params);
	            }
	        }.bind(this));
	        return lineOperation;
	    }
	
	    /**
	     * 计算小图标的位置，并显示
	     * @param  {[type]} connector [description]
	     * @return {[type]}           [description]
	     */
	    LineOperationManager.prototype.bindOperation = function(connector) {
	        if (this.isEdit == false) {
	            return;
	        }
	        var pointPosition = connector.middle();
	
	        var arrLength = zrUtil.map(connector.icons, function(icon) {
	            return icon._width;
	        });
	
	        var totalLength = zrUtil.reduce(arrLength, function(previousValue,currentValue) {
	            return previousValue + currentValue + 10;
	        }, 0 );
	
	        zrUtil.each(connector.icons, function(icon, index) {
	            var connectorPosition = 0;
	            for (var k = 0; k < index; k++) {
	                connectorPosition += arrLength[k] + 10;
	            }
	            icon.attr("position", [pointPosition[0] + connectorPosition - totalLength / 2, pointPosition[1] + 5]);
	            icon.show();
	            icon.attachLine = connector;
	        })
	    }
	
	    LineOperationManager.prototype.hideAllLineOperation = function() {
	        zrUtil.each(this.lineOperations, function(lineOperation) {
	            lineOperation.hide();
	        });
	    }
	
	    LineOperationManager.prototype.addDeleteIcon = function(lineNode,options) {
	        var opts = zrUtil.defaults({
	            iconPath: 'image://' + icon.DEL_IMG,
	            width: 12,
	            height: 14,
	            lineNode: lineNode,
	            callback: function(e) {
	                this._api.remove(e.target.attachLine);//this.connectionManager.selConnector);
	            }.bind(this)
	        }, options,true);
	
	        this.addIcon("delete", opts);
	    }
	
	    LineOperationManager.prototype.addChangeLineTypeIcon = function(lineNode,options) {
	        var opts = zrUtil.defaults({
	            iconPath: 'image://' + icon.CHANGE_LINE_TYPE_IMG,
	            width: 15,
	            height: 15,
	            lineNode: lineNode,
	            callback: function () {
	                this._api.changeSelectConnectorType();
	            }.bind(this)
	        }, options,true);
	
	        this.addIcon("change", opts)
	    }
	
	    module.exports = LineOperationManager;
	


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * fishTopoFlow的layout对象，框架提供的布局都放在这个对象下。通过addCustomLayout方法添加自定义布局
	 * @class fishTopoFlow.layout
	 * @abstract
	 */
	
	    var BoundingRect = __webpack_require__(27);
	    var zrUtil = __webpack_require__(5);
	    var flowUtil = __webpack_require__(94);
	    var HLayout = __webpack_require__(124);
	    var VLayout = __webpack_require__(125);
	    var TreeLayout = __webpack_require__(126);
	    var ForceLayout = __webpack_require__(129);
	    var parsePercent = flowUtil.parsePercent;
	    var Tree = __webpack_require__(127);
	    var layout = {};
	    layout.HLayout = HLayout;
	    layout.VLayout = VLayout;
	    layout.TreeLayout = TreeLayout;
	    layout.ForceLayout = ForceLayout;
	    layout.Tree = Tree
	
	    /**
	     * @method addCustomLayout
	     * 添加自定义布局类
	     * @param {Object} customLayout 自定义布局的类
	     */
	    layout.addCustomLayout = function(customLayout) {
	        layout.customLayout = customLayout;
	    }
	
	
	    layout.getLayoutRect = function (positionInfo, containerRect, margin) {
	        margin = flowUtil.normalizeCssArray(margin || 0);
	
	        var containerWidth = containerRect.width;
	        var containerHeight = containerRect.height;
	
	        var left = parsePercent(positionInfo.left, containerWidth);
	        var top = parsePercent(positionInfo.top, containerHeight);
	        var right = parsePercent(positionInfo.right, containerWidth);
	        var bottom = parsePercent(positionInfo.bottom, containerHeight);
	        var width = parsePercent(positionInfo.width, containerWidth);
	        var height = parsePercent(positionInfo.height, containerHeight);
	
	        var verticalMargin = margin[2] + margin[0];
	        var horizontalMargin = margin[1] + margin[3];
	        var aspect = positionInfo.aspect;
	
	        // If width is not specified, calculate width from left and right
	        if (isNaN(width)) {
	            width = containerWidth - right - horizontalMargin - left;
	        }
	        if (isNaN(height)) {
	            height = containerHeight - bottom - verticalMargin - top;
	        }
	
	        // If width and height are not given
	        // 1. Graph should not exceeds the container
	        // 2. Aspect must be keeped
	        // 3. Graph should take the space as more as possible
	        if (isNaN(width) && isNaN(height)) {
	            if (aspect > containerWidth / containerHeight) {
	                width = containerWidth * 0.8;
	            }
	            else {
	                height = containerHeight * 0.8;
	            }
	        }
	
	        if (aspect != null) {
	            // Calculate width or height with given aspect
	            if (isNaN(width)) {
	                width = aspect * height;
	            }
	            if (isNaN(height)) {
	                height = width / aspect;
	            }
	        }
	
	        // If left is not specified, calculate left from right and width
	        if (isNaN(left)) {
	            left = containerWidth - right - width - horizontalMargin;
	        }
	        if (isNaN(top)) {
	            top = containerHeight - bottom - height - verticalMargin;
	        }
	
	        // Align left and top
	        switch (positionInfo.left || positionInfo.right) {
	            case 'center':
	                left = containerWidth / 2 - width / 2 - margin[3];
	                break;
	            case 'right':
	                left = containerWidth - width - horizontalMargin;
	                break;
	        }
	        switch (positionInfo.top || positionInfo.bottom) {
	            case 'middle':
	            case 'center':
	                top = containerHeight / 2 - height / 2 - margin[0];
	                break;
	            case 'bottom':
	                top = containerHeight - height - verticalMargin;
	                break;
	        }
	        // If something is wrong and left, top, width, height are calculated as NaN
	        left = left || 0;
	        top = top || 0;
	        if (isNaN(width)) {
	            // Width may be NaN if only one value is given except width
	            width = containerWidth - left - (right || 0);
	        }
	        if (isNaN(height)) {
	            // Height may be NaN if only one value is given except height
	            height = containerHeight - top - (bottom || 0);
	        }
	
	        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);
	        rect.margin = margin;
	        return rect;
	    };
	
	
	    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {
	        var h = !opt || !opt.hv || opt.hv[0];
	        var v = !opt || !opt.hv || opt.hv[1];
	        var boundingMode = opt && opt.boundingMode || 'all';
	
	        if (!h && !v) {
	            return;
	        }
	
	        var rect;
	        if (boundingMode === 'raw') {
	            rect = (el.type === 'group' || el.type === 'GroupNode')
	                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)
	                : el.getBoundingRect();
	        }
	        else {
	            rect = el.getBoundingRect();
	            if (el.needLocalTransform()) {
	                var transform = el.getLocalTransform();
	                // Notice: raw rect may be inner object of el,
	                // which should not be modified.
	                rect = rect.clone();
	                rect.applyTransform(transform);
	            }
	        }
	
	        positionInfo = layout.getLayoutRect(
	            zrUtil.defaults(
	                {width: rect.width, height: rect.height},
	                positionInfo
	            ),
	            containerRect,
	            margin
	        );
	
	        // Because 'tranlate' is the last step in transform
	        // (see zrender/core/Transformable#getLocalTransfrom),
	        // we can just only modify el.position to get final result.
	        var elPos = el.position;
	        var dx = h ? positionInfo.x - rect.x : 0;
	        var dy = v ? positionInfo.y - rect.y : 0;
	
	        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);
	    };
	
	
	    module.exports = layout;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 水平布局<br>
	 * @class fishTopoFlow.layout.HLayout
	 * @extends fishTopoFlow.layout
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var layout = fishTopoFlow.layout;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       function newNode(group,text) {
	 *           var rect = new node.Rect({
	 *                   shape:{width:25,height:25},
	 *                   style: {text:text,fill: "#167CFF"}
	 *               });
	 *           group.add(rect);
	 *           return rect;
	 *       }
	 *       var hGroup =  new node.Group({
	 *           style: {
	 *               text: "水平布局",
	 *               textPosition:"bottom"
	 *           },
	 *           position:[50,50],
	 *           layout : new layout.HLayout({gap:10})
	 *       });
	 *       newNode(hGroup, "A_1")
	 *       newNode(hGroup, "A_2");
	 *       newNode(hGroup, "A_3");
	 *       newNode(hGroup, "A_4");
	 *       newNode(hGroup, "A_5");
	 *       fishTopo.add(hGroup);
	 */
	
	            var zrUtil = __webpack_require__(5);
	             var Connector = __webpack_require__(82);
	            function HLayout(opts) {
	                /**
	                 * @cfg {Number} gap 节点之间的间隔
	                 */
	                /**
	                 * @cfg {Number} maxHeight=Infinity 组最大的宽度，如果超过会换行
	                 */
	                var defaultOptions = {
	                    gap: 5,
	                    maxWidth: Infinity
	                };
	                this.options = zrUtil.merge(defaultOptions, opts, true);
	            }
	            /**
	             * @method run
	             * 进行垂直布局，一般不需要调用，直接将布局类 赋值给组layout 属性即可
	             * @param {Object} group 需要进行垂直布局的组
	             */
	            HLayout.prototype.run = function(group)  {
	                var x = 0;
	                var y = 0;
	                var currentLineMaxSize = 0;
	                group.each(function (child, idx) {
	                    if (child instanceof Connector) {
	                        return;
	                    }
	
	                    var position = child.position;
	                    var rect = child.getBoundingRect();
	                    var nextChild = group.childAt(idx + 1);
	                    var nextChildRect = nextChild && nextChild.getBoundingRect();
	                    var nextX;
	
	                    var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);
	                    nextX = x + moveX;
	                    // Wrap when width exceeds maxWidth or meet a `newline` group
	                    if (nextX > this.options.maxWidth || child.newline) {
	                        x = 0;
	                        nextX = moveX;
	                        y += currentLineMaxSize + parseInt(this.options.gap,10);
	                        currentLineMaxSize = rect.height;
	                    } else {
	                        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
	                    }
	
	                    if (child.newline) {
	                        return;
	                    }
	
	                    position[0] = x;
	                    position[1] = y;
	                    x = nextX + this.options.gap;
	                },this);
	
	                return HLayout;
	            }
	        module.exports = HLayout;
	
	/**
	 * @method addCustomLayout
	 * @hide
	 */

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 垂直布局<br>
	 * @class fishTopoFlow.layout.VLayout
	 * @extends fishTopoFlow.layout
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var layout = fishTopoFlow.layout;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       function newNode(group,text) {
	 *           var rect = new node.Rect({
	 *                   shape:{width:25,height:25},
	 *                   style: {text:text,fill: "#167CFF"}
	 *               });
	 *           group.add(rect);
	 *           return rect;
	 *       }
	 *       var vGroup =  new node.Group({
	 *           style: {
	 *               text: "垂直布局",
	 *               textPosition:"bottom"
	 *           },
	 *           position:[60,60],
	 *           layout : new layout.VLayout({gap:10})
	 *       });
	*
	 *       newNode(vGroup, "A_1")
	 *       newNode(vGroup, "A_2");
	 *       newNode(vGroup, "A_3");
	 *       newNode(vGroup, "A_4");
	 *       newNode(vGroup, "A_5");
	 *       fishTopo.add(vGroup);
	 */
	
	            var zrUtil = __webpack_require__(5);
	            var Connector = __webpack_require__(82);
	            function VLayout(opts) {
	                /**
	                 * @cfg {Number} gap 节点之间的间隔
	                 */
	                /**
	                 * @cfg {Number} maxHeight=Infinity 组最大的高度，如果超过会换行
	                 */
	                var defaultOptions = {
	                    gap: 5,
	                    maxHeight: Infinity
	                };
	                this.options = zrUtil.merge(defaultOptions, opts, true);
	            }
	
	            /**
	             * @method run
	             * 进行垂直布局，一般不需要调用，直接将布局类 赋值给组layout 属性即可
	             * @param {Object} group 需要进行垂直布局的组
	             */
	            VLayout.prototype.run = function(group)  {
	                var x = 0;
	                var y = 0;
	                var currentLineMaxSize = 0;
	                group.each(function (child, idx) {
	                    if (child instanceof Connector) {
	                        return;
	                    }
	
	                    var position = child.position;
	                    var rect = child.getBoundingRect();
	                    var nextChild = group.childAt(idx + 1);
	                    var nextChildRect = nextChild && nextChild.getBoundingRect();
	                    var nextY;
	
	                    var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);
	                    nextY = y + moveY;
	                    // Wrap when width exceeds maxHeight or meet a `newline` group
	                    if (nextY > this.options.maxHeight || child.newline) {
	                        x += currentLineMaxSize + parseInt(this.options.gap,10);
	                        y = 0;
	                        nextY = moveY;
	                        currentLineMaxSize = rect.width;
	                    }
	                    else {
	                        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
	                    }
	
	                    if (child.newline) {
	                        return;
	                    }
	
	                    position[0] = x;
	                    position[1] = y;
	                    y = nextY + this.options.gap;
	                },this);
	
	                return VLayout;
	            }
	        module.exports = VLayout;
	
	
	/**
	 * @method addCustomLayout
	 * @hide
	 */

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 树布局<br>
	 * @class fishTopoFlow.layout.TreeLayout
	 * @extends fishTopoFlow.layout
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var layout = fishTopoFlow.layout;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"));
	 *       function newNode(data) {
	 *           var circle = new node.Circle({
	 *               shape: { r: 15 },
	 *               style: { fill: "#4883b4" },
	 *               name: data.name
	 *           });
	 *           return circle;
	 *       }
	 *       var options = {
	 *           createNodeFunction: newNode,
	 *           data:[{
	 *               name: '根节点',
	 *               children: [
	 *                   {   name: '节点1',
	 *                       children: [
	 *                           {name: '叶子节点1'},
	 *                           {name: '叶子节点2'},
	 *                           {name: '叶子节点3'},
	 *                           {name: '叶子节点4'},
	 *                           {name: '叶子节点5'},
	 *                           {name: '叶子节点6'}
	 *                       ]
	 *                   },
	 *                   {   name: '节点2',
	 *                       children: [
	 *                           {name: '叶子节点7'},
	 *                           {name: '叶子节点8'}]
	 *                   },
	 *                   {   name: '节点3',
	 *                       children: [
	 *                           {name: '叶子节点9'},
	 *                           {name: '叶子节点10'},
	 *                           {name: '叶子节点11'},
	 *                           {name: '叶子节点12'}
	 *                       ]
	 *                   }
	 *               ]
	 *           }]
	 *       }
	*
	 *       var treeLayout = new layout.TreeLayout({
	 *           fishTopo:fishTopo,
	 *           rootLocation:{x:'center', y:50},
	 *           nodePadding:1
	 *       });
	 *       treeLayout.doLayout(options);
	 */
	
	            var zrUtil = __webpack_require__(5);
	            var BoundingRect = __webpack_require__(27);
	            var flowUtil = __webpack_require__(94);
	            var parsePercent = flowUtil.parsePercent;
	            var TreeData = __webpack_require__(127);  // 数据依赖
	            var TreeHelper = __webpack_require__(128); // 布局依赖
	            function TreeLayout(opts) {
	                /**
	                 * @cfg {Object} fishTopo fishTopo实例
	                 */
	                /**
	                 * @cfg {Object} rootLocation 根节点坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number
	                 * @cfg {Number|String} rootLocation.x  根节点横坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number
	                 * @cfg {Number|String} rootLocation.y  根节点纵坐标，支持绝对值（px）、字符和百分比 'center' | 'left' | 'right' | 'x%' | number
	                 */
	                /**
	                 * @cfg {Number} layerPadding=100 层间距,默认:100
	                 */
	                /**
	                 * @cfg {Number} nodePadding=30 节点间距,默认:30
	                 */
	                /**
	                 *@cfg {String} direction 树的方向可选：'vertical' | 'horizontal' ,默认:vertical
	                 */
	                /**
	                 * @cfg {Object} lineStyle 连线的样式  参见{@link fishTopoFlow.link#constructor 构造函数options参数}
	                 */
	                var defaultOptions = {
	                    orient:'vertical',  // vertical,horizontal
	                    nodePadding:30, //节点间距
	                    layerPadding:100,  //层间距
	                    rootLocation: {x:100, y:230}, // 根节点坐标，支持绝对值（px）、字符和百分比
	                    animateTime : 500,
	                    lineStyle: {pos:'bottom,top', symbol:{type:'none'}}
	                };
	                if (opts.orient === 'horizontal') {
	                    defaultOptions.lineStyle.pos = 'right,left';
	                }
	
	                this.options = zrUtil.defaults(defaultOptions, opts, true);
	                this.nodePadding = this.options.nodePadding;
	                this.layerPadding = this.options.layerPadding;
	                this.fishTopo = this.options.fishTopo;
	                this._layerOffsets = [];
	                this._layers = [];
	                this._hideNodes = [];
	            }
	
	            /**
	             * @method layoutByRootNode
	             * 根据根节点及连线的关系 ，生成树
	             * @param {Object} rootNode 树的根节点
	             * @return {Object} boundingbox 包围和
	             */
	            TreeLayout.prototype.layoutByRootNode = function(rootNode) {
	                var connectors = this.fishTopo.connectionManager.connectors;  //所有线段的数组
	                //递归生成树型数据结构
	                function traverseNode(parentNode, treeData) {
	                    var childrenData = [];
	                    var childrenNode = [];
	                    //1.根据连线，找出起始节点的所有子节点
	                    zrUtil.each(connectors, function(connector) {
	                        if(connector.startNode === parentNode) {
	                            if(!connector.endNode.exclude) {   //如果是排斥的节点则不加入
	                                childrenNode.push(connector.endNode);
	                            }
	                        }
	                    })
	
	                    if (childrenNode.length > 0) {
	                        //2.遍历子节点
	                        zrUtil.each(childrenNode, function(node) {
	                             var nodeData = {name: node.id, node:node};
	                             childrenData.push(nodeData);
	                             traverseNode(node, nodeData);
	                        })
	                    }
	                    //3.将子节点放入children中
	                    if (childrenData.length > 0) {
	                        treeData.children = childrenData;
	                    }
	                }
	                var rootTreeData = {name: rootNode.id, node:rootNode};
	                traverseNode(rootNode,rootTreeData);
	                return this.doLayout({data:[rootTreeData]}, true);
	            }
	
	            /**
	             * @method doLayout
	             * 根据传过来树型结构数据进行树布局
	             * @param {Object} treeData 树形数据
	             * @param {Function} treeData.createNodeFunction=null 创建节点的函数 会把data中的数据 传递过去  如果没有默认就是创建圆形
	             * @param {Object} treeData.data 创建树布局数据（必须包括name属性）
	             * @param {boolean} isNotBuildLink=true 默认是自动创建连线，传true则不会自动创建连线
	             * @return {Object} boundingbox 包围和
	             */
	            TreeLayout.prototype.doLayout = function(treeData, isNotBuildLink)  {
	                var rootData = treeData.data[0];
	                this.treeData = treeData;
	
	                this.tree = TreeData.fromOptionData(rootData.name, rootData.children);
	                this.tree.root.data = rootData;
	
	
	                this._buildNode(treeData);
	
	                //根据root坐标 方向 对每个节点的坐标进行映射
	                this._setTreeShape(function() {
	                    this._buildAllLink(isNotBuildLink);
	                }.bind(this));
	
	                return this.getBoundingRect();
	            }
	
	            /**
	             * @private
	             * @method _buildAllLink
	             * 递归画出连接线 与设置节点坐标
	             */
	             TreeLayout.prototype._buildAllLink = function (isNotBuildLink) {
	                this.tree.traverse(function(treeNode) {
	                    //画连接线
	                    if (treeNode.children.length > 0 && !isNotBuildLink) {
	                        this._buildLinkByParent(treeNode, this.treeData.createLinkFunction)
	                    } else {
	                        this.fishTopo.connectionManager.refreshLineByNode(treeNode.data.node);
	                    }
	                },this)
	             }
	
	
	            /**
	             * @method getBoundingRect
	             * 计算出树的包围和
	             * @return {Object} boundingbox 包围和
	             */
	            TreeLayout.prototype.getBoundingRect = function() {
	                var rect = null;
	                this.tree.traverse(function(treeNode) {
	                    var childRect = BoundingRect.create({x:treeNode.layout.position[0], y:treeNode.layout.position[1], width:treeNode.layout.width, height: treeNode.layout.height});
	                    if (!rect) rect = childRect.clone();
	                    rect.union(childRect);
	                },this)
	                return rect;
	            }
	
	
	
	            TreeLayout.prototype._setTreeShape = function(doneCallback) {
	                var animateCount = 0;
	                var treeHelper = new TreeHelper(
	                    {
	                        nodePadding: this.nodePadding,
	                        layerPadding: this.layerPadding
	                    }
	                );
	
	
	                this.tree.traverse(function(treeNode) {
	                    if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){
	                        var boundingRect = treeNode.data.node.getBoundingRect();
	                        treeNode.layout = {
	                            width: treeNode.data.node._width || boundingRect.width,
	                            height: treeNode.data.node._height || boundingRect.height
	                        }
	                    }
	
	                },this);
	                treeHelper._hideNodes = this._hideNodes;
	                treeHelper.run(this.tree);
	                // 树的方向
	                var orient = this.options.orient;
	                var rootX = this.options.rootLocation.x;
	                var rootY = this.options.rootLocation.y;
	                var zrWidth = this.fishTopo.getWidth();
	                var zrHeight = this.fishTopo.getHeight();
	                if (rootX === 'center') {
	                    rootX = zrWidth * 0.5;
	                }
	                else {
	                    rootX = parsePercent(rootX, zrWidth);
	                }
	                if (rootY === 'center') {
	                    rootY = zrHeight * 0.5;
	                }
	                else {
	                    rootY = parsePercent(rootY, zrHeight);
	                }
	                rootY = parsePercent(rootY, zrHeight);
	                // 水平树
	                if (orient === 'horizontal') {
	                    rootX = isNaN(rootX) ? 10 : rootX;
	                    rootY = isNaN(rootY) ? zrHeight * 0.5 : rootY;
	                }
	                // 纵向树
	                else {
	                    rootX = isNaN(rootX) ? zrWidth * 0.5 : rootX;
	                    rootY = isNaN(rootY) ? 10 : rootY;
	                }
	                // tree layout自动算出来的root的坐标
	                var originRootX = this.tree.root.layout.position[0];
	
	                var treeNodeCount = treeHelper.count(this.tree) - this._hideNodes.length;
	                var minY = Infinity;
	
	                this.tree.traverse(
	                    function (treeNode) {
	                        var x;
	                        var y;
	                        if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){
	                            if (orient === 'vertical' && this.options.direction === 'inverse') {
	                                x = treeNode.layout.position[0] - originRootX + rootX;
	                                y = rootY - treeNode.layout.position[1];
	                            }
	                            else if (orient === 'vertical') {
	                                x = treeNode.layout.position[0] - originRootX + rootX;
	                                y = treeNode.layout.position[1] + rootY;
	                            }
	                            else if (orient === 'horizontal' && this.options.direction === 'inverse') {
	                                y = treeNode.layout.position[0] - originRootX + rootY;
	                                x = rootX - treeNode.layout.position[1];
	                            }
	                            else if (orient === 'horizontal') {
	                                y = treeNode.layout.position[0] - originRootX + rootY;
	                                x = treeNode.layout.position[1] + rootX;
	                            }
	                            treeNode.layout.__x = x;
	                            treeNode.layout.__y = y;
	                            if (y < minY) {
	                                minY = y;
	                            }
	                        }
	                    },
	                    this
	                );
	
	                this.tree.traverse(function (treeNode) {
	                    if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){
	                        if (minY > 0) {
	                            treeNode.layout.position[0] = treeNode.layout.__x;
	                            treeNode.layout.position[1] = treeNode.layout.__y;
	                        } else  {
	                            treeNode.layout.position[0] = treeNode.layout.__x;
	                            treeNode.layout.position[1] = treeNode.layout.__y - minY;
	                        }
	
	                        treeNode.data.node.animateTo({
	                            position: [treeNode.layout.position[0], treeNode.layout.position[1]]
	                        }, this.options.animateTime, function() {
	                            if (++animateCount === treeNodeCount) {
	                                doneCallback();
	                            }
	                        }.bind(this));
	                        //节点有孩子才显示 收缩按钮
	                        if(this._hideNodes.length == 0){
	                            if (treeNode.children.length > 0 && treeNode.data.node._toggleShrink) {
	                                treeNode.data.node._toggleShrink(true);
	                            }
	                        }
	                    }
	
	                },this)
	            }
	
	            TreeLayout.prototype._buildNode = function(treeData) {
	                if(!treeData.createNodeFunction) {
	                    treeData.createNodeFunction = this._defaultCreateNodeFunction;
	                }
	                //判断一下是否有node 如果没有则自己创建
	                this.tree.traverse(function(treeNode) {
	                    if(!treeNode.data.node) {
	                        var createNodeFunction = treeNode.data.createNodeFunction || treeData.createNodeFunction;
	                        var node = createNodeFunction(treeNode.data, this);
	                        node._childShow = true;
	                        this.fishTopo.add(node);
	                        treeNode.data.node = node;
	                    }
	                },this);
	            }
	
	            TreeLayout.prototype._defaultCreateNodeFunction = function(item) {
	                var circle = this.fishTopo.createNode("Circle",{
	                    shape: { r: 15 },
	                    style: { fill: "#4883b4" },
	                    name: item.lable || item.name
	                });
	                return circle;
	            }
	
	            TreeLayout.prototype._buildLinkByParent = function (parentTreeNode, createLinkFunction) {
	                for (var i = 0, childLength = parentTreeNode.children.length; i < childLength; i++) {
	                    this._buildLink(parentTreeNode, parentTreeNode.children[i], createLinkFunction);
	                }
	            };
	
	
	            TreeLayout.prototype._buildLink = function (startTreeNode, endTreeNode, createLinkFunction) {
	                    var connector = null;
	                    var startNode = startTreeNode.data.node;
	                    var endNode = endTreeNode.data.node;
	                    if(createLinkFunction) {
	                        var paramObj =  endTreeNode.data;
	                        paramObj.startNode = startNode;
	                        paramObj.endNode = endNode;
	                        connector = createLinkFunction(paramObj);
	                    } else {
	                        var linkStyle = this.options.lineStyle;
	                        if (endTreeNode.data.lineStyle) {
	                            linkStyle = zrUtil.merge(zrUtil.clone(linkStyle), endTreeNode.data.lineStyle, true);
	                        }
	                        connector = this.fishTopo.createLink(startNode,endNode,linkStyle)
	                    }
	                    this.fishTopo.add(connector);
	            };
	
	
	            TreeLayout.prototype.addChild = function (treeNode, data, callback) {
	                var newTreeNode = (new TreeData(data.name)).root;
	                newTreeNode.data = data;
	
	                var node = this.treeData.createNodeFunction(newTreeNode.data, this);
	                node._childShow = true;
	                if (treeNode.children.length >= 1) {
	                    node.attr('position', zrUtil.clone(treeNode.children[treeNode.children.length - 1].layout.position));
	                } else {
	                    node.attr('position', zrUtil.clone(treeNode.layout.position));
	                }
	
	                this.fishTopo.add(node);
	                newTreeNode.data.node = node;
	                setTimeout(function () {
	                    this._buildLink(treeNode, newTreeNode, this.treeData.createLinkFunction);
	                }.bind(this), this.options.animateTime);
	
	                treeNode.add(newTreeNode);
	                this.refreshPositionAndLine(callback);
	                return node;
	            };
	
	            TreeLayout.prototype.toggleChild = function (node) {
	                var toggleTreeNode = this.findTreeNodeByNode(node);
	                if (node._childShow) {
	                    toggleTreeNode.traverse(function (treeNode) {
	                        if (treeNode.data.node !== node) {
	                            treeNode.data.node.hide();
	                            if(zrUtil.indexOf(this._hideNodes, treeNode) == -1){
	                                this._hideNodes.push(treeNode);
	                            }
	                            this.fishTopo.connectionManager.toggleLineByNode(treeNode.data.node, false);
	                            if (treeNode.children.length > 0) {
	                                treeNode.data.node._childShow = false;
	                                treeNode.data.node._toggleShrink && treeNode.data.node._toggleShrink(false);
	                            }
	                        }
	                    },this);
	                    node._childShow = false;
	                    node._toggleShrink && node._toggleShrink(false);
	                    this.refreshPositionAndLine();
	                } else {
	                    toggleTreeNode.traverse(function (treeNode) {
	                        if (treeNode.data.node !== node) {
	                            treeNode.data.node.show();
	                            this._hideNodes.splice(zrUtil.indexOf(this._hideNodes, treeNode),1);
	                            this.fishTopo.connectionManager.toggleLineByNode(treeNode.data.node, true);
	                            if (treeNode.children.length > 0) {
	                                treeNode.data.node._childShow = true;
	                                treeNode.data.node._toggleShrink && treeNode.data.node._toggleShrink(true);
	                            }
	                        }
	                    },this);
	                    node._childShow = true;
	                    node._toggleShrink && node._toggleShrink(true);
	                    this.refreshPositionAndLine();
	                }
	            };
	
	
	            TreeLayout.prototype.findTreeNodeByNode = function (node) {
	                var returnTreeNode = null;
	                this.tree.traverse(function (treeNode) {
	                    if (treeNode.data.node === node) {
	                        returnTreeNode = treeNode;
	                    }
	                });
	                return returnTreeNode;
	            };
	
	            TreeLayout.prototype.removeNode = function (node) {
	                var treeNode = this.findTreeNodeByNode(node);
	                var parentTreeNode = treeNode.parent;
	                if (!parentTreeNode) return false;
	                //遍历 topo中删除自己及孩子节点
	                treeNode.traverse(function (eachTreeNode) {
	                    this.fishTopo.remove(eachTreeNode.data.node); //删除节点
	                },this)
	
	                parentTreeNode.remove(treeNode);
	
	                //判断一下父节点是不是没有了,如果没有的话,要把线与+-号给隐藏掉
	                if (parentTreeNode.children.length === 0) {
	                    parentTreeNode.data.node._hideToggle && parentTreeNode.data.node._hideToggle();
	                }
	
	                //重新生成数据
	                this.refreshPositionAndLine();
	                return true;
	            };
	
	
	            TreeLayout.prototype.removeChildren = function (node) {
	                var treeNode = this.findTreeNodeByNode(node);
	                //遍历 topo中删除孩子节点
	                treeNode.traverse(function (eachTreeNode) {
	                    if (eachTreeNode !== treeNode) {
	                        this.fishTopo.remove(eachTreeNode.data.node); //删除节点
	                    }
	                },this)
	
	                treeNode.removeAllChildren();
	                node._hideToggle && node._hideToggle(); //this._hidePath(node);
	
	                //重新生成数据
	                this.refreshPositionAndLine();
	                return true;
	            };
	
	            TreeLayout.prototype.refreshPositionAndLine = function (callback) {
	                this.tree.root.updateDepthAndHeight(0);
	                this._setTreeShape(function () {
	                    this.tree.traverse(function (eachTreeNode) {
	                        this.fishTopo.connectionManager.refreshLineByNode(eachTreeNode.data.node);
	                    }, this);
	                    callback && callback();
	                }.bind(this));
	            }
	
	            TreeLayout.prototype.changePosition = function (node, direction) {
	                var parentNode = node.parent;
	                var nowIndex = zrUtil.indexOf(parentNode.children, node);
	                var targetIndex;
	                if(direction == "next"){
	                    targetIndex = nowIndex + 1;
	                }else if(direction == "prev"){
	                    targetIndex = nowIndex - 1;
	                }
	                var targetNode = parentNode.children[targetIndex];
	                if(targetNode){
	                    var storage = targetNode;
	                    parentNode.children[targetIndex] = node;
	                    parentNode.children[nowIndex] = storage;
	                }
	                this.refreshPositionAndLine();
	                this.fishTopo.trigger('treeLayout:changePosition',{
	                    node:node,
	                    parentNode:parentNode,
	                    targetNode:targetNode
	                })
	            }
	
	        module.exports = TreeLayout;
	
	
	/**
	 * @method addCustomLayout
	 * @hide
	 */

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var zrUtil = __webpack_require__(5);
	
	    /**
	     * @constructor TreeNode
	     * @param {string} id Node ID
	     * @param {Object} [data]
	     */
	    function TreeNode(id, data) {
	        /**
	         * @type {string}
	         */
	        this.id = id;
	        /**
	         * 节点的深度
	         * @type {number}
	         */
	        this.depth = 0;
	        /**
	         * 以当前节点为根节点的子树的高度
	         * @type {number}
	         */
	        this.height = 0;
	        /**
	         * 子节点列表
	         * @type {Array.<TreeNode>}
	         */
	        this.children = [];
	
	        /**
	         * @type {TreeNode}
	         */
	        this.parent = null;
	
	        /**
	         * 存储的用户数据
	         * @type {Object}
	         */
	        this.data = data || null;
	    }
	
	    /**
	     * 添加子节点
	     * @param {TreeNode} child
	     */
	    TreeNode.prototype.add = function (child) {
	        var children = this.children;
	        if (child.parent === this) {
	            return;
	        }
	
	        children.push(child);
	        child.parent = this;
	    };
	
	    /**
	     * 移除子节点
	     * @param {TreeNode} child
	     */
	    TreeNode.prototype.remove = function (child) {
	        var children = this.children;
	        var idx = zrUtil.indexOf(children, child);
	        if (idx >= 0) {
	            children.splice(idx, 1);
	            child.parent = null;
	        }
	    };
	
	     TreeNode.prototype.removeAllChildren = function () {
	         var children = this.children;
	         for (var i = 0; i < children.length; i++) {
	             var child = children[i];
	            child.parent = null;
	         }
	        this.children = [];
	     }
	
	    /**
	     * 遍历当前节点及其所有子节点
	     * @param  {Function} cb
	     * @param  {Object}   [context]
	     */
	    TreeNode.prototype.traverse = function (cb, context) {
	        cb.call(context, this);
	
	        for (var i = 0; i < this.children.length; i++) {
	            this.children[i].traverse(cb, context);
	        }
	    };
	
	    /**
	     * 遍历节前节点及所有子节点的数量
	     */
	    TreeNode.prototype.count = function () {
	        var count = 0;
	        this.traverse(function() {
	            count++;
	         });
	        return count;
	    }
	
	    /**
	     * 更新当前树及所有子树的高度和深度
	     * @param  {number} depth
	     */
	    TreeNode.prototype.updateDepthAndHeight = function (depth) {
	        var height = 0;
	        this.depth = depth;
	        for (var i = 0; i < this.children.length; i++) {
	            var child = this.children[i];
	            child.updateDepthAndHeight(depth + 1);
	            if (child.height > height) {
	                height = child.height;
	            }
	        }
	        this.height = height + 1;
	    };
	
	    /**
	     * @param  {string} id
	     * @return TreeNode
	     */
	    TreeNode.prototype.getNodeById = function (id) {
	        if (this.id === id) {
	            return this;
	        }
	        for (var i = 0; i < this.children.length; i++) {
	            var res = this.children[i].getNodeById(id);
	            if (res) {
	                return res;
	            }
	        }
	    };
	
	    /**
	     * @constructor
	     * @alias module:echarts/data/Tree
	     * @param {string} id
	     */
	    function Tree(id) {
	        /**
	         * @type {TreeNode}
	         */
	        this.root = new TreeNode(id);
	    }
	
	    /**
	     * 遍历树的所有子节点(深度优先遍历)
	     * @param  {Function} cb
	     * @param  {Object}   [context]
	     */
	    Tree.prototype.traverse = function(cb, context) {
	        this.root.traverse(cb, context);
	    };
	
	    /**
	     * 生成子树
	     * @param  {string} id 子树根节点 id
	     * @return {module:echarts/data/Tree}
	     */
	    Tree.prototype.getSubTree = function(id) {
	        var root = this.getNodeById(id);
	        if (root) {
	            var tree = new Tree(root.id);
	            tree.root = root;
	            return tree;
	        }
	    };
	
	    /**
	     * @param  {string} id
	     * @return TreeNode
	     */
	    Tree.prototype.getNodeById = function (id) {
	        return this.root.getNodeById(id);
	    };
	
	
	    /**
	     * 从 option 里的 data 数据构建树
	     * @param {string} id
	     * @param {Array.<Object>} data
	     * @return Tree
	     */
	    Tree.fromOptionData = function (id, data) {
	        var tree = new Tree(id);
	        var rootNode = tree.root;
	        // Root node
	        rootNode.data = {
	            name: id,
	            children: data
	        };
	
	        function buildHierarchy(dataNode, parentNode) {
	            var node = new TreeNode(dataNode.name, dataNode);
	            parentNode.add(node);
	            // 遍历添加子节点
	            var children = dataNode.children;
	            if (children) {
	                for (var i = 0; i < children.length; i++) {
	                    buildHierarchy(children[i], node);
	                }
	            }
	        }
	
	        for (var i = 0; i < data.length; i++) {
	            buildHierarchy(data[i], rootNode);
	        }
	
	        tree.root.updateDepthAndHeight(0);
	
	        return tree;
	    };
	
	
	    Tree.fromDataSource = function (dataSource, rootItem) {
	
	        function _findChildItem(nodeName) {
	            return zrUtil.filter(dataSource.link,function(item){
	                if(item.from === nodeName && !item.pos) {  // 数据中有pos属性的不是子节点
	                    return item;
	                }
	            });
	        }
	
	
	        function buildHierarchy(root) {
	            var childItem = _findChildItem(root.id);
	            for (var i = 0; i < childItem.length; i++) {
	                var item = childItem[i];
	                var childTreeNode = treeNodesMap[item.to];
	                root.children.push(childTreeNode);
	                buildHierarchy(childTreeNode);
	            }
	        }
	
	        var treeNodesMap = {};
	        for (var i = 0; i < dataSource.node.length; i++) {
	            var node = dataSource.node[i];
	            var treeNode = new TreeNode(node.name,node);
	            treeNodesMap[node.name] = treeNode;
	        }
	
	        var tree = new Tree(rootItem.name);
	        var rootNode = tree.root;
	        // Root node
	        rootNode.data = rootItem;
	
	
	        buildHierarchy(tree.root);
	        tree.root.updateDepthAndHeight(0);
	
	        return tree;
	    };
	
	    module.exports = Tree;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var vec2 = __webpack_require__(15);
	    var zrUtil = __webpack_require__(5);
	
	    function TreeHelper(opts) {
	        opts = opts || {};
	
	        this.nodePadding = opts.nodePadding || 30;
	
	        this.layerPadding = opts.layerPadding || 100;
	
	        this._layerOffsets = [];
	
	        this._layers = [];
	
	        this._hideNodes = [];
	    }
	
	    TreeHelper.prototype.count = function (tree) {
	        var count = 0;
	        tree.traverse(function() {
	            count++;
	         });
	        return count;
	    }
	
	    TreeHelper.prototype.run = function (tree) {
	        this._layerOffsets.length = 0;
	        for (var i = 0; i < tree.root.height + 1; i++) {
	            this._layerOffsets[i] = 0;
	            this._layers[i] = [];
	        }
	        this._updateNodeXPosition(tree.root);
	        var root = tree.root;
	        this._updateNodeYPosition(root, 0, root.layout.height);
	    };
	
	    TreeHelper.prototype._updateNodeXPosition = function (node) {
	        var minX = Infinity;
	        var maxX = -Infinity;
	        node.layout.position = node.layout.position || vec2.create();
	        for (var i = 0; i < node.children.length; i++) {
	            var child = node.children[i];
	            if(zrUtil.indexOf(this._hideNodes, child) == -1){
	                this._updateNodeXPosition(child);
	                var x = child.layout.position[0];
	                if (x < minX) {
	                    minX = x;
	                }
	                if (x > maxX) {
	                    maxX = x;
	                }
	            }
	        }
	        if (node.children.length > 0 && (zrUtil.indexOf(this._hideNodes, node.children[0]) == -1)) {
	            node.layout.position[0] = (minX + maxX) / 2;
	        } else {
	            node.layout.position[0] = 0;
	            node.height = 0;   // 隐藏节点的 深度设为0
	        }
	        var off = this._layerOffsets[node.depth] || 0;
	        if (off > node.layout.position[0]) {
	            var shift = off - node.layout.position[0];
	            this._shiftSubtree(node, shift);
	            for (var j = node.depth + 1; j < node.height + node.depth; j++) {
	                this._layerOffsets[j] += shift;
	            }
	        }
	        this._layerOffsets[node.depth] = node.layout.position[0] + node.layout.width + this.nodePadding;
	
	        if(zrUtil.indexOf(this._layers[node.depth], node) == -1){
	            this._layers[node.depth].push(node);
	        }
	    };
	
	    TreeHelper.prototype._shiftSubtree = function (root, offset) {
	        root.layout.position[0] += offset;
	        for (var i = 0; i < root.children.length; i++) {
	            if(zrUtil.indexOf(this._hideNodes,root.children[i]) == -1){
	                this._shiftSubtree(root.children[i], offset);
	            }
	        }
	    };
	
	    TreeHelper.prototype._updateNodeYPosition = function (node, y, prevLayerHeight) {
	        if(zrUtil.indexOf(this._hideNodes,node) == -1){
	            node.layout.position[1] = y;
	            var layerHeight = 0;
	            for (var i = 0; i < node.children.length; i++) {
	                layerHeight = Math.max(node.children[i].layout.height, layerHeight);
	            }
	            var layerPadding = this.layerPadding;
	            if (typeof (layerPadding) === 'function') {
	                layerPadding = layerPadding(node.depth);
	            }
	            for (var j = 0; j < node.children.length; j++) {
	                this._updateNodeYPosition(node.children[j], y + layerPadding + prevLayerHeight, layerHeight);
	            }
	        }
	
	    };
	    module.exports = TreeHelper;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * 力导向布局<br>
	 * @class fishTopoFlow.layout.ForceLayout
	 * @extends fishTopoFlow.layout
	 *
	 * **使用范例**：
	 *
	 *      @example
	 *       var node = fishTopoFlow.node;
	 *       var layout = fishTopoFlow.layout;
	 *       var fishTopo = fishTopoFlow.init(document.getElementById("flowIns"), {roam:false});
	 *       function newNode(data) {
	 *           var circle = new node.Circle({
	 *               shape: { r: 15 },
	 *               style: { fill: "#4883b4" },
	 *               name: data.name
	 *           });
	 *           return circle;
	 *       }
	 *       var options = {
	 *           createNodeFunction: newNode,
	 *           data:[{nodes:[
	 *                           {name: '节点1'},
	 *                           {name: '节点2'},
	 *                           {name: '节点3'},
	 *                           {name: '节点4'},
	 *                           {name: '节点5'},
	 *                           {name: '节点6'},
	 *                           {name: '节点7'},
	 *                           {name: '节点8'}
	 *                       ],
	 *                   links:[
	 *                           {source:'节点1', target:'节点2'},
	 *                           {source:'节点2', target:'节点3'},
	 *                           {source:'节点3', target:'节点4'},
	 *                           {source:'节点4', target:'节点5'},
	 *                           {source:'节点5', target:'节点6'},
	 *                           {source:'节点6', target:'节点7'},
	 *                           {source:'节点7', target:'节点8'}
	 *                       ]
	 *           }]
	 *       }
	 *       var forceLayout = new layout.ForceLayout({
	 *          fishTopo:fishTopo,
	 *           repulsion: 200
	 *       });
	 *       forceLayout.doLayout(options);
	 */
	
	
	
	    var forceHelper = __webpack_require__(130);
	    var vec2 = __webpack_require__(15);
	    var zrUtil = __webpack_require__(5);
	    function ForceLayout(opts) {
	         /**
	         * @cfg {Object} fishTopo fishTopo实例
	         */
	         /**
	         * @cfg {Number} [repulsion=100] 节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100
	         */
	         /**
	         * @cfg {Number} [gravity=0.1] 节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1
	         */
	        /**
	         * @cfg {Number} [edgeLength=30] 边的两个节点之间的距离，这个距离也会受 repulsion影响。 默认为30
	         */
	        /**
	         * @cfg {Boolean} [once=true] 是否只进行布局一次
	         */
	        /**
	         * @cfg {Object} [rect] 布局显示范围
	         *
	         * @cfg {Object} [rect.x] 布局显示范围x坐标
	         * @cfg {Object} [rect.y] 布局显示范围y坐标
	         * @cfg {Object} [rect.width] 布局显示宽度
	         * @cfg {Object} [rect.height] 布局显示高度
	         */
	        /**
	         * @cfg {Boolean} [layoutAnimation=true] 是否显示布局动画
	         */
	        /**
	         * @cfg {Object} [lineStyle] 连线的样式  参见{@link fishTopoFlow.link#constructor 构造函数options参数}
	         */
	        this.fishTopo = opts.fishTopo;
	        var defaultOptions = {
	            repulsion: 100,  //节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100
	            gravity: 0.1, //节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1
	            edgeLength: 30, // 边的两个节点之间的距离，这个距离也会受 repulsion。 默认为30
	            once:true,
	            layoutAnimation:true,
	            rect: {x:0, y:0, width:this.fishTopo.getWidth() ,height:this.fishTopo.getHeight()},
	            lineStyle: {symbol:{type:'none'}},
	            preservedPoints: {}
	        };
	
	        this.options = zrUtil.defaults(defaultOptions, opts, true);
	    }
	
	    /**
	     * @method doLayout
	     * 根据forceData进行力导向布局
	     * @param {Object} forceData 力导向数据
	     * @param {Function} forceData.createNodeFunction=null 创建节点的函数 会把data中nodes的数据 传递过去  如果没有默认就是创建圆形
	     * @param {Object} forceData.data 创建力导向布局数据
	     * @param {Object} forceData.data.nodes 创建力导向布局节点的对象数据（必须包括name属性）
	     * @param {Object} forceData.data.links 创建力导向布局连线的对象数据（必须包括name属性）
	     *
	     */
	    ForceLayout.prototype.doLayout = function(forceData) {
	         var rootData = forceData.data[0];
	        this.allNodes = this._buildNode(rootData.nodes);
	        this.allLinks = this._buildLinks(rootData.links);
	        this._forceIns();
	
	        this._startForceLayoutIteration();
	    }
	
	    ForceLayout.prototype._buildNode = function(datas) {
	        if(!datas.createNodeFunction) {
	            datas.createNodeFunction = this._defaultCreateNodeFunction.bind(this);
	        }
	        var allNodes = [];
	        //判断一下是否有node 如果没有则自己创建
	        zrUtil.each(datas,  function(item,idx) {
	            if(!item.node) {
	                var createNodeFunction = item.createNodeFunction || datas.createNodeFunction;
	                var node = createNodeFunction(item);
	                this.fishTopo.add(node);
	                this._addNodeEvent(node,idx);
	                allNodes.push(node);
	            }
	        },this);
	        return allNodes;
	    }
	
	    ForceLayout.prototype._addNodeEvent = function(node,idx) {
	        if(!this.options.once) {
	            node.on('drag', function() {
	                if(this.options.forceLayout) {
	                    this.options.forceLayout.warmUp();
	                    !this._layouting && this._startForceLayoutIteration();
	                    this.options.forceLayout.setFixed(idx);
	                }
	            },this).on('dragend', function() {
	                if(this.options.forceLayout) {
	                    this.options.forceLayout.setUnfixed(idx);
	                }
	            },this)
	        }
	    }
	
	    ForceLayout.prototype._defaultCreateNodeFunction = function(item) {
	        var circle = this.fishTopo.createNode("Circle",{
	            shape: { r: 15 },
	            style: { fill: "#4883b4" },
	            name: item.lable || item.name
	        });
	        return circle;
	    }
	
	    ForceLayout.prototype._buildLinks = function(links,createLinkFunction) {
	        var allLinks = [];
	
	        zrUtil.each(links, function(link) {
	            var startNode = this.fishTopo.childOfName(link.source);
	            var endNode = this.fishTopo.childOfName(link.target);
	            if(startNode && endNode) {
	                 var connector = null;
	                if(createLinkFunction) {
	                    var paramObj = link;
	                    paramObj.startNode = startNode;
	                    paramObj.endNode = endNode;
	                    connector = createLinkFunction(paramObj);
	                } else {
	                    var linkStyle = this.options.lineStyle;
	                    if (link.style) {
	                        linkStyle = zrUtil.merge(zrUtil.clone(linkStyle), link.style, true);
	                    }
	                    connector = this.fishTopo.createLink(startNode,endNode,linkStyle);
	                }
	                this.fishTopo.add(connector);
	                allLinks.push(connector);
	            }
	        },this);
	        return allLinks;
	    }
	
	
	    ForceLayout.prototype._forceIns = function() {
	        var rect = this.options.rect;
	        var self = this;
	        var preservedPoints = this.options.preservedPoints;
	        var nodes = zrUtil.map(this.allNodes, function(node) {
	            var rep = this.options.repulsion; node.w = rep; node.rep = rep; node.p = null;
	            return {
	                w: rep,
	                rep: rep,
	                p: null
	            };
	        },this);
	        if (preservedPoints) {
	            zrUtil.each(this.allNodes, function(node,idx) {
	                node.attr("position", preservedPoints[idx]);
	            })
	        }
	        zrUtil.each(this.allLinks, function(link) {
	            link.n1 = link.startNode,
	            link.n2 = link.endNode,
	            link.d = this.options.edgeLength;
	            link.curveness = 0;
	        },this)
	
	        var forceInstance = forceHelper(this.allNodes, this.allLinks, {
	            rect: rect,
	            gravity: this.options.gravity
	        });
	        var oldStep = forceInstance.step;
	        forceInstance.step = function(cb) {
	            zrUtil.each(this.allNodes, function(node) {
	                if (nodes.fixed) {
	                    vec2.copy(nodes.p, nodes.position);
	                }
	            })
	
	            oldStep(function(allNodes, allLinks, stopped) {
	                for (var i = 0, l = allNodes.length; i < l; i++) {
	                    if (!allNodes[i].fixed) {
	                        allNodes[i].attr("position", allNodes[i].p);
	                    }
	                    preservedPoints[i] = allNodes[i].p;
	                }
	
	                zrUtil.each(allLinks, function(connector) {
	                    self.fishTopo.connectionManager.refreshConnector(connector, true);
	                })
	
	                cb && cb(stopped);
	            });
	        };
	        this.options.forceLayout = forceInstance;
	        this.options.preservedPoints = preservedPoints;
	        // Step to get the layout
	        forceInstance.step();
	    }
	
	
	    ForceLayout.prototype._startForceLayoutIteration = function () {
	        var self = this;
	        var layoutAnimation = this.options.layoutAnimation;
	        (function step() {
	            self.options.forceLayout.step(function (stopped) {
	                self._layouting = !stopped;
	                if (self._layouting) {
	                    if (layoutAnimation) {
	                        self._layoutTimeout = setTimeout(step, 16)
	                    } else {
	                        step();
	                    }
	                } else {
	                     self.fishTopo.trigger("forceLayoutEnd");  //派发布局结束事件
	                }
	            })
	        })();
	    };
	    module.exports = ForceLayout;
	
	/**
	 * @method addCustomLayout
	 * @hide
	 */
	
	/**
	 * @event forceLayoutEnd
	 * 布局结束事件
	 *
	 * <pre>
	 * fishtopo.on('forceLayoutEnd', function(e) {
	 *   //do something
	 * })
	 * </pre>
	 */


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var vec2 = __webpack_require__(15);
	    var scaleAndAdd = vec2.scaleAndAdd;
	
	    // function adjacentNode(n, e) {
	    //     return e.n1 === n ? e.n2 : e.n1;
	    // }
	
	    module.exports = function (nodes, edges, opts) {
	        var rect = opts.rect;
	        var width = rect.width;
	        var height = rect.height;
	        var center = [rect.x + width / 2, rect.y + height / 2];
	        // var scale = opts.scale || 1;
	        var gravity = opts.gravity == null ? 0.1 : opts.gravity;
	
	        // for (var i = 0; i < edges.length; i++) {
	        //     var e = edges[i];
	        //     var n1 = e.n1;
	        //     var n2 = e.n2;
	        //     n1.edges = n1.edges || [];
	        //     n2.edges = n2.edges || [];
	        //     n1.edges.push(e);
	        //     n2.edges.push(e);
	        // }
	        // Init position
	        for (var i = 0; i < nodes.length; i++) {
	            var n = nodes[i];
	            if (!n.p) {
	                // Use the position from first adjecent node with defined position
	                // Or use a random position
	                // From d3
	                // if (n.edges) {
	                //     var j = -1;
	                //     while (++j < n.edges.length) {
	                //         var e = n.edges[j];
	                //         var other = adjacentNode(n, e);
	                //         if (other.p) {
	                //             n.p = vec2.clone(other.p);
	                //             break;
	                //         }
	                //     }
	                // }
	                // if (!n.p) {
	                    n.p = vec2.create(
	                        width * (Math.random() - 0.5) + center[0],
	                        height * (Math.random() - 0.5) + center[1]
	                    );
	                // }
	            }
	            n.pp = vec2.clone(n.p);
	            n.edges = null;
	        }
	
	        // Formula in 'Graph Drawing by Force-directed Placement'
	        // var k = scale * Math.sqrt(width * height / nodes.length);
	        // var k2 = k * k;
	
	        var friction = 0.6;
	
	        return {
	            warmUp: function () {
	                friction = 0.5;
	            },
	
	            setFixed: function (idx) {
	                nodes[idx].fixed = true;
	            },
	
	            setUnfixed: function (idx) {
	                nodes[idx].fixed = false;
	            },
	
	            step: function (cb) {
	                var v12 = [];
	                var nLen = nodes.length;
	                for (var i = 0; i < edges.length; i++) {
	                    var e = edges[i];
	                    var n1 = e.n1;
	                    var n2 = e.n2;
	
	                    vec2.sub(v12, n2.p, n1.p);
	                    var d = vec2.len(v12) - e.d;
	                    var w = n2.w / (n1.w + n2.w);
	                    vec2.normalize(v12, v12);
	
	                    !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);
	                    !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);
	                }
	                // Gravity
	                for (var i = 0; i < nLen; i++) {
	                    var n = nodes[i];
	                    if (!n.fixed) {
	                        vec2.sub(v12, center, n.p);
	                        // var d = vec2.len(v12);
	                        // vec2.scale(v12, v12, 1 / d);
	                        // var gravityFactor = gravity;
	                        vec2.scaleAndAdd(n.p, n.p, v12, gravity * friction);
	                    }
	                }
	
	                // Repulsive
	                // PENDING
	                for (var i = 0; i < nLen; i++) {
	                    var n1 = nodes[i];
	                    for (var j = i + 1; j < nLen; j++) {
	                        var n2 = nodes[j];
	                        vec2.sub(v12, n2.p, n1.p);
	                        var d = vec2.len(v12);
	                        if (d === 0) {
	                            // Random repulse
	                            vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);
	                            d = 1;
	                        }
	                        var repFact = (n1.rep + n2.rep) / d / d;
	                        !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);
	                        !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);
	                    }
	                }
	                var v = [];
	                for (var i = 0; i < nLen; i++) {
	                    var n = nodes[i];
	                    if (!n.fixed) {
	                        vec2.sub(v, n.p, n.pp);
	                        vec2.scaleAndAdd(n.p, n.p, v, friction);
	                        vec2.copy(n.pp, n.p);
	                    }
	                }
	
	                friction = friction * 0.992;
	
	                cb && cb(nodes, edges, friction < 0.01);
	            }
	        };
	    }
	


/***/ }),
/* 131 */
/***/ (function(module, exports) {

	/**
	 * 工具类
	 * @class fishTopoFlow.util
	 */
	
	/**
	 * @method initImagePool
	 * 初始化图片池  用于对图片加载进行管理
	 * @param {number} max 最大连接数。数值。
	 * @returns {{load: Function, info: Function}}
	 *
	 * **使用范例**：
	 *
	 *      @example
	        var imagepool = fishTopoFlow.util.initImagePool(100);
	        imagepool.load(grayArray, {
	            success: function(imgs) {
	            },
	            once: true
	        });
	 */
	
	/**
	 * @method inherits
	 * 构造类继承关系
	 *
	 * @param {Function} clazz 源类
	 * @param {Function} baseClazz 基类
	 */
	
	
	    var emptyFn = function() {};
	    //初始默认配置
	    var config_default = {
	        //线程池"线程"数量
	        thread: 5,
	        //图片加载失败重试次数
	        //重试2次，加上原有的一次，总共是3次
	        "tries": 2
	    };
	    //工具
	    var _helpers = {
	        //设置dom属性
	        setAttr: (function() {
	            var img = new Image();
	            //判断浏览器是否支持HTML5 dataset
	            if (img.dataset) {
	                return function(dom, name, value) {
	                    dom.dataset[name] = value;
	                    return value;
	                };
	            } else {
	                return function(dom, name, value) {
	                    dom.setAttribute("data-" + name, value);
	                    return value;
	                };
	            }
	        }()),
	        //获取dom属性
	        getAttr: (function() {
	            var img = new Image();
	            //判断浏览器是否支持HTML5 dataset
	            if (img.dataset) {
	                return function(dom, name) {
	                    if(!dom.dataset[name]){
	                        return dom.getAttribute("data-" + name);
	                    }else{
	                        return dom.dataset[name];
	                    }
	                };
	            } else {
	                return function(dom, name) {
	                    return dom.getAttribute("data-" + name);
	                };
	            }
	        }())
	    };
	    /**
	     * 构造方法
	     * @private
	     * @param max 最大连接数。数值。
	     */
	    function ImagePool(max) {
	        //最大并发数量
	        this.max = max || config_default.thread;
	        this.linkHead = null;
	        this.linkNode = null;
	        //加载池
	        //[{img: dom,free: true, node: node}]
	        //node
	        //{src: "", options: {success: "fn",error: "fn", once: true}, tries: 0}
	        this.pool = [];
	    }
	    /**
	     * 初始化
	     * @private
	     */
	    ImagePool.prototype.initPool = function() {
	        var i, img, obj, _s;
	        _s = this;
	        for (i = 0; i < this.max; i++) {
	            obj = {};
	            img = new Image();
	            _helpers.setAttr(img, "id", i);
	            img.onload = function() {
	                //回调
	                _s.notice(_s.getNode(this), "success", this);
	                //处理任务
	                _s.executeLink(this);
	            };
	            img.onerror = function() {
	                var node = _s.getNode(this);
	                //判断尝试次数
	                if (node.tries < config_default.tries) {
	                    node.tries = node.tries+1;
	                    //再次追加到任务链表末尾
	                    _s.appendNode(_s.createNode(node.src, node.options, node.notice, node.group, node.tries));
	                } else {
	                    //error回调
	                    //node.options.error.call(null, this.src);
	                    _s.notice(node, "error", this);
	                }
	                //处理任务
	                _s.executeLink(this);
	            };
	            obj.img = img;
	            obj.free = true;
	            this.pool.push(obj);
	        }
	    };
	    /**
	     * 回调封装
	     * @private
	     * @param node 节点。对象。
	     * @param status 状态。字符串。可选值：success(成功)|error(失败)
	     * @param img 图片。
	     */
	    ImagePool.prototype.notice = function(node, status, img) {
	        node.notice(status, img);
	    };
	    /**
	     * 处理链表任务
	     * @private
	     * @param dom 图像dom对象。对象。
	     */
	    ImagePool.prototype.executeLink = function(dom) {
	        //判断链表是否存在节点
	        if (this.linkHead) {
	            //加载下一个图片
	            this.setSrc(dom, this.linkHead);
	            //去除链表头
	            this.shiftNode();
	        } else {
	            //设置自身状态为空闲
	            this.status(dom, true);
	        }
	    };
	    /**
	     * 获取空闲"线程"
	     * @private
	     */
	    ImagePool.prototype.getFree = function() {
	        var length, i;
	        for (i = 0, length = this.pool.length; i < length; i++) {
	            if (this.pool[i].free) {
	                return this.pool[i];
	            }
	        }
	        return null;
	    };
	    /**
	     * 封装src属性设置
	     * 因为改变src属性相当于加载图片，所以把操作封装起来
	     * @private
	     * @param dom 图像dom对象。对象。
	     * @param node 节点。对象。
	     */
	    ImagePool.prototype.setSrc = function(dom, node) {
	        //设置池中的"线程"为非空闲状态
	        this.status(dom, false);
	        //关联节点
	        this.setNode(dom, node);
	        //加载图片
	        dom.src = node.src;
	    };
	    /**
	     * 更新池中的"线程"状态
	     * @private
	     * @param dom 图像dom对象。对象。
	     * @param status 状态。布尔。可选值：true(空闲)|false(非空闲)
	     */
	    ImagePool.prototype.status = function(dom, status) {
	        var id = _helpers.getAttr(dom, "id");
	        if(id){
	            this.pool[id].free = status;
	        }
	
	        //空闲状态，清除关联的节点
	        if (status) {
	            this.pool[id].node = null;
	        }
	    };
	    /**
	     * 更新池中的"线程"的关联节点
	     * @private
	     * @param dom 图像dom对象。对象。
	     * @param node 节点。对象。
	     */
	    ImagePool.prototype.setNode = function(dom, node) {
	        var id = _helpers.getAttr(dom, "id");
	        if(id){
	            this.pool[id].node = node;
	            return this.pool[id].node === node;
	        }
	
	    };
	    /**
	     * 获取池中的"线程"的关联节点
	     * @private
	     * @param dom 图像dom对象。对象。
	     */
	    ImagePool.prototype.getNode = function(dom) {
	        var id = _helpers.getAttr(dom, "id");
	        if(id){
	            return this.pool[id].node;
	        }
	
	    };
	    /**
	     * 对外接口，加载图片
	     * @private
	     * @param src 可以是src字符串，也可以是src字符串数组。
	     * @param options 用户自定义参数。包含：success回调、error回调、once标识。
	     */
	    ImagePool.prototype._load = function(src, options) {
	        var srcs = [],
	            free = null,
	            length = 0,
	            i = 0,
	            //只初始化一次回调策略
	            notice = (function() {
	                if (options.once) {
	                    return function(status, img) {
	                        var g = this.group,
	                            o = this.options;
	                        //记录
	                        g[status].push(img);
	                        //判断改组是否全部处理完成
	                        if (g.success.length + g.error.length === g.count) {
	                            //异步
	                            //实际上是作为另一个任务单独执行，防止回调函数执行时间过长影响图片加载速度
	                            setTimeout(function() {
	                                o.success.call(null, g.success, g.error, g.count);
	                            }, 1);
	                        }
	                    };
	                } else {
	                    return function(status, img) {
	                        var o = this.options;
	                        //直接回调
	                        setTimeout(function() {
	                            o[status].call(null, img);
	                        }, 1);
	                    };
	                }
	            }()),
	            group = {
	                count: 0,
	                success: [],
	                error: []
	            },
	            node = null;
	        options = options || {};
	        options.success = options.success || emptyFn;
	        options.error = options.error || emptyFn;
	        srcs = srcs.concat(src);
	        //设置组元素个数
	        group.count = srcs.length;
	        //遍历需要加载的图片
	        for (i = 0, length = srcs.length; i < length; i++) {
	            //创建节点
	            node = this.createNode(srcs[i], options, notice, group);
	            //判断线程池是否有空闲
	            free = this.getFree();
	            if (free) {
	                //有空闲，则立即加载图片
	                this.setSrc(free.img, node);
	            } else {
	                //没有空闲，将任务添加到链表
	                this.appendNode(node);
	            }
	        }
	    };
	    /**
	     * 获取内部状态信息
	     * @private
	     * @returns {Object}
	     */
	    ImagePool.prototype._info = function() {
	        var info = {},
	            length = 0,
	            i = 0,
	            node = null;
	        //线程
	        info.thread = {};
	        //线程总数量
	        info.thread.count = this.pool.length;
	        //空闲线程数量
	        info.thread.free = 0;
	        //任务
	        info.task = {};
	        //待处理任务数量
	        info.task.count = 0;
	        //获取空闲"线程"数量
	        for (i = 0, length = this.pool.length; i < length; i++) {
	            if (this.pool[i].free) {
	                info.thread.free = info.thread.free + 1;
	            }
	        }
	        //获取任务数量(任务链长度)
	        node = this.linkHead;
	        if (node) {
	            info.task.count = info.task.count + 1;
	            while (node.next) {
	                info.task.count = info.task.count + 1;
	                node = node.next;
	            }
	        }
	        return info;
	    };
	
	    /**
	     * 创建节点
	     * @private
	     * @param src 图片路径。字符串。
	     * @param options 用户自定义参数。包含：success回调、error回调、once标识。
	     * @param notice 回调策略。 函数。
	     * @param group 组信息。对象。{count: 0, success: [], error: []}
	     * @param tr 出错重试次数。数值。默认为0。
	     * @returns {Object}
	     */
	    ImagePool.prototype.createNode = function(src, options, notice, group, tr) {
	        var node = {};
	        node.src = src;
	        node.options = options;
	        node.notice = notice;
	        node.group = group;
	        node.tries = tr || 0;
	        return node;
	    };
	    /**
	     * 向任务链表末尾追加节点
	     * @private
	     * @param node 节点。对象。
	     */
	    ImagePool.prototype.appendNode = function(node) {
	        //判断链表是否为空
	        if (!this.linkHead) {
	            this.linkHead = node;
	            this.linkNode = node;
	        } else {
	            this.linkNode.next = node;
	            this.linkNode = node;
	        }
	    };
	    /**
	     * 删除链表头
	     * @private
	     */
	    ImagePool.prototype.shiftNode = function() {
	        //判断链表是否存在节点
	        if (this.linkHead) {
	            //修改链表头
	            this.linkHead = this.linkHead.next || null;
	        }
	    };
	    /**
	     * 初始化图片池
	     * @param {number} max 最大连接数。数值。
	     * @returns {{load: Function, info: Function}}
	     */
	    var initImagePool = function(max) {
	        var instance = new ImagePool(max);
	        instance.initPool();
	        return {
	            /**
	             * 加载图片
	             * @param {string|Array} src 可以是src字符串，也可以是src字符串数组。
	             * @param {Object} options 用户自定义参数。包含：success回调、error回调、once标识。
	             * @param {Function} [options.success] success回调
	             * @param {Function} [options.error] error回调
	             * @param {boolean} [options.once] 是否全部加载完毕后，一次回调
	             */
	            load: function() {
	                instance._load.apply(instance, arguments);
	            },
	            /**
	             * 获取内部状态信息
	             * @returns {Object}
	             */
	            info: function() {
	                return instance._info.call(instance);
	            }
	        };
	    };
	
	    module.exports = { initImagePool: initImagePool }
	


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var TooltipContent = __webpack_require__(133);
	    var globalListener = __webpack_require__(134);
	    var Model = __webpack_require__(87);
	    var zrUtil = __webpack_require__(5);
	    var env = __webpack_require__(50);
	    var flowUtil = __webpack_require__(94);
	    var layout = __webpack_require__(123);
	    function TooltipView(tooltipModel, api) {
	        this._tooltipContent = new TooltipContent(api.getDom(),api);
	        this._api = api;
	        this._tooltipModel = tooltipModel;
	        this._alwaysShowContent = tooltipModel.get('alwaysShowContent');
	        this._initGloablListener();
	    }
	
	    TooltipView.prototype._initGloablListener = function() {
	        var triggerOn = this._tooltipModel.get('triggerOn');
	        // 当有 'click' | 'mousemove' | 'none' 事件时触发回调
	        globalListener.register(
	            'itemTooltip',
	            this._api,
	            function(currTrigger, e, dispatchAction){
	                if (triggerOn !== 'none') {
	                    if (triggerOn.indexOf(currTrigger) >= 0 ) {
	                        this._tryShow(e, dispatchAction);
	                    }
	                    else if (currTrigger === 'leave') {
	                        this._hide(dispatchAction)
	                    }
	                }
	            }.bind(this)
	        )
	    };
	
	    TooltipView.prototype._tryShow = function(e, dispatchAction) {
	            var el = e.target;
	            var tooltipModel = this._tooltipModel;
	
	            if (!tooltipModel) {
	                return;
	            }
	
	            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed
	            this._lastX = e.offsetX;
	            this._lastY = e.offsetY;
	
	            if (el && el.tooltip) {
	                this._showComponentItemTooltip(e, el);
	            }
	            else {
	                this._hide(dispatchAction);
	            }
	    };
	
	     TooltipView.prototype._hide = function(dispatchAction) {
	            // Do not directly hideLater here, because this behavior may be prevented
	            // in dispatchAction when showTip is dispatched.
	
	            // FIXME
	            // duplicated hideTip if manuallyHideTip is called from dispatchAction.
	            this._lastDataByCoordSys = null;
	            dispatchAction({
	                type: 'hideTip',
	                from: this.uid
	            });
	            this.manuallyHideTip();
	        };
	
	       TooltipView.prototype.dispose = function () {
	            if (env.node) {
	                return;
	            }
	            this._tooltipContent.hide();
	            globalListener.unregister('itemTooltip', this._api);
	        };
	
	        TooltipView.prototype.manuallyHideTip = function () {
	            var tooltipContent = this._tooltipContent;
	
	            if (!this._alwaysShowContent) {
	                tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));
	            }
	
	            this._lastX = this._lastY = null;
	
	
	        },
	
	    TooltipView.prototype._showComponentItemTooltip = function (e, el) {
	            var tooltipOpt = el.tooltip;
	            if (typeof tooltipOpt === 'string') {
	                var content = tooltipOpt;
	                tooltipOpt = {
	                    content: content,
	                    // Fixed formatter
	                    formatter: content
	                };
	            }
	            var subTooltipModel = new Model(tooltipOpt, this._tooltipModel);
	            var defaultHtml = subTooltipModel.get('content');
	            var asyncTicket = Math.random();
	
	            // Do not check whether `trigger` is 'none' here, because `trigger`
	            // only works on cooridinate system. In fact, we have not found case
	            // that requires setting `trigger` nothing on component yet.
	
	            this._showOrMove(subTooltipModel, function () {
	                this._showTooltipContent(
	                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},
	                    asyncTicket, e.offsetX, e.offsetY, e.position, el
	                );
	            });
	
	
	        };
	
	      TooltipView.prototype._showOrMove = function (tooltipModel, cb) {
	            // showDelay is used in this case: tooltip.enterable is set
	            // as true. User intent to move mouse into tooltip and click
	            // something. `showDelay` makes it easyer to enter the content
	            // but tooltip do not move immediately.
	            var delay = tooltipModel.get('showDelay');
	            cb = zrUtil.bind(cb, this);
	            clearTimeout(this._showTimout);
	            delay > 0
	                ? (this._showTimout = setTimeout(cb, delay))
	                : cb();
	        };
	
	        TooltipView.prototype._showTooltipContent = function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {
	            // Reset ticket
	            this._ticket = '';
	
	            if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {
	                return;
	            }
	
	            var tooltipContent = this._tooltipContent;
	
	            var formatter = tooltipModel.get('formatter');
	            positionExpr = positionExpr || tooltipModel.get('position');
	            var html = defaultHtml;
	
	            if (formatter && typeof formatter === 'string') {
	                html = flowUtil.formatTpl(formatter, params, true);
	            }
	            else if (typeof formatter === 'function') {
	                var callback = function (cbTicket, html) {
	                    if (cbTicket === this._ticket) {
	                        tooltipContent.setContent(html);
	                        this._updatePosition(
	                            tooltipModel, positionExpr, x, y, tooltipContent, params, el
	                        );
	                    }
	                }.bind(this);
	                this._ticket = asyncTicket;
	                html = formatter(params, asyncTicket, callback);
	            }
	
	            tooltipContent.setContent(html);
	            tooltipContent.show(tooltipModel);
	
	            this._updatePosition(
	                tooltipModel, positionExpr, x, y, tooltipContent, params, el
	            );
	        };
	
	        /**
	         * @param  {string|Function|Array.<number>} positionExpr
	         * @param  {number} x Mouse x
	         * @param  {number} y Mouse y
	         * @param  {boolean} confine Whether confine tooltip content in view rect.
	         * @param  {Object|<Array.<Object>} params
	         * @param  {module:zrender/Element} el target element
	         * @param  {module:echarts/ExtensionAPI} api
	         * @return {Array.<number>}
	         */
	        TooltipView.prototype._updatePosition = function (tooltipModel, positionExpr, x, y, content, params, el) {
	            var viewWidth = this._api.getWidth();
	            var viewHeight = this._api.getHeight();
	            positionExpr = positionExpr || tooltipModel.get('position');
	
	            var contentSize = content.getSize();
	            var align = tooltipModel.get('align');
	            var vAlign = tooltipModel.get('verticalAlign');
	            var rect = el && el.getBoundingRect().clone();
	            el && rect.applyTransform(el.transform);
	
	            if (typeof positionExpr === 'function') {
	                // Callback of position can be an array or a string specify the position
	                positionExpr = positionExpr([x, y], params, content.el, rect, {
	                    viewSize: [viewWidth, viewHeight],
	                    contentSize: contentSize.slice()
	                });
	            }
	
	            if (zrUtil.isArray(positionExpr)) {
	                x = flowUtil.parsePercent(positionExpr[0], viewWidth);
	                y = flowUtil.parsePercent(positionExpr[1], viewHeight);
	            }
	            else if (zrUtil.isObject(positionExpr)) {
	                positionExpr.width = contentSize[0];
	                positionExpr.height = contentSize[1];
	                var layoutRect = layout.getLayoutRect(
	                    positionExpr, {width: viewWidth, height: viewHeight}
	                );
	                x = layoutRect.x;
	                y = layoutRect.y;
	                align = null;
	                // When positionExpr is left/top/right/bottom,
	                // align and verticalAlign will not work.
	                vAlign = null;
	            }
	            // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element
	            else if (typeof positionExpr === 'string' && el) {
	                var pos = calcTooltipPosition(
	                    positionExpr, rect, contentSize
	                );
	                x = pos[0];
	                y = pos[1];
	            }
	            else {
	                var pos1 = refixTooltipPosition(
	                    x, y, content.el, viewWidth, viewHeight, align ? 0 : 20, vAlign ? 0 : 20
	                );
	                x = pos1[0];
	                y = pos1[1];
	            }
	
	            align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);
	            vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);
	
	            if (tooltipModel.get('confine')) {
	                var pos2 = confineTooltipPosition(
	                    x, y, content.el, viewWidth, viewHeight
	                );
	                x = pos2[0];
	                y = pos2[1];
	            }
	
	            content.moveTo(x, y);
	        }
	
	    function calcTooltipPosition(position, rect, contentSize) {
	        var domWidth = contentSize[0];
	        var domHeight = contentSize[1];
	        var gap = 5;
	        var x = 0;
	        var y = 0;
	        var rectWidth = rect.width;
	        var rectHeight = rect.height;
	        switch (position) {
	            case 'inside':
	                x = rect.x + rectWidth / 2 - domWidth / 2;
	                y = rect.y + rectHeight / 2 - domHeight / 2;
	                break;
	            case 'top':
	                x = rect.x + rectWidth / 2 - domWidth / 2;
	                y = rect.y - domHeight - gap;
	                break;
	            case 'bottom':
	                x = rect.x + rectWidth / 2 - domWidth / 2;
	                y = rect.y + rectHeight + gap;
	                break;
	            case 'left':
	                x = rect.x - domWidth - gap;
	                y = rect.y + rectHeight / 2 - domHeight / 2;
	                break;
	            case 'right':
	                x = rect.x + rectWidth + gap;
	                y = rect.y + rectHeight / 2 - domHeight / 2;
	        }
	        return [x, y];
	    }
	    function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {
	        var width = el.clientWidth;
	        var height = el.clientHeight;
	
	        if (x + width + gapH > viewWidth) {
	            x -= width + gapH;
	        }
	        else {
	            x += gapH;
	        }
	        if (y + height + gapV > viewHeight) {
	            y -= height + gapV;
	        }
	        else {
	            y += gapV;
	        }
	        return [x, y];
	    }
	
	    function isCenterAlign(align) {
	        return align === 'center' || align === 'middle';
	    }
	
	    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {
	        var width = el.clientWidth;
	        var height = el.clientHeight;
	
	        x = Math.min(x + width, viewWidth) - width;
	        y = Math.min(y + height, viewHeight) - height;
	        x = Math.max(x, 0);
	        y = Math.max(y, 0);
	
	        return [x, y];
	    }
	    module.exports = TooltipView;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	
	    var zrUtil = __webpack_require__(5);
	    var zrColor = __webpack_require__(20);
	    var env = __webpack_require__(50);
	    var eventUtil = __webpack_require__(74);
	    var flowUtil = __webpack_require__(94);
	    var toCamelCase = flowUtil.toCamelCase;
	    var normalizeCssArray = flowUtil.normalizeCssArray;
	    var each = zrUtil.each;
	
	
	    var vendors = ['', '-webkit-', '-moz-', '-o-'];
	
	    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:999;';//fish popup zindex:1050
	    /**
	     * @param {number} duration
	     * @return {string}
	     * @inner
	     */
	    function assembleTransition(duration) {
	        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';
	        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','
	                            + 'top ' + duration + 's ' + transitionCurve;
	        return zrUtil.map(vendors, function (vendorPrefix) {
	            return vendorPrefix + 'transition:' + transitionText;
	        }).join(';');
	    }
	
	    /**
	     * @param {Object} textStyle
	     * @return {string}
	     * @inner
	     */
	    function assembleFont(textStyleModel) {
	        var cssText = [];
	
	        var fontSize = textStyleModel.get('fontSize');
	        var color = textStyleModel.get("color");
	
	        color && cssText.push('color:' + color);
	
	        var font = textStyleModel.get("font");
	        font && cssText.push('font:' + font);
	
	        fontSize &&
	            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');
	
	        each(['decoration', 'align'], function (name) {
	            var val = textStyleModel.get(name);
	            val && cssText.push('text-' + name + ':' + val);
	        });
	
	        return cssText.join(';');
	    }
	    /**
	     * @param {Object} tooltipModel
	     * @return {string}
	     * @inner
	     */
	    function assembleCssText(tooltipModel) {
	
	        var cssText = [];
	
	        var transitionDuration = tooltipModel.get('transitionDuration');
	        var backgroundColor = tooltipModel.get('backgroundColor');
	        var textStyleModel = tooltipModel.getModel('textStyle');
	        var padding = tooltipModel.get('padding');
	
	        // Animation transition. Do not animate when transitionDuration is 0.
	        transitionDuration &&
	            cssText.push(assembleTransition(transitionDuration));
	
	        if (backgroundColor) {
	            if (env.canvasSupported) {
	                cssText.push('background-Color:' + backgroundColor);
	            }
	            else {
	                // for ie
	                cssText.push(
	                    'background-Color:#' + zrColor.toHex(backgroundColor)
	                );
	                cssText.push('filter:alpha(opacity=70)');
	            }
	        }
	
	        // Border style
	        each(['width', 'color', 'radius'], function (name) {
	            var borderName = 'border-' + name;
	            var camelCase = toCamelCase(borderName);
	            var val = tooltipModel.get(camelCase);
	            val != null &&
	                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));
	        });
	
	        // Text style
	        cssText.push(assembleFont(textStyleModel));
	
	        // Padding
	        if (padding != null) {
	            cssText.push('padding:' + normalizeCssArray(padding).join('px ') + 'px');
	        }
	
	        return cssText.join(';') + ';';
	    }
	    /**
	     *
	     *
	     * @param {any} container
	     * @param {any} api
	     */
	    function TooltipContent(container, api) {
	        var el = document.createElement('div');
	        var zr = this._zr = api.getZr();
	
	        this.el = el;
	
	        this._x = api.getWidth() / 2;
	        this._y = api.getHeight() / 2;
	
	        container.appendChild(el);
	
	        this._container = container;
	
	        this._show = false;
	
	        /**
	         * @private
	         */
	        this._hideTimeout;
	
	        var self = this;
	        el.onmouseenter = function () {
	            // clear the timeout in hideLater and keep showing tooltip
	            if (self._enterable) {
	                clearTimeout(self._hideTimeout);
	                self._show = true;
	            }
	            self._inContent = true;
	        };
	        el.onmousemove = function (e) {
	            e = e || window.event;
	            if (!self._enterable) {
	                // Try trigger zrender event to avoid mouse
	                // in and out shape too frequently
	                var handler = zr.handler;
	                eventUtil.normalizeEvent(container, e, true);
	                handler.dispatch('mousemove', e);
	            }
	        };
	        el.onmouseleave = function () {
	            if (self._enterable) {
	                if (self._show) {
	                    self.hideLater(self._hideDelay);
	                }
	            }
	            self._inContent = false;
	        };
	    }
	    TooltipContent.prototype = {
	
	        constructor: TooltipContent,
	
	        /**
	         * @private
	         * @type {boolean}
	         */
	        _enterable: true,
	
	        /**
	         * Update when tooltip is rendered
	         */
	        update: function () {
	            // FIXME
	            // Move this logic to ec main?
	            var container = this._container;
	            var stl = container.currentStyle
	                || document.defaultView.getComputedStyle(container);
	            var domStyle = container.style;
	            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {
	                domStyle.position = 'relative';
	            }
	            // Hide the tooltip
	            // PENDING
	            // this.hide();
	        },
	
	        show: function (tooltipModel) {
	            clearTimeout(this._hideTimeout);
	            var el = this.el;
	
	            el.style.cssText = gCssText + assembleCssText(tooltipModel)
	                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore
	                + ';left:' + this._x + 'px;top:' + this._y + 'px;'
	                + (tooltipModel.get('extraCssText') || '');
	
	            el.style.display = el.innerHTML ?  'block' : 'none';
	
	            this._show = true;
	        },
	
	        setContent: function (content) {
	            this.el.innerHTML = content;
	        },
	
	        setEnterable: function (enterable) {
	            this._enterable = enterable;
	        },
	
	        getSize: function () {
	            var el = this.el;
	            return [el.clientWidth, el.clientHeight];
	        },
	
	        moveTo: function (x, y) {
	            // xy should be based on canvas root. But tooltipContent is
	            // the sibling of canvas root. So padding of ec container
	            // should be considered here.
	            var zr = this._zr;
	            var viewportRoot;
	            if (zr && zr.painter && (viewportRoot = zr.painter.getViewportRoot())) {
	                x += viewportRoot.offsetLeft || 0;
	                y += viewportRoot.offsetTop || 0;
	            }
	
	            var style = this.el.style;
	            style.left = x + 'px';
	            style.top = y + 'px';
	
	            this._x = x;
	            this._y = y;
	        },
	
	        hide: function () {
	            this.el.style.display = 'none';
	            this._show = false;
	        },
	
	        hideLater: function (time) {
	            if (this._show && !(this._inContent && this._enterable)) {
	                if (time) {
	                    this._hideDelay = time;
	                    // Set show false to avoid invoke hideLater mutiple times
	                    this._show = false;
	                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);
	                }
	                else {
	                    this.hide();
	                }
	            }
	        },
	
	        isShow: function () {
	            return this._show;
	        }
	    };
	
	    module.exports = TooltipContent;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var env = __webpack_require__(50);
	    var zrUtil = __webpack_require__(5);
	    var get = __webpack_require__(94).makeGetter();
	
	    var each = zrUtil.each;
	
	    var globalListener = {};
	
	    /**
	     * @param key 注册的字符串
	     * @param api ExtensionAPI
	     * @param handler 处理回调
	     */
	    globalListener.register = function (key, api, handler) {
	        if (env.node) {   //node环境下不执行
	            return;
	        }
	        //判断zrender的 records  并初始化
	        var zr = api.getZr();
	        get(zr).records || (get(zr).records = {});
	
	        initGlobalListeners(zr, api);
	
	        //将回调加入record
	        var record = get(zr).records[key] || (get(zr).records[key] = {});
	        record.handler = handler;
	    };
	
	    /**
	     * 初始化全局侦听
	     *
	     * @param {object} zr   zrender
	     * @param {object} api  ExtensionAPI
	     * @returns
	     */
	    function initGlobalListeners(zr, api) {
	        if (get(zr).initialized) {   //避免重复初始化
	            return;
	        }
	
	        get(zr).initialized = true;
	
	        //侦听事件
	        useHandler('click', zrUtil.curry(doEnter, 'click'));
	        useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove'));
	        // useHandler('mouseout', onLeave);
	        useHandler('globalout', onLeave);
	
	        function useHandler(eventType, cb) {
	            zr.on(eventType, function (e) {
	                var dis = makeDispatchAction(api);
	                //遍历注册的 所有records， 并进行调用
	                each(get(zr).records, function (record) {
	                    record && cb(record, e, dis.dispatchAction);
	                });
	
	                dispatchTooltipFinally(dis.pendings, api);
	            });
	        }
	    }
	
	    function dispatchTooltipFinally(pendings, api) {
	        var showLen = pendings.showTip.length;
	        var hideLen = pendings.hideTip.length;
	
	        var actuallyPayload;
	        if (showLen) {
	            actuallyPayload = pendings.showTip[showLen - 1];
	        }
	        else if (hideLen) {
	            actuallyPayload = pendings.hideTip[hideLen - 1];
	        }
	        if (actuallyPayload) {
	            actuallyPayload.dispatchAction = null;
	            api.dispatchAction(actuallyPayload);
	        }
	    }
	
	    function onLeave(record, e, dispatchAction) {
	        record.handler('leave', null, dispatchAction);
	    }
	
	    function doEnter(currTrigger, record, e, dispatchAction) {
	        record.handler(currTrigger, e, dispatchAction);
	    }
	
	    /**
	     * 派发action   行将发生的
	     *
	     * @param {any} api
	     * @returns
	     */
	    function makeDispatchAction(api) {
	        var pendings = {
	            showTip: [],
	            hideTip: []
	        };
	        // FIXME
	        // better approach?
	        // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,
	        // which may be conflict, (axisPointer call showTip but tooltip call hideTip);
	        // So we have to add "final stage" to merge those dispatched actions.
	        var dispatchAction = function (payload) {
	            var pendingList = pendings[payload.type];
	            if (pendingList) {
	                pendingList.push(payload);
	            }
	            else {
	                payload.dispatchAction = dispatchAction;
	                api.dispatchAction(payload);
	            }
	        };
	
	        return {
	            dispatchAction: dispatchAction,
	            pendings: pendings
	        };
	    }
	
	    /**
	     * @param {string} key
	     * @param {module:echarts/ExtensionAPI} api
	     */
	    globalListener.unregister = function (key, api) {
	        if (env.node) {
	            return;
	        }
	        var zr = api.getZr();
	        var record = (get(zr).records || {})[key];
	        if (record) {
	            get(zr).records[key] = null;
	        }
	    };
	
	    module.exports = globalListener;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	    var Model = __webpack_require__(87);
	    module.exports = Model.extend({
	
	        type: 'tooltip',
	
	        defaultOption: {
	            zlevel: 0,
	
	            z: 8,
	
	            show: true,
	
	            // tooltip主体内容
	            showContent: true,
	
	
	
	            // 'click' | 'mousemove' | 'none'
	            triggerOn: 'mousemove',
	
	            alwaysShowContent: false,
	
	            displayMode: 'single', // 'single' | 'multipleByCoordSys'
	
	            // 位置 {Array} | {Function}
	            // position: null
	            // Consider triggered from axisPointer handle, verticalAlign should be 'middle'
	            // align: null,
	            // verticalAlign: null,
	
	            // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。
	            confine: false,
	
	            // 内容格式器：{string}（Template） ¦ {Function}
	            // formatter: null
	
	            showDelay: 0,
	
	            // 隐藏延迟，单位ms
	            hideDelay: 100,
	
	            // 动画变换时间，单位s
	            transitionDuration: 0.4,
	
	            enterable: false,
	
	            // 提示背景颜色，默认为透明度为0.7的黑色
	            backgroundColor: 'rgba(50,50,50,0.7)',
	
	            // 提示边框颜色
	            borderColor: '#333',
	
	            // 提示边框圆角，单位px，默认为4
	            borderRadius: 4,
	
	            // 提示边框线宽，单位px，默认为0（无边框）
	            borderWidth: 0,
	
	            // 提示内边距，单位px，默认各方向内边距为5，
	            // 接受数组分别设定上右下左边距，同css
	            padding: 5,
	
	            // Extra css text
	            extraCssText: '',
	
	            textStyle: {
	                color: '#fff',
	                fontSize: 14
	            }
	        }
	    });


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	
	    __webpack_require__(137);
	    __webpack_require__(69).registerPainter('vml', __webpack_require__(139));


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	// http://www.w3.org/TR/NOTE-VML
	// TODO Use proxy like svg instead of overwrite brush methods
	
	
	if (!__webpack_require__(50).canvasSupported) {
	    var vec2 = __webpack_require__(15);
	    var BoundingRect = __webpack_require__(27);
	    var CMD = __webpack_require__(30).CMD;
	    var colorTool = __webpack_require__(20);
	    var textContain = __webpack_require__(26);
	    var textHelper = __webpack_require__(25);
	    var RectText = __webpack_require__(24);
	    var Displayable = __webpack_require__(8);
	    var ZImage = __webpack_require__(45);
	    var Text = __webpack_require__(46);
	    var Path = __webpack_require__(7);
	    var PathProxy = __webpack_require__(30);
	
	    var Gradient = __webpack_require__(42);
	
	    var vmlCore = __webpack_require__(138);
	
	    var round = Math.round;
	    var sqrt = Math.sqrt;
	    var abs = Math.abs;
	    var cos = Math.cos;
	    var sin = Math.sin;
	    var mathMax = Math.max;
	
	    var applyTransform = vec2.applyTransform;
	
	    var comma = ',';
	    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';
	
	    var Z = 21600;
	    var Z2 = Z / 2;
	
	    var ZLEVEL_BASE = 100000;
	    var Z_BASE = 1000;
	
	    var initRootElStyle = function (el) {
	        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';
	        el.coordsize = Z + ','  + Z;
	        el.coordorigin = '0,0';
	    };
	
	    var encodeHtmlAttribute = function (s) {
	        return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
	    };
	
	    var rgb2Str = function (r, g, b) {
	        return 'rgb(' + [r, g, b].join(',') + ')';
	    };
	
	    var append = function (parent, child) {
	        if (child && parent && child.parentNode !== parent) {
	            parent.appendChild(child);
	        }
	    };
	
	    var remove = function (parent, child) {
	        if (child && parent && child.parentNode === parent) {
	            parent.removeChild(child);
	        }
	    };
	
	    var getZIndex = function (zlevel, z, z2) {
	        // z 的取值范围为 [0, 1000]
	        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
	    };
	
	    var parsePercent = function (value, maxValue) {
	        if (typeof value === 'string') {
	            if (value.lastIndexOf('%') >= 0) {
	                return parseFloat(value) / 100 * maxValue;
	            }
	            return parseFloat(value);
	        }
	        return value;
	    };
	
	    /***************************************************
	     * PATH
	     **************************************************/
	
	    var setColorAndOpacity = function (el, color, opacity) {
	        var colorArr = colorTool.parse(color);
	        opacity = +opacity;
	        if (isNaN(opacity)) {
	            opacity = 1;
	        }
	        if (colorArr) {
	            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
	            el.opacity = opacity * colorArr[3];
	        }
	    };
	
	    var getColorAndAlpha = function (color) {
	        var colorArr = colorTool.parse(color);
	        return [
	            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),
	            colorArr[3]
	        ];
	    };
	
	    var updateFillNode = function (el, style, zrEl) {
	        // TODO pattern
	        var fill = style.fill;
	        if (fill != null) {
	            // Modified from excanvas
	            if (fill instanceof Gradient) {
	                var gradientType;
	                var angle = 0;
	                var focus = [0, 0];
	                // additional offset
	                var shift = 0;
	                // scale factor for offset
	                var expansion = 1;
	                var rect = zrEl.getBoundingRect();
	                var rectWidth = rect.width;
	                var rectHeight = rect.height;
	                if (fill.type === 'linear') {
	                    gradientType = 'gradient';
	                    var transform = zrEl.transform;
	                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];
	                    if (transform) {
	                        applyTransform(p0, p0, transform);
	                        applyTransform(p1, p1, transform);
	                    }
	                    var dx = p1[0] - p0[0];
	                    var dy = p1[1] - p0[1];
	                    angle = Math.atan2(dx, dy) * 180 / Math.PI;
	                    // The angle should be a non-negative number.
	                    if (angle < 0) {
	                        angle += 360;
	                    }
	
	                    // Very small angles produce an unexpected result because they are
	                    // converted to a scientific notation string.
	                    if (angle < 1e-6) {
	                        angle = 0;
	                    }
	                }
	                else {
	                    gradientType = 'gradientradial';
	                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];
	                    var transform = zrEl.transform;
	                    var scale = zrEl.scale;
	                    var width = rectWidth;
	                    var height = rectHeight;
	                    focus = [
	                        // Percent in bounding rect
	                        (p0[0] - rect.x) / width,
	                        (p0[1] - rect.y) / height
	                    ];
	                    if (transform) {
	                        applyTransform(p0, p0, transform);
	                    }
	
	                    width /= scale[0] * Z;
	                    height /= scale[1] * Z;
	                    var dimension = mathMax(width, height);
	                    shift = 2 * 0 / dimension;
	                    expansion = 2 * fill.r / dimension - shift;
	                }
	
	                // We need to sort the color stops in ascending order by offset,
	                // otherwise IE won't interpret it correctly.
	                var stops = fill.colorStops.slice();
	                stops.sort(function(cs1, cs2) {
	                    return cs1.offset - cs2.offset;
	                });
	
	                var length = stops.length;
	                // Color and alpha list of first and last stop
	                var colorAndAlphaList = [];
	                var colors = [];
	                for (var i = 0; i < length; i++) {
	                    var stop = stops[i];
	                    var colorAndAlpha = getColorAndAlpha(stop.color);
	                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);
	                    if (i === 0 || i === length - 1) {
	                        colorAndAlphaList.push(colorAndAlpha);
	                    }
	                }
	
	                if (length >= 2) {
	                    var color1 = colorAndAlphaList[0][0];
	                    var color2 = colorAndAlphaList[1][0];
	                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;
	                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;
	
	                    el.type = gradientType;
	                    el.method = 'none';
	                    el.focus = '100%';
	                    el.angle = angle;
	                    el.color = color1;
	                    el.color2 = color2;
	                    el.colors = colors.join(',');
	                    // When colors attribute is used, the meanings of opacity and o:opacity2
	                    // are reversed.
	                    el.opacity = opacity2;
	                    // FIXME g_o_:opacity ?
	                    el.opacity2 = opacity1;
	                }
	                if (gradientType === 'radial') {
	                    el.focusposition = focus.join(',');
	                }
	            }
	            else {
	                // FIXME Change from Gradient fill to color fill
	                setColorAndOpacity(el, fill, style.opacity);
	            }
	        }
	    };
	
	    var updateStrokeNode = function (el, style) {
	        // if (style.lineJoin != null) {
	        //     el.joinstyle = style.lineJoin;
	        // }
	        // if (style.miterLimit != null) {
	        //     el.miterlimit = style.miterLimit * Z;
	        // }
	        // if (style.lineCap != null) {
	        //     el.endcap = style.lineCap;
	        // }
	        if (style.lineDash != null) {
	            el.dashstyle = style.lineDash.join(' ');
	        }
	        if (style.stroke != null && !(style.stroke instanceof Gradient)) {
	            setColorAndOpacity(el, style.stroke, style.opacity);
	        }
	    };
	
	    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {
	        var isFill = type == 'fill';
	        var el = vmlEl.getElementsByTagName(type)[0];
	        // Stroke must have lineWidth
	        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {
	            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';
	            // FIXME Remove before updating, or set `colors` will throw error
	            if (style[type] instanceof Gradient) {
	                remove(vmlEl, el);
	            }
	            if (!el) {
	                el = vmlCore.createNode(type);
	            }
	
	            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
	            append(vmlEl, el);
	        }
	        else {
	            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';
	            remove(vmlEl, el);
	        }
	    };
	
	    var points = [[], [], []];
	    var pathDataToString = function (data, m) {
	        var M = CMD.M;
	        var C = CMD.C;
	        var L = CMD.L;
	        var A = CMD.A;
	        var Q = CMD.Q;
	
	        var str = [];
	        var nPoint;
	        var cmdStr;
	        var cmd;
	        var i;
	        var xi;
	        var yi;
	        for (i = 0; i < data.length;) {
	            cmd = data[i++];
	            cmdStr = '';
	            nPoint = 0;
	            switch (cmd) {
	                case M:
	                    cmdStr = ' m ';
	                    nPoint = 1;
	                    xi = data[i++];
	                    yi = data[i++];
	                    points[0][0] = xi;
	                    points[0][1] = yi;
	                    break;
	                case L:
	                    cmdStr = ' l ';
	                    nPoint = 1;
	                    xi = data[i++];
	                    yi = data[i++];
	                    points[0][0] = xi;
	                    points[0][1] = yi;
	                    break;
	                case Q:
	                case C:
	                    cmdStr = ' c ';
	                    nPoint = 3;
	                    var x1 = data[i++];
	                    var y1 = data[i++];
	                    var x2 = data[i++];
	                    var y2 = data[i++];
	                    var x3;
	                    var y3;
	                    if (cmd === Q) {
	                        // Convert quadratic to cubic using degree elevation
	                        x3 = x2;
	                        y3 = y2;
	                        x2 = (x2 + 2 * x1) / 3;
	                        y2 = (y2 + 2 * y1) / 3;
	                        x1 = (xi + 2 * x1) / 3;
	                        y1 = (yi + 2 * y1) / 3;
	                    }
	                    else {
	                        x3 = data[i++];
	                        y3 = data[i++];
	                    }
	                    points[0][0] = x1;
	                    points[0][1] = y1;
	                    points[1][0] = x2;
	                    points[1][1] = y2;
	                    points[2][0] = x3;
	                    points[2][1] = y3;
	
	                    xi = x3;
	                    yi = y3;
	                    break;
	                case A:
	                    var x = 0;
	                    var y = 0;
	                    var sx = 1;
	                    var sy = 1;
	                    var angle = 0;
	                    if (m) {
	                        // Extract SRT from matrix
	                        x = m[4];
	                        y = m[5];
	                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);
	                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);
	                        angle = Math.atan2(-m[1] / sy, m[0] / sx);
	                    }
	
	                    var cx = data[i++];
	                    var cy = data[i++];
	                    var rx = data[i++];
	                    var ry = data[i++];
	                    var startAngle = data[i++] + angle;
	                    var endAngle = data[i++] + startAngle + angle;
	                    // FIXME
	                    // var psi = data[i++];
	                    i++;
	                    var clockwise = data[i++];
	
	                    var x0 = cx + cos(startAngle) * rx;
	                    var y0 = cy + sin(startAngle) * ry;
	
	                    var x1 = cx + cos(endAngle) * rx;
	                    var y1 = cy + sin(endAngle) * ry;
	
	                    var type = clockwise ? ' wa ' : ' at ';
	                    if (Math.abs(x0 - x1) < 1e-4) {
	                        // IE won't render arches drawn counter clockwise if x0 == x1.
	                        if (Math.abs(endAngle - startAngle) > 1e-2) {
	                            // Offset x0 by 1/80 of a pixel. Use something
	                            // that can be represented in binary
	                            if (clockwise) {
	                                x0 += 270 / Z;
	                            }
	                        }
	                        else {
	                            // Avoid case draw full circle
	                            if (Math.abs(y0 - cy) < 1e-4) {
	                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {
	                                    y1 -= 270 / Z;
	                                }
	                                else {
	                                    y1 += 270 / Z;
	                                }
	                            }
	                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {
	                                x1 += 270 / Z;
	                            }
	                            else {
	                                x1 -= 270 / Z;
	                            }
	                        }
	                    }
	                    str.push(
	                        type,
	                        round(((cx - rx) * sx + x) * Z - Z2), comma,
	                        round(((cy - ry) * sy + y) * Z - Z2), comma,
	                        round(((cx + rx) * sx + x) * Z - Z2), comma,
	                        round(((cy + ry) * sy + y) * Z - Z2), comma,
	                        round((x0 * sx + x) * Z - Z2), comma,
	                        round((y0 * sy + y) * Z - Z2), comma,
	                        round((x1 * sx + x) * Z - Z2), comma,
	                        round((y1 * sy + y) * Z - Z2)
	                    );
	
	                    xi = x1;
	                    yi = y1;
	                    break;
	                case CMD.R:
	                    var p0 = points[0];
	                    var p1 = points[1];
	                    // x0, y0
	                    p0[0] = data[i++];
	                    p0[1] = data[i++];
	                    // x1, y1
	                    p1[0] = p0[0] + data[i++];
	                    p1[1] = p0[1] + data[i++];
	
	                    if (m) {
	                        applyTransform(p0, p0, m);
	                        applyTransform(p1, p1, m);
	                    }
	
	                    p0[0] = round(p0[0] * Z - Z2);
	                    p1[0] = round(p1[0] * Z - Z2);
	                    p0[1] = round(p0[1] * Z - Z2);
	                    p1[1] = round(p1[1] * Z - Z2);
	                    str.push(
	                        // x0, y0
	                        ' m ', p0[0], comma, p0[1],
	                        // x1, y0
	                        ' l ', p1[0], comma, p0[1],
	                        // x1, y1
	                        ' l ', p1[0], comma, p1[1],
	                        // x0, y1
	                        ' l ', p0[0], comma, p1[1]
	                    );
	                    break;
	                case CMD.Z:
	                    // FIXME Update xi, yi
	                    str.push(' x ');
	            }
	
	            if (nPoint > 0) {
	                str.push(cmdStr);
	                for (var k = 0; k < nPoint; k++) {
	                    var p = points[k];
	
	                    m && applyTransform(p, p, m);
	                    // 不 round 会非常慢
	                    str.push(
	                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),
	                        k < nPoint - 1 ? comma : ''
	                    );
	                }
	            }
	        }
	
	        return str.join('');
	    };
	
	    // Rewrite the original path method
	    Path.prototype.brushVML = function (vmlRoot) {
	        var style = this.style;
	
	        var vmlEl = this._vmlEl;
	        if (!vmlEl) {
	            vmlEl = vmlCore.createNode('shape');
	            initRootElStyle(vmlEl);
	
	            this._vmlEl = vmlEl;
	        }
	
	        updateFillAndStroke(vmlEl, 'fill', style, this);
	        updateFillAndStroke(vmlEl, 'stroke', style, this);
	
	        var m = this.transform;
	        var needTransform = m != null;
	        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];
	        if (strokeEl) {
	            var lineWidth = style.lineWidth;
	            // Get the line scale.
	            // Determinant of this.m_ means how much the area is enlarged by the
	            // transformation. So its square root can be used as a scale factor
	            // for width.
	            if (needTransform && !style.strokeNoScale) {
	                var det = m[0] * m[3] - m[1] * m[2];
	                lineWidth *= sqrt(abs(det));
	            }
	            strokeEl.weight = lineWidth + 'px';
	        }
	
	        var path = this.path || (this.path = new PathProxy());
	        if (this.__dirtyPath) {
	            path.beginPath();
	            this.buildPath(path, this.shape);
	            path.toStatic();
	            this.__dirtyPath = false;
	        }
	
	        vmlEl.path = pathDataToString(path.data, this.transform);
	
	        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
	
	        // Append to root
	        append(vmlRoot, vmlEl);
	
	        // Text
	        if (style.text != null) {
	            this.drawRectText(vmlRoot, this.getBoundingRect());
	        }
	        else {
	            this.removeRectText(vmlRoot);
	        }
	    };
	
	    Path.prototype.onRemove = function (vmlRoot) {
	        remove(vmlRoot, this._vmlEl);
	        this.removeRectText(vmlRoot);
	    };
	
	    Path.prototype.onAdd = function (vmlRoot) {
	        append(vmlRoot, this._vmlEl);
	        this.appendRectText(vmlRoot);
	    };
	
	    /***************************************************
	     * IMAGE
	     **************************************************/
	    var isImage = function (img) {
	        // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错
	        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';
	        // return img instanceof Image;
	    };
	
	    // Rewrite the original path method
	    ZImage.prototype.brushVML = function (vmlRoot) {
	        var style = this.style;
	        var image = style.image;
	
	        // Image original width, height
	        var ow;
	        var oh;
	
	        if (isImage(image)) {
	            var src = image.src;
	            if (src === this._imageSrc) {
	                ow = this._imageWidth;
	                oh = this._imageHeight;
	            }
	            else {
	                var imageRuntimeStyle = image.runtimeStyle;
	                var oldRuntimeWidth = imageRuntimeStyle.width;
	                var oldRuntimeHeight = imageRuntimeStyle.height;
	                imageRuntimeStyle.width = 'auto';
	                imageRuntimeStyle.height = 'auto';
	
	                // get the original size
	                ow = image.width;
	                oh = image.height;
	
	                // and remove overides
	                imageRuntimeStyle.width = oldRuntimeWidth;
	                imageRuntimeStyle.height = oldRuntimeHeight;
	
	                // Caching image original width, height and src
	                this._imageSrc = src;
	                this._imageWidth = ow;
	                this._imageHeight = oh;
	            }
	            image = src;
	        }
	        else {
	            if (image === this._imageSrc) {
	                ow = this._imageWidth;
	                oh = this._imageHeight;
	            }
	        }
	        if (!image) {
	            return;
	        }
	
	        var x = style.x || 0;
	        var y = style.y || 0;
	
	        var dw = style.width;
	        var dh = style.height;
	
	        var sw = style.sWidth;
	        var sh = style.sHeight;
	        var sx = style.sx || 0;
	        var sy = style.sy || 0;
	
	        var hasCrop = sw && sh;
	
	        var vmlEl = this._vmlEl;
	        if (!vmlEl) {
	            // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。
	            // vmlEl = vmlCore.createNode('group');
	            vmlEl = vmlCore.doc.createElement('div');
	            initRootElStyle(vmlEl);
	
	            this._vmlEl = vmlEl;
	        }
	
	        var vmlElStyle = vmlEl.style;
	        var hasRotation = false;
	        var m;
	        var scaleX = 1;
	        var scaleY = 1;
	        if (this.transform) {
	            m = this.transform;
	            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
	            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
	
	            hasRotation = m[1] || m[2];
	        }
	        if (hasRotation) {
	            // If filters are necessary (rotation exists), create them
	            // filters are bog-slow, so only create them if abbsolutely necessary
	            // The following check doesn't account for skews (which don't exist
	            // in the canvas spec (yet) anyway.
	            // From excanvas
	            var p0 = [x, y];
	            var p1 = [x + dw, y];
	            var p2 = [x, y + dh];
	            var p3 = [x + dw, y + dh];
	            applyTransform(p0, p0, m);
	            applyTransform(p1, p1, m);
	            applyTransform(p2, p2, m);
	            applyTransform(p3, p3, m);
	
	            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
	            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
	
	            var transformFilter = [];
	            transformFilter.push('M11=', m[0] / scaleX, comma,
	                        'M12=', m[2] / scaleY, comma,
	                        'M21=', m[1] / scaleX, comma,
	                        'M22=', m[3] / scaleY, comma,
	                        'Dx=', round(x * scaleX + m[4]), comma,
	                        'Dy=', round(y * scaleY + m[5]));
	
	            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';
	            // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用
	            vmlElStyle.filter = imageTransformPrefix + '.Matrix('
	                + transformFilter.join('') + ', SizingMethod=clip)';
	
	        }
	        else {
	            if (m) {
	                x = x * scaleX + m[4];
	                y = y * scaleY + m[5];
	            }
	            vmlElStyle.filter = '';
	            vmlElStyle.left = round(x) + 'px';
	            vmlElStyle.top = round(y) + 'px';
	        }
	
	        var imageEl = this._imageEl;
	        var cropEl = this._cropEl;
	
	        if (!imageEl) {
	            imageEl = vmlCore.doc.createElement('div');
	            this._imageEl = imageEl;
	        }
	        var imageELStyle = imageEl.style;
	        if (hasCrop) {
	            // Needs know image original width and height
	            if (! (ow && oh)) {
	                var tmpImage = new Image();
	                var self = this;
	                tmpImage.onload = function () {
	                    tmpImage.onload = null;
	                    ow = tmpImage.width;
	                    oh = tmpImage.height;
	                    // Adjust image width and height to fit the ratio destinationSize / sourceSize
	                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
	
	                    // Caching image original width, height and src
	                    self._imageWidth = ow;
	                    self._imageHeight = oh;
	                    self._imageSrc = image;
	                };
	                tmpImage.src = image;
	            }
	            else {
	                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
	                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
	            }
	
	            if (! cropEl) {
	                cropEl = vmlCore.doc.createElement('div');
	                cropEl.style.overflow = 'hidden';
	                this._cropEl = cropEl;
	            }
	            var cropElStyle = cropEl.style;
	            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
	            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
	            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='
	                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';
	
	            if (! cropEl.parentNode) {
	                vmlEl.appendChild(cropEl);
	            }
	            if (imageEl.parentNode != cropEl) {
	                cropEl.appendChild(imageEl);
	            }
	        }
	        else {
	            imageELStyle.width = round(scaleX * dw) + 'px';
	            imageELStyle.height = round(scaleY * dh) + 'px';
	
	            vmlEl.appendChild(imageEl);
	
	            if (cropEl && cropEl.parentNode) {
	                vmlEl.removeChild(cropEl);
	                this._cropEl = null;
	            }
	        }
	
	        var filterStr = '';
	        var alpha = style.opacity;
	        if (alpha < 1) {
	            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';
	        }
	        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';
	
	        imageELStyle.filter = filterStr;
	
	        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
	
	        // Append to root
	        append(vmlRoot, vmlEl);
	
	        // Text
	        if (style.text != null) {
	            this.drawRectText(vmlRoot, this.getBoundingRect());
	        }
	    };
	
	    ZImage.prototype.onRemove = function (vmlRoot) {
	        remove(vmlRoot, this._vmlEl);
	
	        this._vmlEl = null;
	        this._cropEl = null;
	        this._imageEl = null;
	
	        this.removeRectText(vmlRoot);
	    };
	
	    ZImage.prototype.onAdd = function (vmlRoot) {
	        append(vmlRoot, this._vmlEl);
	        this.appendRectText(vmlRoot);
	    };
	
	
	    /***************************************************
	     * TEXT
	     **************************************************/
	
	    var DEFAULT_STYLE_NORMAL = 'normal';
	
	    var fontStyleCache = {};
	    var fontStyleCacheCount = 0;
	    var MAX_FONT_CACHE_SIZE = 100;
	    var fontEl = document.createElement('div');
	
	    var getFontStyle = function (fontString) {
	        var fontStyle = fontStyleCache[fontString];
	        if (!fontStyle) {
	            // Clear cache
	            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
	                fontStyleCacheCount = 0;
	                fontStyleCache = {};
	            }
	
	            var style = fontEl.style;
	            var fontFamily;
	            try {
	                style.font = fontString;
	                fontFamily = style.fontFamily.split(',')[0];
	            }
	            catch (e) {
	            }
	
	            fontStyle = {
	                style: style.fontStyle || DEFAULT_STYLE_NORMAL,
	                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
	                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
	                size: parseFloat(style.fontSize || 12) | 0,
	                family: fontFamily || 'Microsoft YaHei'
	            };
	
	            fontStyleCache[fontString] = fontStyle;
	            fontStyleCacheCount++;
	        }
	        return fontStyle;
	    };
	
	    var textMeasureEl;
	    // Overwrite measure text method
	    textContain.measureText = function (text, textFont) {
	        var doc = vmlCore.doc;
	        if (!textMeasureEl) {
	            textMeasureEl = doc.createElement('div');
	            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'
	                + 'padding:0;margin:0;border:none;white-space:pre;';
	            vmlCore.doc.body.appendChild(textMeasureEl);
	        }
	
	        try {
	            textMeasureEl.style.font = textFont;
	        } catch (ex) {
	            // Ignore failures to set to invalid font.
	        }
	        textMeasureEl.innerHTML = '';
	        // Don't use innerHTML or innerText because they allow markup/whitespace.
	        textMeasureEl.appendChild(doc.createTextNode(text));
	        return {
	            width: textMeasureEl.offsetWidth
	        };
	    };
	
	    var tmpRect = new BoundingRect();
	
	    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {
	
	        var style = this.style;
	
	        // Optimize, avoid normalize every time.
	        this.__dirty && textHelper.normalizeTextStyle(style, true);
	
	        var text = style.text;
	        // Convert to string
	        text != null && (text += '');
	        if (!text) {
	            return;
	        }
	
	        // Convert rich text to plain text. Rich text is not supported in
	        // IE8-, but tags in rich text template will be removed.
	        if (style.rich) {
	            var contentBlock = textContain.parseRichText(text, style);
	            text = [];
	            for (var i = 0; i < contentBlock.lines.length; i++) {
	                var tokens = contentBlock.lines[i].tokens;
	                var textLine = [];
	                for (var j = 0; j < tokens.length; j++) {
	                    textLine.push(tokens[j].text);
	                }
	                text.push(textLine.join(''));
	            }
	            text = text.join('\n');
	        }
	
	        var x;
	        var y;
	        var align = style.textAlign;
	        var verticalAlign = style.textVerticalAlign;
	
	        var fontStyle = getFontStyle(style.font);
	        // FIXME encodeHtmlAttribute ?
	        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '
	            + fontStyle.size + 'px "' + fontStyle.family + '"';
	
	        textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign);
	
	        // Transform rect to view space
	        var m = this.transform;
	        // Ignore transform for text in other element
	        if (m && !fromTextEl) {
	            tmpRect.copy(rect);
	            tmpRect.applyTransform(m);
	            rect = tmpRect;
	        }
	
	        if (!fromTextEl) {
	            var textPosition = style.textPosition;
	            var distance = style.textDistance;
	            // Text position represented by coord
	            if (textPosition instanceof Array) {
	                x = rect.x + parsePercent(textPosition[0], rect.width);
	                y = rect.y + parsePercent(textPosition[1], rect.height);
	
	                align = align || 'left';
	            }
	            else {
	                var res = textContain.adjustTextPositionOnRect(
	                    textPosition, rect, distance
	                );
	                x = res.x;
	                y = res.y;
	
	                // Default align and baseline when has textPosition
	                align = align || res.textAlign;
	                verticalAlign = verticalAlign || res.textVerticalAlign;
	            }
	        }
	        else {
	            x = rect.x;
	            y = rect.y;
	        }
	
	        x = textContain.adjustTextX(x, textRect.width, align);
	        y = textContain.adjustTextY(y, textRect.height, verticalAlign);
	
	        // Force baseline 'middle'
	        y += textRect.height / 2;
	
	        // var fontSize = fontStyle.size;
	        // 1.75 is an arbitrary number, as there is no info about the text baseline
	        // switch (baseline) {
	            // case 'hanging':
	            // case 'top':
	            //     y += fontSize / 1.75;
	            //     break;
	        //     case 'middle':
	        //         break;
	        //     default:
	        //     // case null:
	        //     // case 'alphabetic':
	        //     // case 'ideographic':
	        //     // case 'bottom':
	        //         y -= fontSize / 2.25;
	        //         break;
	        // }
	
	        // switch (align) {
	        //     case 'left':
	        //         break;
	        //     case 'center':
	        //         x -= textRect.width / 2;
	        //         break;
	        //     case 'right':
	        //         x -= textRect.width;
	        //         break;
	            // case 'end':
	                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';
	                // break;
	            // case 'start':
	                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';
	                // break;
	            // default:
	            //     align = 'left';
	        // }
	
	        var createNode = vmlCore.createNode;
	
	        var textVmlEl = this._textVmlEl;
	        var pathEl;
	        var textPathEl;
	        var skewEl;
	        if (!textVmlEl) {
	            textVmlEl = createNode('line');
	            pathEl = createNode('path');
	            textPathEl = createNode('textpath');
	            skewEl = createNode('skew');
	
	            // FIXME Why here is not cammel case
	            // Align 'center' seems wrong
	            textPathEl.style['v-text-align'] = 'left';
	
	            initRootElStyle(textVmlEl);
	
	            pathEl.textpathok = true;
	            textPathEl.on = true;
	
	            textVmlEl.from = '0 0';
	            textVmlEl.to = '1000 0.05';
	
	            append(textVmlEl, skewEl);
	            append(textVmlEl, pathEl);
	            append(textVmlEl, textPathEl);
	
	            this._textVmlEl = textVmlEl;
	        }
	        else {
	            // 这里是在前面 appendChild 保证顺序的前提下
	            skewEl = textVmlEl.firstChild;
	            pathEl = skewEl.nextSibling;
	            textPathEl = pathEl.nextSibling;
	        }
	
	        var coords = [x, y];
	        var textVmlElStyle = textVmlEl.style;
	        // Ignore transform for text in other element
	        if (m && fromTextEl) {
	            applyTransform(coords, coords, m);
	
	            skewEl.on = true;
	
	            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +
	            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';
	
	            // Text position
	            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);
	            // Left top point as origin
	            skewEl.origin = '0 0';
	
	            textVmlElStyle.left = '0px';
	            textVmlElStyle.top = '0px';
	        }
	        else {
	            skewEl.on = false;
	            textVmlElStyle.left = round(x) + 'px';
	            textVmlElStyle.top = round(y) + 'px';
	        }
	
	        textPathEl.string = encodeHtmlAttribute(text);
	        // TODO
	        try {
	            textPathEl.style.font = font;
	        }
	        // Error font format
	        catch (e) {}
	
	        updateFillAndStroke(textVmlEl, 'fill', {
	            fill: style.textFill,
	            opacity: style.opacity
	        }, this);
	        updateFillAndStroke(textVmlEl, 'stroke', {
	            stroke: style.textStroke,
	            opacity: style.opacity,
	            lineDash: style.lineDash
	        }, this);
	
	        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
	
	        // Attached to root
	        append(vmlRoot, textVmlEl);
	    };
	
	    var removeRectText = function (vmlRoot) {
	        remove(vmlRoot, this._textVmlEl);
	        this._textVmlEl = null;
	    };
	
	    var appendRectText = function (vmlRoot) {
	        append(vmlRoot, this._textVmlEl);
	    };
	
	    var list = [RectText, Displayable, ZImage, Path, Text];
	
	    // In case Displayable has been mixed in RectText
	    for (var i = 0; i < list.length; i++) {
	        var proto = list[i].prototype;
	        proto.drawRectText = drawRectText;
	        proto.removeRectText = removeRectText;
	        proto.appendRectText = appendRectText;
	    }
	
	    Text.prototype.brushVML = function (vmlRoot) {
	        var style = this.style;
	        if (style.text != null) {
	            this.drawRectText(vmlRoot, {
	                x: style.x || 0, y: style.y || 0,
	                width: 0, height: 0
	            }, this.getBoundingRect(), true);
	        }
	        else {
	            this.removeRectText(vmlRoot);
	        }
	    };
	
	    Text.prototype.onRemove = function (vmlRoot) {
	        this.removeRectText(vmlRoot);
	    };
	
	    Text.prototype.onAdd = function (vmlRoot) {
	        this.appendRectText(vmlRoot);
	    };
	}


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	
	
	if (!__webpack_require__(50).canvasSupported) {
	    var urn = 'urn:schemas-microsoft-com:vml';
	
	    var createNode;
	    var win = window;
	    var doc = win.document;
	
	    var vmlInited = false;
	
	    try {
	        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);
	        createNode = function (tagName) {
	            return doc.createElement('<zrvml:' + tagName + ' class="zrvml">');
	        };
	    }
	    catch (e) {
	        createNode = function (tagName) {
	            return doc.createElement('<' + tagName + ' xmlns="' + urn + '" class="zrvml">');
	        };
	    }
	
	    // From raphael
	    var initVML = function () {
	        if (vmlInited) {
	            return;
	        }
	        vmlInited = true;
	
	        var styleSheets = doc.styleSheets;
	        if (styleSheets.length < 31) {
	            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');
	        }
	        else {
	            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
	            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');
	        }
	    };
	
	    // Not useing return to avoid error when converting to CommonJS module
	    module.exports = {
	        doc: doc,
	        initVML: initVML,
	        createNode: createNode
	    };
	}


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * VML Painter.
	 *
	 * @module zrender/vml/Painter
	 */
	
	
	
	    var zrLog = __webpack_require__(22);
	    var vmlCore = __webpack_require__(138);
	
	    function parseInt10(val) {
	        return parseInt(val, 10);
	    }
	
	    /**
	     * @alias module:zrender/vml/Painter
	     */
	    function VMLPainter(root, storage) {
	
	        vmlCore.initVML();
	
	        this.root = root;
	
	        this.storage = storage;
	
	        var vmlViewport = document.createElement('div');
	
	        var vmlRoot = document.createElement('div');
	
	        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';
	
	        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';
	
	        root.appendChild(vmlViewport);
	
	        this._vmlRoot = vmlRoot;
	        this._vmlViewport = vmlViewport;
	
	        this.resize();
	
	        // Modify storage
	        var oldDelFromStorage = storage.delFromStorage;
	        var oldAddToStorage = storage.addToStorage;
	        storage.delFromStorage = function (el) {
	            oldDelFromStorage.call(storage, el);
	
	            if (el) {
	                el.onRemove && el.onRemove(vmlRoot);
	            }
	        };
	
	        storage.addToStorage = function (el) {
	            // Displayable already has a vml node
	            el.onAdd && el.onAdd(vmlRoot);
	
	            oldAddToStorage.call(storage, el);
	        };
	
	        this._firstPaint = true;
	    }
	
	    VMLPainter.prototype = {
	
	        constructor: VMLPainter,
	
	        getType: function () {
	            return 'vml';
	        },
	
	        /**
	         * @return {HTMLDivElement}
	         */
	        getViewportRoot: function () {
	            return this._vmlViewport;
	        },
	
	        getViewportRootOffset: function () {
	            var viewportRoot = this.getViewportRoot();
	            if (viewportRoot) {
	                return {
	                    offsetLeft: viewportRoot.offsetLeft || 0,
	                    offsetTop: viewportRoot.offsetTop || 0
	                };
	            }
	        },
	
	        /**
	         * 刷新
	         */
	        refresh: function () {
	
	            var list = this.storage.getDisplayList(true, true);
	
	            this._paintList(list);
	        },
	
	        _paintList: function (list) {
	            var vmlRoot = this._vmlRoot;
	            for (var i = 0; i < list.length; i++) {
	                var el = list[i];
	                if (el.invisible || el.ignore) {
	                    if (!el.__alreadyNotVisible) {
	                        el.onRemove(vmlRoot);
	                    }
	                    // Set as already invisible
	                    el.__alreadyNotVisible = true;
	                }
	                else {
	                    if (el.__alreadyNotVisible) {
	                        el.onAdd(vmlRoot);
	                    }
	                    el.__alreadyNotVisible = false;
	                    if (el.__dirty) {
	                        el.beforeBrush && el.beforeBrush();
	                        (el.brushVML || el.brush).call(el, vmlRoot);
	                        el.afterBrush && el.afterBrush();
	                    }
	                }
	                el.__dirty = false;
	            }
	
	            if (this._firstPaint) {
	                // Detached from document at first time
	                // to avoid page refreshing too many times
	
	                // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变
	                this._vmlViewport.appendChild(vmlRoot);
	                this._firstPaint = false;
	            }
	        },
	
	        resize: function (width, height) {
	            var width = width == null ? this._getWidth() : width;
	            var height = height == null ? this._getHeight() : height;
	
	            if (this._width != width || this._height != height) {
	                this._width = width;
	                this._height = height;
	
	                var vmlViewportStyle = this._vmlViewport.style;
	                vmlViewportStyle.width = width + 'px';
	                vmlViewportStyle.height = height + 'px';
	            }
	        },
	
	        dispose: function () {
	            this.root.innerHTML = '';
	
	            this._vmlRoot =
	            this._vmlViewport =
	            this.storage = null;
	        },
	
	        getWidth: function () {
	            return this._width;
	        },
	
	        getHeight: function () {
	            return this._height;
	        },
	
	        clear: function () {
	            if (this._vmlViewport) {
	                this.root.removeChild(this._vmlViewport);
	            }
	        },
	
	        _getWidth: function () {
	            var root = this.root;
	            var stl = root.currentStyle;
	
	            return ((root.clientWidth || parseInt10(stl.width))
	                    - parseInt10(stl.paddingLeft)
	                    - parseInt10(stl.paddingRight)) | 0;
	        },
	
	        _getHeight: function () {
	            var root = this.root;
	            var stl = root.currentStyle;
	
	            return ((root.clientHeight || parseInt10(stl.height))
	                    - parseInt10(stl.paddingTop)
	                    - parseInt10(stl.paddingBottom)) | 0;
	        }
	    };
	
	    // Not supported methods
	    function createMethodNotSupport(method) {
	        return function () {
	            zrLog('In IE8.0 VML mode painter not support method "' + method + '"');
	        };
	    }
	
	    var notSupportedMethods = [
	        'getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers',
	        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'
	    ];
	
	    for (var i = 0; i < notSupportedMethods.length; i++) {
	        var name = notSupportedMethods[i];
	        VMLPainter.prototype[name] = createMethodNotSupport(name);
	    }
	
	    module.exports = VMLPainter;


/***/ })
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBlMzc3Mzc1NGNlNDFhNTE3NjM0OSIsIndlYnBhY2s6Ly8vLi9pbmRleC5mbG93LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvRmlzaFRvcG9GbG93LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi90b29sL3BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvRGlzcGxheWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9TdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9FbGVtZW50LmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvcmUvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bC5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9taXhpbi9UcmFuc2Zvcm1hYmxlLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL21peGluL0FuaW1hdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2FuaW1hdGlvbi9DbGlwLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvdG9vbC9jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9jb3JlL0xSVS5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9jb3JlL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9jb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci90ZXh0LmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9pbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9yb3VuZFJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvY29yZS9QYXRoUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvY29yZS9jdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9jb3JlL2Jib3guanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvY29udGFpbi9wYXRoLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvbnRhaW4vbGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9jb250YWluL2N1YmljLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9jb250YWluL3dpbmRpbmdMaW5lLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvUGF0dGVybi5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi90b29sL3RyYW5zZm9ybVBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9taXhpbi9EcmFnZ2FibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0LmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ZpeENsaXBXaXRoU2hhZG93LmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvcmUvZW52LmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seS5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhTcGxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0LmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9ncmFwaGljL1N0YXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21pbmltYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9MaW5lU3RydWN0LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvRXh0ZW5zaW9uQXBpLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL3pyZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvSGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9TdG9yYWdlLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvcmUvdGltc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0aW9uLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvcmUvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi8uMy42LjNAenJlbmRlci9saWIvYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9kb20vSGFuZGxlclByb3h5LmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvcmUvR2VzdHVyZU1nci5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9QYWludGVyLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL0xheWVyLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9PcGVyYXRpb25Ob2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvU3ltYm9sLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0hhbmRsZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9FZmZlY3RMaW5lLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rpb25Qb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21vZGVsLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tY29yZS9saWIvY2xhenouanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL0ljb25PcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9tYW5hZ2VyL0Zsb3dDb25uZWN0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvQ29ubmVjdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Mb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi91dGlsL0Zsb3dDb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi91dGlsL0Zsb3dVdGlsLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9Hcm91cE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL2Zsb3dOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9SZWN0LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0ltYWdlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9UZXh0LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9TZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1JpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0VsbGlwc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0hlYXJ0LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9Ecm9wbGV0LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9Sb3NlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9Jc29nb24uanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1BvbHlsaW5lLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9CZXppZXJDdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvQXJjLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9TdGFyLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9Ucm9jaG9pZC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvSWNvbkJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2xpbmsvZmxvd0xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9saW5rL0xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9GbG93LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGluay9Gb2xkLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGluay9DdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvTGluZU9wZXJhdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvbGF5b3V0LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L0hMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvVkxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2xheW91dC9UcmVlTGF5b3V0LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvZGF0YS9UcmVlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L3RyZWVIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvRm9yY2VMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvZm9yY2VIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9JbWFnZVBvb2wuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi90b29sdGlwL1Rvb2x0aXBWaWV3LmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvdG9vbHRpcC9Ub29sdGlwQ29udGVudC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL3Rvb2x0aXAvZ2xvYmFsTGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi90b29sdGlwL1Rvb2x0aXBNb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi92bWwvdm1sLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL3ZtbC9ncmFwaGljLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL3ZtbC9jb3JlLmpzIiwid2VicGFjazovLy8uL34vLjMuNi4zQHpyZW5kZXIvbGliL3ZtbC9QYWludGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBOEUsV0FBVztBQUN6Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsU0FBUztBQUN4QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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ZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5RUFBd0U7QUFDeEU7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ2hvQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsZUFBZTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZaQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSx5REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDLG9CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsU0FBUztBQUN4QixnQkFBZSxTQUFTO0FBQ3hCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2pYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUEsdUNBQXNDOztBQUV0QyxzQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQSxvQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQSx5Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHdDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxQkFBb0IsU0FBUztBQUM3QixzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakMsb0JBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUMzUUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBOztBQUVBOzs7Ozs7OztBQzVTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQW9CLFFBQVE7QUFDNUIscUJBQW9CLFFBQVE7QUFDNUIscUJBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQW9CLFFBQVE7QUFDNUIscUJBQW9CLFFBQVE7QUFDNUIscUJBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDdFZBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFlO0FBQ2YsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUscUJBQXFCO0FBQ3BDLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7O0FDNWRBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXVCLHFCQUFxQixLQUFLO0FBQ2pEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxlQUFlO0FBQzlCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsT0FBTyxFQUFFO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTyxPQUFPO0FBQzdCLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCLE9BQU8sRUFBRTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1RUFBc0UsV0FBVzs7QUFFakY7QUFDQTtBQUNBO0FBQ0EsNERBQTJELEdBQUc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN2ckJBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFD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QUFFVDtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixRQUFRO0FBQzVCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQix5QkFBeUI7QUFDNUMscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLG9CQUFtQix5QkFBeUI7QUFDNUMscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkIsU0FBUztBQUNwQztBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLG9FQUFvRTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixTQUFTO0FBQ3BDO0FBQ0EsZ0NBQStCLDJCQUEyQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixpQkFBaUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixTQUFTO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ254QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLGVBQWU7QUFDL0IsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFvQztBQUNwQyxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixlQUFlO0FBQy9CLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLGVBQWU7QUFDOUIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsWUFBWTtBQUMzQztBQUNBOztBQUVBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDOVlBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdkNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDcENBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJB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O0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsU0FBUztBQUM3QixzQkFBcUI7QUFDckI7QUFDQTtBQUNBLDRCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLDRCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLDRCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDM1RBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7Ozs7Ozs7O0FDbENMO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE0QyxTQUFTO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNuR0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7Ozs7O0FDNUJMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7Ozs7Ozs7O0FDeENMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7Ozs7Ozs7QUN6REw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxV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QUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsNEJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ2hhQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QixnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtB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LHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsdUJBQXVCO0FBQzNDLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLGNBQWM7QUFDakMsb0JBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7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QSxnQ0FBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBOzs7Ozs7OztBQzFQQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFjLFlBQVk7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXVCLGFBQWE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QkFBbUIsTUFBTTtBQUN6QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE1BQU07QUFDekI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBOztBQUVBOztBQUVBLDBDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBb0U7QUFDcEU7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw0QkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsNEJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLDZCQUE2QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtB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O0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EscUVBQW9FLHNCQUFzQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ2pXQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MsMkNBQTJDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDLDJDQUEyQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Qsd0NBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhDQUE2Qzs7QUFFN0MsNENBQTJDOztBQUUzQyxpREFBZ0Q7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQsb0NBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7QUNqTEE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQztBQUN0QyxxQ0FBb0M7QUFDcEMsb0NBQW1DO0FBQ25DLGtDQUFpQztBQUNqQywrQ0FBOEM7QUFDOUM7QUFDQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQjtBQUMvQiw2QkFBNEI7QUFDNUIseURBQXdEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLFFBQVE7QUFDbEMseUJBQXdCO0FBQ3hCLHFDQUFvQztBQUNwQztBQUNBLGlHQUFnRztBQUNoRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBbUIsWUFBWTtBQUMvQix5QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLG9CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7Ozs7QUN6Y0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE2QjtBQUM3QixrQ0FBaUM7QUFDakMsbUNBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0Esd0JBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLHdCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEwRTs7QUFFMUU7QUFDQTs7QUFFQSxrQ0FBaUM7QUFDakM7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3R0FBdUc7QUFDdkcsd0dBQXVHO0FBQ3ZHLHdHQUF1RztBQUN2Ryx3R0FBdUc7O0FBRXZHO0FBQ0E7QUFDQSxvQ0FBbUMsMkJBQTJCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLHNHQUFxRztBQUNyRyxzR0FBcUc7QUFDckcsc0dBQXFHO0FBQ3JHLHNHQUFxRzs7QUFFckc7QUFDQTtBQUNBLG9DQUFtQywyQkFBMkI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9GQUFtRjs7QUFFbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxRkFBb0Y7O0FBRXBGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0ZBQW1GOztBQUVuRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFGQUFvRjs7QUFFcEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxzQkFBc0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7O0FBRUEsdURBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQW9EO0FBQ3BEO0FBQ0E7O0FBRUEsZ0NBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLHNCQUFzQjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTs7Ozs7OztBQ2pwQkE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7O0FBR1Q7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxtREFBa0Q7QUFDbEQsb0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG1EQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUM7QUFDQSxxQztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCLGlCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXdELFlBQVk7QUFDcEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakMsaUNBQWdDO0FBQ2hDLGlDQUFnQztBQUNoQyxtQ0FBa0M7QUFDbEMsa0NBQWlDO0FBQ2pDOztBQUVBOztBQUVBO0FBQ0Esa0JBQWlCLHVEQUF1RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLHNCQUFzQjtBQUNyQyxnQkFBZSxRQUFRO0FBQ3ZCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLHVCQUF1QjtBQUN0RCw0QkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDalhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUErRSxXQUFXO0FBQzFGO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLHFCQUFvQixvQkFBb0I7QUFDeEMscUJBQW9CLDJDQUEyQztBQUMvRDtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxxQkFBb0Isb0JBQW9CO0FBQ3hDLHFCQUFvQiwyQ0FBMkM7QUFDL0Q7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CLFNBQVM7QUFDN0IscUJBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWIsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0EsVUFBUyxPQUFPO0FBQ2hCOztBQUVBO0FBQ0EsVUFBUyxRQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSTs7Ozs7O0FDblZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQWtGLFdBQVc7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0EsZUFBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDLGtDQUFrQyxFQUFFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFNBQVM7QUFDeEIsZ0JBQWUsU0FBUztBQUN4QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQSxVQUFTLE1BQU07QUFDZjs7QUFFQTtBQUNBLFVBQVMsT0FBTztBQUNoQixVQUFTLE9BQU87QUFDaEIsVUFBUyxPQUFPO0FBQ2hCLFVBQVMsT0FBTztBQUNoQixVQUFTLE1BQU07QUFDZixVQUFTLE9BQU87QUFDaEIsVUFBUyxPQUFPO0FBQ2hCLFVBQVMsT0FBTztBQUNoQixVQUFTLE9BQU87QUFDaEIsVUFBUyxPQUFPO0FBQ2hCLFVBQVMsT0FBTztBQUNoQixVQUFTLE9BQU87QUFDaEIsVUFBUyxPQUFPO0FBQ2hCLFVBQVMsT0FBTztBQUNoQixVQUFTLGFBQWE7QUFDdEIsVUFBUyxPQUFPO0FBQ2hCLFVBQVMsTUFBTTtBQUNmLFVBQVMsT0FBTztBQUNoQixVQUFTLE9BQU87QUFDaEIsVUFBUyxPQUFPO0FBQ2hCLFVBQVMsT0FBTztBQUNoQixVQUFTLE9BQU87QUFDaEIsVUFBUyxPQUFPO0FBQ2hCLFVBQVMsT0FBTztBQUNoQixVQUFTLE9BQU87QUFDaEIsVUFBUyxPQUFPO0FBQ2hCLFVBQVMsT0FBTztBQUNoQixVQUFTLE9BQU87QUFDaEIsVUFBUyxjQUFjLDBEQUEwRDtBQUNqRixVQUFTLGFBQWE7QUFDdEIsVUFBUyxPQUFPO0FBQ2hCLFVBQVMsT0FBTztBQUNoQixVQUFTLE9BQU87QUFDaEIsVUFBUyxPQUFPO0FBQ2hCLFVBQVMsT0FBTztBQUNoQixVQUFTLE9BQU87QUFDaEIsVUFBUyxPQUFPO0FBQ2hCLFVBQVMsT0FBTztBQUNoQixVQUFTLE9BQU87QUFDaEIsVUFBUyxPQUFPO0FBQ2hCOztBQUVBO0FBQ0EsVUFBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQSxVQUFTLE9BQU8sK0JBQStCLFlBQVk7QUFDM0Q7QUFDQTtBQUNBLFVBQVMsUUFBUTtBQUNqQjs7QUFFQTtBQUNBLFVBQVMsUUFBUTtBQUNqQjs7QUFFQTtBQUNBLFVBQVMsT0FBTztBQUNoQjs7QUFFQTtBQUNBLFdBQVUsUUFBUTtBQUNsQjs7QUFFQTtBQUNBLFVBQVMsT0FBTztBQUNoQjs7QUFFQTtBQUNBLFVBQVMsT0FBTztBQUNoQjs7QUFFQTtBQUNBLFVBQVMsT0FBTztBQUNoQixVQUFTLGNBQWM7QUFDdkIsVUFBUyxjQUFjO0FBQ3ZCLFVBQVMsY0FBYztBQUN2QixVQUFTLGNBQWM7QUFDdkIsVUFBUyxPQUFPO0FBQ2hCOztBQUVBO0FBQ0EsVUFBUyxNQUFNO0FBQ2Y7O0FBRUE7QUFDQSxVQUFTLE9BQU87QUFDaEI7O0FBRUE7QUFDQSxVQUFTLE1BQU07QUFDZjs7QUFFQTtBQUNBLFVBQVMsT0FBTztBQUNoQjs7QUFFQTtBQUNBLFVBQVMsT0FBTztBQUNoQjs7QUFFQTtBQUNBLFVBQVMsUUFBUTtBQUNqQjtBQUNBO0FBQ0EsVUFBUyxRQUFRO0FBQ2pCOztBQUVBO0FBQ0EsVUFBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQSxVQUFTLE9BQU8sb0RBQW9ELHNCQUFzQixRQUFRLGdCQUFnQixNQUFNLGdCQUFnQixNQUFNLGtCQUFrQjtBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0EsbUJBQWtCLHNCQUFzQjtBQUN4QyxtQkFBa0IsdUJBQXVCO0FBQ3pDLG1CQUFrQjtBQUNsQjtBQUNBLFdBQVU7QUFDVjs7QUFFQTtBQUNBLGVBQWMsT0FBTztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBLGVBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLEVBQUU7QUFDYixhQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLGFBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQixZQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxRQUFRO0FBQ25CLGFBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QixNQUFNO0FBQzlCLDZCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLGVBQWUsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxxQ0FBcUMsVUFBVTtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU8sd0VBQXdFOztBQUUxRjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7Ozs7Ozs7QUN2akJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUErRSxXQUFXO0FBQzFGO0FBQ0EscUJBQW9CLG9CQUFvQjtBQUN4QztBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QixrQkFBaUIsTUFBTTtBQUN2QixrQkFBaUIsc0JBQXNCLHVGQUF1RjtBQUM5SCxrQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxJOzs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBK0UsV0FBVztBQUMxRjtBQUNBLHFCQUFvQixLQUFLO0FBQ3pCO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQixPQUFPO0FBQ3hCLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEk7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBK0UsV0FBVztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLGlDQUFpQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJOzs7Ozs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQix3RUFBd0U7QUFDNUY7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXNELG9CQUFvQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERB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Q1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXNEO0FBQ3RELGNBQWE7QUFDYixVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTOztBQUVUO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQix1Q0FBdUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7Ozs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBK0UsV0FBVztBQUMxRjtBQUNBO0FBQ0EsNkJBQTRCLG1CQUFtQjtBQUMvQyw4QkFBNkI7QUFDN0IsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0EsMkNBQTBDLE9BQU87QUFDakQsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBLDBCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJOzs7Ozs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBK0UsV0FBVztBQUMxRjtBQUNBO0FBQ0EsNkJBQTRCLG1CQUFtQjtBQUMvQyw4QkFBNkI7QUFDN0IsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0EsMkNBQTBDLE9BQU87QUFDakQsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0EsMEJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSTs7Ozs7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCLFFBQVE7QUFDakMsMEJBQXlCLGtCQUFrQjtBQUMzQztBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBLCtCQUE4QixjQUFjO0FBQzVDLCtCQUE4QixjQUFjO0FBQzVDLCtCQUE4QixjQUFjO0FBQzVDLCtCQUE4QixjQUFjO0FBQzVDLCtCQUE4QixjQUFjO0FBQzVDLCtCQUE4QjtBQUM5QjtBQUNBLHVCQUFzQjtBQUN0Qix1QkFBc0I7QUFDdEI7QUFDQSwrQkFBOEIsY0FBYztBQUM1QywrQkFBOEIsY0FBYztBQUM1Qyx1QkFBc0I7QUFDdEIsdUJBQXNCO0FBQ3RCO0FBQ0EsK0JBQThCLGNBQWM7QUFDNUMsK0JBQThCLGVBQWU7QUFDN0MsK0JBQThCLGVBQWU7QUFDN0MsK0JBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixpQkFBaUI7QUFDNUM7QUFDQSxXQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFtRDtBQUNuRCx1REFBcUQ7QUFDckQ7QUFDQTtBQUNBLDBCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQSwwQkFBeUIsT0FBTztBQUNoQywwQkFBeUIsY0FBYztBQUN2QywwQkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0EsMEJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBLDBCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQSx5QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsMEJBQXlCLE9BQU8scUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsYUFBYTtBQUNoRDtBQUNBLGlDQUFnQywwQkFBMEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsT0FBTztBQUM5Qix5QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsNkVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DO0FBQ3BDO0FBQ0EsdUNBQXNDLG9CQUFvQjtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsT0FBTztBQUM5Qix3QkFBdUIsU0FBUztBQUNoQyx3QkFBdUIsT0FBTztBQUM5Qix3QkFBdUIsUUFBUTtBQUMvQix5QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBeUQsMEhBQTBIO0FBQ25MO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0EsNkJBQTRCLFFBQVE7QUFDcEMsNkJBQTRCLGtCQUFrQjtBQUM5QztBQUNBLGtCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0EsOEVBQTZFLGlCQUFpQjtBQUM5RjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBaUU7QUFDakUsa0JBQWlCOztBQUVqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFxRTtBQUNyRTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQSx3REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJOzs7Ozs7O0FDM2dCQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLFNBQVM7QUFDekIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBLHdCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsU0FBUztBQUN6QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLDBEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsY0FBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0EsNEJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDOVBBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3Qyw4QkFBOEI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUErRSxXQUFXO0FBQzFGO0FBQ0E7QUFDQSwwQkFBeUIsUUFBUTtBQUNqQywwQkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCLCtCQUE4QixZQUFZO0FBQzFDLCtCQUE4QixZQUFZO0FBQzFDLCtCQUE4QixZQUFZO0FBQzFDLCtCQUE4QixZQUFZO0FBQzFDLCtCQUE4QixZQUFZO0FBQzFDLCtCQUE4QixZQUFZO0FBQzFDLCtCQUE4QixZQUFZO0FBQzFDLCtCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsK0JBQThCLDJCQUEyQjtBQUN6RCwrQkFBOEIsMkJBQTJCO0FBQ3pELCtCQUE4QiwyQkFBMkI7QUFDekQsK0JBQThCLDJCQUEyQjtBQUN6RCwrQkFBOEIsMkJBQTJCO0FBQ3pELCtCQUE4QiwyQkFBMkI7QUFDekQsK0JBQThCO0FBQzlCO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0Esa0JBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLGtCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QjtBQUNBLGtCQUFpQixPQUFPO0FBQ3hCLGtCQUFpQixPQUFPO0FBQ3hCLGtCQUFpQixPQUFPO0FBQ3hCLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSxrQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0Esa0JBQWlCLE9BQU8sdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsMkVBQTJFO0FBQzlGLHlCQUF3QixRQUFRLGFBQWE7QUFDN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsU0FBUztBQUN4QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBb0IsUUFBUTtBQUM1QixxQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxjQUFjLGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0EscURBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLDhEQUE2RDtBQUM3RDtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOzs7Ozs7Ozs7QUN2UkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQixVQUFVO0FBQ3pDO0FBQ0Esd0NBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsU0FBUztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksZ0NBQWdDO0FBQzVDO0FBQ0EsWUFBVyxtQkFBbUIsc0NBQXNDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQThDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGFBQWE7QUFDcEMsd0JBQXVCLE9BQU87QUFDOUIsd0JBQXVCLFNBQVM7QUFDaEMsd0JBQXVCLFNBQVM7QUFDaEMsd0JBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUFzQjs7Ozs7Ozs7O0FDclp0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtGQUE4RjtBQUM5RjtBQUNBO0FBQ0EsY0FBYTs7O0FBR2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBb0IsK0JBQStCO0FBQ25ELHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixRQUFRO0FBQzVCLHFCQUFvQix1QkFBdUI7QUFDM0MscUJBQW9CLHVCQUF1QjtBQUMzQyxxQkFBb0IsNEJBQTRCO0FBQ2hELHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLHVDQUFzQyxjQUFjLG1CQUFtQixtQkFBbUIsWUFBWSxFQUFFO0FBQ3hHO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVMsU0FBUztBQUNsQjs7QUFFQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQsK0JBQThCO0FBQzlCO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLElBQUk7QUFDbkIsZ0JBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFvQix1QkFBdUIsc0JBQXNCO0FBQ2pFOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQzlQQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWdEOztBQUVoRDs7QUFFQTtBQUNBLHdFQUF1RTtBQUN2RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUN0SUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFtQixNQUFNLElBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBc0IsT0FBTyxjQUFjO0FBQzNDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7Ozs7OztBQ3ZFTDtBQUNBOzs7Ozs7O0FDRkE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0NBQThDLE9BQU8sTUFBTSxVQUFVLFdBQVc7QUFDaEY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQTZDLHdCQUF3QjtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBK0IsWUFBWTtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQTZELGFBQWEsT0FBTztBQUNqRiw4QkFBNkIsU0FBUyxZQUFZLGdCQUFnQjtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsK0JBQStCO0FBQzFEO0FBQ0E7QUFDQSxnQ0FBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN6aUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkRBQTBELGdCQUFnQixrQkFBa0IsWUFBWSxhQUFhOztBQUVySCxvREFBbUQsT0FBTyxNQUFNOztBQUVoRTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsNEJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJmaXNoVG9wb0Zsb3cuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJmaXNoVG9wb0Zsb3dcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZmlzaFRvcG9GbG93XCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGUzNzczNzU0Y2U0MWE1MTc2MzQ5IiwiLyoqXHJcbiAqIEV4cG9ydCBmaXNoVG9wbyBhcyBDb21tb25KUyBtb2R1bGVcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL0Zpc2hUb3BvRmxvdy5qcycpO1xyXG4vL+WFvOWuuUlFOCDlvJXlhaVWTUwg5aaC5p6c5LiN6ZyA6KaB5YW85a65SUU46K+35Yig6ZmkXHJcbnJlcXVpcmUoJ3pyZW5kZXIvbGliL3ZtbC92bWwnKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbmRleC5mbG93LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBmaXNodG9wb+a1geeoi+WunuS+i1xyXG4gKiBAY2xhc3MgZmlzaC50b3BvLkZpc2hUb3BvRmxvd1xyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBjbGlja1xyXG4gKiDoioLngrnmiJbogIXnur/mrrXnmoRjbGlja+S6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2IGV2ZW50LnRhcmdldOS4uuebruagh+WvueixoSBldmVudC50YXJnZXQubW9kZWzkuLrnm67moIflr7nosaHnmoTkuJrliqHmlbDmja5cclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgICAgIHRoaXMuZmlzaFRvcG8ub24oXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLngrnlh7vnmoTmmK/vvJpcIiArIGV2ZW50LnRhcmdldC5tb2RlbC5nZXQoJ2VsZW1lbnRUeXBlJykpO1xyXG4gKiAgICAgICAgICB9KTtcclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGRibGNsaWNrXHJcbiAqIOiKgueCueaIluiAhee6v+auteeahOWPjOWHu+S6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2IGV2ZW50LnRhcmdldOS4uuebruagh+WvueixoSBldmVudC50YXJnZXQubW9kZWzkuLrnm67moIflr7nosaHnmoTkuJrliqHmlbDmja5cclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgICAgIHRoaXMuZmlzaFRvcG8ub24oXCJkYmxjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLlj4zlh7vnmoTmmK/vvJpcIiArIGV2ZW50LnRhcmdldC5tb2RlbC5nZXQoJ2VsZW1lbnRUeXBlJykpO1xyXG4gKiAgICAgICAgICB9KTtcclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGNyZWF0ZVxyXG4gKiDoioLngrnkuI7nur/mrrXliJvlu7rlrozmr5XnmoTkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tiBldmVudC50YXJnZXTkuLrnm67moIflr7nosaEgZXZlbnQudGFyZ2V0Lm1vZGVs5Li655uu5qCH5a+56LGh55qE5Lia5Yqh5pWw5o2uXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICAgICB0aGlzLmZpc2hUb3BvLm9uKFwiY3JlYXRlXCIsIGZ1bmN0aW9uKGUpIHtcclxuICogICAgICAgICAgICAgICBpZiAobWUuZmlzaFRvcG8uRmxvdy5pc0xpbmsoZS50YXJnZXQubW9kZWwpKSB7XHJcbiAqICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLnur/mrrXliJvlu7rlrozmr5XvvJpcIiArIGUudGFyZ2V0Lm1vZGVsKTtcclxuICogICAgICAgICAgICAgICB9XHJcbiAqICAgICAgICAgIH0pO1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgZGVsZXRlXHJcbiAqIOiKgueCueS4jue6v+auteWIm+W7uuWujOavleeahOS6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2IGV2ZW50LnRhcmdldOS4uuebruagh+WvueixoSBldmVudC50YXJnZXQubW9kZWzkuLrnm67moIflr7nosaHnmoTkuJrliqHmlbDmja5cclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgICAgIC8v6IqC54K55Yig6Zmk5a6M5q+V5LqL5Lu2XHJcbiAqICAgICAgICAgIHRoaXMuZmlzaFRvcG8ub24oXCJkZWxldGVcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICogICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5Yig6Zmk55qE5piv77yaXCIgKyBldmVudC50YXJnZXQubW9kZWwuZ2V0KCdlbGVtZW50VHlwZScpKTtcclxuICogICAgICAgICAgfSk7XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBkcm9wRHJhZ1xyXG4gKiDoioLngrnnp7vliqjlrozmiJDnmoTkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tiBldmVudC50YXJnZXTkuLrnm67moIflr7nosaEgZXZlbnQudGFyZ2V0Lm1vZGVs5Li655uu5qCH5a+56LGh55qE5Lia5Yqh5pWw5o2uXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICAgICAvL+iKgueCueenu+WKqOe7k+adn+S6i+S7tlxyXG4gICAgICAgICAgICB0aGlzLmZpc2hUb3BvLm9uKFwiZHJvcERyYWdcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi56e75Yqo55qE6IqC54K55piv77yaXCIrZXZlbnQudGFyZ2V0Lm1vZGVsLmdldCgnZWxlbWVudFR5cGUnKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gKi9cclxuXHJcblxyXG5cclxuXHJcbiAgICByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3BvbHlmaWxsLmpzXCIpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgTWluaW1hcCA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvbWluaW1hcC5qc1wiKTtcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXCIpO1xyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9Qb2ludC5qc1wiKTtcclxuICAgIHZhciBFeHRlbnNpb25BUEkgPSByZXF1aXJlKCcuL0V4dGVuc2lvbkFwaScpO1xyXG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnenJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwnKTtcclxuICAgIHZhciB6cmVuZGVyID0gcmVxdWlyZSgnenJlbmRlci9saWIvenJlbmRlcicpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIE9wZXJhdGlvbk5vZGUgPSByZXF1aXJlKFwiLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvT3BlcmF0aW9uTm9kZS5qc1wiKTtcclxuICAgIHZhciBGbG93Q29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9tYW5hZ2VyL0Zsb3dDb25uZWN0aW9uTWFuYWdlci5qc1wiKTtcclxuICAgIHZhciBGbG93VXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvRmxvd1V0aWwuanNcIik7XHJcbiAgICB2YXIgQ29uc3RhbnRzID0gcmVxdWlyZShcIi4vdXRpbC9GbG93Q29uc3RhbnRzLmpzXCIpO1xyXG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9tb2RlbC5qc1wiKTtcclxuICAgIHZhciBldmVudFRvb2wgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2V2ZW50Jyk7XHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIExpbmVPcGVyYXRpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9tYW5hZ2VyL0xpbmVPcGVyYXRpb25NYW5hZ2VyLmpzXCIpO1xyXG4gICAgdmFyIEZsb3cgPSByZXF1aXJlKFwiLi9GbG93LmpzXCIpO1xyXG4gICAgdmFyIGZsb3dOb2RlID0gcmVxdWlyZShcIi4vbm9kZS9mbG93Tm9kZVwiKTtcclxuICAgIHZhciBmbG93TGluayA9IHJlcXVpcmUoXCIuL2xpbmsvZmxvd0xpbmtcIik7XHJcbiAgICB2YXIgbGF5b3V0ID0gcmVxdWlyZShcIi4vbGF5b3V0L2xheW91dFwiKTtcclxuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xyXG4gICAgdmFyIEltYWdlUG9vbCA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvSW1hZ2VQb29sLmpzXCIpO1xyXG4gICAgdmFyIFRvb2xUaXBWaWV3ID0gcmVxdWlyZShcIi4vdG9vbHRpcC9Ub29sdGlwVmlld1wiKTtcclxuICAgIHZhciBUb29sdGlwTW9kZWwgPSByZXF1aXJlKFwiLi90b29sdGlwL1Rvb2x0aXBNb2RlbFwiKTtcclxuICAgIHZhciBhY3Rpb25zID0ge307XHJcbiAgICB2YXIga2V5Q29kZSA9IHtFTlRFUjoxMywgRVNDQVBFOjI3fVxyXG4gICAgZnVuY3Rpb24gRmlzaFRvcG9GbG93KGRvbSwgb3B0cykge1xyXG4gICAgICAgIHRoaXMuaWQ7XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZG9tID0gZG9tO1xyXG4gICAgICAgIHRoaXMubm93Wm9vbSA9IDE7XHJcbiAgICAgICAgdGhpcy5jYW5TY2FsZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5lYWdsZUV5ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZWFnbGVFeWVOb2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluaXRTY2FsZVJhdGlvID0gMTtcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWROb2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmFsbE5vZGVzID0gW107XHJcbiAgICAgICAgdGhpcy5taW5pbWFwID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9hcGkgPSBuZXcgRXh0ZW5zaW9uQVBJKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyKHRoaXMuX2FwaSk7XHJcbiAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlciA9IG5ldyBMaW5lT3BlcmF0aW9uTWFuYWdlcih0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLHRoaXMuX2FwaSk7XHJcbiAgICAgICAgdGhpcy5fenIgPSB6cmVuZGVyLmluaXQoZG9tLCB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyOiBvcHRzLnJlbmRlcmVyIHx8ICdjYW52YXMnLFxyXG4gICAgICAgICAgICBkZXZpY2VQaXhlbFJhdGlvOiBvcHRzLmRldmljZVBpeGVsUmF0aW9cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl90b29sdGlwVmlldyA9IG5ldyBUb29sVGlwVmlldyhuZXcgVG9vbHRpcE1vZGVsKG9wdHMudG9vbHRpcCksdGhpcy5fYXBpKTtcclxuICAgICAgICB0aGlzLlNoYXBlID0gZ3JhcGhpYztcclxuICAgICAgICB0aGlzLm1vZGVsID0gbmV3IE1vZGVsKHt9KTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChDb25zdGFudHMuRUxFTUVOVF9UWVBFLCBcInNjZW5lXCIpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KENvbnN0YW50cy5NT0RFLCBcIm5vcm1hbFwiKTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRzO1xyXG4gICAgICAgIEV2ZW50ZnVsLmNhbGwodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZpc2hUb3BvUHJvdG8gPSBGaXNoVG9wb0Zsb3cucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+WIGZpc2hUb3BvIOWunuS+i+WuueWZqOeahCBkb20g6IqC54K5XHJcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5nZXREb20gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvbTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmdldFpyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl96cjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPliBmaXNoVG9wbyDlrp7kvovlrrnlmajnmoTlrr3luqbjgIJcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fenIuZ2V0V2lkdGgoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5YgZmlzaFRvcG8g5a6e5L6L5a655Zmo55qE6auY5bqm44CCXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl96ci5nZXRIZWlnaHQoKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5b2T5YmN5a6e5L6L5piv5ZCm5bey57uP6KKr6YeK5pS+44CCXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmlzRGlzcG9zZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOmHiuaUviDlvZPliY3lrp7kvotcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5fenIuZGlzcG9zZSgpO1xyXG5cclxuICAgICAgICBpbnN0YW5jZXNbdGhpcy5pZF0gPSBudWxsO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDosIPmlbTlsLrlr7ggIOWcqOeql+WPo+Wkp+Wwj+WPkeeUn+aUueWPmOaXtumcgOimgeaJi+W3peiwg+eUqFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIOWuveW6plxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCDpq5jluqZcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fenIucmVzaXplKCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLmRpc3BhdGNoQWN0aW9uID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcclxuICAgICAgICBpZighYWN0aW9uc1twYXlsb2FkLnR5cGVdKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIG9wdGlvblxyXG4gICAgICog5L+u5pS555S75biD55qE6YCJ6aG5XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IOmUriAg5aaC77yacm9hbSBsaW5rTW9kaWZ5ICB0ZXh0RWRpdGFibGXnrYlcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd8RnVuY3Rpb259IHZhbHVlIOmAiemhueWAvFxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLm9wdGlvbiA9IGZ1bmN0aW9uKGtleSx2YWx1ZSkge1xyXG4gICAgICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbCh0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB6clV0aWwuY2xvbmUodGhpcy5vcHRpb25zKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vZGVsLmdldChrZXkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcInJvYW1cIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSb2FtKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbW9kZWwuc2V0KGtleSx2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgdGhpcy5ncm91cC5pc0JnID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8g6byg5qCH5bmz56e75pON5L2cXHJcbiAgICAgICAgaWYgKCh0aGlzLm9wdGlvbnMucm9hbSA9PT0gdHJ1ZSkgfHwgKHRoaXMub3B0aW9ucy5yb2FtID09PSAnbW92ZScpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuenJNb3ZlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl96ci5hZGQodGhpcy5ncm91cCk7XHJcblxyXG4gICAgICAgIC8v5piv5ZCm5YWB6K646byg5qCH5rua6L2u5pS+5aSn57yp5bCPXHJcbiAgICAgICAgaWYgKCh0aGlzLm9wdGlvbnMucm9hbSA9PT0gdHJ1ZSkgfHwgKHRoaXMub3B0aW9ucy5yb2FtID09PSAnc2NhbGUnKSkge1xyXG4gICAgICAgICAgICB0aGlzLnpyU2NhbGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycyA9IFtdO1xyXG4gICAgICAgIC8vbW91c2V1cCDkvJrlnKjlkITkuKpub2Rl5oiW57q/55qEY2xpY2vkuovku7bkuYvngrnmiafooYwgIOWcqOmAieS4reiKgueCueaIlue6v+WJjSDlhYjmuIXnqbrpgInkuK3mlYjmnpxcclxuICAgICAgICB0aGlzLl96ci5vbihcIm1vdXNldXBcIiwgZnVuY3Rpb24gKGUpIHsgLy8gY2xlYXJTZWxlY3RcclxuICAgICAgICAgICAgLy8gMS4g5riF56m66IqC54K555qE6YCJ5Lit5pWI5p6cXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZU9wZXJhdGlvbk5vZGUoKTtcclxuICAgICAgICAgICAgLy8gMi4g54K55Ye755qE57q/IO+8jOWImeebtOaOpei/lOWbnlxyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBlLnRhcmdldDtcclxuICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLm1vZGVsICYmIEZsb3cuaXNMaW5rKHNoYXBlLm1vZGVsKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5jb25uZWN0b3IgaW5zdGFuY2VvZiBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAzLiDmuIXnqbrov57mjqXnur9cclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jbGVhclNlbGVjdENvbigpO1xyXG4gICAgICAgICAgICAvLyA0LiDngrnlh7vnmoTmmK/nur/kuIrmk43kvZzmjInpkq7vvIzliJnnm7TmjqXov5Tlm55cclxuICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLl9pc0xpbmVPcGVyYXRpb25JY29uICYmIHNoYXBlLl9pc0xpbmVPcGVyYXRpb25JY29uID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyA1LumakOiXj+e6v+S4iuaTjeS9nOWbvuagh1xyXG4gICAgICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmhpZGVBbGxMaW5lT3BlcmF0aW9uKCk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgdGhpcy5fenIub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZVRhcmdldCA9IGUudGFyZ2V0O1xyXG4gICAgICAgICAgICB2YXIgc2hhcGU7XHJcbiAgICAgICAgICAgIGlmIChub2RlVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBzaGFwZSA9IG5vZGVUYXJnZXQubW9kZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChub2RlVGFyZ2V0ICYmIHNoYXBlICYmIEZsb3cuaXNMaW5rKHNoYXBlKSkgfHwgKG5vZGVUYXJnZXQgJiYgc2hhcGUgJiYgRmxvdy5pc05vZGUoXHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcImNsaWNrXCI7XHJcbiAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLl9hcGkudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMub24oJ2NvblBvaW50c0dyb3VwOmNsaWNrJywgZnVuY3Rpb24gKGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZU9wZXJhdGlvbk1hbmFnZXIuYmluZE9wZXJhdGlvbihhcmd1bWVudC5saW5lTm9kZSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH07XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5zZXRSb2FtID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgLy/mmK/lkKblhYHorrjpvKDmoIfmu5rova7mlL7lpKfnvKnlsI9cclxuICAgICAgICBpZiAoKHZhbHVlID09PSB0cnVlKSB8fCAodmFsdWUgPT09ICdtb3ZlJykpIHtcclxuICAgICAgICAgICAgdGhpcy56ck1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh2YWx1ZSA9PT0gdHJ1ZSkgfHwgKHZhbHVlID09PSAnc2NhbGUnKSkge1xyXG4gICAgICAgICAgICB0aGlzLnpyU2NhbGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSApIHtcclxuICAgICAgICAgICAgdGhpcy5fenIub2ZmKFwibW91c2Vkb3duXCIpOyAgLy/npoHmraIg5ouW5ou955S75biDXHJcbiAgICAgICAgICAgIHRoaXMuX3pyLm9mZihcIm1vdXNld2hlZWxcIik7Ly/npoHmraLnlKjmiLfnvKnmlL7nlLvluINcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHRvSnNvblxyXG4gICAgICog5a+85Ye6anNvblxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBqc29u5a+56LGhXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8udG9Kc29uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBGbG93VXRpbC50b0pzb24odGhpcy5tb2RlbCwgdGhpcy5ncm91cCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGZyb21Kc29uXHJcbiAgICAgKiDlr7zlhaVqc29uXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGpzb27lr7nosaFcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5mcm9tSnNvbiA9IGZ1bmN0aW9uIChqc29uKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbChqc29uKTtcclxuICAgICAgICB0aGlzLnNldEJhY2tncm91bmQobW9kZWwuZ2V0KENvbnN0YW50cy5CQUNLR1JPVU5EKSk7XHJcbiAgICAgICAgdmFyIGxheW91dFJvb3ROb2RlID0gW107XHJcbiAgICAgICAgRmxvd1V0aWwuZnJvbUpzb24odGhpcywgdGhpcy5ncm91cCwgbW9kZWwuZ2V0KENvbnN0YW50cy5DSElMRFMpLCBmYWxzZSwgbGF5b3V0Um9vdE5vZGUpO1xyXG4gICAgICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0Um9vdE5vZGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyAgICAgdGhpcy5sYXlvdXROb2RlKFwidHJlZVwiLCB7XHJcbiAgICAgICAgLy8gICAgICAgICBcIm5vZGVcIjogbGF5b3V0Um9vdE5vZGVbaV0sXHJcbiAgICAgICAgLy8gICAgICAgICBcInR5cGVcIjogbGF5b3V0Um9vdE5vZGVbaV0udHJlZVR5cGVcclxuICAgICAgICAvLyAgICAgfSk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5re75Yqg6IqC54K55oiW57q/5q615Yiw55S75biDIOWQjGFkZOaWueazlVxyXG4gICAgICogQG1ldGhvZCBhZGROb2RlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBjcmVhdGVOb2Rl5oiWY3JlYXRlTGlua+i/lOWbnueahOWvueixoVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25dIOWPguaVsOWvueixoVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9uLnRyaWdnZXJdIOaYr+WQpuinpuWPkSBiZWZvcmVDcmVhdGXkuovku7ZcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IOi/lOWbnua3u+WKoOaIkOWKn+eahOiKgueCuSDvvIzlpoLooqvnlKjmiLflj5bmtojkuYvnsbvliJkg6L+U5ZuebnVsbFxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIOa3u+WKoOiKgueCueaIlue6v+auteWIsOeUu+W4gyDlkIxhZGROb2Rl5pa55rOVXHJcbiAgICAgKiBAbWV0aG9kIGFkZFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgY3JlYXRlTm9kZeaIlmNyZWF0ZUxpbmvov5Tlm57nmoTlr7nosaFcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uXSDlj4LmlbDlr7nosaFcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbi50cmlnZ2VyXSDmmK/lkKbop6blj5EgYmVmb3JlQ3JlYXRl5LqL5Lu2XHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSDov5Tlm57mt7vliqDmiJDlip/nmoToioLngrkg77yM5aaC6KKr55So5oi35Y+W5raI5LmL57G75YiZIOi/lOWbnm51bGxcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5hZGQgPSBmaXNoVG9wb1Byb3RvLmFkZE5vZGUgPSBmdW5jdGlvbiAobm9kZSxvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgaWYob3B0LnRyaWdnZXIgIT09ZmFsc2UgJiYgKCF0aGlzLl90cmlnZ2VyKCdiZWZvcmVDcmVhdGUnLCB7dGFyZ2V0Om5vZGV9KSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ29ubmVjdG9yQXR0ckV2ZW50KG5vZGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChGbG93LmlzR3JvdXBOb2RlKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLndpbGxSZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cE9wdGlvbnMgPSBub2RlLm1vZGVsLmdldChDb25zdGFudHMuT1BUSU9OUyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBPcHRpb25zLm1lcmdlZEltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwUmVwbGFjZUltYWdlID0gbmV3IGZsb3dOb2RlLkltYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBncm91cE9wdGlvbnMubWVyZ2VkSW1hZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBncm91cE9wdGlvbnMuc3R5bGUudGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRQb3NpdGlvbjogJ2JvdHRvbSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFstNTAwMCwgLTUwMDBdXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnKGdyb3VwUmVwbGFjZUltYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLl9yZWxhdGlvbkltYWdlID0gZ3JvdXBSZXBsYWNlSW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoZ3JvdXBSZXBsYWNlSW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cFJlcGxhY2VJbWFnZS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgMzAwKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tZXJnZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy/pgY3ljobnu4TkuK3miYDmnInoioLngrlcclxuICAgICAgICAgICAgICAgIG5vZGUuZWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENvbm5lY3RvckF0dHJFdmVudChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE5vZGVBdHRyRXZlbnQoY2hpbGQsIGdyb3VwT3B0aW9ucy5jaGlsZERyYWdnYWJsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChjaGlsZC5zZWxlY3RhYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnNlbGVjdGFibGUgPSBmYWxzZTsgIC8v57uE5YaF6buY6K6k5LiN5Y+v6YCJ5LitXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQucmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVSZWxhdGl2ZVBvc3Rpb24oY2hpbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaG92ZXJTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZShjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcihcImNyZWF0ZVwiLCB7dGFyZ2V0OmNoaWxkfSk7XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFkZE5vZGVBdHRyRXZlbnQobm9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXCJjcmVhdGVcIiwge3RhcmdldDpub2RlfSk7XHJcblxyXG4gICAgICAgIGlmIChub2RlLmhvdmVyU3R5bGUpIHtcclxuICAgICAgICAgICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKG5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5ncm91cC5hZGQobm9kZSk7XHJcbiAgICAgICAgaWYgKG5vZGUucmVsYXRpdmUpIHsgIC8v5b+F6aG75Zyo5Yqg5YWl55S75biD5ZCO5omn6KGMXHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVJlbGF0aXZlUG9zdGlvbihub2RlKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5ob3ZlckFuaW1hdGlvbiAmJiB0aGlzLm9wdGlvbnMuaXNBbmltYXRpb25FbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGZsb3dOb2RlLmFkZEhvdmVyQW5pbWF0aW9uKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5hZGRDb25uZWN0b3JBdHRyRXZlbnQgPSBmdW5jdGlvbiAoY29ubmVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIGNvbm5lY3Rvci5vcHRpb25zLmlzRWRpdCA9ICEhdGhpcy5vcHRpb25zLmxpbmtNb2RpZnk7XHJcbiAgICAgICAgY29ubmVjdG9yLm9uKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JGb3JiaWRFZGl0KCF0aGlzLm9wdGlvbnMubGlua01vZGlmeSk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNOb2RlID0gZmFsc2U7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgIC8v5pSv5oyB5Y+M5Ye757yW6L6RXHJcbiAgICAgICAgY29ubmVjdG9yLm9uKFwiZGJsY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy50ZXh0LnRleHRFZGl0YWJsZSA9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnRleHRFZGl0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY29ubmVjdG9yRWRpdCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dC50ZXh0RWRpdGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbm5lY3RvckVkaXQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZE5vZGVBdHRyRXZlbnQgPSBmdW5jdGlvbiAobm9kZSwgY2hpbGREcmFnZ2FibGUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGNoaWxkRHJhZ2dhYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZyhub2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5vZGUuYXR0cihcIm9wZXJhdGlvbkljb25zXCIsIG5vZGUubW9kZWwuZ2V0KCdvcHRpb25zLm9wZXJhdGlvbkljb25zJykpO1xyXG5cclxuICAgICAgICAvL+S+puWQrOiKgueCueeahGNsaWNrIGRibGNsaWNr5LqL5Lu277yM6YCJ5Lit77yM5bm25rS+5Y+R5Ye65Y67XHJcbiAgICAgICAgbm9kZS5vbignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdlTm9kZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoYXQubm9kZUNsaWNrSGFuZGxlcih0YXJnZU5vZGUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICBwYXJhbXMuZXZlbnQgPSBldmVudDtcclxuICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSAnY2xpY2snO1xyXG4gICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGFyZ2VOb2RlO1xyXG4gICAgICAgICAgICB0aGF0Ll9hcGkudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIC8v5Yik5pat5LiA5LiL5piv5ZCm5piv57uE5YaF5oiQ57uE55qE54K55Ye75LqL5Lu277yM5aaC5p6c5piv55qE6K+d77yM6YKj57uE5Lmf5Lmf5rS+5Y+R5LiA5LiLXHJcbiAgICAgICAgICAgIGlmIChGbG93LmlzSW5Hcm91cCh0YXJnZU5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHRhcmdlTm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnRyaWdnZXIoJ2NsaWNrJywge2V2ZW50OmV2ZW50LCB0eXBlOidjbGljaycsdGFyZ2V0OnBhcmVudE5vZGV9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5vZGUub24oJ2RibGNsaWNrJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdlTm9kZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2VOb2RlLnN0eWxlIHx8ICh0eXBlb2YgdGFyZ2VOb2RlLnN0eWxlLnRleHRFZGl0YWJsZSA9PSBcInVuZGVmaW5lZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy50ZXh0RWRpdGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Lm5vZGVFZGl0KHRhcmdlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2VOb2RlLnN0eWxlLnRleHRFZGl0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQubm9kZUVkaXQodGFyZ2VOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgIHBhcmFtcy50eXBlID0gJ2RibGNsaWNrJztcclxuICAgICAgICAgICAgcGFyYW1zLnRhcmdldCA9IHRhcmdlTm9kZTtcclxuICAgICAgICAgICAgdGhhdC5fYXBpLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcblxyXG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWxsTm9kZXMucHVzaChub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLl9oYW5kbGVSZWxhdGl2ZVBvc3Rpb24gPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudEVsID0gbm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwYXJlbnRFbCA9PT0gdGhpcy5ncm91cFxyXG4gICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOnRoaXMuX2FwaS5nZXRXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OnRoaXMuX2FwaS5nZXRIZWlnaHQoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6cGFyZW50RWwuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6cGFyZW50RWwuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBsYXlvdXQucG9zaXRpb25FbGVtZW50KG5vZGUsIG5vZGUucmVsYXRpdmUsIGNvbnRhaW5lckluZm8sIG5vZGUucmVsYXRpdmUucGFkZGluZywge2JvdW5kaW5nTW9kZTpub2RlLnJlbGF0aXZlLmJvdW5kaW5nfHwnYWxsJ30pO1xyXG4gICAgfVxyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uX2dldFBhcmVudFpyID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIHZhciBwYXJlbnRaciA9IG51bGw7XHJcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50WnIgPSBub2RlLnBhcmVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJlbnRaciA9IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJlbnRacjtcclxuICAgIH1cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLl9yZW1vdmVPcGVyYXRpb25Ob2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3BlcmF0aW9uTm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZSh0aGlzLm9wZXJhdGlvbk5vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUuY2xlYW51cCgpO1xyXG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOa4heepuuW9k+WJjeWunuS+i++8jOS8muenu+mZpOWunuS+i+S4reaJgOacieeahOiKgueCueS4jue6v1xyXG4gICAgICogQG1ldGhvZCBjbGVhclxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50WnIgPSB0aGlzLl9nZXRQYXJlbnRacih0aGlzLmFsbE5vZGVzW2ldKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5kZWxldGVTZWxlY3RDb24odGhpcy5hbGxOb2Rlc1tpXSwgcGFyZW50WnIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9yTWFwLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5hbGxOb2RlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3pyLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgdGhpcy5ncm91cC5pc0JnID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl96ci5hZGQodGhpcy5ncm91cCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66L+e57q/55qE5bCP5Zu+5qCH5pON5L2cXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IOWwj+Wbvuagh+eahOWQjeensFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMg5bCP5Zu+5qCH55qE55u45YWz5Y+C5pWwXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaWNvbl0g5bCP5Zu+5qCH6Lev5b6EXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGluZU5vZGVdIOe6v+auteWunuS+i1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdIOeCueWHu+WQjueahOWbnuiwg1xyXG4gICAgICpcclxuICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIHRoaXMuZmlzaFRvcG8uYWRkSWNvbihcImljb24xXCIsIHtcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGljb246IFwiaHR0cHM6Ly9zczAuYmRzdGF0aWMuY29tLzVhVjFianFoX1EyM29kQ2Yvc3RhdGljL3N1cGVybWFuL2ltZy9sb2dvX3RvcF9jYTc5YTE0Ni5wbmdcIixcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGxpbmVOb2RlOiBsaW5lTm9kZSxcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KEpTT04uc3RyaW5naWZ5KGV2ZW50LmRhdGEpKVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uYWRkTGluZUljb24gPSBmaXNoVG9wb1Byb3RvLmFkZEljb24gPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlci5hZGRJY29uKGtleSwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66L+e57q/55qE6buY6K6k5Yig6Zmk5pON5L2cXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGxpbmVOb2RlIOe6v1xyXG4gICAgICpcclxuICAgICAqICAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICBmaXNoVG9wby5saW5lRGVmYXVsdEljb24obGluZU5vZGUpO1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmxpbmVEZWZhdWx0SWNvbiA9IGZ1bmN0aW9uIChsaW5lTm9kZSkge1xyXG4gICAgICAgIHRoaXMuYWRkTGluZURlbGV0ZUljb24obGluZU5vZGUpO1xyXG4gICAgICAgIHRoaXMuYWRkTGluZUNoYW5nZUljb24obGluZU5vZGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uui/nue6v+eahOm7mOiupOWIoOmZpOaTjeS9nFxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBsaW5lTm9kZSDnur9cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10g6L+e57q/5pON5L2c55qE6YCJ6aG5XHJcbiAgICAgKlxyXG4gICAgICogICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgIGZpc2hUb3BvLmFkZExpbmVDaGFuZ2VJY29uKGxpbmVOb2RlKTtcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5hZGRMaW5lRGVsZXRlSWNvbiA9IGZ1bmN0aW9uIChsaW5lTm9kZSxvcHRpb25zKSB7XHJcbiAgICAgICAgLy/liJvlu7rliKDpmaRcclxuICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmFkZERlbGV0ZUljb24obGluZU5vZGUsb3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu66L+e57q/55qE6buY6K6k5YiH5o2i57G75Z6L5pON5L2cXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGxpbmVOb2RlIOe6v1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSDov57nur/mk43kvZznmoTpgInpoblcclxuICAgICAqXHJcbiAgICAgKiAgKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICpcclxuICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICAgZmlzaFRvcG8uYWRkTGluZUNoYW5nZUljb24obGluZU5vZGUpO1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZExpbmVDaGFuZ2VJY29uID0gZnVuY3Rpb24gKGxpbmVOb2RlLG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmFkZENoYW5nZUxpbmVUeXBlSWNvbihsaW5lTm9kZSxvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlj5jmm7TlvZPliY3nur/nmoTnsbvlnovvvIzlpoLmnpzkuI3kvKDliJnmjInpobrluo/lj5bkuIvkuIDkuKrnsbvlnovjgILlhYjliKDpmaTljp/mnaXnmoTnur/mrrUg5YaN5aKe5Yqg5LiA56eN57G75Z6L55qE57q/5q61XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZVR5cGUg5qyy5Y+Y5pu057q/55qE57G75Z6LXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY2hhbmdlU2VsZWN0Q29ubmVjdG9yVHlwZSA9IGZ1bmN0aW9uKGxpbmVUeXBlKSB7XHJcbiAgICAgICAgdmFyIG5leHRMaW5lVHlwZSA9IGxpbmVUeXBlO1xyXG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zZWxDb25uZWN0b3I7XHJcbiAgICAgICAgdmFyIG9yaWdpbkxpbmVUeXBlID0gbGluZS5vcHRpb25zLnN0eWxlLmxpbmVUeXBlO1xyXG4gICAgICAgIGlmIChuZXh0TGluZVR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKG5leHRMaW5lVHlwZSA9PSBvcmlnaW5MaW5lVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGFyckxpbmVUeXBlID0gW0Nvbm5lY3Rvci5UWVBFX1NUUkFJR0hULCBDb25uZWN0b3IuVFlQRV9KQUdHRUQsIENvbm5lY3Rvci5UWVBFX0NVUlZFXTtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0genJVdGlsLmluZGV4T2YoYXJyTGluZVR5cGUsIG9yaWdpbkxpbmVUeXBlKTtcclxuICAgICAgICAgICAgbmV4dExpbmVUeXBlID0gYXJyTGluZVR5cGVbKGluZGV4ICsgMSkgJSBhcnJMaW5lVHlwZS5sZW5ndGhdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy90aGlzLnJlbW92ZShsaW5lLCB7dHJpZ2dlcjpmYWxzZX0pOyDov5nmoLfkvJrliKDpmaRpY29uc1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZGVsZXRlTGluZSh0aGlzLl9nZXRQYXJlbnRacihsaW5lKSk7XHJcbiAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlci5oaWRlQWxsTGluZU9wZXJhdGlvbigpO1xyXG5cclxuICAgICAgICB6clV0aWwubWVyZ2UobGluZS5vcHRpb25zLnN0eWxlLCB7bGluZVR5cGU6IG5leHRMaW5lVHlwZX0sIHRydWUpO1xyXG4gICAgICAgIHZhciBuZXh0TGluZSA9IHRoaXMuY3JlYXRlQ29ubmVjdG9yQnlOb2RlcyhsaW5lLnN0YXJ0Tm9kZSwgbGluZS5lbmROb2RlLCBsaW5lLm9wdGlvbnMpO1xyXG4gICAgICAgIGlmIChuZXh0TGluZSkge1xyXG4gICAgICAgICAgICBuZXh0TGluZS5pY29ucyA9IGxpbmUuaWNvbnM7XHJcbiAgICAgICAgICAgIG5leHRMaW5lLm9uKCdDb25uZWN0b3I6Y2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmJpbmRPcGVyYXRpb24obmV4dExpbmUpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLmluaXRPcGVyYXRpb25Ob2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUgPSBuZXcgT3BlcmF0aW9uTm9kZShub2RlLCB0aGlzLmdyb3VwLCB0aGlzLl9hcGkpO1xyXG5cclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUub24oT3BlcmF0aW9uTm9kZS5BUlJPV19EUkFHU1RBUlQsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gKGUuZXZlbnQub2Zmc2V0WCAtIHRoaXMuZ3JvdXAucG9zaXRpb25bMF0pIC8gdGhpcy5ub3dab29tO1xyXG4gICAgICAgICAgICB2YXIgeSA9IChlLmV2ZW50Lm9mZnNldFkgLSB0aGlzLmdyb3VwLnBvc2l0aW9uWzFdKSAvIHRoaXMubm93Wm9vbTtcclxuICAgICAgICAgICAgLy/mi5bmi73lvIDlp4vlhYjmioog566t5aS05Zu+5qCHIOe7memakOiXj1xyXG4gICAgICAgICAgICB2YXIgYXJyb3cgPSBlLmV2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgYXJyb3cuaGlkZSgpO1xyXG4gICAgICAgICAgICB2YXIgckVuZFBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xyXG4gICAgICAgICAgICB2YXIgY29ubmVjdG9yID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5tYW5hZ2VUZW1wQ29ubmVjdG9yKHRoaXMuc2VsZWN0ZWROb2RlLCByRW5kUG9pbnQsXHJcbiAgICAgICAgICAgICAgICBhcnJvdy5saW5lVHlwZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICAvLyDkvqblkKwg566t5aS0IOaLluaLveS6i+S7tlxyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZS5vbihPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUcsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gKGUuZXZlbnQub2Zmc2V0WCAtIHRoaXMuZ3JvdXAucG9zaXRpb25bMF0pIC8gdGhpcy5ub3dab29tO1xyXG4gICAgICAgICAgICB2YXIgeSA9IChlLmV2ZW50Lm9mZnNldFkgLSB0aGlzLmdyb3VwLnBvc2l0aW9uWzFdKSAvIHRoaXMubm93Wm9vbTtcclxuICAgICAgICAgICAgdmFyIGFycm93ID0gZS5ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgIHZhciByRW5kUG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIubWFuYWdlVGVtcENvbm5lY3Rvcih0aGlzLnNlbGVjdGVkTm9kZSwgckVuZFBvaW50LCBhcnJvdy5saW5lVHlwZSk7XHJcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICAvL+S+puWQrCDnrq3lpLQg5ouW5ou957uT5p2f5LqL5Lu2IOeUu+e6v1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uTm9kZS5vbihPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUdFTkQsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHggPSBlLmV2ZW50Lm9mZnNldFg7XHJcbiAgICAgICAgICAgIHZhciB5ID0gZS5ldmVudC5vZmZzZXRZO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgIC8v5ouW5ou957uT5p2f5YWI5oqKIOeureWktOWbvuaghyDnu5nmmL7npLpcclxuICAgICAgICAgICAgdmFyIGFycm93ID0gZS5ldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgIGFycm93LnNob3coKTtcclxuICAgICAgICAgICAgLy/liKDpmaTkuLTml7bnur9cclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZW1vdmVUZW1wQ29ubmVjdG9yKHRoaXMuZ3JvdXApO1xyXG5cclxuICAgICAgICAgICAgLy8xLuWmguaenOaYr+WtkOiKgueCuSDlhoUg6IqC54K55ouW5ou9IOWImSDlop7liqDmjpLpmaTlrZDoioLngrnnmoTlj4LmlbBcclxuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGZpbmRIb3Zlcih0aGlzLmFsbE5vZGVzLCB4LCB5KTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzSG92ZXIobm9kZSwgeCwgeSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucmVjdENvbnRhaW4oeCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRIb3ZlcihsaXN0LCB4LCB5LCBleGNsdWRlcykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFeGNsdWRlKGV4Y2x1ZGVzLCBsaXN0W2ldKSAvL2xpc3RbaV0gIT09IGV4Y2x1ZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0RGlzcGxheUxpc3QgbWF5IGluY2x1ZGUgaWdub3JlZCBpdGVtIGluIFZNTCBtb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFsaXN0W2ldLmlnbm9yZSAmJiBpc0hvdmVyKGxpc3RbaV0sIHgsIHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaXNFeGNsdWRlKGV4Y2x1ZGVzLCBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4genJVdGlsLmluZGV4T2YoZXhjbHVkZXMsIG5vZGUpID09IC0xO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLzIu5aaC5p6c5om+5Yiw55uu5qCH57uT54K5IOWImeeUu+e6v1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSAmJiAodGhpcy5zZWxlY3RlZE5vZGUgIT0gdGFyZ2V0Tm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb25uZWN0T3B0aW9ucztcclxuICAgICAgICAgICAgICAgIGlmIChlLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0T3B0aW9ucyA9IGUuZGF0YTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lVHlwZTogYXJyb3cubGluZVR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKCF0aGlzLl90cmlnZ2VyKCdiZWZvcmVDcmVhdGUnLCB7dGFyZ2V0OnRoaXMuc2VsZWN0ZWROb2RlLGVuZE5vZGU6dGFyZ2V0Tm9kZSxjb25uZWN0T3B0aW9uczpjb25uZWN0T3B0aW9uc30pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUNvbm5lY3RvckJ5Tm9kZXModGhpcy5zZWxlY3RlZE5vZGUsIHRhcmdldE5vZGUsIGNvbm5lY3RPcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIC8v5Yig6Zmk5oyJ6ZKu54K55Ye75LqL5Lu2XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25Ob2RlLm9uKE9wZXJhdGlvbk5vZGUuREVMRVRFX0NMSUNLLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZSh0aGlzLnNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLmdyb3VwLmFkZCh0aGlzLm9wZXJhdGlvbk5vZGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOenu+mZpOWcuuaZr+S4reeahOafkOS4quiKgueCueaIluiAhee6v+autSzlkIxyZW1vdmVOb2RlXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBub2RlIG9yIGxpbmsg5b6F5Yig6Zmk55qE6IqC54K55oiW6ICF57q/5q61XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIOWPguaVsFxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmlnZ2VyPXRydWVdIOaYr+WQpuinpuWPkeWIoOmZpOS6i+S7tlxyXG4gICAgICpcclxuICAgICAqICAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICBmaXNoVG9wby5yZW1vdmUocGVvcGxlTm9kZSk7XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIOenu+mZpOWcuuaZr+S4reeahOafkOS4quiKgueCueaIluiAhee6v+autSzlkIxyZW1vdmVcclxuICAgICAqIEBtZXRob2QgcmVtb3ZlTm9kZVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBub2RlIG9yIGxpbmsg5b6F5Yig6Zmk55qE6IqC54K55oiW6ICF57q/5q61XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIOWPguaVsFxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmlnZ2VyPXRydWVdIOaYr+WQpuinpuWPkeWIoOmZpOS6i+S7tlxyXG4gICAgICpcclxuICAgICAqICAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICBmaXNoVG9wby5yZW1vdmVOb2RlKHBlb3BsZU5vZGUpO1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnJlbW92ZSA9IGZpc2hUb3BvUHJvdG8ucmVtb3ZlTm9kZSA9IGZ1bmN0aW9uIChkZWxOb2RlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgaWYob3B0LnRyaWdnZXIgIT09ZmFsc2UgJiYgKCF0aGlzLl90cmlnZ2VyKCdiZWZvcmVEZWxldGUnLCB7dGFyZ2V0OmRlbE5vZGV9KSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFyZW50WnIgPSB0aGlzLl9nZXRQYXJlbnRacihkZWxOb2RlKTtcclxuICAgICAgICBpZiAoZGVsTm9kZSBpbnN0YW5jZW9mIENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAvLyAxLjEg5Yig6Zmk57q/5q615LiK55qE5pON5L2c5Zu+5qCHXHJcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGRlbE5vZGUuaWNvbnMsIGZ1bmN0aW9uKGxpbmVPcGVyYXRpb25JY29uKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRaci5yZW1vdmUobGluZU9wZXJhdGlvbkljb24pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAvLyAxLjIg5Yig6Zmk5b2T5YmN6YCJ5Lit57q/5q61XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZGVsZXRlQnlMaW5lKGRlbE5vZGUscGFyZW50WnIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vMi4xIOWIoOmZpOiKgueCuVxyXG4gICAgICAgICAgICBwYXJlbnRaci5yZW1vdmUoZGVsTm9kZSk7XHJcbiAgICAgICAgICAgIC8vMi4yIOS7jmFsbE5vZGVz5pWw57uE5Lit5Yig6ZmkXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlbE5vZGUuaWQgPT0gdGhpcy5hbGxOb2Rlc1tpXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsTm9kZXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vMi4zIOWIoOmZpOWSjOiKgueCueebuOWFs+iBlOeahOe6v+autVxyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmRlbGV0ZVNlbGVjdENvbihkZWxOb2RlLCB0aGlzLmdyb3VwKTtcclxuICAgICAgICAgICAgLy8yLjQg5Yig6Zmk6IqC54K55pON5L2cXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZU9wZXJhdGlvbk5vZGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vMy4g5riF56m66L+e5o6l57q/5LiK55qE6LCD5pW05L2N572u5oyJ6ZKuXHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jbGVhclNlbGVjdENvbigpO1xyXG4gICAgICAgIC8vNC4g5riF56m66L+e5o6l57q/5LiK55qE5pON5L2c5oyJ6ZKuXHJcbiAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9uTWFuYWdlci5oaWRlQWxsTGluZU9wZXJhdGlvbigpO1xyXG4gICAgICAgIC8vNC4g5rS+5Y+R5Yig6Zmk5LqL5Lu2XHJcbiAgICAgICAgIHRoaXMuX3RyaWdnZXIoXCJkZWxldGVcIiwge3RhcmdldDpkZWxOb2RlfSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNruiKgueCueWIm+W7uui/nue6v1xyXG4gICAgICogQG1ldGhvZCBjcmVhdGVDb25uZWN0b3JCeU5vZGVzXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHN0YXJ0Tm9kZSDlvIDlp4voioLngrlcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZW5kTm9kZSAgIOe7k+adn+iKgueCuVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIOe6v+autemAiemhuSDlj4Lop4F7QGxpbmsgZmlzaFRvcG9GbG93LmxpbmsjY29uc3RydWN0b3Ig5p6E6YCg5Ye95pWwb3B0aW9uc+WPguaVsH1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5jcmVhdGVDb25uZWN0b3JCeU5vZGVzID0gZnVuY3Rpb24gKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgb3B0aW9ucykge1xyXG5cclxuICAgICAgICB2YXIgbGlua1R5cGUgPSBvcHRpb25zLnN0eWxlLmxpbmVUeXBlIHx8IENvbm5lY3Rvci5UWVBFX1NUUkFJR0hUO1xyXG4gICAgICAgIGlmICghZmxvd0xpbmtbbGlua1R5cGVdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgTGluayA9IGZsb3dMaW5rW2xpbmtUeXBlXTtcclxuICAgICAgICB2YXIgY29ubmVjdG9yID0gbmV3IExpbmsoc3RhcnROb2RlLCBlbmROb2RlLCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmFkZChjb25uZWN0b3IpO1xyXG5cclxuICAgICAgICBpZiAoc3RhcnROb2RlLnBhcmVudCAmJiBlbmROb2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICBlbmROb2RlLnBhcmVudC5hZGQoY29ubmVjdG9yKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29ubmVjdG9yLm9uKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JGb3JiaWRFZGl0KCF0aGlzLm9wdGlvbnMubGlua01vZGlmeSk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNOb2RlID0gZmFsc2U7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICBjb25uZWN0b3Iub24oXCJkYmxjbGlja1wiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dEVkaXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RvckVkaXQodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICB0aGlzLl90cmlnZ2VyKFwiY3JlYXRlXCIsIHt0YXJnZXQ6Y29ubmVjdG9yfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5rS+5Y+R5Yib5bu65a6M5oiQ5LqL5Lu2ICDov5Tlm55mYWxlc+WImeWPlua2iFxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLl90cmlnZ2VyID0gZnVuY3Rpb24odHlwZSwgZXZlbnQsIGRhdGEpIHtcclxuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLm9wdGlvbnNbdHlwZV07XHJcblxyXG4gICAgICAgIGlmIChkYXRhID09PSB2b2lkIDApIGRhdGEgPSB7fTtcclxuICAgICAgICBpZiAoZXZlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgZXZlbnQgPSB7dHlwZTp0eXBlLCB0YXJnZXQ6dGhpc31cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudC50eXBlID0gdHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnQuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5fYXBpLnRyaWdnZXIoZXZlbnQudHlwZSwgZXZlbnQpO1xyXG4gICAgICAgIHJldHVybiAhKHpyVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSAmJiBjYWxsYmFjay5hcHBseSh0aGlzLCBbZXZlbnRdLmNvbmNhdChkYXRhKSkgPT09IGZhbHNlKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5ub2RlQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAvLyDpvKDmoIfngrnkuIsg5bCG5pON5L2c5qGGIOenu+WIsOWvueW6lOeahOiKgueCueS4ilxyXG4gICAgICAgIGlmIChub2RlLnNlbGVjdGFibGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmIChGbG93LmlzSW5Hcm91cChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gbm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAuc2VsZWN0YWJsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBncm91cDsgICAvLyDlpoLmnpzmnInnu4TnmoTor53vvIzlsLHpkojlr7nnu4Tov5vooYzlpITnkIZcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZE5vZGUgPSBub2RlO1xyXG4gICAgICAgIHZhciBzaGFwZVJlY3QgPSB1dGlsLmdldFJlY3Qobm9kZSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLm9wZXJhdGlvbk5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0T3BlcmF0aW9uTm9kZShub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5Zyo5a2Y5Zyo5a2Q5rWB56iL55qE5oOF5Ya15LiLIOmcgOimgeaKim5vZGXkuZ/kvKDpgJLkuIDkuItcclxuICAgICAgICB0aGlzLm9wZXJhdGlvbk5vZGUucmVmcmVzaFBvc3Rpb24obm9kZSwgc2hhcGVSZWN0KTtcclxuICAgIH07XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5fZ3JvdXBEcmFnSGFuZGxlciA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgLy8gZmxvd+S4reacgOWkluWxgueahGdyb3Vw56e75Yqo5pON5L2cXHJcbiAgICAgICAgdmFyIG5vd0dyb3VwUG9zaXRpb24gPSB0aGlzLmdyb3VwLnBvc2l0aW9uO1xyXG4gICAgICAgIHZhciBncm91cFBvc2l0aW9uWCA9IHRoaXMuZ3JvdXAucG9zaXRpb25bMF07XHJcbiAgICAgICAgdmFyIGdyb3VwUG9zaXRpb25ZID0gdGhpcy5ncm91cC5wb3NpdGlvblsxXTtcclxuXHJcbiAgICAgICAgdmFyIG1vdmVIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggKiB0aGlzLm5vd1pvb207XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAqIHRoaXMubm93Wm9vbTtcclxuICAgICAgICAgICAgdmFyIGd4ID0gdGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKS54ICogdGhpcy5ub3dab29tO1xyXG4gICAgICAgICAgICB2YXIgZ3kgPSB0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLnkgKiB0aGlzLm5vd1pvb207XHJcbiAgICAgICAgICAgIHZhciBtaW4gPSBbMTAgLSAod2lkdGggKyBneCksIDEwIC0gKGhlaWdodCArIGd5KV07XHJcbiAgICAgICAgICAgIHZhciBtYXggPSBbKHRoaXMuX3pyLmdldFdpZHRoKCkgLSBneCkgLSAxMCwgKHRoaXMuX3pyLmdldEhlaWdodCgpIC0gZ3kpIC0gMTBdO1xyXG4gICAgICAgICAgICB2YXIgc1ggPSBldmVudC5vZmZzZXRYIC0geDtcclxuICAgICAgICAgICAgdmFyIHNZID0gZXZlbnQub2Zmc2V0WSAtIHk7XHJcbiAgICAgICAgICAgIG5vd0dyb3VwUG9zaXRpb25bMF0gPSBncm91cFBvc2l0aW9uWCArIHNYO1xyXG4gICAgICAgICAgICBub3dHcm91cFBvc2l0aW9uWzFdID0gZ3JvdXBQb3NpdGlvblkgKyBzWTtcclxuICAgICAgICAgICAgaWYgKG5vd0dyb3VwUG9zaXRpb25bMF0gPiBtYXhbMF0gfHwgbm93R3JvdXBQb3NpdGlvblsxXSA+IG1heFsxXSB8fCBub3dHcm91cFBvc2l0aW9uWzBdIDxcclxuICAgICAgICAgICAgICAgIG1pblswXSB8fCBub3dHcm91cFBvc2l0aW9uWzFdIDwgbWluWzFdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmF0dHIoXCJwb3NpdGlvblwiLCBub3dHcm91cFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVhZ2xlRXllID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbmltYXAudXBkYXRhU2VsZWN0aW9uUG9zaXRpb24obm93R3JvdXBQb3NpdGlvbiwgdGhpcy5ub3dab29tKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl96ci5vbignbW91c2Vtb3ZlJywgbW92ZUhhbmRsZXIpO1xyXG5cclxuICAgICAgICB2YXIgZW5kRHJhZ0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3pyLm9mZignbW91c2Vtb3ZlJywgbW92ZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl96ci5vZmYoJ21vdXNldXAnLCBlbmREcmFnSGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX3pyLm9mZihcImdsb2JhbG91dFwiLCBlbmREcmFnSGFuZGxlcik7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3pyLm9uKCdtb3VzZXVwJywgZW5kRHJhZ0hhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuX3pyLm9uKFwiZ2xvYmFsb3V0XCIsIGVuZERyYWdIYW5kbGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog6IqC54K555qE56e75Yqo5pON5L2cLCDkuLrkvZXopoHoh6rlt7Hlrp7njrDmi5bliqjvvJ96cmVkbmVyIEdyb3Vw5LiN5pSv5oyB5ouW5Yqo77yM5Y+q6IO96Ieq5bex5a6e546wXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uZHJhZyA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzOyAvLyB6cmVuZGVy5Lit55qE5LiA5LiqYnVnIGV2ZW50LnRhcmdldOS4jeS8muW4pmdyb3VwIOWPquiDveeUqHRoYXQg5LiN6IO955SoYmluZCh0aGlzKVxyXG4gICAgICAgIG5vZGUub24oXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IHRoaXM7XHJcbiAgICAgICAgICAgIC8v5aaC5p6c5Yqg5LqG5bGe5oCnIGRyYWdnYWJsZTpmYWxzZSDliJnkuI3lj6/ku6Xmi5bliqhcclxuICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0LmlzZHJhZ2dhYmxlID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhhdC5fbm9kZURyYWdIYW5kbGVyKGRyYWdnaW5nVGFyZ2V0LCBldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcclxuICAgICAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgZmlzaFRvcG9Qcm90by5fbm9kZURyYWdIYW5kbGVyID0gZnVuY3Rpb24gKG5vZGUsIHgsIHkpIHtcclxuICAgICAgICB2YXIgaXNNb3ZlID0gMDtcclxuICAgICAgICB2YXIgbm93R3JvdXBQb3NpdGlvbiA9IG5vZGUucG9zaXRpb247XHJcbiAgICAgICAgdmFyIGdyb3VwUG9zaXRpb25YID0gbm9kZS5wb3NpdGlvblswXTtcclxuICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvblkgPSBub2RlLnBvc2l0aW9uWzFdO1xyXG4gICAgICAgIG5vZGUuX3N0YXJ0WCA9IHg7XHJcbiAgICAgICAgbm9kZS5fc3RhcnRZID0geTtcclxuXHJcbiAgICAgICAgbm9kZS50cmlnZ2VyKFwiZHJhZ3N0YXJ0XCIpO1xyXG4gICAgICAgIC8vIDHjgIHkvqblkKznp7vliqjkuovku7ZcclxuXHJcbiAgICAgICAgdmFyIG1vdmVIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBzWCA9IChldmVudC5vZmZzZXRYIC0gbm9kZS5fc3RhcnRYKSAvICh0aGlzLm5vd1pvb20pO1xyXG4gICAgICAgICAgICB2YXIgc1kgPSAoZXZlbnQub2Zmc2V0WSAtIG5vZGUuX3N0YXJ0WSkgLyAodGhpcy5ub3dab29tKTtcclxuXHJcbiAgICAgICAgICAgIGlmICgoc1ggIT0gMCkgfHwgKHNZICE9IDApKSB7XHJcbiAgICAgICAgICAgICAgICBpc01vdmUgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGUudHJpZ2dlcihcImRyYWdcIik7XHJcbiAgICAgICAgICAgIC8vIDEuMeWkhOeQhue7hOWGheeahOaDheWGte+8iOWmguaenOiKgueCueaLluWKqO+8jOe7hOS5n+i3n+edgOWPmO+8iVxyXG4gICAgICAgICAgICBpZiAoRmxvdy5pc0luR3JvdXAobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIC8v5pS+5YWlbm9kZeeOsOacieaVsOWAvO+8jOeUqOS6jumHjee7mGdyb3VwXHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZU1lc3NhZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG5vZGUuc2hhcGUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlLnNoYXBlLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogbm9kZS5wb3NpdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlUG9zaXRpb246IFtncm91cFBvc2l0aW9uWCwgZ3JvdXBQb3NpdGlvblldLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVYOiBzWCxcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlWTogc1ksXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogbm9kZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Lm1vZGlmeUdyb3VwUmVjdChub2RlTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm93R3JvdXBQb3NpdGlvblswXSA9IGdyb3VwUG9zaXRpb25YICsgc1g7XHJcbiAgICAgICAgICAgIG5vd0dyb3VwUG9zaXRpb25bMV0gPSBncm91cFBvc2l0aW9uWSArIHNZO1xyXG4gICAgICAgICAgICBub2RlLmF0dHIoXCJwb3NpdGlvblwiLCBub3dHcm91cFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgLy8gMS4yIOWkhOeQhuWRiuitpueahOaDheWGtSDvvIjlkYrorabpmo/nnYDoioLngrnnp7vliqjvvIlcclxuICAgICAgICAgICAgaWYgKG5vZGUuYWxhcm0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdBbGFybVBvc2l0aW9uID0gW25vd0dyb3VwUG9zaXRpb25bMF0gKyBub2RlLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC0gKG5vZGUuYWxhcm1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC0gNiksIG5vd0dyb3VwUG9zaXRpb25bMV0gLSBub2RlLmFsYXJtLmdldEJvdW5kaW5nUmVjdCgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmhlaWdodCAtIDNcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBub2RlLmFsYXJtLmF0dHIoXCJwb3NpdGlvblwiLCBuZXdBbGFybVBvc2l0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAxLjQg6Kem5Y+R54K55Ye7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZUNsaWNrSGFuZGxlcihub2RlKTtcclxuICAgICAgICAgICAgLy8gMS41IOWIt+aWsOi/nue6v1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKG5vZGUpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl96ci5vbignbW91c2Vtb3ZlJywgbW92ZUhhbmRsZXIpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIC8vMi4g5ouW5ou957uT5p2fXHJcbiAgICAgICAgdmFyIGVuZERyYWdIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5tb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5tb2RlbC5zZXQoXCJvcHRpb25zLnBvc2l0aW9uXCIsIEZsb3dVdGlsLnRydW5jUG9zaXRpb24obm9kZS5wb3NpdGlvbikpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl96ci5vZmYoJ21vdXNlbW92ZScsIG1vdmVIYW5kbGVyKTtcclxuICAgICAgICAgICAgdGhpcy5fenIub2ZmKCdtb3VzZXVwJywgZW5kRHJhZ0hhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl96ci5vZmYoXCJnbG9iYWxvdXRcIiwgZW5kRHJhZ0hhbmRsZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8yLjEg57yp5b6u5Zu+XHJcbiAgICAgICAgICAgIGlmIChpc01vdmUgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcihcImRyb3BEcmFnXCIsIHt0YXJnZXQ6bm9kZX0pO1xyXG4gICAgICAgICAgICAgICAgbm9kZS50cmlnZ2VyKFwiZHJhZ2VuZFwiKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVhZ2xlRXllID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW5FYWdsZUV5ZSh0aGlzLmVhZ2xlRXllTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fenIub24oJ21vdXNldXAnLCBlbmREcmFnSGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5fenIub24oJ2dsb2JhbG91dCcsIGVuZERyYWdIYW5kbGVyKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7roioLngrlcclxuICAgICAqIEBtZXRob2QgY3JlYXRlTm9kZVxyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlIOexu+WeiyBlZy4gJ1JlY3Qn44CBJ0NpcmNsZSfjgIEnSW1hZ2Un44CBJ0dyb3VwJ+OAgSdUZXh0J+etiVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHQg6IqC54K56YCJ6aG5IOivpuingXtAbGluayBmaXNoVG9wb0Zsb3cubm9kZSBDb25maWcgb3B0aW9uc31cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyRGF0YSDnlKjmiLfkvKDpgJLnmoTkuJrliqHmlbDmja5cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0g5Yib5bu655qE6IqC54K55a+56LGhXHJcbiAgICAgKlxyXG4gICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICpcclxuICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAqICAgICAgdmFyIHJlY3QgPSB0aGlzLmZpc2hUb3BvLmNyZWF0ZU5vZGUoXCJSZWN0XCIsIHsgLy/nn6nlvaJcclxuICAgICAqICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgKiAgICAgICAgICAgICAgd2lkdGg6IDEwMCxcclxuICAgICAqICAgICAgICAgICAgICBoZWlnaHQ6IDYwLFxyXG4gICAgICogICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgKiAgICAgICAgICAgICAgdGV4dDogXCLln7rmnKznn6nlvaJcIixcclxuICAgICAqICAgICAgICAgICAgICBmaWxsOiBcIiMxNjdDRkZcIixcclxuICAgICAqICAgICAgICAgICAgICBzdHJva2U6IFwicmdiKDI1NSwyNTUsMjU1KVwiLFxyXG4gICAgICogICAgICAgICAgICAgIHRleHRGb250OiAnMTRweCBNaWNyb3NvZnQgWWFIZWknXHJcbiAgICAgKiAgICAgICAgICB9LFxyXG4gICAgICogICAgICAgICAgcG9zaXRpb246IFsxODAsIDEwMF0sXHJcbiAgICAgKiAgICAgICAgICBvcGVyYXRpb25JY29uczogW3sgbmFtZTogJ0RFTCcgfSxcclxuICAgICAqICAgICAgICAgICAgICB7IG5hbWU6ICdTVFJBSUdIVCcgfSxcclxuICAgICAqICAgICAgICAgICAgICB7IG5hbWU6ICdKQUdHRUQnIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgeyBuYW1lOiAnQ1VSVkUnIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAge1xyXG4gICAgICogICAgICAgICAgICAgICAgICBuYW1lOiBcImN1c3RvbTFcIixcclxuICAgICAqICAgICAgICAgICAgICAgICAgaWNvblBhdGg6IFwiaW1nL2hvc3QucG5nXCIsXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbihlKSB7IGFsZXJ0KGUuZGF0YS5uYW1lICsgXCIgY2xpY2tlZFwiKSB9ICAvL2Uubm9kZeaYr+W9k+WJjeeahOiKgueCuVxyXG4gICAgICogICAgICAgICAgICAgIH1cclxuICAgICAqICAgICAgICAgIF1cclxuICAgICAqICAgICAgfSk7XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY3JlYXRlTm9kZSA9IGZpc2hUb3BvUHJvdG8uY3JlYXROb2RlID0gZnVuY3Rpb24gKHR5cGUsIG9wdCwgdXNlckRhdGEpIHtcclxuICAgICAgICBpZiAoIWZsb3dOb2RlW3R5cGVdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgU2hhcGUgPSBmbG93Tm9kZVt0eXBlXTtcclxuICAgICAgICB2YXIgbm9kZSA9IG5ldyBTaGFwZShvcHQpO1xyXG5cclxuICAgICAgICBGbG93LnNldFVzZXJEYXRhKG5vZGUsIHVzZXJEYXRhKTtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja5uYW1l6I635Y+W6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUg5Zyo5Yib5bu66IqC54K55LitICBuYW1l5bGe5oCn6K6+572u55qE5YC8XHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgbmFtZeWvueW6lOeahOiKgueCuVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNoaWxkT2ZOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgYXJyUmVzdWx0ID0gW107XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuTm9kZSA9IHRoaXMuYWxsTm9kZXM7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuTGluZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9ycztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTm9kZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5Ob2RlW2ldLm1vZGVsLmdldChcIm9wdGlvbnMubmFtZVwiKSAmJiBjaGlsZHJlbk5vZGVbaV0ubW9kZWwuZ2V0KFwib3B0aW9ucy5uYW1lXCIpID09XHJcbiAgICAgICAgICAgICAgICBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJSZXN1bHQucHVzaChjaGlsZHJlbk5vZGVbaV0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuTm9kZVtpXS5tb2RlbC5nZXQoXCJ1c2VyRGF0YS5uYW1lXCIpID09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGFyclJlc3VsdC5wdXNoKGNoaWxkcmVuTm9kZVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZHJlbkxpbmUubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuTGluZVtqXS5tb2RlbC5nZXQoXCJvcHRpb25zLm5hbWVcIikgJiYgY2hpbGRyZW5MaW5lW2pdLm1vZGVsLmdldChcIm9wdGlvbnMubmFtZVwiKSA9PVxyXG4gICAgICAgICAgICAgICAgbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgYXJyUmVzdWx0LnB1c2goY2hpbGRyZW5MaW5lW2pdKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZHJlbkxpbmVbal0ubW9kZWwuZ2V0KFwidXNlckRhdGEubmFtZVwiKSA9PSBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJSZXN1bHQucHVzaChjaGlsZHJlbkxpbmVbal0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcnJSZXN1bHQubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyUmVzdWx0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJSZXN1bHRbMF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOafpeaJvuWcuuaZr+S4reeahOWvueixoSAgIOS+i+WmgjogeOWdkOagh+Wkp+S6jjEwMOeahOiKgueCuSBmaW5kRWxlbWVudHMoZnVuY3Rpb24obm9kZSl7IHJldHVybiBub2RlLnBvc2l0aW9uWzBdID4gMTAwOyB9KTtcclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYiAgICAgIOWbnuiwg+WHveaVsCDlj4LmlbDkuLrpgY3ljobnmoToioLngrlcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gICBjb250ZXh0IOWbnuiwg+WHveaVsOaJp+ihjOeahOS4iuS4i+aWh1xyXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICDov5Tlm57mn6Xmib7liLDnmoTlr7nosaFcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5maW5kRWxlbWVudHMgPSBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgY2hpbGRyZW5Ob2RlID0gdGhpcy5hbGxOb2RlcztcclxuICAgICAgICB2YXIgY2hpbGRyZW5MaW5lID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0b3JzO1xyXG4gICAgICAgIHZhciBhcnIgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTm9kZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbk5vZGVbaV07XHJcbiAgICAgICAgICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIGNoaWxkLCBpKSkge1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hpbGRyZW5MaW5lLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZEwgPSBjaGlsZHJlbkxpbmVbal07XHJcbiAgICAgICAgICAgIGlmIChjYi5jYWxsKGNvbnRleHQsIGNoaWxkTCwgaikpIHtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKGNoaWxkTCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva7og4zmma/oibIgIOaIliDog4zmma/lm77niYdcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZVVybCDog4zmma/oibIgIOaIliDog4zmma/lm77niYcgZWcuICdpbWcvYmcuanBnJ++8jOS4uuKAmGdyaWRMaW5l4oCZ5pe2572R5qC86IOM5pmvXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaXNSZXBlYXQg5piv5ZCm6YeN5aSN6IOM5pmvICDlpoLmnpzph43lpI3nmoTor53vvIzlsIbkvb/nlKhjc3PnmoRyZXBlYXQg5Zug5Li6Y2FudmFz5LiN5pSv5oyBcmVwZWF0XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uc2V0QmFja2dyb3VuZCA9IGZ1bmN0aW9uIChpbWFnZVVybCwgaXNSZXBlYXQpIHtcclxuICAgICAgICBpZiAoaW1hZ2VVcmwgJiYgaW1hZ2VVcmwubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldChDb25zdGFudHMuQkFDS0dST1VORCwgaW1hZ2VVcmwpO1xyXG4gICAgICAgICAgICBpZiAoaW1hZ2VVcmwuc3Vic3RyKDAsIDEpID09IFwiI1wiIHx8IGltYWdlVXJsLnN1YnN0cigwLCA0KSA9PSBcInJnYmFcIikgeyAvL+WmguaenOaYr+minOiJsuWIm+W7unJlY3TkuLrog4zmma9cclxuICAgICAgICAgICAgICAgIGlmICghZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBpbWFnZVVybDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlU2hhcGUgPSBuZXcgdGhpcy5TaGFwZS5SZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLl96ci5nZXRXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLl96ci5nZXRIZWlnaHQoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogaW1hZ2VVcmxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHo6IC0xXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fenIuYWRkKGltYWdlU2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbWFnZVVybCA9PSBcImdyaWRMaW5lXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZExpbmVHcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRMaW5lKDAuMik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl96ci5hZGQodGhpcy5ncmlkTGluZUdyb3VwKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCB8fCBpc1JlcGVhdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvbS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBcInVybChcIiArIGltYWdlVXJsICsgXCIpXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9tLnN0eWxlLmJhY2tncm91bmRSZXBlYXQgPSBcInJlcGVhdFwiO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VTaGFwZTEgPSBuZXcgdGhpcy5TaGFwZS5JbWFnZSh7IC8v5aaC5p6c5piv5Zu+54mH5Yib5bu6aW1hZ2XkuLrog4zmma9cclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFswLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGU6IFsxLCAxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlVXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuX3pyLmdldFdpZHRoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuX3pyLmdldEhlaWdodCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB6OiAtMVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3pyLmFkZChpbWFnZVNoYXBlMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8v6IOM5pmv572R5qC857q/XHJcbiAgICBmaXNoVG9wb1Byb3RvLmdyaWRMaW5lID0gZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuICAgICAgICB2YXIgcGl4ZWwgPSAxMDtcclxuICAgICAgICB2YXIgd2lkdGhMZW4gPSBwYXJzZUludCh0aGlzLmdldFdpZHRoKCkgLyBwaXhlbCk7XHJcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPD0gd2lkdGhMZW47IHgrKykge1xyXG4gICAgICAgICAgICB2YXIgbGluZVggPSBuZXcgZ3JhcGhpYy5MaW5lKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDE6IHggKiBwaXhlbCxcclxuICAgICAgICAgICAgICAgICAgICB5MTogMCxcclxuICAgICAgICAgICAgICAgICAgICB4MjogeCAqIHBpeGVsLFxyXG4gICAgICAgICAgICAgICAgICAgIHkyOiB0aGlzLmdldEhlaWdodCgpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lRGFzaDogWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB6OiAwLFxyXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmdyaWRMaW5lR3JvdXAuYWRkKGxpbmVYKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBoZWlnaHRMZW4gPSBwYXJzZUludCh0aGlzLmdldEhlaWdodCgpIC8gcGl4ZWwsIHBpeGVsKTtcclxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8PSBoZWlnaHRMZW47IHkrKykge1xyXG4gICAgICAgICAgICB2YXIgbGluZVkgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDE6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgeTE6IHkgKiBwaXhlbCxcclxuICAgICAgICAgICAgICAgICAgICB4MjogdGhpcy5nZXRXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHkyOiB5ICogcGl4ZWxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVEYXNoOiBbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHo6IDAsXHJcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JpZExpbmVHcm91cC5hZGQobGluZVkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rnur/mrrVcclxuICAgICAqIEBtZXRob2QgY3JlYXRlTGlua1xyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzdGFydE5vZGUg5byA5aeL6IqC54K5XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGVuZE5vZGUgICDnu5PmnZ/oioLngrlcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyDnur/mrrXpgInpoblcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zdHlsZV0g6IqC54K555qE5qC35byPXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3R5bGUubGluZVdpZHRoPTFdIOe6v+auteeahOWuveW6plxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN0eWxlLmxpbmVUeXBlPSdzdHJhaWdodCddIOe6v+auteeahOexu+WeiyBlZy4gJ3N0cmFpZ2h0JywgJ2phZ2dlZCcsJ2N1cnZlJ1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN0eWxlLnN0cm9rZT1cIiMwMDAwMDBcIl0g57q/5q6155qE6aKc6Imy5YC8IGVnLiAnIzE1N2NmZicgICdyZ2IoMTIyLDEyMiwxMjIpJ1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLnN0eWxlLmxpbmVEYXNoXSDomZrnur/nmoTpl7TpmpQgZWcuIFszLDNdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc3ltYm9sXSDnur/mrrXnmoTnrq3lpLRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wudHlwZT0nYXJyb3cnXSDnur/mrrXnmoTnrq3lpLTnmoTnsbvlnosg5Y+v6YCJ5YC85Li677yaICdjaXJjbGUnLCAncmVjdCcsICdyb3VuZFJlY3QnLCAndHJpYW5nbGUnLCAnZGlhbW9uZCcsICdwaW4nLCAnYXJyb3cnXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3ltYm9sLnNpemU9MTBdIOe6v+auteeahOeureWktOeahOWwuuWvuFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN5bWJvbC5jb2xvcj0nIzAwMDAwMCddIOe6v+auteeahOeureWktOeahOminOiJslxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN5bWJvbC56XSBb566t5aS055qE5bGC57qn77yM6LaK5aSn6LaK5Zyo5YmN6Z2i5pi+56S6XVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRleHRdIOe6v+auteS4iueahOaWh+Wtl1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHQudGV4dF0g57q/5q615LiK55qE5paH5a2X5YaF5a65XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC5jb2xvcl0g57q/5q615LiK55qE5paH5a2X6aKc6ImyXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC50ZXh0UG9zXSDmloflrZfkvY3nva7lj6/pgInlgLwgJ3N0YXJ0JywnY2VudGVyJywnZW5kJyzpu5jorqTlgLzkuLpjZW50ZXJcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfEFycmF5fSBbb3B0aW9ucy50ZXh0Lm9mZnNldF0g5paH5a2X5L2N572u5YGP56e76YePLOS4um51bWJlcuWImeaYr3jlgY/np7sgYXJyYXnliJnkuLpbeCx5XVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc10g5L+d55WZIOivt+S9v+eUqG9wdGlvbnMucG9zaXRpb24uZGlyZWN0aW9uIOaMh+Wumue6v+autei1t+Wni+S4jue7iOatoiDlnKjoioLngrnnmoTku4DkuYjkvY3nva4g6buY6K6k5YC85Li6J2xlZnQscmlnaHQnICDlj6/lj5blgLzlm5vkuKrmlrnlkJF0b3AsYm90dG9tLGxlZnQscmlnaHQg5pa55ZCR5Y+v5Yqg5YGP56e76YeP5aaC5aaCIFwibGVmdCsxMCx0b3BcIlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uXSDmjIflrprnur/mrrXkvY3nva5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb3NpdGlvbi5kaXJlY3Rpb25dIOaMh+Wumue6v+autei1t+Wni+S4jue7iOatoiDlnKjoioLngrnnmoTku4DkuYjkvY3nva4g6buY6K6k5YC85Li6J2xlZnQscmlnaHQnICDlj6/lj5blgLzlm5vkuKrmlrnlkJF0b3AsYm90dG9tLGxlZnQscmlnaHQg5pa55ZCR5Y+v5Yqg5YGP56e76YeP5aaC5aaCIFwibGVmdCsxMCx0b3BcIlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLnN0YXJ0T2Zmc2V0XSDnur/mrrXlvIDlp4vkvY3nva7nmoTlgY/np7tcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb3NpdGlvbi5lbmRPZmZzZXRdIOe6v+autee7k+adn+S9jee9rueahOWBj+enu1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uLmVzY2FwZURpc3RhbmNlXSDmjIflrprnur/mrrXnrKzkuIDmnaHmipjnur/nmoTplb/luqbvvIzmnIDlkI7kuIDmnaHmipjnur/nmoTplb/luqbvvIzpu5jorqTlgLzkuLpbMzAsIDMwXVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uLnBvaW50c10g5LiN5L2/55So6Ieq5Yqo6K6h566XIOaMh+Wumui/nue6v+eahOaKmOeCueS9jee9ruaVsOe7hO+8jOmmluWwvuWPr+S7peS9v+eUqGxlZnQscmlnaHQsdG9wLGJvdHRvbVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmVmZmVjdF0g57q/5LiK5Yqo5oCB5pWI5p6cXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZWZmZWN0LnNob3ddIOaYr+WQpuaYvuekuueureWktOWKqOaViFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVmZmVjdC5wZXJpb2RdIOWKqOaViOenu+WKqOmAn+W6plxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvQ2hhbmdlUG9zaXRpb25dIOi/nue6v+eahOi/nuaOpeeCuemaj25vZGXnp7vliqjoh6rliqjliIfmjaLkvY3nva7vvIzpu5jorqTkuLpmbGFzZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnpdIFvov57nur/nmoTlsYLnuqfvvIzotorlpKfotorlnKjliY3pnaLmmL7npLpdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlckRhdGEg55So5oi35Lyg6YCS55qE5Lia5Yqh5pWw5o2uXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IOWIm+W7uueahOe6v+auteWvueixoVxyXG4gICAgICpcclxuICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgIHZhciBsaW5rID0gbWUuZmlzaFRvcG8uY3JlYXRlTGluayhzdGFydE5vZGUsIGVuZE5vZGUsIHtcclxuICAgICAqICAgICAgICAgICAgICBzeW1ib2w6IHsgdHlwZTogJ2Fycm93Jywgc2l6ZTogMTAsIGNvbG9yOiBcInJnYigwLDIwMCwyNTUpXCIgfSwgLy/nrq3lpLQgIOWPr+mAieWAvOS4uu+8miAnY2lyY2xlJywgJ3JlY3QnLCAncm91bmRSZWN0JywgJ3RyaWFuZ2xlJywgJ2RpYW1vbmQnLCAncGluJywgJ2Fycm93J1xyXG4gICAgICogICAgICAgICAgICAgIHN0eWxlOiB7IGxpbmVXaWR0aDogMywgc3Ryb2tlOiBcInJnYigwLDIwMCwyNTUpXCIsIGxpbmVEYXNoOiBbMywzXSwgbGluZVR5cGU6IFwiamFnZ2VkXCIgIH0sIC8v5qC35byPXHJcbiAgICAgKiAgICAgICAgICAgICAgdGV4dDoge1xyXG4gICAgICogICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICogICAgICAgICAgICAgICAgICBjb2xvcjogJyNmZmZmZmYnLFxyXG4gICAgICogICAgICAgICAgICAgICAgICB0ZXh0UG9zOnRleHRQb3MsLy/mloflrZfkvY3nva7lj6/pgInlgLwgJ3N0YXJ0JywnY2VudGVyJywnZW5kJyzpu5jorqTlgLzkuLpjZW50ZXJcclxuICAgICAqICAgICAgICAgICAgICAgICAgeE9mZnNldDoxMCwgLy/mloflrZfkvY3nva545YGP56e76YePXHJcbiAgICAgKiAgICAgICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgICAgICBwb3M6J3JpZ2h0LGxlZnQnLFxyXG4gICAgICogICAgICAgICAgICAgIGVmZmVjdDoge1xyXG4gICAgICogICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLC8v5piv5ZCm5pi+56S6566t5aS05Yqo5pWIXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIHBlcmlvZDogNiwvL+eureWktOmAn+W6plxyXG4gICAgICogICAgICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgcG9zaXRpb246e1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgIGVzY2FwZURpc3RhbmNlOls1MCwzMF0sICAvL+esrOS4gOadoeaKmOe6v+eahOmVv+W6pu+8jOacgOWQjuS4gOadoeaKmOe6v+eahOmVv+W6plxyXG4gICAgICogICAgICAgICAgICAgICAgICAgIHBvaW50czpbXCJ4MSx5MVwiLFwieDIseTJcIl0gIOS4jeS9v+eUqOiHquWKqOiuoeeulyDmjIflrprov57nur/nmoTkvY3nva7mlbDnu4RcclxuICAgICAqICAgICAgICAgICAgICB9LFxyXG4gICAgICogICAgICAgICAgICAgIHo6IDBcclxuICAgICAqICAgICAgICAgIH0pO1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNyZWF0ZUxpbmsgPSBmaXNoVG9wb1Byb3RvLmNyZWF0TGluayA9IGZ1bmN0aW9uIChzdGFydE5vZGUsIGVuZE5vZGUsIG9wdGlvbnMsIHVzZXJEYXRhKSB7XHJcbiAgICAgICAgdmFyIGxpbmtUeXBlID0gQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQ7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zdHlsZSAmJiBvcHRpb25zLnN0eWxlLmxpbmVUeXBlKSB7XHJcbiAgICAgICAgICAgIGxpbmtUeXBlID0gb3B0aW9ucy5zdHlsZS5saW5lVHlwZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFmbG93TGlua1tsaW5rVHlwZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBMaW5rID0gZmxvd0xpbmtbbGlua1R5cGVdO1xyXG4gICAgICAgIHZhciBjb25uZWN0b3IgPSBuZXcgTGluayhzdGFydE5vZGUsIGVuZE5vZGUsIG9wdGlvbnMpO1xyXG4gICAgICAgIGlmICh1c2VyRGF0YSkge1xyXG4gICAgICAgICAgICBjb25uZWN0b3IubW9kZWwuc2V0KENvbnN0YW50cy5VU0VSREFUQSwgenJVdGlsLmNsb25lKHVzZXJEYXRhKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNruiKgueCueWIt+aWsOiKgueCueaJgOi/nueahOe6v++8iOmHjeaWsOiuoeeul+e6v+eahOS9jee9ru+8iVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBub2RlIFvoioLngrldXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8ucmVmcmVzaExpbmVCeU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUobm9kZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiDnur/kuIrmloflrZfnvJbovpFcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5jb25uZWN0b3JFZGl0ID0gZnVuY3Rpb24gKHRoaXNDb25uZWN0b3IpIHtcclxuICAgICAgICB2YXIgbGluZVRleHQgPSB0aGlzQ29ubmVjdG9yLmNoaWxkT2ZOYW1lKCdsaW5lVGV4dCcpO1xyXG4gICAgICAgIGlmICghbGluZVRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGV4dGFyZWEgPSB0aGlzLmNyZWF0ZVRleHRBcmVhKCk7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSAxLjEgKiB1dGlsLmdldFJlY3QobGluZVRleHQpLndpZHRoICogdGhpcy5ub3dab29tICsgXCJweFwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmhlaWdodCA9ICh1dGlsLmdldFJlY3QobGluZVRleHQpLmhlaWdodCB8fCAxMikgKiB0aGlzLm5vd1pvb20gKyBcInB4XCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuYm9yZGVyID0gXCIxcHggc29saWQgIzAwMDAwMFwiO1xyXG4gICAgICAgIHRleHRhcmVhLmlubmVySFRNTCA9IGxpbmVUZXh0LnN0eWxlLnRleHQ7XHJcbiAgICAgICAgdGhpc0Nvbm5lY3Rvci5zZXRTdHlsZSh7XHJcbiAgICAgICAgICAgIHRleHQ6IHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy5fZG9tLmFwcGVuZENoaWxkKHRleHRhcmVhKTtcclxuICAgICAgICB0aGlzLl9kb20uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XHJcbiAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KGxpbmVUZXh0LnN0eWxlLnRleHQsIGxpbmVUZXh0LnN0eWxlLnRleHRGb250KTtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5saW5lSGVpZ2h0ID0gKHRleHRSZWN0LmxpbmVIZWlnaHQgfHwgMTQpICsgXCJweFwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLnRvcCA9IChsaW5lVGV4dC5wb3NpdGlvblsxXSAtIHV0aWwuZ2V0UmVjdChsaW5lVGV4dCkuaGVpZ2h0KSAqIHRoaXMubm93Wm9vbSArIHRoaXMuZ3JvdXBcclxuICAgICAgICAgICAgLnBvc2l0aW9uWzFdICsgXCJweFwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmxlZnQgPSAobGluZVRleHQucG9zaXRpb25bMF0gLSAwLjA1ICogdXRpbC5nZXRSZWN0KGxpbmVUZXh0KS53aWR0aCkgKiB0aGlzLm5vd1pvb20gK1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwLnBvc2l0aW9uWzBdICsgXCJweFwiO1xyXG4gICAgICAgIHRleHRhcmVhLmZvY3VzKCk7XHJcbiAgICAgICAgdGV4dGFyZWEuc2VsZWN0KCk7XHJcbiAgICAgICAgJCh0ZXh0YXJlYSkub24oXCJrZXl1cFwiLCB6clV0aWwuYmluZChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgdGV4dFJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QobGluZVRleHQuc3R5bGUudGV4dCwgbGluZVRleHQuc3R5bGUudGV4dEZvbnQpO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0YXJlYVJlc2l6ZSh0ZXh0UmVjdCwgdGV4dGFyZWEsIGUpO1xyXG4gICAgICAgIH0sIHRoaXMpKTtcclxuICAgICAgICAkKHRleHRhcmVhKS5vbihcImZvY3Vzb3V0XCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpc0Nvbm5lY3Rvci5zZXRTdHlsZSh7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dGFyZWEudmFsdWUgfHwgXCJcIlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB0ZXh0YXJlYS5yZW1vdmUoKTtcclxuICAgICAgICB9KVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOiKgueCueS4iuaWh+Wtl+e8lui+kVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLm5vZGVFZGl0ID0gZnVuY3Rpb24gKHRoaXNOb2RlKSB7XHJcbiAgICAgICAgdmFyIGlzTm90U2V0VGV4dCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciB0ZXh0YXJlYSA9IHRoaXMuY3JlYXRlVGV4dEFyZWEoKTtcclxuICAgICAgICB2YXIgbm9kZVRleHQgPSB6clV0aWwuY2xvbmUodGhpc05vZGUuc3R5bGUudGV4dCk7XHJcbiAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KG5vZGVUZXh0LCB0aGlzTm9kZS5zdHlsZS50ZXh0Rm9udCk7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSAyICogdGV4dFJlY3Qud2lkdGggKiB0aGlzLm5vd1pvb20gKyBcInB4XCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gKDIgKiB0ZXh0UmVjdC5oZWlnaHQgfHwgMTIpICogdGhpcy5ub3dab29tICsgXCJweFwiO1xyXG4gICAgICAgIHZhciBub2RlUmVjdCA9IHV0aWwuZ2V0UmVjdCh0aGlzTm9kZSk7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUubWF4V2lkdGggPSAxLjIgKiBub2RlUmVjdC53aWR0aCAqIHRoaXMubm93Wm9vbSArIFwicHhcIjtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5saW5lSGVpZ2h0ID0gKDEuMiAqIHRleHRSZWN0LmxpbmVIZWlnaHQgfHwgMTIpICsgXCJweFwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmJvcmRlciA9IFwiMXB4IHNvbGlkICMwMDAwMDBcIjtcclxuICAgICAgICB0ZXh0YXJlYS5pbm5lckhUTUwgPSB0aGlzTm9kZS5zdHlsZS50ZXh0O1xyXG4gICAgICAgIHRoaXMuc2V0U3R5bGUodGhpc05vZGUsIHt0ZXh0OiBcIlwifSk7ICAvL+WFiOaKiuiKgueCueaWh+acrOe7mea4heepuu+8jOWQpuWImeWIoOmZpOaWh+acrOahhuS4reaWh+Wtl+eahOaXtuWAme+8jOS8muaYvuekuuWHuuadpVxyXG4gICAgICAgIHRoaXMuX2RvbS5hcHBlbmRDaGlsZCh0ZXh0YXJlYSk7XHJcbiAgICAgICAgdGhpcy5fZG9tLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xyXG4gICAgICAgIHZhciBvZmZlc3RJID0gMTtcclxuICAgICAgICBpZiAodGhpc05vZGUuc3R5bGUudGV4dEFsaWduID09IFwibGVmdFwiKSB7XHJcbiAgICAgICAgICAgIG9mZmVzdEkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpc05vZGUuc3R5bGUudGV4dEFsaWduID09IFwicmlnaHRcIikge1xyXG4gICAgICAgICAgICBvZmZlc3RJID0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9mZmVzdFAgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzTm9kZS5zdHlsZS50ZXh0UG9zaXRpb24gJiYgdGhpc05vZGUuc3R5bGUudGV4dFBvc2l0aW9uID09IFwiYm90dG9tXCIpIHtcclxuICAgICAgICAgICAgb2ZmZXN0UCA9IDE7XHJcbiAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLm1heFdpZHRoID0gMyAqIDEuMSAqIG5vZGVSZWN0LndpZHRoICogdGhpcy5ub3dab29tICsgXCJweFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpc05vZGUuc3R5bGUudGV4dFBvc2l0aW9uICYmIHRoaXNOb2RlLnN0eWxlLnRleHRQb3NpdGlvbiA9PSBcInRvcFwiKSB7XHJcbiAgICAgICAgICAgIG9mZmVzdFAgPSAtMTtcclxuICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUubWF4V2lkdGggPSAzICogMS4xICogbm9kZVJlY3Qud2lkdGggKiB0aGlzLm5vd1pvb20gKyBcInB4XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLnRvcCA9IChub2RlUmVjdC55IC0gdGV4dFJlY3QuaGVpZ2h0IC8gMiArIG9mZmVzdFAgKiAobm9kZVJlY3QuaGVpZ2h0IC0gdGV4dFJlY3QuaGVpZ2h0IC9cclxuICAgICAgICAgICAgMikpICogdGhpcy5ub3dab29tICsgdGhpcy5ncm91cC5wb3NpdGlvblsxXSArIFwicHhcIjtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5sZWZ0ID0gKG5vZGVSZWN0LnggLSBvZmZlc3RJICogdGV4dFJlY3Qud2lkdGggLyAyIC0gMC4wNSAqIHRleHRSZWN0LndpZHRoKSAqIHRoaXMubm93Wm9vbSArXHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAucG9zaXRpb25bMF0gKyBcInB4XCI7XHJcbiAgICAgICAgdGV4dGFyZWEuZm9jdXMoKTtcclxuICAgICAgICB0ZXh0YXJlYS5zZWxlY3QoKTtcclxuICAgICAgICB0ZXh0YXJlYS5vbmtleXVwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IGtleUNvZGUuRVNDQVBFKSB7XHJcbiAgICAgICAgICAgICAgICBpc05vdFNldFRleHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGV4dGFyZWEuYmx1cigpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRleHRhcmVhLnZhbHVlLCB0aGlzTm9kZS5zdHlsZS50ZXh0Rm9udCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0YXJlYVJlc2l6ZSh0ZXh0UmVjdCwgdGV4dGFyZWEsIHRleHRhcmVhLnN0eWxlLm1heFdpZHRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICAgICAgdGV4dGFyZWEub25ibHVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNOb3RTZXRUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuaGFuZGxlV3JhcCh0ZXh0YXJlYS52YWx1ZSwgdGV4dGFyZWEuc3R5bGUubWF4V2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdHlsZSh0aGlzTm9kZSwge3RleHQ6IHRleHR9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3R5bGUodGhpc05vZGUsIHt0ZXh0OiBub2RlVGV4dH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRleHRhcmVhLnJlbW92ZSgpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5Yib5bu65paH5pys5Z+fXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY3JlYXRlVGV4dEFyZWEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLnBhZGRpbmcgPSBcIjZweFwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLnJlc2l6ZSA9IFwibm9uZVwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLndoaXRlU3BhY2UgPSBcInByZVwiO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmxpbmVIZWlnaHQgPSBcIjEyNSVcIjtcclxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuYm9yZGVyID0gXCIwXCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3BlbGxjaGVjayA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0ZXh0YXJlYTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICog5aSE55CGdGV4dGFyZWHoh6rliqjmjaLooYxcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5oYW5kbGVXcmFwID0gZnVuY3Rpb24gKHZhbHVlLCB3aWR0aCkge1xyXG4gICAgICAgIHZhciBzcGFuTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xyXG4gICAgICAgIHNwYW5Ob2RlLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgICAgIHNwYW5Ob2RlLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcclxuICAgICAgICBzcGFuTm9kZS5zdHlsZS5ib3JkZXIgPSBcIjBcIjtcclxuICAgICAgICBzcGFuTm9kZS5zdHlsZS5wYWRkaW5nID0gXCIwXCI7XHJcbiAgICAgICAgc3Bhbk5vZGUuc3R5bGUubGVmdCA9IFwiMFwiO1xyXG4gICAgICAgIHNwYW5Ob2RlLnN0eWxlLnRvcCA9IFwiMFwiO1xyXG4gICAgICAgIHRoaXMuX2RvbS5hcHBlbmRDaGlsZChzcGFuTm9kZSk7XHJcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB2YWx1ZS5zcGxpdChcIlxcblwiKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICAkLmVhY2goY29udGVudCwgZnVuY3Rpb24gKGksIHZhbCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHZhbExlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvL3Jlc3VsdCArPSBcIlxcblwiO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZSA9IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJWYWwsIHRlbXBXaWR0aCwgY29uV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbm5lckkgPSAwOyBpbm5lckkgPCB2YWxMZW5ndGg7IGlubmVySSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJWYWwgPSB2YWwuY2hhckF0KGlubmVySSk7XHJcbiAgICAgICAgICAgICAgICAgICAgJChzcGFuTm9kZSkudGV4dCgkKHNwYW5Ob2RlKS50ZXh0KCkgKyBpbm5lclZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFdpZHRoID0gJChzcGFuTm9kZSkud2lkdGgoKTsgLy/ojrflj5bmt7vliqDlrZfnrKblkI7pmpDol4/ln5/nmoTlrr3luqZcclxuICAgICAgICAgICAgICAgICAgICBjb25XaWR0aCA9IE51bWJlcih3aWR0aC5zdWJzdHJpbmcoMCwgd2lkdGgubGVuZ3RoIC0gMikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wV2lkdGggPiBjb25XaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcHJlOyAvL+WmguaenOi/veWKoOWtl+espuWQjumakOiXj+Wfn+WuveW6puWkp+S6jlRleHRBcmVh5a695bqm77yM5YiZ6KGo5piO6K+l5a2X56ym5Li65LiL5LiA6KGM5a2X56ym77yMXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKHNwYW5Ob2RlKS50ZXh0KGlubmVyVmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlID0gaW5uZXJWYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbm5lckkgPT0gdmFsTGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcHJlICsgaW5uZXJWYWw7IC8v5pyA5ZCO5LiA5Liq5a2X56ymXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpIDwgY29udGVudC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcXG5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKHNwYW5Ob2RlKS50ZXh0KFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmUgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZSArPSBpbm5lclZhbDsgLy/kvp3mrKHov73liqDliLBwcmXlj5jph4/kuK1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fZG9tLnJlbW92ZUNoaWxkKHNwYW5Ob2RlKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiDmlofmnKzln5/oh6rpgILlupTpq5jlrr1cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5fdGV4dGFyZWFSZXNpemUgPSBmdW5jdGlvbiAodGV4dFJlY3QsIHRleHRhcmVhLCB3aWR0aCkge1xyXG4gICAgICAgIHZhciBtaW5XaWR0aCA9IDA7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSAwO1xyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gKDEuMSAqIHRleHRSZWN0LndpZHRoKSAqIHRoaXMubm93Wm9vbSArIFwicHhcIjtcclxuICAgICAgICBpZiAod2lkdGggPCA2MCkge1xyXG4gICAgICAgICAgICBtaW5XaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1pbldpZHRoID0gNjBcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRleHRSZWN0LndpZHRoIDw9IG1pbldpZHRoKSB7XHJcbiAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gbWluV2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmhlaWdodCA9IFwiMHB4XCI7XHJcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gdGV4dGFyZWEuc2Nyb2xsSGVpZ2h0ICsgJ3B4JztcclxuICAgICAgICBpZiAodGV4dGFyZWEuc2Nyb2xsSGVpZ2h0IDw9IDApIHtcclxuICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gXCIxMnB4XCI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBzZXRTdHlsZVxyXG4gICAgICog6IqC54K55pu05pS5c3R5bGXph4znmoTlsZ7mgKdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIOiKgueCuXN0eWxl6YeM55qE5p+Q5Liq5bGe5oCn5ZCN56ewXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIOiKgueCuXN0eWxl6YeM55qE5p+Q5Liq5bGe5oCn5ZCN56ew5a+55bqU55qE5YC8XHJcbiAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICAgICAgLy/oioLngrnorr7nva7mloflrZdcclxuICAgICAqICAgICAgICAgZmlzaHRvcG8uc2V0U3R5bGUobm9kZSx7dGV4dDpcIuS+i+WtkFwifSk7XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uc2V0U3R5bGUgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xyXG4gICAgICAgIG5vZGUuc2V0U3R5bGUob3B0aW9ucyk7XHJcbiAgICAgICAgenJVdGlsLm1lcmdlKG5vZGUubW9kZWwuZ2V0KFwib3B0aW9ucy5zdHlsZVwiKSwgb3B0aW9ucywgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIHNldFNoYXBlXHJcbiAgICAgKiDoioLngrnmm7TmlLlzaGFwZemHjOeahOWxnuaAp1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUg6IqC54K5c2hhcGXph4znmoTmn5DkuKrlsZ7mgKflkI3np7BcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcg6IqC54K5c2hhcGXph4znmoTmn5DkuKrlsZ7mgKflkI3np7Dlr7nlupTnmoTlgLxcclxuICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgICAgICAvL+efqeW9ouiKgueCueiuvue9ruWuvVxyXG4gICAgICogICAgICAgICBmaXNodG9wby5zZXRTaGFwZShub2RlLHt3aWR0aDoxMDB9KTtcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5zZXRTaGFwZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgbm9kZS5zZXRTaGFwZShvcHRpb25zKTtcclxuICAgICAgICB6clV0aWwubWVyZ2Uobm9kZS5tb2RlbC5nZXQoXCJvcHRpb25zLnNoYXBlXCIpLCBvcHRpb25zLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uuiKgueCueS4iumdoueahOitpuWRilxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVBbGFybVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBub2RlIOiKgueCuVxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHQgIOmAiemhueWAvFxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0LnRleHRdIOitpuWRiueahOaWh+Wtl1xyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0LnRleHRGb250XSDorablkYrnmoTmloflrZfnmoTlrZfkvZNcclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdC50ZXh0RmlsbF0g6K2m5ZGK55qE5paH5a2X55qE6aKc6ImyXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHQudGV4dEJhY2tncm91bmRdIOitpuWRiueahOiDjOaZr+eahOminOiJslxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSDov5Tlm57oioLngrnkuIrnmoTorablkYpcclxuICAgICAqXHJcbiAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgKlxyXG4gICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICogICAgICAgICAgdGhpcy5maXNoVG9wby5jcmVhdGVBbGFybShzMSx7XHJcbiAgICAgKiAgICAgICAgICB0ZXh0OlwiMiBXXCIsXHJcbiAgICAgKiAgICAgICAgICB0ZXh0Rm9udDpcIjRweCBNaWNyb3NvZnQgWWFIZWlcIixcclxuICAgICAqICAgICAgICAgIHRleHRGaWxsOlwiI0ZGRkZGRlwiLFxyXG4gICAgICogICAgICAgICAgdGV4dEJhY2tncm91bmQ6XCJyZ2JhKDI1NSwwLDAsMC42KVwiXHJcbiAgICAgKiAgICAgIH0pOy8v5Yib5bu65bCP5Zu+54mH5ZKM6IqC54K557uR5a6aXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uY3JlYXRlQWxhcm0gPSBmaXNoVG9wb1Byb3RvLmNyZWF0QWxhcm0gPSBmdW5jdGlvbiAobm9kZSwgb3B0KSB7XHJcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5jcmVhdGVOb2RlKFwiR3JvdXBcIiwge1xyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJ3JnYmEoMCwwLDAsMCknLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAncmdiYSgwLDAsMCwwKSdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGdyb3VwLmlzZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmNyZWF0ZU5vZGUoXCJUZXh0XCIsIHsgLy/mloflrZdcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IG9wdC50ZXh0LFxyXG4gICAgICAgICAgICAgICAgdGV4dEZvbnQ6IG9wdC50ZXh0Rm9udCxcclxuICAgICAgICAgICAgICAgIGZpbGw6IG9wdC50ZXh0RmlsbCxcclxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogXCJ0b3BcIiAvL+WeguebtOWvuem9kCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBbMiwgMF0sXHJcbiAgICAgICAgICAgIHo6IDJcclxuICAgICAgICB9KTtcclxuICAgICAgICB0ZXh0LmlzZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgZ3JvdXAuYWRkKHRleHQpO1xyXG4gICAgICAgIGlmIChGbG93LmlzSW5Hcm91cChub2RlKSkge1xyXG4gICAgICAgICAgICBub2RlLnBhcmVudC5hZGQoZ3JvdXApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKGdyb3VwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGdyb3VwV2lkdGggPSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCArIDI7XHJcbiAgICAgICAgdmFyIGdyb3VwSGVpZ2h0ID0gZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0ICsgNjtcclxuICAgICAgICB2YXIgcG9pbnRzID0gW1xyXG4gICAgICAgICAgICBbMCwgMF0sXHJcbiAgICAgICAgICAgIFtncm91cFdpZHRoLCAwXSxcclxuICAgICAgICAgICAgW2dyb3VwV2lkdGgsIGdyb3VwSGVpZ2h0XSxcclxuICAgICAgICAgICAgW2dyb3VwV2lkdGggLSAzLCBncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgIFtncm91cFdpZHRoIC0gNiwgZ3JvdXBIZWlnaHQgKyAzXSxcclxuICAgICAgICAgICAgW2dyb3VwV2lkdGggLSA5LCBncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgIFswLCBncm91cEhlaWdodF0sXHJcbiAgICAgICAgICAgIFswLCAwXVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdmFyIFBvbHlsaW5lID0gdGhpcy5jcmVhdGVOb2RlKFwiUG9seWxpbmVcIiwge1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IG9wdC50ZXh0QmFja2dyb3VuZCxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogb3B0LnRleHRCYWNrZ3JvdW5kXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB6OiAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgUG9seWxpbmUuaXNkcmFnZ2FibGUgPSBmYWxzZTtcclxuICAgICAgICBncm91cC5hZGQoUG9seWxpbmUpO1xyXG4gICAgICAgIHZhciBncm91cFBvc2l0aW9uID0gW25vZGUucG9zaXRpb25bMF0gKyBub2RlLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC0gKGdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC1cclxuICAgICAgICAgICAgNiksIG5vZGUucG9zaXRpb25bMV0gLSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLSAzXTtcclxuICAgICAgICBncm91cC5hdHRyKFwicG9zaXRpb25cIiwgZ3JvdXBQb3NpdGlvbik7XHJcbiAgICAgICAgbm9kZS5hbGFybSA9IGdyb3VwO1xyXG4gICAgICAgIC8v6K6+572u5qih5Z6LIOe7mWpzb27luo/liJfljJbnlKhcclxuICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoe30pO1xyXG4gICAgICAgIG1vZGVsLnNldChDb25zdGFudHMuRUxFTUVOVF9UWVBFLCBDb25zdGFudHMuQUxBUk0pO1xyXG4gICAgICAgIG1vZGVsLnNldChDb25zdGFudHMuT1BUSU9OUywgenJVdGlsLmNsb25lKG9wdCkpO1xyXG4gICAgICAgIG1vZGVsLnNldChDb25zdGFudHMuUkVMQVRJT05JRCwgbm9kZS5tb2RlbC5nZXQoQ29uc3RhbnRzLklEKSk7XHJcbiAgICAgICAgZ3JvdXAubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICByZXR1cm4gZ3JvdXA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIOi/lOWbnuW9k+WJjeeUu+W4g+eahOaVsOaNrlxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLnRvRGF0YVVSTCA9IGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIEZsb3dVdGlsLnRvRGF0YVVSTCh0aGlzLl96ciwgb3B0cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZpc2hUb3BvUHJvdG8uenJNb3ZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3pyLm9uKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChlKSB7IC8v54K55Ye75Zyo6IqC54K55LiK5oiW6ICF57q/5LiK5LiN6L+b6KGM5bmz56e75pON5L2cXHJcbiAgICAgICAgICAgIGlmICgoZS50YXJnZXQgJiYgZS50YXJnZXQubW9kZWwpIHx8IChlLnRhcmdldCAmJiBlLnRhcmdldC5saW5lVHlwZSAmJiBlLnRhcmdldC5wYXJlbnQpIHx8XHJcbiAgICAgICAgICAgICAgICAoZS50YXJnZXQgJiYgZS50YXJnZXQuY29ubmVjdG9yIGluc3RhbmNlb2YgQ29ubmVjdG9yKSB8fCAoZS50YXJnZXQgJiYgZS50YXJnZXQgaW5zdGFuY2VvZiBncmFwaGljXHJcbiAgICAgICAgICAgICAgICAgICAgLkNpcmNsZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dyb3VwRHJhZ0hhbmRsZXIoZS5vZmZzZXRYLCBlLm9mZnNldFkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuXHJcbiAgICBmaXNoVG9wb1Byb3RvLmluaXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZ3JvdXBNYXhXaWR0aCA9IHRoaXMuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGg7XHJcbiAgICAgICAgdmFyIGdyb3VwTWF4SGVpZ2h0ID0gdGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHJhbmdlV2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XHJcbiAgICAgICAgdmFyIHJhbmdlSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcclxuICAgICAgICB2YXIgaW5pdFJhdGlvID0gMSxcclxuICAgICAgICAgICAgcG9zID0gW107XHJcbiAgICAgICAgaWYgKGdyb3VwTWF4V2lkdGggLyBncm91cE1heEhlaWdodCA+IHJhbmdlV2lkdGggLyByYW5nZUhlaWdodCkge1xyXG4gICAgICAgICAgICBpZiAoZ3JvdXBNYXhXaWR0aCA+IHJhbmdlV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGluaXRSYXRpbyA9IHJhbmdlV2lkdGggLyBncm91cE1heFdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGdyb3VwTWF4SGVpZ2h0ID4gcmFuZ2VIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGluaXRSYXRpbyA9IHJhbmdlSGVpZ2h0IC8gZ3JvdXBNYXhIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcG9zWzBdID0gTWF0aC5hYnModGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKS54KSAqIGluaXRSYXRpbztcclxuICAgICAgICBwb3NbMV0gPSBNYXRoLmFicyh0aGlzLmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLnkpICogaW5pdFJhdGlvO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAuYXR0cihcInBvc2l0aW9uXCIsIFtwb3NbMF0sIHBvc1sxXV0pO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAuYXR0cihcInNjYWxlXCIsIFtpbml0UmF0aW8sIGluaXRSYXRpb10pO1xyXG4gICAgICAgIHRoaXMuaW5pdFNjYWxlUmF0aW8gPSBpbml0UmF0aW87XHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gW3Bvc1swXSwgcG9zWzFdLCB0aGlzLmluaXRTY2FsZVJhdGlvLCBncm91cE1heFdpZHRoLCBncm91cE1heEhlaWdodF07XHJcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOaUvuWkp+aIluiAhee8qeWwj1xyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gdHlwZSDlvZPkuLrlrZfnrKbkuLLml7YgXCJlbmxhcmdlXCLmlL7lpKcgIFwibmFycm93aW5nXCLnvKnlsI8gIOW9k+S4uuaVsOWAvOaXtiDnvKnmlL7nmoTmr5TkvosgIOW7uuiurjAuMy0xLjdcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by56clNjYWxlID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PSBcIm5hcnJvd2luZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgem9vbURlbHRhMSA9IC0wLjA3O1xyXG4gICAgICAgICAgICAgICAgdGhpcy56b29tKHpvb21EZWx0YTEsIHRoaXMuX3pyLmdldFdpZHRoKCkgLyAyLCB0aGlzLl96ci5nZXRIZWlnaHQoKSAvIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09IFwiZW5sYXJnZVwiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgem9vbURlbHRhID0gMC4wNztcclxuICAgICAgICAgICAgICAgIHRoaXMuem9vbSh6b29tRGVsdGEsIHRoaXMuX3pyLmdldFdpZHRoKCkgLyAyLCB0aGlzLl96ci5nZXRIZWlnaHQoKSAvIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOYU4odHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmdyb3VwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB6b29tU2NhbGUgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3pvb20gPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm93Wm9vbSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTY2FsZSh0aGlzLl96ci5nZXRXaWR0aCgpIC8gMiwgdGhpcy5fenIuZ2V0SGVpZ2h0KCkgLyAyLCB6b29tU2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fenIub24oJ21vdXNld2hlZWwnLCB6clV0aWwuYmluZChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRUb29sLnN0b3AoZS5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgem9vbURlbHRhID0gZS53aGVlbERlbHRhID4gMCA/IDAuMDcgOiAtMC4wNztcclxuICAgICAgICAgICAgICAgIHRoaXMuem9vbSh6b29tRGVsdGEsIHRoaXMuX3pyLmdldFdpZHRoKCkgLyAyLCB0aGlzLl96ci5nZXRIZWlnaHQoKSAvIDIpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uem9vbSA9IGZ1bmN0aW9uICh6b29tRGVsdGEsIHpvb21YLCB6b29tWSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhblNjYWxlID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgaWYgKHRhcmdldCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG5ld1pvb20gPSB0aGlzLl96b29tID0gdGhpcy5fem9vbSB8fCAxO1xyXG4gICAgICAgICAgICBuZXdab29tICs9IHpvb21EZWx0YTtcclxuXHJcbiAgICAgICAgICAgIG5ld1pvb20gPSBOdW1iZXIobmV3Wm9vbS50b0ZpeGVkKDIpKTtcclxuICAgICAgICAgICAgdmFyIHpvb21TY2FsZSA9IG5ld1pvb20gLyB0aGlzLl96b29tO1xyXG4gICAgICAgICAgICBpZiAobmV3Wm9vbSA+IDEuNyB8fCBuZXdab29tIDwgMC4zKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fem9vbSA9IG5ld1pvb207XHJcblxyXG4gICAgICAgICAgICB0aGlzLm5vd1pvb20gPSBuZXdab29tO1xyXG4gICAgICAgICAgICB0aGlzLnNldFNjYWxlKHpvb21YLCB6b29tWSwgem9vbVNjYWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5zZXRTY2FsZSA9IGZ1bmN0aW9uICh6b29tWCwgem9vbVksIHpvb21TY2FsZSkge1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmdyb3VwO1xyXG4gICAgICAgIHZhciBwb3MgPSB0YXJnZXQucG9zaXRpb247XHJcbiAgICAgICAgdmFyIHNjYWxlID0gdGFyZ2V0LnNjYWxlO1xyXG4gICAgICAgIC8vIEtlZXAgdGhlIG1vdXNlIGNlbnRlciB3aGVuIHNjYWxpbmdcclxuICAgICAgICBwb3NbMF0gLT0gKHpvb21YIC0gcG9zWzBdKSAqICh6b29tU2NhbGUgLSAxKTtcclxuICAgICAgICBwb3NbMV0gLT0gKHpvb21ZIC0gcG9zWzFdKSAqICh6b29tU2NhbGUgLSAxKTtcclxuICAgICAgICBzY2FsZVswXSAqPSB6b29tU2NhbGU7XHJcbiAgICAgICAgc2NhbGVbMV0gKj0gem9vbVNjYWxlO1xyXG4gICAgICAgIHRhcmdldC5hdHRyKFwicG9zaXRpb25cIiwgW3Bvc1swXSwgcG9zWzFdXSk7XHJcbiAgICAgICAgdGFyZ2V0LmF0dHIoXCJzY2FsZVwiLCBbc2NhbGVbMF0sIHNjYWxlWzFdXSk7XHJcbiAgICAgICAgaWYgKHRoaXMuZWFnbGVFeWUgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1pbmltYXAudXBkYXRhU2VsZWN0aW9uKHBvc1swXSwgcG9zWzFdLCB6b29tU2NhbGUsIHRoaXMubm93Wm9vbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOm5sOecvOWbvlxyXG4gICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVhZ2xlRXllTm9kZSDmmL7npLrpubDnnLzlm77nmoRkaXblhYPntKBcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5vcGVuRWFnbGVFeWUgPSBmdW5jdGlvbiAoZWFnbGVFeWVOb2RlKSB7XHJcbiAgICAgICAgdGhpcy5lYWdsZUV5ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5lYWdsZUV5ZU5vZGUgPSBlYWdsZUV5ZU5vZGU7XHJcbiAgICAgICAgdmFyIGdyb3VwUG9zaXRpb24gPSB6clV0aWwuY2xvbmUodGhpcy5ncm91cC5wb3NpdGlvbik7XHJcbiAgICAgICAgdmFyIGdyb3VwU2NhbGUgPSB6clV0aWwuY2xvbmUodGhpcy5ncm91cC5zY2FsZSk7XHJcbiAgICAgICAgdGhpcy5ncm91cC5hdHRyKFwicG9zaXRpb25cIiwgWzAsIDBdKTtcclxuICAgICAgICB0aGlzLmdyb3VwLmF0dHIoXCJzY2FsZVwiLCBbMSwgMV0pO1xyXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHRoaXMuaW5pdFNjYWxlKCk7XHJcbiAgICAgICAgdmFyIGltZ1NyYyA9IHRoaXMudG9EYXRhVVJMKCk7XHJcbiAgICAgICAgdGhpcy5ncm91cC5hdHRyKFwicG9zaXRpb25cIiwgZ3JvdXBQb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5ncm91cC5hdHRyKFwic2NhbGVcIiwgZ3JvdXBTY2FsZSk7XHJcbiAgICAgICAgaWYgKHRoaXMubWluaW1hcCkge1xyXG4gICAgICAgICAgICB0aGlzLm1pbmltYXAudXBkYXRhTWFwKGltZ1NyYywgdGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5taW5pbWFwID0gbmV3IE1pbmltYXAodGhpcywgdGhpcy5ncm91cC5wb3NpdGlvbiwgdGhpcy5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKSxcclxuICAgICAgICAgICAgICAgIGVhZ2xlRXllTm9kZSwgZGlzdGFuY2UsIGltZ1NyYyk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoenJVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuRWFnbGVFeWUodGhpcy5lYWdsZUV5ZU5vZGUpXHJcbiAgICAgICAgICAgIH0sIHRoaXMpLCAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWluaW1hcC5zZWxlY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRYID0gZS5jbGllbnRYO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gZS5jbGllbnRZO1xyXG4gICAgICAgICAgICB2YXIgbWluaW1hcExlZnQgPSBOdW1iZXIodGhpcy5taW5pbWFwLnNlbGVjdGlvbi5zdHlsZS5sZWZ0LnN1YnN0cmluZygwLCB0aGlzLm1pbmltYXAuc2VsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUubGVmdC5sZW5ndGggLSAyKSk7XHJcbiAgICAgICAgICAgIHZhciBtaW5pbWFwVG9wID0gTnVtYmVyKHRoaXMubWluaW1hcC5zZWxlY3Rpb24uc3R5bGUudG9wLnN1YnN0cmluZygwLCB0aGlzLm1pbmltYXAuc2VsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUudG9wLmxlbmd0aCAtIDIpKTtcclxuICAgICAgICAgICAgdmFyIGVhZ2xlRXllTW92ZSA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IGUuY2xpZW50WCAtIHN0YXJ0WDtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRZID0gZS5jbGllbnRZIC0gc3RhcnRZO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taW5pbWFwLnNlbGVjdGlvbi5zdHlsZS5sZWZ0ID0gbWluaW1hcExlZnQgKyBvZmZzZXRYICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taW5pbWFwLnNlbGVjdGlvbi5zdHlsZS50b3AgPSBtaW5pbWFwVG9wICsgb2Zmc2V0WSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIHRoaXMubWluaW1hcC51cGRhdGFHcm91cFBvc2l0aW9uKHRoaXMuZ3JvdXAsIHRoaXMubm93Wm9vbSk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubWluaW1hcC5zZWxlY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBlYWdsZUV5ZU1vdmUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGVhZ2xlRXllVXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pbmltYXAuc2VsZWN0aW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgZWFnbGVFeWVNb3ZlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWluaW1hcC5zZWxlY3Rpb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgZWFnbGVFeWVVcCk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5taW5pbWFwLnNlbGVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBlYWdsZUV5ZVVwKTtcclxuICAgICAgICB9LmJpbmQodGhpcykpXHJcbiAgICB9O1xyXG5cclxuXHJcblxyXG4gICAgenJVdGlsLm1peGluKEZpc2hUb3BvRmxvdywgRXZlbnRmdWwpO1xyXG5cclxuICAgIC8vIC0tLS0tLS0tLeWvueWkluaatOmcsmZpc2hUb3BvRmxvdy0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgdmFyIGlkQmFzZSA9IG5ldyBEYXRlKCkgLSAwO1xyXG4gICAgdmFyIGluc3RhbmNlcyA9IHt9O1xyXG4gICAgdmFyIERPTV9BVFRSSUJVVEVfS0VZID0gJ19maXNoVG9wb0Zsb3dfaW5zdGFuY2VfJztcclxuXHJcbiAgICAvKipcclxuICAgICAqIGZpc2hUb3BvRmxvd+WFqOWxgOWvueixoe+8jOWmguaenOaYr2FtZOaWueW8j+WKoOi9ve+8jOWImeebtOaOpei/lOWbnlxyXG4gICAgICogQGNsYXNzIGZpc2hUb3BvRmxvd1xyXG4gICAgICogQHNpbmdsZXRvblxyXG4gICAgICpcclxuICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAqXHJcbiAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgKiAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICAgICAqL1xyXG4gICAgdmFyIGZpc2hUb3BvRmxvdyA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDniYjmnKzlj7dcclxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZlcnNpb246ICcyLjIuMScsXHJcbiAgICAgICAgZGVwZW5kZW5jaWVzOiB7XHJcbiAgICAgICAgICAgIHpyZW5kZXI6ICczLjYuMydcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yid5aeL5YyWZG9t5YWD57Sg5Li6IGZsb3flr7nosaFcclxuICAgICAqIEBtZW1iZXIgZmlzaFRvcG9GbG93XHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb20gIOS4gOS4qmRpduWFg+e0oFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgIOS8oOmAkueahOmAiemhueWPguaVsFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnJlbmRlcmVyPSdjYW52YXMnXSAnY2FudmFzJyBvciAnc3ZnJyBvciAndm1sJ1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW89MV0gcmV0aW5hIOWxj+W5leS8mOWMllxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5saW5rTW9kaWZ5PWZhbHNlXSDmmK/lkKblhYHorrjosIPmlbTnur/mrrVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMudGV4dEVkaXRhYmxlPWZhbHNlXSDmmK/lkKblhYHorrjlj4zlh7voioLngrnnvJbovpHmloflrZdcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMucm9hbT10cnVlXSDmmK/lkKblvIDlkK/pvKDmoIfnvKnmlL7lkozlubPnp7vmvKvmuLjjgILpu5jorqTlvIDlkK/jgILlpoLmnpzlj6rmg7PopoHlvIDlkK/nvKnmlL7miJbogIXlubPnp7vvvIzlj6/ku6Xorr7nva7miJAgJ3NjYWxlJyDmiJbogIUgJ21vdmUn44CC6K6+572u5oiQIHRydWUg5Li66YO95byA5ZCvXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHMudG9vbHRpcF0gdG9vbHRpcOmFjee9rumhuVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy50b29sdGlwLnNob3ddIHRvb2x0aXDphY3nva7pobk65o6n5Yi2dG9vbHRpcOaYr+WQpuaYvuekulxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pc0FuaW1hdGlvbkVuYWJsZWQ9dHJ1ZV0g5piv5ZCm5byA5ZCv5Yqo55S7LOm7mOiupOS4unRydWVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmJlZm9yZURlbGV0ZV0g5Yig6Zmk6IqC54K55oiW6L6557q/IOS5i+WJjeeahOWbnuiwg++8jOWmguaenOi/lOWbnmZhbHNl5YiZ5LiN6L+b6KGM5ZCO57ut55qE5Yig6Zmk5pON5L2cXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHMuYmVmb3JlQ3JlYXRlXSDliJvlu7roioLngrnmiJbovrnnur8g5LmL5YmN55qE5Zue6LCD77yM5aaC5p6c6L+U5ZueZmFsc2XliJnkuI3ov5vooYzlkI7nu63nmoTliKDpmaTmk43kvZxcclxuICAgICAqIEByZXR1cm4ge2Zpc2gudG9wby5GaXNoVG9wb0Zsb3d9XHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvRmxvdy5pbml0ID0gZnVuY3Rpb24gKGRvbSwgb3B0cykge1xyXG4gICAgICAgIGlmICghZG9tKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5pdGlhbGl6ZSBmYWlsZWQ6IGludmFsaWQgZG9tLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XHJcbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgIHpyVXRpbC5kZWZhdWx0cyhvcHRzLCB7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiZmxvd1wiLFxyXG4gICAgICAgICAgICBkZXZpY2VQaXhlbFJhdGlvOiAxLFxyXG4gICAgICAgICAgICBsaW5rTW9kaWZ5OiBmYWxzZSxcclxuICAgICAgICAgICAgdGV4dEVkaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgcm9hbTogdHJ1ZSxcclxuICAgICAgICAgICAgdG9vbHRpcDoge1xyXG4gICAgICAgICAgICAgICAgc2hvdzp0cnVlXHJcbiAgICAgICAgICAgIH0sICAvL+imhueblnRvb2x0aXBNb2RlbFxyXG4gICAgICAgICAgICBpc0FuaW1hdGlvbkVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIGJlZm9yZURlbGV0ZTogbnVsbCwgIC8vIOWIoOmZpOS5i+WJjeeahOS6i+S7tlxyXG4gICAgICAgICAgICBiZWZvcmVDcmVhdGU6bnVsbCAgIC8v5Yib5bu66IqC54K55oiW6L+e57q/5LmL5YmN55qE5LqL5Lu2XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciBmaXNoVG9wb0Zsb3cgPSBuZXcgRmlzaFRvcG9GbG93KGRvbSwgb3B0cyk7XHJcbiAgICAgICAgZmlzaFRvcG9GbG93LmluaXQoKTtcclxuICAgICAgICBmaXNoVG9wb0Zsb3cuRmxvdyA9IEZsb3c7XHJcbiAgICAgICAgZmlzaFRvcG9GbG93LmlkID0gJ2Z0XycgKyBpZEJhc2UrKztcclxuICAgICAgICBpbnN0YW5jZXNbZmlzaFRvcG9GbG93LmlkXSA9IGZpc2hUb3BvRmxvdztcclxuXHJcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZSAmJiBkb20uc2V0QXR0cmlidXRlKERPTV9BVFRSSUJVVEVfS0VZLCBmaXNoVG9wb0Zsb3cuaWQpO1xyXG5cclxuICAgICAgICByZXR1cm4gZmlzaFRvcG9GbG93O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5YgZG9tIOWuueWZqOS4iueahOWunuS+i+OAglxyXG4gICAgICogQG1lbWJlciBmaXNoVG9wb0Zsb3dcclxuICAgICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBkb20g5LiA5LiqZGl25YWD57SgXHJcbiAgICAgKiBAcmV0dXJuIHtmaXNoLnRvcG8uRmlzaFRvcG9GbG93fVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb0Zsb3cuZ2V0SW5zdGFuY2VCeURvbSA9IGZ1bmN0aW9uIChkb20pIHtcclxuICAgICAgICB2YXIga2V5ID0gZG9tLmdldEF0dHJpYnV0ZShET01fQVRUUklCVVRFX0tFWSk7XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlc1trZXldO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOmUgOavgeWunuS+i++8jOWunuS+i+mUgOavgeWQjuaXoOazleWGjeiiq+S9v+eUqOOAglxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIgZmlzaFRvcG9GbG93XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R8c3RyaW5nfSBjaGFydCBmaXNoVG9wb0JwbW7lrp7kvosg5oiWIGZpc2hUb3BvQnBtbueahGlkXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvRmxvdy5kaXNwb3NlID0gZnVuY3Rpb24gKGNoYXJ0KSB7XHJcbiAgICAgICAgdmFyIHRvcG87XHJcbiAgICAgICAgaWYgKHpyVXRpbC5pc0RvbShjaGFydCkpIHtcclxuICAgICAgICAgICAgdG9wbyA9IGZpc2hUb3BvRmxvdy5nZXRJbnN0YW5jZUJ5RG9tKGNoYXJ0KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjaGFydCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdG9wbyA9IGluc3RhbmNlc1tjaGFydF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgodG9wbyBpbnN0YW5jZW9mIGZpc2hUb3BvRmxvdykgJiYgIXRvcG8uaXNEaXNwb3NlZCgpKSB7XHJcbiAgICAgICAgICAgIHRvcG8uZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy/mmrTpnLLlh7rljrvnmoTnsbtcclxuICAgIGZpc2hUb3BvRmxvdy5ncmFwaGljID0gZ3JhcGhpYztcclxuICAgIGZpc2hUb3BvRmxvdy5ub2RlID0gRmxvd1V0aWwucmVnaXN0ZXJGbG93Tm9kZShmbG93Tm9kZSk7XHJcbiAgICBmaXNoVG9wb0Zsb3cubGluayA9IGZsb3dMaW5rO1xyXG5cclxuICAgIGZpc2hUb3BvRmxvdy5sYXlvdXQgPSBsYXlvdXQ7XHJcbiAgICBmaXNoVG9wb0Zsb3cuRmxvdyA9IEZsb3c7XHJcbiAgICBmaXNoVG9wb0Zsb3cuY29uc3RhbnRzID0gQ29uc3RhbnRzO1xyXG4gICAgZmlzaFRvcG9GbG93LnV0aWwgPSB1dGlsO1xyXG4gICAgZmlzaFRvcG9GbG93LnV0aWxbJ2luaXRJbWFnZVBvb2wnXSA9IEltYWdlUG9vbC5pbml0SW1hZ2VQb29sO1xyXG4gICAgenJVdGlsLmVhY2goW1xyXG4gICAgICAgICAgICAnbWFwJywgJ2VhY2gnLCAnZmlsdGVyJywgJ2luZGV4T2YnLCAnaW5oZXJpdHMnLFxyXG4gICAgICAgICAgICAncmVkdWNlJywgJ2ZpbHRlcicsICdiaW5kJywgJ2N1cnJ5JywgJ2lzQXJyYXknLFxyXG4gICAgICAgICAgICAnaXNTdHJpbmcnLCAnaXNPYmplY3QnLCAnaXNGdW5jdGlvbicsICdleHRlbmQnLFxyXG4gICAgICAgICAgICAnbWVyZ2UnLCBcIm1lcmdlQWxsXCJcclxuICAgICAgICBdLFxyXG4gICAgICAgIGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIGZpc2hUb3BvRmxvdy51dGlsW25hbWVdID0genJVdGlsW25hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaXNoVG9wb0Zsb3c7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9GaXNoVG9wb0Zsb3cuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbiAgICAvL3BvbHlmaWxsIGJpbmRcclxuICAgIGlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcclxuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKG9UaGlzKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDUgaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG4gICAgICAgICAgICAgICAgZlRvQmluZCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBmTk9QID0gZnVuY3Rpb24oKSB7fSxcclxuICAgICAgICAgICAgICAgIGZCb3VuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBmTk9QICYmIG9UaGlzID8gdGhpcyA6IG9UaGlzIHx8IHdpbmRvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xyXG4gICAgICAgICAgICBmQm91bmQucHJvdG90eXBlID0gbmV3IGZOT1AoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmQm91bmQ7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvL3BvbHlmaWxsIHJlbW92ZVxyXG4gICAgaWYgKCEoJ3JlbW92ZScgaW4gRWxlbWVudC5wcm90b3R5cGUpKSB7XHJcbiAgICAgICAgRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKSB7XHJcbiAgICBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoID0gZnVuY3Rpb24oc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciBzdWJqZWN0U3RyaW5nID0gdGhpcy50b1N0cmluZygpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gIT09ICdudW1iZXInIHx8ICFpc0Zpbml0ZShwb3NpdGlvbikgfHwgTWF0aC5mbG9vcihwb3NpdGlvbikgIT09IHBvc2l0aW9uIHx8IHBvc2l0aW9uID4gc3ViamVjdFN0cmluZy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcG9zaXRpb24gPSBzdWJqZWN0U3RyaW5nLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcG9zaXRpb24gLT0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcclxuICAgICAgICB2YXIgbGFzdEluZGV4ID0gc3ViamVjdFN0cmluZy5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xyXG4gICAgICAgIHJldHVybiBsYXN0SW5kZXggIT09IC0xICYmIGxhc3RJbmRleCA9PT0gcG9zaXRpb247XHJcbiAgICB9O1xyXG4gICAgfVxyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL3BvbHlmaWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuXHJcbiAgICB2YXIgcGF0aFRvb2wgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi90b29sL3BhdGgnKTtcclxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XHJcbiAgICB2YXIgUGF0aCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aCcpO1xyXG4gICAgdmFyIGNvbG9yVG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvY29sb3InKTtcclxuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL21hdHJpeCcpO1xyXG4gICAgdmFyIHZlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XHJcbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0dyYWRpZW50Jyk7XHJcbiAgICB2YXIgRHJhZ2dhYmxlID0gcmVxdWlyZSgnenJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlJyk7XHJcblxyXG4gICAgdmFyIGdyYXBoaWMgPSB7fTtcclxuICAgIGdyYXBoaWMuVXRpbCA9IHpyVXRpbDtcclxuICAgIGdyYXBoaWMuR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAnKTtcclxuXHJcbiAgICBncmFwaGljLkltYWdlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZScpO1xyXG5cclxuICAgIGdyYXBoaWMuVGV4dCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dCcpO1xyXG5cclxuICAgIGdyYXBoaWMudGV4dENvbnRhaW4gPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluL3RleHQnKTtcclxuXHJcbiAgICBncmFwaGljLkNpcmNsZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQ2lyY2xlJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5TZWN0b3IgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3RvcicpO1xyXG5cclxuICAgIGdyYXBoaWMuUmluZyA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZycpO1xyXG5cclxuICAgIGdyYXBoaWMuUG9seWdvbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbicpO1xyXG5cclxuICAgIGdyYXBoaWMuUG9seWxpbmUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5SZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy5MaW5lID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5CZXppZXJDdXJ2ZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUnKTtcclxuXHJcbiAgICBncmFwaGljLkFyYyA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5MaW5lYXJHcmFkaWVudCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQnKTtcclxuXHJcbiAgICBncmFwaGljLlJhZGlhbEdyYWRpZW50ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudCcpO1xyXG5cclxuICAgIGdyYXBoaWMuQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcclxuICAgIGdyYXBoaWMuU3RhdGVzID0gcmVxdWlyZShcInpyZW5kZXIvbGliL2dyYXBoaWMvU3RhdGVzLmpzXCIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlbmQgc2hhcGUgd2l0aCBwYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuZXh0ZW5kU2hhcGUgPSBmdW5jdGlvbiAob3B0cykge1xyXG4gICAgICAgIHJldHVybiBQYXRoLmV4dGVuZChvcHRzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlbmQgcGF0aFxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmV4dGVuZFBhdGggPSBmdW5jdGlvbiAocGF0aERhdGEsIG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gcGF0aFRvb2wuZXh0ZW5kRnJvbVN0cmluZyhwYXRoRGF0YSwgb3B0cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgcGF0aCBlbGVtZW50IGZyb20gcGF0aCBkYXRhIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhEYXRhXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gcmVjdFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYXlvdXQ9Y292ZXJdICdjZW50ZXInIG9yICdjb3ZlcidcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5tYWtlUGF0aCA9IGZ1bmN0aW9uIChwYXRoRGF0YSwgb3B0cywgcmVjdCwgbGF5b3V0KSB7XHJcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoVG9vbC5jcmVhdGVGcm9tU3RyaW5nKHBhdGhEYXRhLCBvcHRzKTtcclxuICAgICAgICBEcmFnZ2FibGUuY2FsbChwYXRoKTtcclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICBpZiAocmVjdCkge1xyXG4gICAgICAgICAgICB2YXIgYXNwZWN0ID0gYm91bmRpbmdSZWN0LndpZHRoIC8gYm91bmRpbmdSZWN0LmhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIGlmIChsYXlvdXQgPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgcmVjdCB0byBjZW50ZXIsIGtlZXAgd2lkdGggLyBoZWlnaHQgcmF0aW8uXHJcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSByZWN0LmhlaWdodCAqIGFzcGVjdDtcclxuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggPD0gcmVjdC53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gcmVjdC54ICsgcmVjdC53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3kgPSByZWN0LnkgKyByZWN0LmhlaWdodCAvIDI7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVjdC54ID0gY3ggLSB3aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICByZWN0LnkgPSBjeSAtIGhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICByZWN0LndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICByZWN0LmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5yZXNpemVQYXRoKHBhdGgsIHJlY3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgenJVdGlsLmluaGVyaXRzKHBhdGgsIERyYWdnYWJsZSk7XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9O1xyXG5cclxuICAgIGdyYXBoaWMubWVyZ2VQYXRoID0gcGF0aFRvb2wubWVyZ2VQYXRoO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplIGEgcGF0aCB0byBmaXQgdGhlIHJlY3RcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBwYXRoXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdFxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnJlc2l6ZVBhdGggPSBmdW5jdGlvbiAocGF0aCwgcmVjdCkge1xyXG4gICAgICAgIGlmICghcGF0aC5hcHBseVRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcGF0aFJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xyXG5cclxuICAgICAgICB2YXIgbSA9IHBhdGhSZWN0LmNhbGN1bGF0ZVRyYW5zZm9ybShyZWN0KTtcclxuXHJcbiAgICAgICAgcGF0aC5hcHBseVRyYW5zZm9ybShtKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWIgcGl4ZWwgb3B0aW1pemUgbGluZSBmb3IgY2FudmFzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnNoYXBlXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54MV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueTFdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLngyXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55Ml1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc3R5bGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnN0eWxlLmxpbmVXaWR0aF1cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gTW9kaWZpZWQgcGFyYW1cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSA9IGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAgIHZhciBzdWJQaXhlbE9wdGltaXplID0gZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplO1xyXG4gICAgICAgIHZhciBzaGFwZSA9IHBhcmFtLnNoYXBlO1xyXG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBwYXJhbS5zdHlsZS5saW5lV2lkdGg7XHJcblxyXG4gICAgICAgIGlmIChyb3VuZChzaGFwZS54MSAqIDIpID09PSByb3VuZChzaGFwZS54MiAqIDIpKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLngxID0gc2hhcGUueDIgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLngxLCBsaW5lV2lkdGgsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm91bmQoc2hhcGUueTEgKiAyKSA9PT0gcm91bmQoc2hhcGUueTIgKiAyKSkge1xyXG4gICAgICAgICAgICBzaGFwZS55MSA9IHNoYXBlLnkyID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS55MSwgbGluZVdpZHRoLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSByZWN0IGZvciBjYW52YXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc2hhcGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnhdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnldXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLndpZHRoXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS5oZWlnaHRdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnN0eWxlXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zdHlsZS5saW5lV2lkdGhdXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE1vZGlmaWVkIHBhcmFtXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZVJlY3QgPSBmdW5jdGlvbiAocGFyYW0pIHtcclxuICAgICAgICB2YXIgc3ViUGl4ZWxPcHRpbWl6ZSA9IGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZTtcclxuICAgICAgICB2YXIgc2hhcGUgPSBwYXJhbS5zaGFwZTtcclxuICAgICAgICB2YXIgbGluZVdpZHRoID0gcGFyYW0uc3R5bGUubGluZVdpZHRoO1xyXG4gICAgICAgIHZhciBvcmlnaW5YID0gc2hhcGUueDtcclxuICAgICAgICB2YXIgb3JpZ2luWSA9IHNoYXBlLnk7XHJcbiAgICAgICAgdmFyIG9yaWdpbldpZHRoID0gc2hhcGUud2lkdGg7XHJcbiAgICAgICAgdmFyIG9yaWdpbkhlaWdodCA9IHNoYXBlLmhlaWdodDtcclxuICAgICAgICBzaGFwZS54ID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS54LCBsaW5lV2lkdGgsIHRydWUpO1xyXG4gICAgICAgIHNoYXBlLnkgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLnksIGxpbmVXaWR0aCwgdHJ1ZSk7XHJcbiAgICAgICAgc2hhcGUud2lkdGggPSBNYXRoLm1heChcclxuICAgICAgICAgICAgc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5YICsgb3JpZ2luV2lkdGgsIGxpbmVXaWR0aCwgZmFsc2UpIC0gc2hhcGUueCxcclxuICAgICAgICAgICAgb3JpZ2luV2lkdGggPT09IDAgPyAwIDogMVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgc2hhcGUuaGVpZ2h0ID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgIHN1YlBpeGVsT3B0aW1pemUob3JpZ2luWSArIG9yaWdpbkhlaWdodCwgbGluZVdpZHRoLCBmYWxzZSkgLSBzaGFwZS55LFxyXG4gICAgICAgICAgICBvcmlnaW5IZWlnaHQgPT09IDAgPyAwIDogMVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBmb3IgY2FudmFzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIENvb3JkaW5hdGUsIHN1Y2ggYXMgeCwgeVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBTaG91bGQgYmUgbm9ubmVnYXRpdmUgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHBvc2l0aXZlT3JOZWdhdGl2ZSBEZWZhdWx0IGZhbHNlIChuZWdhdGl2ZSkuXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE9wdGltaXplZCBwb3NpdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBsaW5lV2lkdGgsIHBvc2l0aXZlT3JOZWdhdGl2ZSkge1xyXG4gICAgICAgIC8vIEFzc3VyZSB0aGF0IChwb3NpdGlvbiArIGxpbmVXaWR0aCAvIDIpIGlzIG5lYXIgaW50ZWdlciBlZGdlLFxyXG4gICAgICAgIC8vIG90aGVyd2lzZSBsaW5lIHdpbGwgYmUgZnV6enkgaW4gY2FudmFzLlxyXG4gICAgICAgIHZhciBkb3VibGVkUG9zaXRpb24gPSByb3VuZChwb3NpdGlvbiAqIDIpO1xyXG4gICAgICAgIHJldHVybiAoZG91YmxlZFBvc2l0aW9uICsgcm91bmQobGluZVdpZHRoKSkgJSAyID09PSAwXHJcbiAgICAgICAgICAgID8gZG91YmxlZFBvc2l0aW9uIC8gMlxyXG4gICAgICAgICAgICA6IChkb3VibGVkUG9zaXRpb24gKyAocG9zaXRpdmVPck5lZ2F0aXZlID8gMSA6IC0xKSkgLyAyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRvU2luZ2xlRW50ZXJIb3ZlcihlbCkge1xyXG4gICAgICAgIGlmIChlbC5fX2lzSG92ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWwuX19ob3ZlclN0bERpcnR5KSB7XHJcbiAgICAgICAgICAgIHZhciBzdHJva2UgPSBlbC5zdHlsZS5zdHJva2U7XHJcbiAgICAgICAgICAgIHZhciBmaWxsID0gZWwuc3R5bGUuZmlsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBob3ZlclN0eWxlIG9uIG1vdXNlb3ZlclxyXG4gICAgICAgICAgICB2YXIgaG92ZXJTdHlsZSA9IGVsLl9faG92ZXJTdGw7XHJcbiAgICAgICAgICAgIHZhciBsaWZ0ID0gY29sb3JUb29sLmxpZnQ7XHJcbiAgICAgICAgICAgIGhvdmVyU3R5bGUuZmlsbCA9IGhvdmVyU3R5bGUuZmlsbFxyXG4gICAgICAgICAgICAgICAgfHwgKGZpbGwgJiYgKGZpbGwgaW5zdGFuY2VvZiBHcmFkaWVudCA/IGZpbGwgOiBsaWZ0KGZpbGwsIC0wLjEpKSk7XHJcbiAgICAgICAgICAgIGhvdmVyU3R5bGUuc3Ryb2tlID0gaG92ZXJTdHlsZS5zdHJva2VcclxuICAgICAgICAgICAgICAgIHx8IChzdHJva2UgJiYgKHN0cm9rZSBpbnN0YW5jZW9mIEdyYWRpZW50ID8gc3Ryb2tlIDogbGlmdChzdHJva2UsIC0wLjEpKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9ybWFsU3R5bGUgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBob3ZlclN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG92ZXJTdHlsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFN0eWxlW25hbWVdID0gZWwuc3R5bGVbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVsLl9fbm9ybWFsU3RsID0gbm9ybWFsU3R5bGU7XHJcblxyXG4gICAgICAgICAgICBlbC5fX2hvdmVyU3RsRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWwuc2V0U3R5bGUoZWwuX19ob3ZlclN0bCk7XHJcbiAgICAgICAgZWwuejIgKz0gMTtcclxuXHJcbiAgICAgICAgZWwuX19pc0hvdmVyID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkb1NpbmdsZUxlYXZlSG92ZXIoZWwpIHtcclxuICAgICAgICBpZiAoIWVsLl9faXNIb3Zlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbm9ybWFsU3RsID0gZWwuX19ub3JtYWxTdGw7XHJcbiAgICAgICAgbm9ybWFsU3RsICYmIGVsLnNldFN0eWxlKG5vcm1hbFN0bCk7XHJcbiAgICAgICAgZWwuejIgLT0gMTtcclxuXHJcbiAgICAgICAgZWwuX19pc0hvdmVyID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZG9FbnRlckhvdmVyKGVsKSB7XHJcbiAgICAgICAgKGVsLnR5cGUgPT09ICdncm91cCcgfHwgZWwudHlwZSA9PT0gJ0dyb3VwTm9kZScpXHJcbiAgICAgICAgICAgID8gZWwudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvU2luZ2xlRW50ZXJIb3ZlcihjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogZG9TaW5nbGVFbnRlckhvdmVyKGVsKTtcclxuICAgIH1cclxuICAgIGdyYXBoaWMuZG9FbnRlckhvdmVyID0gZG9FbnRlckhvdmVyO1xyXG4gICAgZnVuY3Rpb24gZG9MZWF2ZUhvdmVyKGVsKSB7XHJcbiAgICAgICAgZWwudHlwZSA9PT0gJ2dyb3VwJ1xyXG4gICAgICAgICAgICA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09ICdncm91cCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb1NpbmdsZUxlYXZlSG92ZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICA6IGRvU2luZ2xlTGVhdmVIb3ZlcihlbCk7XHJcbiAgICB9XHJcbiAgICBncmFwaGljLmRvTGVhdmVIb3ZlciA9IGRvTGVhdmVIb3ZlcjtcclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNldEVsZW1lbnRIb3ZlclN0bChlbCwgaG92ZXJTdGwpIHtcclxuICAgICAgICAvLyBJZiBlbGVtZW50IGhhcyBzZXBjaWZpZWQgaG92ZXJTdHlsZSwgdGhlbiB1c2UgaXQgaW5zdGVhZCBvZiBnaXZlbiBob3ZlclN0eWxlXHJcbiAgICAgICAgLy8gT2Z0ZW4gdXNlZCB3aGVuIGl0ZW0gZ3JvdXAgaGFzIGEgbGFiZWwgZWxlbWVudCBhbmQgaXQncyBob3ZlclN0eWxlIGlzIGRpZmZlcmVudFxyXG4gICAgICAgIGVsLl9faG92ZXJTdGwgPSBlbC5ob3ZlclN0eWxlIHx8IGhvdmVyU3RsIHx8IHt9O1xyXG4gICAgICAgIGVsLl9faG92ZXJTdGxEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBncmFwaGljLnNldEVsZW1lbnRIb3ZlclN0bCA9IHNldEVsZW1lbnRIb3ZlclN0bDtcclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uRWxlbWVudE1vdXNlT3ZlcigpIHtcclxuICAgICAgICAvLyBPbmx5IGlmIGVsZW1lbnQgaXMgbm90IGluIGVtcGhhc2lzIHN0YXR1c1xyXG4gICAgICAgICF0aGlzLl9faXNFbXBoYXNpcyAmJiBkb0VudGVySG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25FbGVtZW50TW91c2VPdXQoKSB7XHJcbiAgICAgICAgLy8gT25seSBpZiBlbGVtZW50IGlzIG5vdCBpbiBlbXBoYXNpcyBzdGF0dXNcclxuICAgICAgICAhdGhpcy5fX2lzRW1waGFzaXMgJiYgZG9MZWF2ZUhvdmVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGVudGVyRW1waGFzaXMoKSB7XHJcbiAgICAgICAgdGhpcy5fX2lzRW1waGFzaXMgPSB0cnVlO1xyXG4gICAgICAgIGRvRW50ZXJIb3Zlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBsZWF2ZUVtcGhhc2lzKCkge1xyXG4gICAgICAgIHRoaXMuX19pc0VtcGhhc2lzID0gZmFsc2U7XHJcbiAgICAgICAgZG9MZWF2ZUhvdmVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGhvdmVyIHN0eWxlIG9mIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbaG92ZXJTdHlsZV1cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlID0gZnVuY3Rpb24gKGVsLCBob3ZlclN0eWxlKSB7XHJcbiAgICAgICAgZWwudHlwZSA9PT0gJ2dyb3VwJ1xyXG4gICAgICAgICAgICA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09ICdncm91cCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50SG92ZXJTdGwoY2hpbGQsIGhvdmVyU3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICA6IHNldEVsZW1lbnRIb3ZlclN0bChlbCwgaG92ZXJTdHlsZSk7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGJvdW5kIGhhbmRsZXJzXHJcbiAgICAgICAgZWwub24oJ21vdXNlb3ZlcicsIG9uRWxlbWVudE1vdXNlT3ZlcilcclxuICAgICAgICAgIC5vbignbW91c2VvdXQnLCBvbkVsZW1lbnRNb3VzZU91dCk7XHJcblxyXG4gICAgICAgIC8vIEVtcGhhc2lzLCBub3JtYWwgY2FuIGJlIHRyaWdnZXJlZCBtYW51YWxseVxyXG4gICAgICAgIGVsLm9uKCdlbXBoYXNpcycsIGVudGVyRW1waGFzaXMpXHJcbiAgICAgICAgICAub24oJ25vcm1hbCcsIGxlYXZlRW1waGFzaXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBncmFwaGljLnNldE5vcm1hbFN0eWxlID0gZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoZWwuX19ub3JtYWxTdGwpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwuX19ub3JtYWxTdGwuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5fX25vcm1hbFN0bFtuYW1lXSA9IG9wdGlvbnNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRleHQgb3B0aW9uIGluIHRoZSBzdHlsZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRleHRTdHlsZVxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbGFiZWxNb2RlbFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuc2V0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0U3R5bGUsIGxhYmVsTW9kZWwsIGNvbG9yKSB7XHJcbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ3Bvc2l0aW9uJykgfHwgJ2luc2lkZSc7XHJcbiAgICAgICAgdmFyIGxhYmVsQ29sb3IgPSBsYWJlbFBvc2l0aW9uLmluZGV4T2YoJ2luc2lkZScpID49IDAgPyAnd2hpdGUnIDogY29sb3I7XHJcbiAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gbGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XHJcbiAgICAgICAgenJVdGlsLmV4dGVuZCh0ZXh0U3R5bGUsIHtcclxuICAgICAgICAgICAgdGV4dERpc3RhbmNlOiBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ2Rpc3RhbmNlJykgfHwgNSxcclxuICAgICAgICAgICAgdGV4dEZvbnQ6IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcclxuICAgICAgICAgICAgdGV4dFBvc2l0aW9uOiBsYWJlbFBvc2l0aW9uLFxyXG4gICAgICAgICAgICB0ZXh0RmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCkgfHwgbGFiZWxDb2xvclxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBhbmltYXRlT3JTZXRQcm9wcyhpc1VwZGF0ZSwgZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGNiKSB7XHJcbiAgICAgICAgdmFyIHBvc3RmaXggPSBpc1VwZGF0ZSA/ICdVcGRhdGUnIDogJyc7XHJcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gYW5pbWF0YWJsZU1vZGVsXHJcbiAgICAgICAgICAgICYmIGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb25EdXJhdGlvbicgKyBwb3N0Zml4KTtcclxuICAgICAgICB2YXIgYW5pbWF0aW9uRWFzaW5nID0gYW5pbWF0YWJsZU1vZGVsXHJcbiAgICAgICAgICAgICYmIGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb25FYXNpbmcnICsgcG9zdGZpeCk7XHJcblxyXG4gICAgICAgIGFuaW1hdGFibGVNb2RlbCAmJiBhbmltYXRhYmxlTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uJylcclxuICAgICAgICAgICAgPyBlbC5hbmltYXRlVG8ocHJvcHMsIGR1cmF0aW9uLCBhbmltYXRpb25FYXNpbmcsIGNiKVxyXG4gICAgICAgICAgICA6IChlbC5hdHRyKHByb3BzKSwgY2IgJiYgY2IoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBncmFwaGljIGVsZW1lbnQgcHJvcGVydGllcyB3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uIGFjY29yZGluZyB0byB0aGUgY29uZmlndXJhdGlvbiBpbiBzZXJpZXNcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW2FuaW1hdGFibGVNb2RlbF1cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMudXBkYXRlUHJvcHMgPSB6clV0aWwuY3VycnkoYW5pbWF0ZU9yU2V0UHJvcHMsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdCBncmFwaGljIGVsZW1lbnQgcHJvcGVydGllcyB3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uIGFjY29yZGluZyB0byB0aGUgY29uZmlndXJhdGlvbiBpbiBzZXJpZXNcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gW2FuaW1hdGFibGVNb2RlbF1cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuaW5pdFByb3BzID0genJVdGlsLmN1cnJ5KGFuaW1hdGVPclNldFByb3BzLCBmYWxzZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdHJhbnNmb3JtIG1hdHJpeCBvZiB0YXJnZXQgKHBhcmFtIHRhcmdldCksXHJcbiAgICAgKiBpbiBjb29yZGluYXRlIG9mIGl0cyBhbmNlc3RvciAocGFyYW0gYW5jZXN0b3IpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX0gYW5jZXN0b3JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodGFyZ2V0LCBhbmNlc3Rvcikge1xyXG4gICAgICAgIHZhciBtYXQgPSBtYXRyaXguaWRlbnRpdHkoW10pO1xyXG5cclxuICAgICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gYW5jZXN0b3IpIHtcclxuICAgICAgICAgICAgbWF0cml4Lm11bChtYXQsIHRhcmdldC5nZXRMb2NhbFRyYW5zZm9ybSgpLCBtYXQpO1xyXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG1hdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSB0cmFuc2Zvcm0gdG8gYW4gdmVydGV4LlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmVydGV4IFt4LCB5XVxyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdHJhbnNmb3JtIFRyYW5zZm9ybSBtYXRyaXg6IGxpa2UgWzEsIDAsIDAsIDEsIDAsIDBdXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbnZlcnQgV2hldGhlciB1c2UgaW52ZXJ0IG1hdHJpeC5cclxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBbeCwgeV1cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2ZXJ0ZXgsIHRyYW5zZm9ybSwgaW52ZXJ0KSB7XHJcbiAgICAgICAgaWYgKGludmVydCkge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBtYXRyaXguaW52ZXJ0KFtdLCB0cmFuc2Zvcm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5VHJhbnNmb3JtKFtdLCB2ZXJ0ZXgsIHRyYW5zZm9ybSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiAnbGVmdCcgJ3JpZ2h0JyAndG9wJyAnYm90dG9tJ1xyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdHJhbnNmb3JtIFRyYW5zZm9ybSBtYXRyaXg6IGxpa2UgWzEsIDAsIDAsIDEsIDAsIDBdXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbnZlcnQgV2hldGhlciB1c2UgaW52ZXJ0IG1hdHJpeC5cclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVHJhbnNmb3JtZWQgZGlyZWN0aW9uLiAnbGVmdCcgJ3JpZ2h0JyAndG9wJyAnYm90dG9tJ1xyXG4gICAgICovXHJcbiAgICBncmFwaGljLnRyYW5zZm9ybURpcmVjdGlvbiA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIHRyYW5zZm9ybSwgaW52ZXJ0KSB7XHJcblxyXG4gICAgICAgIC8vIFBpY2sgYSBiYXNlLCBlbnN1cmUgdGhhdCB0cmFuc2Zvcm0gcmVzdWx0IHdpbGwgbm90IGJlICgwLCAwKS5cclxuICAgICAgICB2YXIgaEJhc2UgPSAodHJhbnNmb3JtWzRdID09PSAwIHx8IHRyYW5zZm9ybVs1XSA9PT0gMCB8fCB0cmFuc2Zvcm1bMF0gPT09IDApXHJcbiAgICAgICAgICAgID8gMSA6IE1hdGguYWJzKDIgKiB0cmFuc2Zvcm1bNF0gLyB0cmFuc2Zvcm1bMF0pO1xyXG4gICAgICAgIHZhciB2QmFzZSA9ICh0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVsyXSA9PT0gMClcclxuICAgICAgICAgICAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVsyXSk7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0ZXggPSBbXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ2xlZnQnID8gLWhCYXNlIDogZGlyZWN0aW9uID09PSAncmlnaHQnID8gaEJhc2UgOiAwLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb24gPT09ICd0b3AnID8gLXZCYXNlIDogZGlyZWN0aW9uID09PSAnYm90dG9tJyA/IHZCYXNlIDogMFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIHZlcnRleCA9IGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0odmVydGV4LCB0cmFuc2Zvcm0sIGludmVydCk7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh2ZXJ0ZXhbMF0pID4gTWF0aC5hYnModmVydGV4WzFdKVxyXG4gICAgICAgICAgICA/ICh2ZXJ0ZXhbMF0gPiAwID8gJ3JpZ2h0JyA6ICdsZWZ0JylcclxuICAgICAgICAgICAgOiAodmVydGV4WzFdID4gMCA/ICdib3R0b20nIDogJ3RvcCcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdyYXBoaWM7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL3V0aWxcbiAqL1xuXG5cbiAgICAvLyDnlKjkuo7lpITnkIZtZXJnZeaXtuaXoOazlemBjeWOhkRhdGXnrYnlr7nosaHnmoTpl67pophcbiAgICB2YXIgQlVJTFRJTl9PQkpFQ1QgPSB7XG4gICAgICAgICdbb2JqZWN0IEZ1bmN0aW9uXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IFJlZ0V4cF0nOiAxLFxuICAgICAgICAnW29iamVjdCBEYXRlXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IEVycm9yXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJzogMSxcbiAgICAgICAgLy8gRm9yIG5vZGUtY2FudmFzXG4gICAgICAgICdbb2JqZWN0IEltYWdlXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IENhbnZhc10nOiAxXG4gICAgfTtcblxuICAgIHZhciBUWVBFRF9BUlJBWSA9IHtcbiAgICAgICAgJ1tvYmplY3QgSW50OEFycmF5XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJzogMSxcbiAgICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJzogMSxcbiAgICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBJbnQzMkFycmF5XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nOiAxLFxuICAgICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJzogMVxuICAgIH07XG5cbiAgICB2YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gICAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG4gICAgdmFyIG5hdGl2ZUZvckVhY2ggPSBhcnJheVByb3RvLmZvckVhY2g7XG4gICAgdmFyIG5hdGl2ZUZpbHRlciA9IGFycmF5UHJvdG8uZmlsdGVyO1xuICAgIHZhciBuYXRpdmVTbGljZSA9IGFycmF5UHJvdG8uc2xpY2U7XG4gICAgdmFyIG5hdGl2ZU1hcCA9IGFycmF5UHJvdG8ubWFwO1xuICAgIHZhciBuYXRpdmVSZWR1Y2UgPSBhcnJheVByb3RvLnJlZHVjZTtcblxuICAgIC8qKlxuICAgICAqIFRob3NlIGRhdGEgdHlwZXMgY2FuIGJlIGNsb25lZDpcbiAgICAgKiAgICAgUGxhaW4gb2JqZWN0LCBBcnJheSwgVHlwZWRBcnJheSwgbnVtYmVyLCBzdHJpbmcsIG51bGwsIHVuZGVmaW5lZC5cbiAgICAgKiBUaG9zZSBkYXRhIHR5cGVzIHdpbGwgYmUgYXNzZ2luZWQgdXNpbmcgdGhlIG9yZ2luYWwgZGF0YTpcbiAgICAgKiAgICAgQlVJTFRJTl9PQkpFQ1RcbiAgICAgKiBJbnN0YW5jZSBvZiB1c2VyIGRlZmluZWQgY2xhc3Mgd2lsbCBiZSBjbG9uZWQgdG8gYSBwbGFpbiBvYmplY3QsIHdpdGhvdXRcbiAgICAgKiBwcm9wZXJ0aWVzIGluIHByb3RvdHlwZS5cbiAgICAgKiBPdGhlciBkYXRhIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQgKG5vdCBzdXJlIHdoYXQgd2lsbCBoYXBwZW4pLlxuICAgICAqXG4gICAgICogQ2F1dGlvbjogZG8gbm90IHN1cHBvcnQgY2xvbmUgRGF0ZSwgZm9yIHBlcmZvcm1hbmNlIGNvbnNpZGVyYXRpb24uXG4gICAgICogKFRoZXJlIG1pZ2h0IGJlIGEgbGFyZ2UgbnVtYmVyIG9mIGRhdGUgaW4gYHNlcmllcy5kYXRhYCkuXG4gICAgICogU28gZGF0ZSBzaG91bGQgbm90IGJlIG1vZGlmaWVkIGluIGFuZCBvdXQgb2YgZWNoYXJ0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlXG4gICAgICogQHJldHVybiB7Kn0gbmV3XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UgPT0gbnVsbCB8fCB0eXBlb2Ygc291cmNlICE9ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHNvdXJjZTtcbiAgICAgICAgdmFyIHR5cGVTdHIgPSBvYmpUb1N0cmluZy5jYWxsKHNvdXJjZSk7XG5cbiAgICAgICAgaWYgKHR5cGVTdHIgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNsb25lKHNvdXJjZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVFlQRURfQVJSQVlbdHlwZVN0cl0pIHtcbiAgICAgICAgICAgIHZhciBDdG9yID0gc291cmNlLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5jb25zdHJ1Y3Rvci5mcm9tKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQ3Rvci5mcm9tKHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQ3Rvcihzb3VyY2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNsb25lKHNvdXJjZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFCVUlMVElOX09CSkVDVFt0eXBlU3RyXSAmJiAhaXNQcmltaXRpdmUoc291cmNlKSAmJiAhaXNEb20oc291cmNlKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gY2xvbmUoc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG92ZXJ3cml0ZSkge1xuICAgICAgICAvLyBXZSBzaG91bGQgZXNjYXBzZSB0aGF0IHNvdXJjZSBpcyBzdHJpbmdcbiAgICAgICAgLy8gYW5kIGVudGVyIGZvciAuLi4gaW4gLi4uXG4gICAgICAgIGlmICghaXNPYmplY3Qoc291cmNlKSB8fCAhaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG92ZXJ3cml0ZSA/IGNsb25lKHNvdXJjZSkgOiB0YXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0UHJvcCA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VQcm9wID0gc291cmNlW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgaXNPYmplY3QodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzQXJyYXkoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzQXJyYXkodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzRG9tKHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0RvbSh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNCdWlsdEluT2JqZWN0KHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0J1aWx0SW5PYmplY3QodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzUHJpbWl0aXZlKHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc1ByaW1pdGl2ZSh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzpnIDopoHpgJLlvZLopobnm5bvvIzlsLHpgJLlvZLosIPnlKhtZXJnZVxuICAgICAgICAgICAgICAgICAgICBtZXJnZSh0YXJnZXRQcm9wLCBzb3VyY2VQcm9wLCBvdmVyd3JpdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvdmVyd3JpdGUgfHwgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlkKbliJnlj6rlpITnkIZvdmVyd3JpdGXkuLp0cnVl77yM5oiW6ICF5Zyo55uu5qCH5a+56LGh5Lit5rKh5pyJ5q2k5bGe5oCn55qE5oOF5Ya1XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEXvvIzlnKggdGFyZ2V0W2tleV0g5LiN5a2Y5Zyo55qE5pe25YCZ5Lmf5piv55u05o6l6KaG55uWXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gY2xvbmUoc291cmNlW2tleV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0QW5kU291cmNlcyBUaGUgZmlyc3QgaXRlbSBpcyB0YXJnZXQsIGFuZCB0aGUgcmVzdHMgYXJlIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdXG4gICAgICogQHJldHVybiB7Kn0gdGFyZ2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VBbGwodGFyZ2V0QW5kU291cmNlcywgb3ZlcndyaXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXRBbmRTb3VyY2VzWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGFyZ2V0QW5kU291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gbWVyZ2UocmVzdWx0LCB0YXJnZXRBbmRTb3VyY2VzW2ldLCBvdmVyd3JpdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVybGF5PWZhbHNlXVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSlcbiAgICAgICAgICAgICAgICAmJiAob3ZlcmxheSA/IHNvdXJjZVtrZXldICE9IG51bGwgOiB0YXJnZXRba2V5XSA9PSBudWxsKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH1cbiAgICAvLyBGSVhNRVxuICAgIHZhciBfY3R4O1xuICAgIGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgICAgIGlmICghX2N0eCkge1xuICAgICAgICAgICAgLy8gVXNlIHV0aWwuY3JlYXRlQ2FudmFzIGluc3RlYWQgb2YgY3JlYXRlQ2FudmFzXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGNyZWF0ZUNhbnZhcyBtYXkgYmUgb3ZlcndyaXR0ZW4gaW4gZGlmZmVyZW50IGVudmlyb25tZW50XG4gICAgICAgICAgICBfY3R4ID0gdXRpbC5jcmVhdGVDYW52YXMoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfY3R4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOafpeivouaVsOe7hOS4reWFg+e0oOeahGluZGV4XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKGFycmF5LmluZGV4T2YpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5p6E6YCg57G757un5om/5YWz57O7XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xhenog5rqQ57G7XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZUNsYXp6IOWfuuexu1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaGVyaXRzKGNsYXp6LCBiYXNlQ2xhenopIHtcbiAgICAgICAgdmFyIGNsYXp6UHJvdG90eXBlID0gY2xhenoucHJvdG90eXBlO1xuICAgICAgICBmdW5jdGlvbiBGKCkge31cbiAgICAgICAgRi5wcm90b3R5cGUgPSBiYXNlQ2xhenoucHJvdG90eXBlO1xuICAgICAgICBjbGF6ei5wcm90b3R5cGUgPSBuZXcgRigpO1xuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gY2xhenpQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGNsYXp6LnByb3RvdHlwZVtwcm9wXSA9IGNsYXp6UHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIGNsYXp6LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNsYXp6O1xuICAgICAgICBjbGF6ei5zdXBlckNsYXNzID0gYmFzZUNsYXp6O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHNvcmNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvdmVybGF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4odGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpIHtcbiAgICAgICAgdGFyZ2V0ID0gJ3Byb3RvdHlwZScgaW4gdGFyZ2V0ID8gdGFyZ2V0LnByb3RvdHlwZSA6IHRhcmdldDtcbiAgICAgICAgc291cmNlID0gJ3Byb3RvdHlwZScgaW4gc291cmNlID8gc291cmNlLnByb3RvdHlwZSA6IHNvdXJjZTtcblxuICAgICAgICBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc2lkZXIgdHlwZWQgYXJyYXkuXG4gICAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UoZGF0YSkge1xuICAgICAgICBpZiAoISBkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkYXRhLmxlbmd0aCA9PSAnbnVtYmVyJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4TmiJblr7nosaHpgY3ljoZcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYWNoKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICAgICAgb2JqLmZvckVhY2goY2IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4TmmKDlsIRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLm1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoubWFwKGNiLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFttZW1vXVxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKG9iaiwgY2IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoucmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5yZWR1Y2UoY2IsIG1lbW8sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG1lbW8gPSBjYi5jYWxsKGNvbnRleHQsIG1lbW8sIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5pWw57uE6L+H5rukXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIob2JqLCBjYiwgY29udGV4dCkge1xuICAgICAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5maWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmZpbHRlcihjYiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9ialtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaVsOe7hOmhueafpeaJvlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZChvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kKGZ1bmMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZ1bmMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBTdHJpbmddJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAoISF2YWx1ZSAmJiB0eXBlID09ICdvYmplY3QnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCdWlsdEluT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhIUJVSUxUSU5fT0JKRUNUW29ialRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEb20odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICYmIHR5cGVvZiB2YWx1ZS5ub2RlVHlwZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICYmIHR5cGVvZiB2YWx1ZS5vd25lckRvY3VtZW50ID09PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGlzIGV4YWN0bHkgTmFOLiBOb3RpY2UgaXNOYU4oJ2EnKSByZXR1cm5zIHRydWUuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXFOYU4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB2YWx1ZTEgaXMgbm90IG51bGwsIHRoZW4gcmV0dXJuIHZhbHVlMSwgb3RoZXJ3aXNlIGp1ZGdldCByZXN0IG9mIHZhbHVlcy5cbiAgICAgKiBMb3cgcGVyZm9ybWFuY2UuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEByZXR1cm4geyp9IEZpbmFsIHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV0cmlldmUodmFsdWVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXRyaWV2ZTIodmFsdWUwLCB2YWx1ZTEpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlMCAhPSBudWxsXG4gICAgICAgICAgICA/IHZhbHVlMFxuICAgICAgICAgICAgOiB2YWx1ZTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV0cmlldmUzKHZhbHVlMCwgdmFsdWUxLCB2YWx1ZTIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlMCAhPSBudWxsXG4gICAgICAgICAgICA/IHZhbHVlMFxuICAgICAgICAgICAgOiB2YWx1ZTEgIT0gbnVsbFxuICAgICAgICAgICAgPyB2YWx1ZTFcbiAgICAgICAgICAgIDogdmFsdWUyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRJbmRleFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKCkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24uY2FsbC5hcHBseShuYXRpdmVTbGljZSwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgY3NzIGxpa2VkIGFycmF5IGNvbmZpZ3VyYXRpb25cbiAgICAgKiBlLmcuXG4gICAgICogIDMgPT4gWzMsIDMsIDMsIDNdXG4gICAgICogIFs0LCAyXSA9PiBbNCwgMiwgNCwgMl1cbiAgICAgKiAgWzQsIDMsIDJdID0+IFs0LCAzLCAyLCAzXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSB2YWxcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVDc3NBcnJheSh2YWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBbdmFsLCB2YWwsIHZhbCwgdmFsXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gdmFsLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMikge1xuICAgICAgICAgICAgLy8gdmVydGljYWwgfCBob3Jpem9udGFsXG4gICAgICAgICAgICByZXR1cm4gW3ZhbFswXSwgdmFsWzFdLCB2YWxbMF0sIHZhbFsxXV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID09PSAzKSB7XG4gICAgICAgICAgICAvLyB0b3AgfCBob3Jpem9udGFsIHwgYm90dG9tXG4gICAgICAgICAgICByZXR1cm4gW3ZhbFswXSwgdmFsWzFdLCB2YWxbMl0sIHZhbFsxXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25kaXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmltaXRpdmVLZXkgPSAnX19lY19wcmltaXRpdmVfXyc7XG4gICAgLyoqXG4gICAgICogU2V0IGFuIG9iamVjdCBhcyBwcmltaXRpdmUgdG8gYmUgaWdub3JlZCB0cmF2ZXJzaW5nIGNoaWxkcmVuIGluIGNsb25lIG9yIG1lcmdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0QXNQcmltaXRpdmUob2JqKSB7XG4gICAgICAgIG9ialtwcmltaXRpdmVLZXldID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmopIHtcbiAgICAgICAgcmV0dXJuIG9ialtwcmltaXRpdmVLZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT25seSBhcHBseSBgb3duUHJvcGVydHlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhhc2hNYXAob2JqKSB7XG4gICAgICAgIG9iaiAmJiBlYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcHJlZml4IHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZS5cbiAgICB2YXIgSEFTSF9NQVBfUFJFRklYID0gJ19lY18nO1xuICAgIHZhciBIQVNIX01BUF9QUkVGSVhfTEVOR1RIID0gNDtcblxuICAgIEhhc2hNYXAucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogSGFzaE1hcCxcbiAgICAgICAgLy8gRG8gbm90IHByb3ZpZGUgYGhhc2AgbWV0aG9kIHRvIGF2b2lkIGRlZmluaW5nIHdoYXQgaXMgYGhhc2AuXG4gICAgICAgIC8vIChXZSB1c3VhbGx5IHRyZWF0IGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXMgdGhlIHNhbWUsIGRpZmZlcmVudFxuICAgICAgICAvLyBmcm9tIEVTNiBNYXApLlxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNbSEFTSF9NQVBfUFJFRklYICsga2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gQ29tcGFyaW5nIHdpdGggaW52b2NhdGlvbiBjaGFpbmluZywgYHJldHVybiB2YWx1ZWAgaXMgbW9yZSBjb21tb25seVxuICAgICAgICAgICAgLy8gdXNlZCBpbiB0aGlzIGNhc2U6IGB2YXIgc29tZVZhbCA9IG1hcC5zZXQoJ2EnLCBnZW5WYWwoKSk7YFxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICAvLyBBbHRob3VnaCB1dGlsLmVhY2ggY2FuIGJlIHBlcmZvcm1lZCBvbiB0aGlzIGhhc2hNYXAgZGlyZWN0bHksIHVzZXJcbiAgICAgICAgLy8gc2hvdWxkIG5vdCB1c2UgdGhlIGV4cG9zZWQga2V5cywgd2hvIGFyZSBwcmVmaXhlZC5cbiAgICAgICAgZWFjaDogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0ICE9PSB2b2lkIDAgJiYgKGNiID0gYmluZChjYiwgY29udGV4dCkpO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJlZml4ZWRLZXkgaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzT3duUHJvcGVydHkocHJlZml4ZWRLZXkpXG4gICAgICAgICAgICAgICAgICAgICYmIGNiKHRoaXNbcHJlZml4ZWRLZXldLCBwcmVmaXhlZEtleS5zbGljZShIQVNIX01BUF9QUkVGSVhfTEVOR1RIKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgaWYgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICAgICAgICByZW1vdmVLZXk6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW0hBU0hfTUFQX1BSRUZJWCArIGtleV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlSGFzaE1hcChvYmopIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIYXNoTWFwKG9iaik7XG4gICAgfVxuXG4gICAgdmFyIHV0aWwgPSB7XG4gICAgICAgIGluaGVyaXRzOiBpbmhlcml0cyxcbiAgICAgICAgbWl4aW46IG1peGluLFxuICAgICAgICBjbG9uZTogY2xvbmUsXG4gICAgICAgIG1lcmdlOiBtZXJnZSxcbiAgICAgICAgbWVyZ2VBbGw6IG1lcmdlQWxsLFxuICAgICAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgICAgICBnZXRDb250ZXh0OiBnZXRDb250ZXh0LFxuICAgICAgICBjcmVhdGVDYW52YXM6IGNyZWF0ZUNhbnZhcyxcbiAgICAgICAgaW5kZXhPZjogaW5kZXhPZixcbiAgICAgICAgc2xpY2U6IHNsaWNlLFxuICAgICAgICBmaW5kOiBmaW5kLFxuICAgICAgICBpc0FycmF5TGlrZTogaXNBcnJheUxpa2UsXG4gICAgICAgIGVhY2g6IGVhY2gsXG4gICAgICAgIG1hcDogbWFwLFxuICAgICAgICByZWR1Y2U6IHJlZHVjZSxcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgIGJpbmQ6IGJpbmQsXG4gICAgICAgIGN1cnJ5OiBjdXJyeSxcbiAgICAgICAgaXNBcnJheTogaXNBcnJheSxcbiAgICAgICAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICAgICAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gICAgICAgIGlzQnVpbHRJbk9iamVjdDogaXNCdWlsdEluT2JqZWN0LFxuICAgICAgICBpc0RvbTogaXNEb20sXG4gICAgICAgIGVxTmFOOiBlcU5hTixcbiAgICAgICAgcmV0cmlldmU6IHJldHJpZXZlLFxuICAgICAgICByZXRyaWV2ZTI6IHJldHJpZXZlMixcbiAgICAgICAgcmV0cmlldmUzOiByZXRyaWV2ZTMsXG4gICAgICAgIGFzc2VydDogYXNzZXJ0LFxuICAgICAgICBzZXRBc1ByaW1pdGl2ZTogc2V0QXNQcmltaXRpdmUsXG4gICAgICAgIGNyZWF0ZUhhc2hNYXA6IGNyZWF0ZUhhc2hNYXAsXG4gICAgICAgIG5vcm1hbGl6ZUNzc0FycmF5OiBub3JtYWxpemVDc3NBcnJheSxcbiAgICAgICAgbm9vcDogZnVuY3Rpb24gKCkge31cbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gdXRpbDtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cbiAgICB2YXIgUGF0aCA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvUGF0aCcpO1xuICAgIHZhciBQYXRoUHJveHkgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpO1xuICAgIHZhciB0cmFuc2Zvcm1QYXRoID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1QYXRoJyk7XG5cbiAgICAvLyBjb21tYW5kIGNoYXJzXG4gICAgdmFyIGNjID0gW1xuICAgICAgICAnbScsICdNJywgJ2wnLCAnTCcsICd2JywgJ1YnLCAnaCcsICdIJywgJ3onLCAnWicsXG4gICAgICAgICdjJywgJ0MnLCAncScsICdRJywgJ3QnLCAnVCcsICdzJywgJ1MnLCAnYScsICdBJ1xuICAgIF07XG5cbiAgICB2YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgbWF0aENvcyA9IE1hdGguY29zO1xuICAgIHZhciBQSSA9IE1hdGguUEk7XG5cbiAgICB2YXIgdk1hZyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh2WzBdICogdlswXSArIHZbMV0gKiB2WzFdKTtcbiAgICB9O1xuICAgIHZhciB2UmF0aW8gPSBmdW5jdGlvbih1LCB2KSB7XG4gICAgICAgIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodk1hZyh1KSAqIHZNYWcodikpO1xuICAgIH07XG4gICAgdmFyIHZBbmdsZSA9IGZ1bmN0aW9uKHUsIHYpIHtcbiAgICAgICAgcmV0dXJuICh1WzBdICogdlsxXSA8IHVbMV0gKiB2WzBdID8gLTEgOiAxKVxuICAgICAgICAgICAgICAgICogTWF0aC5hY29zKHZSYXRpbyh1LCB2KSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NBcmMoeDEsIHkxLCB4MiwgeTIsIGZhLCBmcywgcngsIHJ5LCBwc2lEZWcsIGNtZCwgcGF0aCkge1xuICAgICAgICB2YXIgcHNpID0gcHNpRGVnICogKFBJIC8gMTgwLjApO1xuICAgICAgICB2YXIgeHAgPSBtYXRoQ29zKHBzaSkgKiAoeDEgLSB4MikgLyAyLjBcbiAgICAgICAgICAgICAgICAgKyBtYXRoU2luKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG4gICAgICAgIHZhciB5cCA9IC0xICogbWF0aFNpbihwc2kpICogKHgxIC0geDIpIC8gMi4wXG4gICAgICAgICAgICAgICAgICsgbWF0aENvcyhwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuXG4gICAgICAgIHZhciBsYW1iZGEgPSAoeHAgKiB4cCkgLyAocnggKiByeCkgKyAoeXAgKiB5cCkgLyAocnkgKiByeSk7XG5cbiAgICAgICAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICAgICAgICAgIHJ4ICo9IG1hdGhTcXJ0KGxhbWJkYSk7XG4gICAgICAgICAgICByeSAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSAoZmEgPT09IGZzID8gLTEgOiAxKVxuICAgICAgICAgICAgKiBtYXRoU3FydCgoKChyeCAqIHJ4KSAqIChyeSAqIHJ5KSlcbiAgICAgICAgICAgICAgICAgICAgLSAoKHJ4ICogcngpICogKHlwICogeXApKVxuICAgICAgICAgICAgICAgICAgICAtICgocnkgKiByeSkgKiAoeHAgKiB4cCkpKSAvICgocnggKiByeCkgKiAoeXAgKiB5cClcbiAgICAgICAgICAgICAgICAgICAgKyAocnkgKiByeSkgKiAoeHAgKiB4cCkpXG4gICAgICAgICAgICAgICAgKSB8fCAwO1xuXG4gICAgICAgIHZhciBjeHAgPSBmICogcnggKiB5cCAvIHJ5O1xuICAgICAgICB2YXIgY3lwID0gZiAqIC1yeSAqIHhwIC8gcng7XG5cbiAgICAgICAgdmFyIGN4ID0gKHgxICsgeDIpIC8gMi4wXG4gICAgICAgICAgICAgICAgICsgbWF0aENvcyhwc2kpICogY3hwXG4gICAgICAgICAgICAgICAgIC0gbWF0aFNpbihwc2kpICogY3lwO1xuICAgICAgICB2YXIgY3kgPSAoeTEgKyB5MikgLyAyLjBcbiAgICAgICAgICAgICAgICArIG1hdGhTaW4ocHNpKSAqIGN4cFxuICAgICAgICAgICAgICAgICsgbWF0aENvcyhwc2kpICogY3lwO1xuXG4gICAgICAgIHZhciB0aGV0YSA9IHZBbmdsZShbIDEsIDAgXSwgWyAoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeSBdKTtcbiAgICAgICAgdmFyIHUgPSBbICh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5IF07XG4gICAgICAgIHZhciB2ID0gWyAoLTEgKiB4cCAtIGN4cCkgLyByeCwgKC0xICogeXAgLSBjeXApIC8gcnkgXTtcbiAgICAgICAgdmFyIGRUaGV0YSA9IHZBbmdsZSh1LCB2KTtcblxuICAgICAgICBpZiAodlJhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgICAgICAgICBkVGhldGEgPSBQSTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodlJhdGlvKHUsIHYpID49IDEpIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZzID09PSAwICYmIGRUaGV0YSA+IDApIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IGRUaGV0YSAtIDIgKiBQSTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnMgPT09IDEgJiYgZFRoZXRhIDwgMCkge1xuICAgICAgICAgICAgZFRoZXRhID0gZFRoZXRhICsgMiAqIFBJO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3gsIGN5LCByeCwgcnksIHRoZXRhLCBkVGhldGEsIHBzaSwgZnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGhQcm94eUZyb21TdHJpbmcoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbW1hbmQgc3RyaW5nXG4gICAgICAgIHZhciBjcyA9IGRhdGEucmVwbGFjZSgvLS9nLCAnIC0nKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyAgL2csICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8gL2csICcsJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8sLC9nLCAnLCcpO1xuXG4gICAgICAgIHZhciBuO1xuICAgICAgICAvLyBjcmVhdGUgcGlwZXMgc28gdGhhdCB3ZSBjYW4gc3BsaXQgdGhlIGRhdGFcbiAgICAgICAgZm9yIChuID0gMDsgbiA8IGNjLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICBjcyA9IGNzLnJlcGxhY2UobmV3IFJlZ0V4cChjY1tuXSwgJ2cnKSwgJ3wnICsgY2Nbbl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGFycmF5XG4gICAgICAgIHZhciBhcnIgPSBjcy5zcGxpdCgnfCcpO1xuICAgICAgICAvLyBpbml0IGNvbnRleHQgcG9pbnRcbiAgICAgICAgdmFyIGNweCA9IDA7XG4gICAgICAgIHZhciBjcHkgPSAwO1xuXG4gICAgICAgIHZhciBwYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICAgICAgICB2YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcblxuICAgICAgICB2YXIgcHJldkNtZDtcbiAgICAgICAgZm9yIChuID0gMTsgbiA8IGFyci5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgdmFyIHN0ciA9IGFycltuXTtcbiAgICAgICAgICAgIHZhciBjID0gc3RyLmNoYXJBdCgwKTtcbiAgICAgICAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgICAgICAgdmFyIHAgPSBzdHIuc2xpY2UoMSkucmVwbGFjZSgvZSwtL2csICdlLScpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICB2YXIgY21kO1xuXG4gICAgICAgICAgICBpZiAocC5sZW5ndGggPiAwICYmIHBbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwW2ldID0gcGFyc2VGbG9hdChwW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChvZmYgPCBwLmxlbmd0aCAmJiAhaXNOYU4ocFtvZmZdKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihwWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGN0bFB0eDtcbiAgICAgICAgICAgICAgICB2YXIgY3RsUHR5O1xuXG4gICAgICAgICAgICAgICAgdmFyIHJ4O1xuICAgICAgICAgICAgICAgIHZhciByeTtcbiAgICAgICAgICAgICAgICB2YXIgcHNpO1xuICAgICAgICAgICAgICAgIHZhciBmYTtcbiAgICAgICAgICAgICAgICB2YXIgZnM7XG5cbiAgICAgICAgICAgICAgICB2YXIgeDEgPSBjcHg7XG4gICAgICAgICAgICAgICAgdmFyIHkxID0gY3B5O1xuXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBsLCBILCBoLCBWLCBhbmQgdiB0byBMXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJ0wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY21kLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYgLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYgLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELkMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gY3B4ICsgcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IGNweSArIHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gcFtvZmYrK10gKyBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHBbb2ZmKytdICsgY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuUSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzaSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzID0gcFtvZmYrK107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NBcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcnggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IGNweCwgeTEgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NBcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYyA9PT0gJ3onIHx8IGMgPT09ICdaJykge1xuICAgICAgICAgICAgICAgIGNtZCA9IENNRC5aO1xuICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2Q21kID0gY21kO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aC50b1N0YXRpYygpO1xuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8vIFRPRE8gT3B0aW1pemUgZG91YmxlIG1lbW9yeSBjb3N0IHByb2JsZW1cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpIHtcbiAgICAgICAgdmFyIHBhdGhQcm94eSA9IGNyZWF0ZVBhdGhQcm94eUZyb21TdHJpbmcoc3RyKTtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChwYXRoLnNldERhdGEpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnNldERhdGEocGF0aFByb3h5LmRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIFN2ZyBhbmQgdm1sIHJlbmRlcmVyIGRvbid0IGhhdmUgY29udGV4dFxuICAgICAgICAgICAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gcGF0aDtcbiAgICAgICAgICAgICAgICBwYXRoUHJveHkucmVidWlsZFBhdGgoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBvcHRzLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybVBhdGgocGF0aFByb3h5LCBtKTtcblxuICAgICAgICAgICAgdGhpcy5kaXJ0eSh0cnVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIFBhdGggb2JqZWN0IGZyb20gcGF0aCBzdHJpbmcgZGF0YVxuICAgICAgICAgKiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YVxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlRnJvbVN0cmluZzogZnVuY3Rpb24gKHN0ciwgb3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXRoKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBQYXRoIGNsYXNzIGZyb20gcGF0aCBzdHJpbmcgZGF0YVxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgZXh0ZW5kRnJvbVN0cmluZzogZnVuY3Rpb24gKHN0ciwgb3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIFBhdGguZXh0ZW5kKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXJnZSBtdWx0aXBsZSBwYXRoc1xuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETyBBcHBseSB0cmFuc2Zvcm1cbiAgICAgICAgLy8gVE9ETyBzdHJva2UgZGFzaFxuICAgICAgICAvLyBUT0RPIE9wdGltaXplIGRvdWJsZSBtZW1vcnkgY29zdCBwcm9ibGVtXG4gICAgICAgIG1lcmdlUGF0aDogZnVuY3Rpb24gKHBhdGhFbHMsIG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBwYXRoTGlzdCA9IFtdO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGhFbHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoRWwgPSBwYXRoRWxzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghcGF0aEVsLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aEVsLmNyZWF0ZVBhdGhQcm94eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGF0aEVsLl9fZGlydHlQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhFbC5idWlsZFBhdGgocGF0aEVsLnBhdGgsIHBhdGhFbC5zaGFwZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGhMaXN0LnB1c2gocGF0aEVsLnBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGF0aEJ1bmRsZSA9IG5ldyBQYXRoKG9wdHMpO1xuICAgICAgICAgICAgLy8gTmVlZCBwYXRoIHByb3h5LlxuICAgICAgICAgICAgcGF0aEJ1bmRsZS5jcmVhdGVQYXRoUHJveHkoKTtcbiAgICAgICAgICAgIHBhdGhCdW5kbGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmFwcGVuZFBhdGgocGF0aExpc3QpO1xuICAgICAgICAgICAgICAgIC8vIFN2ZyBhbmQgdm1sIHJlbmRlcmVyIGRvbid0IGhhdmUgY29udGV4dFxuICAgICAgICAgICAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gcGF0aEJ1bmRsZTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL3Rvb2wvcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFBhdGggZWxlbWVudFxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvUGF0aFxuICovXG5cblxuXG4gICAgdmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZSgnLi9EaXNwbGF5YWJsZScpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgUGF0aFByb3h5ID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKTtcbiAgICB2YXIgcGF0aENvbnRhaW4gPSByZXF1aXJlKCcuLi9jb250YWluL3BhdGgnKTtcblxuICAgIHZhciBQYXR0ZXJuID0gcmVxdWlyZSgnLi9QYXR0ZXJuJyk7XG4gICAgdmFyIGdldENhbnZhc1BhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuO1xuXG4gICAgdmFyIGFicyA9IE1hdGguYWJzO1xuXG4gICAgdmFyIHBhdGhQcm94eUZvckRyYXcgPSBuZXcgUGF0aFByb3h5KHRydWUpO1xuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGhcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXRoKG9wdHMpIHtcbiAgICAgICAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGF0aCA9IG51bGw7XG4gICAgfVxuXG4gICAgUGF0aC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFBhdGgsXG5cbiAgICAgICAgdHlwZTogJ3BhdGgnLFxuXG4gICAgICAgIF9fZGlydHlQYXRoOiB0cnVlLFxuXG4gICAgICAgIHN0cm9rZUNvbnRhaW5UaHJlc2hvbGQ6IDUsXG5cbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoIHx8IHBhdGhQcm94eUZvckRyYXc7XG4gICAgICAgICAgICB2YXIgaGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCk7XG4gICAgICAgICAgICB2YXIgaGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKTtcbiAgICAgICAgICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcbiAgICAgICAgICAgIHZhciBzdHJva2UgPSBzdHlsZS5zdHJva2U7XG4gICAgICAgICAgICB2YXIgaGFzRmlsbEdyYWRpZW50ID0gaGFzRmlsbCAmJiAhIShmaWxsLmNvbG9yU3RvcHMpO1xuICAgICAgICAgICAgdmFyIGhhc1N0cm9rZUdyYWRpZW50ID0gaGFzU3Ryb2tlICYmICEhKHN0cm9rZS5jb2xvclN0b3BzKTtcbiAgICAgICAgICAgIHZhciBoYXNGaWxsUGF0dGVybiA9IGhhc0ZpbGwgJiYgISEoZmlsbC5pbWFnZSk7XG4gICAgICAgICAgICB2YXIgaGFzU3Ryb2tlUGF0dGVybiA9IGhhc1N0cm9rZSAmJiAhIShzdHJva2UuaW1hZ2UpO1xuXG4gICAgICAgICAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdDtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZ3JhZGllbnQgYmVjYXVzZSBib3VuZGluZyByZWN0IG1heSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgaWYgKGhhc0ZpbGxHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0gcmVjdCB8fCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maWxsR3JhZGllbnQgPSBzdHlsZS5nZXRHcmFkaWVudChjdHgsIGZpbGwsIHJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzU3Ryb2tlR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHJlY3QgfHwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3Ryb2tlR3JhZGllbnQgPSBzdHlsZS5nZXRHcmFkaWVudChjdHgsIHN0cm9rZSwgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXNlIHRoZSBncmFkaWVudCBvciBwYXR0ZXJuXG4gICAgICAgICAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gUEVORElORyBJZiBtYXkgaGF2ZSBhZmZlY3QgdGhlIHN0YXRlXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2ZpbGxHcmFkaWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0ZpbGxQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdldENhbnZhc1BhdHRlcm4uY2FsbChmaWxsLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1N0cm9rZUdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlR3JhZGllbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNTdHJva2VQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZ2V0Q2FudmFzUGF0dGVybi5jYWxsKHN0cm9rZSwgY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gc3R5bGUubGluZURhc2g7XG4gICAgICAgICAgICB2YXIgbGluZURhc2hPZmZzZXQgPSBzdHlsZS5saW5lRGFzaE9mZnNldDtcblxuICAgICAgICAgICAgdmFyIGN0eExpbmVEYXNoID0gISFjdHguc2V0TGluZURhc2g7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwYXRoIHN4LCBzeVxuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRHbG9iYWxTY2FsZSgpO1xuICAgICAgICAgICAgcGF0aC5zZXRTY2FsZShzY2FsZVswXSwgc2NhbGVbMV0pO1xuXG4gICAgICAgICAgICAvLyBQcm94eSBjb250ZXh0XG4gICAgICAgICAgICAvLyBSZWJ1aWxkIHBhdGggaW4gZm9sbG93aW5nIDIgY2FzZXNcbiAgICAgICAgICAgIC8vIDEuIFBhdGggaXMgZGlydHlcbiAgICAgICAgICAgIC8vIDIuIFBhdGggbmVlZHMgamF2YXNjcmlwdCBpbXBsZW1lbnRlZCBsaW5lRGFzaCBzdHJva2luZy5cbiAgICAgICAgICAgIC8vICAgIEluIHRoaXMgY2FzZSwgbGluZURhc2ggaW5mb3JtYXRpb24gd2lsbCBub3QgYmUgc2F2ZWQgaW4gUGF0aFByb3h5XG4gICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5UGF0aFxuICAgICAgICAgICAgICAgIHx8IChsaW5lRGFzaCAmJiAhY3R4TGluZURhc2ggJiYgaGFzU3Ryb2tlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5iZWdpblBhdGgoY3R4KTtcblxuICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgbGluZSBkYXNoIGJlZm9yZSBidWlsZCBwYXRoXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVEYXNoICYmICFjdHhMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRMaW5lRGFzaE9mZnNldChsaW5lRGFzaE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgcGF0aCBkaXJ0eSBmbGFnXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGF5IHBhdGggYnVpbGRpbmdcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhc0ZpbGwgJiYgcGF0aC5maWxsKGN0eCk7XG5cbiAgICAgICAgICAgIGlmIChsaW5lRGFzaCAmJiBjdHhMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChsaW5lRGFzaCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhc1N0cm9rZSAmJiBwYXRoLnN0cm9rZShjdHgpO1xuXG4gICAgICAgICAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGxpbmVEYXNoXG4gICAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgIC8vIERyYXcgcmVjdCB0ZXh0XG4gICAgICAgICAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBXaGVuIGJ1bmRsaW5nIHBhdGgsIHNvbWUgc2hhcGUgbWF5IGRlY2lkZSBpZiB1c2UgbW92ZVRvIHRvIGJlZ2luIGEgbmV3IHN1YnBhdGggb3IgY2xvc2VQYXRoXG4gICAgICAgIC8vIExpa2UgaW4gY2lyY2xlXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGVDZmcsIGluQnVuZGxlKSB7fSxcblxuICAgICAgICBjcmVhdGVQYXRoUHJveHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5fcmVjdDtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgbmVlZHNVcGRhdGVSZWN0ID0gIXJlY3Q7XG4gICAgICAgICAgICBpZiAobmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBwYXRoIG9uIGRlbWFuZC5cbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuXG4gICAgICAgICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkcyB1cGRhdGUgcmVjdCB3aXRoIHN0cm9rZSBsaW5lV2lkdGggd2hlblxuICAgICAgICAgICAgICAgIC8vIDEuIEVsZW1lbnQgY2hhbmdlcyBzY2FsZSBvciBsaW5lV2lkdGhcbiAgICAgICAgICAgICAgICAvLyAyLiBTaGFwZSBpcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgdmFyIHJlY3RXaXRoU3Ryb2tlID0gdGhpcy5fcmVjdFdpdGhTdHJva2UgfHwgKHRoaXMuX3JlY3RXaXRoU3Ryb2tlID0gcmVjdC5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5IHx8IG5lZWRzVXBkYXRlUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS5jb3B5KHJlY3QpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBNdXN0IGFmdGVyIHVwZGF0ZVRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUEVORElORywgTWluIGxpbmUgd2lkdGggaXMgbmVlZGVkIHdoZW4gbGluZSBpcyBob3Jpem9udGFsIG9yIHZlcnRpY2FsXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhZGQgZXh0cmEgaG92ZXIgbGluZVdpZHRoIHdoZW4gdGhlcmUgYXJlIG5vIGZpbGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSBNYXRoLm1heCh3LCB0aGlzLnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQgfHwgNCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgbGluZSB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIHNjYWxlIGNhbid0IGJlIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2Uud2lkdGggKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLmhlaWdodCArPSB3IC8gbGluZVNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2UueCAtPSB3IC8gbGluZVNjYWxlIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnkgLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gcmVjdCB3aXRoIHN0cm9rZVxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0V2l0aFN0cm9rZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbFBvcyA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHggPSBsb2NhbFBvc1swXTtcbiAgICAgICAgICAgIHkgPSBsb2NhbFBvc1sxXTtcblxuICAgICAgICAgICAgaWYgKHJlY3QuY29udGFpbih4LCB5KSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMucGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVNjYWxlID0gc3R5bGUuc3Ryb2tlTm9TY2FsZSA/IHRoaXMuZ2V0TGluZVNjYWxlKCkgOiAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIHNjYWxlIGNhbid0IGJlIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhZGQgZXh0cmEgaG92ZXIgbGluZVdpZHRoIHdoZW4gdGhlcmUgYXJlIG5vIGZpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoID0gTWF0aC5tYXgobGluZVdpZHRoLCB0aGlzLnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhDb250YWluLmNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aERhdGEsIGxpbmVXaWR0aCAvIGxpbmVTY2FsZSwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhDb250YWluLmNvbnRhaW4ocGF0aERhdGEsIHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gZGlydHlQYXRoXG4gICAgICAgICAqL1xuICAgICAgICBkaXJ0eTogZnVuY3Rpb24gKGRpcnR5UGF0aCkge1xuICAgICAgICAgICAgaWYgKGRpcnR5UGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlydHlQYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgbWFyayBkaXJ0eSwgbm90IG1hcmsgY2xlYW5cbiAgICAgICAgICAgIGlmIChkaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZGlydHlQYXRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcblxuICAgICAgICAgICAgLy8gVXNlZCBhcyBhIGNsaXBwaW5nIHBhdGhcbiAgICAgICAgICAgIGlmICh0aGlzLl9fY2xpcFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19jbGlwVGFyZ2V0LmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWFzIGZvciBhbmltYXRlKCdzaGFwZScpXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0ZVNoYXBlOiBmdW5jdGlvbiAobG9vcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgnc2hhcGUnLCBsb29wKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBPdmVyd3JpdGUgYXR0cktWXG4gICAgICAgIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnc2hhcGUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBEaXNwbGF5YWJsZS5wcm90b3R5cGUuYXR0cktWLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIHNldFNoYXBlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgIC8vIFBhdGggZnJvbSBzdHJpbmcgbWF5IG5vdCBoYXZlIHNoYXBlXG4gICAgICAgICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoenJVdGlsLmlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZVtuYW1lXSA9IGtleVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGluZVNjYWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBsaW5lIHNjYWxlLlxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5hbnQgb2YgYG1gIG1lYW5zIGhvdyBtdWNoIHRoZSBhcmVhIGlzIGVubGFyZ2VkIGJ5IHRoZVxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgICAgICAgICAgLy8gZm9yIHdpZHRoLlxuICAgICAgICAgICAgcmV0dXJuIG0gJiYgYWJzKG1bMF0gLSAxKSA+IDFlLTEwICYmIGFicyhtWzNdIC0gMSkgPiAxZS0xMFxuICAgICAgICAgICAgICAgID8gTWF0aC5zcXJ0KGFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKSlcbiAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5omp5bGV5LiA5LiqIFBhdGggZWxlbWVudCwg5q+U5aaC5pif5b2i77yM5ZyG562J44CCXG4gICAgICogRXh0ZW5kIGEgcGF0aCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BzLnR5cGUgUGF0aCB0eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuaW5pdCBJbml0aWFsaXplXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuYnVpbGRQYXRoIE92ZXJ3cml0ZSBidWlsZFBhdGggbWV0aG9kXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5zdHlsZV0gRXh0ZW5kZWQgZGVmYXVsdCBzdHlsZSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnNoYXBlXSBFeHRlbmRlZCBkZWZhdWx0IHNoYXBlIGNvbmZpZ1xuICAgICAqL1xuICAgIFBhdGguZXh0ZW5kID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBTdWIgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgUGF0aC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgICAgICBpZiAoZGVmYXVsdHMuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRlbmQgZGVmYXVsdCBzdHlsZVxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuZXh0ZW5kRnJvbShkZWZhdWx0cy5zdHlsZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFeHRlbmQgZGVmYXVsdCBzaGFwZVxuICAgICAgICAgICAgdmFyIGRlZmF1bHRTaGFwZSA9IGRlZmF1bHRzLnNoYXBlO1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRTaGFwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSB0aGlzLnNoYXBlIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciB0aGlzU2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdFNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICEgdGhpc1NoYXBlLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBkZWZhdWx0U2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzU2hhcGVbbmFtZV0gPSBkZWZhdWx0U2hhcGVbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHRzLmluaXQgJiYgZGVmYXVsdHMuaW5pdC5jYWxsKHRoaXMsIG9wdHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHpyVXRpbC5pbmhlcml0cyhTdWIsIFBhdGgpO1xuXG4gICAgICAgIC8vIEZJWE1FIOS4jeiDvSBleHRlbmQgcG9zaXRpb24sIHJvdGF0aW9uIOetieW8leeUqOWvueixoVxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICAvLyBFeHRlbmRpbmcgcHJvdG90eXBlIHZhbHVlcyBhbmQgbWV0aG9kc1xuICAgICAgICAgICAgaWYgKG5hbWUgIT09ICdzdHlsZScgJiYgbmFtZSAhPT0gJ3NoYXBlJykge1xuICAgICAgICAgICAgICAgIFN1Yi5wcm90b3R5cGVbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBTdWI7XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhQYXRoLCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhdGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIOWPr+e7mOWItueahOWbvuW9ouWfuuexu1xuICogQmFzZSBjbGFzcyBvZiBhbGwgZGlzcGxheWFibGUgZ3JhcGhpYyBvYmplY3RzXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICovXG5cblxuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIFN0eWxlID0gcmVxdWlyZSgnLi9TdHlsZScpO1xuXG4gICAgdmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuLi9FbGVtZW50Jyk7XG4gICAgdmFyIFJlY3RUZXh0ID0gcmVxdWlyZSgnLi9taXhpbi9SZWN0VGV4dCcpO1xuICAgIC8vIHZhciBTdGF0ZWZ1bCA9IHJlcXVpcmUoJy4vbWl4aW4vU3RhdGVmdWwnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvbWl4aW4vUmVjdFRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEaXNwbGF5YWJsZShvcHRzKSB7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgRWxlbWVudC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIC8vIEV4dGVuZCBwcm9wZXJ0aWVzXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gb3B0cykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG9wdHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICAgICAgICBuYW1lICE9PSAnc3R5bGUnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gb3B0c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob3B0cy5zdHlsZSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgICAgIC8vIFNoYXBlcyBmb3IgY2FzY2FkZSBjbGlwcGluZy5cbiAgICAgICAgdGhpcy5fX2NsaXBQYXRocyA9IFtdO1xuXG4gICAgICAgIC8vIEZJWE1FIFN0YXRlZnVsIG11c3QgYmUgbWl4aW5lZCBhZnRlciBzdHlsZSBpcyBzZXR0ZWRcbiAgICAgICAgLy8gU3RhdGVmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB9XG5cbiAgICBEaXNwbGF5YWJsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IERpc3BsYXlhYmxlLFxuXG4gICAgICAgIHR5cGU6ICdkaXNwbGF5YWJsZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXlhYmxlIOaYr+WQpuS4uuiEj++8jFBhaW50ZXIg5Lit5Lya5qC55o2u6K+l5qCH6K6w5Yik5pat5piv5ZCm6ZyA6KaB5piv5ZCm6ZyA6KaB6YeN5paw57uY5Yi2XG4gICAgICAgICAqIERpcnR5IGZsYWcuIEZyb20gd2hpY2ggcGFpbnRlciB3aWxsIGRldGVybWluZSBpZiB0aGlzIGRpc3BsYXlhYmxlIG9iamVjdCBuZWVkcyBicnVzaFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI19fZGlydHlcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfX2RpcnR5OiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlm77lvaLmmK/lkKblj6/op4HvvIzkuLp0cnVl5pe25LiN57uY5Yi25Zu+5b2i77yM5L2G5piv5LuN6IO96Kem5Y+R6byg5qCH5LqL5Lu2XG4gICAgICAgICAqIElmIGlnbm9yZSBkcmF3aW5nIG9mIHRoZSBkaXNwbGF5YWJsZSBvYmplY3QuIE1vdXNlIGV2ZW50IHdpbGwgc3RpbGwgYmUgdHJpZ2dlcmVkXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2ludmlzaWJsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGludmlzaWJsZTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgejogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjelxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB6MjogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogeuWxgmxldmVs77yM5Yaz5a6a57uY55S75Zyo5ZOq5bGCY2FudmFz5LitXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3psZXZlbFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB6bGV2ZWw6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpuWPr+aLluaLvVxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNkcmFnZ2FibGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbmraPlnKjmi5bmi71cbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbnm7jlupTpvKDmoIfkuovku7ZcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjc2lsZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lsZW50OiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZW5hYmxlIGN1bGxpbmdcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBjdWxsaW5nOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW91c2UgY3Vyc29yIHdoZW4gaG92ZXJlZFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNjdXJzb3JcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBob3ZlciBhcmVhIGlzIGJvdW5kaW5nIHJlY3RcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjcmVjdEhvdmVyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICByZWN0SG92ZXI6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIGVsZW1lbnQgcHJvZ3Jlc3NpdmVseSB3aGVuIHRoZSB2YWx1ZSA+PSAwLFxuICAgICAgICAgKiB1c2VmdWxsIGZvciBsYXJnZSBkYXRhLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvZ3Jlc3NpdmU6IC0xLFxuXG4gICAgICAgIGJlZm9yZUJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcblxuICAgICAgICBhZnRlckJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i57uY5Yi25pa55rOVXG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAgICovXG4gICAgICAgIC8vIEludGVyZmFjZVxuICAgICAgICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5pyA5bCP5YyF5Zu055uSXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gSW50ZXJmYWNlXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIpOaWreWdkOaghyB4LCB5IOaYr+WQpuWcqOWbvuW9ouS4ilxuICAgICAgICAgKiBJZiBkaXNwbGF5YWJsZSBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjdENvbnRhaW4oeCwgeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yik5pat5Z2Q5qCHIHgsIHkg5piv5ZCm5Zyo5Zu+5b2i55qE5YyF5Zu055uS5LiKXG4gICAgICAgICAqIElmIGJvdW5kaW5nIHJlY3Qgb2YgZWxlbWVudCBjb250YWluIGNvb3JkIHgsIHlcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgcmVjdENvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgY29vcmQgPSB0aGlzLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCh4LCB5KTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0LmNvbnRhaW4oY29vcmRbMF0sIGNvb3JkWzFdKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5qCH6K6w5Zu+5b2i5YWD57Sg5Li66ISP77yM5bm25LiU5Zyo5LiL5LiA5bin6YeN57uYXG4gICAgICAgICAqIE1hcmsgZGlzcGxheWFibGUgZWxlbWVudCBkaXJ0eSBhbmQgcmVmcmVzaCBuZXh0IGZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICBkaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG5cbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlm77lvaLmmK/lkKbkvJrop6blj5Hkuovku7ZcbiAgICAgICAgICogSWYgZGlzcGxheWFibGUgb2JqZWN0IGJpbmRlZCBhbnkgZXZlbnRcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE8sIOmAmui/hyBiaW5kIOe7keWumueahOS6i+S7tlxuICAgICAgICAvLyBpc1NpbGVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAgICAgcmV0dXJuICEoXG4gICAgICAgIC8vICAgICAgICAgdGhpcy5ob3ZlcmFibGUgfHwgdGhpcy5kcmFnZ2FibGVcbiAgICAgICAgLy8gICAgICAgICB8fCB0aGlzLm9ubW91c2Vtb3ZlIHx8IHRoaXMub25tb3VzZW92ZXIgfHwgdGhpcy5vbm1vdXNlb3V0XG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlZG93biB8fCB0aGlzLm9ubW91c2V1cCB8fCB0aGlzLm9uY2xpY2tcbiAgICAgICAgLy8gICAgICAgICB8fCB0aGlzLm9uZHJhZ2VudGVyIHx8IHRoaXMub25kcmFnb3ZlciB8fCB0aGlzLm9uZHJhZ2xlYXZlXG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbmRyb3BcbiAgICAgICAgLy8gICAgICk7XG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc3R5bGUnKVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGVTdHlsZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoJ3N0eWxlJywgbG9vcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgIEVsZW1lbnQucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5zZXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBzZXRTdHlsZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIGdpdmVuIHN0eWxlIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9ialxuICAgICAgICAgKi9cbiAgICAgICAgdXNlU3R5bGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUob2JqLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKERpc3BsYXlhYmxlLCBFbGVtZW50KTtcblxuICAgIHpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgUmVjdFRleHQpO1xuICAgIC8vIHpyVXRpbC5taXhpbihEaXNwbGF5YWJsZSwgU3RhdGVmdWwpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEaXNwbGF5YWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL1N0eWxlXG4gKi9cblxuXG4gICAgdmFyIFNUWUxFX0NPTU1PTl9QUk9QUyA9IFtcbiAgICAgICAgWydzaGFkb3dCbHVyJywgMF0sIFsnc2hhZG93T2Zmc2V0WCcsIDBdLCBbJ3NoYWRvd09mZnNldFknLCAwXSwgWydzaGFkb3dDb2xvcicsICcjMDAwJ10sXG4gICAgICAgIFsnbGluZUNhcCcsICdidXR0J10sIFsnbGluZUpvaW4nLCAnbWl0ZXInXSwgWydtaXRlckxpbWl0JywgMTBdXG4gICAgXTtcblxuICAgIC8vIHZhciBTSEFET1dfUFJPUFMgPSBTVFlMRV9DT01NT05fUFJPUFMuc2xpY2UoMCwgNCk7XG4gICAgLy8gdmFyIExJTkVfUFJPUFMgPSBTVFlMRV9DT01NT05fUFJPUFMuc2xpY2UoNCk7XG5cbiAgICB2YXIgU3R5bGUgPSBmdW5jdGlvbiAob3B0cywgaG9zdCkge1xuICAgICAgICB0aGlzLmV4dGVuZEZyb20ob3B0cywgZmFsc2UpO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMaW5lYXJHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICAgICAgICB2YXIgeCA9IG9iai54ID09IG51bGwgPyAwIDogb2JqLng7XG4gICAgICAgIHZhciB4MiA9IG9iai54MiA9PSBudWxsID8gMSA6IG9iai54MjtcbiAgICAgICAgdmFyIHkgPSBvYmoueSA9PSBudWxsID8gMCA6IG9iai55O1xuICAgICAgICB2YXIgeTIgPSBvYmoueTIgPT0gbnVsbCA/IDAgOiBvYmoueTI7XG5cbiAgICAgICAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgICAgICAgICB4ID0geCAqIHJlY3Qud2lkdGggKyByZWN0Lng7XG4gICAgICAgICAgICB4MiA9IHgyICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICAgICAgICAgIHkgPSB5ICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgICAgICB5MiA9IHkyICogcmVjdC5oZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeDIsIHkyKTtcblxuICAgICAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmFkaWFsR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgdmFyIHggPSBvYmoueCA9PSBudWxsID8gMC41IDogb2JqLng7XG4gICAgICAgIHZhciB5ID0gb2JqLnkgPT0gbnVsbCA/IDAuNSA6IG9iai55O1xuICAgICAgICB2YXIgciA9IG9iai5yID09IG51bGwgPyAwLjUgOiBvYmoucjtcbiAgICAgICAgaWYgKCFvYmouZ2xvYmFsKSB7XG4gICAgICAgICAgICB4ID0geCAqIHdpZHRoICsgcmVjdC54O1xuICAgICAgICAgICAgeSA9IHkgKiBoZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgICAgICByID0gciAqIG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4LCB5LCAwLCB4LCB5LCByKTtcblxuICAgICAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gICAgfVxuXG5cbiAgICBTdHlsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFN0eWxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZX1cbiAgICAgICAgICovXG4gICAgICAgIGhvc3Q6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBmaWxsOiAnIzAwMCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBzdHJva2U6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBvcGFjaXR5OiAxLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBsaW5lRGFzaDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2hhZG93Qmx1cjogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNoYWRvd09mZnNldFg6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBzaGFkb3dPZmZzZXRZOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbGluZVdpZHRoOiAxLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzdHJva2UgaWdub3JlIHNjYWxlXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgc3Ryb2tlTm9TY2FsZTogZmFsc2UsXG5cbiAgICAgICAgLy8gQm91bmRpbmcgcmVjdCB0ZXh0IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgLy8gTm90IGFmZmVjdGVkIGJ5IGVsZW1lbnQgdHJhbnNmb3JtXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYGZvbnRTaXplYCBvciBgZm9udEZhbWlseWAgZXhpc3RzLCBgZm9udGAgd2lsbCBiZSByZXNldCBieVxuICAgICAgICAgKiBgZm9udFNpemVgLCBgZm9udFN0eWxlYCwgYGZvbnRXZWlnaHRgLCBgZm9udEZhbWlseWAuXG4gICAgICAgICAqIFNvIGRvIG5vdCB2aXNpdCBpdCBkaXJlY3RseSBpbiB1cHBlciBhcHBsaWNhdGlvbiAobGlrZSBlY2hhcnRzKSxcbiAgICAgICAgICogYnV0IHVzZSBgY29udGFpbi90ZXh0I21ha2VGb250YCBpbnN0ZWFkLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZm9udDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNhbWUgYXMgZm9udC4gVXNlIGZvbnQgcGxlYXNlLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dEZvbnQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0IGhlbHBzIG1lcmdpbmcgcmVzcGVjdGl2ZWx5LCByYXRoZXIgdGhhbiBwYXJzaW5nIGFuIGVudGlyZSBmb250IHN0cmluZy5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGZvbnRTdHlsZTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZm9udFdlaWdodDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgICAgICAgKiBTaG91bGQgYmUgMTIgYnV0IG5vdCAnMTJweCcuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBmb250U2l6ZTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZm9udEZhbWlseTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXJ2ZWQgZm9yIHNwZWNpYWwgZnVuY3RpbmFsaXR5LCBsaWtlICdocicuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0VGFnOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dEZpbGw6ICcjMDAwJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHRTdHJva2U6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0V2lkdGg6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgZm9yIHRleHRCYWNrZ3JvdW5kLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dEhlaWdodDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogdGV4dFN0cm9rZSBtYXkgYmUgc2V0IGFzIHNvbWUgY29sb3IgYXMgYSBkZWZhdWx0XG4gICAgICAgICAqIHZhbHVlIGluIHVwcGVyIGFwcGxpY2Fpb24sIHdoZXJlIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICAgICAqIG9mIHRleHRTdHJva2VXaWR0aCBzaG91bGQgYmUgMCB0byBtYWtlIHN1cmUgdGhhdFxuICAgICAgICAgKiB1c2VyIGNhbiBjaG9vc2UgdG8gZG8gbm90IHVzZSB0ZXh0IHN0cm9rZS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRTdHJva2VXaWR0aDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRMaW5lSGVpZ2h0OiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAnaW5zaWRlJywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSdcbiAgICAgICAgICogW3gsIHldXG4gICAgICAgICAqIEJhc2VkIG9uIHgsIHkgb2YgcmVjdC5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ3xBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQGRlZmF1bHQgJ2luc2lkZSdcbiAgICAgICAgICovXG4gICAgICAgIHRleHRQb3NpdGlvbjogJ2luc2lkZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG5vdCBzcGVjaWZpZWQsIHVzZSB0aGUgYm91bmRpbmdSZWN0IG9mIGEgYGRpc3BsYXlhYmxlYC5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRSZWN0OiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBbeCwgeV1cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dE9mZnNldDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHRBbGlnbjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dERpc3RhbmNlOiA1LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFNoYWRvd0JsdXI6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0U2hhZG93T2Zmc2V0WDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRTaGFkb3dPZmZzZXRZOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dEJveFNoYWRvd0NvbG9yOiAndHJhbnNwYXJlbnQnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dEJveFNoYWRvd0JsdXI6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0Qm94U2hhZG93T2Zmc2V0WDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRCb3hTaGFkb3dPZmZzZXRZOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRyYW5zZm9ybSB0ZXh0LlxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNmb3JtVGV4dDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRleHQgcm90YXRlIGFyb3VuZCBwb3NpdGlvbiBvZiBQYXRoIG9yIEltYWdlXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnQgYW5kIHRyYW5zZm9ybVRleHQgaXMgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0Um90YXRpb246IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRleHQgb3JpZ2luIG9mIHRleHQgcm90YXRpb24sIGxpa2UgWzEwLCA0MF0uXG4gICAgICAgICAqIEJhc2VkIG9uIHgsIHkgb2YgcmVjdC5cbiAgICAgICAgICogVXNlZnVsIGluIGxhYmVsIHJvdGF0aW9uIG9mIGNpcmN1bGFyIHN5bWJvbC5cbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhpcyBvcmlnaW4gaXMgdGV4dFBvc2l0aW9uLlxuICAgICAgICAgKiBDYW4gYmUgJ2NlbnRlcicuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0T3JpZ2luOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dEJhY2tncm91bmRDb2xvcjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHRCb3JkZXJDb2xvcjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRCb3JkZXJXaWR0aDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRCb3JkZXJSYWRpdXM6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbiBiZSBgMmAgb3IgYFsyLCA0XWAgb3IgYFsyLCAzLCA0LCA1XWBcbiAgICAgICAgICogQHR5cGUge251bWJlcnxBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRQYWRkaW5nOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXh0IHN0eWxlcyBmb3IgcmljaCB0ZXh0LlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgcmljaDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICoge291dGVyV2lkdGgsIG91dGVySGVpZ2h0LCBlbGxpcHNpcywgcGxhY2Vob2xkZXJ9XG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0cnVuY2F0ZTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9nbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGJsZW5kOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICAgICAqL1xuICAgICAgICBiaW5kOiBmdW5jdGlvbiAoY3R4LCBlbCwgcHJldkVsKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHByZXZTdHlsZSA9IHByZXZFbCAmJiBwcmV2RWwuc3R5bGU7XG4gICAgICAgICAgICB2YXIgZmlyc3REcmF3ID0gIXByZXZTdHlsZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTVFlMRV9DT01NT05fUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IFNUWUxFX0NPTU1PTl9QUk9QU1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVOYW1lID0gcHJvcFswXTtcblxuICAgICAgICAgICAgICAgIGlmIChmaXJzdERyYXcgfHwgc3R5bGVbc3R5bGVOYW1lXSAhPT0gcHJldlN0eWxlW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgSW52YWxpZCBwcm9wZXJ0eSB2YWx1ZSB3aWxsIGNhdXNlIHN0eWxlIGxlYWsgZnJvbSBwcmV2aW91cyBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBjdHhbc3R5bGVOYW1lXSA9IHN0eWxlW3N0eWxlTmFtZV0gfHwgcHJvcFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgoZmlyc3REcmF3IHx8IHN0eWxlLmZpbGwgIT09IHByZXZTdHlsZS5maWxsKSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5maWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChmaXJzdERyYXcgfHwgc3R5bGUuc3Ryb2tlICE9PSBwcmV2U3R5bGUuc3Ryb2tlKSkge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLnN0cm9rZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZmlyc3REcmF3IHx8IHN0eWxlLm9wYWNpdHkgIT09IHByZXZTdHlsZS5vcGFjaXR5KSkge1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHN0eWxlLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBzdHlsZS5vcGFjaXR5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGZpcnN0RHJhdyB8fCBzdHlsZS5ibGVuZCAhPT0gcHJldlN0eWxlLmJsZW5kKSkge1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBzdHlsZS5ibGVuZCB8fCAnc291cmNlLW92ZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGggLyAoXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnN0cm9rZU5vU2NhbGUgJiYgZWwgJiYgZWwuZ2V0TGluZVNjYWxlKSA/IGVsLmdldExpbmVTY2FsZSgpIDogMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzRmlsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZpbGwgPSB0aGlzLmZpbGw7XG4gICAgICAgICAgICByZXR1cm4gZmlsbCAhPSBudWxsICYmIGZpbGwgIT09ICdub25lJztcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNTdHJva2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHJva2UgPSB0aGlzLnN0cm9rZTtcbiAgICAgICAgICAgIHJldHVybiBzdHJva2UgIT0gbnVsbCAmJiBzdHJva2UgIT09ICdub25lJyAmJiB0aGlzLmxpbmVXaWR0aCA+IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4dGVuZCBmcm9tIG90aGVyIHN0eWxlXG4gICAgICAgICAqIEBwYXJhbSB7enJlbmRlci9ncmFwaGljL1N0eWxlfSBvdGhlclN0eWxlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcndyaXRlIHRydWU6IG92ZXJ3cmlydGUgYW55IHdheS5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2U6IG92ZXJ3cml0ZSBvbmx5IHdoZW4gIXRhcmdldC5oYXNPd25Qcm9wZXJ0eVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlcnM6IG92ZXJ3cml0ZSB3aGVuIHByb3BlcnR5IGlzIG5vdCBudWxsL3VuZGVmaW5lZC5cbiAgICAgICAgICovXG4gICAgICAgIGV4dGVuZEZyb206IGZ1bmN0aW9uIChvdGhlclN0eWxlLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgICAgIGlmIChvdGhlclN0eWxlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvdGhlclN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdGhlclN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAob3ZlcndyaXRlID09PSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyd3JpdGUgPT09IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICF0aGlzLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG90aGVyU3R5bGVbbmFtZV0gIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gb3RoZXJTdHlsZVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQmF0Y2ggc2V0dGluZyBzdHlsZSB3aXRoIGEgZ2l2ZW4gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gb2JqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29ial1cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG9iaiwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXNbb2JqXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRGcm9tKG9iaiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb25lXG4gICAgICAgICAqIEByZXR1cm4ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdTdHlsZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgICBuZXdTdHlsZS5leHRlbmRGcm9tKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1N0eWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEdyYWRpZW50OiBmdW5jdGlvbiAoY3R4LCBvYmosIHJlY3QpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBvYmoudHlwZSA9PT0gJ3JhZGlhbCcgPyBjcmVhdGVSYWRpYWxHcmFkaWVudCA6IGNyZWF0ZUxpbmVhckdyYWRpZW50O1xuICAgICAgICAgICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gbWV0aG9kKGN0eCwgb2JqLCByZWN0KTtcbiAgICAgICAgICAgIHZhciBjb2xvclN0b3BzID0gb2JqLmNvbG9yU3RvcHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yU3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3AoXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yU3RvcHNbaV0ub2Zmc2V0LCBjb2xvclN0b3BzW2ldLmNvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW52YXNHcmFkaWVudDtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHZhciBzdHlsZVByb3RvID0gU3R5bGUucHJvdG90eXBlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgU1RZTEVfQ09NTU9OX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gU1RZTEVfQ09NTU9OX1BST1BTW2ldO1xuICAgICAgICBpZiAoIShwcm9wWzBdIGluIHN0eWxlUHJvdG8pKSB7XG4gICAgICAgICAgICBzdHlsZVByb3RvW3Byb3BbMF1dID0gcHJvcFsxXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb3ZpZGUgZm9yIG90aGVyc1xuICAgIFN0eWxlLmdldEdyYWRpZW50ID0gc3R5bGVQcm90by5nZXRHcmFkaWVudDtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gU3R5bGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvU3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvRWxlbWVudFxuICovXG5cblxuICAgIHZhciBndWlkID0gcmVxdWlyZSgnLi9jb3JlL2d1aWQnKTtcbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuL21peGluL0V2ZW50ZnVsJyk7XG4gICAgdmFyIFRyYW5zZm9ybWFibGUgPSByZXF1aXJlKCcuL21peGluL1RyYW5zZm9ybWFibGUnKTtcbiAgICB2YXIgQW5pbWF0YWJsZSA9IHJlcXVpcmUoJy4vbWl4aW4vQW5pbWF0YWJsZScpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZX1cbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZX1cbiAgICAgKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWx9XG4gICAgICovXG4gICAgdmFyIEVsZW1lbnQgPSBmdW5jdGlvbiAob3B0cykge1xuXG4gICAgICAgIFRyYW5zZm9ybWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgQW5pbWF0YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnlLvluIPlhYPntKBJRFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG9wdHMuaWQgfHwgZ3VpZCgpO1xuICAgIH07XG5cbiAgICBFbGVtZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICog5YWD57Sg57G75Z6LXG4gICAgICAgICAqIEVsZW1lbnQgdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2VsZW1lbnQnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlhYPntKDlkI3lrZdcbiAgICAgICAgICogRWxlbWVudCBuYW1lXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBuYW1lOiAnJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogWlJlbmRlciDlrp7kvovlr7nosaHvvIzkvJrlnKggZWxlbWVudCDmt7vliqDliLAgenJlbmRlciDlrp7kvovkuK3lkI7oh6rliqjotYvlgLxcbiAgICAgICAgICogWlJlbmRlciBpbnN0YW5jZSB3aWxsIGJlIGFzc2lnbmVkIHdoZW4gZWxlbWVudCBpcyBhc3NvY2lhdGVkIHdpdGggenJlbmRlclxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNfX3pyXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX196cjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i5piv5ZCm5b+955Wl77yM5Li6dHJ1ZeaXtuW/veeVpeWbvuW9oueahOe7mOWItuS7peWPiuS6i+S7tuinpuWPkVxuICAgICAgICAgKiBJZiBpZ25vcmUgZHJhd2luZyBhbmQgZXZlbnRzIG9mIHRoZSBlbGVtZW50IG9iamVjdFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNpZ25vcmVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpZ25vcmU6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnlKjkuo7oo4HliarnmoTot6/lvoQoc2hhcGUp77yM5omA5pyJIEdyb3VwIOWGheeahOi3r+W+hOWcqOe7mOWItuaXtumDveS8muiiq+i/meS4qui3r+W+hOijgeWJqlxuICAgICAgICAgKiDor6Xot6/lvoTkvJrnu6fmib/ooqvoo4Hlh4/lr7nosaHnmoTlj5jmjaJcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH1cbiAgICAgICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvI2NsaXBwaW5nLXJlZ2lvblxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIGNsaXBQYXRoOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmlmdCBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gZHggZHggb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR5IGR5IG9uIHRoZSBnbG9iYWwgc3BhY2VcbiAgICAgICAgICovXG4gICAgICAgIGRyaWZ0OiBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICAgICAgICAgICAgICAgIGR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgICAgICAgICAgICBkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgbSA9IHRoaXMudHJhbnNmb3JtID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbVs0XSArPSBkeDtcbiAgICAgICAgICAgIG1bNV0gKz0gZHk7XG5cbiAgICAgICAgICAgIHRoaXMuZGVjb21wb3NlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSG9vayBiZWZvcmUgdXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSG9vayBhZnRlciB1cGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyVXBkYXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBlYWNoIGZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicgfHwga2V5ID09PSAnc2NhbGUnIHx8IGtleSA9PT0gJ29yaWdpbicpIHtcbiAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBhcnJheVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpc1trZXldID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WzBdID0gdmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFsxXSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIHRoZSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pZ25vcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBhdHRyOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyS1Yoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cktWKG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGNsaXBQYXRoXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDbGlwUGF0aDogZnVuY3Rpb24gKGNsaXBQYXRoKSB7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgICAgICAgICBpZiAoenIpIHtcbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBjbGlwIHBhdGhcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBQYXRoICYmIHRoaXMuY2xpcFBhdGggIT09IGNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDbGlwUGF0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNsaXBQYXRoID0gY2xpcFBhdGg7XG4gICAgICAgICAgICBjbGlwUGF0aC5fX3pyID0genI7XG4gICAgICAgICAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNsaXBQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsaXBQYXRoLl9fenIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcFBhdGgucmVtb3ZlU2VsZkZyb21acihjbGlwUGF0aC5fX3pyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5fX3pyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpcFBhdGggPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICAgICAgICogTm90IHJlY3Vyc2l2ZWx5IGJlY2F1c2UgaXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWxlbWVudCBhZGRlZCB0byBzdG9yYWdlLlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAgICAgICAqL1xuICAgICAgICBhZGRTZWxmVG9acjogZnVuY3Rpb24gKHpyKSB7XG4gICAgICAgICAgICB0aGlzLl9fenIgPSB6cjtcbiAgICAgICAgICAgIC8vIOa3u+WKoOWKqOeUu1xuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgICAgICAgICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHpyLmFuaW1hdGlvbi5hZGRBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHNlbGYgZnJvbSB6cmVuZGVyIGluc3RhbmNlLlxuICAgICAgICAgKiBOb3QgcmVjdXJzaXZlbHkgYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgd2hlbiBlbGVtZW50IGFkZGVkIHRvIHN0b3JhZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn0genJcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZVNlbGZGcm9tWnI6IGZ1bmN0aW9uICh6cikge1xuICAgICAgICAgICAgdGhpcy5fX3pyID0gbnVsbDtcbiAgICAgICAgICAgIC8vIOenu+mZpOWKqOeUu1xuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgICAgICAgICAgaWYgKGFuaW1hdG9ycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHpyLmFuaW1hdGlvbi5yZW1vdmVBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoenIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5taXhpbihFbGVtZW50LCBBbmltYXRhYmxlKTtcbiAgICB6clV0aWwubWl4aW4oRWxlbWVudCwgVHJhbnNmb3JtYWJsZSk7XG4gICAgenJVdGlsLm1peGluKEVsZW1lbnQsIEV2ZW50ZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gRWxlbWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvRWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiB6cmVuZGVyOiDnlJ/miJDllK/kuIBpZFxuICpcbiAqIEBhdXRob3IgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgaWRTdGFydCA9IDB4MDkwNztcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaWRTdGFydCsrO1xuICAgIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvY29yZS9ndWlkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIOS6i+S7tuaJqeWxlVxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cblxuICAgIHZhciBhcnJ5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgICAvKipcbiAgICAgKiDkuovku7bliIblj5HlmahcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgRXZlbnRmdWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuXyRoYW5kbGVycyA9IHt9O1xuICAgIH07XG5cbiAgICBFdmVudGZ1bC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEV2ZW50ZnVsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDljZXmrKHop6blj5Hnu5HlrprvvIx0cmlnZ2Vy5ZCO6ZSA5q+BXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDlk43lupTlh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIG9uZTogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICAgICAgICAgIGlmICghaGFuZGxlciB8fCAhZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFfaFtldmVudF0pIHtcbiAgICAgICAgICAgICAgICBfaFtldmVudF0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaFtldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgaDogaGFuZGxlcixcbiAgICAgICAgICAgICAgICBvbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgY3R4OiBjb250ZXh0IHx8IHRoaXNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog57uR5a6a5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDkuovku7blpITnkIblh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICAgICAgICAgKi9cbiAgICAgICAgb246IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIgfHwgIWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghX2hbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgX2hbZXZlbnRdID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2hbZXZlbnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9oW2V2ZW50XVtpXS5oID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2hbZXZlbnRdLnB1c2goe1xuICAgICAgICAgICAgICAgIGg6IGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjdHg6IGNvbnRleHQgfHwgdGhpc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbnu5Hlrprkuobkuovku7ZcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSAgZXZlbnRcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGlzU2lsZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcbiAgICAgICAgICAgIHJldHVybiBfaFtldmVudF0gJiYgX2hbZXZlbnRdLmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6Kej57uR5LqL5Lu2XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCDkuovku7blkI1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAgICAgKi9cbiAgICAgICAgb2ZmOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgICAgICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuXyRoYW5kbGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBfaFtldmVudF0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldWydoJ10gIT0gaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xpc3QucHVzaChfaFtldmVudF1baV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9oW2V2ZW50XSA9IG5ld0xpc3Q7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfaFtldmVudF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS6i+S7tuWIhuWPkVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fJGhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ0xlbiA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ0xlbiA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFycnlTbGljZS5jYWxsKGFyZ3MsIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gX2gubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBhZHZpc2UgZnJvbSBiYWNrYm9uZVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGFyZ0xlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChfaFtpXVsnY3R4J10sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXZlIG1vcmUgdGhhbiAyIGdpdmVuIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uYXBwbHkoX2hbaV1bJ2N0eCddLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaFtpXVsnb25lJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5bim5pyJY29udGV4dOeahOS6i+S7tuWIhuWPkSwg5pyA5ZCO5LiA5Liq5Y+C5pWw5piv5LqL5Lu25Zue6LCD55qEY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXJXaXRoQ29udGV4dDogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl8kaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnTGVuID4gNCkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSwgYXJncy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gX2gubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBhZHZpc2UgZnJvbSBiYWNrYm9uZVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGFyZ0xlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgsIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uY2FsbChjdHgsIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXZlIG1vcmUgdGhhbiAyIGdpdmVuIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oW2ldWydoJ10uYXBwbHkoY3R4LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaFtpXVsnb25lJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyDlr7nosaHlj6/ku6XpgJrov4cgb254eHh4IOe7keWumuS6i+S7tlxuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmNsaWNrXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW92ZXJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3V0XG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW1vdmVcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNld2hlZWxcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlZG93blxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V1cFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ3N0YXJ0XG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnZW5kXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnZW50ZXJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdsZWF2ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ292ZXJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyb3BcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudGZ1bDtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDmj5Dkvpvlj5jmjaLmianlsZVcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgbWF0cml4ID0gcmVxdWlyZSgnLi4vY29yZS9tYXRyaXgnKTtcbiAgICB2YXIgdmVjdG9yID0gcmVxdWlyZSgnLi4vY29yZS92ZWN0b3InKTtcbiAgICB2YXIgbUlkZW50aXR5ID0gbWF0cml4LmlkZW50aXR5O1xuXG4gICAgdmFyIEVQU0lMT04gPSA1ZS01O1xuXG4gICAgZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBUcmFuc2Zvcm1hYmxlID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBnaXZlbiBwb3NpdGlvbiwgcm90YXRpb24sIHNjYWxlXG4gICAgICAgIGlmICghb3B0cy5wb3NpdGlvbikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDlubPnp7tcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IFswLCAwXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gWzAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnJvdGF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5peL6L2sXG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0cy5zY2FsZSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDnvKnmlL5cbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IFsxLCAxXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gWzEsIDFdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDml4vovazlkoznvKnmlL7nmoTljp/ngrlcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWdpbiA9IHRoaXMub3JpZ2luIHx8IG51bGw7XG4gICAgfTtcblxuICAgIHZhciB0cmFuc2Zvcm1hYmxlUHJvdG8gPSBUcmFuc2Zvcm1hYmxlLnByb3RvdHlwZTtcbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIOWIpOaWreaYr+WQpumcgOimgeacieWdkOagh+WPmOaNolxuICAgICAqIOWmguaenOacieWdkOagh+WPmOaNoiwg5YiZ5LuOcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZeS7peWPiueItuiKgueCueeahHRyYW5zZm9ybeiuoeeul+WHuuiHqui6q+eahHRyYW5zZm9ybeefqemYtVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by5uZWVkTG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpc05vdEFyb3VuZFplcm8odGhpcy5yb3RhdGlvbilcbiAgICAgICAgICAgIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzBdKVxuICAgICAgICAgICAgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMucG9zaXRpb25bMV0pXG4gICAgICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVswXSAtIDEpXG4gICAgICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVsxXSAtIDEpO1xuICAgIH07XG5cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8udXBkYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHZhciBwYXJlbnRIYXNUcmFuc2Zvcm0gPSBwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybTtcbiAgICAgICAgdmFyIG5lZWRMb2NhbFRyYW5zZm9ybSA9IHRoaXMubmVlZExvY2FsVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKCEobmVlZExvY2FsVHJhbnNmb3JtIHx8IHBhcmVudEhhc1RyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgIG0gJiYgbUlkZW50aXR5KG0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbSA9IG0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuXG4gICAgICAgIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0TG9jYWxUcmFuc2Zvcm0obSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtSWRlbnRpdHkobSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDlupTnlKjniLboioLngrnlj5jmjaJcbiAgICAgICAgaWYgKHBhcmVudEhhc1RyYW5zZm9ybSkge1xuICAgICAgICAgICAgaWYgKG5lZWRMb2NhbFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIG1hdHJpeC5tdWwobSwgcGFyZW50LnRyYW5zZm9ybSwgbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXRyaXguY29weShtLCBwYXJlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyDkv53lrZjov5nkuKrlj5jmjaLnn6npmLVcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBtO1xuXG4gICAgICAgIHRoaXMuaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuICAgICAgICBtYXRyaXguaW52ZXJ0KHRoaXMuaW52VHJhbnNmb3JtLCBtKTtcbiAgICB9O1xuXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLmdldExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIFRyYW5zZm9ybWFibGUuZ2V0TG9jYWxUcmFuc2Zvcm0odGhpcywgbSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOWwhuiHquW3seeahHRyYW5zZm9ybeW6lOeUqOWIsGNvbnRleHTkuIpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjdHgpIHsgICAgICAgIFxuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybShkcHIgKiBtWzBdLCBkcHIgKiBtWzFdLCBkcHIgKiBtWzJdLCBkcHIgKiBtWzNdLCBkcHIgKiBtWzRdLCBkcHIgKiBtWzVdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRyYW5zZm9ybWFibGVQcm90by5yZXN0b3JlVHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKGRwciwgMCwgMCwgZHByLCAwLCAwKTtcbiAgICB9O1xuXG4gICAgdmFyIHRtcFRyYW5zZm9ybSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICog5YiG6KejYHRyYW5zZm9ybWDnn6npmLXliLBgcG9zaXRpb25gLCBgcm90YXRpb25gLCBgc2NhbGVgXG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLmRlY29tcG9zZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBHZXQgbG9jYWwgdHJhbnNmb3JtIGFuZCBkZWNvbXBvc2UgdGhlbSB0byBwb3NpdGlvbiwgc2NhbGUsIHJvdGF0aW9uXG4gICAgICAgICAgICBtYXRyaXgubXVsKHRtcFRyYW5zZm9ybSwgcGFyZW50LmludlRyYW5zZm9ybSwgbSk7XG4gICAgICAgICAgICBtID0gdG1wVHJhbnNmb3JtO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzeCA9IG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV07XG4gICAgICAgIHZhciBzeSA9IG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM107XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgIGlmIChpc05vdEFyb3VuZFplcm8oc3ggLSAxKSkge1xuICAgICAgICAgICAgc3ggPSBNYXRoLnNxcnQoc3gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05vdEFyb3VuZFplcm8oc3kgLSAxKSkge1xuICAgICAgICAgICAgc3kgPSBNYXRoLnNxcnQoc3kpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtWzBdIDwgMCkge1xuICAgICAgICAgICAgc3ggPSAtc3g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1bM10gPCAwKSB7XG4gICAgICAgICAgICBzeSA9IC1zeTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvblswXSA9IG1bNF07XG4gICAgICAgIHBvc2l0aW9uWzFdID0gbVs1XTtcbiAgICAgICAgc2NhbGVbMF0gPSBzeDtcbiAgICAgICAgc2NhbGVbMV0gPSBzeTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IE1hdGguYXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGdsb2JhbCBzY2FsZVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by5nZXRHbG9iYWxTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gWzEsIDFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzeCA9IE1hdGguc3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgICAgdmFyIHN5ID0gTWF0aC5zcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICBpZiAobVswXSA8IDApIHtcbiAgICAgICAgICAgIHN4ID0gLXN4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtWzNdIDwgMCkge1xuICAgICAgICAgICAgc3kgPSAtc3k7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzeCwgc3ldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICog5Y+Y5o2i5Z2Q5qCH5L2N572u5YiwIHNoYXBlIOeahOWxgOmDqOWdkOagh+epuumXtFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciB2MiA9IFt4LCB5XTtcbiAgICAgICAgdmFyIGludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtO1xuICAgICAgICBpZiAoaW52VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0odjIsIHYyLCBpbnZUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5Y+Y5o2i5bGA6YOo5Z2Q5qCH5L2N572u5Yiw5YWo5bGA5Z2Q5qCH56m66Ze0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtQ29vcmRUb0dsb2JhbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciB2MiA9IFt4LCB5XTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0odjIsIHYyLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2MjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0YXJnZXQub3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldC5yb3RhdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRhcmdldC5wb3NpdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFttXVxuICAgICAqL1xuICAgIFRyYW5zZm9ybWFibGUuZ2V0TG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodGFyZ2V0LCBtKSB7XG4gICAgICAgIG0gPSBtIHx8IFtdO1xuICAgICAgICBtSWRlbnRpdHkobSk7XG5cbiAgICAgICAgdmFyIG9yaWdpbiA9IHRhcmdldC5vcmlnaW47XG4gICAgICAgIHZhciBzY2FsZSA9IHRhcmdldC5zY2FsZSB8fCBbMSwgMV07XG4gICAgICAgIHZhciByb3RhdGlvbiA9IHRhcmdldC5yb3RhdGlvbiB8fCAwO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0YXJnZXQucG9zaXRpb24gfHwgWzAsIDBdO1xuXG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSB0byBvcmlnaW5cbiAgICAgICAgICAgIG1bNF0gLT0gb3JpZ2luWzBdO1xuICAgICAgICAgICAgbVs1XSAtPSBvcmlnaW5bMV07XG4gICAgICAgIH1cbiAgICAgICAgbWF0cml4LnNjYWxlKG0sIG0sIHNjYWxlKTtcbiAgICAgICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICAgICAgICBtYXRyaXgucm90YXRlKG0sIG0sIHJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgYmFjayBmcm9tIG9yaWdpblxuICAgICAgICAgICAgbVs0XSArPSBvcmlnaW5bMF07XG4gICAgICAgICAgICBtWzVdICs9IG9yaWdpblsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1bNF0gKz0gcG9zaXRpb25bMF07XG4gICAgICAgIG1bNV0gKz0gcG9zaXRpb25bMV07XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtYWJsZTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9taXhpbi9UcmFuc2Zvcm1hYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbiAgICB2YXIgQXJyYXlDdG9yID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBBcnJheVxuICAgICAgICA6IEZsb2F0MzJBcnJheTtcbiAgICAvKipcbiAgICAgKiAzeDLnn6npmLXmk43kvZznsbtcbiAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL3Rvb2wvbWF0cml4XG4gICAgICovXG4gICAgdmFyIG1hdHJpeCA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIm+W7uuS4gOS4quWNleS9jeefqemYtVxuICAgICAgICAgKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGUgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDYpO1xuICAgICAgICAgICAgbWF0cml4LmlkZW50aXR5KG91dCk7XG5cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7nn6npmLXkuLrljZXkvY3nn6npmLVcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKi9cbiAgICAgICAgaWRlbnRpdHkgOiBmdW5jdGlvbihvdXQpIHtcbiAgICAgICAgICAgIG91dFswXSA9IDE7XG4gICAgICAgICAgICBvdXRbMV0gPSAwO1xuICAgICAgICAgICAgb3V0WzJdID0gMDtcbiAgICAgICAgICAgIG91dFszXSA9IDE7XG4gICAgICAgICAgICBvdXRbNF0gPSAwO1xuICAgICAgICAgICAgb3V0WzVdID0gMDtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlpI3liLbnn6npmLVcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbVxuICAgICAgICAgKi9cbiAgICAgICAgY29weTogZnVuY3Rpb24ob3V0LCBtKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBtWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gbVsxXTtcbiAgICAgICAgICAgIG91dFsyXSA9IG1bMl07XG4gICAgICAgICAgICBvdXRbM10gPSBtWzNdO1xuICAgICAgICAgICAgb3V0WzRdID0gbVs0XTtcbiAgICAgICAgICAgIG91dFs1XSA9IG1bNV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog55+p6Zi155u45LmYXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG0xXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtMlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsIDogZnVuY3Rpb24gKG91dCwgbTEsIG0yKSB7XG4gICAgICAgICAgICAvLyBDb25zaWRlciBtYXRyaXgubXVsKG0sIG0yLCBtKTtcbiAgICAgICAgICAgIC8vIHdoZXJlIG91dCBpcyB0aGUgc2FtZSBhcyBtMi5cbiAgICAgICAgICAgIC8vIFNvIHVzZSB0ZW1wIHZhcmlhYmxlIHRvIGVzY2FwZSBlcnJvci5cbiAgICAgICAgICAgIHZhciBvdXQwID0gbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV07XG4gICAgICAgICAgICB2YXIgb3V0MSA9IG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdO1xuICAgICAgICAgICAgdmFyIG91dDIgPSBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXTtcbiAgICAgICAgICAgIHZhciBvdXQzID0gbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM107XG4gICAgICAgICAgICB2YXIgb3V0NCA9IG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF07XG4gICAgICAgICAgICB2YXIgb3V0NSA9IG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV07XG4gICAgICAgICAgICBvdXRbMF0gPSBvdXQwO1xuICAgICAgICAgICAgb3V0WzFdID0gb3V0MTtcbiAgICAgICAgICAgIG91dFsyXSA9IG91dDI7XG4gICAgICAgICAgICBvdXRbM10gPSBvdXQzO1xuICAgICAgICAgICAgb3V0WzRdID0gb3V0NDtcbiAgICAgICAgICAgIG91dFs1XSA9IG91dDU7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5bmz56e75Y+Y5o2iXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IHZcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zbGF0ZSA6IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgICAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IGFbMV07XG4gICAgICAgICAgICBvdXRbMl0gPSBhWzJdO1xuICAgICAgICAgICAgb3V0WzNdID0gYVszXTtcbiAgICAgICAgICAgIG91dFs0XSA9IGFbNF0gKyB2WzBdO1xuICAgICAgICAgICAgb3V0WzVdID0gYVs1XSArIHZbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5peL6L2s5Y+Y5o2iXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZFxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlIDogZnVuY3Rpb24ob3V0LCBhLCByYWQpIHtcbiAgICAgICAgICAgIHZhciBhYSA9IGFbMF07XG4gICAgICAgICAgICB2YXIgYWMgPSBhWzJdO1xuICAgICAgICAgICAgdmFyIGF0eCA9IGFbNF07XG4gICAgICAgICAgICB2YXIgYWIgPSBhWzFdO1xuICAgICAgICAgICAgdmFyIGFkID0gYVszXTtcbiAgICAgICAgICAgIHZhciBhdHkgPSBhWzVdO1xuICAgICAgICAgICAgdmFyIHN0ID0gTWF0aC5zaW4ocmFkKTtcbiAgICAgICAgICAgIHZhciBjdCA9IE1hdGguY29zKHJhZCk7XG5cbiAgICAgICAgICAgIG91dFswXSA9IGFhICogY3QgKyBhYiAqIHN0O1xuICAgICAgICAgICAgb3V0WzFdID0gLWFhICogc3QgKyBhYiAqIGN0O1xuICAgICAgICAgICAgb3V0WzJdID0gYWMgKiBjdCArIGFkICogc3Q7XG4gICAgICAgICAgICBvdXRbM10gPSAtYWMgKiBzdCArIGN0ICogYWQ7XG4gICAgICAgICAgICBvdXRbNF0gPSBjdCAqIGF0eCArIHN0ICogYXR5O1xuICAgICAgICAgICAgb3V0WzVdID0gY3QgKiBhdHkgLSBzdCAqIGF0eDtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnvKnmlL7lj5jmjaJcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gdlxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGUgOiBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICAgICAgICAgIHZhciB2eCA9IHZbMF07XG4gICAgICAgICAgICB2YXIgdnkgPSB2WzFdO1xuICAgICAgICAgICAgb3V0WzBdID0gYVswXSAqIHZ4O1xuICAgICAgICAgICAgb3V0WzFdID0gYVsxXSAqIHZ5O1xuICAgICAgICAgICAgb3V0WzJdID0gYVsyXSAqIHZ4O1xuICAgICAgICAgICAgb3V0WzNdID0gYVszXSAqIHZ5O1xuICAgICAgICAgICAgb3V0WzRdID0gYVs0XSAqIHZ4O1xuICAgICAgICAgICAgb3V0WzVdID0gYVs1XSAqIHZ5O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaxgumAhuefqemYtVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gICAgICAgICAqL1xuICAgICAgICBpbnZlcnQgOiBmdW5jdGlvbihvdXQsIGEpIHtcblxuICAgICAgICAgICAgdmFyIGFhID0gYVswXTtcbiAgICAgICAgICAgIHZhciBhYyA9IGFbMl07XG4gICAgICAgICAgICB2YXIgYXR4ID0gYVs0XTtcbiAgICAgICAgICAgIHZhciBhYiA9IGFbMV07XG4gICAgICAgICAgICB2YXIgYWQgPSBhWzNdO1xuICAgICAgICAgICAgdmFyIGF0eSA9IGFbNV07XG5cbiAgICAgICAgICAgIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcbiAgICAgICAgICAgIGlmICghZGV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICAgICAgICAgIG91dFswXSA9IGFkICogZGV0O1xuICAgICAgICAgICAgb3V0WzFdID0gLWFiICogZGV0O1xuICAgICAgICAgICAgb3V0WzJdID0gLWFjICogZGV0O1xuICAgICAgICAgICAgb3V0WzNdID0gYWEgKiBkZXQ7XG4gICAgICAgICAgICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gICAgICAgICAgICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gbWF0cml4O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvcmUvbWF0cml4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbiAgICB2YXIgQXJyYXlDdG9yID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBBcnJheVxuICAgICAgICA6IEZsb2F0MzJBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IFZlY3RvcjJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiDkuoznu7TlkJHph4/nsbtcbiAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL3Rvb2wvdmVjdG9yXG4gICAgICovXG4gICAgdmFyIHZlY3RvciA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIm+W7uuS4gOS4quWQkemHj1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbmV3IEFycmF5Q3RvcigyKTtcbiAgICAgICAgICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dFswXSA9IHg7XG4gICAgICAgICAgICBvdXRbMV0gPSB5O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5aSN5Yi25ZCR6YeP5pWw5o2uXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgICAgICAgKi9cbiAgICAgICAgY29weTogZnVuY3Rpb24gKG91dCwgdikge1xuICAgICAgICAgICAgb3V0WzBdID0gdlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHZbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlhYvpmobkuIDkuKrlkJHph49cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDIpO1xuICAgICAgICAgICAgb3V0WzBdID0gdlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHZbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7lkJHph4/nmoTkuKTkuKrpoblcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGFcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGJcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yMn0g57uT5p6cXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IGE7XG4gICAgICAgICAgICBvdXRbMV0gPSBiO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP55u45YqgXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdICsgdjJbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSArIHYyWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP57yp5pS+5ZCO55u45YqgXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYVxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGVBbmRBZGQ6IGZ1bmN0aW9uIChvdXQsIHYxLCB2MiwgYSkge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gKyB2MlswXSAqIGE7XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSArIHYyWzFdICogYTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+ebuOWHj1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIHN1YjogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSAtIHYyWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gLSB2MlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+mVv+W6plxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbGVuOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmxlblNxdWFyZSh2KSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+mVv+W6puW5s+aWuVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbGVuU3F1YXJlOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+S5mOazlVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIG11bDogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSAqIHYyWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gKiB2MlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+mZpOazlVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIGRpdjogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSAvIHYyWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gLyB2MlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+eCueS5mFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZG90OiBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgICAgICByZXR1cm4gdjFbMF0gKiB2MlswXSArIHYxWzFdICogdjJbMV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+e8qeaUvlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNcbiAgICAgICAgICovXG4gICAgICAgIHNjYWxlOiBmdW5jdGlvbiAob3V0LCB2LCBzKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2WzBdICogcztcbiAgICAgICAgICAgIG91dFsxXSA9IHZbMV0gKiBzO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP5b2S5LiA5YyWXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKi9cbiAgICAgICAgbm9ybWFsaXplOiBmdW5jdGlvbiAob3V0LCB2KSB7XG4gICAgICAgICAgICB2YXIgZCA9IHZlY3Rvci5sZW4odik7XG4gICAgICAgICAgICBpZiAoZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG91dFswXSA9IDA7XG4gICAgICAgICAgICAgICAgb3V0WzFdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dFswXSA9IHZbMF0gLyBkO1xuICAgICAgICAgICAgICAgIG91dFsxXSA9IHZbMV0gLyBkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6h566X5ZCR6YeP6Ze06Led56a7XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBkaXN0YW5jZTogZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgICAgICAgICAgICAodjFbMF0gLSB2MlswXSkgKiAodjFbMF0gLSB2MlswXSlcbiAgICAgICAgICAgICAgICArICh2MVsxXSAtIHYyWzFdKSAqICh2MVsxXSAtIHYyWzFdKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP6Led56a75bmz5pa5XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBkaXN0YW5jZVNxdWFyZTogZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICAgICAgcmV0dXJuICh2MVswXSAtIHYyWzBdKSAqICh2MVswXSAtIHYyWzBdKVxuICAgICAgICAgICAgICAgICsgKHYxWzFdIC0gdjJbMV0pICogKHYxWzFdIC0gdjJbMV0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmsYLotJ/lkJHph49cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGU6IGZ1bmN0aW9uIChvdXQsIHYpIHtcbiAgICAgICAgICAgIG91dFswXSA9IC12WzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gLXZbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmj5LlgLzkuKTkuKrngrlcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gICAgICAgICAqL1xuICAgICAgICBsZXJwOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIsIHQpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdICsgdCAqICh2MlswXSAtIHYxWzBdKTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdICsgdCAqICh2MlsxXSAtIHYxWzFdKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOefqemYteW3puS5mOWQkemHj1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBtXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseVRyYW5zZm9ybTogZnVuY3Rpb24gKG91dCwgdiwgbSkge1xuICAgICAgICAgICAgdmFyIHggPSB2WzBdO1xuICAgICAgICAgICAgdmFyIHkgPSB2WzFdO1xuICAgICAgICAgICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gICAgICAgICAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmsYLkuKTkuKrlkJHph4/mnIDlsI/lgLxcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBtaW46IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gTWF0aC5taW4odjFbMF0sIHYyWzBdKTtcbiAgICAgICAgICAgIG91dFsxXSA9IE1hdGgubWluKHYxWzFdLCB2MlsxXSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5rGC5Lik5Liq5ZCR6YeP5pyA5aSn5YC8XG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgbWF4OiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IE1hdGgubWF4KHYxWzBdLCB2MlswXSk7XG4gICAgICAgICAgICBvdXRbMV0gPSBNYXRoLm1heCh2MVsxXSwgdjJbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2ZWN0b3IubGVuZ3RoID0gdmVjdG9yLmxlbjtcbiAgICB2ZWN0b3IubGVuZ3RoU3F1YXJlID0gdmVjdG9yLmxlblNxdWFyZTtcbiAgICB2ZWN0b3IuZGlzdCA9IHZlY3Rvci5kaXN0YW5jZTtcbiAgICB2ZWN0b3IuZGlzdFNxdWFyZSA9IHZlY3Rvci5kaXN0YW5jZVNxdWFyZTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gdmVjdG9yO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9BbmltYXRhYmxlXG4gKi9cblxuXG4gICAgdmFyIEFuaW1hdG9yID0gcmVxdWlyZSgnLi4vYW5pbWF0aW9uL0FuaW1hdG9yJyk7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgaXNTdHJpbmcgPSB1dGlsLmlzU3RyaW5nO1xuICAgIHZhciBpc0Z1bmN0aW9uID0gdXRpbC5pc0Z1bmN0aW9uO1xuICAgIHZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG4gICAgdmFyIGxvZyA9IHJlcXVpcmUoJy4uL2NvcmUvbG9nJyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWU6enJlbmRlci9taXhpbi9BbmltYXRhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGFibGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yPn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdG9ycyA9IFtdO1xuICAgIH07XG5cbiAgICBBbmltYXRhYmxlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQW5pbWF0YWJsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yqo55S7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGZldGNoIHZhbHVlIGZyb20gb2JqZWN0LCBsaWtlICdhLmIuYycuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xvb3BdIFdoZXRoZXIgdG8gbG9vcCBhbmltYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICogQGV4YW1wbGU6XG4gICAgICAgICAqICAgICBlbC5hbmltYXRlKCdzdHlsZScsIGZhbHNlKVxuICAgICAgICAgKiAgICAgICAgIC53aGVuKDEwMDAsIHt4OiAxMH0gKVxuICAgICAgICAgKiAgICAgICAgIC5kb25lKGZ1bmN0aW9uKCl7IC8vIEFuaW1hdGlvbiBkb25lIH0pXG4gICAgICAgICAqICAgICAgICAgLnN0YXJ0KClcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIChwYXRoLCBsb29wKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGFuaW1hdGluZ1NoYXBlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aFNwbGl0dGVkID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gZWw7XG4gICAgICAgICAgICAgICAgLy8gSWYgYW5pbWF0aW5nIHNoYXBlXG4gICAgICAgICAgICAgICAgYW5pbWF0aW5nU2hhcGUgPSBwYXRoU3BsaXR0ZWRbMF0gPT09ICdzaGFwZSc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoU3BsaXR0ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IHByb3BbcGF0aFNwbGl0dGVkW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBlbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBsb2coXG4gICAgICAgICAgICAgICAgICAgICdQcm9wZXJ0eSBcIidcbiAgICAgICAgICAgICAgICAgICAgKyBwYXRoXG4gICAgICAgICAgICAgICAgICAgICsgJ1wiIGlzIG5vdCBleGlzdGVkIGluIGVsZW1lbnQgJ1xuICAgICAgICAgICAgICAgICAgICArIGVsLmlkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSBlbC5hbmltYXRvcnM7XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcih0YXJnZXQsIGxvb3ApO1xuXG4gICAgICAgICAgICBhbmltYXRvci5kdXJpbmcoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGVsLmRpcnR5KGFuaW1hdGluZ1NoYXBlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgQW5pbWF0b3Igd2lsbCBub3QgYmUgcmVtb3ZlZCBpZiB1c2UgYEFuaW1hdG9yI3N0b3BgIHRvIHN0b3AgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgYW5pbWF0b3JzLnNwbGljZSh1dGlsLmluZGV4T2YoYW5pbWF0b3JzLCBhbmltYXRvciksIDEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGFuaW1hdG9ycy5wdXNoKGFuaW1hdG9yKTtcblxuICAgICAgICAgICAgLy8gSWYgYW5pbWF0ZSBhZnRlciBhZGRlZCB0byB0aGUgenJlbmRlclxuICAgICAgICAgICAgaWYgKHpyKSB7XG4gICAgICAgICAgICAgICAgenIuYW5pbWF0aW9uLmFkZEFuaW1hdG9yKGFuaW1hdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdG9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLliqjnlLtcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcEFuaW1hdGlvbjogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRvcnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yc1tpXS5zdG9wKGZvcndhcmRUb0xhc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5pbWF0b3JzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXV0aW9uOiB0aGlzIG1ldGhvZCB3aWxsIHN0b3AgcHJldmlvdXMgYW5pbWF0aW9uLlxuICAgICAgICAgKiBTbyBkbyBub3QgdXNlIHRoaXMgbWV0aG9kIHRvIG9uZSBlbGVtZW50IHR3aWNlIGJlZm9yZVxuICAgICAgICAgKiBhbmltYXRpb24gc3RhcnRzLCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT01MDBdIFRpbWUgaW4gbXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtlYXNpbmc9J2xpbmVhciddXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm9yY2VBbmltYXRlXSBQcmV2ZW50IHN0b3AgYW5pbWF0aW9uIGFuZCBjYWxsYmFja1xuICAgICAgICAgKiAgICAgICAgaW1tZWRpZW50bHkgd2hlbiB0YXJnZXQgdmFsdWVzIGFyZSB0aGUgc2FtZSBhcyBjdXJyZW50IHZhbHVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogIC8vIEFuaW1hdGUgcG9zaXRpb25cbiAgICAgICAgICogIGVsLmFuaW1hdGVUbyh7XG4gICAgICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICAgICAqICB9LCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcbiAgICAgICAgICpcbiAgICAgICAgICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtcywgd2l0aCBjdWJpY091dCBlYXNpbmdcbiAgICAgICAgICogIGVsLmFuaW1hdGVUbyh7XG4gICAgICAgICAqICAgICAgc2hhcGU6IHtcbiAgICAgICAgICogICAgICAgICAgd2lkdGg6IDUwMFxuICAgICAgICAgKiAgICAgIH0sXG4gICAgICAgICAqICAgICAgc3R5bGU6IHtcbiAgICAgICAgICogICAgICAgICAgZmlsbDogJ3JlZCdcbiAgICAgICAgICogICAgICB9XG4gICAgICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICAgICAqICB9LCAxMDAsIDEwMCwgJ2N1YmljT3V0JywgZnVuY3Rpb24gKCkgeyAvLyBkb25lIH0pXG4gICAgICAgICAqL1xuICAgICAgICAgLy8gVE9ETyBSZXR1cm4gYW5pbWF0aW9uIGtleVxuICAgICAgICBhbmltYXRlVG86IGZ1bmN0aW9uICh0YXJnZXQsIHRpbWUsIGRlbGF5LCBlYXNpbmcsIGNhbGxiYWNrLCBmb3JjZUFuaW1hdGUpIHtcbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGVhc2luZywgY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgICAgICAgICAgIGVhc2luZyA9IGRlbGF5O1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGRlbGF5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVhc2luZykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgICAgICBlYXNpbmcgPSAnbGluZWFyJztcbiAgICAgICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZGVsYXk7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgY2FsbGJhY2spXG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRpbWUpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB0aW1lO1xuICAgICAgICAgICAgICAgIHRpbWUgPSA1MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0KVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcCBhbGwgcHJldmlvdXMgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlVG9TaGFsbG93KCcnLCB0aGlzLCB0YXJnZXQsIHRpbWUsIGRlbGF5LCBlYXNpbmcsIGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgLy8gQW5pbWF0b3JzIG1heSBiZSByZW1vdmVkIGltbWVkaWF0ZWx5IGFmdGVyIHN0YXJ0XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBub3RoaW5nIHRvIGFuaW1hdGVcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycy5zbGljZSgpO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gYW5pbWF0b3JzLmxlbmd0aDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBObyBhbmltYXRvcnMuIFRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgYmVmb3JlIGFuaW1hdG9yc1tpXS5zdGFydCgpLFxuICAgICAgICAgICAgLy8gYmVjYXVzZSAnZG9uZScgbWF5IGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IGlmIG5vIG5lZWQgdG8gYW5pbWF0ZS5cbiAgICAgICAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgYWZ0ZXIgYWxsIGFuaW1hdG9ycyBjcmVhdGVkXG4gICAgICAgICAgICAvLyBJbmNhc2UgYW55IGFuaW1hdG9yIGlzIGRvbmUgaW1tZWRpYXRlbHkgd2hlbiBhbGwgYW5pbWF0aW9uIHByb3BlcnRpZXMgYXJlIG5vdCBjaGFuZ2VkXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yc1tpXVxuICAgICAgICAgICAgICAgICAgICAuZG9uZShkb25lKVxuICAgICAgICAgICAgICAgICAgICAuc3RhcnQoZWFzaW5nLCBmb3JjZUFuaW1hdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aD0nJ1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlPXRoaXNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICAvLyBBbmltYXRlIHBvc2l0aW9uXG4gICAgICAgICAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gICAgICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICAgICAqICB9KVxuICAgICAgICAgKlxuICAgICAgICAgKiAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zXG4gICAgICAgICAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gICAgICAgICAqICAgICAgc2hhcGU6IHtcbiAgICAgICAgICogICAgICAgICAgd2lkdGg6IDUwMFxuICAgICAgICAgKiAgICAgIH0sXG4gICAgICAgICAqICAgICAgc3R5bGU6IHtcbiAgICAgICAgICogICAgICAgICAgZmlsbDogJ3JlZCdcbiAgICAgICAgICogICAgICB9XG4gICAgICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICAgICAqICB9LCAxMDAsIDEwMClcbiAgICAgICAgICovXG4gICAgICAgIF9hbmltYXRlVG9TaGFsbG93OiBmdW5jdGlvbiAocGF0aCwgc291cmNlLCB0YXJnZXQsIHRpbWUsIGRlbGF5KSB7XG4gICAgICAgICAgICB2YXIgb2JqU2hhbGxvdyA9IHt9O1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5Q291bnQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHRhcmdldFtuYW1lXSkgJiYgIXV0aWwuaXNBcnJheUxpa2UodGFyZ2V0W25hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZVRvU2hhbGxvdyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID8gcGF0aCArICcuJyArIG5hbWUgOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVtuYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialNoYWxsb3dbbmFtZV0gPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0W25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ciBkaXJlY3RseSBpZiBub3QgaGFzIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FLCBpZiBzb21lIHByb3BlcnR5IG5vdCBuZWVkZWQgZm9yIGVsZW1lbnQgP1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cihuYW1lLCB0YXJnZXRbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAgLy8gU2hhcGUgb3Igc3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbcGF0aF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW3BhdGhdW25hbWVdID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByb3BlcnR5Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlKHBhdGgsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAud2hlbih0aW1lID09IG51bGwgPyA1MDAgOiB0aW1lLCBvYmpTaGFsbG93KVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoZGVsYXkgfHwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQW5pbWF0YWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvbWl4aW4vQW5pbWF0YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvYW5pbWF0aW9uL0FuaW1hdG9yXG4gKi9cblxuXG4gICAgdmFyIENsaXAgPSByZXF1aXJlKCcuL0NsaXAnKTtcbiAgICB2YXIgY29sb3IgPSByZXF1aXJlKCcuLi90b29sL2NvbG9yJyk7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgaXNBcnJheUxpa2UgPSB1dGlsLmlzQXJyYXlMaWtlO1xuXG4gICAgdmFyIGFycmF5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0R2V0dGVyKHRhcmdldCwga2V5KSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0U2V0dGVyKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlTnVtYmVyKHAwLCBwMSwgcGVyY2VudCkge1xuICAgICAgICByZXR1cm4gKHAxIC0gcDApICogcGVyY2VudCArIHAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gcDBcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlU3RyaW5nKHAwLCBwMSwgcGVyY2VudCkge1xuICAgICAgICByZXR1cm4gcGVyY2VudCA+IDAuNSA/IHAxIDogcDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAwXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAgICogQHBhcmFtICB7QXJyYXl9IG91dFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHBlcmNlbnQsIG91dCwgYXJyRGltKSB7XG4gICAgICAgIHZhciBsZW4gPSBwMC5sZW5ndGg7XG4gICAgICAgIGlmIChhcnJEaW0gPT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IGludGVycG9sYXRlTnVtYmVyKHAwW2ldLCBwMVtpXSwgcGVyY2VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGVuMiA9IGxlbiAmJiBwMFswXS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0W2ldW2pdID0gaW50ZXJwb2xhdGVOdW1iZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBwMFtpXVtqXSwgcDFbaV1bal0sIHBlcmNlbnRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhcnIwIGlzIHNvdXJjZSBhcnJheSwgYXJyMSBpcyB0YXJnZXQgYXJyYXkuXG4gICAgLy8gRG8gc29tZSBwcmVwcm9jZXNzIHRvIGF2b2lkIGVycm9yIGhhcHBlbmVkIHdoZW4gaW50ZXJwb2xhdGluZyBmcm9tIGFycjAgdG8gYXJyMVxuICAgIGZ1bmN0aW9uIGZpbGxBcnIoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gICAgICAgIHZhciBhcnIwTGVuID0gYXJyMC5sZW5ndGg7XG4gICAgICAgIHZhciBhcnIxTGVuID0gYXJyMS5sZW5ndGg7XG4gICAgICAgIGlmIChhcnIwTGVuICE9PSBhcnIxTGVuKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSBOb3Qgd29yayBmb3IgVHlwZWRBcnJheVxuICAgICAgICAgICAgdmFyIGlzUHJldmlvdXNMYXJnZXIgPSBhcnIwTGVuID4gYXJyMUxlbjtcbiAgICAgICAgICAgIGlmIChpc1ByZXZpb3VzTGFyZ2VyKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3V0IHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgICAgIGFycjAubGVuZ3RoID0gYXJyMUxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZpbGwgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGFycjBMZW47IGkgPCBhcnIxTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyMC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyRGltID09PSAxID8gYXJyMVtpXSA6IGFycmF5U2xpY2UuY2FsbChhcnIxW2ldKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGluZyBOYU4gdmFsdWVcbiAgICAgICAgdmFyIGxlbjIgPSBhcnIwWzBdICYmIGFycjBbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycjAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYXJyMFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyMFtpXSA9IGFycjFbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGFycjBbaV1bal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIwW2ldW2pdID0gYXJyMVtpXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnIwXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFycjFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheVNhbWUoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gICAgICAgIGlmIChhcnIwID09PSBhcnIxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gYXJyMC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gIT09IGFycjEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyckRpbSA9PT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnIwW2ldICE9PSBhcnIxW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGVuMiA9IGFycjBbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnIwW2ldW2pdICE9PSBhcnIxW2ldW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2F0bXVsbCBSb20gaW50ZXJwb2xhdGUgYXJyYXlcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDJcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0M1xuICAgICAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGFyckRpbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICBwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzLCBvdXQsIGFyckRpbVxuICAgICkge1xuICAgICAgICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyRGltID09IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbaV0gPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUoXG4gICAgICAgICAgICAgICAgICAgIHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0LCB0MiwgdDNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxlbjIgPSBwMFswXS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0W2ldW2pdID0gY2F0bXVsbFJvbUludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcDBbaV1bal0sIHAxW2ldW2pdLCBwMltpXVtqXSwgcDNbaV1bal0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0LCB0MiwgdDNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBudW1iZXJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMpIHtcbiAgICAgICAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICAgICAgICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gICAgICAgIHJldHVybiAoMiAqIChwMSAtIHAyKSArIHYwICsgdjEpICogdDNcbiAgICAgICAgICAgICAgICArICgtMyAqIChwMSAtIHAyKSAtIDIgKiB2MCAtIHYxKSAqIHQyXG4gICAgICAgICAgICAgICAgKyB2MCAqIHQgKyBwMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWVbMF0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goYXJyYXlTbGljZS5jYWxsKHZhbHVlW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhcnJheVNsaWNlLmNhbGwodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJnYmEyU3RyaW5nKHJnYmEpIHtcbiAgICAgICAgcmdiYVswXSA9IE1hdGguZmxvb3IocmdiYVswXSk7XG4gICAgICAgIHJnYmFbMV0gPSBNYXRoLmZsb29yKHJnYmFbMV0pO1xuICAgICAgICByZ2JhWzJdID0gTWF0aC5mbG9vcihyZ2JhWzJdKTtcblxuICAgICAgICByZXR1cm4gJ3JnYmEoJyArIHJnYmEuam9pbignLCcpICsgJyknO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEFycmF5RGltKGtleWZyYW1lcykge1xuICAgICAgICB2YXIgbGFzdFZhbHVlID0ga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKGxhc3RWYWx1ZSAmJiBsYXN0VmFsdWVbMF0pID8gMiA6IDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVHJhY2tDbGlwKGFuaW1hdG9yLCBlYXNpbmcsIG9uZVRyYWNrRG9uZSwga2V5ZnJhbWVzLCBwcm9wTmFtZSwgZm9yY2VBbmltYXRlKSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBhbmltYXRvci5fZ2V0dGVyO1xuICAgICAgICB2YXIgc2V0dGVyID0gYW5pbWF0b3IuX3NldHRlcjtcbiAgICAgICAgdmFyIHVzZVNwbGluZSA9IGVhc2luZyA9PT0gJ3NwbGluZSc7XG5cbiAgICAgICAgdmFyIHRyYWNrTGVuID0ga2V5ZnJhbWVzLmxlbmd0aDtcbiAgICAgICAgaWYgKCF0cmFja0xlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEd1ZXNzIGRhdGEgdHlwZVxuICAgICAgICB2YXIgZmlyc3RWYWwgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gICAgICAgIHZhciBpc1ZhbHVlQXJyYXkgPSBpc0FycmF5TGlrZShmaXJzdFZhbCk7XG4gICAgICAgIHZhciBpc1ZhbHVlQ29sb3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIGlzVmFsdWVTdHJpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBGb3IgdmVydGljZXMgbW9ycGhpbmdcbiAgICAgICAgdmFyIGFyckRpbSA9IGlzVmFsdWVBcnJheSA/IGdldEFycmF5RGltKGtleWZyYW1lcykgOiAwO1xuXG4gICAgICAgIHZhciB0cmFja01heFRpbWU7XG4gICAgICAgIC8vIFNvcnQga2V5ZnJhbWUgYXMgYXNjZW5kaW5nXG4gICAgICAgIGtleWZyYW1lcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyYWNrTWF4VGltZSA9IGtleWZyYW1lc1t0cmFja0xlbiAtIDFdLnRpbWU7XG4gICAgICAgIC8vIFBlcmNlbnRzIG9mIGVhY2gga2V5ZnJhbWVcbiAgICAgICAgdmFyIGtmUGVyY2VudHMgPSBbXTtcbiAgICAgICAgLy8gVmFsdWUgb2YgZWFjaCBrZXlmcmFtZVxuICAgICAgICB2YXIga2ZWYWx1ZXMgPSBbXTtcbiAgICAgICAgdmFyIHByZXZWYWx1ZSA9IGtleWZyYW1lc1swXS52YWx1ZTtcbiAgICAgICAgdmFyIGlzQWxsVmFsdWVFcXVhbCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW47IGkrKykge1xuICAgICAgICAgICAga2ZQZXJjZW50cy5wdXNoKGtleWZyYW1lc1tpXS50aW1lIC8gdHJhY2tNYXhUaW1lKTtcbiAgICAgICAgICAgIC8vIEFzc3VtZSB2YWx1ZSBpcyBhIGNvbG9yIHdoZW4gaXQgaXMgYSBzdHJpbmdcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGtleWZyYW1lc1tpXS52YWx1ZTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdmFsdWUgaXMgZXF1YWwsIGRlZXAgY2hlY2sgaWYgdmFsdWUgaXMgYXJyYXlcbiAgICAgICAgICAgIGlmICghKChpc1ZhbHVlQXJyYXkgJiYgaXNBcnJheVNhbWUodmFsdWUsIHByZXZWYWx1ZSwgYXJyRGltKSlcbiAgICAgICAgICAgICAgICB8fCAoIWlzVmFsdWVBcnJheSAmJiB2YWx1ZSA9PT0gcHJldlZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICBpc0FsbFZhbHVlRXF1YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAvLyBUcnkgY29udmVydGluZyBhIHN0cmluZyB0byBhIGNvbG9yIGFycmF5XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yQXJyYXkgPSBjb2xvci5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb2xvckFycmF5O1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbHVlQ29sb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWx1ZVN0cmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2ZWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmb3JjZUFuaW1hdGUgJiYgaXNBbGxWYWx1ZUVxdWFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdFZhbHVlID0ga2ZWYWx1ZXNbdHJhY2tMZW4gLSAxXTtcbiAgICAgICAgLy8gUG9seWZpbGwgYXJyYXkgYW5kIE5hTiB2YWx1ZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgZmlsbEFycihrZlZhbHVlc1tpXSwgbGFzdFZhbHVlLCBhcnJEaW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGtmVmFsdWVzW2ldKSAmJiAhaXNOYU4obGFzdFZhbHVlKSAmJiAhaXNWYWx1ZVN0cmluZyAmJiAhaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGtmVmFsdWVzW2ldID0gbGFzdFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpc1ZhbHVlQXJyYXkgJiYgZmlsbEFycihnZXR0ZXIoYW5pbWF0b3IuX3RhcmdldCwgcHJvcE5hbWUpLCBsYXN0VmFsdWUsIGFyckRpbSk7XG5cbiAgICAgICAgLy8gQ2FjaGUgdGhlIGtleSBvZiBsYXN0IGZyYW1lIHRvIHNwZWVkIHVwIHdoZW5cbiAgICAgICAgLy8gYW5pbWF0aW9uIHBsYXliYWNrIGlzIHNlcXVlbmN5XG4gICAgICAgIHZhciBsYXN0RnJhbWUgPSAwO1xuICAgICAgICB2YXIgbGFzdEZyYW1lUGVyY2VudCA9IDA7XG4gICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgdmFyIHc7XG4gICAgICAgIHZhciBwMDtcbiAgICAgICAgdmFyIHAxO1xuICAgICAgICB2YXIgcDI7XG4gICAgICAgIHZhciBwMztcblxuICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgICB2YXIgcmdiYSA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbmZyYW1lID0gZnVuY3Rpb24gKHRhcmdldCwgcGVyY2VudCkge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgcmFuZ2Uga2V5ZnJhbWVzXG4gICAgICAgICAgICAvLyBrZjEtLS0tLWtmMi0tLS0tLS0tLWN1cnJlbnQtLS0tLS0tLWtmM1xuICAgICAgICAgICAgLy8gZmluZCBrZjIgYW5kIGtmMyBhbmQgZG8gaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgdmFyIGZyYW1lO1xuICAgICAgICAgICAgLy8gSW4gdGhlIGVhc2luZyBmdW5jdGlvbiBsaWtlIGVsYXN0aWNPdXQsIHBlcmNlbnQgbWF5IGxlc3MgdGhhbiAwXG4gICAgICAgICAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgICAgICBmcmFtZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwZXJjZW50IDwgbGFzdEZyYW1lUGVyY2VudCkge1xuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGZyb20gbmV4dCBrZXlcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HIHN0YXJ0IGZyb20gbGFzdEZyYW1lID9cbiAgICAgICAgICAgICAgICBzdGFydCA9IE1hdGgubWluKGxhc3RGcmFtZSArIDEsIHRyYWNrTGVuIC0gMSk7XG4gICAgICAgICAgICAgICAgZm9yIChmcmFtZSA9IHN0YXJ0OyBmcmFtZSA+PSAwOyBmcmFtZS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZlBlcmNlbnRzW2ZyYW1lXSA8PSBwZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HIHJlYWxseSBuZWVkIHRvIGRvIHRoaXMgP1xuICAgICAgICAgICAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUsIHRyYWNrTGVuIC0gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGZyYW1lID0gbGFzdEZyYW1lOyBmcmFtZSA8IHRyYWNrTGVuOyBmcmFtZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZlBlcmNlbnRzW2ZyYW1lXSA+IHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUgLSAxLCB0cmFja0xlbiAtIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEZyYW1lID0gZnJhbWU7XG4gICAgICAgICAgICBsYXN0RnJhbWVQZXJjZW50ID0gcGVyY2VudDtcblxuICAgICAgICAgICAgdmFyIHJhbmdlID0gKGtmUGVyY2VudHNbZnJhbWUgKyAxXSAtIGtmUGVyY2VudHNbZnJhbWVdKTtcbiAgICAgICAgICAgIGlmIChyYW5nZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHcgPSAocGVyY2VudCAtIGtmUGVyY2VudHNbZnJhbWVdKSAvIHJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZVNwbGluZSkge1xuICAgICAgICAgICAgICAgIHAxID0ga2ZWYWx1ZXNbZnJhbWVdO1xuICAgICAgICAgICAgICAgIHAwID0ga2ZWYWx1ZXNbZnJhbWUgPT09IDAgPyBmcmFtZSA6IGZyYW1lIC0gMV07XG4gICAgICAgICAgICAgICAgcDIgPSBrZlZhbHVlc1tmcmFtZSA+IHRyYWNrTGVuIC0gMiA/IHRyYWNrTGVuIC0gMSA6IGZyYW1lICsgMV07XG4gICAgICAgICAgICAgICAgcDMgPSBrZlZhbHVlc1tmcmFtZSA+IHRyYWNrTGVuIC0gMyA/IHRyYWNrTGVuIC0gMSA6IGZyYW1lICsgMl07XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgIHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGVyKHRhcmdldCwgcHJvcE5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyRGltXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmdiYSwgMVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWx1ZVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlU3RyaW5nKHAxLCBwMiwgdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogd1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXR0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAga2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0dGVyKHRhcmdldCwgcHJvcE5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyRGltXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJnYmEsIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJnYmEyU3RyaW5nKHJnYmEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmluZyBpcyBzdGVwKDAuNSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVN0cmluZyhrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpbnRlcnBvbGF0ZU51bWJlcihrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNsaXAgPSBuZXcgQ2xpcCh7XG4gICAgICAgICAgICB0YXJnZXQ6IGFuaW1hdG9yLl90YXJnZXQsXG4gICAgICAgICAgICBsaWZlOiB0cmFja01heFRpbWUsXG4gICAgICAgICAgICBsb29wOiBhbmltYXRvci5fbG9vcCxcbiAgICAgICAgICAgIGRlbGF5OiBhbmltYXRvci5fZGVsYXksXG4gICAgICAgICAgICBvbmZyYW1lOiBvbmZyYW1lLFxuICAgICAgICAgICAgb25kZXN0cm95OiBvbmVUcmFja0RvbmVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGVhc2luZyAmJiBlYXNpbmcgIT09ICdzcGxpbmUnKSB7XG4gICAgICAgICAgICBjbGlwLmVhc2luZyA9IGVhc2luZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGlwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyXG4gICAgICovXG4gICAgdmFyIEFuaW1hdG9yID0gZnVuY3Rpb24odGFyZ2V0LCBsb29wLCBnZXR0ZXIsIHNldHRlcikge1xuICAgICAgICB0aGlzLl90cmFja3MgPSB7fTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgICAgIHRoaXMuX2xvb3AgPSBsb29wIHx8IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2dldHRlciA9IGdldHRlciB8fCBkZWZhdWx0R2V0dGVyO1xuICAgICAgICB0aGlzLl9zZXR0ZXIgPSBzZXR0ZXIgfHwgZGVmYXVsdFNldHRlcjtcblxuICAgICAgICB0aGlzLl9jbGlwQ291bnQgPSAwO1xuXG4gICAgICAgIHRoaXMuX2RlbGF5ID0gMDtcblxuICAgICAgICB0aGlzLl9kb25lTGlzdCA9IFtdO1xuXG4gICAgICAgIHRoaXMuX29uZnJhbWVMaXN0ID0gW107XG5cbiAgICAgICAgdGhpcy5fY2xpcExpc3QgPSBbXTtcbiAgICB9O1xuXG4gICAgQW5pbWF0b3IucHJvdG90eXBlID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5Yqo55S75YWz6ZSu5binXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDlhbPplK7luKfml7bpl7TvvIzljZXkvY3mmK9tc1xuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3BzIOWFs+mUruW4p+eahOWxnuaAp+WAvO+8jGtleS12YWx1ZeihqOekulxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICB3aGVuOiBmdW5jdGlvbih0aW1lIC8qIG1zICovLCBwcm9wcykge1xuICAgICAgICAgICAgdmFyIHRyYWNrcyA9IHRoaXMuX3RyYWNrcztcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0cmFja3NbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrc1twcm9wTmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9nZXR0ZXIodGhpcy5fdGFyZ2V0LCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB6ckxvZygnSW52YWxpZCBwcm9wZXJ0eSAnICsgcHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGltZSBpcyAwXG4gICAgICAgICAgICAgICAgICAgIC8vICBUaGVuIHByb3BzIGlzIGdpdmVuIGluaXRpYWxpemUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZVxuICAgICAgICAgICAgICAgICAgICAvLyAgSW5pdGlhbGl6ZSB2YWx1ZSBmcm9tIGN1cnJlbnQgcHJvcCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tzW3Byb3BOYW1lXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjbG9uZVZhbHVlKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhY2tzW3Byb3BOYW1lXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByb3BzW3Byb3BOYW1lXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDliqjnlLvmr4/kuIDluKfnmoTlm57osIPlh73mlbBcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIGR1cmluZzogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9vbmZyYW1lTGlzdC5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpcExpc3RbaV0ucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpcExpc3RbaV0ucmVzdW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc1BhdXNlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5fcGF1c2VkO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb25lQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIGFsbCB0cmFja3NcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrcyA9IHt9O1xuICAgICAgICAgICAgLy8gQ2xlYXIgYWxsIGNsaXBzXG4gICAgICAgICAgICB0aGlzLl9jbGlwTGlzdC5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICB2YXIgZG9uZUxpc3QgPSB0aGlzLl9kb25lTGlzdDtcbiAgICAgICAgICAgIHZhciBsZW4gPSBkb25lTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZG9uZUxpc3RbaV0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8gOWni+aJp+ihjOWKqOeUu1xuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd8RnVuY3Rpb259IFtlYXNpbmddXG4gICAgICAgICAqICAgICAgICAg5Yqo55S757yT5Yqo5Ye95pWw77yM6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmd9XG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGZvcmNlQW5pbWF0ZVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBzdGFydDogZnVuY3Rpb24gKGVhc2luZywgZm9yY2VBbmltYXRlKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjbGlwQ291bnQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgb25lVHJhY2tEb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2xpcENvdW50LS07XG4gICAgICAgICAgICAgICAgaWYgKCFjbGlwQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZG9uZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGxhc3RDbGlwO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdGhpcy5fdHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFja3MuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IGNyZWF0ZVRyYWNrQ2xpcChcbiAgICAgICAgICAgICAgICAgICAgdGhpcywgZWFzaW5nLCBvbmVUcmFja0RvbmUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrc1twcm9wTmFtZV0sIHByb3BOYW1lLCBmb3JjZUFuaW1hdGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsaXBMaXN0LnB1c2goY2xpcCk7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBDb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHN0YXJ0IGFmdGVyIGFkZGVkIHRvIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmFkZENsaXAoY2xpcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsYXN0Q2xpcCA9IGNsaXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgZHVyaW5nIGNhbGxiYWNrIG9uIHRoZSBsYXN0IGNsaXBcbiAgICAgICAgICAgIGlmIChsYXN0Q2xpcCkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRPbkZyYW1lID0gbGFzdENsaXAub25mcmFtZTtcbiAgICAgICAgICAgICAgICBsYXN0Q2xpcC5vbmZyYW1lID0gZnVuY3Rpb24gKHRhcmdldCwgcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRPbkZyYW1lKHRhcmdldCwgcGVyY2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl9vbmZyYW1lTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25mcmFtZUxpc3RbaV0odGFyZ2V0LCBwZXJjZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoaXMgb3B0aW1pemF0aW9uIHdpbGwgaGVscCB0aGUgY2FzZSB0aGF0IGluIHRoZSB1cHBlciBhcHBsaWNhdGlvblxuICAgICAgICAgICAgLy8gdGhlIHZpZXcgbWF5IGJlIHJlZnJlc2hlZCBmcmVxdWVudGx5LCB3aGVyZSBhbmltYXRpb24gd2lsbCBiZVxuICAgICAgICAgICAgLy8gY2FsbGVkIHJlcGVhdGx5IGJ1dCBub3RoaW5nIGNoYW5nZWQuXG4gICAgICAgICAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvbmVDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLliqjnlLtcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgIHZhciBjbGlwTGlzdCA9IHRoaXMuX2NsaXBMaXN0O1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbGlwID0gY2xpcExpc3RbaV07XG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAgICAgICAgICAgICAgICAgIGNsaXAub25mcmFtZSh0aGlzLl90YXJnZXQsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnJlbW92ZUNsaXAoY2xpcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGlwTGlzdC5sZW5ndGggPSAwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5Yqo55S75bu26L+f5byA5aeL55qE5pe26Ze0XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDljZXkvY1tc1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkZWxheTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5ID0gdGltZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5Yqo55S757uT5p2f55qE5Zue6LCDXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkb25lOiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9uZUxpc3QucHVzaChjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldENsaXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xpcExpc3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBbmltYXRvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIOWKqOeUu+S4u+aOp+WItuWZqFxuICogQGNvbmZpZyB0YXJnZXQg5Yqo55S75a+56LGh77yM5Y+v5Lul5piv5pWw57uE77yM5aaC5p6c5piv5pWw57uE55qE6K+d5Lya5om56YeP5YiG5Y+Rb25mcmFtZeetieS6i+S7tlxuICogQGNvbmZpZyBsaWZlKDEwMDApIOWKqOeUu+aXtumVv1xuICogQGNvbmZpZyBkZWxheSgwKSDliqjnlLvlu7bov5/ml7bpl7RcbiAqIEBjb25maWcgbG9vcCh0cnVlKVxuICogQGNvbmZpZyBnYXAoMCkg5b6q546v55qE6Ze06ZqU5pe26Ze0XG4gKiBAY29uZmlnIG9uZnJhbWVcbiAqIEBjb25maWcgZWFzaW5nKG9wdGlvbmFsKVxuICogQGNvbmZpZyBvbmRlc3Ryb3kob3B0aW9uYWwpXG4gKiBAY29uZmlnIG9ucmVzdGFydChvcHRpb25hbClcbiAqXG4gKiBUT0RPIHBhdXNlXG4gKi9cblxuXG4gICAgdmFyIGVhc2luZ0Z1bmNzID0gcmVxdWlyZSgnLi9lYXNpbmcnKTtcblxuICAgIGZ1bmN0aW9uIENsaXAob3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuXG4gICAgICAgIC8vIOeUn+WRveWRqOacn1xuICAgICAgICB0aGlzLl9saWZlID0gb3B0aW9ucy5saWZlIHx8IDEwMDA7XG4gICAgICAgIC8vIOW7tuaXtlxuICAgICAgICB0aGlzLl9kZWxheSA9IG9wdGlvbnMuZGVsYXkgfHwgMDtcbiAgICAgICAgLy8g5byA5aeL5pe26Ze0XG4gICAgICAgIC8vIHRoaXMuX3N0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgdGhpcy5fZGVsYXk7Ly8g5Y2V5L2N5q+r56eSXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8g5piv5ZCm5b6q546vXG4gICAgICAgIHRoaXMubG9vcCA9IG9wdGlvbnMubG9vcCA9PSBudWxsID8gZmFsc2UgOiBvcHRpb25zLmxvb3A7XG5cbiAgICAgICAgdGhpcy5nYXAgPSBvcHRpb25zLmdhcCB8fCAwO1xuXG4gICAgICAgIHRoaXMuZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcgfHwgJ0xpbmVhcic7XG5cbiAgICAgICAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lO1xuICAgICAgICB0aGlzLm9uZGVzdHJveSA9IG9wdGlvbnMub25kZXN0cm95O1xuICAgICAgICB0aGlzLm9ucmVzdGFydCA9IG9wdGlvbnMub25yZXN0YXJ0O1xuXG4gICAgICAgIHRoaXMuX3BhdXNlZFRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBDbGlwLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQ2xpcCxcblxuICAgICAgICBzdGVwOiBmdW5jdGlvbiAoZ2xvYmFsVGltZSwgZGVsdGFUaW1lKSB7XG4gICAgICAgICAgICAvLyBTZXQgc3RhcnRUaW1lIG9uIGZpcnN0IHN0ZXAsIG9yIF9zdGFydFRpbWUgbWF5IGhhcyBtaWxsZXNlY29uZHMgZGlmZmVyZW50IGJldHdlZW4gY2xpcHNcbiAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lICsgdGhpcy5fZGVsYXk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2VkVGltZSArPSBkZWx0YVRpbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGVyY2VudCA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fcGF1c2VkVGltZSkgLyB0aGlzLl9saWZlO1xuXG4gICAgICAgICAgICAvLyDov5jmsqHlvIDlp4tcbiAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGVyY2VudCA9IE1hdGgubWluKHBlcmNlbnQsIDEpO1xuXG4gICAgICAgICAgICB2YXIgZWFzaW5nID0gdGhpcy5lYXNpbmc7XG4gICAgICAgICAgICB2YXIgZWFzaW5nRnVuYyA9IHR5cGVvZiBlYXNpbmcgPT0gJ3N0cmluZycgPyBlYXNpbmdGdW5jc1tlYXNpbmddIDogZWFzaW5nO1xuICAgICAgICAgICAgdmFyIHNjaGVkdWxlID0gdHlwZW9mIGVhc2luZ0Z1bmMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IGVhc2luZ0Z1bmMocGVyY2VudClcbiAgICAgICAgICAgICAgICA6IHBlcmNlbnQ7XG5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZnJhbWUnLCBzY2hlZHVsZSk7XG5cbiAgICAgICAgICAgIC8vIOe7k+adn1xuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0YXJ0IChnbG9iYWxUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8g6YeN5paw5byA5aeL5ZGo5pyfXG4gICAgICAgICAgICAgICAgICAgIC8vIOaKm+WHuuiAjOS4jeaYr+ebtOaOpeiwg+eUqOS6i+S7tuebtOWIsCBzdGFnZS51cGRhdGUg5ZCO5YaN57uf5LiA6LCD55So6L+Z5Lqb5LqL5Lu2XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAncmVzdGFydCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8g5Yqo55S75a6M5oiQ5bCG6L+Z5Liq5o6n5Yi25Zmo5qCH6K+G5Li65b6F5Yig6ZmkXG4gICAgICAgICAgICAgICAgLy8g5ZyoQW5pbWF0aW9uLnVwZGF0ZeS4rei/m+ihjOaJuemHj+WIoOmZpFxuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzUmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Rlc3Ryb3knO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICByZXN0YXJ0OiBmdW5jdGlvbiAoZ2xvYmFsVGltZSkge1xuICAgICAgICAgICAgdmFyIHJlbWFpbmRlciA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fcGF1c2VkVGltZSkgJSB0aGlzLl9saWZlO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gZ2xvYmFsVGltZSAtIHJlbWFpbmRlciArIHRoaXMuZ2FwO1xuICAgICAgICAgICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVtb3ZlID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlyZTogZnVuY3Rpb24gKGV2ZW50VHlwZSwgYXJnKSB7XG4gICAgICAgICAgICBldmVudFR5cGUgPSAnb24nICsgZXZlbnRUeXBlO1xuICAgICAgICAgICAgaWYgKHRoaXNbZXZlbnRUeXBlXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbZXZlbnRUeXBlXSh0aGlzLl90YXJnZXQsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENsaXA7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICog57yT5Yqo5Luj56CB5p2l6IeqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xlL3R3ZWVuLmpzL2Jsb2IvbWFzdGVyL3NyYy9Ud2Vlbi5qc1xuICogQHNlZSBodHRwOi8vc29sZS5naXRodWIuaW8vdHdlZW4uanMvZXhhbXBsZXMvMDNfZ3JhcGhzLmh0bWxcbiAqIEBleHBvcnRzIHpyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZ1xuICovXG5cbiAgICB2YXIgZWFzaW5nID0ge1xuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgbGluZWFyOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YWRyYXRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhZHJhdGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiAoMiAtIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhZHJhdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOS4ieasoeaWueeahOe8k+WKqO+8iHReM++8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY3ViaWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogayAqIGs7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjdWJpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAtLWsgKiBrICogayArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjdWJpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDlm5vmrKHmlrnnmoTnvJPliqjvvIh0XjTvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YXJ0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogayAqIGsgKiBrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhcnRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gKC0tayAqIGsgKiBrICogayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFydGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAtIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOS6lOasoeaWueeahOe8k+WKqO+8iHReNe+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVpbnRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrICogayAqIGsgKiBrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVpbnRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1aW50aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKiBrICogayArIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOato+W8puabsue6v+eahOe8k+WKqO+8iHNpbih0Ke+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgc2ludXNvaWRhbEluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcyhrICogTWF0aC5QSSAvIDIpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgc2ludXNvaWRhbE91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNpbihrICogTWF0aC5QSSAvIDIpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgc2ludXNvaWRhbEluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDmjIfmlbDmm7Lnur/nmoTnvJPliqjvvIgyXnTvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGV4cG9uZW50aWFsSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayA9PT0gMCA/IDAgOiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBleHBvbmVudGlhbE91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdygyLCAtMTAgKiBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGV4cG9uZW50aWFsSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKGsgLSAxKSkgKyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDlnIblvaLmm7Lnur/nmoTnvJPliqjvvIhzcXJ0KDEtdF4yKe+8iVxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY2lyY3VsYXJJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBrICogayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjaXJjdWxhck91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoMSAtICgtLWsgKiBrKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBjaXJjdWxhckluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gayAqIGspIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKGsgLT0gMikgKiBrKSArIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWIm+W7uuexu+S8vOS6juW8ueewp+WcqOWBnOatouWJjeadpeWbnuaMr+iNoeeahOWKqOeUu1xuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZWxhc3RpY0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHM7XG4gICAgICAgICAgICB2YXIgYSA9IDAuMTtcbiAgICAgICAgICAgIHZhciBwID0gMC40O1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgICAgICAgICAgICBhID0gMTsgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGVsYXN0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcztcbiAgICAgICAgICAgIHZhciBhID0gMC4xO1xuICAgICAgICAgICAgdmFyIHAgPSAwLjQ7XG4gICAgICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgICAgICAgICAgIGEgPSAxOyBzID0gcCAvIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChhICogTWF0aC5wb3coMiwgLTEwICogaykgKlxuICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBlbGFzdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcztcbiAgICAgICAgICAgIHZhciBhID0gMC4xO1xuICAgICAgICAgICAgdmFyIHAgPSAwLjQ7XG4gICAgICAgICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgICAgICAgICAgIGEgPSAxOyBzID0gcCAvIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKVxuICAgICAgICAgICAgICAgICAgICAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiAoayAtPSAxKSlcbiAgICAgICAgICAgICAgICAgICAgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICogMC41ICsgMTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWcqOafkOS4gOWKqOeUu+W8gOWni+ayv+aMh+ekuueahOi3r+W+hOi/m+ihjOWKqOeUu+WkhOeQhuWJjeeojeeojeaUtuWbnuivpeWKqOeUu+eahOenu+WKqFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYmFja0luOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICAgICAgcmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBiYWNrT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICAgICAgcmV0dXJuIC0tayAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBiYWNrSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTggKiAxLjUyNTtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrIC0gcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIOWIm+W7uuW8uei3s+aViOaenFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYm91bmNlSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIGVhc2luZy5ib3VuY2VPdXQoMSAtIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYm91bmNlT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgPCAoMSAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoayA8ICgyIC8gMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gKDEuNSAvIDIuNzUpKSAqIGsgKyAwLjc1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoayA8ICgyLjUgLyAyLjc1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAoMi4yNSAvIDIuNzUpKSAqIGsgKyAwLjkzNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gKDIuNjI1IC8gMi43NSkpICogayArIDAuOTg0Mzc1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYm91bmNlSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoayA8IDAuNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlYXNpbmcuYm91bmNlSW4oayAqIDIpICogMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVhc2luZy5ib3VuY2VPdXQoayAqIDIgLSAxKSAqIDAuNSArIDAuNTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVhc2luZztcblxuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL3Rvb2wvY29sb3JcbiAqL1xuXG5cbiAgICB2YXIgTFJVID0gcmVxdWlyZSgnLi4vY29yZS9MUlUnKTtcblxuICAgIHZhciBrQ1NTQ29sb3JUYWJsZSA9IHtcbiAgICAgICAgJ3RyYW5zcGFyZW50JzogWzAsMCwwLDBdLCAnYWxpY2VibHVlJzogWzI0MCwyNDgsMjU1LDFdLFxuICAgICAgICAnYW50aXF1ZXdoaXRlJzogWzI1MCwyMzUsMjE1LDFdLCAnYXF1YSc6IFswLDI1NSwyNTUsMV0sXG4gICAgICAgICdhcXVhbWFyaW5lJzogWzEyNywyNTUsMjEyLDFdLCAnYXp1cmUnOiBbMjQwLDI1NSwyNTUsMV0sXG4gICAgICAgICdiZWlnZSc6IFsyNDUsMjQ1LDIyMCwxXSwgJ2Jpc3F1ZSc6IFsyNTUsMjI4LDE5NiwxXSxcbiAgICAgICAgJ2JsYWNrJzogWzAsMCwwLDFdLCAnYmxhbmNoZWRhbG1vbmQnOiBbMjU1LDIzNSwyMDUsMV0sXG4gICAgICAgICdibHVlJzogWzAsMCwyNTUsMV0sICdibHVldmlvbGV0JzogWzEzOCw0MywyMjYsMV0sXG4gICAgICAgICdicm93bic6IFsxNjUsNDIsNDIsMV0sICdidXJseXdvb2QnOiBbMjIyLDE4NCwxMzUsMV0sXG4gICAgICAgICdjYWRldGJsdWUnOiBbOTUsMTU4LDE2MCwxXSwgJ2NoYXJ0cmV1c2UnOiBbMTI3LDI1NSwwLDFdLFxuICAgICAgICAnY2hvY29sYXRlJzogWzIxMCwxMDUsMzAsMV0sICdjb3JhbCc6IFsyNTUsMTI3LDgwLDFdLFxuICAgICAgICAnY29ybmZsb3dlcmJsdWUnOiBbMTAwLDE0OSwyMzcsMV0sICdjb3Juc2lsayc6IFsyNTUsMjQ4LDIyMCwxXSxcbiAgICAgICAgJ2NyaW1zb24nOiBbMjIwLDIwLDYwLDFdLCAnY3lhbic6IFswLDI1NSwyNTUsMV0sXG4gICAgICAgICdkYXJrYmx1ZSc6IFswLDAsMTM5LDFdLCAnZGFya2N5YW4nOiBbMCwxMzksMTM5LDFdLFxuICAgICAgICAnZGFya2dvbGRlbnJvZCc6IFsxODQsMTM0LDExLDFdLCAnZGFya2dyYXknOiBbMTY5LDE2OSwxNjksMV0sXG4gICAgICAgICdkYXJrZ3JlZW4nOiBbMCwxMDAsMCwxXSwgJ2RhcmtncmV5JzogWzE2OSwxNjksMTY5LDFdLFxuICAgICAgICAnZGFya2toYWtpJzogWzE4OSwxODMsMTA3LDFdLCAnZGFya21hZ2VudGEnOiBbMTM5LDAsMTM5LDFdLFxuICAgICAgICAnZGFya29saXZlZ3JlZW4nOiBbODUsMTA3LDQ3LDFdLCAnZGFya29yYW5nZSc6IFsyNTUsMTQwLDAsMV0sXG4gICAgICAgICdkYXJrb3JjaGlkJzogWzE1Myw1MCwyMDQsMV0sICdkYXJrcmVkJzogWzEzOSwwLDAsMV0sXG4gICAgICAgICdkYXJrc2FsbW9uJzogWzIzMywxNTAsMTIyLDFdLCAnZGFya3NlYWdyZWVuJzogWzE0MywxODgsMTQzLDFdLFxuICAgICAgICAnZGFya3NsYXRlYmx1ZSc6IFs3Miw2MSwxMzksMV0sICdkYXJrc2xhdGVncmF5JzogWzQ3LDc5LDc5LDFdLFxuICAgICAgICAnZGFya3NsYXRlZ3JleSc6IFs0Nyw3OSw3OSwxXSwgJ2Rhcmt0dXJxdW9pc2UnOiBbMCwyMDYsMjA5LDFdLFxuICAgICAgICAnZGFya3Zpb2xldCc6IFsxNDgsMCwyMTEsMV0sICdkZWVwcGluayc6IFsyNTUsMjAsMTQ3LDFdLFxuICAgICAgICAnZGVlcHNreWJsdWUnOiBbMCwxOTEsMjU1LDFdLCAnZGltZ3JheSc6IFsxMDUsMTA1LDEwNSwxXSxcbiAgICAgICAgJ2RpbWdyZXknOiBbMTA1LDEwNSwxMDUsMV0sICdkb2RnZXJibHVlJzogWzMwLDE0NCwyNTUsMV0sXG4gICAgICAgICdmaXJlYnJpY2snOiBbMTc4LDM0LDM0LDFdLCAnZmxvcmFsd2hpdGUnOiBbMjU1LDI1MCwyNDAsMV0sXG4gICAgICAgICdmb3Jlc3RncmVlbic6IFszNCwxMzksMzQsMV0sICdmdWNoc2lhJzogWzI1NSwwLDI1NSwxXSxcbiAgICAgICAgJ2dhaW5zYm9ybyc6IFsyMjAsMjIwLDIyMCwxXSwgJ2dob3N0d2hpdGUnOiBbMjQ4LDI0OCwyNTUsMV0sXG4gICAgICAgICdnb2xkJzogWzI1NSwyMTUsMCwxXSwgJ2dvbGRlbnJvZCc6IFsyMTgsMTY1LDMyLDFdLFxuICAgICAgICAnZ3JheSc6IFsxMjgsMTI4LDEyOCwxXSwgJ2dyZWVuJzogWzAsMTI4LDAsMV0sXG4gICAgICAgICdncmVlbnllbGxvdyc6IFsxNzMsMjU1LDQ3LDFdLCAnZ3JleSc6IFsxMjgsMTI4LDEyOCwxXSxcbiAgICAgICAgJ2hvbmV5ZGV3JzogWzI0MCwyNTUsMjQwLDFdLCAnaG90cGluayc6IFsyNTUsMTA1LDE4MCwxXSxcbiAgICAgICAgJ2luZGlhbnJlZCc6IFsyMDUsOTIsOTIsMV0sICdpbmRpZ28nOiBbNzUsMCwxMzAsMV0sXG4gICAgICAgICdpdm9yeSc6IFsyNTUsMjU1LDI0MCwxXSwgJ2toYWtpJzogWzI0MCwyMzAsMTQwLDFdLFxuICAgICAgICAnbGF2ZW5kZXInOiBbMjMwLDIzMCwyNTAsMV0sICdsYXZlbmRlcmJsdXNoJzogWzI1NSwyNDAsMjQ1LDFdLFxuICAgICAgICAnbGF3bmdyZWVuJzogWzEyNCwyNTIsMCwxXSwgJ2xlbW9uY2hpZmZvbic6IFsyNTUsMjUwLDIwNSwxXSxcbiAgICAgICAgJ2xpZ2h0Ymx1ZSc6IFsxNzMsMjE2LDIzMCwxXSwgJ2xpZ2h0Y29yYWwnOiBbMjQwLDEyOCwxMjgsMV0sXG4gICAgICAgICdsaWdodGN5YW4nOiBbMjI0LDI1NSwyNTUsMV0sICdsaWdodGdvbGRlbnJvZHllbGxvdyc6IFsyNTAsMjUwLDIxMCwxXSxcbiAgICAgICAgJ2xpZ2h0Z3JheSc6IFsyMTEsMjExLDIxMSwxXSwgJ2xpZ2h0Z3JlZW4nOiBbMTQ0LDIzOCwxNDQsMV0sXG4gICAgICAgICdsaWdodGdyZXknOiBbMjExLDIxMSwyMTEsMV0sICdsaWdodHBpbmsnOiBbMjU1LDE4MiwxOTMsMV0sXG4gICAgICAgICdsaWdodHNhbG1vbic6IFsyNTUsMTYwLDEyMiwxXSwgJ2xpZ2h0c2VhZ3JlZW4nOiBbMzIsMTc4LDE3MCwxXSxcbiAgICAgICAgJ2xpZ2h0c2t5Ymx1ZSc6IFsxMzUsMjA2LDI1MCwxXSwgJ2xpZ2h0c2xhdGVncmF5JzogWzExOSwxMzYsMTUzLDFdLFxuICAgICAgICAnbGlnaHRzbGF0ZWdyZXknOiBbMTE5LDEzNiwxNTMsMV0sICdsaWdodHN0ZWVsYmx1ZSc6IFsxNzYsMTk2LDIyMiwxXSxcbiAgICAgICAgJ2xpZ2h0eWVsbG93JzogWzI1NSwyNTUsMjI0LDFdLCAnbGltZSc6IFswLDI1NSwwLDFdLFxuICAgICAgICAnbGltZWdyZWVuJzogWzUwLDIwNSw1MCwxXSwgJ2xpbmVuJzogWzI1MCwyNDAsMjMwLDFdLFxuICAgICAgICAnbWFnZW50YSc6IFsyNTUsMCwyNTUsMV0sICdtYXJvb24nOiBbMTI4LDAsMCwxXSxcbiAgICAgICAgJ21lZGl1bWFxdWFtYXJpbmUnOiBbMTAyLDIwNSwxNzAsMV0sICdtZWRpdW1ibHVlJzogWzAsMCwyMDUsMV0sXG4gICAgICAgICdtZWRpdW1vcmNoaWQnOiBbMTg2LDg1LDIxMSwxXSwgJ21lZGl1bXB1cnBsZSc6IFsxNDcsMTEyLDIxOSwxXSxcbiAgICAgICAgJ21lZGl1bXNlYWdyZWVuJzogWzYwLDE3OSwxMTMsMV0sICdtZWRpdW1zbGF0ZWJsdWUnOiBbMTIzLDEwNCwyMzgsMV0sXG4gICAgICAgICdtZWRpdW1zcHJpbmdncmVlbic6IFswLDI1MCwxNTQsMV0sICdtZWRpdW10dXJxdW9pc2UnOiBbNzIsMjA5LDIwNCwxXSxcbiAgICAgICAgJ21lZGl1bXZpb2xldHJlZCc6IFsxOTksMjEsMTMzLDFdLCAnbWlkbmlnaHRibHVlJzogWzI1LDI1LDExMiwxXSxcbiAgICAgICAgJ21pbnRjcmVhbSc6IFsyNDUsMjU1LDI1MCwxXSwgJ21pc3R5cm9zZSc6IFsyNTUsMjI4LDIyNSwxXSxcbiAgICAgICAgJ21vY2Nhc2luJzogWzI1NSwyMjgsMTgxLDFdLCAnbmF2YWpvd2hpdGUnOiBbMjU1LDIyMiwxNzMsMV0sXG4gICAgICAgICduYXZ5JzogWzAsMCwxMjgsMV0sICdvbGRsYWNlJzogWzI1MywyNDUsMjMwLDFdLFxuICAgICAgICAnb2xpdmUnOiBbMTI4LDEyOCwwLDFdLCAnb2xpdmVkcmFiJzogWzEwNywxNDIsMzUsMV0sXG4gICAgICAgICdvcmFuZ2UnOiBbMjU1LDE2NSwwLDFdLCAnb3JhbmdlcmVkJzogWzI1NSw2OSwwLDFdLFxuICAgICAgICAnb3JjaGlkJzogWzIxOCwxMTIsMjE0LDFdLCAncGFsZWdvbGRlbnJvZCc6IFsyMzgsMjMyLDE3MCwxXSxcbiAgICAgICAgJ3BhbGVncmVlbic6IFsxNTIsMjUxLDE1MiwxXSwgJ3BhbGV0dXJxdW9pc2UnOiBbMTc1LDIzOCwyMzgsMV0sXG4gICAgICAgICdwYWxldmlvbGV0cmVkJzogWzIxOSwxMTIsMTQ3LDFdLCAncGFwYXlhd2hpcCc6IFsyNTUsMjM5LDIxMywxXSxcbiAgICAgICAgJ3BlYWNocHVmZic6IFsyNTUsMjE4LDE4NSwxXSwgJ3BlcnUnOiBbMjA1LDEzMyw2MywxXSxcbiAgICAgICAgJ3BpbmsnOiBbMjU1LDE5MiwyMDMsMV0sICdwbHVtJzogWzIyMSwxNjAsMjIxLDFdLFxuICAgICAgICAncG93ZGVyYmx1ZSc6IFsxNzYsMjI0LDIzMCwxXSwgJ3B1cnBsZSc6IFsxMjgsMCwxMjgsMV0sXG4gICAgICAgICdyZWQnOiBbMjU1LDAsMCwxXSwgJ3Jvc3licm93bic6IFsxODgsMTQzLDE0MywxXSxcbiAgICAgICAgJ3JveWFsYmx1ZSc6IFs2NSwxMDUsMjI1LDFdLCAnc2FkZGxlYnJvd24nOiBbMTM5LDY5LDE5LDFdLFxuICAgICAgICAnc2FsbW9uJzogWzI1MCwxMjgsMTE0LDFdLCAnc2FuZHlicm93bic6IFsyNDQsMTY0LDk2LDFdLFxuICAgICAgICAnc2VhZ3JlZW4nOiBbNDYsMTM5LDg3LDFdLCAnc2Vhc2hlbGwnOiBbMjU1LDI0NSwyMzgsMV0sXG4gICAgICAgICdzaWVubmEnOiBbMTYwLDgyLDQ1LDFdLCAnc2lsdmVyJzogWzE5MiwxOTIsMTkyLDFdLFxuICAgICAgICAnc2t5Ymx1ZSc6IFsxMzUsMjA2LDIzNSwxXSwgJ3NsYXRlYmx1ZSc6IFsxMDYsOTAsMjA1LDFdLFxuICAgICAgICAnc2xhdGVncmF5JzogWzExMiwxMjgsMTQ0LDFdLCAnc2xhdGVncmV5JzogWzExMiwxMjgsMTQ0LDFdLFxuICAgICAgICAnc25vdyc6IFsyNTUsMjUwLDI1MCwxXSwgJ3NwcmluZ2dyZWVuJzogWzAsMjU1LDEyNywxXSxcbiAgICAgICAgJ3N0ZWVsYmx1ZSc6IFs3MCwxMzAsMTgwLDFdLCAndGFuJzogWzIxMCwxODAsMTQwLDFdLFxuICAgICAgICAndGVhbCc6IFswLDEyOCwxMjgsMV0sICd0aGlzdGxlJzogWzIxNiwxOTEsMjE2LDFdLFxuICAgICAgICAndG9tYXRvJzogWzI1NSw5OSw3MSwxXSwgJ3R1cnF1b2lzZSc6IFs2NCwyMjQsMjA4LDFdLFxuICAgICAgICAndmlvbGV0JzogWzIzOCwxMzAsMjM4LDFdLCAnd2hlYXQnOiBbMjQ1LDIyMiwxNzksMV0sXG4gICAgICAgICd3aGl0ZSc6IFsyNTUsMjU1LDI1NSwxXSwgJ3doaXRlc21va2UnOiBbMjQ1LDI0NSwyNDUsMV0sXG4gICAgICAgICd5ZWxsb3cnOiBbMjU1LDI1NSwwLDFdLCAneWVsbG93Z3JlZW4nOiBbMTU0LDIwNSw1MCwxXVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjbGFtcENzc0J5dGUoaSkgeyAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDI1NS5cbiAgICAgICAgaSA9IE1hdGgucm91bmQoaSk7ICAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cbiAgICAgICAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAyNTUgPyAyNTUgOiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsYW1wQ3NzQW5nbGUoaSkgeyAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDM2MC5cbiAgICAgICAgaSA9IE1hdGgucm91bmQoaSk7ICAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cbiAgICAgICAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAzNjAgPyAzNjAgOiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsYW1wQ3NzRmxvYXQoZikgeyAgLy8gQ2xhbXAgdG8gZmxvYXQgMC4wIC4uIDEuMC5cbiAgICAgICAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDc3NJbnQoc3RyKSB7ICAvLyBpbnQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgICAgICAgICAgcmV0dXJuIGNsYW1wQ3NzQnl0ZShwYXJzZUZsb2F0KHN0cikgLyAxMDAgKiAyNTUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VJbnQoc3RyLCAxMCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ3NzRmxvYXQoc3RyKSB7ICAvLyBmbG9hdCBvciBwZXJjZW50YWdlLlxuICAgICAgICBpZiAoc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhbXBDc3NGbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFtcENzc0Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3NzSHVlVG9SZ2IobTEsIG0yLCBoKSB7XG4gICAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICAgICAgaCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGggPiAxKSB7XG4gICAgICAgICAgICBoIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaCAqIDYgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaCAqIDIgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGggKiAzIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIvMyAtIGgpICogNjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGVycE51bWJlcihhLCBiLCBwKSB7XG4gICAgICAgIHJldHVybiBhICsgKGIgLSBhKSAqIHA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0UmdiYShvdXQsIHIsIGcsIGIsIGEpIHtcbiAgICAgICAgb3V0WzBdID0gcjsgb3V0WzFdID0gZzsgb3V0WzJdID0gYjsgb3V0WzNdID0gYTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVJnYmEob3V0LCBhKSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07IG91dFsxXSA9IGFbMV07IG91dFsyXSA9IGFbMl07IG91dFszXSA9IGFbM107XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHZhciBjb2xvckNhY2hlID0gbmV3IExSVSgyMCk7XG4gICAgdmFyIGxhc3RSZW1vdmVkQXJyID0gbnVsbDtcbiAgICBmdW5jdGlvbiBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKSB7XG4gICAgICAgIC8vIFJldXNlIHJlbW92ZWQgYXJyYXlcbiAgICAgICAgaWYgKGxhc3RSZW1vdmVkQXJyKSB7XG4gICAgICAgICAgICBjb3B5UmdiYShsYXN0UmVtb3ZlZEFyciwgcmdiYUFycik7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFJlbW92ZWRBcnIgPSBjb2xvckNhY2hlLnB1dChjb2xvclN0ciwgbGFzdFJlbW92ZWRBcnIgfHwgKHJnYmFBcnIuc2xpY2UoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JTdHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlKGNvbG9yU3RyLCByZ2JhQXJyKSB7XG4gICAgICAgIGlmICghY29sb3JTdHIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZ2JhQXJyID0gcmdiYUFyciB8fCBbXTtcblxuICAgICAgICB2YXIgY2FjaGVkID0gY29sb3JDYWNoZS5nZXQoY29sb3JTdHIpO1xuICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29weVJnYmEocmdiYUFyciwgY2FjaGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbG9yU3RyIG1heSBiZSBub3Qgc3RyaW5nXG4gICAgICAgIGNvbG9yU3RyID0gY29sb3JTdHIgKyAnJztcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG4gICAgICAgIHZhciBzdHIgPSBjb2xvclN0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIC8vIENvbG9yIGtleXdvcmRzIChhbmQgdHJhbnNwYXJlbnQpIGxvb2t1cC5cbiAgICAgICAgaWYgKHN0ciBpbiBrQ1NTQ29sb3JUYWJsZSkge1xuICAgICAgICAgICAgY29weVJnYmEocmdiYUFyciwga0NTU0NvbG9yVGFibGVbc3RyXSk7XG4gICAgICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguXG4gICAgICAgIGlmIChzdHIuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICAgICAgICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLFxuICAgICAgICAgICAgICAgICAgICAoKGl2ICYgMHhmMDApID4+IDQpIHwgKChpdiAmIDB4ZjAwKSA+PiA4KSxcbiAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmMCkgfCAoKGl2ICYgMHhmMCkgPj4gNCksXG4gICAgICAgICAgICAgICAgICAgIChpdiAmIDB4ZikgfCAoKGl2ICYgMHhmKSA8PCA0KSxcbiAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICAgICAgICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLFxuICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGZmMDAwMCkgPj4gMTYsXG4gICAgICAgICAgICAgICAgICAgIChpdiAmIDB4ZmYwMCkgPj4gOCxcbiAgICAgICAgICAgICAgICAgICAgaXYgJiAweGZmLFxuICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmdiYUFycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcCA9IHN0ci5pbmRleE9mKCcoJyksIGVwID0gc3RyLmluZGV4T2YoJyknKTtcbiAgICAgICAgaWYgKG9wICE9PSAtMSAmJiBlcCArIDEgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3AgKyAxLCBlcCAtIChvcCArIDEpKS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgdmFyIGFscGhhID0gMTsgIC8vIFRvIGFsbG93IGNhc2UgZmFsbHRocm91Z2guXG4gICAgICAgICAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFscGhhID0gcGFyc2VDc3NGbG9hdChwYXJhbXMucG9wKCkpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICAgICAgICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VDc3NJbnQocGFyYW1zWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQ3NzSW50KHBhcmFtc1sxXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUNzc0ludChwYXJhbXNbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGFcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZ2JhQXJyO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hzbGEnOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbM10gPSBwYXJzZUNzc0Zsb2F0KHBhcmFtc1szXSk7XG4gICAgICAgICAgICAgICAgICAgIGhzbGEycmdiYShwYXJhbXMsIHJnYmFBcnIpO1xuICAgICAgICAgICAgICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgICAgICAgICAgICAgY2FzZSAnaHNsJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaHNsYTJyZ2JhKHBhcmFtcywgcmdiYUFycik7XG4gICAgICAgICAgICAgICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmdiYUFycjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaHNsYVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhzbGEycmdiYShoc2xhLCByZ2JhKSB7XG4gICAgICAgIHZhciBoID0gKCgocGFyc2VGbG9hdChoc2xhWzBdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MDsgIC8vIDAgLi4gMVxuICAgICAgICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgICAgICAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuICAgICAgICB2YXIgcyA9IHBhcnNlQ3NzRmxvYXQoaHNsYVsxXSk7XG4gICAgICAgIHZhciBsID0gcGFyc2VDc3NGbG9hdChoc2xhWzJdKTtcbiAgICAgICAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBtMSA9IGwgKiAyIC0gbTI7XG5cbiAgICAgICAgcmdiYSA9IHJnYmEgfHwgW107XG4gICAgICAgIHNldFJnYmEocmdiYSxcbiAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGggKyAxIC8gMykgKiAyNTUpLFxuICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkgKiAyNTUpLFxuICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCAtIDEgLyAzKSAqIDI1NSksXG4gICAgICAgICAgICAxXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGhzbGEubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICByZ2JhWzNdID0gaHNsYVszXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZ2JhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gaHNsYVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJnYmEyaHNsYShyZ2JhKSB7XG4gICAgICAgIGlmICghcmdiYSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUkdCIGZyb20gMCB0byAyNTVcbiAgICAgICAgdmFyIFIgPSByZ2JhWzBdIC8gMjU1O1xuICAgICAgICB2YXIgRyA9IHJnYmFbMV0gLyAyNTU7XG4gICAgICAgIHZhciBCID0gcmdiYVsyXSAvIDI1NTtcblxuICAgICAgICB2YXIgdk1pbiA9IE1hdGgubWluKFIsIEcsIEIpOyAvLyBNaW4uIHZhbHVlIG9mIFJHQlxuICAgICAgICB2YXIgdk1heCA9IE1hdGgubWF4KFIsIEcsIEIpOyAvLyBNYXguIHZhbHVlIG9mIFJHQlxuICAgICAgICB2YXIgZGVsdGEgPSB2TWF4IC0gdk1pbjsgLy8gRGVsdGEgUkdCIHZhbHVlXG5cbiAgICAgICAgdmFyIEwgPSAodk1heCArIHZNaW4pIC8gMjtcbiAgICAgICAgdmFyIEg7XG4gICAgICAgIHZhciBTO1xuICAgICAgICAvLyBIU0wgcmVzdWx0cyBmcm9tIDAgdG8gMVxuICAgICAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgICAgICAgIEggPSAwO1xuICAgICAgICAgICAgUyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoTCA8IDAuNSkge1xuICAgICAgICAgICAgICAgIFMgPSBkZWx0YSAvICh2TWF4ICsgdk1pbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBTID0gZGVsdGEgLyAoMiAtIHZNYXggLSB2TWluKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRlbHRhUiA9ICgoKHZNYXggLSBSKSAvIDYpICsgKGRlbHRhIC8gMikpIC8gZGVsdGE7XG4gICAgICAgICAgICB2YXIgZGVsdGFHID0gKCgodk1heCAtIEcpIC8gNikgKyAoZGVsdGEgLyAyKSkgLyBkZWx0YTtcbiAgICAgICAgICAgIHZhciBkZWx0YUIgPSAoKCh2TWF4IC0gQikgLyA2KSArIChkZWx0YSAvIDIpKSAvIGRlbHRhO1xuXG4gICAgICAgICAgICBpZiAoUiA9PT0gdk1heCkge1xuICAgICAgICAgICAgICAgIEggPSBkZWx0YUIgLSBkZWx0YUc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChHID09PSB2TWF4KSB7XG4gICAgICAgICAgICAgICAgSCA9ICgxIC8gMykgKyBkZWx0YVIgLSBkZWx0YUI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChCID09PSB2TWF4KSB7XG4gICAgICAgICAgICAgICAgSCA9ICgyIC8gMykgKyBkZWx0YUcgLSBkZWx0YVI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChIIDwgMCkge1xuICAgICAgICAgICAgICAgIEggKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEggPiAxKSB7XG4gICAgICAgICAgICAgICAgSCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhzbGEgPSBbSCAqIDM2MCwgUywgTF07XG5cbiAgICAgICAgaWYgKHJnYmFbM10gIT0gbnVsbCkge1xuICAgICAgICAgICAgaHNsYS5wdXNoKHJnYmFbM10pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhzbGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlmdChjb2xvciwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIGNvbG9yQXJyID0gcGFyc2UoY29sb3IpO1xuICAgICAgICBpZiAoY29sb3JBcnIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvckFycltpXSA9IGNvbG9yQXJyW2ldICogKDEgLSBsZXZlbCkgfCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JBcnJbaV0gPSAoKDI1NSAtIGNvbG9yQXJyW2ldKSAqIGxldmVsICsgY29sb3JBcnJbaV0pIHwgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KGNvbG9yQXJyLCBjb2xvckFyci5sZW5ndGggPT09IDQgPyAncmdiYScgOiAncmdiJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0hleChjb2xvciwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIGNvbG9yQXJyID0gcGFyc2UoY29sb3IpO1xuICAgICAgICBpZiAoY29sb3JBcnIpIHtcbiAgICAgICAgICAgIHJldHVybiAoKDEgPDwgMjQpICsgKGNvbG9yQXJyWzBdIDw8IDE2KSArIChjb2xvckFyclsxXSA8PCA4KSArICgrY29sb3JBcnJbMl0pKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXAgdmFsdWUgdG8gY29sb3IuIEZhc3RlciB0aGFuIGxlcnAgbWV0aG9kcyBiZWNhdXNlIGNvbG9yIGlzIHJlcHJlc2VudGVkIGJ5IHJnYmEgYXJyYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRWYWx1ZSBBIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGNvbG9ycyBMaXN0IG9mIHJnYmEgY29sb3IgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3V0XSBNYXBwZWQgZ2JhIGNvbG9yIGFycmF5XG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IHdpbGwgYmUgbnVsbC91bmRlZmluZWQgaWYgaW5wdXQgaWxsZWdhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmYXN0TGVycChub3JtYWxpemVkVmFsdWUsIGNvbG9ycywgb3V0KSB7XG4gICAgICAgIGlmICghKGNvbG9ycyAmJiBjb2xvcnMubGVuZ3RoKVxuICAgICAgICAgICAgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvdXQgPSBvdXQgfHwgW107XG5cbiAgICAgICAgdmFyIHZhbHVlID0gbm9ybWFsaXplZFZhbHVlICogKGNvbG9ycy5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIGxlZnRJbmRleCA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgICB2YXIgcmlnaHRJbmRleCA9IE1hdGguY2VpbCh2YWx1ZSk7XG4gICAgICAgIHZhciBsZWZ0Q29sb3IgPSBjb2xvcnNbbGVmdEluZGV4XTtcbiAgICAgICAgdmFyIHJpZ2h0Q29sb3IgPSBjb2xvcnNbcmlnaHRJbmRleF07XG4gICAgICAgIHZhciBkdiA9IHZhbHVlIC0gbGVmdEluZGV4O1xuICAgICAgICBvdXRbMF0gPSBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMF0sIHJpZ2h0Q29sb3JbMF0sIGR2KSk7XG4gICAgICAgIG91dFsxXSA9IGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKTtcbiAgICAgICAgb3V0WzJdID0gY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzJdLCByaWdodENvbG9yWzJdLCBkdikpO1xuICAgICAgICBvdXRbM10gPSBjbGFtcENzc0Zsb2F0KGxlcnBOdW1iZXIobGVmdENvbG9yWzNdLCByaWdodENvbG9yWzNdLCBkdikpO1xuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRWYWx1ZSBBIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjb2xvcnMgQ29sb3IgbGlzdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBmdWxsT3V0cHV0IERlZmF1bHQgZmFsc2UuXG4gICAgICogQHJldHVybiB7KHN0cmluZ3xPYmplY3QpfSBSZXN1bHQgY29sb3IuIElmIGZ1bGxPdXRwdXQsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvbG9yOiAuLi4sIGxlZnRJbmRleDogLi4uLCByaWdodEluZGV4OiAuLi4sIHZhbHVlOiAuLi59LFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVycChub3JtYWxpemVkVmFsdWUsIGNvbG9ycywgZnVsbE91dHB1dCkge1xuICAgICAgICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aClcbiAgICAgICAgICAgIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gbm9ybWFsaXplZFZhbHVlICogKGNvbG9ycy5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIGxlZnRJbmRleCA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgICB2YXIgcmlnaHRJbmRleCA9IE1hdGguY2VpbCh2YWx1ZSk7XG4gICAgICAgIHZhciBsZWZ0Q29sb3IgPSBwYXJzZShjb2xvcnNbbGVmdEluZGV4XSk7XG4gICAgICAgIHZhciByaWdodENvbG9yID0gcGFyc2UoY29sb3JzW3JpZ2h0SW5kZXhdKTtcbiAgICAgICAgdmFyIGR2ID0gdmFsdWUgLSBsZWZ0SW5kZXg7XG5cbiAgICAgICAgdmFyIGNvbG9yID0gc3RyaW5naWZ5KFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclswXSwgcmlnaHRDb2xvclswXSwgZHYpKSxcbiAgICAgICAgICAgICAgICBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSksXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzJdLCByaWdodENvbG9yWzJdLCBkdikpLFxuICAgICAgICAgICAgICAgIGNsYW1wQ3NzRmxvYXQobGVycE51bWJlcihsZWZ0Q29sb3JbM10sIHJpZ2h0Q29sb3JbM10sIGR2KSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncmdiYSdcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gZnVsbE91dHB1dFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgIGxlZnRJbmRleDogbGVmdEluZGV4LFxuICAgICAgICAgICAgICAgIHJpZ2h0SW5kZXg6IHJpZ2h0SW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGNvbG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gaCAwIH4gMzYwLCBpZ25vcmUgd2hlbiBudWxsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcyAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGwgMCB+IDEsIGlnbm9yZSB3aGVuIG51bGwuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb2xvciBzdHJpbmcgaW4gcmdiYSBmb3JtYXQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtb2RpZnlIU0woY29sb3IsIGgsIHMsIGwpIHtcbiAgICAgICAgY29sb3IgPSBwYXJzZShjb2xvcik7XG5cbiAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICBjb2xvciA9IHJnYmEyaHNsYShjb2xvcik7XG4gICAgICAgICAgICBoICE9IG51bGwgJiYgKGNvbG9yWzBdID0gY2xhbXBDc3NBbmdsZShoKSk7XG4gICAgICAgICAgICBzICE9IG51bGwgJiYgKGNvbG9yWzFdID0gcGFyc2VDc3NGbG9hdChzKSk7XG4gICAgICAgICAgICBsICE9IG51bGwgJiYgKGNvbG9yWzJdID0gcGFyc2VDc3NGbG9hdChsKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoaHNsYTJyZ2JhKGNvbG9yKSwgJ3JnYmEnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYWxwaGEgMCB+IDFcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vZGlmeUFscGhhKGNvbG9yLCBhbHBoYSkge1xuICAgICAgICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICAgICAgICBpZiAoY29sb3IgJiYgYWxwaGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29sb3JbM10gPSBjbGFtcENzc0Zsb2F0KGFscGhhKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoY29sb3IsICdyZ2JhJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJDb2xvciBsaWtlIFsxMiwzMyw0NCwwLjRdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgJ3JnYmEnLCAnaHN2YScsIC4uLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUmVzdWx0IGNvbG9yLiAoSWYgaW5wdXQgaWxsZWdhbCwgcmV0dXJuIHVuZGVmaW5lZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KGFyckNvbG9yLCB0eXBlKSB7XG4gICAgICAgIGlmICghYXJyQ29sb3IgfHwgIWFyckNvbG9yLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xvclN0ciA9IGFyckNvbG9yWzBdICsgJywnICsgYXJyQ29sb3JbMV0gKyAnLCcgKyBhcnJDb2xvclsyXTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdyZ2JhJyB8fCB0eXBlID09PSAnaHN2YScgfHwgdHlwZSA9PT0gJ2hzbGEnKSB7XG4gICAgICAgICAgICBjb2xvclN0ciArPSAnLCcgKyBhcnJDb2xvclszXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZSArICcoJyArIGNvbG9yU3RyICsgJyknO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBwYXJzZTogcGFyc2UsXG4gICAgICAgIGxpZnQ6IGxpZnQsXG4gICAgICAgIHRvSGV4OiB0b0hleCxcbiAgICAgICAgZmFzdExlcnA6IGZhc3RMZXJwLFxuICAgICAgICBmYXN0TWFwVG9Db2xvcjogZmFzdExlcnAsIC8vIERlcHJlY2F0ZWRcbiAgICAgICAgbGVycDogbGVycCxcbiAgICAgICAgbWFwVG9Db2xvcjogbGVycCwgLy8gRGVwcmVjYXRlZFxuICAgICAgICBtb2RpZnlIU0w6IG1vZGlmeUhTTCxcbiAgICAgICAgbW9kaWZ5QWxwaGE6IG1vZGlmeUFscGhhLFxuICAgICAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeVxuICAgIH07XG5cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi90b29sL2NvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBTaW1wbGUgTFJVIGNhY2hlIHVzZSBkb3VibHkgbGlua2VkIGxpc3Rcbi8vIEBtb2R1bGUgenJlbmRlci9jb3JlL0xSVVxuXG5cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgZG91YmxlIGxpbmtlZCBsaXN0LiBDb21wYXJlZCB3aXRoIGFycmF5LCBpdCBoYXMgTygxKSByZW1vdmUgb3BlcmF0aW9uLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2xlbiA9IDA7XG4gICAgfTtcblxuICAgIHZhciBsaW5rZWRMaXN0UHJvdG8gPSBMaW5rZWRMaXN0LnByb3RvdHlwZTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBuZXcgdmFsdWUgYXQgdGhlIHRhaWxcbiAgICAgKiBAcGFyYW0gIHt9IHZhbFxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgICAqL1xuICAgIGxpbmtlZExpc3RQcm90by5pbnNlcnQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG5ldyBFbnRyeSh2YWwpO1xuICAgICAgICB0aGlzLmluc2VydEVudHJ5KGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYW4gZW50cnkgYXQgdGhlIHRhaWxcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAgICAgKi9cbiAgICBsaW5rZWRMaXN0UHJvdG8uaW5zZXJ0RW50cnkgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5LnByZXYgPSB0aGlzLnRhaWw7XG4gICAgICAgICAgICBlbnRyeS5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xlbisrO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZW50cnkuXG4gICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9IGVudHJ5XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnByZXY7XG4gICAgICAgIHZhciBuZXh0ID0gZW50cnkubmV4dDtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJcyBoZWFkXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSXMgdGFpbFxuICAgICAgICAgICAgdGhpcy50YWlsID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeS5uZXh0ID0gZW50cnkucHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xlbi0tO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLmxlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgbGlzdFxuICAgICAqL1xuICAgIGxpbmtlZExpc3RQcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHt9IHZhbFxuICAgICAqL1xuICAgIHZhciBFbnRyeSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHt9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5leHQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTFJVIENhY2hlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2NvcmUvTFJVXG4gICAgICovXG4gICAgdmFyIExSVSA9IGZ1bmN0aW9uIChtYXhTaXplKSB7XG5cbiAgICAgICAgdGhpcy5fbGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XG5cbiAgICAgICAgdGhpcy5fbWFwID0ge307XG5cbiAgICAgICAgdGhpcy5fbWF4U2l6ZSA9IG1heFNpemUgfHwgMTA7XG5cbiAgICAgICAgdGhpcy5fbGFzdFJlbW92ZWRFbnRyeSA9IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBMUlVQcm90byA9IExSVS5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSAge30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHt9IFJlbW92ZWQgdmFsdWVcbiAgICAgKi9cbiAgICBMUlVQcm90by5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gICAgICAgIHZhciByZW1vdmVkID0gbnVsbDtcbiAgICAgICAgaWYgKG1hcFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBsaXN0LmxlbigpO1xuICAgICAgICAgICAgLy8gUmV1c2UgbGFzdCByZW1vdmVkIGVudHJ5XG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5O1xuXG4gICAgICAgICAgICBpZiAobGVuID49IHRoaXMuX21heFNpemUgJiYgbGVuID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZFxuICAgICAgICAgICAgICAgIHZhciBsZWFzdFVzZWRFbnRyeSA9IGxpc3QuaGVhZDtcbiAgICAgICAgICAgICAgICBsaXN0LnJlbW92ZShsZWFzdFVzZWRFbnRyeSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hcFtsZWFzdFVzZWRFbnRyeS5rZXldO1xuXG4gICAgICAgICAgICAgICAgcmVtb3ZlZCA9IGxlYXN0VXNlZEVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RSZW1vdmVkRW50cnkgPSBsZWFzdFVzZWRFbnRyeTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgZW50cnkudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVudHJ5ID0gbmV3IEVudHJ5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJ5LmtleSA9IGtleTtcbiAgICAgICAgICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgbWFwW2tleV0gPSBlbnRyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm4ge31cbiAgICAgKi9cbiAgICBMUlVQcm90by5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX21hcFtrZXldO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gICAgICAgIGlmIChlbnRyeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBQdXQgdGhlIGxhdGVzdCB1c2VkIGVudHJ5IGluIHRoZSB0YWlsXG4gICAgICAgICAgICBpZiAoZW50cnkgIT09IGxpc3QudGFpbCkge1xuICAgICAgICAgICAgICAgIGxpc3QucmVtb3ZlKGVudHJ5KTtcbiAgICAgICAgICAgICAgICBsaXN0Lmluc2VydEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjYWNoZVxuICAgICAqL1xuICAgIExSVVByb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9saXN0LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX21hcCA9IHt9O1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExSVTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvY29yZS9MUlUuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuICAgICAgICB2YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBleHBvcnRzIHpyZW5kZXIvdG9vbC9sb2dcbiAgICAgICAgICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gICAgICAgICAqL1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5kZWJ1Z01vZGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuZGVidWdNb2RlID09IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXJndW1lbnRzW2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuZGVidWdNb2RlID4gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50c1trXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qIGZvciBkZWJ1Z1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obWVzKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd3JvbmctbWVzc2FnZScpLmlubmVySFRNTCA9XG4gICAgICAgICAgICAgICAgbWVzICsgJyAnICsgKG5ldyBEYXRlKCkgLSAwKVxuICAgICAgICAgICAgICAgICsgJzxici8+J1xuICAgICAgICAgICAgICAgICsgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dyb25nLW1lc3NhZ2UnKS5pbm5lckhUTUw7XG4gICAgICAgIH07XG4gICAgICAgICovXG4gICAgXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvcmUvbG9nLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbiAgICB2YXIgZHByID0gMTtcbiAgICAvLyBJZiBpbiBicm93c2VyIGVudmlyb25tZW50XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRwciA9IE1hdGgubWF4KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25maWfpu5jorqTphY3nva7poblcbiAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL2NvbmZpZ1xuICAgICAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICAgICAqL1xuICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZWJ1Z+aXpeW/l+mAiemhue+8mmNhdGNoQnJ1c2hFeGNlcHRpb27kuLp0cnVl5LiL5pyJ5pWIXG4gICAgICAgICAqIDAgOiDkuI3nlJ/miJBkZWJ1Z+aVsOaNru+8jOWPkeW4g+eUqFxuICAgICAgICAgKiAxIDog5byC5bi45oqb5Ye677yM6LCD6K+V55SoXG4gICAgICAgICAqIDIgOiDmjqfliLblj7DovpPlh7rvvIzosIPor5XnlKhcbiAgICAgICAgICovXG4gICAgICAgIGRlYnVnTW9kZTogMCxcblxuICAgICAgICAvLyByZXRpbmEg5bGP5bmV5LyY5YyWXG4gICAgICAgIGRldmljZVBpeGVsUmF0aW86IGRwclxuICAgIH07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb25maWc7XG5cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9jb25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogTWl4aW4gZm9yIGRyYXdpbmcgdGV4dCBpbiBhIGVsZW1lbnQgYm91bmRpbmcgcmVjdFxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1JlY3RUZXh0XG4gKi9cblxuXG5cbiAgICB2YXIgdGV4dEhlbHBlciA9IHJlcXVpcmUoJy4uL2hlbHBlci90ZXh0Jyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG5cbiAgICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoKTtcblxuICAgIHZhciBSZWN0VGV4dCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgUmVjdFRleHQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBSZWN0VGV4dCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRHJhdyB0ZXh0IGluIGEgcmVjdCB3aXRoIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICAgICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSByZWN0IERpc3BsYXlhYmxlIHJlY3RcbiAgICAgICAgICovXG4gICAgICAgIGRyYXdSZWN0VGV4dDogZnVuY3Rpb24gKGN0eCwgcmVjdCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcblxuICAgICAgICAgICAgcmVjdCA9IHN0eWxlLnRleHRSZWN0IHx8IHJlY3Q7XG5cbiAgICAgICAgICAgIC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcblxuICAgICAgICAgICAgLy8gQ29udmVydCB0byBzdHJpbmdcbiAgICAgICAgICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgICAgICAgICAgIGlmICghdGV4dEhlbHBlci5uZWVkRHJhd1RleHQodGV4dCwgc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHJlY3QgdG8gdmlldyBzcGFjZVxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgaWYgKCFzdHlsZS50cmFuc2Zvcm1UZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0bXBSZWN0LmNvcHkocmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHRtcFJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtVGV4dCBhbmQgdGV4dFJvdGF0aW9uIGNhbiBub3QgYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAgICAgdGV4dEhlbHBlci5yZW5kZXJUZXh0KHRoaXMsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpO1xuXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUmVjdFRleHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuXG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnLi4vLi4vY29udGFpbi90ZXh0Jyk7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZSgnLi9yb3VuZFJlY3QnKTtcbiAgICB2YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKCcuL2ltYWdlJyk7XG5cbiAgICB2YXIgcmV0cmlldmUzID0gdXRpbC5yZXRyaWV2ZTM7XG4gICAgdmFyIHJldHJpZXZlMiA9IHV0aWwucmV0cmlldmUyO1xuXG4gICAgLy8gVE9ETzogSGF2ZSBub3Qgc3VwcG9ydCAnc3RhcnQnLCAnZW5kJyB5ZXQuXG4gICAgdmFyIFZBTElEX1RFWFRfQUxJR04gPSB7bGVmdDogMSwgcmlnaHQ6IDEsIGNlbnRlcjogMX07XG4gICAgdmFyIFZBTElEX1RFWFRfVkVSVElDQUxfQUxJR04gPSB7dG9wOiAxLCBib3R0b206IDEsIG1pZGRsZTogMX07XG5cbiAgICB2YXIgaGVscGVyID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IHN0eWxlXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gVGhlIGlucHV0IHN0eWxlLlxuICAgICAqL1xuICAgIGhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICAgICAgICB1dGlsLmVhY2goc3R5bGUucmljaCwgbm9ybWFsaXplU3R5bGUpO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHN0eWxlKSB7XG4gICAgICAgIGlmIChzdHlsZSkge1xuXG4gICAgICAgICAgICBzdHlsZS5mb250ID0gdGV4dENvbnRhaW4ubWFrZUZvbnQoc3R5bGUpO1xuXG4gICAgICAgICAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgICAgICAgICAgdGV4dEFsaWduID09PSAnbWlkZGxlJyAmJiAodGV4dEFsaWduID0gJ2NlbnRlcicpO1xuICAgICAgICAgICAgc3R5bGUudGV4dEFsaWduID0gKFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9PSBudWxsIHx8IFZBTElEX1RFWFRfQUxJR05bdGV4dEFsaWduXVxuICAgICAgICAgICAgKSA/IHRleHRBbGlnbiA6ICdsZWZ0JztcblxuICAgICAgICAgICAgLy8gQ29tcGF0aWJsZSB3aXRoIHRleHRCYXNlbGluZS5cbiAgICAgICAgICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduIHx8IHN0eWxlLnRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID09PSAnY2VudGVyJyAmJiAodGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJyk7XG4gICAgICAgICAgICBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiA9IChcbiAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9PSBudWxsIHx8IFZBTElEX1RFWFRfVkVSVElDQUxfQUxJR05bdGV4dFZlcnRpY2FsQWxpZ25dXG4gICAgICAgICAgICApID8gdGV4dFZlcnRpY2FsQWxpZ24gOiAndG9wJztcblxuICAgICAgICAgICAgdmFyIHRleHRQYWRkaW5nID0gc3R5bGUudGV4dFBhZGRpbmc7XG4gICAgICAgICAgICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0UGFkZGluZyA9IHV0aWwubm9ybWFsaXplQ3NzQXJyYXkoc3R5bGUudGV4dFBhZGRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBzdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IFtyZWN0XSB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAgICAgKiAgICAgICAgICAgICAgICAgIElmIHNldCBmYWxzZSwgcmVjdCB0ZXh0IGlzIG5vdCB1c2VkLlxuICAgICAqL1xuICAgIGhlbHBlci5yZW5kZXJUZXh0ID0gZnVuY3Rpb24gKGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCkge1xuICAgICAgICBzdHlsZS5yaWNoXG4gICAgICAgICAgICA/IHJlbmRlclJpY2hUZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdClcbiAgICAgICAgICAgIDogcmVuZGVyUGxhaW5UZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbmRlclBsYWluVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QpIHtcbiAgICAgICAgdmFyIGZvbnQgPSBzZXRDdHgoY3R4LCAnZm9udCcsIHN0eWxlLmZvbnQgfHwgdGV4dENvbnRhaW4uREVGQVVMVF9GT05UKTtcblxuICAgICAgICB2YXIgdGV4dFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcblxuICAgICAgICB2YXIgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrO1xuICAgICAgICBpZiAoIWNvbnRlbnRCbG9jayB8fCBob3N0RWwuX19kaXJ0eSkge1xuICAgICAgICAgICAgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrID0gdGV4dENvbnRhaW4ucGFyc2VQbGFpblRleHQoXG4gICAgICAgICAgICAgICAgdGV4dCwgZm9udCwgdGV4dFBhZGRpbmcsIHN0eWxlLnRydW5jYXRlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuXG4gICAgICAgIHZhciB0ZXh0TGluZXMgPSBjb250ZW50QmxvY2subGluZXM7XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gY29udGVudEJsb2NrLmxpbmVIZWlnaHQ7XG5cbiAgICAgICAgdmFyIGJveFBvcyA9IGdldEJveFBvc2l0aW9uKG91dGVySGVpZ2h0LCBzdHlsZSwgcmVjdCk7XG4gICAgICAgIHZhciBiYXNlWCA9IGJveFBvcy5iYXNlWDtcbiAgICAgICAgdmFyIGJhc2VZID0gYm94UG9zLmJhc2VZO1xuICAgICAgICB2YXIgdGV4dEFsaWduID0gYm94UG9zLnRleHRBbGlnbjtcbiAgICAgICAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gYm94UG9zLnRleHRWZXJ0aWNhbEFsaWduO1xuXG4gICAgICAgIC8vIE9yaWdpbiBvZiB0ZXh0Um90YXRpb24gc2hvdWxkIGJlIHRoZSBiYXNlIHBvaW50IG9mIHRleHQgZHJhd2luZy5cbiAgICAgICAgYXBwbHlUZXh0Um90YXRpb24oY3R4LCBzdHlsZSwgcmVjdCwgYmFzZVgsIGJhc2VZKTtcblxuICAgICAgICB2YXIgYm94WSA9IHRleHRDb250YWluLmFkanVzdFRleHRZKGJhc2VZLCBvdXRlckhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pO1xuICAgICAgICB2YXIgdGV4dFggPSBiYXNlWDtcbiAgICAgICAgdmFyIHRleHRZID0gYm94WTtcblxuICAgICAgICB2YXIgbmVlZERyYXdCZyA9IG5lZWREcmF3QmFja2dyb3VuZChzdHlsZSk7XG4gICAgICAgIGlmIChuZWVkRHJhd0JnIHx8IHRleHRQYWRkaW5nKSB7XG4gICAgICAgICAgICAvLyBDb25zaWRlciBwZXJmb3JtYW5jZSwgZG8gbm90IGNhbGwgZ2V0VGV4dFdpZHRoIHV0aWwgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgdmFyIHRleHRXaWR0aCA9IHRleHRDb250YWluLmdldFdpZHRoKHRleHQsIGZvbnQpO1xuICAgICAgICAgICAgdmFyIG91dGVyV2lkdGggPSB0ZXh0V2lkdGg7XG4gICAgICAgICAgICB0ZXh0UGFkZGluZyAmJiAob3V0ZXJXaWR0aCArPSB0ZXh0UGFkZGluZ1sxXSArIHRleHRQYWRkaW5nWzNdKTtcbiAgICAgICAgICAgIHZhciBib3hYID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFgoYmFzZVgsIG91dGVyV2lkdGgsIHRleHRBbGlnbik7XG5cbiAgICAgICAgICAgIG5lZWREcmF3QmcgJiYgZHJhd0JhY2tncm91bmQoaG9zdEVsLCBjdHgsIHN0eWxlLCBib3hYLCBib3hZLCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0UGFkZGluZykge1xuICAgICAgICAgICAgICAgIHRleHRYID0gZ2V0VGV4dFhGb3JQYWRkaW5nKGJhc2VYLCB0ZXh0QWxpZ24sIHRleHRQYWRkaW5nKTtcbiAgICAgICAgICAgICAgICB0ZXh0WSArPSB0ZXh0UGFkZGluZ1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNldEN0eChjdHgsICd0ZXh0QWxpZ24nLCB0ZXh0QWxpZ24gfHwgJ2xlZnQnKTtcbiAgICAgICAgLy8gRm9yY2UgYmFzZWxpbmUgdG8gYmUgXCJtaWRkbGVcIi4gT3RoZXJ3aXNlLCBpZiB1c2luZyBcInRvcFwiLCB0aGVcbiAgICAgICAgLy8gdGV4dCB3aWxsIG9mZnNldCBkb3dud2FyZCBhIGxpdHRsZSBiaXQgaW4gZm9udCBcIk1pY3Jvc29mdCBZYUhlaVwiLlxuICAgICAgICBzZXRDdHgoY3R4LCAndGV4dEJhc2VsaW5lJywgJ21pZGRsZScpO1xuXG4gICAgICAgIC8vIEFsd2F5cyBzZXQgc2hhZG93Qmx1ciBhbmQgc2hhZG93T2Zmc2V0IHRvIGF2b2lkIGxlYWsgZnJvbSBkaXNwbGF5YWJsZS5cbiAgICAgICAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0JsdXInLCBzdHlsZS50ZXh0U2hhZG93Qmx1ciB8fCAwKTtcbiAgICAgICAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0NvbG9yJywgc3R5bGUudGV4dFNoYWRvd0NvbG9yIHx8ICd0cmFuc3BhcmVudCcpO1xuICAgICAgICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WCcsIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRYIHx8IDApO1xuICAgICAgICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WScsIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZIHx8IDApO1xuXG4gICAgICAgIC8vIGB0ZXh0QmFzZWxpbmVgIGlzIHNldCBhcyAnbWlkZGxlJy5cbiAgICAgICAgdGV4dFkgKz0gbGluZUhlaWdodCAvIDI7XG5cbiAgICAgICAgdmFyIHRleHRTdHJva2VXaWR0aCA9IHN0eWxlLnRleHRTdHJva2VXaWR0aDtcbiAgICAgICAgdmFyIHRleHRTdHJva2UgPSBnZXRTdHJva2Uoc3R5bGUudGV4dFN0cm9rZSwgdGV4dFN0cm9rZVdpZHRoKTtcbiAgICAgICAgdmFyIHRleHRGaWxsID0gZ2V0RmlsbChzdHlsZS50ZXh0RmlsbCk7XG5cbiAgICAgICAgaWYgKHRleHRTdHJva2UpIHtcbiAgICAgICAgICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICAgICAgICAgICAgc2V0Q3R4KGN0eCwgJ3N0cm9rZVN0eWxlJywgdGV4dFN0cm9rZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHRGaWxsKSB7XG4gICAgICAgICAgICBzZXRDdHgoY3R4LCAnZmlsbFN0eWxlJywgdGV4dEZpbGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEZpbGwgYWZ0ZXIgc3Ryb2tlIHNvIHRoZSBvdXRsaW5lIHdpbGwgbm90IGNvdmVyIHRoZSBtYWluIHBhcnQuXG4gICAgICAgICAgICB0ZXh0U3Ryb2tlICYmIGN0eC5zdHJva2VUZXh0KHRleHRMaW5lc1tpXSwgdGV4dFgsIHRleHRZKTtcbiAgICAgICAgICAgIHRleHRGaWxsICYmIGN0eC5maWxsVGV4dCh0ZXh0TGluZXNbaV0sIHRleHRYLCB0ZXh0WSk7XG4gICAgICAgICAgICB0ZXh0WSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyUmljaFRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0KSB7XG4gICAgICAgIHZhciBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2s7XG5cbiAgICAgICAgaWYgKCFjb250ZW50QmxvY2sgfHwgaG9zdEVsLl9fZGlydHkpIHtcbiAgICAgICAgICAgIGNvbnRlbnRCbG9jayA9IGhvc3RFbC5fX3RleHRDb3RlbnRCbG9jayA9IHRleHRDb250YWluLnBhcnNlUmljaFRleHQodGV4dCwgc3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZHJhd1JpY2hUZXh0KGhvc3RFbCwgY3R4LCBjb250ZW50QmxvY2ssIHN0eWxlLCByZWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3UmljaFRleHQoaG9zdEVsLCBjdHgsIGNvbnRlbnRCbG9jaywgc3R5bGUsIHJlY3QpIHtcbiAgICAgICAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRlbnRCbG9jay53aWR0aDtcbiAgICAgICAgdmFyIG91dGVyV2lkdGggPSBjb250ZW50QmxvY2sub3V0ZXJXaWR0aDtcbiAgICAgICAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuICAgICAgICB2YXIgdGV4dFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcblxuICAgICAgICB2YXIgYm94UG9zID0gZ2V0Qm94UG9zaXRpb24ob3V0ZXJIZWlnaHQsIHN0eWxlLCByZWN0KTtcbiAgICAgICAgdmFyIGJhc2VYID0gYm94UG9zLmJhc2VYO1xuICAgICAgICB2YXIgYmFzZVkgPSBib3hQb3MuYmFzZVk7XG4gICAgICAgIHZhciB0ZXh0QWxpZ24gPSBib3hQb3MudGV4dEFsaWduO1xuICAgICAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBib3hQb3MudGV4dFZlcnRpY2FsQWxpZ247XG5cbiAgICAgICAgLy8gT3JpZ2luIG9mIHRleHRSb3RhdGlvbiBzaG91bGQgYmUgdGhlIGJhc2UgcG9pbnQgb2YgdGV4dCBkcmF3aW5nLlxuICAgICAgICBhcHBseVRleHRSb3RhdGlvbihjdHgsIHN0eWxlLCByZWN0LCBiYXNlWCwgYmFzZVkpO1xuXG4gICAgICAgIHZhciBib3hYID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFgoYmFzZVgsIG91dGVyV2lkdGgsIHRleHRBbGlnbik7XG4gICAgICAgIHZhciBib3hZID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFkoYmFzZVksIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gICAgICAgIHZhciB4TGVmdCA9IGJveFg7XG4gICAgICAgIHZhciBsaW5lVG9wID0gYm94WTtcbiAgICAgICAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgICAgICAgICB4TGVmdCArPSB0ZXh0UGFkZGluZ1szXTtcbiAgICAgICAgICAgIGxpbmVUb3AgKz0gdGV4dFBhZGRpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHhSaWdodCA9IHhMZWZ0ICsgY29udGVudFdpZHRoO1xuXG4gICAgICAgIG5lZWREcmF3QmFja2dyb3VuZChzdHlsZSkgJiYgZHJhd0JhY2tncm91bmQoXG4gICAgICAgICAgICBob3N0RWwsIGN0eCwgc3R5bGUsIGJveFgsIGJveFksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0XG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QmxvY2subGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gY29udGVudEJsb2NrLmxpbmVzW2ldO1xuICAgICAgICAgICAgdmFyIHRva2VucyA9IGxpbmUudG9rZW5zO1xuICAgICAgICAgICAgdmFyIHRva2VuQ291bnQgPSB0b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSBsaW5lLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgdXNlZFdpZHRoID0gbGluZS53aWR0aDtcblxuICAgICAgICAgICAgdmFyIGxlZnRJbmRleCA9IDA7XG4gICAgICAgICAgICB2YXIgbGluZVhMZWZ0ID0geExlZnQ7XG4gICAgICAgICAgICB2YXIgbGluZVhSaWdodCA9IHhSaWdodDtcbiAgICAgICAgICAgIHZhciByaWdodEluZGV4ID0gdG9rZW5Db3VudCAtIDE7XG4gICAgICAgICAgICB2YXIgdG9rZW47XG5cbiAgICAgICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgICAgICBsZWZ0SW5kZXggPCB0b2tlbkNvdW50XG4gICAgICAgICAgICAgICAgJiYgKHRva2VuID0gdG9rZW5zW2xlZnRJbmRleF0sICF0b2tlbi50ZXh0QWxpZ24gfHwgdG9rZW4udGV4dEFsaWduID09PSAnbGVmdCcpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIGxpbmVYTGVmdCwgJ2xlZnQnKTtcbiAgICAgICAgICAgICAgICB1c2VkV2lkdGggLT0gdG9rZW4ud2lkdGg7XG4gICAgICAgICAgICAgICAgbGluZVhMZWZ0ICs9IHRva2VuLndpZHRoO1xuICAgICAgICAgICAgICAgIGxlZnRJbmRleCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICAgICAgcmlnaHRJbmRleCA+PSAwXG4gICAgICAgICAgICAgICAgJiYgKHRva2VuID0gdG9rZW5zW3JpZ2h0SW5kZXhdLCB0b2tlbi50ZXh0QWxpZ24gPT09ICdyaWdodCcpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIGxpbmVYUmlnaHQsICdyaWdodCcpO1xuICAgICAgICAgICAgICAgIHVzZWRXaWR0aCAtPSB0b2tlbi53aWR0aDtcbiAgICAgICAgICAgICAgICBsaW5lWFJpZ2h0IC09IHRva2VuLndpZHRoO1xuICAgICAgICAgICAgICAgIHJpZ2h0SW5kZXgtLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIG90aGVyIHRva2VucyBhcmUgcGxhY2VkIGFzIHRleHRBbGlnbiAnY2VudGVyJyBpZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2UuXG4gICAgICAgICAgICBsaW5lWExlZnQgKz0gKGNvbnRlbnRXaWR0aCAtIChsaW5lWExlZnQgLSB4TGVmdCkgLSAoeFJpZ2h0IC0gbGluZVhSaWdodCkgLSB1c2VkV2lkdGgpIC8gMjtcbiAgICAgICAgICAgIHdoaWxlIChsZWZ0SW5kZXggPD0gcmlnaHRJbmRleCkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2xlZnRJbmRleF07XG4gICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgd2lkdGggc3BlY2lmaWVkIGJ5IHVzZXIsIHVzZSAnY2VudGVyJyByYXRoZXIgdGhhbiAnbGVmdCcuXG4gICAgICAgICAgICAgICAgcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCBsaW5lWExlZnQgKyB0b2tlbi53aWR0aCAvIDIsICdjZW50ZXInKTtcbiAgICAgICAgICAgICAgICBsaW5lWExlZnQgKz0gdG9rZW4ud2lkdGg7XG4gICAgICAgICAgICAgICAgbGVmdEluZGV4Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmVUb3AgKz0gbGluZUhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VGV4dFJvdGF0aW9uKGN0eCwgc3R5bGUsIHJlY3QsIHgsIHkpIHtcbiAgICAgICAgLy8gdGV4dFJvdGF0aW9uIG9ubHkgYXBwbHkgaW4gUmVjdFRleHQuXG4gICAgICAgIGlmIChyZWN0ICYmIHN0eWxlLnRleHRSb3RhdGlvbikge1xuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHN0eWxlLnRleHRPcmlnaW47XG4gICAgICAgICAgICBpZiAob3JpZ2luID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIHggPSByZWN0LndpZHRoIC8gMiArIHJlY3QueDtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC5oZWlnaHQgLyAyICsgcmVjdC55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgeCA9IG9yaWdpblswXSArIHJlY3QueDtcbiAgICAgICAgICAgICAgICB5ID0gb3JpZ2luWzFdICsgcmVjdC55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICAgICAgLy8gUG9zaXRpdmU6IGFudGljbG9ja3dpc2VcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoLXN0eWxlLnRleHRSb3RhdGlvbik7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC14LCAteSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIHgsIHRleHRBbGlnbikge1xuICAgICAgICB2YXIgdG9rZW5TdHlsZSA9IHN0eWxlLnJpY2hbdG9rZW4uc3R5bGVOYW1lXSB8fCB7fTtcblxuICAgICAgICAvLyAnY3R4LnRleHRCYXNlbGluZScgaXMgYWx3YXlzIHNldCBhcyAnbWlkZGxlJywgZm9yIHNha2Ugb2ZcbiAgICAgICAgLy8gdGhlIGJpYXMgb2YgXCJNaWNyb3NvZnQgWWFIZWlcIi5cbiAgICAgICAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gdG9rZW4udGV4dFZlcnRpY2FsQWxpZ247XG4gICAgICAgIHZhciB5ID0gbGluZVRvcCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICBpZiAodGV4dFZlcnRpY2FsQWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgICB5ID0gbGluZVRvcCArIHRva2VuLmhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dFZlcnRpY2FsQWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICB5ID0gbGluZVRvcCArIGxpbmVIZWlnaHQgLSB0b2tlbi5oZWlnaHQgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgIXRva2VuLmlzTGluZUhvbGRlciAmJiBuZWVkRHJhd0JhY2tncm91bmQodG9rZW5TdHlsZSkgJiYgZHJhd0JhY2tncm91bmQoXG4gICAgICAgICAgICBob3N0RWwsXG4gICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICB0b2tlblN0eWxlLFxuICAgICAgICAgICAgdGV4dEFsaWduID09PSAncmlnaHQnXG4gICAgICAgICAgICAgICAgPyB4IC0gdG9rZW4ud2lkdGhcbiAgICAgICAgICAgICAgICA6IHRleHRBbGlnbiA9PT0gJ2NlbnRlcidcbiAgICAgICAgICAgICAgICA/IHggLSB0b2tlbi53aWR0aCAvIDJcbiAgICAgICAgICAgICAgICA6IHgsXG4gICAgICAgICAgICB5IC0gdG9rZW4uaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIHRva2VuLndpZHRoLFxuICAgICAgICAgICAgdG9rZW4uaGVpZ2h0XG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIHRleHRQYWRkaW5nID0gdG9rZW4udGV4dFBhZGRpbmc7XG4gICAgICAgIGlmICh0ZXh0UGFkZGluZykge1xuICAgICAgICAgICAgeCA9IGdldFRleHRYRm9yUGFkZGluZyh4LCB0ZXh0QWxpZ24sIHRleHRQYWRkaW5nKTtcbiAgICAgICAgICAgIHkgLT0gdG9rZW4uaGVpZ2h0IC8gMiAtIHRleHRQYWRkaW5nWzJdIC0gdG9rZW4udGV4dEhlaWdodCAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRDdHgoY3R4LCAnc2hhZG93Qmx1cicsIHJldHJpZXZlMyh0b2tlblN0eWxlLnRleHRTaGFkb3dCbHVyLCBzdHlsZS50ZXh0U2hhZG93Qmx1ciwgMCkpO1xuICAgICAgICBzZXRDdHgoY3R4LCAnc2hhZG93Q29sb3InLCB0b2tlblN0eWxlLnRleHRTaGFkb3dDb2xvciB8fCBzdHlsZS50ZXh0U2hhZG93Q29sb3IgfHwgJ3RyYW5zcGFyZW50Jyk7XG4gICAgICAgIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRYJywgcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dFNoYWRvd09mZnNldFgsIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRYLCAwKSk7XG4gICAgICAgIHNldEN0eChjdHgsICdzaGFkb3dPZmZzZXRZJywgcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dFNoYWRvd09mZnNldFksIHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZLCAwKSk7XG5cbiAgICAgICAgc2V0Q3R4KGN0eCwgJ3RleHRBbGlnbicsIHRleHRBbGlnbik7XG4gICAgICAgIC8vIEZvcmNlIGJhc2VsaW5lIHRvIGJlIFwibWlkZGxlXCIuIE90aGVyd2lzZSwgaWYgdXNpbmcgXCJ0b3BcIiwgdGhlXG4gICAgICAgIC8vIHRleHQgd2lsbCBvZmZzZXQgZG93bndhcmQgYSBsaXR0bGUgYml0IGluIGZvbnQgXCJNaWNyb3NvZnQgWWFIZWlcIi5cbiAgICAgICAgc2V0Q3R4KGN0eCwgJ3RleHRCYXNlbGluZScsICdtaWRkbGUnKTtcblxuICAgICAgICBzZXRDdHgoY3R4LCAnZm9udCcsIHRva2VuLmZvbnQgfHwgdGV4dENvbnRhaW4uREVGQVVMVF9GT05UKTtcblxuICAgICAgICB2YXIgdGV4dFN0cm9rZSA9IGdldFN0cm9rZSh0b2tlblN0eWxlLnRleHRTdHJva2UgfHwgc3R5bGUudGV4dFN0cm9rZSwgdGV4dFN0cm9rZVdpZHRoKTtcbiAgICAgICAgdmFyIHRleHRGaWxsID0gZ2V0RmlsbCh0b2tlblN0eWxlLnRleHRGaWxsIHx8IHN0eWxlLnRleHRGaWxsKTtcbiAgICAgICAgdmFyIHRleHRTdHJva2VXaWR0aCA9IHJldHJpZXZlMih0b2tlblN0eWxlLnRleHRTdHJva2VXaWR0aCwgc3R5bGUudGV4dFN0cm9rZVdpZHRoKTtcblxuICAgICAgICAvLyBGaWxsIGFmdGVyIHN0cm9rZSBzbyB0aGUgb3V0bGluZSB3aWxsIG5vdCBjb3ZlciB0aGUgbWFpbiBwYXJ0LlxuICAgICAgICBpZiAodGV4dFN0cm9rZSkge1xuICAgICAgICAgICAgc2V0Q3R4KGN0eCwgJ2xpbmVXaWR0aCcsIHRleHRTdHJva2VXaWR0aCk7XG4gICAgICAgICAgICBzZXRDdHgoY3R4LCAnc3Ryb2tlU3R5bGUnLCB0ZXh0U3Ryb2tlKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KHRva2VuLnRleHQsIHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0RmlsbCkge1xuICAgICAgICAgICAgc2V0Q3R4KGN0eCwgJ2ZpbGxTdHlsZScsIHRleHRGaWxsKTtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0b2tlbi50ZXh0LCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5lZWREcmF3QmFja2dyb3VuZChzdHlsZSkge1xuICAgICAgICByZXR1cm4gc3R5bGUudGV4dEJhY2tncm91bmRDb2xvclxuICAgICAgICAgICAgfHwgKHN0eWxlLnRleHRCb3JkZXJXaWR0aCAmJiBzdHlsZS50ZXh0Qm9yZGVyQ29sb3IpO1xuICAgIH1cblxuICAgIC8vIHN0eWxlOiB7dGV4dEJhY2tncm91bmRDb2xvciwgdGV4dEJvcmRlcldpZHRoLCB0ZXh0Qm9yZGVyQ29sb3IsIHRleHRCb3JkZXJSYWRpdXN9XG4gICAgLy8gc2hhcGU6IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICAgIGZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCBzdHlsZSwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIHZhciB0ZXh0Qm9yZGVyV2lkdGggPSBzdHlsZS50ZXh0Qm9yZGVyV2lkdGg7XG4gICAgICAgIHZhciB0ZXh0Qm9yZGVyQ29sb3IgPSBzdHlsZS50ZXh0Qm9yZGVyQ29sb3I7XG4gICAgICAgIHZhciBpc1BsYWluQmcgPSB1dGlsLmlzU3RyaW5nKHRleHRCYWNrZ3JvdW5kQ29sb3IpO1xuXG4gICAgICAgIHNldEN0eChjdHgsICdzaGFkb3dCbHVyJywgc3R5bGUudGV4dEJveFNoYWRvd0JsdXIgfHwgMCk7XG4gICAgICAgIHNldEN0eChjdHgsICdzaGFkb3dDb2xvcicsIHN0eWxlLnRleHRCb3hTaGFkb3dDb2xvciB8fCAndHJhbnNwYXJlbnQnKTtcbiAgICAgICAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFgnLCBzdHlsZS50ZXh0Qm94U2hhZG93T2Zmc2V0WCB8fCAwKTtcbiAgICAgICAgc2V0Q3R4KGN0eCwgJ3NoYWRvd09mZnNldFknLCBzdHlsZS50ZXh0Qm94U2hhZG93T2Zmc2V0WSB8fCAwKTtcblxuICAgICAgICBpZiAoaXNQbGFpbkJnIHx8ICh0ZXh0Qm9yZGVyV2lkdGggJiYgdGV4dEJvcmRlckNvbG9yKSkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgdmFyIHRleHRCb3JkZXJSYWRpdXMgPSBzdHlsZS50ZXh0Qm9yZGVyUmFkaXVzO1xuICAgICAgICAgICAgaWYgKCF0ZXh0Qm9yZGVyUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgY3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3VuZFJlY3RIZWxwZXIuYnVpbGRQYXRoKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCByOiB0ZXh0Qm9yZGVyUmFkaXVzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQbGFpbkJnKSB7XG4gICAgICAgICAgICBzZXRDdHgoY3R4LCAnZmlsbFN0eWxlJywgdGV4dEJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHV0aWwuaXNPYmplY3QodGV4dEJhY2tncm91bmRDb2xvcikpIHtcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IHRleHRCYWNrZ3JvdW5kQ29sb3IuaW1hZ2U7XG5cbiAgICAgICAgICAgIGltYWdlID0gaW1hZ2VIZWxwZXIuY3JlYXRlT3JVcGRhdGVJbWFnZShcbiAgICAgICAgICAgICAgICBpbWFnZSwgbnVsbCwgaG9zdEVsLCBvbkJnSW1hZ2VMb2FkZWQsIHRleHRCYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaW1hZ2UgJiYgaW1hZ2VIZWxwZXIuaXNJbWFnZVJlYWR5KGltYWdlKSkge1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRCb3JkZXJXaWR0aCAmJiB0ZXh0Qm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0Qm9yZGVyV2lkdGgpO1xuICAgICAgICAgICAgc2V0Q3R4KGN0eCwgJ3N0cm9rZVN0eWxlJywgdGV4dEJvcmRlckNvbG9yKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQmdJbWFnZUxvYWRlZChpbWFnZSwgdGV4dEJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAvLyBSZXBsYWNlIGltYWdlLCBzbyB0aGF0IGBjb250YWluL3RleHQuanMjcGFyc2VSaWNoVGV4dGBcbiAgICAgICAgLy8gd2lsbCBnZXQgY29ycmVjdCByZXN1bHQgaW4gbmV4dCB0aWNrLlxuICAgICAgICB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlID0gaW1hZ2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm94UG9zaXRpb24oYmxvY2tIZWlodCwgc3R5bGUsIHJlY3QpIHtcbiAgICAgICAgdmFyIGJhc2VYID0gc3R5bGUueCB8fCAwO1xuICAgICAgICB2YXIgYmFzZVkgPSBzdHlsZS55IHx8IDA7XG4gICAgICAgIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gICAgICAgIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduO1xuXG4gICAgICAgIC8vIFRleHQgcG9zaXRpb24gcmVwcmVzZW50ZWQgYnkgY29vcmRcbiAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0UG9zaXRpb24gPSBzdHlsZS50ZXh0UG9zaXRpb247XG4gICAgICAgICAgICBpZiAodGV4dFBvc2l0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBQZXJjZW50XG4gICAgICAgICAgICAgICAgYmFzZVggPSByZWN0LnggKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzBdLCByZWN0LndpZHRoKTtcbiAgICAgICAgICAgICAgICBiYXNlWSA9IHJlY3QueSArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMV0sIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0UG9zaXRpb25PblJlY3QoXG4gICAgICAgICAgICAgICAgICAgIHRleHRQb3NpdGlvbiwgcmVjdCwgc3R5bGUudGV4dERpc3RhbmNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBiYXNlWCA9IHJlcy54O1xuICAgICAgICAgICAgICAgIGJhc2VZID0gcmVzLnk7XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBhbGlnbiBhbmQgYmFzZWxpbmUgd2hlbiBoYXMgdGV4dFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gdGV4dEFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSB0ZXh0VmVydGljYWxBbGlnbiB8fCByZXMudGV4dFZlcnRpY2FsQWxpZ247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRleHRPZmZzZXQgaXMgb25seSBzdXBwb3J0IGluIFJlY3RUZXh0LCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gYWRqdXN0IGJvdW5kaW5nUmVjdCBmb3IgdGV4dE9mZnNldC5cbiAgICAgICAgICAgIHZhciB0ZXh0T2Zmc2V0ID0gc3R5bGUudGV4dE9mZnNldDtcbiAgICAgICAgICAgIGlmICh0ZXh0T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgYmFzZVggKz0gdGV4dE9mZnNldFswXTtcbiAgICAgICAgICAgICAgICBiYXNlWSArPSB0ZXh0T2Zmc2V0WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJhc2VYOiBiYXNlWCxcbiAgICAgICAgICAgIGJhc2VZOiBiYXNlWSxcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRWZXJ0aWNhbEFsaWduXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0Q3R4KGN0eCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgLy8gRklYTUUgPz8/IHBlcmZvcm1hbmNlIHRyeVxuICAgICAgICAvLyBpZiAoY3R4Ll9fY3VycmVudFZhbHVlc1twcm9wXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGN0eFtwcm9wXSA9IGN0eC5fX2N1cnJlbnRWYWx1ZXNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgY3R4W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIGN0eFtwcm9wXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cm9rZV0gSWYgc3BlY2lmaWVkLCBkbyBub3QgY2hlY2sgc3R5bGUudGV4dFN0cm9rZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xpbmVXaWR0aF0gSWYgc3BlY2lmaWVkLCBkbyBub3QgY2hlY2sgc3R5bGUudGV4dFN0cm9rZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3R5bGVcbiAgICAgKi9cbiAgICB2YXIgZ2V0U3Ryb2tlID0gaGVscGVyLmdldFN0cm9rZSA9IGZ1bmN0aW9uIChzdHJva2UsIGxpbmVXaWR0aCkge1xuICAgICAgICByZXR1cm4gKHN0cm9rZSA9PSBudWxsIHx8IGxpbmVXaWR0aCA8PSAwIHx8IHN0cm9rZSA9PT0gJ3RyYW5zcGFyZW50JyB8fCBzdHJva2UgPT09ICdub25lJylcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgLy8gVE9ETyBwYXR0ZXJuIGFuZCBncmFkaWVudD9cbiAgICAgICAgICAgIDogKHN0cm9rZS5pbWFnZSB8fCBzdHJva2UuY29sb3JTdG9wcylcbiAgICAgICAgICAgID8gJyMwMDAnXG4gICAgICAgICAgICA6IHN0cm9rZTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEZpbGwgPSBoZWxwZXIuZ2V0RmlsbCA9IGZ1bmN0aW9uIChmaWxsKSB7XG4gICAgICAgIHJldHVybiAoZmlsbCA9PSBudWxsIHx8IGZpbGwgPT09ICdub25lJylcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgLy8gVE9ETyBwYXR0ZXJuIGFuZCBncmFkaWVudD9cbiAgICAgICAgICAgIDogKGZpbGwuaW1hZ2UgfHwgZmlsbC5jb2xvclN0b3BzKVxuICAgICAgICAgICAgPyAnIzAwMCdcbiAgICAgICAgICAgIDogZmlsbDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VQZXJjZW50KHZhbHVlLCBtYXhWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxhc3RJbmRleE9mKCclJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIG1heFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUZXh0WEZvclBhZGRpbmcoeCwgdGV4dEFsaWduLCB0ZXh0UGFkZGluZykge1xuICAgICAgICByZXR1cm4gdGV4dEFsaWduID09PSAncmlnaHQnXG4gICAgICAgICAgICA/ICh4IC0gdGV4dFBhZGRpbmdbMV0pXG4gICAgICAgICAgICA6IHRleHRBbGlnbiA9PT0gJ2NlbnRlcidcbiAgICAgICAgICAgID8gKHggKyB0ZXh0UGFkZGluZ1szXSAvIDIgLSB0ZXh0UGFkZGluZ1sxXSAvIDIpXG4gICAgICAgICAgICA6ICh4ICsgdGV4dFBhZGRpbmdbM10pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9TdHlsZX0gc3R5bGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGhlbHBlci5uZWVkRHJhd1RleHQgPSBmdW5jdGlvbiAodGV4dCwgc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIHRleHQgIT0gbnVsbFxuICAgICAgICAgICAgJiYgKHRleHRcbiAgICAgICAgICAgICAgICB8fCBzdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yXG4gICAgICAgICAgICAgICAgfHwgKHN0eWxlLnRleHRCb3JkZXJXaWR0aCAmJiBzdHlsZS50ZXh0Qm9yZGVyQ29sb3IpXG4gICAgICAgICAgICAgICAgfHwgc3R5bGUudGV4dFBhZGRpbmdcbiAgICAgICAgICAgICk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gaGVscGVyO1xuXG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvdGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciBpbWFnZUhlbHBlciA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvaGVscGVyL2ltYWdlJyk7XG5cbiAgICB2YXIgdGV4dFdpZHRoQ2FjaGUgPSB7fTtcbiAgICB2YXIgdGV4dFdpZHRoQ2FjaGVDb3VudGVyID0gMDtcblxuICAgIHZhciBURVhUX0NBQ0hFX01BWCA9IDUwMDA7XG4gICAgdmFyIFNUWUxFX1JFRyA9IC9cXHsoW2EtekEtWjAtOV9dKylcXHwoW159XSopXFx9L2c7XG4gICAgdmFyIERFRkFVTFRfRk9OVCA9ICcxMnB4IHNhbnMtc2VyaWYnO1xuXG4gICAgdmFyIHJldHJpZXZlMiA9IHV0aWwucmV0cmlldmUyO1xuICAgIHZhciByZXRyaWV2ZTMgPSB1dGlsLnJldHJpZXZlMztcblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gICAgICogQHJldHVybiB7bnVtYmVyfSB3aWR0aFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFRleHRXaWR0aCh0ZXh0LCBmb250KSB7XG4gICAgICAgIGZvbnQgPSBmb250IHx8IERFRkFVTFRfRk9OVDtcbiAgICAgICAgdmFyIGtleSA9IHRleHQgKyAnOicgKyBmb250O1xuICAgICAgICBpZiAodGV4dFdpZHRoQ2FjaGVba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRXaWR0aENhY2hlW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuICAgICAgICB2YXIgd2lkdGggPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGV4dExpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgLy8gdGV4dENvbnRhaW4ubWVhc3VyZVRleHQgbWF5IGJlIG92ZXJyaWRlZCBpbiBTVkcgb3IgVk1MXG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHRleHRDb250YWluLm1lYXN1cmVUZXh0KHRleHRMaW5lc1tpXSwgZm9udCkud2lkdGgsIHdpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPiBURVhUX0NBQ0hFX01BWCkge1xuICAgICAgICAgICAgdGV4dFdpZHRoQ2FjaGVDb3VudGVyID0gMDtcbiAgICAgICAgICAgIHRleHRXaWR0aENhY2hlID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGV4dFdpZHRoQ2FjaGVDb3VudGVyKys7XG4gICAgICAgIHRleHRXaWR0aENhY2hlW2tleV0gPSB3aWR0aDtcblxuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RleHRBbGlnbj0nbGVmdCddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0VmVydGljYWxBbGlnbj0ndG9wJ11cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbdGV4dFBhZGRpbmddXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtyaWNoXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdHJ1bmNhdGVdXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB7eCwgeSwgd2lkdGgsIGhlaWdodCwgbGluZUhlaWdodH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRUZXh0UmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgcmljaCwgdHJ1bmNhdGUpIHtcbiAgICAgICAgcmV0dXJuIHJpY2hcbiAgICAgICAgICAgID8gZ2V0UmljaFRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCByaWNoLCB0cnVuY2F0ZSlcbiAgICAgICAgICAgIDogZ2V0UGxhaW5UZXh0UmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgdHJ1bmNhdGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBsYWluVGV4dFJlY3QodGV4dCwgZm9udCwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbiwgdGV4dFBhZGRpbmcsIHRydW5jYXRlKSB7XG4gICAgICAgIHZhciBjb250ZW50QmxvY2sgPSBwYXJzZVBsYWluVGV4dCh0ZXh0LCBmb250LCB0ZXh0UGFkZGluZywgdHJ1bmNhdGUpO1xuICAgICAgICB2YXIgb3V0ZXJXaWR0aCA9IGdldFRleHRXaWR0aCh0ZXh0LCBmb250KTtcbiAgICAgICAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgICAgICAgICBvdXRlcldpZHRoICs9IHRleHRQYWRkaW5nWzFdICsgdGV4dFBhZGRpbmdbM107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuXG4gICAgICAgIHZhciB4ID0gYWRqdXN0VGV4dFgoMCwgb3V0ZXJXaWR0aCwgdGV4dEFsaWduKTtcbiAgICAgICAgdmFyIHkgPSBhZGp1c3RUZXh0WSgwLCBvdXRlckhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pO1xuXG4gICAgICAgIHZhciByZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCh4LCB5LCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG4gICAgICAgIHJlY3QubGluZUhlaWdodCA9IGNvbnRlbnRCbG9jay5saW5lSGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJpY2hUZXh0UmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgcmljaCwgdHJ1bmNhdGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnRCbG9jayA9IHBhcnNlUmljaFRleHQodGV4dCwge1xuICAgICAgICAgICAgcmljaDogcmljaCxcbiAgICAgICAgICAgIHRydW5jYXRlOiB0cnVuY2F0ZSxcbiAgICAgICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgIHRleHRQYWRkaW5nOiB0ZXh0UGFkZGluZ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG91dGVyV2lkdGggPSBjb250ZW50QmxvY2sub3V0ZXJXaWR0aDtcbiAgICAgICAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuXG4gICAgICAgIHZhciB4ID0gYWRqdXN0VGV4dFgoMCwgb3V0ZXJXaWR0aCwgdGV4dEFsaWduKTtcbiAgICAgICAgdmFyIHkgPSBhZGp1c3RUZXh0WSgwLCBvdXRlckhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pO1xuXG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHgsIHksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RleHRBbGlnbj0nbGVmdCddXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBBZGp1c3RlZCB4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkanVzdFRleHRYKHgsIHdpZHRoLCB0ZXh0QWxpZ24pIHtcbiAgICAgICAgLy8gRklYTUUgUmlnaHQgdG8gbGVmdCBsYW5ndWFnZVxuICAgICAgICBpZiAodGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB4IC09IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHggLT0gd2lkdGggLyAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RleHRWZXJ0aWNhbEFsaWduPSd0b3AnXVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gQWRqdXN0ZWQgeS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGp1c3RUZXh0WSh5LCBoZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgICAgIHkgLT0gaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHkgLT0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge3N0aXJuZ30gdGV4dFBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlY3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB7eCwgeSwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3QodGV4dFBvc2l0aW9uLCByZWN0LCBkaXN0YW5jZSkge1xuXG4gICAgICAgIHZhciB4ID0gcmVjdC54O1xuICAgICAgICB2YXIgeSA9IHJlY3QueTtcblxuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcblxuICAgICAgICB2YXIgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSAndG9wJztcblxuICAgICAgICBzd2l0Y2ggKHRleHRQb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgeCAtPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHggKz0gZGlzdGFuY2UgKyB3aWR0aDtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSAtPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCArIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlJzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZUxlZnQnOlxuICAgICAgICAgICAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVSaWdodCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVUb3AnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVCb3R0b20nOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVRvcExlZnQnOlxuICAgICAgICAgICAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVRvcFJpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlQm90dG9tTGVmdCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVCb3R0b21SaWdodCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogdGV4dFZlcnRpY2FsQWxpZ25cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93IGVsbGlwc2lzIGlmIG92ZXJmbG93LlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gY29udGFpbmVyV2lkdGhcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZvbnRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtlbGxpcHNpcz0nLi4uJ11cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMubWF4SXRlcmF0aW9ucz0zXVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMubWluQ2hhcj0wXSBJZiB0cnVuY2F0ZSByZXN1bHQgYXJlIGxlc3NcbiAgICAgKiAgICAgICAgICAgICAgICAgIHRoZW4gbWluQ2hhciwgZWxsaXBzaXMgd2lsbCBub3Qgc2hvdywgd2hpY2ggaXNcbiAgICAgKiAgICAgICAgICAgICAgICAgIGJldHRlciBmb3IgdXNlciBoaW50IGluIHNvbWUgY2FzZXMuXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5wbGFjZWhvbGRlcj0nJ10gV2hlbiBhbGwgdHJ1bmNhdGVkLCB1c2UgdGhlIHBsYWNlaG9sZGVyLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZVRleHQodGV4dCwgY29udGFpbmVyV2lkdGgsIGZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0TGluZXMgPSAodGV4dCArICcnKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIG9wdGlvbnMgPSBwcmVwYXJlVHJ1bmNhdGVPcHRpb25zKGNvbnRhaW5lcldpZHRoLCBmb250LCBlbGxpcHNpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgLy8gSXQgaXMgbm90IGFwcHJvcHJpYXRlIHRoYXQgZXZlcnkgbGluZSBoYXMgJy4uLicgd2hlbiB0cnVuY2F0ZSBtdWx0aXBsZSBsaW5lcy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGV4dExpbmVzW2ldID0gdHJ1bmNhdGVTaW5nbGVMaW5lKHRleHRMaW5lc1tpXSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dExpbmVzLmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVUcnVuY2F0ZU9wdGlvbnMoY29udGFpbmVyV2lkdGgsIGZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgb3B0aW9ucyk7XG5cbiAgICAgICAgb3B0aW9ucy5mb250ID0gZm9udDtcbiAgICAgICAgdmFyIGVsbGlwc2lzID0gcmV0cmlldmUyKGVsbGlwc2lzLCAnLi4uJyk7XG4gICAgICAgIG9wdGlvbnMubWF4SXRlcmF0aW9ucyA9IHJldHJpZXZlMihvcHRpb25zLm1heEl0ZXJhdGlvbnMsIDIpO1xuICAgICAgICB2YXIgbWluQ2hhciA9IG9wdGlvbnMubWluQ2hhciA9IHJldHJpZXZlMihvcHRpb25zLm1pbkNoYXIsIDApO1xuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBPdGhlciBsYW5ndWFnZXM/XG4gICAgICAgIG9wdGlvbnMuY25DaGFyV2lkdGggPSBnZXRUZXh0V2lkdGgoJ+WbvScsIGZvbnQpO1xuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBDb25zaWRlciBwcm9wb3J0aW9uYWwgZm9udD9cbiAgICAgICAgdmFyIGFzY0NoYXJXaWR0aCA9IG9wdGlvbnMuYXNjQ2hhcldpZHRoID0gZ2V0VGV4dFdpZHRoKCdhJywgZm9udCk7XG4gICAgICAgIG9wdGlvbnMucGxhY2Vob2xkZXIgPSByZXRyaWV2ZTIob3B0aW9ucy5wbGFjZWhvbGRlciwgJycpO1xuXG4gICAgICAgIC8vIEV4YW1wbGUgMTogbWluQ2hhcjogMywgdGV4dDogJ2FzZGZ6eGN2JywgdHJ1bmNhdGUgcmVzdWx0OiAnYXNkZicsIGJ1dCBub3Q6ICdhLi4uJy5cbiAgICAgICAgLy8gRXhhbXBsZSAyOiBtaW5DaGFyOiAzLCB0ZXh0OiAn57u05bqmJywgdHJ1bmNhdGUgcmVzdWx0OiAn57u0JywgYnV0IG5vdDogJy4uLicuXG4gICAgICAgIHZhciBjb250ZW50V2lkdGggPSBjb250YWluZXJXaWR0aCA9IE1hdGgubWF4KDAsIGNvbnRhaW5lcldpZHRoIC0gMSk7IC8vIFJlc2VydmUgc29tZSBnYXAuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluQ2hhciAmJiBjb250ZW50V2lkdGggPj0gYXNjQ2hhcldpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRlbnRXaWR0aCAtPSBhc2NDaGFyV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxsaXBzaXNXaWR0aCA9IGdldFRleHRXaWR0aChlbGxpcHNpcyk7XG4gICAgICAgIGlmIChlbGxpcHNpc1dpZHRoID4gY29udGVudFdpZHRoKSB7XG4gICAgICAgICAgICBlbGxpcHNpcyA9ICcnO1xuICAgICAgICAgICAgZWxsaXBzaXNXaWR0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZW50V2lkdGggPSBjb250YWluZXJXaWR0aCAtIGVsbGlwc2lzV2lkdGg7XG5cbiAgICAgICAgb3B0aW9ucy5lbGxpcHNpcyA9IGVsbGlwc2lzO1xuICAgICAgICBvcHRpb25zLmVsbGlwc2lzV2lkdGggPSBlbGxpcHNpc1dpZHRoO1xuICAgICAgICBvcHRpb25zLmNvbnRlbnRXaWR0aCA9IGNvbnRlbnRXaWR0aDtcbiAgICAgICAgb3B0aW9ucy5jb250YWluZXJXaWR0aCA9IGNvbnRhaW5lcldpZHRoO1xuXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRydW5jYXRlU2luZ2xlTGluZSh0ZXh0TGluZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSBvcHRpb25zLmNvbnRhaW5lcldpZHRoO1xuICAgICAgICB2YXIgZm9udCA9IG9wdGlvbnMuZm9udDtcbiAgICAgICAgdmFyIGNvbnRlbnRXaWR0aCA9IG9wdGlvbnMuY29udGVudFdpZHRoO1xuXG4gICAgICAgIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBnZXRUZXh0V2lkdGgodGV4dExpbmUsIGZvbnQpO1xuXG4gICAgICAgIGlmIChsaW5lV2lkdGggPD0gY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0TGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOzsgaisrKSB7XG4gICAgICAgICAgICBpZiAobGluZVdpZHRoIDw9IGNvbnRlbnRXaWR0aCB8fCBqID49IG9wdGlvbnMubWF4SXRlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgIHRleHRMaW5lICs9IG9wdGlvbnMuZWxsaXBzaXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdWJMZW5ndGggPSBqID09PSAwXG4gICAgICAgICAgICAgICAgPyBlc3RpbWF0ZUxlbmd0aCh0ZXh0TGluZSwgY29udGVudFdpZHRoLCBvcHRpb25zLmFzY0NoYXJXaWR0aCwgb3B0aW9ucy5jbkNoYXJXaWR0aClcbiAgICAgICAgICAgICAgICA6IGxpbmVXaWR0aCA+IDBcbiAgICAgICAgICAgICAgICA/IE1hdGguZmxvb3IodGV4dExpbmUubGVuZ3RoICogY29udGVudFdpZHRoIC8gbGluZVdpZHRoKVxuICAgICAgICAgICAgICAgIDogMDtcblxuICAgICAgICAgICAgdGV4dExpbmUgPSB0ZXh0TGluZS5zdWJzdHIoMCwgc3ViTGVuZ3RoKTtcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IGdldFRleHRXaWR0aCh0ZXh0TGluZSwgZm9udCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dExpbmUgPT09ICcnKSB7XG4gICAgICAgICAgICB0ZXh0TGluZSA9IG9wdGlvbnMucGxhY2Vob2xkZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dExpbmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXN0aW1hdGVMZW5ndGgodGV4dCwgY29udGVudFdpZHRoLCBhc2NDaGFyV2lkdGgsIGNuQ2hhcldpZHRoKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgZm9yICh2YXIgbGVuID0gdGV4dC5sZW5ndGg7IGkgPCBsZW4gJiYgd2lkdGggPCBjb250ZW50V2lkdGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgd2lkdGggKz0gKDAgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gMTI3KSA/IGFzY0NoYXJXaWR0aCA6IGNuQ2hhcldpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9udFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gbGluZSBoZWlnaHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRMaW5lSGVpZ2h0KGZvbnQpIHtcbiAgICAgICAgLy8gRklYTUUgQSByb3VnaCBhcHByb2FjaC5cbiAgICAgICAgcmV0dXJuIGdldFRleHRXaWR0aCgn5Zu9JywgZm9udCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHdpZHRoXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhc3VyZVRleHQodGV4dCwgZm9udCkge1xuICAgICAgICB2YXIgY3R4ID0gdXRpbC5nZXRDb250ZXh0KCk7XG4gICAgICAgIGN0eC5mb250ID0gZm9udCB8fCBERUZBVUxUX0ZPTlQ7XG4gICAgICAgIHJldHVybiBjdHgubWVhc3VyZVRleHQodGV4dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3RydW5jYXRlXVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gYmxvY2s6IHtsaW5lSGVpZ2h0LCBsaW5lcywgaGVpZ2h0LCBvdXRlckhlaWdodH1cbiAgICAgKiAgTm90aWNlOiBmb3IgcGVyZm9ybWFuY2UsIGRvIG5vdCBjYWxjdWxhdGUgb3V0ZXJXaWR0aCB1dGlsIG5lZWRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVBsYWluVGV4dCh0ZXh0LCBmb250LCBwYWRkaW5nLCB0cnVuY2F0ZSkge1xuICAgICAgICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuXG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gZ2V0TGluZUhlaWdodChmb250KTtcbiAgICAgICAgdmFyIGxpbmVzID0gdGV4dCA/IHRleHQuc3BsaXQoJ1xcbicpIDogW107XG4gICAgICAgIHZhciBoZWlnaHQgPSBsaW5lcy5sZW5ndGggKiBsaW5lSGVpZ2h0O1xuICAgICAgICB2YXIgb3V0ZXJIZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgaWYgKHBhZGRpbmcpIHtcbiAgICAgICAgICAgIG91dGVySGVpZ2h0ICs9IHBhZGRpbmdbMF0gKyBwYWRkaW5nWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHQgJiYgdHJ1bmNhdGUpIHtcbiAgICAgICAgICAgIHZhciB0cnVuY091dGVySGVpZ2h0ID0gdHJ1bmNhdGUub3V0ZXJIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgdHJ1bmNPdXRlcldpZHRoID0gdHJ1bmNhdGUub3V0ZXJXaWR0aDtcbiAgICAgICAgICAgIGlmICh0cnVuY091dGVySGVpZ2h0ICE9IG51bGwgJiYgb3V0ZXJIZWlnaHQgPiB0cnVuY091dGVySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgIGxpbmVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0cnVuY091dGVyV2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gcHJlcGFyZVRydW5jYXRlT3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgdHJ1bmNPdXRlcldpZHRoIC0gKHBhZGRpbmcgPyBwYWRkaW5nWzFdICsgcGFkZGluZ1szXSA6IDApLFxuICAgICAgICAgICAgICAgICAgICBmb250LFxuICAgICAgICAgICAgICAgICAgICB0cnVuY2F0ZS5lbGxpcHNpcyxcbiAgICAgICAgICAgICAgICAgICAge21pbkNoYXI6IHRydW5jYXRlLm1pbkNoYXIsIHBsYWNlaG9sZGVyOiB0cnVuY2F0ZS5wbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBub3QgYXBwcm9wcmlhdGUgdGhhdCBldmVyeSBsaW5lIGhhcyAnLi4uJyB3aGVuIHRydW5jYXRlIG11bHRpcGxlIGxpbmVzLlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lc1tpXSA9IHRydW5jYXRlU2luZ2xlTGluZShsaW5lc1tpXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmVzOiBsaW5lcyxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgb3V0ZXJIZWlnaHQ6IG91dGVySGVpZ2h0LFxuICAgICAgICAgICAgbGluZUhlaWdodDogbGluZUhlaWdodFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvciBleGFtcGxlOiAnc29tZSB0ZXh0IHthfHNvbWUgdGV4dH1vdGhlciB0ZXh0e2J8c29tZSB0ZXh0fXh4eHtjfH14eHgnXG4gICAgICogQWxzbyBjb25zaWRlciAnYmJiYnthfHh4eFxcbnp6en14eHh4XFxuYWFhYScuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGJsb2NrXG4gICAgICoge1xuICAgICAqICAgICAgd2lkdGgsXG4gICAgICogICAgICBoZWlnaHQsXG4gICAgICogICAgICBsaW5lczogW3tcbiAgICAgKiAgICAgICAgICBsaW5lSGVpZ2h0LFxuICAgICAqICAgICAgICAgIHdpZHRoLFxuICAgICAqICAgICAgICAgIHRva2VuczogW1t7XG4gICAgICogICAgICAgICAgICAgIHN0eWxlTmFtZSxcbiAgICAgKiAgICAgICAgICAgICAgdGV4dCxcbiAgICAgKiAgICAgICAgICAgICAgd2lkdGgsICAgICAgLy8gaW5jbHVkZSB0ZXh0UGFkZGluZ1xuICAgICAqICAgICAgICAgICAgICBoZWlnaHQsICAgICAvLyBpbmNsdWRlIHRleHRQYWRkaW5nXG4gICAgICogICAgICAgICAgICAgIHRleHRXaWR0aCwgLy8gcHVyZSB0ZXh0IHdpZHRoXG4gICAgICogICAgICAgICAgICAgIHRleHRIZWlnaHQsIC8vIHB1cmUgdGV4dCBoZWlnaHRcbiAgICAgKiAgICAgICAgICAgICAgbGluZUhlaWhndCxcbiAgICAgKiAgICAgICAgICAgICAgZm9udCxcbiAgICAgKiAgICAgICAgICAgICAgdGV4dEFsaWduLFxuICAgICAqICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnblxuICAgICAqICAgICAgICAgIH1dLCBbLi4uXSwgLi4uXVxuICAgICAqICAgICAgfSwgLi4uXVxuICAgICAqIH1cbiAgICAgKiBJZiBzdHlsZU5hbWUgaXMgdW5kZWZpbmVkLCBpdCBpcyBwbGFpbiB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlUmljaFRleHQodGV4dCwgc3R5bGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnRCbG9jayA9IHtsaW5lczogW10sIHdpZHRoOiAwLCBoZWlnaHQ6IDB9O1xuXG4gICAgICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRCbG9jaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0SW5kZXggPSBTVFlMRV9SRUcubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgd2hpbGUgKChyZXN1bHQgPSBTVFlMRV9SRUcuZXhlYyh0ZXh0KSkgIT0gbnVsbCnCoCB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZEluZGV4ID0gcmVzdWx0LmluZGV4O1xuICAgICAgICAgICAgaWYgKG1hdGNoZWRJbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgIHB1c2hUb2tlbnMoY29udGVudEJsb2NrLCB0ZXh0LnN1YnN0cmluZyhsYXN0SW5kZXgsIG1hdGNoZWRJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHVzaFRva2Vucyhjb250ZW50QmxvY2ssIHJlc3VsdFsyXSwgcmVzdWx0WzFdKTtcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IFNUWUxFX1JFRy5sYXN0SW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHB1c2hUb2tlbnMoY29udGVudEJsb2NrLCB0ZXh0LnN1YnN0cmluZyhsYXN0SW5kZXgsIHRleHQubGVuZ3RoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGluZXMgPSBjb250ZW50QmxvY2subGluZXM7XG4gICAgICAgIHZhciBjb250ZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgdmFyIGNvbnRlbnRXaWR0aCA9IDA7XG4gICAgICAgIC8vIEZvciBgdGV4dFdpZHRoOiAxMDAlYFxuICAgICAgICB2YXIgcGVuZGluZ0xpc3QgPSBbXTtcblxuICAgICAgICB2YXIgc3RsUGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuXG4gICAgICAgIHZhciB0cnVuY2F0ZSA9IHN0eWxlLnRydW5jYXRlO1xuICAgICAgICB2YXIgdHJ1bmNhdGVXaWR0aCA9IHRydW5jYXRlICYmIHRydW5jYXRlLm91dGVyV2lkdGg7XG4gICAgICAgIHZhciB0cnVuY2F0ZUhlaWdodCA9IHRydW5jYXRlICYmIHRydW5jYXRlLm91dGVySGVpZ2h0O1xuICAgICAgICBpZiAoc3RsUGFkZGluZykge1xuICAgICAgICAgICAgdHJ1bmNhdGVXaWR0aCAhPSBudWxsICYmICh0cnVuY2F0ZVdpZHRoIC09IHN0bFBhZGRpbmdbMV0gKyBzdGxQYWRkaW5nWzNdKTtcbiAgICAgICAgICAgIHRydW5jYXRlSGVpZ2h0ICE9IG51bGwgJiYgKHRydW5jYXRlSGVpZ2h0IC09IHN0bFBhZGRpbmdbMF0gKyBzdGxQYWRkaW5nWzJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBsYXlvdXQgaW5mbyBvZiB0b2tlbnMuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgICAgICAgICB2YXIgbGluZUhlaWdodCA9IDA7XG4gICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lLnRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IGxpbmUudG9rZW5zW2pdO1xuICAgICAgICAgICAgICAgIHZhciB0b2tlblN0eWxlID0gdG9rZW4uc3R5bGVOYW1lICYmIHN0eWxlLnJpY2hbdG9rZW4uc3R5bGVOYW1lXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAvLyB0ZXh0UGFkZGluZyBzaG91bGQgbm90IGluaGVyaXQgZnJvbSBzdHlsZS5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dFBhZGRpbmcgPSB0b2tlbi50ZXh0UGFkZGluZyA9IHRva2VuU3R5bGUudGV4dFBhZGRpbmc7XG5cbiAgICAgICAgICAgICAgICAvLyB0ZXh0Rm9udCBoYXMgYmVlbiBhc2lnbmVkIHRvIGZvbnQgYnkgYG5vcm1hbGl6ZVN0eWxlYC5cbiAgICAgICAgICAgICAgICB2YXIgZm9udCA9IHRva2VuLmZvbnQgPSB0b2tlblN0eWxlLmZvbnQgfHwgc3R5bGUuZm9udDtcblxuICAgICAgICAgICAgICAgIC8vIHRleHRIZWlnaHQgY2FuIGJlIHVzZWQgd2hlbiB0ZXh0VmVydGljYWxBbGlnbiBpcyBzcGVjaWZpZWQgaW4gdG9rZW4uXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuSGVpZ2h0ID0gdG9rZW4udGV4dEhlaWdodCA9IHJldHJpZXZlMihcbiAgICAgICAgICAgICAgICAgICAgLy8gdGV4dEhlaWdodCBzaG91bGQgbm90IGJlIGluaGVyaXRlZCwgY29uc2lkZXIgaXQgY2FuIGJlIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgICAgICAvLyBhcyBib3ggaGVpZ2h0IG9mIHRoZSBibG9jay5cbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHlsZS50ZXh0SGVpZ2h0LCB0ZXh0Q29udGFpbi5nZXRMaW5lSGVpZ2h0KGZvbnQpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0ZXh0UGFkZGluZyAmJiAodG9rZW5IZWlnaHQgKz0gdGV4dFBhZGRpbmdbMF0gKyB0ZXh0UGFkZGluZ1syXSk7XG4gICAgICAgICAgICAgICAgdG9rZW4uaGVpZ2h0ID0gdG9rZW5IZWlnaHQ7XG4gICAgICAgICAgICAgICAgdG9rZW4ubGluZUhlaWdodCA9IHJldHJpZXZlMyhcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5TdHlsZS50ZXh0TGluZUhlaWdodCwgc3R5bGUudGV4dExpbmVIZWlnaHQsIHRva2VuSGVpZ2h0XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHRva2VuLnRleHRBbGlnbiA9IHRva2VuU3R5bGUgJiYgdG9rZW5TdHlsZS50ZXh0QWxpZ24gfHwgc3R5bGUudGV4dEFsaWduO1xuICAgICAgICAgICAgICAgIHRva2VuLnRleHRWZXJ0aWNhbEFsaWduID0gdG9rZW5TdHlsZSAmJiB0b2tlblN0eWxlLnRleHRWZXJ0aWNhbEFsaWduIHx8ICdtaWRkbGUnO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRydW5jYXRlSGVpZ2h0ICE9IG51bGwgJiYgY29udGVudEhlaWdodCArIHRva2VuLmxpbmVIZWlnaHQgPiB0cnVuY2F0ZUhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2xpbmVzOiBbXSwgd2lkdGg6IDAsIGhlaWdodDogMH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdG9rZW4udGV4dFdpZHRoID0gdGV4dENvbnRhaW4uZ2V0V2lkdGgodG9rZW4udGV4dCwgZm9udCk7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuV2lkdGggPSB0b2tlblN0eWxlLnRleHRXaWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5XaWR0aE5vdFNwZWNpZmllZCA9IHRva2VuV2lkdGggPT0gbnVsbCB8fCB0b2tlbldpZHRoID09PSAnYXV0byc7XG5cbiAgICAgICAgICAgICAgICAvLyBQZXJjZW50IHdpZHRoLCBjYW4gYmUgYDEwMCVgLCBjYW4gYmUgdXNlZCBpbiBkcmF3aW5nIHNlcGFyYXRlXG4gICAgICAgICAgICAgICAgLy8gbGluZSB3aGVuIGJveCB3aWR0aCBpcyBuZWVkZWQgdG8gYmUgYXV0by5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuV2lkdGggPT09ICdzdHJpbmcnICYmIHRva2VuV2lkdGguY2hhckF0KHRva2VuV2lkdGgubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5wZXJjZW50V2lkdGggPSB0b2tlbldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nTGlzdC5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5XaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCB0cnVuY2F0ZSBpbiB0aGlzIGNhc2UsIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXNlciBjYXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpdCBpcyB0b28gY29tcGxpY2F0ZWQuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5XaWR0aE5vdFNwZWNpZmllZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5XaWR0aCA9IHRva2VuLnRleHRXaWR0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IElmIGltYWdlIGlzIG5vdCBsb2FkZWQgYW5kIHRleHRXaWR0aCBpcyBub3Qgc3BlY2lmaWVkLCBjYWxsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgZ2V0Qm91bmRpbmdSZWN0KClgIHdpbGwgbm90IGdldCBjb3JyZWN0IHJlc3VsdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0QmFja2dyb3VuZENvbG9yID0gdG9rZW5TdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJnSW1nID0gdGV4dEJhY2tncm91bmRDb2xvciAmJiB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgY2FzZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAoMSkgSWYgaW1hZ2UgaXMgbm90IGxvYWRlZCwgaXQgd2lsbCBiZSBsb2FkZWQgYXQgcmVuZGVyIHBoYXNlIGFuZCBjYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgZGlydHkoKWAgYW5kIGB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlYCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1hZ2UsIGFuZCB0aGVuIHRoZSByaWdodCBzaXplIHdpbGwgYmUgY2FsY3VsYXRlZCBoZXJlIGF0IHRoZSBuZXh0IHRpY2suXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWUgYGdyYXBoaWMvaGVscGVyL3RleHQuanNgLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKDIpIElmIGltYWdlIGxvYWRlZCwgYW5kIGB0ZXh0QmFja2dyb3VuZENvbG9yLmltYWdlYCBpcyBpbWFnZSBzcmMgc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGBpbWFnZUhlbHBlci5maW5kRXhpc3RJbWFnZWAgdG8gZmluZCBjYWNoZWQgaW1hZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgaW1hZ2VIZWxwZXIuZmluZEV4aXN0SW1hZ2VgIHdpbGwgYWx3YXlzIGJlIGNhbGxlZCBoZXJlIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGltYWdlSGVscGVyLmNyZWF0ZU9yVXBkYXRlSW1hZ2VgIGluIGBncmFwaGljL2hlbHBlci90ZXh0LmpzI3JlbmRlclJpY2hUZXh0YFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggZW5zdXJlcyB0aGF0IGltYWdlIHdpbGwgbm90IGJlIHJlbmRlcmVkIGJlZm9yZSBjb3JyZWN0IHNpemUgY2FsY3VhbHRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZ0ltZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnSW1nID0gaW1hZ2VIZWxwZXIuZmluZEV4aXN0SW1hZ2UoYmdJbWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoYmdJbWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuV2lkdGggPSBNYXRoLm1heCh0b2tlbldpZHRoLCBiZ0ltZy53aWR0aCAqIHRva2VuSGVpZ2h0IC8gYmdJbWcuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ1cgPSB0ZXh0UGFkZGluZyA/IHRleHRQYWRkaW5nWzFdICsgdGV4dFBhZGRpbmdbM10gOiAwO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbldpZHRoICs9IHBhZGRpbmdXO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1pYW5UcnVuY1dpZHRoID0gdHJ1bmNhdGVXaWR0aCAhPSBudWxsID8gdHJ1bmNhdGVXaWR0aCAtIGxpbmVXaWR0aCA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbWlhblRydW5jV2lkdGggIT0gbnVsbCAmJiByZW1pYW5UcnVuY1dpZHRoIDwgdG9rZW5XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0b2tlbldpZHRoTm90U3BlY2lmaWVkIHx8IHJlbWlhblRydW5jV2lkdGggPCBwYWRkaW5nVykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnRleHQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi50ZXh0V2lkdGggPSB0b2tlbldpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnRleHQgPSB0cnVuY2F0ZVRleHQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnRleHQsIHJlbWlhblRydW5jV2lkdGggLSBwYWRkaW5nVywgZm9udCwgdHJ1bmNhdGUuZWxsaXBzaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHttaW5DaGFyOiB0cnVuY2F0ZS5taW5DaGFyfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udGV4dFdpZHRoID0gdGV4dENvbnRhaW4uZ2V0V2lkdGgodG9rZW4udGV4dCwgZm9udCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5XaWR0aCA9IHRva2VuLnRleHRXaWR0aCArIHBhZGRpbmdXO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoICs9ICh0b2tlbi53aWR0aCA9IHRva2VuV2lkdGgpO1xuICAgICAgICAgICAgICAgIHRva2VuU3R5bGUgJiYgKGxpbmVIZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCB0b2tlbi5saW5lSGVpZ2h0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmUud2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICBsaW5lLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgY29udGVudEhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgY29udGVudFdpZHRoID0gTWF0aC5tYXgoY29udGVudFdpZHRoLCBsaW5lV2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGVudEJsb2NrLm91dGVyV2lkdGggPSBjb250ZW50QmxvY2sud2lkdGggPSByZXRyaWV2ZTIoc3R5bGUudGV4dFdpZHRoLCBjb250ZW50V2lkdGgpO1xuICAgICAgICBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQgPSBjb250ZW50QmxvY2suaGVpZ2h0ID0gcmV0cmlldmUyKHN0eWxlLnRleHRIZWlnaHQsIGNvbnRlbnRIZWlnaHQpO1xuXG4gICAgICAgIGlmIChzdGxQYWRkaW5nKSB7XG4gICAgICAgICAgICBjb250ZW50QmxvY2sub3V0ZXJXaWR0aCArPSBzdGxQYWRkaW5nWzFdICsgc3RsUGFkZGluZ1szXTtcbiAgICAgICAgICAgIGNvbnRlbnRCbG9jay5vdXRlckhlaWdodCArPSBzdGxQYWRkaW5nWzBdICsgc3RsUGFkZGluZ1syXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGVuZGluZ0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHBlbmRpbmdMaXN0W2ldO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnRXaWR0aCA9IHRva2VuLnBlcmNlbnRXaWR0aDtcbiAgICAgICAgICAgIC8vIFNob3VsZCBub3QgYmFzZSBvbiBvdXRlcldpZHRoLCBiZWNhdXNlIHRva2VuIGNhbiBub3QgYmUgcGxhY2VkIG91dCBvZiBwYWRkaW5nLlxuICAgICAgICAgICAgdG9rZW4ud2lkdGggPSBwYXJzZUludChwZXJjZW50V2lkdGgsIDEwKSAvIDEwMCAqIGNvbnRlbnRXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250ZW50QmxvY2s7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaFRva2VucyhibG9jaywgc3RyLCBzdHlsZU5hbWUpIHtcbiAgICAgICAgdmFyIGlzRW1wdHlTdHIgPSBzdHIgPT09ICcnO1xuICAgICAgICB2YXIgc3RycyA9IHN0ci5zcGxpdCgnXFxuJyk7XG4gICAgICAgIHZhciBsaW5lcyA9IGJsb2NrLmxpbmVzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Rycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRleHQgPSBzdHJzW2ldO1xuICAgICAgICAgICAgdmFyIHRva2VuID0ge1xuICAgICAgICAgICAgICAgIHN0eWxlTmFtZTogc3R5bGVOYW1lLFxuICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgaXNMaW5lSG9sZGVyOiAhdGV4dCAmJiAhaXNFbXB0eVN0clxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IHRva2VuIHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgbGFzdCBsaW5lLlxuICAgICAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IChsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSB8fCAobGluZXNbMF0gPSB7dG9rZW5zOiBbXX0pKS50b2tlbnM7XG5cbiAgICAgICAgICAgICAgICAvLyBDb25zaWRlciBjYXNlczpcbiAgICAgICAgICAgICAgICAvLyAoMSkgJycuc3BsaXQoJ1xcbicpID0+IFsnJywgJ1xcbicsICcnXSwgdGhlICcnIGF0IHRoZSBmaXJzdCBpdGVtXG4gICAgICAgICAgICAgICAgLy8gKHdoaWNoIGlzIGEgcGxhY2Vob2xkZXIpIHNob3VsZCBiZSByZXBsYWNlZCBieSBuZXcgdG9rZW4uXG4gICAgICAgICAgICAgICAgLy8gKDIpIEEgaW1hZ2UgYmFja2FnZSwgd2hlcmUgdG9rZW4gbGlrZXMge2F8fS5cbiAgICAgICAgICAgICAgICAvLyAoMykgQSByZWR1bmRhbnQgJycgd2lsbCBhZmZlY3QgdGV4dEFsaWduIGluIGxpbmUuXG4gICAgICAgICAgICAgICAgLy8gKDQpIHRva2VucyB3aXRoIHRoZSBzYW1lIHRwbE5hbWUgc2hvdWxkIG5vdCBiZSBtZXJnZWQsIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAvLyB0aGV5IHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gZGlmZmVyZW50IGJveCAod2l0aCBib3JkZXIgYW5kIHBhZGRpbmcpLlxuICAgICAgICAgICAgICAgIHZhciB0b2tlbnNMZW4gPSB0b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICh0b2tlbnNMZW4gPT09IDEgJiYgdG9rZW5zWzBdLmlzTGluZUhvbGRlcilcbiAgICAgICAgICAgICAgICAgICAgPyAodG9rZW5zWzBdID0gdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIHRleHQgaXMgJycsIG9ubHkgaW5zZXJ0IHdoZW4gaXQgaXMgdGhlIFwibGluZUhvbGRlclwiIG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIFwiZW1wdHlTdHJcIi4gT3RoZXJ3aXNlIGEgcmVkdW5kYW50ICcnIHdpbGwgYWZmZWN0IHRleHRBbGlnbiBpbiBsaW5lLlxuICAgICAgICAgICAgICAgICAgICA6ICgodGV4dCB8fCAhdG9rZW5zTGVuIHx8IGlzRW1wdHlTdHIpICYmIHRva2Vucy5wdXNoKHRva2VuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlciB0b2tlbnMgYWx3YXlzIHN0YXJ0IGEgbmV3IGxpbmUuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyAnJywgaW5zZXJ0IGl0IGFzIGEgcGxhY2Vob2xkZXIuXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCh7dG9rZW5zOiBbdG9rZW5dfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9udChzdHlsZSkge1xuICAgICAgICAvLyBGSVhNRSBpbiBub2RlLWNhbnZhcyBmb250V2VpZ2h0IGlzIGJlZm9yZSBmb250U3R5bGVcbiAgICAgICAgLy8gVXNlIGBmb250U2l6ZWAgYGZvbnRGYW1pbHlgIHRvIGNoZWNrIHdoZXRoZXIgZm9udCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLlxuICAgICAgICByZXR1cm4gKHN0eWxlLmZvbnRTaXplIHx8IHN0eWxlLmZvbnRGYW1pbHkpICYmIFtcbiAgICAgICAgICAgIHN0eWxlLmZvbnRTdHlsZSxcbiAgICAgICAgICAgIHN0eWxlLmZvbnRXZWlnaHQsXG4gICAgICAgICAgICAoc3R5bGUuZm9udFNpemUgfHwgMTIpICsgJ3B4JyxcbiAgICAgICAgICAgIC8vIElmIGZvbnQgcHJvcGVydGllcyBhcmUgZGVmaW5lZCwgYGZvbnRGYW1pbHlgIHNob3VsZCBub3QgYmUgaWdub3JlZC5cbiAgICAgICAgICAgIHN0eWxlLmZvbnRGYW1pbHkgfHwgJ3NhbnMtc2VyaWYnXG4gICAgICAgIF0uam9pbignICcpIHx8IHN0eWxlLnRleHRGb250IHx8IHN0eWxlLmZvbnQ7XG4gICAgfVxuXG4gICAgdmFyIHRleHRDb250YWluID0ge1xuXG4gICAgICAgIGdldFdpZHRoOiBnZXRUZXh0V2lkdGgsXG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBnZXRUZXh0UmVjdCxcblxuICAgICAgICBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3Q6IGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCxcblxuICAgICAgICB0cnVuY2F0ZVRleHQ6IHRydW5jYXRlVGV4dCxcblxuICAgICAgICBtZWFzdXJlVGV4dDogbWVhc3VyZVRleHQsXG5cbiAgICAgICAgZ2V0TGluZUhlaWdodDogZ2V0TGluZUhlaWdodCxcblxuICAgICAgICBwYXJzZVBsYWluVGV4dDogcGFyc2VQbGFpblRleHQsXG5cbiAgICAgICAgcGFyc2VSaWNoVGV4dDogcGFyc2VSaWNoVGV4dCxcblxuICAgICAgICBhZGp1c3RUZXh0WDogYWRqdXN0VGV4dFgsXG5cbiAgICAgICAgYWRqdXN0VGV4dFk6IGFkanVzdFRleHRZLFxuXG4gICAgICAgIG1ha2VGb250OiBtYWtlRm9udCxcblxuICAgICAgICBERUZBVUxUX0ZPTlQ6IERFRkFVTFRfRk9OVFxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRleHRDb250YWluO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9jb250YWluL3RleHQuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0XG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xuXG4gICAgdmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCb3VuZGluZ1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG4gICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgIHggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cblxuICAgIEJvdW5kaW5nUmVjdC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEJvdW5kaW5nUmVjdCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH0gb3RoZXJcbiAgICAgICAgICovXG4gICAgICAgIHVuaW9uOiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gbWF0aE1pbihvdGhlci54LCB0aGlzLngpO1xuICAgICAgICAgICAgdmFyIHkgPSBtYXRoTWluKG90aGVyLnksIHRoaXMueSk7XG5cbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBtYXRoTWF4KFxuICAgICAgICAgICAgICAgICAgICBvdGhlci54ICsgb3RoZXIud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCArIHRoaXMud2lkdGhcbiAgICAgICAgICAgICAgICApIC0geDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gbWF0aE1heChcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIueSArIG90aGVyLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ICsgdGhpcy5oZWlnaHRcbiAgICAgICAgICAgICAgICApIC0geTtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtXG4gICAgICAgICAqIEBtZXRob2RzXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseVRyYW5zZm9ybTogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsdCA9IFtdO1xuICAgICAgICAgICAgdmFyIHJiID0gW107XG4gICAgICAgICAgICB2YXIgbGIgPSBbXTtcbiAgICAgICAgICAgIHZhciBydCA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB1c2FnZSBsaWtlIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBlbC5nZXRCb3VuZGluZ1JlY3QoKS5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgLy8gQW5kIGVsZW1lbnQgaGFzIG5vIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGx0WzBdID0gbGJbMF0gPSB0aGlzLng7XG4gICAgICAgICAgICAgICAgbHRbMV0gPSBydFsxXSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICByYlswXSA9IHJ0WzBdID0gdGhpcy54ICsgdGhpcy53aWR0aDtcbiAgICAgICAgICAgICAgICByYlsxXSA9IGxiWzFdID0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKGx0LCBsdCwgbSk7XG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShyYiwgcmIsIG0pO1xuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0obGIsIGxiLCBtKTtcbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHJ0LCBydCwgbSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnggPSBtYXRoTWluKGx0WzBdLCByYlswXSwgbGJbMF0sIHJ0WzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSBtYXRoTWluKGx0WzFdLCByYlsxXSwgbGJbMV0sIHJ0WzFdKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4WCA9IG1hdGhNYXgobHRbMF0sIHJiWzBdLCBsYlswXSwgcnRbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBtYXhZID0gbWF0aE1heChsdFsxXSwgcmJbMV0sIGxiWzFdLCBydFsxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IG1heFggLSB0aGlzLng7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBtYXhZIC0gdGhpcy55O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIG1hdHJpeCBvZiB0cmFuc2Zvcm1pbmcgZnJvbSBzZWxmIHRvIHRhcmdldCByZWN0XG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSBiXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgY2FsY3VsYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHN4ID0gYi53aWR0aCAvIGEud2lkdGg7XG4gICAgICAgICAgICB2YXIgc3kgPSBiLmhlaWdodCAvIGEuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgbSA9IG1hdHJpeC5jcmVhdGUoKTtcblxuICAgICAgICAgICAgLy8g55+p6Zi15Y+z5LmYXG4gICAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFstYS54LCAtYS55XSk7XG4gICAgICAgICAgICBtYXRyaXguc2NhbGUobSwgbSwgW3N4LCBzeV0pO1xuICAgICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbYi54LCBiLnldKTtcblxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7KG1vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fE9iamVjdCl9IGJcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGludGVyc2VjdDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoYiBpbnN0YW5jZW9mIEJvdW5kaW5nUmVjdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxpemUgbmVnYXRpdmUgd2lkdGgvaGVpZ2h0LlxuICAgICAgICAgICAgICAgIGIgPSBCb3VuZGluZ1JlY3QuY3JlYXRlKGIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXgwID0gYS54O1xuICAgICAgICAgICAgdmFyIGF4MSA9IGEueCArIGEud2lkdGg7XG4gICAgICAgICAgICB2YXIgYXkwID0gYS55O1xuICAgICAgICAgICAgdmFyIGF5MSA9IGEueSArIGEuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgYngwID0gYi54O1xuICAgICAgICAgICAgdmFyIGJ4MSA9IGIueCArIGIud2lkdGg7XG4gICAgICAgICAgICB2YXIgYnkwID0gYi55O1xuICAgICAgICAgICAgdmFyIGJ5MSA9IGIueSArIGIuaGVpZ2h0O1xuXG4gICAgICAgICAgICByZXR1cm4gISAoYXgxIDwgYngwIHx8IGJ4MSA8IGF4MCB8fCBheTEgPCBieTAgfHwgYnkxIDwgYXkwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHggPj0gcmVjdC54XG4gICAgICAgICAgICAgICAgJiYgeCA8PSAocmVjdC54ICsgcmVjdC53aWR0aClcbiAgICAgICAgICAgICAgICAmJiB5ID49IHJlY3QueVxuICAgICAgICAgICAgICAgICYmIHkgPD0gKHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29weSBmcm9tIGFub3RoZXIgcmVjdFxuICAgICAgICAgKi9cbiAgICAgICAgY29weTogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICB0aGlzLnggPSBvdGhlci54O1xuICAgICAgICAgICAgdGhpcy55ID0gb3RoZXIueTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBvdGhlci53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gb3RoZXIuaGVpZ2h0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBsYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxtb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gcmVjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LnhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVjdC55XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlY3Qud2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVjdC5oZWlnaHRcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgKi9cbiAgICBCb3VuZGluZ1JlY3QuY3JlYXRlID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCb3VuZGluZ1JlY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuICAgIHZhciBMUlUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0xSVScpO1xuICAgIHZhciBnbG9iYWxJbWFnZUNhY2hlID0gbmV3IExSVSg1MCk7XG5cbiAgICB2YXIgaGVscGVyID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gbmV3SW1hZ2VPclNyY1xuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZVxuICAgICAqL1xuICAgIGhlbHBlci5maW5kRXhpc3RJbWFnZSA9IGZ1bmN0aW9uIChuZXdJbWFnZU9yU3JjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3SW1hZ2VPclNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZWRJbWdPYmogPSBnbG9iYWxJbWFnZUNhY2hlLmdldChuZXdJbWFnZU9yU3JjKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRJbWdPYmogJiYgY2FjaGVkSW1nT2JqLmltYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ld0ltYWdlT3JTcmM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2F1dGlvbjogVXNlciBzaG91bGQgY2FjaGUgbG9hZGVkIGltYWdlcywgYnV0IG5vdCBqdXN0IGNvdW50IG9uIExSVS5cbiAgICAgKiBDb25zaWRlciBpZiByZXF1aXJlZCBpbWFnZXMgbW9yZSB0aGFuIExSVSBzaXplLCB3aWxsIGRlYWQgbG9vcCBvY2N1cj9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBuZXdJbWFnZU9yU3JjXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fENhbnZhc30gaW1hZ2UgRXhpc3RlbnQgaW1hZ2UuXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBbaG9zdEVsXSBGb3IgY2FsbGluZyBgZGlydHlgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gcGFyYW1zOiAoaW1hZ2UsIGNiUGF5bG9hZClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NiUGF5bG9hZF0gUGF5bG9hZCBvbiBjYiBjYWxsaW5nLlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZVxuICAgICAqL1xuICAgIGhlbHBlci5jcmVhdGVPclVwZGF0ZUltYWdlID0gZnVuY3Rpb24gKG5ld0ltYWdlT3JTcmMsIGltYWdlLCBob3N0RWwsIGNiLCBjYlBheWxvYWQpIHtcbiAgICAgICAgaWYgKCFuZXdJbWFnZU9yU3JjKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5ld0ltYWdlT3JTcmMgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgIC8vIEltYWdlIHNob3VsZCBub3QgYmUgbG9hZGVkIHJlcGVhdGx5LlxuICAgICAgICAgICAgaWYgKChpbWFnZSAmJiBpbWFnZS5fX3pySW1hZ2VTcmMgPT09IG5ld0ltYWdlT3JTcmMpIHx8ICFob3N0RWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9ubHkgd2hlbiB0aGVyZSBpcyBubyBleGlzdGVudCBpbWFnZSBvciBleGlzdGVudCBpbWFnZSBzcmNcbiAgICAgICAgICAgIC8vIGlzIGRpZmZlcmVudCwgdGhpcyBtZXRob2QgaXMgcmVzcG9uc2libGUgZm9yIGxvYWQuXG4gICAgICAgICAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQobmV3SW1hZ2VPclNyYyk7XG5cbiAgICAgICAgICAgIHZhciBwZW5kaW5nV3JhcCA9IHtob3N0RWw6IGhvc3RFbCwgY2I6IGNiLCBjYlBheWxvYWQ6IGNiUGF5bG9hZH07XG5cbiAgICAgICAgICAgIGlmIChjYWNoZWRJbWdPYmopIHtcbiAgICAgICAgICAgICAgICBpbWFnZSA9IGNhY2hlZEltZ09iai5pbWFnZTtcbiAgICAgICAgICAgICAgICAhaXNJbWFnZVJlYWR5KGltYWdlKSAmJiBjYWNoZWRJbWdPYmoucGVuZGluZy5wdXNoKHBlbmRpbmdXcmFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICFpbWFnZSAmJiAoaW1hZ2UgPSBuZXcgSW1hZ2UoKSk7XG4gICAgICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gaW1hZ2VPbkxvYWQ7XG5cbiAgICAgICAgICAgICAgICBnbG9iYWxJbWFnZUNhY2hlLnB1dChcbiAgICAgICAgICAgICAgICAgICAgbmV3SW1hZ2VPclNyYyxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UuX19jYWNoZWRJbWdPYmogPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nOiBbcGVuZGluZ1dyYXBdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gaW1hZ2UuX196ckltYWdlU3JjID0gbmV3SW1hZ2VPclNyYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5ld0ltYWdlT3JTcmMgaXMgYW4gSFRNTEltYWdlRWxlbWVudCBvciBIVE1MQ2FudmFzRWxlbWVudCBvciBDYW52YXNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3SW1hZ2VPclNyYztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbWFnZU9uTG9hZCgpIHtcbiAgICAgICAgdmFyIGNhY2hlZEltZ09iaiA9IHRoaXMuX19jYWNoZWRJbWdPYmo7XG4gICAgICAgIHRoaXMub25sb2FkID0gdGhpcy5fX2NhY2hlZEltZ09iaiA9IG51bGw7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZWRJbWdPYmoucGVuZGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBlbmRpbmdXcmFwID0gY2FjaGVkSW1nT2JqLnBlbmRpbmdbaV07XG4gICAgICAgICAgICB2YXIgY2IgPSBwZW5kaW5nV3JhcC5jYjtcbiAgICAgICAgICAgIGNiICYmIGNiKHRoaXMsIHBlbmRpbmdXcmFwLmNiUGF5bG9hZCk7XG4gICAgICAgICAgICBwZW5kaW5nV3JhcC5ob3N0RWwuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZWRJbWdPYmoucGVuZGluZy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIHZhciBpc0ltYWdlUmVhZHkgPSBoZWxwZXIuaXNJbWFnZVJlYWR5ID0gZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgIHJldHVybiBpbWFnZSAmJiBpbWFnZS53aWR0aCAmJiBpbWFnZS5oZWlnaHQ7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gaGVscGVyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgciA9IHNoYXBlLnI7XG4gICAgICAgICAgICB2YXIgcjE7XG4gICAgICAgICAgICB2YXIgcjI7XG4gICAgICAgICAgICB2YXIgcjM7XG4gICAgICAgICAgICB2YXIgcjQ7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgd2lkdGggYW5kIGhlaWdodCB0byBwb3NpdGl2ZSBmb3IgYmV0dGVyIGJvcmRlclJhZGl1c1xuICAgICAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgICAgICAgIHggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgICAgIHkgPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSByWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICByMSA9IHIzID0gclswXTtcbiAgICAgICAgICAgICAgICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHIxID0gclswXTtcbiAgICAgICAgICAgICAgICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgICAgICAgICAgICAgICAgIHIzID0gclsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHIxID0gclswXTtcbiAgICAgICAgICAgICAgICAgICAgcjIgPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICByMyA9IHJbMl07XG4gICAgICAgICAgICAgICAgICAgIHI0ID0gclszXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b3RhbDtcbiAgICAgICAgICAgIGlmIChyMSArIHIyID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHIxICsgcjI7XG4gICAgICAgICAgICAgICAgcjEgKj0gd2lkdGggLyB0b3RhbDtcbiAgICAgICAgICAgICAgICByMiAqPSB3aWR0aCAvIHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIzICsgcjQgPiB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gcjMgKyByNDtcbiAgICAgICAgICAgICAgICByMyAqPSB3aWR0aCAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIHI0ICo9IHdpZHRoIC8gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocjIgKyByMyA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gcjIgKyByMztcbiAgICAgICAgICAgICAgICByMiAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICAgICAgICAgICAgICByMyAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyMSArIHI0ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSByMSArIHI0O1xuICAgICAgICAgICAgICAgIHIxICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIHI0ICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgcjEsIHkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByMiwgeSk7XG4gICAgICAgICAgICByMiAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHIyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByMyk7XG4gICAgICAgICAgICByMyAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHIzLCB5ICsgaGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgcjQsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgcjQgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHI0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcjEpO1xuICAgICAgICAgICAgcjEgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHIxLCB5KTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBQYXRoIOS7o+eQhu+8jOWPr+S7peWcqGBidWlsZFBhdGhg5Lit55So5LqO5pu/5LujYGN0eGAsIOS8muS/neWtmOavj+S4qnBhdGjmk43kvZznmoTlkb3ku6TliLBwYXRoQ29tbWFuZHPlsZ7mgKfkuK1cbiAqIOWPr+S7peeUqOS6jiBpc0luc2lkZVBhdGgg5Yik5pat5Lul5Y+K6I635Y+WYm91bmRpbmdSZWN0XG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvUGF0aFByb3h5XG4gKiBAYXV0aG9yIFlpIFNoZW4gKGh0dHA6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cbiAvLyBUT0RPIGdldFRvdGFsTGVuZ3RoLCBnZXRQb2ludEF0TGVuZ3RoXG5cblxuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4vY3VydmUnKTtcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG4gICAgdmFyIGJib3ggPSByZXF1aXJlKCcuL2Jib3gnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi9Cb3VuZGluZ1JlY3QnKTtcbiAgICB2YXIgZHByID0gcmVxdWlyZSgnLi4vY29uZmlnJykuZGV2aWNlUGl4ZWxSYXRpbztcblxuICAgIHZhciBDTUQgPSB7XG4gICAgICAgIE06IDEsXG4gICAgICAgIEw6IDIsXG4gICAgICAgIEM6IDMsXG4gICAgICAgIFE6IDQsXG4gICAgICAgIEE6IDUsXG4gICAgICAgIFo6IDYsXG4gICAgICAgIC8vIFJlY3RcbiAgICAgICAgUjogN1xuICAgIH07XG5cbiAgICAvLyB2YXIgQ01EX01FTV9TSVpFID0ge1xuICAgIC8vICAgICBNOiAzLFxuICAgIC8vICAgICBMOiAzLFxuICAgIC8vICAgICBDOiA3LFxuICAgIC8vICAgICBROiA1LFxuICAgIC8vICAgICBBOiA5LFxuICAgIC8vICAgICBSOiA1LFxuICAgIC8vICAgICBaOiAxXG4gICAgLy8gfTtcblxuICAgIHZhciBtaW4gPSBbXTtcbiAgICB2YXIgbWF4ID0gW107XG4gICAgdmFyIG1pbjIgPSBbXTtcbiAgICB2YXIgbWF4MiA9IFtdO1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICB2YXIgbWF0aENvcyA9IE1hdGguY29zO1xuICAgIHZhciBtYXRoU2luID0gTWF0aC5zaW47XG4gICAgdmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICB2YXIgaGFzVHlwZWRBcnJheSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgUGF0aFByb3h5ID0gZnVuY3Rpb24gKG5vdFNhdmVEYXRhKSB7XG5cbiAgICAgICAgdGhpcy5fc2F2ZURhdGEgPSAhKG5vdFNhdmVEYXRhIHx8IGZhbHNlKTtcblxuICAgICAgICBpZiAodGhpcy5fc2F2ZURhdGEpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGF0aCBkYXRhLiBTdG9yZWQgYXMgZmxhdCBhcnJheVxuICAgICAgICAgICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2N0eCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOW/q+mAn+iuoeeul1BhdGjljIXlm7Tnm5LvvIjlubbkuI3mmK/mnIDlsI/ljIXlm7Tnm5LvvIlcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgUGF0aFByb3h5LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogUGF0aFByb3h5LFxuXG4gICAgICAgIF94aTogMCxcbiAgICAgICAgX3lpOiAwLFxuXG4gICAgICAgIF94MDogMCxcbiAgICAgICAgX3kwOiAwLFxuICAgICAgICAvLyBVbml0IHgsIFVuaXQgeS4gUHJvdmlkZSBmb3IgYXZvaWRpbmcgZHJhd2luZyB0aGF0IHRvbyBzaG9ydCBsaW5lIHNlZ21lbnRcbiAgICAgICAgX3V4OiAwLFxuICAgICAgICBfdXk6IDAsXG5cbiAgICAgICAgX2xlbjogMCxcblxuICAgICAgICBfbGluZURhc2g6IG51bGwsXG5cbiAgICAgICAgX2Rhc2hPZmZzZXQ6IDAsXG5cbiAgICAgICAgX2Rhc2hJZHg6IDAsXG5cbiAgICAgICAgX2Rhc2hTdW06IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0U2NhbGU6IGZ1bmN0aW9uIChzeCwgc3kpIHtcbiAgICAgICAgICAgIHRoaXMuX3V4ID0gbWF0aEFicygxIC8gZHByIC8gc3gpIHx8IDA7XG4gICAgICAgICAgICB0aGlzLl91eSA9IG1hdGhBYnMoMSAvIGRwciAvIHN5KSB8fCAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdHg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgYmVnaW5QYXRoOiBmdW5jdGlvbiAoY3R4KSB7XG5cbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IGN0eDtcblxuICAgICAgICAgICAgY3R4ICYmIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgY3R4ICYmICh0aGlzLmRwciA9IGN0eC5kcHIpO1xuXG4gICAgICAgICAgICAvLyBSZXNldFxuICAgICAgICAgICAgaWYgKHRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmVEYXNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZURhc2ggPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZVRvOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKENNRC5NLCB4LCB5KTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHgubW92ZVRvKHgsIHkpO1xuXG4gICAgICAgICAgICAvLyB4MCwgeTAsIHhpLCB5aSDmmK/orrDlvZXlnKggX2Rhc2hlZFhYWFhUbyDmlrnms5XkuK3kvb/nlKhcbiAgICAgICAgICAgIC8vIHhpLCB5aSDorrDlvZXlvZPliY3ngrksIHgwLCB5MCDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeWbnuWIsOi1t+Wni+eCueOAglxuICAgICAgICAgICAgLy8g5pyJ5Y+v6IO95ZyoIGJlZ2luUGF0aCDkuYvlkI7nm7TmjqXosIPnlKggbGluZVRv77yM6L+Z5pe25YCZIHgwLCB5MCDpnIDopoFcbiAgICAgICAgICAgIC8vIOWcqCBsaW5lVG8g5pa55rOV5Lit6K6w5b2V77yM6L+Z6YeM5YWI5LiN6ICD6JmR6L+Z56eN5oOF5Ya177yMZGFzaGVkIGxpbmUg5Lmf5Y+q5ZyoIElFMTAtIOS4reS4jeaUr+aMgVxuICAgICAgICAgICAgdGhpcy5feDAgPSB4O1xuICAgICAgICAgICAgdGhpcy5feTAgPSB5O1xuXG4gICAgICAgICAgICB0aGlzLl94aSA9IHg7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgbGluZVRvOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGV4Y2VlZFVuaXQgPSBtYXRoQWJzKHggLSB0aGlzLl94aSkgPiB0aGlzLl91eFxuICAgICAgICAgICAgICAgIHx8IG1hdGhBYnMoeSAtIHRoaXMuX3lpKSA+IHRoaXMuX3V5XG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgZHJhdyB0aGUgZmlyc3Qgc2VnbWVudFxuICAgICAgICAgICAgICAgIHx8IHRoaXMuX2xlbiA8IDU7XG5cbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuTCwgeCwgeSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9jdHggJiYgZXhjZWVkVW5pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkTGluZVRvKHgsIHkpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleGNlZWRVbml0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feGkgPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3lpID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4M1xuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkzXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuQywgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNEYXNoKCkgPyB0aGlzLl9kYXNoZWRCZXppZXJUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2N0eC5iZXppZXJDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5feGkgPSB4MztcbiAgICAgICAgICAgIHRoaXMuX3lpID0geTM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5MlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKENNRC5RLCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNEYXNoKCkgPyB0aGlzLl9kYXNoZWRRdWFkcmF0aWNUbyh4MSwgeTEsIHgyLCB5MilcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9jdHgucXVhZHJhdGljQ3VydmVUbyh4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl94aSA9IHgyO1xuICAgICAgICAgICAgdGhpcy5feWkgPSB5MjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gY3lcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSByXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gc3RhcnRBbmdsZVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGVuZEFuZ2xlXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGFudGljbG9ja3dpc2VcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBhcmM6IGZ1bmN0aW9uIChjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoXG4gICAgICAgICAgICAgICAgQ01ELkEsIGN4LCBjeSwgciwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlLCAwLCBhbnRpY2xvY2t3aXNlID8gMCA6IDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4LmFyYyhjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKTtcblxuICAgICAgICAgICAgdGhpcy5feGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHIgKyBjeDtcbiAgICAgICAgICAgIHRoaXMuX3lpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByICsgY3g7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIGFyY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N0eC5hcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgcmVjdDogZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuUiwgeCwgeSwgdywgaCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZVBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuWik7XG5cbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICB2YXIgeDAgPSB0aGlzLl94MDtcbiAgICAgICAgICAgIHZhciB5MCA9IHRoaXMuX3kwO1xuICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpICYmIHRoaXMuX2Rhc2hlZExpbmVUbyh4MCwgeTApO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5feGkgPSB4MDtcbiAgICAgICAgICAgIHRoaXMuX3lpID0geTA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGV4dCDku47lpJbpg6jkvKDlhaXvvIzlm6DkuLrmnInlj6/og73mmK8gcmVidWlsZFBhdGgg5a6M5LmL5ZCO5YaNIGZpbGzjgIJcbiAgICAgICAgICogc3Ryb2tlIOWQjOagt1xuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsbDogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgY3R4ICYmIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB0aGlzLnRvU3RhdGljKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBzdHJva2U6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIGN0eCAmJiBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB0aGlzLnRvU3RhdGljKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW/hemhu+WcqOWFtuWug+e7mOWItuWRveS7pOWJjeiwg+eUqFxuICAgICAgICAgKiBNdXN0IGJlIGludm9rZWQgYmVmb3JlIGFsbCBvdGhlciBwYXRoIGRyYXdpbmcgbWV0aG9kc1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIHNldExpbmVEYXNoOiBmdW5jdGlvbiAobGluZURhc2gpIHtcbiAgICAgICAgICAgIGlmIChsaW5lRGFzaCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZURhc2ggPSBsaW5lRGFzaDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Rhc2hJZHggPSAwO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVEYXNoU3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVEYXNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVEYXNoU3VtICs9IGxpbmVEYXNoW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kYXNoU3VtID0gbGluZURhc2hTdW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5b+F6aG75Zyo5YW25a6D57uY5Yi25ZG95Luk5YmN6LCD55SoXG4gICAgICAgICAqIE11c3QgYmUgaW52b2tlZCBiZWZvcmUgYWxsIG90aGVyIHBhdGggZHJhd2luZyBtZXRob2RzXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0TGluZURhc2hPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGxlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog55u05o6l6K6+572uIFBhdGgg5pWw5o2uXG4gICAgICAgICAqL1xuICAgICAgICBzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuXG4gICAgICAgICAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICghICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmxlbmd0aCA9PSBsZW4pICYmIGhhc1R5cGVkQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGxlbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSBkYXRhW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9sZW4gPSBsZW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWtkOi3r+W+hFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fEFycmF5Ljxtb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eT59IHBhdGhcbiAgICAgICAgICovXG4gICAgICAgIGFwcGVuZFBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IFtwYXRoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBhcHBlbmRTaXplID0gMDtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9sZW47XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kU2l6ZSArPSBwYXRoW2ldLmxlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1R5cGVkQXJyYXkgJiYgKHRoaXMuZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KG9mZnNldCArIGFwcGVuZFNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBhcHBlbmRQYXRoRGF0YSA9IHBhdGhbaV0uZGF0YTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGFwcGVuZFBhdGhEYXRhLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtvZmZzZXQrK10gPSBhcHBlbmRQYXRoRGF0YVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sZW4gPSBvZmZzZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWhq+WFhSBQYXRoIOaVsOaNruOAglxuICAgICAgICAgKiDlsL3ph4/lpI3nlKjogIzkuI3nlLPmmI7mlrDnmoTmlbDnu4TjgILlpKfpg6jliIblm77lvaLph43nu5jnmoTmjIfku6TmlbDmja7plb/luqbpg73mmK/kuI3lj5jnmoTjgIJcbiAgICAgICAgICovXG4gICAgICAgIGFkZERhdGE6IGZ1bmN0aW9uIChjbWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc2F2ZURhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xlbiArIGFyZ3VtZW50cy5sZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIOWboOS4uuS5i+WJjeeahOaVsOe7hOW3sue7j+i9rOaNouaIkOmdmeaAgeeahCBGbG9hdDMyQXJyYXlcbiAgICAgICAgICAgICAgICAvLyDmiYDku6XkuI3lpJ/nlKjml7bpnIDopoHmianlsZXkuIDkuKrmlrDnmoTliqjmgIHmlbDnu4RcbiAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmREYXRhKCk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YVt0aGlzLl9sZW4rK10gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3ByZXZDbWQgPSBjbWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2V4cGFuZERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgaWYgZGF0YSBpcyBGbG9hdDMyQXJyYXlcbiAgICAgICAgICAgIGlmICghKHRoaXMuZGF0YSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW2ldID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXdEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBuZWVkcyBqcyBpbXBsZW1lbnRlZCBkYXNoZWQgbGluZVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX25lZWRzRGFzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVEYXNoO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kYXNoZWRMaW5lVG86IGZ1bmN0aW9uICh4MSwgeTEpIHtcbiAgICAgICAgICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9kYXNoT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gdGhpcy5fbGluZURhc2g7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXG4gICAgICAgICAgICB2YXIgeDAgPSB0aGlzLl94aTtcbiAgICAgICAgICAgIHZhciB5MCA9IHRoaXMuX3lpO1xuICAgICAgICAgICAgdmFyIGR4ID0geDEgLSB4MDtcbiAgICAgICAgICAgIHZhciBkeSA9IHkxIC0geTA7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgIHZhciB4ID0geDA7XG4gICAgICAgICAgICB2YXIgeSA9IHkwO1xuICAgICAgICAgICAgdmFyIGRhc2g7XG4gICAgICAgICAgICB2YXIgbkRhc2ggPSBsaW5lRGFzaC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaWR4O1xuICAgICAgICAgICAgZHggLz0gZGlzdDtcbiAgICAgICAgICAgIGR5IC89IGRpc3Q7XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBwb3NpdGl2ZSBvZmZzZXRcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBkYXNoU3VtICsgb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICU9IGRhc2hTdW07XG4gICAgICAgICAgICB4IC09IG9mZnNldCAqIGR4O1xuICAgICAgICAgICAgeSAtPSBvZmZzZXQgKiBkeTtcblxuICAgICAgICAgICAgd2hpbGUgKChkeCA+IDAgJiYgeCA8PSB4MSkgfHwgKGR4IDwgMCAmJiB4ID49IHgxKVxuICAgICAgICAgICAgfHwgKGR4ID09IDAgJiYgKChkeSA+IDAgJiYgeSA8PSB5MSkgfHwgKGR5IDwgMCAmJiB5ID49IHkxKSkpKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gdGhpcy5fZGFzaElkeDtcbiAgICAgICAgICAgICAgICBkYXNoID0gbGluZURhc2hbaWR4XTtcbiAgICAgICAgICAgICAgICB4ICs9IGR4ICogZGFzaDtcbiAgICAgICAgICAgICAgICB5ICs9IGR5ICogZGFzaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXNoSWR4ID0gKGlkeCArIDEpICUgbkRhc2g7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBwb3NpdGl2ZSBvZmZzZXRcbiAgICAgICAgICAgICAgICBpZiAoKGR4ID4gMCAmJiB4IDwgeDApIHx8IChkeCA8IDAgJiYgeCA+IHgwKSB8fCAoZHkgPiAwICYmIHkgPCB5MCkgfHwgKGR5IDwgMCAmJiB5ID4geTApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHhbaWR4ICUgMiA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKFxuICAgICAgICAgICAgICAgICAgICBkeCA+PSAwID8gbWF0aE1pbih4LCB4MSkgOiBtYXRoTWF4KHgsIHgxKSxcbiAgICAgICAgICAgICAgICAgICAgZHkgPj0gMCA/IG1hdGhNaW4oeSwgeTEpIDogbWF0aE1heCh5LCB5MSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT2Zmc2V0IGZvciBuZXh0IGxpbmVUb1xuICAgICAgICAgICAgZHggPSB4IC0geDE7XG4gICAgICAgICAgICBkeSA9IHkgLSB5MTtcbiAgICAgICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAtbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE5vdCBhY2N1cmF0ZSBkYXNoZWQgbGluZSB0b1xuICAgICAgICBfZGFzaGVkQmV6aWVyVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgICAgICB2YXIgZGFzaFN1bSA9IHRoaXMuX2Rhc2hTdW07XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblxuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgICAgICAgICB2YXIgeTAgPSB0aGlzLl95aTtcbiAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgdmFyIGR4O1xuICAgICAgICAgICAgdmFyIGR5O1xuICAgICAgICAgICAgdmFyIGN1YmljQXQgPSBjdXJ2ZS5jdWJpY0F0O1xuICAgICAgICAgICAgdmFyIGJlemllckxlbiA9IDA7XG4gICAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5fZGFzaElkeDtcbiAgICAgICAgICAgIHZhciBuRGFzaCA9IGxpbmVEYXNoLmxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgICB2YXIgeTtcblxuICAgICAgICAgICAgdmFyIHRtcExlbiA9IDA7XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBwb3NpdGl2ZSBvZmZzZXRcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBkYXNoU3VtICsgb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICU9IGRhc2hTdW07XG4gICAgICAgICAgICAvLyBCZXppZXIgYXBwcm94IGxlbmd0aFxuICAgICAgICAgICAgZm9yICh0ID0gMDsgdCA8IDE7IHQgKz0gMC4xKSB7XG4gICAgICAgICAgICAgICAgZHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0ICsgMC4xKVxuICAgICAgICAgICAgICAgICAgICAtIGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgICAgICAgICAgIGR5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCArIDAuMSlcbiAgICAgICAgICAgICAgICAgICAgLSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICAgICAgICAgICAgICBiZXppZXJMZW4gKz0gbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5kIGlkeCBhZnRlciBhZGQgb2Zmc2V0XG4gICAgICAgICAgICBmb3IgKDsgaWR4IDwgbkRhc2g7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgdG1wTGVuICs9IGxpbmVEYXNoW2lkeF07XG4gICAgICAgICAgICAgICAgaWYgKHRtcExlbiA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ID0gKHRtcExlbiAtIG9mZnNldCkgLyBiZXppZXJMZW47XG5cbiAgICAgICAgICAgIHdoaWxlICh0IDw9IDEpIHtcblxuICAgICAgICAgICAgICAgIHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgICAgICAgICB5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgbGluZSB0byBhcHByb3hpbWF0ZSBkYXNoZWQgYmV6aWVyXG4gICAgICAgICAgICAgICAgLy8gQmFkIHJlc3VsdCBpZiBkYXNoIGlzIGxvbmdcbiAgICAgICAgICAgICAgICBpZHggJSAyID8gY3R4Lm1vdmVUbyh4LCB5KVxuICAgICAgICAgICAgICAgICAgICA6IGN0eC5saW5lVG8oeCwgeSk7XG5cbiAgICAgICAgICAgICAgICB0ICs9IGxpbmVEYXNoW2lkeF0gLyBiZXppZXJMZW47XG5cbiAgICAgICAgICAgICAgICBpZHggPSAoaWR4ICsgMSkgJSBuRGFzaDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmluaXNoIHRoZSBsYXN0IHNlZ21lbnQgYW5kIGNhbGN1bGF0ZSB0aGUgbmV3IG9mZnNldFxuICAgICAgICAgICAgKGlkeCAlIDIgIT09IDApICYmIGN0eC5saW5lVG8oeDMsIHkzKTtcbiAgICAgICAgICAgIGR4ID0geDMgLSB4O1xuICAgICAgICAgICAgZHkgPSB5MyAtIHk7XG4gICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gLW1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGFzaGVkUXVhZHJhdGljVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICAgICAgLy8gQ29udmVydCBxdWFkcmF0aWMgdG8gY3ViaWMgdXNpbmcgZGVncmVlIGVsZXZhdGlvblxuICAgICAgICAgICAgdmFyIHgzID0geDI7XG4gICAgICAgICAgICB2YXIgeTMgPSB5MjtcbiAgICAgICAgICAgIHgyID0gKHgyICsgMiAqIHgxKSAvIDM7XG4gICAgICAgICAgICB5MiA9ICh5MiArIDIgKiB5MSkgLyAzO1xuICAgICAgICAgICAgeDEgPSAodGhpcy5feGkgKyAyICogeDEpIC8gMztcbiAgICAgICAgICAgIHkxID0gKHRoaXMuX3lpICsgMiAqIHkxKSAvIDM7XG5cbiAgICAgICAgICAgIHRoaXMuX2Rhc2hlZEJlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDovazmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5IOWHj+WwkeWghuWGheWtmOWNoOeUqFxuICAgICAgICAgKiBDb252ZXJ0IGR5bmFtaWMgYXJyYXkgdG8gc3RhdGljIEZsb2F0MzJBcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdGF0aWM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGRhdGEubGVuZ3RoID0gdGhpcy5fbGVuO1xuICAgICAgICAgICAgICAgIGlmIChoYXNUeXBlZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWluWzBdID0gbWluWzFdID0gbWluMlswXSA9IG1pbjJbMV0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgbWF4WzBdID0gbWF4WzFdID0gbWF4MlswXSA9IG1heDJbMV0gPSAtTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICB2YXIgeGkgPSAwO1xuICAgICAgICAgICAgdmFyIHlpID0gMDtcbiAgICAgICAgICAgIHZhciB4MCA9IDA7XG4gICAgICAgICAgICB2YXIgeTAgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIHZhciBjbWQgPSBkYXRhW2krK107XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgICAgICAgICAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSArIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIHgwID0geGk7XG4gICAgICAgICAgICAgICAgICAgIHkwID0geWk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluMlswXSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluMlsxXSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4MlswXSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4MlsxXSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21MaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIG1pbjIsIG1heDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5DOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tQ3ViaWMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjIsIG1heDJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21RdWFkcmF0aWMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluMiwgbWF4MlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQXJjIOWIpOaWreeahOW8gOmUgOavlOi+g+Wkp1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBkYXRhW2krK10gKyBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5peL6L2sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHNpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g55u05o6l5L2/55SoIGFyYyDlkb3ku6RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MCA9IG1hdGhDb3Moc3RhcnRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkwID0gbWF0aFNpbihzdGFydEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbUFyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeCwgY3ksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZSwgbWluMiwgbWF4MlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0geWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGZyb21MaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21MaW5lKHgwLCB5MCwgeDAgKyB3aWR0aCwgeTAgKyBoZWlnaHQsIG1pbjIsIG1heDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVuaW9uXG4gICAgICAgICAgICAgICAgdmVjMi5taW4obWluLCBtaW4sIG1pbjIpO1xuICAgICAgICAgICAgICAgIHZlYzIubWF4KG1heCwgbWF4LCBtYXgyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm8gZGF0YVxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtaW5bMF0gPSBtaW5bMV0gPSBtYXhbMF0gPSBtYXhbMV0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdChcbiAgICAgICAgICAgICAgICBtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYnVpbGQgcGF0aCBmcm9tIGN1cnJlbnQgZGF0YVxuICAgICAgICAgKiBSZWJ1aWxkIHBhdGggd2lsbCBub3QgY29uc2lkZXIgamF2YXNjcmlwdCBpbXBsZW1lbnRlZCBsaW5lIGRhc2guXG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAgICovXG4gICAgICAgIHJlYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIHZhciB4MCwgeTA7XG4gICAgICAgICAgICB2YXIgeGksIHlpO1xuICAgICAgICAgICAgdmFyIHgsIHk7XG4gICAgICAgICAgICB2YXIgdXggPSB0aGlzLl91eDtcbiAgICAgICAgICAgIHZhciB1eSA9IHRoaXMuX3V5O1xuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2xlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgICAgIHZhciBjbWQgPSBkW2krK107XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgICAgICAgICAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkW2ldO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRbaSArIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIHgwID0geGk7XG4gICAgICAgICAgICAgICAgICAgIHkwID0geWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHhpID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5aSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeGksIHlpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgZHJhdyB0b28gc21hbGwgc2VnIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRoQWJzKHggLSB4aSkgPiB1eCB8fCBtYXRoQWJzKHkgLSB5aSkgPiB1eSB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBkW2kgLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gZFtpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5BOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN4ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ5ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwc2kgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnMgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IChyeCA+IHJ5KSA/IHJ4IDogcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVYID0gKHJ4ID4gcnkpID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVZID0gKHJ4ID4gcnkpID8gcnkgLyByeCA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNFbGxpcHNlID0gTWF0aC5hYnMocnggLSByeSkgPiAxZS0zO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gdGhldGEgKyBkVGhldGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbGxpcHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUocHNpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKC1wc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhjeCwgY3ksIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSBtYXRoQ29zKHRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSBtYXRoU2luKHRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHhpID0gZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0geWkgPSBkW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBQYXRoUHJveHkuQ01EID0gQ01EO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXRoUHJveHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvcmUvUGF0aFByb3h5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOabsue6v+i+heWKqeaooeWdl1xuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciB2MkNyZWF0ZSA9IHZlYzIuY3JlYXRlO1xuICAgIHZhciB2MkRpc3RTcXVhcmUgPSB2ZWMyLmRpc3RTcXVhcmU7XG4gICAgdmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcbiAgICB2YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG5cbiAgICB2YXIgRVBTSUxPTiA9IDFlLTg7XG4gICAgdmFyIEVQU0lMT05fTlVNRVJJQyA9IDFlLTQ7XG5cbiAgICB2YXIgVEhSRUVfU1FSVCA9IG1hdGhTcXJ0KDMpO1xuICAgIHZhciBPTkVfVEhJUkQgPSAxIC8gMztcblxuICAgIC8vIOS4tOaXtuWPmOmHj1xuICAgIHZhciBfdjAgPSB2MkNyZWF0ZSgpO1xuICAgIHZhciBfdjEgPSB2MkNyZWF0ZSgpO1xuICAgIHZhciBfdjIgPSB2MkNyZWF0ZSgpO1xuICAgIC8vIHZhciBfdjMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgZnVuY3Rpb24gaXNBcm91bmRaZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gLUVQU0lMT04gJiYgdmFsIDwgRVBTSUxPTjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOb3RBcm91bmRaZXJvKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID4gRVBTSUxPTiB8fCB2YWwgPCAtRVBTSUxPTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5YC8XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgICAgICAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIG9uZXQgKiBvbmV0ICogKG9uZXQgKiBwMCArIDMgKiB0ICogcDEpXG4gICAgICAgICAgICAgKyB0ICogdCAqICh0ICogcDMgKyAzICogb25ldCAqIHAyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTlr7zmlbDlgLxcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNEZXJpdmF0aXZlQXQocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgICAgICAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIDMgKiAoXG4gICAgICAgICAgICAoKHAxIC0gcDApICogb25ldCArIDIgKiAocDIgLSBwMSkgKiB0KSAqIG9uZXRcbiAgICAgICAgICAgICsgKHAzIC0gcDIpICogdCAqIHRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTmlrnnqIvmoLnvvIzkvb/nlKjnm5vph5HlhazlvI9cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbFxuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICAgICAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5qC55pWw55uuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNSb290QXQocDAsIHAxLCBwMiwgcDMsIHZhbCwgcm9vdHMpIHtcbiAgICAgICAgLy8gRXZhbHVhdGUgcm9vdHMgb2YgY3ViaWMgZnVuY3Rpb25zXG4gICAgICAgIHZhciBhID0gcDMgKyAzICogKHAxIC0gcDIpIC0gcDA7XG4gICAgICAgIHZhciBiID0gMyAqIChwMiAtIHAxICogMiArIHAwKTtcbiAgICAgICAgdmFyIGMgPSAzICogKHAxICAtIHAwKTtcbiAgICAgICAgdmFyIGQgPSBwMCAtIHZhbDtcblxuICAgICAgICB2YXIgQSA9IGIgKiBiIC0gMyAqIGEgKiBjO1xuICAgICAgICB2YXIgQiA9IGIgKiBjIC0gOSAqIGEgKiBkO1xuICAgICAgICB2YXIgQyA9IGMgKiBjIC0gMyAqIGIgKiBkO1xuXG4gICAgICAgIHZhciBuID0gMDtcblxuICAgICAgICBpZiAoaXNBcm91bmRaZXJvKEEpICYmIGlzQXJvdW5kWmVybyhCKSkge1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhiKSkge1xuICAgICAgICAgICAgICAgIHJvb3RzWzBdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1jIC8gYjsgIC8vdDEsIHQyLCB0MywgYiBpcyBub3QgemVyb1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkaXNjID0gQiAqIEIgLSA0ICogQSAqIEM7XG5cbiAgICAgICAgICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgICAgICAgICAgICB2YXIgSyA9IEIgLyBBO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1iIC8gYSArIEs7ICAvLyB0MSwgYSBpcyBub3QgemVyb1xuICAgICAgICAgICAgICAgIHZhciB0MiA9IC1LIC8gMjsgIC8vIHQyLCB0M1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciBZMSA9IEEgKiBiICsgMS41ICogYSAqICgtQiArIGRpc2NTcXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgWTIgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgLSBkaXNjU3FydCk7XG4gICAgICAgICAgICAgICAgaWYgKFkxIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBZMSA9IC1tYXRoUG93KC1ZMSwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFkxID0gbWF0aFBvdyhZMSwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFkyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBZMiA9IC1tYXRoUG93KC1ZMiwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFkyID0gbWF0aFBvdyhZMiwgT05FX1RISVJEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iIC0gKFkxICsgWTIpKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIFQgPSAoMiAqIEEgKiBiIC0gMyAqIGEgKiBCKSAvICgyICogbWF0aFNxcnQoQSAqIEEgKiBBKSk7XG4gICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gTWF0aC5hY29zKFQpIC8gMztcbiAgICAgICAgICAgICAgICB2YXIgQVNxcnQgPSBtYXRoU3FydChBKTtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gTWF0aC5jb3ModGhldGEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iIC0gMiAqIEFTcXJ0ICogdG1wKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iICsgQVNxcnQgKiAodG1wICsgVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcbiAgICAgICAgICAgICAgICB2YXIgdDMgPSAoLWIgKyBBU3FydCAqICh0bXAgLSBUSFJFRV9TUVJUICogTWF0aC5zaW4odGhldGEpKSkgLyAoMyAqIGEpO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQzID49IDAgJiYgdDMgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S4ieasoei0neWhnuWwlOaWueeoi+aegemZkOWAvOeahOS9jee9rlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBleHRyZW1hXG4gICAgICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmlbDnm65cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY0V4dHJlbWEocDAsIHAxLCBwMiwgcDMsIGV4dHJlbWEpIHtcbiAgICAgICAgdmFyIGIgPSA2ICogcDIgLSAxMiAqIHAxICsgNiAqIHAwO1xuICAgICAgICB2YXIgYSA9IDkgKiBwMSArIDMgKiBwMyAtIDMgKiBwMCAtIDkgKiBwMjtcbiAgICAgICAgdmFyIGMgPSAzICogcDEgLSAzICogcDA7XG5cbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGEpKSB7XG4gICAgICAgICAgICBpZiAoaXNOb3RBcm91bmRaZXJvKGIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gLWMgLyBiO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9MSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgICAgIGV4dHJlbWFbMF0gPSAtYiAvICgyICogYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbWFbbisrXSA9IHQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnu4bliIbkuInmrKHotJ3loZ7lsJTmm7Lnur9cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNTdWJkaXZpZGUocDAsIHAxLCBwMiwgcDMsIHQsIG91dCkge1xuICAgICAgICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICAgICAgICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICAgICAgICB2YXIgcDIzID0gKHAzIC0gcDIpICogdCArIHAyO1xuXG4gICAgICAgIHZhciBwMDEyID0gKHAxMiAtIHAwMSkgKiB0ICsgcDAxO1xuICAgICAgICB2YXIgcDEyMyA9IChwMjMgLSBwMTIpICogdCArIHAxMjtcblxuICAgICAgICB2YXIgcDAxMjMgPSAocDEyMyAtIHAwMTIpICogdCArIHAwMTI7XG4gICAgICAgIC8vIFNlZzBcbiAgICAgICAgb3V0WzBdID0gcDA7XG4gICAgICAgIG91dFsxXSA9IHAwMTtcbiAgICAgICAgb3V0WzJdID0gcDAxMjtcbiAgICAgICAgb3V0WzNdID0gcDAxMjM7XG4gICAgICAgIC8vIFNlZzFcbiAgICAgICAgb3V0WzRdID0gcDAxMjM7XG4gICAgICAgIG91dFs1XSA9IHAxMjM7XG4gICAgICAgIG91dFs2XSA9IHAyMztcbiAgICAgICAgb3V0WzddID0gcDM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5oqV5bCE54K55Yiw5LiJ5qyh6LSd5aGe5bCU5puy57q/5LiK77yM6L+U5Zue5oqV5bCE6Led56a744CCXG4gICAgICog5oqV5bCE54K55pyJ5Y+v6IO95Lya5pyJ5LiA5Liq5oiW6ICF5aSa5Liq77yM6L+Z6YeM5Y+q6L+U5Zue5YW25Lit6Led56a75pyA55+t55qE5LiA5Liq44CCXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIOaKleWwhOeCuVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY1Byb2plY3RQb2ludChcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLFxuICAgICAgICB4LCB5LCBvdXRcbiAgICApIHtcbiAgICAgICAgLy8gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNwcm9qZWN0aW9uc1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgdmFyIGludGVydmFsID0gMC4wMDU7XG4gICAgICAgIHZhciBkID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBwcmV2O1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgdmFyIGQxO1xuICAgICAgICB2YXIgZDI7XG5cbiAgICAgICAgX3YwWzBdID0geDtcbiAgICAgICAgX3YwWzFdID0geTtcblxuICAgICAgICAvLyDlhYjnspfnlaXkvLDorqHkuIDkuIvlj6/og73nmoTmnIDlsI/ot53nprvnmoQgdCDlgLxcbiAgICAgICAgLy8gUEVORElOR1xuICAgICAgICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgICAgICAgICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgX3QpO1xuICAgICAgICAgICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgX3QpO1xuICAgICAgICAgICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuICAgICAgICAgICAgaWYgKGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBfdDtcbiAgICAgICAgICAgICAgICBkID0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZCA9IEluZmluaXR5O1xuXG4gICAgICAgIC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgICAgICAgICAgbmV4dCA9IHQgKyBpbnRlcnZhbDtcbiAgICAgICAgICAgIC8vIHQgLSBpbnRlcnZhbFxuICAgICAgICAgICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgcHJldik7XG4gICAgICAgICAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBwcmV2KTtcblxuICAgICAgICAgICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgICAgICAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBwcmV2O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIF92MlswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIG5leHQpO1xuICAgICAgICAgICAgICAgIF92MlsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIG5leHQpO1xuICAgICAgICAgICAgICAgIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkID0gZDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRcbiAgICAgICAgaWYgKG91dCkge1xuICAgICAgICAgICAgb3V0WzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICBvdXRbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG4gICAgICAgIHJldHVybiBtYXRoU3FydChkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTlgLxcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljQXQocDAsIHAxLCBwMiwgdCkge1xuICAgICAgICB2YXIgb25ldCA9IDEgLSB0O1xuICAgICAgICByZXR1cm4gb25ldCAqIChvbmV0ICogcDAgKyAyICogdCAqIHAxKSArIHQgKiB0ICogcDI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5a+85pWw5YC8XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCB0KSB7XG4gICAgICAgIHJldHVybiAyICogKCgxIC0gdCkgKiAocDEgLSBwMCkgKyB0ICogKHAyIC0gcDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTmlrnnqIvmoLlcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcm9vdHNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1Jvb3RBdChwMCwgcDEsIHAyLCB2YWwsIHJvb3RzKSB7XG4gICAgICAgIHZhciBhID0gcDAgLSAyICogcDEgKyBwMjtcbiAgICAgICAgdmFyIGIgPSAyICogKHAxIC0gcDApO1xuICAgICAgICB2YXIgYyA9IHAwIC0gdmFsO1xuXG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgICAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1jIC8gYjtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1iIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S6jOasoei0neWhnuWwlOaWueeoi+aegemZkOWAvFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0V4dHJlbXVtKHAwLCBwMSwgcDIpIHtcbiAgICAgICAgdmFyIGRpdmlkZXIgPSBwMCArIHAyIC0gMiAqIHAxO1xuICAgICAgICBpZiAoZGl2aWRlciA9PT0gMCkge1xuICAgICAgICAgICAgLy8gcDEgaXMgY2VudGVyIG9mIHAwIGFuZCBwMlxuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAocDAgLSBwMSkgLyBkaXZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog57uG5YiG5LqM5qyh6LSd5aGe5bCU5puy57q/XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHQsIG91dCkge1xuICAgICAgICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICAgICAgICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICAgICAgICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTtcblxuICAgICAgICAvLyBTZWcwXG4gICAgICAgIG91dFswXSA9IHAwO1xuICAgICAgICBvdXRbMV0gPSBwMDE7XG4gICAgICAgIG91dFsyXSA9IHAwMTI7XG5cbiAgICAgICAgLy8gU2VnMVxuICAgICAgICBvdXRbM10gPSBwMDEyO1xuICAgICAgICBvdXRbNF0gPSBwMTI7XG4gICAgICAgIG91dFs1XSA9IHAyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaKleWwhOeCueWIsOS6jOasoei0neWhnuWwlOabsue6v+S4iu+8jOi/lOWbnuaKleWwhOi3neemu+OAglxuICAgICAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXQg5oqV5bCE54K5XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1Byb2plY3RQb2ludChcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgeCwgeSwgb3V0XG4gICAgKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICAgICAgICB2YXIgZCA9IEluZmluaXR5O1xuXG4gICAgICAgIF92MFswXSA9IHg7XG4gICAgICAgIF92MFsxXSA9IHk7XG5cbiAgICAgICAgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICAgICAgICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIF90KTtcbiAgICAgICAgICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIF90KTtcbiAgICAgICAgICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjAsIF92MSk7XG4gICAgICAgICAgICBpZiAoZDEgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IF90O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkID0gSW5maW5pdHk7XG5cbiAgICAgICAgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OX05VTUVSSUMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgICAgICAgICAgdmFyIG5leHQgPSB0ICsgaW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyB0IC0gaW50ZXJ2YWxcbiAgICAgICAgICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHByZXYpO1xuICAgICAgICAgICAgX3YxWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgcHJldik7XG5cbiAgICAgICAgICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjEsIF92MCk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2ID49IDAgJiYgZDEgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IHByZXY7XG4gICAgICAgICAgICAgICAgZCA9IGQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdCArIGludGVydmFsXG4gICAgICAgICAgICAgICAgX3YyWzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgbmV4dCk7XG4gICAgICAgICAgICAgICAgX3YyWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgbmV4dCk7XG4gICAgICAgICAgICAgICAgdmFyIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0XG4gICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHQpO1xuICAgICAgICAgICAgb3V0WzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coaW50ZXJ2YWwsIGkpO1xuICAgICAgICByZXR1cm4gbWF0aFNxcnQoZCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAgICAgY3ViaWNBdDogY3ViaWNBdCxcblxuICAgICAgICBjdWJpY0Rlcml2YXRpdmVBdDogY3ViaWNEZXJpdmF0aXZlQXQsXG5cbiAgICAgICAgY3ViaWNSb290QXQ6IGN1YmljUm9vdEF0LFxuXG4gICAgICAgIGN1YmljRXh0cmVtYTogY3ViaWNFeHRyZW1hLFxuXG4gICAgICAgIGN1YmljU3ViZGl2aWRlOiBjdWJpY1N1YmRpdmlkZSxcblxuICAgICAgICBjdWJpY1Byb2plY3RQb2ludDogY3ViaWNQcm9qZWN0UG9pbnQsXG5cbiAgICAgICAgcXVhZHJhdGljQXQ6IHF1YWRyYXRpY0F0LFxuXG4gICAgICAgIHF1YWRyYXRpY0Rlcml2YXRpdmVBdDogcXVhZHJhdGljRGVyaXZhdGl2ZUF0LFxuXG4gICAgICAgIHF1YWRyYXRpY1Jvb3RBdDogcXVhZHJhdGljUm9vdEF0LFxuXG4gICAgICAgIHF1YWRyYXRpY0V4dHJlbXVtOiBxdWFkcmF0aWNFeHRyZW11bSxcblxuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGU6IHF1YWRyYXRpY1N1YmRpdmlkZSxcblxuICAgICAgICBxdWFkcmF0aWNQcm9qZWN0UG9pbnQ6IHF1YWRyYXRpY1Byb2plY3RQb2ludFxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvcmUvY3VydmUuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGF1dGhvciBZaSBTaGVuKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cblxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJyk7XG5cbiAgICB2YXIgYmJveCA9IHt9O1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbiAgICB2YXIgbWF0aFNpbiA9IE1hdGguc2luO1xuICAgIHZhciBtYXRoQ29zID0gTWF0aC5jb3M7XG5cbiAgICB2YXIgc3RhcnQgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHZhciBlbmQgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHZhciBleHRyZW1pdHkgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgIC8qKlxuICAgICAqIOS7jumhtueCueaVsOe7hOS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwb2ludHMg6aG254K55pWw57uEXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgKi9cbiAgICBiYm94LmZyb21Qb2ludHMgPSBmdW5jdGlvbihwb2ludHMsIG1pbiwgbWF4KSB7XG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSBwb2ludHNbMF07XG4gICAgICAgIHZhciBsZWZ0ID0gcFswXTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcFswXTtcbiAgICAgICAgdmFyIHRvcCA9IHBbMV07XG4gICAgICAgIHZhciBib3R0b20gPSBwWzFdO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgbGVmdCA9IG1hdGhNaW4obGVmdCwgcFswXSk7XG4gICAgICAgICAgICByaWdodCA9IG1hdGhNYXgocmlnaHQsIHBbMF0pO1xuICAgICAgICAgICAgdG9wID0gbWF0aE1pbih0b3AsIHBbMV0pO1xuICAgICAgICAgICAgYm90dG9tID0gbWF0aE1heChib3R0b20sIHBbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWluWzBdID0gbGVmdDtcbiAgICAgICAgbWluWzFdID0gdG9wO1xuICAgICAgICBtYXhbMF0gPSByaWdodDtcbiAgICAgICAgbWF4WzFdID0gYm90dG9tO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tTGluZSA9IGZ1bmN0aW9uICh4MCwgeTAsIHgxLCB5MSwgbWluLCBtYXgpIHtcbiAgICAgICAgbWluWzBdID0gbWF0aE1pbih4MCwgeDEpO1xuICAgICAgICBtaW5bMV0gPSBtYXRoTWluKHkwLCB5MSk7XG4gICAgICAgIG1heFswXSA9IG1hdGhNYXgoeDAsIHgxKTtcbiAgICAgICAgbWF4WzFdID0gbWF0aE1heCh5MCwgeTEpO1xuICAgIH07XG5cbiAgICB2YXIgeERpbSA9IFtdO1xuICAgIHZhciB5RGltID0gW107XG4gICAgLyoqXG4gICAgICog5LuO5LiJ6Zi26LSd5aGe5bCU5puy57q/KHAwLCBwMSwgcDIsIHAzKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tQ3ViaWMgPSBmdW5jdGlvbihcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW4sIG1heFxuICAgICkge1xuICAgICAgICB2YXIgY3ViaWNFeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hO1xuICAgICAgICB2YXIgY3ViaWNBdCA9IGN1cnZlLmN1YmljQXQ7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbiA9IGN1YmljRXh0cmVtYSh4MCwgeDEsIHgyLCB4MywgeERpbSk7XG4gICAgICAgIG1pblswXSA9IEluZmluaXR5O1xuICAgICAgICBtaW5bMV0gPSBJbmZpbml0eTtcbiAgICAgICAgbWF4WzBdID0gLUluZmluaXR5O1xuICAgICAgICBtYXhbMV0gPSAtSW5maW5pdHk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB4RGltW2ldKTtcbiAgICAgICAgICAgIG1pblswXSA9IG1hdGhNaW4oeCwgbWluWzBdKTtcbiAgICAgICAgICAgIG1heFswXSA9IG1hdGhNYXgoeCwgbWF4WzBdKTtcbiAgICAgICAgfVxuICAgICAgICBuID0gY3ViaWNFeHRyZW1hKHkwLCB5MSwgeTIsIHkzLCB5RGltKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB5RGltW2ldKTtcbiAgICAgICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeSwgbWluWzFdKTtcbiAgICAgICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeSwgbWF4WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pblswXSA9IG1hdGhNaW4oeDAsIG1pblswXSk7XG4gICAgICAgIG1heFswXSA9IG1hdGhNYXgoeDAsIG1heFswXSk7XG4gICAgICAgIG1pblswXSA9IG1hdGhNaW4oeDMsIG1pblswXSk7XG4gICAgICAgIG1heFswXSA9IG1hdGhNYXgoeDMsIG1heFswXSk7XG5cbiAgICAgICAgbWluWzFdID0gbWF0aE1pbih5MCwgbWluWzFdKTtcbiAgICAgICAgbWF4WzFdID0gbWF0aE1heCh5MCwgbWF4WzFdKTtcbiAgICAgICAgbWluWzFdID0gbWF0aE1pbih5MywgbWluWzFdKTtcbiAgICAgICAgbWF4WzFdID0gbWF0aE1heCh5MywgbWF4WzFdKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5LuO5LqM6Zi26LSd5aGe5bCU5puy57q/KHAwLCBwMSwgcDIp5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAgICAgKi9cbiAgICBiYm94LmZyb21RdWFkcmF0aWMgPSBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBtaW4sIG1heCkge1xuICAgICAgICB2YXIgcXVhZHJhdGljRXh0cmVtdW0gPSBjdXJ2ZS5xdWFkcmF0aWNFeHRyZW11bTtcbiAgICAgICAgdmFyIHF1YWRyYXRpY0F0ID0gY3VydmUucXVhZHJhdGljQXQ7XG4gICAgICAgIC8vIEZpbmQgZXh0cmVtaXRpZXMsIHdoZXJlIGRlcml2YXRpdmUgaW4geCBkaW0gb3IgeSBkaW0gaXMgemVyb1xuICAgICAgICB2YXIgdHggPVxuICAgICAgICAgICAgbWF0aE1heChcbiAgICAgICAgICAgICAgICBtYXRoTWluKHF1YWRyYXRpY0V4dHJlbXVtKHgwLCB4MSwgeDIpLCAxKSwgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgdmFyIHR5ID1cbiAgICAgICAgICAgIG1hdGhNYXgoXG4gICAgICAgICAgICAgICAgbWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh5MCwgeTEsIHkyKSwgMSksIDBcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgdmFyIHggPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0eCk7XG4gICAgICAgIHZhciB5ID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdHkpO1xuXG4gICAgICAgIG1pblswXSA9IG1hdGhNaW4oeDAsIHgyLCB4KTtcbiAgICAgICAgbWluWzFdID0gbWF0aE1pbih5MCwgeTIsIHkpO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MiwgeCk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkyLCB5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5LuO5ZyG5byn5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFudGljbG9ja3dpc2VcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtaW5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAgICAgKi9cbiAgICBiYm94LmZyb21BcmMgPSBmdW5jdGlvbiAoXG4gICAgICAgIHgsIHksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIG1pbiwgbWF4XG4gICAgKSB7XG4gICAgICAgIHZhciB2ZWMyTWluID0gdmVjMi5taW47XG4gICAgICAgIHZhciB2ZWMyTWF4ID0gdmVjMi5tYXg7XG5cbiAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xuXG5cbiAgICAgICAgaWYgKGRpZmYgJSBQSTIgPCAxZS00ICYmIGRpZmYgPiAxZS00KSB7XG4gICAgICAgICAgICAvLyBJcyBhIGNpcmNsZVxuICAgICAgICAgICAgbWluWzBdID0geCAtIHJ4O1xuICAgICAgICAgICAgbWluWzFdID0geSAtIHJ5O1xuICAgICAgICAgICAgbWF4WzBdID0geCArIHJ4O1xuICAgICAgICAgICAgbWF4WzFdID0geSArIHJ5O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRbMF0gPSBtYXRoQ29zKHN0YXJ0QW5nbGUpICogcnggKyB4O1xuICAgICAgICBzdGFydFsxXSA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIHk7XG5cbiAgICAgICAgZW5kWzBdID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIHg7XG4gICAgICAgIGVuZFsxXSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyB5O1xuXG4gICAgICAgIHZlYzJNaW4obWluLCBzdGFydCwgZW5kKTtcbiAgICAgICAgdmVjMk1heChtYXgsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIC8vIFRocmVzaCB0byBbMCwgTWF0aC5QSSAqIDJdXG4gICAgICAgIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlICUgKFBJMik7XG4gICAgICAgIGlmIChzdGFydEFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBQSTI7XG4gICAgICAgIH1cbiAgICAgICAgZW5kQW5nbGUgPSBlbmRBbmdsZSAlIChQSTIpO1xuICAgICAgICBpZiAoZW5kQW5nbGUgPCAwKSB7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IGVuZEFuZ2xlICsgUEkyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSAmJiAhYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgZW5kQW5nbGUgKz0gUEkyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0QW5nbGUgPCBlbmRBbmdsZSAmJiBhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICBzdGFydEFuZ2xlICs9IFBJMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IGVuZEFuZ2xlO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhciBudW1iZXIgPSAwO1xuICAgICAgICAvLyB2YXIgc3RlcCA9IChhbnRpY2xvY2t3aXNlID8gLU1hdGguUEkgOiBNYXRoLlBJKSAvIDI7XG4gICAgICAgIGZvciAodmFyIGFuZ2xlID0gMDsgYW5nbGUgPCBlbmRBbmdsZTsgYW5nbGUgKz0gTWF0aC5QSSAvIDIpIHtcbiAgICAgICAgICAgIGlmIChhbmdsZSA+IHN0YXJ0QW5nbGUpIHtcbiAgICAgICAgICAgICAgICBleHRyZW1pdHlbMF0gPSBtYXRoQ29zKGFuZ2xlKSAqIHJ4ICsgeDtcbiAgICAgICAgICAgICAgICBleHRyZW1pdHlbMV0gPSBtYXRoU2luKGFuZ2xlKSAqIHJ5ICsgeTtcblxuICAgICAgICAgICAgICAgIHZlYzJNaW4obWluLCBleHRyZW1pdHksIG1pbik7XG4gICAgICAgICAgICAgICAgdmVjMk1heChtYXgsIGV4dHJlbWl0eSwgbWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJib3g7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvY29yZS9iYm94LmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciBDTUQgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpLkNNRDtcbiAgICB2YXIgbGluZSA9IHJlcXVpcmUoJy4vbGluZScpO1xuICAgIHZhciBjdWJpYyA9IHJlcXVpcmUoJy4vY3ViaWMnKTtcbiAgICB2YXIgcXVhZHJhdGljID0gcmVxdWlyZSgnLi9xdWFkcmF0aWMnKTtcbiAgICB2YXIgYXJjID0gcmVxdWlyZSgnLi9hcmMnKTtcbiAgICB2YXIgbm9ybWFsaXplUmFkaWFuID0gcmVxdWlyZSgnLi91dGlsJykubm9ybWFsaXplUmFkaWFuO1xuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvY3VydmUnKTtcblxuICAgIHZhciB3aW5kaW5nTGluZSA9IHJlcXVpcmUoJy4vd2luZGluZ0xpbmUnKTtcblxuICAgIHZhciBjb250YWluU3Ryb2tlID0gbGluZS5jb250YWluU3Ryb2tlO1xuXG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuXG4gICAgdmFyIEVQU0lMT04gPSAxZS00O1xuXG4gICAgZnVuY3Rpb24gaXNBcm91bmRFcXVhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBFUFNJTE9OO1xuICAgIH1cblxuICAgIC8vIOS4tOaXtuaVsOe7hFxuICAgIHZhciByb290cyA9IFstMSwgLTEsIC0xXTtcbiAgICB2YXIgZXh0cmVtYSA9IFstMSwgLTFdO1xuXG4gICAgZnVuY3Rpb24gc3dhcEV4dHJlbWEoKSB7XG4gICAgICAgIHZhciB0bXAgPSBleHRyZW1hWzBdO1xuICAgICAgICBleHRyZW1hWzBdID0gZXh0cmVtYVsxXTtcbiAgICAgICAgZXh0cmVtYVsxXSA9IHRtcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aW5kaW5nQ3ViaWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5KSB7XG4gICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoeSA+IHkwICYmIHkgPiB5MSAmJiB5ID4geTIgJiYgeSA+IHkzKVxuICAgICAgICAgICAgfHwgKHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyICYmIHkgPCB5MylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgblJvb3RzID0gY3VydmUuY3ViaWNSb290QXQoeTAsIHkxLCB5MiwgeTMsIHksIHJvb3RzKTtcbiAgICAgICAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgICAgICB2YXIgbkV4dHJlbWEgPSAtMTtcbiAgICAgICAgICAgIHZhciB5MF8sIHkxXztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJvb3RzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHJvb3RzW2ldO1xuXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgd2luZGluZyBlcnJvciB3aGVuIGludGVyc2VjdGlvbiBwb2ludCBpcyB0aGUgY29ubmVjdCBwb2ludCBvZiB0d28gbGluZSBvZiBwb2x5Z29uXG4gICAgICAgICAgICAgICAgdmFyIHVuaXQgPSAodCA9PT0gMCB8fCB0ID09PSAxKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5jdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgICAgICAgICBpZiAoeF8gPCB4KSB7IC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5FeHRyZW1hIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBuRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyZW1hWzFdIDwgZXh0cmVtYVswXSAmJiBuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3YXBFeHRyZW1hKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeTBfID0gY3VydmUuY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYVswXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWIhuaIkOS4ieauteWNleiwg+WHveaVsFxuICAgICAgICAgICAgICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTBfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodCA8IGV4dHJlbWFbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTFfIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MyA8IHkxXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5YiG5oiQ5Lik5q615Y2V6LCD5Ye95pWwXG4gICAgICAgICAgICAgICAgICAgIGlmICh0IDwgZXh0cmVtYVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MF8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTMgPCB5MF8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpbmRpbmdRdWFkcmF0aWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyKVxuICAgICAgICAgICAgfHwgKHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuUm9vdHMgPSBjdXJ2ZS5xdWFkcmF0aWNSb290QXQoeTAsIHkxLCB5MiwgeSwgcm9vdHMpO1xuICAgICAgICBpZiAoblJvb3RzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0ID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5Mik7XG4gICAgICAgICAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgICAgICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgeV8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCB0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbmUgZW5kcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgIHZhciB1bml0ID0gKHJvb3RzW2ldID09PSAwIHx8IHJvb3RzW2ldID09PSAxKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeF8gPCB4KSB7ICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocm9vdHNbaV0gPCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHlfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkyIDwgeV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgICAgICAgICAgIHZhciB1bml0ID0gKHJvb3RzWzBdID09PSAwIHx8IHJvb3RzWzBdID09PSAxKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCByb290c1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKHhfIDwgeCkgeyAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHkyIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPXG4gICAgLy8gQXJjIOaXi+i9rFxuICAgIGZ1bmN0aW9uIHdpbmRpbmdBcmMoXG4gICAgICAgIGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHgsIHlcbiAgICApIHtcbiAgICAgICAgeSAtPSBjeTtcbiAgICAgICAgaWYgKHkgPiByIHx8IHkgPCAtcikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRtcCA9IE1hdGguc3FydChyICogciAtIHkgKiB5KTtcbiAgICAgICAgcm9vdHNbMF0gPSAtdG1wO1xuICAgICAgICByb290c1sxXSA9IHRtcDtcblxuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG4gICAgICAgIGlmIChkaWZmIDwgMWUtNCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpZmYgJSBQSTIgPCAxZS00KSB7XG4gICAgICAgICAgICAvLyBJcyBhIGNpcmNsZVxuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IDA7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IFBJMjtcbiAgICAgICAgICAgIHZhciBkaXIgPSBhbnRpY2xvY2t3aXNlID8gMSA6IC0xO1xuICAgICAgICAgICAgaWYgKHggPj0gcm9vdHNbMF0gKyBjeCAmJiB4IDw9IHJvb3RzWzFdICsgY3gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4odG1wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgICAgICAgICAgZW5kQW5nbGUgKz0gUEkyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgdmFyIHhfID0gcm9vdHNbaV07XG4gICAgICAgICAgICBpZiAoeF8gKyBjeCA+IHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHksIHhfKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gUEkyICsgYW5nbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUpXG4gICAgICAgICAgICAgICAgICAgIHx8IChhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJIC8gMiAmJiBhbmdsZSA8IE1hdGguUEkgKiAxLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpciA9IC1kaXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdyArPSBkaXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5QYXRoKGRhdGEsIGxpbmVXaWR0aCwgaXNTdHJva2UsIHgsIHkpIHtcbiAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICB2YXIgeGkgPSAwO1xuICAgICAgICB2YXIgeWkgPSAwO1xuICAgICAgICB2YXIgeDAgPSAwO1xuICAgICAgICB2YXIgeTAgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgLy8gQmVnaW4gYSBuZXcgc3VicGF0aFxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gQ01ELk0gJiYgaSA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzdWJwYXRoXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgICAgICAgLy8gaWYgKHcgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSArIDFdO1xuXG4gICAgICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgICAgICB5MCA9IHlpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgICAgICAgICAgICAgIC8vIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5L2/55SoXG4gICAgICAgICAgICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFIOWcqOesrOS4gOS4quWRveS7pOS4uiBMLCBDLCBRIOeahOaXtuWAmeS8muiuoeeul+WHuiBOYU5cbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgeCwgeSkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1YmljLmNvbnRhaW5TdHJva2UoeGksIHlpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdDdWJpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWFkcmF0aWMuY29udGFpblN0cm9rZSh4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nUXVhZHJhdGljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5Yik5pat55qE5byA6ZSA5q+U6L6D5aSnXG4gICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZFRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEFyYyDml4vovaxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSBNYXRoLmNvcyh0aGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTEgPSBNYXRoLnNpbih0aGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAvLyDkuI3mmK/nm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHgxO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB6ciDkvb/nlKhzY2FsZeadpeaooeaLn+akreWchiwg6L+Z6YeM5Lmf5a+5eOWBmuS4gOWumueahOe8qeaUvlxuICAgICAgICAgICAgICAgICAgICB2YXIgX3ggPSAoeCAtIGN4KSAqIHJ5IC8gcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJjLmNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCwgX3gsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0FyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3gsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBNYXRoLmNvcyh0aGV0YSArIGRUaGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICB5aSA9IE1hdGguc2luKHRoZXRhICsgZFRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHkwID0geWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0geDAgKyB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0geTAgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTAsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29udGFpblN0cm9rZSh4MSwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBjb250YWluU3Ryb2tlKHgxLCB5MSwgeDAsIHkxLCBsaW5lV2lkdGgsIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNvbnRhaW5TdHJva2UoeDAsIHkxLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgQ2xvY2t3aXNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDEsIHkwLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4MCwgeTEsIHgwLCB5MCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpblN0cm9rZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksIHgwLCB5MCwgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZSBhIHN1YnBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBzdWJwYXRocyBtYXkgb3ZlcmxhcFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHcgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzU3Ryb2tlICYmICFpc0Fyb3VuZEVxdWFsKHlpLCB5MCkpIHtcbiAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHcgIT09IDA7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uIChwYXRoRGF0YSwgeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCAwLCBmYWxzZSwgeCwgeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKHBhdGhEYXRhLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluUGF0aChwYXRoRGF0YSwgbGluZVdpZHRoLCB0cnVlLCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvbnRhaW4vcGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnur/mrrXljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKHgwLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICB2YXIgX2EgPSAwO1xuICAgICAgICAgICAgdmFyIF9iID0geDA7XG4gICAgICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh4MCAhPT0geDEpIHtcbiAgICAgICAgICAgICAgICBfYSA9ICh5MCAtIHkxKSAvICh4MCAtIHgxKTtcbiAgICAgICAgICAgICAgICBfYiA9ICh4MCAqIHkxIC0geDEgKiB5MCkgLyAoeDAgLSB4MSkgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHggLSB4MCkgPD0gX2wgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRtcCA9IF9hICogeCAtIHkgKyBfYjtcbiAgICAgICAgICAgIHZhciBfcyA9IHRtcCAqIHRtcCAvIChfYSAqIF9hICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gX3MgPD0gX2wgLyAyICogX2wgLyAyO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvY29udGFpbi9saW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvY3VydmUnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5LiJ5qyh6LSd5aGe5bCU5puy57q/5o+P6L655YyF5ZCr5Yik5patXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkwXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHgzXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHkzXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGxpbmVXaWR0aFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5TdHJva2U6IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sICYmIHkgPiB5MiArIF9sICYmIHkgPiB5MyArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCAmJiB5IDwgeTIgLSBfbCAmJiB5IDwgeTMgLSBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wgJiYgeCA+IHgzICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sICYmIHggPCB4MiAtIF9sICYmIHggPCB4MyAtIF9sKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGQgPSBjdXJ2ZS5jdWJpY1Byb2plY3RQb2ludChcbiAgICAgICAgICAgICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsXG4gICAgICAgICAgICAgICAgeCwgeSwgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBkIDw9IF9sIC8gMjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvbnRhaW4vY3ViaWMuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuXG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY29yZS9jdXJ2ZScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuozmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIGxpbmVXaWR0aCwgeCwgeSkge1xuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbCAmJiB5ID4geTIgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wgJiYgeSA8IHkyIC0gX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sICYmIHggPiB4MiArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbCAmJiB4IDwgeDIgLSBfbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkID0gY3VydmUucXVhZHJhdGljUHJvamVjdFBvaW50KFxuICAgICAgICAgICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICAgICAgeCwgeSwgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBkIDw9IF9sIC8gMjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuICAgIHZhciBub3JtYWxpemVSYWRpYW4gPSByZXF1aXJlKCcuL3V0aWwnKS5ub3JtYWxpemVSYWRpYW47XG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlnIblvKfmj4/ovrnljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgY3hcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgY3lcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBzdGFydEFuZ2xlXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIGVuZEFuZ2xlXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59ICBhbnRpY2xvY2t3aXNlXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKFxuICAgICAgICAgICAgY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICApIHtcblxuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbCA9IGxpbmVXaWR0aDtcblxuICAgICAgICAgICAgeCAtPSBjeDtcbiAgICAgICAgICAgIHkgLT0gY3k7XG4gICAgICAgICAgICB2YXIgZCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblxuICAgICAgICAgICAgaWYgKChkIC0gX2wgPiByKSB8fCAoZCArIF9sIDwgcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSAlIFBJMiA8IDFlLTQpIHtcbiAgICAgICAgICAgICAgICAvLyBJcyBhIGNpcmNsZVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICAgICAgICAgICAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgICAgICAgICBlbmRBbmdsZSArPSBQSTI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeCk7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgYW5nbGUgKz0gUEkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlKVxuICAgICAgICAgICAgICAgIHx8IChhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgbm9ybWFsaXplUmFkaWFuOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICAgICAgYW5nbGUgJT0gUEkyO1xuICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgIGFuZ2xlICs9IFBJMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhbmdsZTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aW5kaW5nTGluZSh4MCwgeTAsIHgxLCB5MSwgeCwgeSkge1xuICAgICAgICBpZiAoKHkgPiB5MCAmJiB5ID4geTEpIHx8ICh5IDwgeTAgJiYgeSA8IHkxKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWdub3JlIGhvcml6b250YWwgbGluZVxuICAgICAgICBpZiAoeTEgPT09IHkwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlyID0geTEgPCB5MCA/IDEgOiAtMTtcbiAgICAgICAgdmFyIHQgPSAoeSAtIHkwKSAvICh5MSAtIHkwKTtcblxuICAgICAgICAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cbiAgICAgICAgaWYgKHQgPT09IDEgfHwgdCA9PT0gMCkge1xuICAgICAgICAgICAgZGlyID0geTEgPCB5MCA/IDAuNSA6IC0wLjU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeF8gPSB0ICogKHgxIC0geDApICsgeDA7XG5cbiAgICAgICAgcmV0dXJuIHhfID4geCA/IGRpciA6IDA7XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvY29udGFpbi93aW5kaW5nTGluZS5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cbiAgICB2YXIgUGF0dGVybiA9IGZ1bmN0aW9uIChpbWFnZSwgcmVwZWF0KSB7XG4gICAgICAgIC8vIFNob3VsZCBkbyBub3RoaW5nIG1vcmUgaW4gdGhpcyBjb25zdHJ1Y3Rvci4gQmVjYXVzZSBncmFkaWVudCBjYW4gYmVcbiAgICAgICAgLy8gZGVjbGFyZCBieSBgY29sb3I6IHtpbWFnZTogLi4ufWAsIHdoZXJlIHRoaXMgY29uc3RydWN0b3Igd2lsbCBub3QgYmUgY2FsbGVkLlxuXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgdGhpcy5yZXBlYXQgPSByZXBlYXQ7XG5cbiAgICAgICAgLy8gQ2FuIGJlIGNsb25lZFxuICAgICAgICB0aGlzLnR5cGUgPSAncGF0dGVybic7XG4gICAgfTtcblxuICAgIFBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm4gPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHJldHVybiBjdHguY3JlYXRlUGF0dGVybih0aGlzLmltYWdlLCB0aGlzLnJlcGVhdCB8fCAncmVwZWF0Jyk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUGF0dGVybjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9QYXR0ZXJuLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuICAgIHZhciBDTUQgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpLkNNRDtcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xuXG4gICAgdmFyIHBvaW50cyA9IFtbXSwgW10sIFtdXTtcbiAgICB2YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIG1hdGhBdGFuMiA9IE1hdGguYXRhbjI7XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtUGF0aChwYXRoLCBtKSB7XG4gICAgICAgIHZhciBkYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICB2YXIgY21kO1xuICAgICAgICB2YXIgblBvaW50O1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGo7XG4gICAgICAgIHZhciBrO1xuICAgICAgICB2YXIgcDtcblxuICAgICAgICB2YXIgTSA9IENNRC5NO1xuICAgICAgICB2YXIgQyA9IENNRC5DO1xuICAgICAgICB2YXIgTCA9IENNRC5MO1xuICAgICAgICB2YXIgUiA9IENNRC5SO1xuICAgICAgICB2YXIgQSA9IENNRC5BO1xuICAgICAgICB2YXIgUSA9IENNRC5RO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICBjbWQgPSBkYXRhW2krK107XG4gICAgICAgICAgICBqID0gaTtcbiAgICAgICAgICAgIG5Qb2ludCA9IDA7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBNOlxuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEw6XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQzpcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBROlxuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEE6XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gbVs0XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBtWzVdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ggPSBtYXRoU3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0gbWF0aFNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IG1hdGhBdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjeFxuICAgICAgICAgICAgICAgICAgICBkYXRhW2ldICo9IHN4O1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKz0geDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3lcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpXSAqPSBzeTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IHk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNjYWxlIHJ4IGFuZCByeVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBBc3N1bWUgcHNpIGlzIDAgaGVyZVxuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKj0gc3g7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSAqPSBzeTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBhbmdsZVxuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKz0gYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuZCBhbmdsZVxuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKz0gYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIHBzaVxuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGogPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFI6XG4gICAgICAgICAgICAgICAgICAgIC8vIHgwLCB5MFxuICAgICAgICAgICAgICAgICAgICBwWzBdID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBwWzFdID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzFdO1xuICAgICAgICAgICAgICAgICAgICAvLyB4MSwgeTFcbiAgICAgICAgICAgICAgICAgICAgcFswXSArPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHBbMV0gKz0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgblBvaW50OyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBvaW50c1trXTtcbiAgICAgICAgICAgICAgICBwWzBdID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgIHBbMV0gPSBkYXRhW2krK107XG5cbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICAgICAgICAgIC8vIFdyaXRlIGJhY2tcbiAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybVBhdGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL3Rvb2wvdHJhbnNmb3JtUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBjb2xvclN0b3BzXG4gICAgICovXG4gICAgdmFyIEdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yU3RvcHMpIHtcblxuICAgICAgICB0aGlzLmNvbG9yU3RvcHMgPSBjb2xvclN0b3BzIHx8IFtdO1xuXG4gICAgfTtcblxuICAgIEdyYWRpZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogR3JhZGllbnQsXG5cbiAgICAgICAgYWRkQ29sb3JTdG9wOiBmdW5jdGlvbiAob2Zmc2V0LCBjb2xvcikge1xuICAgICAgICAgICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG5cbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHcmFkaWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVE9ETyBEcmFnZ2FibGUgZm9yIGdyb3VwXG4vLyBGSVhNRSBEcmFnZ2FibGUgb24gZWxlbWVudCB3aGljaCBoYXMgcGFyZW50IHJvdGF0aW9uIG9yIHNjYWxlXG5cbiAgICBmdW5jdGlvbiBEcmFnZ2FibGUoKSB7XG5cbiAgICAgICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5fZHJhZ1N0YXJ0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbignbW91c2Vtb3ZlJywgdGhpcy5fZHJhZywgdGhpcyk7XG4gICAgICAgIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbignZ2xvYmFsb3V0JywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7XG4gICAgICAgIC8vIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICAvLyB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG5cbiAgICAgICAgLy8gdGhpcy5feCA9IDA7XG4gICAgICAgIC8vIHRoaXMuX3kgPSAwO1xuICAgIH1cblxuICAgIERyYWdnYWJsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IERyYWdnYWJsZSxcblxuICAgICAgICBfZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQgJiYgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBkcmFnZ2luZ1RhcmdldDtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gZS5vZmZzZXRZO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcmFnZ2luZ1RhcmdldCwgZSksICdkcmFnc3RhcnQnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IHRoaXMuX2RyYWdnaW5nVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGUub2Zmc2V0WTtcblxuICAgICAgICAgICAgICAgIHZhciBkeCA9IHggLSB0aGlzLl94O1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IHkgLSB0aGlzLl95O1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJpZnQoZHgsIGR5LCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWcnLCBlLmV2ZW50KTtcblxuICAgICAgICAgICAgICAgIHZhciBkcm9wVGFyZ2V0ID0gdGhpcy5maW5kSG92ZXIoeCwgeSwgZHJhZ2dpbmdUYXJnZXQpLnRhcmdldDtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdERyb3BUYXJnZXQgPSB0aGlzLl9kcm9wVGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICE9PSBkcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0RHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShsYXN0RHJvcFRhcmdldCwgZSksICdkcmFnbGVhdmUnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcm9wVGFyZ2V0LCBlKSwgJ2RyYWdlbnRlcicsIGUuZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gdGhpcy5fZHJhZ2dpbmdUYXJnZXQ7XG5cbiAgICAgICAgICAgIGlmIChkcmFnZ2luZ1RhcmdldCkge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nVGFyZ2V0LmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJhZ2dpbmdUYXJnZXQsIGUpLCAnZHJhZ2VuZCcsIGUuZXZlbnQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0odGhpcy5fZHJvcFRhcmdldCwgZSksICdkcm9wJywgZS5ldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGFyYW0odGFyZ2V0LCBlKSB7XG4gICAgICAgIHJldHVybiB7dGFyZ2V0OiB0YXJnZXQsIHRvcFRhcmdldDogZSAmJiBlLnRvcFRhcmdldH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBEcmFnZ2FibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBHcm91cOaYr+S4gOS4quWuueWZqO+8jOWPr+S7peaPkuWFpeWtkOiKgueCue+8jEdyb3Vw55qE5Y+Y5o2i5Lmf5Lya6KKr5bqU55So5Yiw5a2Q6IqC54K55LiKXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAnKTtcbiAqICAgICB2YXIgQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUnKTtcbiAqICAgICB2YXIgZyA9IG5ldyBHcm91cCgpO1xuICogICAgIGcucG9zaXRpb25bMF0gPSAxMDA7XG4gKiAgICAgZy5wb3NpdGlvblsxXSA9IDEwMDtcbiAqICAgICBnLmFkZChuZXcgQ2lyY2xlKHtcbiAqICAgICAgICAgc3R5bGU6IHtcbiAqICAgICAgICAgICAgIHg6IDEwMCxcbiAqICAgICAgICAgICAgIHk6IDEwMCxcbiAqICAgICAgICAgICAgIHI6IDIwLFxuICogICAgICAgICB9XG4gKiAgICAgfSkpO1xuICogICAgIHpyLmFkZChnKTtcbiAqL1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuLi9FbGVtZW50Jyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4uL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICAgICAqL1xuICAgIHZhciBHcm91cCA9IGZ1bmN0aW9uIChvcHRzKSB7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgRWxlbWVudC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRzKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gb3B0c1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcblxuICAgICAgICB0aGlzLl9fc3RvcmFnZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgR3JvdXAucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBHcm91cCxcblxuICAgICAgICBpc0dyb3VwOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogJ2dyb3VwJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5omA5pyJ5a2Q5a2Z5YWD57Sg5piv5ZCm5ZON5bqU6byg5qCH5LqL5Lu2XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9jb250YWluZXIvR3JvdXAjc2lsZW50XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgc2lsZW50OiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL0VsZW1lbnQ+fVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmjIflrpogaW5kZXgg55qE5YS/5a2Q6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gaWR4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZEF0OiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW5baWR4XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5oyH5a6a5ZCN5a2X55qE5YS/5a2Q6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRPZk5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW5baV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRDb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5a2Q6IqC54K55Yiw5pyA5ZCOXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgY2hpbGQgIT09IHRoaXMgJiYgY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2RvQWRkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWtkOiKgueCueWcqCBuZXh0U2libGluZyDkuYvliY1cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IG5leHRTaWJsaW5nXG4gICAgICAgICAqL1xuICAgICAgICBhZGRCZWZvcmU6IGZ1bmN0aW9uIChjaGlsZCwgbmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXNcbiAgICAgICAgICAgICAgICAmJiBuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnQgPT09IHRoaXMpIHtcblxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBjaGlsZHJlbi5pbmRleE9mKG5leHRTaWJsaW5nKTtcblxuICAgICAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAwLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvQWRkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb0FkZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50LnJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgICAgICAgICBpZiAoc3RvcmFnZSAmJiBzdG9yYWdlICE9PSBjaGlsZC5fX3N0b3JhZ2UpIHtcblxuICAgICAgICAgICAgICAgIHN0b3JhZ2UuYWRkVG9TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmFkZENoaWxkcmVuVG9TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgenIgJiYgenIucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnp7vpmaTlrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgICAgICAgdmFyIGlkeCA9IHpyVXRpbC5pbmRleE9mKGNoaWxkcmVuLCBjaGlsZCk7XG4gICAgICAgICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChzdG9yYWdlKSB7XG5cbiAgICAgICAgICAgICAgICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnp7vpmaTmiYDmnInlrZDoioLngrlcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgICAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmBjeWOhuaJgOacieWtkOiKgueCuVxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGVhY2hDaGlsZDogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7HluqbkvJjlhYjpgY3ljobmiYDmnInlrZDlrZnoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBjaGlsZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkQ2hpbGRyZW5Ub1N0b3JhZ2U6IGZ1bmN0aW9uIChzdG9yYWdlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmFkZENoaWxkcmVuVG9TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZWxDaGlsZHJlbkZyb21TdG9yYWdlOiBmdW5jdGlvbiAoc3RvcmFnZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uIChpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIC8vIFRPRE8gQ2FjaGluZ1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gaW5jbHVkZUNoaWxkcmVuIHx8IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgdmFyIHRtcE1hdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlnbm9yZSB8fCBjaGlsZC5pbnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkUmVjdCA9IGNoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBjaGlsZC5nZXRMb2NhbFRyYW5zZm9ybSh0bXBNYXQpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgICAgICAvLyBUaGUgYm91bmRpbmdSZWN0IGNhY2x1YXRlZCBieSB0cmFuc2Zvcm1pbmcgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAvLyByZWN0IG1heSBiZSBiaWdnZXIgdGhhbiB0aGUgYWN0dWFsIGJ1bmRpbmdSZWN0IHdoZW4gcm90YXRpb25cbiAgICAgICAgICAgICAgICAvLyBpcyB1c2VkLiAoQ29uc2lkZXIgYSBjaXJjbGUgcm90YXRlZCBhZ2luc3QgaXRzIGNlbnRlciwgd2hlcmVcbiAgICAgICAgICAgICAgICAvLyB0aGUgYWN0dWFsIGJvdW5kaW5nUmVjdCBzaG91bGQgYmUgdGhlIHNhbWUgYXMgdGhhdCBub3QgYmVcbiAgICAgICAgICAgICAgICAvLyByb3RhdGVkLikgQnV0IHdlIGNhbiBub3QgZmluZCBiZXR0ZXIgYXBwcm9hY2ggdG8gY2FsY3VsYXRlXG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsIGJvdW5kaW5nUmVjdCB5ZXQsIGNvbnNpZGVyaW5nIHBlcmZvcm1hbmNlLlxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wUmVjdC5jb3B5KGNoaWxkUmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHJlY3QgfHwgdG1wUmVjdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICByZWN0LnVuaW9uKHRtcFJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHJlY3QgfHwgY2hpbGRSZWN0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QudW5pb24oY2hpbGRSZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjdCB8fCB0bXBSZWN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhHcm91cCwgRWxlbWVudCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdyb3VwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9jb250YWluZXIvR3JvdXAuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogSW1hZ2UgZWxlbWVudFxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvSW1hZ2VcbiAqL1xuXG5cblxuICAgIHZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoJy4vRGlzcGxheWFibGUnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIGltYWdlSGVscGVyID0gcmVxdWlyZSgnLi9oZWxwZXIvaW1hZ2UnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyB6cmVuZGVyL2dyYXBoaWMvSW1hZ2VcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBaSW1hZ2Uob3B0cykge1xuICAgICAgICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIH1cblxuICAgIFpJbWFnZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFpJbWFnZSxcblxuICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuXG4gICAgICAgIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgc3JjID0gc3R5bGUuaW1hZ2U7XG5cbiAgICAgICAgICAgIC8vIE11c3QgYmluZCBlYWNoIHRpbWVcbiAgICAgICAgICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuXG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSA9IGltYWdlSGVscGVyLmNyZWF0ZU9yVXBkYXRlSW1hZ2Uoc3JjLCB0aGlzLl9pbWFnZSwgdGhpcyk7XG5cbiAgICAgICAgICAgIGlmICghaW1hZ2UgfHwgIWltYWdlSGVscGVyLmlzSW1hZ2VSZWFkeShpbWFnZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIOWbvueJh+W3sue7j+WKoOi9veWujOaIkFxuICAgICAgICAgICAgLy8gaWYgKGltYWdlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gJ0lNRycpIHtcbiAgICAgICAgICAgIC8vICAgICBpZiAoIWltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBFbHNlIGlzIGNhbnZhc1xuXG4gICAgICAgICAgICB2YXIgeCA9IHN0eWxlLnggfHwgMDtcbiAgICAgICAgICAgIHZhciB5ID0gc3R5bGUueSB8fCAwO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc3R5bGUuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGFzcGVjdCA9IGltYWdlLndpZHRoIC8gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHdpZHRoID09IG51bGwgJiYgaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBLZWVwIGltYWdlL2hlaWdodCByYXRpb1xuICAgICAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwgJiYgd2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDorr7nva50cmFuc2Zvcm1cbiAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS5zV2lkdGggJiYgc3R5bGUuc0hlaWdodCkge1xuICAgICAgICAgICAgICAgIHZhciBzeCA9IHN0eWxlLnN4IHx8IDA7XG4gICAgICAgICAgICAgICAgdmFyIHN5ID0gc3R5bGUuc3kgfHwgMDtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHgsIHksIHdpZHRoLCBoZWlnaHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGUuc3ggJiYgc3R5bGUuc3kpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ggPSBzdHlsZS5zeDtcbiAgICAgICAgICAgICAgICB2YXIgc3kgPSBzdHlsZS5zeTtcbiAgICAgICAgICAgICAgICB2YXIgc1dpZHRoID0gd2lkdGggLSBzeDtcbiAgICAgICAgICAgICAgICB2YXIgc0hlaWdodCA9IGhlaWdodCAtIHN5O1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICAgICAgICBzeCwgc3ksIHNXaWR0aCwgc0hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgeCwgeSwgd2lkdGgsIGhlaWdodFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgIC8vIERyYXcgcmVjdCB0ZXh0XG4gICAgICAgICAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICBpZiAoISB0aGlzLl9yZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnggfHwgMCwgc3R5bGUueSB8fCAwLCBzdHlsZS53aWR0aCB8fCAwLCBzdHlsZS5oZWlnaHQgfHwgMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoWkltYWdlLCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFpJbWFnZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUZXh0IGVsZW1lbnRcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL1RleHRcbiAqXG4gKiBUT0RPIFdyYXBwaW5nXG4gKlxuICogVGV4dCBub3Qgc3VwcG9ydCBncmFkaWVudFxuICovXG5cblxuXG4gICAgdmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZSgnLi9EaXNwbGF5YWJsZScpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKCcuLi9jb250YWluL3RleHQnKTtcbiAgICB2YXIgdGV4dEhlbHBlciA9IHJlcXVpcmUoJy4vaGVscGVyL3RleHQnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyB6cmVuZGVyL2dyYXBoaWMvVGV4dFxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIHZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB9O1xuXG4gICAgVGV4dC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFRleHQsXG5cbiAgICAgICAgdHlwZTogJ3RleHQnLFxuXG4gICAgICAgIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICAgICAgICAgIC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIFVzZSBwcm9wcyB3aXRoIHByZWZpeCAndGV4dCcuXG4gICAgICAgICAgICBzdHlsZS5maWxsID0gc3R5bGUuc3Ryb2tlID0gc3R5bGUuc2hhZG93Qmx1ciA9IHN0eWxlLnNoYWRvd0NvbG9yID1cbiAgICAgICAgICAgICAgICBzdHlsZS5zaGFkb3dPZmZzZXRYID0gc3R5bGUuc2hhZG93T2Zmc2V0WSA9IG51bGw7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gc3RyaW5nXG4gICAgICAgICAgICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuXG4gICAgICAgICAgICAvLyBBbHdheXMgYmluZCBzdHlsZVxuICAgICAgICAgICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG5cbiAgICAgICAgICAgIGlmICghdGV4dEhlbHBlci5uZWVkRHJhd1RleHQodGV4dCwgc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgICAgICB0ZXh0SGVscGVyLnJlbmRlclRleHQodGhpcywgY3R4LCB0ZXh0LCBzdHlsZSk7XG5cbiAgICAgICAgICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcblxuICAgICAgICAgICAgLy8gT3B0aW1pemUsIGF2b2lkIG5vcm1hbGl6ZSBldmVyeSB0aW1lLlxuICAgICAgICAgICAgdGhpcy5fX2RpcnR5ICYmIHRleHRIZWxwZXIubm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlLCB0cnVlKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0O1xuICAgICAgICAgICAgICAgIHRleHQgIT0gbnVsbCA/ICh0ZXh0ICs9ICcnKSA6ICh0ZXh0ID0gJycpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnRleHQgKyAnJyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuZm9udCxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZS50ZXh0VmVydGljYWxBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUudGV4dFBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnJpY2hcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgcmVjdC54ICs9IHN0eWxlLnggfHwgMDtcbiAgICAgICAgICAgICAgICByZWN0LnkgKz0gc3R5bGUueSB8fCAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRleHRIZWxwZXIuZ2V0U3Ryb2tlKHN0eWxlLnRleHRTdHJva2UsIHN0eWxlLnRleHRTdHJva2VXaWR0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSBzdHlsZS50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QueCAtPSB3IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgcmVjdC55IC09IHcgLyAyO1xuICAgICAgICAgICAgICAgICAgICByZWN0LndpZHRoICs9IHc7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QuaGVpZ2h0ICs9IHc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhUZXh0LCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRleHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDlnIblvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9DaXJjbGVcbiAqL1xuXG5cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2NpcmNsZScsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIGN4OiAwLFxuICAgICAgICAgICAgY3k6IDAsXG4gICAgICAgICAgICByOiAwXG4gICAgICAgIH0sXG5cblxuICAgICAgICBidWlsZFBhdGggOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSwgaW5CdW5kbGUpIHtcbiAgICAgICAgICAgIC8vIEJldHRlciBzdHJva2luZyBpbiBTaGFwZUJ1bmRsZVxuICAgICAgICAgICAgLy8gQWx3YXlzIGRvIGl0IG1heSBoYXZlIHBlcmZvcm1lbmNlIGlzc3VlICggZmlsbCBtYXkgYmUgMnggbW9yZSBjb3N0KVxuICAgICAgICAgICAgaWYgKGluQnVuZGxlKSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhzaGFwZS5jeCArIHNoYXBlLnIsIHNoYXBlLmN5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2Uge1xuICAgICAgICAgICAgLy8gICAgIGlmIChjdHguYWxsb2NhdGUgJiYgIWN0eC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gICAgICAgICBjdHguYWxsb2NhdGUoY3R4LkNNRF9NRU1fU0laRS5BKTtcbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBCZXR0ZXIgc3Ryb2tpbmcgaW4gU2hhcGVCdW5kbGVcbiAgICAgICAgICAgIC8vIGN0eC5tb3ZlVG8oc2hhcGUuY3ggKyBzaGFwZS5yLCBzaGFwZS5jeSk7XG4gICAgICAgICAgICBjdHguYXJjKHNoYXBlLmN4LCBzaGFwZS5jeSwgc2hhcGUuciwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICog5omH5b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9TZWN0b3JcbiAqL1xuXG5cblxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnLi4vUGF0aCcpO1xuICAgIHZhciBmaXhDbGlwV2l0aFNoYWRvdyA9IHJlcXVpcmUoJy4uL2hlbHBlci9maXhDbGlwV2l0aFNoYWRvdycpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXRoLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3NlY3RvcicsXG5cbiAgICAgICAgc2hhcGU6IHtcblxuICAgICAgICAgICAgY3g6IDAsXG5cbiAgICAgICAgICAgIGN5OiAwLFxuXG4gICAgICAgICAgICByMDogMCxcblxuICAgICAgICAgICAgcjogMCxcblxuICAgICAgICAgICAgc3RhcnRBbmdsZTogMCxcblxuICAgICAgICAgICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuXG4gICAgICAgICAgICBjbG9ja3dpc2U6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBicnVzaDogZml4Q2xpcFdpdGhTaGFkb3coUGF0aC5wcm90b3R5cGUuYnJ1c2gpLFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcblxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgICAgICAgICB2YXIgcjAgPSBNYXRoLm1heChzaGFwZS5yMCB8fCAwLCAwKTtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICAgICAgICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG5cbiAgICAgICAgICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odW5pdFggKiByMCArIHgsIHVuaXRZICogcjAgKyB5KTtcblxuICAgICAgICAgICAgY3R4LmxpbmVUbyh1bml0WCAqIHIgKyB4LCB1bml0WSAqIHIgKyB5KTtcblxuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgIWNsb2Nrd2lzZSk7XG5cbiAgICAgICAgICAgIGN0eC5saW5lVG8oXG4gICAgICAgICAgICAgICAgTWF0aC5jb3MoZW5kQW5nbGUpICogcjAgKyB4LFxuICAgICAgICAgICAgICAgIE1hdGguc2luKGVuZEFuZ2xlKSAqIHIwICsgeVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByMCwgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIGNsb2Nrd2lzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuICAgIHZhciBlbnYgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2VudicpO1xuXG4gICAgLy8gRml4IHdlaXJkIGJ1ZyBpbiBzb21lIHZlcnNpb24gb2YgSUUxMSAobGlrZSAxMS4wLjk2MDAuMTc4KiopLFxuICAgIC8vIHdoZXJlIGV4Y2VwdGlvbiBcInVuZXhwZWN0ZWQgY2FsbCB0byBtZXRob2Qgb3IgcHJvcGVydHkgYWNjZXNzXCJcbiAgICAvLyBtaWdodCBiZSB0aHJvd24gd2hlbiBjYWxsaW5nIGN0eC5maWxsIG9yIGN0eC5zdHJva2UgYWZ0ZXIgYSBwYXRoXG4gICAgLy8gd2hvc2UgYXJlYSBzaXplIGlzIHplcm8gaXMgZHJhd24gYW5kIGN0eC5jbGlwKCkgaXMgY2FsbGVkIGFuZFxuICAgIC8vIHNoYWRvd0JsdXIgaXMgc2V0LiBTZWUgIzQ1NzIsICMzMTEyLCAjNTc3Ny5cbiAgICAvLyAoZS5nLixcbiAgICAvLyAgY3R4Lm1vdmVUbygxMCwgMTApO1xuICAgIC8vICBjdHgubGluZVRvKDIwLCAxMCk7XG4gICAgLy8gIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAvLyAgY3R4LmNsaXAoKTtcbiAgICAvLyAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcbiAgICAvLyAgLi4uXG4gICAgLy8gIGN0eC5maWxsKCk7XG4gICAgLy8gKVxuXG4gICAgdmFyIHNoYWRvd1RlbXAgPSBbXG4gICAgICAgIFsnc2hhZG93Qmx1cicsIDBdLFxuICAgICAgICBbJ3NoYWRvd0NvbG9yJywgJyMwMDAnXSxcbiAgICAgICAgWydzaGFkb3dPZmZzZXRYJywgMF0sXG4gICAgICAgIFsnc2hhZG93T2Zmc2V0WScsIDBdXG4gICAgXTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWduYWxCcnVzaCkge1xuXG4gICAgICAgIC8vIHZlcnNpb24gc3RyaW5nIGNhbiBiZTogJzExLjAnXG4gICAgICAgIHJldHVybiAoZW52LmJyb3dzZXIuaWUgJiYgZW52LmJyb3dzZXIudmVyc2lvbiA+PSAxMSlcblxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsaXBQYXRocyA9IHRoaXMuX19jbGlwUGF0aHM7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcFBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBjbGlwUGF0aCAmJiBjbGlwUGF0aC5zaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gY2xpcFBhdGggJiYgY2xpcFBhdGgudHlwZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZSA9PT0gJ3NlY3RvcicgJiYgc2hhcGUuc3RhcnRBbmdsZSA9PT0gc2hhcGUuZW5kQW5nbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHR5cGUgPT09ICdyZWN0JyAmJiAoIXNoYXBlLndpZHRoIHx8ICFzaGFwZS5oZWlnaHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhZG93VGVtcC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBzYXZlIHRvIHB1dCBzaGFkb3dUZW1wIHN0YXRpYywgYmVjYXVzZSBzaGFkb3dUZW1wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgYWxsIG1vZGlmaWVkIGVhY2ggaXRlbSBicnVzaCBjYWxsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvd1RlbXBbal1bMl0gPSBzdHlsZVtzaGFkb3dUZW1wW2pdWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbc2hhZG93VGVtcFtqXVswXV0gPSBzaGFkb3dUZW1wW2pdWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvcmlnbmFsQnJ1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlW3NoYWRvd1RlbXBbal1bMF1dID0gc2hhZG93VGVtcFtqXVsyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgOiBvcmlnbmFsQnJ1c2g7XG4gICAgfTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9maXhDbGlwV2l0aFNoYWRvdy5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBlY2hhcnRz6K6+5aSH546v5aKD6K+G5YirXG4gKlxuICogQGRlc2MgZWNoYXJ0c+WfuuS6jkNhbnZhc++8jOe6r0phdmFzY3JpcHTlm77ooajlupPvvIzmj5Dkvpvnm7Top4LvvIznlJ/liqjvvIzlj6/kuqTkupLvvIzlj6/kuKrmgKfljJblrprliLbnmoTmlbDmja7nu5/orqHlm77ooajjgIJcbiAqIEBhdXRob3IgZmlyZWRlW2ZpcmVkZUBmaXJlZGUudXNdXG4gKiBAZGVzYyB0aGFua3MgemVwdG8uXG4gKi9cblxuICAgIHZhciBlbnYgPSB7fTtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gSW4gbm9kZVxuICAgICAgICBlbnYgPSB7XG4gICAgICAgICAgICBicm93c2VyOiB7fSxcbiAgICAgICAgICAgIG9zOiB7fSxcbiAgICAgICAgICAgIG5vZGU6IHRydWUsXG4gICAgICAgICAgICAvLyBBc3N1bWUgY2FudmFzIGlzIHN1cHBvcnRlZFxuICAgICAgICAgICAgY2FudmFzU3VwcG9ydGVkOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbnYgPSBkZXRlY3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlbnY7XG5cbiAgICAvLyBaZXB0by5qc1xuICAgIC8vIChjKSAyMDEwLTIwMTMgVGhvbWFzIEZ1Y2hzXG4gICAgLy8gWmVwdG8uanMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbiAgICBmdW5jdGlvbiBkZXRlY3QodWEpIHtcbiAgICAgICAgdmFyIG9zID0ge307XG4gICAgICAgIHZhciBicm93c2VyID0ge307XG4gICAgICAgIC8vIHZhciB3ZWJraXQgPSB1YS5tYXRjaCgvV2ViW2tLXWl0W1xcL117MCwxfShbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgYW5kcm9pZCA9IHVhLm1hdGNoKC8oQW5kcm9pZCk7P1tcXHNcXC9dKyhbXFxkLl0rKT8vKTtcbiAgICAgICAgLy8gdmFyIGlwYWQgPSB1YS5tYXRjaCgvKGlQYWQpLipPU1xccyhbXFxkX10rKS8pO1xuICAgICAgICAvLyB2YXIgaXBvZCA9IHVhLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/Lyk7XG4gICAgICAgIC8vIHZhciBpcGhvbmUgPSAhaXBhZCAmJiB1YS5tYXRjaCgvKGlQaG9uZVxcc09TKVxccyhbXFxkX10rKS8pO1xuICAgICAgICAvLyB2YXIgd2Vib3MgPSB1YS5tYXRjaCgvKHdlYk9TfGhwd09TKVtcXHNcXC9dKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciB0b3VjaHBhZCA9IHdlYm9zICYmIHVhLm1hdGNoKC9Ub3VjaFBhZC8pO1xuICAgICAgICAvLyB2YXIga2luZGxlID0gdWEubWF0Y2goL0tpbmRsZVxcLyhbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgc2lsayA9IHVhLm1hdGNoKC9TaWxrXFwvKFtcXGQuX10rKS8pO1xuICAgICAgICAvLyB2YXIgYmxhY2tiZXJyeSA9IHVhLm1hdGNoKC8oQmxhY2tCZXJyeSkuKlZlcnNpb25cXC8oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIGJiMTAgPSB1YS5tYXRjaCgvKEJCMTApLipWZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciByaW10YWJsZXRvcyA9IHVhLm1hdGNoKC8oUklNXFxzVGFibGV0XFxzT1MpXFxzKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBwbGF5Ym9vayA9IHVhLm1hdGNoKC9QbGF5Qm9vay8pO1xuICAgICAgICAvLyB2YXIgY2hyb21lID0gdWEubWF0Y2goL0Nocm9tZVxcLyhbXFxkLl0rKS8pIHx8IHVhLm1hdGNoKC9DcmlPU1xcLyhbXFxkLl0rKS8pO1xuICAgICAgICB2YXIgZmlyZWZveCA9IHVhLm1hdGNoKC9GaXJlZm94XFwvKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBzYWZhcmkgPSB3ZWJraXQgJiYgdWEubWF0Y2goL01vYmlsZVxcLy8pICYmICFjaHJvbWU7XG4gICAgICAgIC8vIHZhciB3ZWJ2aWV3ID0gdWEubWF0Y2goLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvKSAmJiAhY2hyb21lO1xuICAgICAgICB2YXIgaWUgPSB1YS5tYXRjaCgvTVNJRVxccyhbXFxkLl0rKS8pXG4gICAgICAgICAgICAvLyBJRSAxMSBUcmlkZW50LzcuMDsgcnY6MTEuMFxuICAgICAgICAgICAgfHwgdWEubWF0Y2goL1RyaWRlbnRcXC8uKz9ydjooKFtcXGQuXSspKS8pO1xuICAgICAgICB2YXIgZWRnZSA9IHVhLm1hdGNoKC9FZGdlXFwvKFtcXGQuXSspLyk7IC8vIElFIDEyIGFuZCAxMitcblxuICAgICAgICB2YXIgd2VDaGF0ID0gKC9taWNyb21lc3Nlbmdlci9pKS50ZXN0KHVhKTtcblxuICAgICAgICAvLyBUb2RvOiBjbGVhbiB0aGlzIHVwIHdpdGggYSBiZXR0ZXIgT1MvYnJvd3NlciBzZXBlcmF0aW9uOlxuICAgICAgICAvLyAtIGRpc2Nlcm4gKG1vcmUpIGJldHdlZW4gbXVsdGlwbGUgYnJvd3NlcnMgb24gYW5kcm9pZFxuICAgICAgICAvLyAtIGRlY2lkZSBpZiBraW5kbGUgZmlyZSBpbiBzaWxrIG1vZGUgaXMgYW5kcm9pZCBvciBub3RcbiAgICAgICAgLy8gLSBGaXJlZm94IG9uIEFuZHJvaWQgZG9lc24ndCBzcGVjaWZ5IHRoZSBBbmRyb2lkIHZlcnNpb25cbiAgICAgICAgLy8gLSBwb3NzaWJseSBkZXZpZGUgaW4gb3MsIGRldmljZSBhbmQgYnJvd3NlciBoYXNoZXNcblxuICAgICAgICAvLyBpZiAoYnJvd3Nlci53ZWJraXQgPSAhIXdlYmtpdCkgYnJvd3Nlci52ZXJzaW9uID0gd2Via2l0WzFdO1xuXG4gICAgICAgIC8vIGlmIChhbmRyb2lkKSBvcy5hbmRyb2lkID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGFuZHJvaWRbMl07XG4gICAgICAgIC8vIGlmIChpcGhvbmUgJiYgIWlwb2QpIG9zLmlvcyA9IG9zLmlwaG9uZSA9IHRydWUsIG9zLnZlcnNpb24gPSBpcGhvbmVbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAgICAgICAvLyBpZiAoaXBhZCkgb3MuaW9zID0gb3MuaXBhZCA9IHRydWUsIG9zLnZlcnNpb24gPSBpcGFkWzJdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgICAgICAgLy8gaWYgKGlwb2QpIG9zLmlvcyA9IG9zLmlwb2QgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBvZFszXSA/IGlwb2RbM10ucmVwbGFjZSgvXy9nLCAnLicpIDogbnVsbDtcbiAgICAgICAgLy8gaWYgKHdlYm9zKSBvcy53ZWJvcyA9IHRydWUsIG9zLnZlcnNpb24gPSB3ZWJvc1syXTtcbiAgICAgICAgLy8gaWYgKHRvdWNocGFkKSBvcy50b3VjaHBhZCA9IHRydWU7XG4gICAgICAgIC8vIGlmIChibGFja2JlcnJ5KSBvcy5ibGFja2JlcnJ5ID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGJsYWNrYmVycnlbMl07XG4gICAgICAgIC8vIGlmIChiYjEwKSBvcy5iYjEwID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGJiMTBbMl07XG4gICAgICAgIC8vIGlmIChyaW10YWJsZXRvcykgb3MucmltdGFibGV0b3MgPSB0cnVlLCBvcy52ZXJzaW9uID0gcmltdGFibGV0b3NbMl07XG4gICAgICAgIC8vIGlmIChwbGF5Ym9vaykgYnJvd3Nlci5wbGF5Ym9vayA9IHRydWU7XG4gICAgICAgIC8vIGlmIChraW5kbGUpIG9zLmtpbmRsZSA9IHRydWUsIG9zLnZlcnNpb24gPSBraW5kbGVbMV07XG4gICAgICAgIC8vIGlmIChzaWxrKSBicm93c2VyLnNpbGsgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBzaWxrWzFdO1xuICAgICAgICAvLyBpZiAoIXNpbGsgJiYgb3MuYW5kcm9pZCAmJiB1YS5tYXRjaCgvS2luZGxlIEZpcmUvKSkgYnJvd3Nlci5zaWxrID0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgKGNocm9tZSkgYnJvd3Nlci5jaHJvbWUgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBjaHJvbWVbMV07XG4gICAgICAgIGlmIChmaXJlZm94KSB7XG4gICAgICAgICAgICBicm93c2VyLmZpcmVmb3ggPSB0cnVlO1xuICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uID0gZmlyZWZveFsxXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiAoc2FmYXJpICYmICh1YS5tYXRjaCgvU2FmYXJpLykgfHwgISFvcy5pb3MpKSBicm93c2VyLnNhZmFyaSA9IHRydWU7XG4gICAgICAgIC8vIGlmICh3ZWJ2aWV3KSBicm93c2VyLndlYnZpZXcgPSB0cnVlO1xuXG4gICAgICAgIGlmIChpZSkge1xuICAgICAgICAgICAgYnJvd3Nlci5pZSA9IHRydWU7XG4gICAgICAgICAgICBicm93c2VyLnZlcnNpb24gPSBpZVsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlZGdlKSB7XG4gICAgICAgICAgICBicm93c2VyLmVkZ2UgPSB0cnVlO1xuICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uID0gZWRnZVsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEl0IGlzIGRpZmZpY3VsdCB0byBkZXRlY3QgV2VDaGF0IGluIFdpbiBQaG9uZSBwcmVjaXNlbHksIGJlY2F1c2UgdWEgY2FuXG4gICAgICAgIC8vIG5vdCBiZSBzZXQgb24gd2luIHBob25lLiBTbyB3ZSBkbyBub3QgY29uc2lkZXIgV2luIFBob25lLlxuICAgICAgICBpZiAod2VDaGF0KSB7XG4gICAgICAgICAgICBicm93c2VyLndlQ2hhdCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvcy50YWJsZXQgPSAhIShpcGFkIHx8IHBsYXlib29rIHx8IChhbmRyb2lkICYmICF1YS5tYXRjaCgvTW9iaWxlLykpIHx8XG4gICAgICAgIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvVGFibGV0LykpIHx8IChpZSAmJiAhdWEubWF0Y2goL1Bob25lLykgJiYgdWEubWF0Y2goL1RvdWNoLykpKTtcbiAgICAgICAgLy8gb3MucGhvbmUgID0gISEoIW9zLnRhYmxldCAmJiAhb3MuaXBvZCAmJiAoYW5kcm9pZCB8fCBpcGhvbmUgfHwgd2Vib3MgfHxcbiAgICAgICAgLy8gICAgIChjaHJvbWUgJiYgdWEubWF0Y2goL0FuZHJvaWQvKSkgfHwgKGNocm9tZSAmJiB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKSkgfHxcbiAgICAgICAgLy8gICAgIChmaXJlZm94ICYmIHVhLm1hdGNoKC9Nb2JpbGUvKSkgfHwgKGllICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSkpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBicm93c2VyOiBicm93c2VyLFxuICAgICAgICAgICAgb3M6IG9zLFxuICAgICAgICAgICAgbm9kZTogZmFsc2UsXG4gICAgICAgICAgICAvLyDljp/nlJ9jYW52YXPmlK/mjIHvvIzmlLnmnoHnq6/ngrnkuoZcbiAgICAgICAgICAgIC8vIGNhbnZhc1N1cHBvcnRlZCA6ICEoYnJvd3Nlci5pZSAmJiBwYXJzZUZsb2F0KGJyb3dzZXIudmVyc2lvbikgPCA5KVxuICAgICAgICAgICAgY2FudmFzU3VwcG9ydGVkIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIEBzZWUgPGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDgxNzAyOS93aGF0cy10aGUtYmVzdC13YXktdG8tZGV0ZWN0LWEtdG91Y2gtc2NyZWVuLWRldmljZS11c2luZy1qYXZhc2NyaXB0PlxuICAgICAgICAgICAgLy8gd29ya3Mgb24gbW9zdCBicm93c2Vyc1xuICAgICAgICAgICAgLy8gSUUxMC8xMSBkb2VzIG5vdCBzdXBwb3J0IHRvdWNoIGV2ZW50LCBhbmQgTVMgRWRnZSBzdXBwb3J0cyB0aGVtIGJ1dCBub3QgYnlcbiAgICAgICAgICAgIC8vIGRlZmF1bHQsIHNvIHdlIGRvbnQgY2hlY2sgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIGZvciB0aGVtIGhlcmUuXG4gICAgICAgICAgICB0b3VjaEV2ZW50c1N1cHBvcnRlZDogJ29udG91Y2hzdGFydCcgaW4gd2luZG93ICYmICFicm93c2VyLmllICYmICFicm93c2VyLmVkZ2UsXG4gICAgICAgICAgICAvLyA8aHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9cG9pbnRlciUyMGV2ZW50Pi5cbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHNTdXBwb3J0ZWQ6ICdvbnBvaW50ZXJkb3duJyBpbiB3aW5kb3dcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IHN1cHBvcnRzIHBvaW50ZXIgYnV0IG5vdCBieSBkZWZhdWx0LCBvbmx5IE1TIGJyb3dzZXJzIGFyZSByZWxpYWJsZSBvbiBwb2ludGVyXG4gICAgICAgICAgICAgICAgLy8gZXZlbnRzIGN1cnJlbnRseS4gU28gd2UgZG9udCB1c2UgdGhhdCBvbiBvdGhlciBicm93c2VycyB1bmxlc3MgdGVzdGVkIHN1ZmZpY2llbnRseS5cbiAgICAgICAgICAgICAgICAvLyBBbHRob3VnaCBJRSAxMCBzdXBwb3J0cyBwb2ludGVyIGV2ZW50LCBpdCB1c2Ugb2xkIHN0eWxlIGFuZCBpcyBkaWZmZXJlbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZC4gU28gd2UgZXhjbHVkZSB0aGF0LiAoSUUgMTAgaXMgaGFyZGx5IHVzZWQgb24gdG91Y2ggZGV2aWNlKVxuICAgICAgICAgICAgICAgICYmIChicm93c2VyLmVkZ2UgfHwgKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci52ZXJzaW9uID49IDExKSlcbiAgICAgICAgfTtcbiAgICB9XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvcmUvZW52LmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIOWchueOr1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmluZ1xuICovXG5cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3JpbmcnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBjeDogMCxcbiAgICAgICAgICAgIGN5OiAwLFxuICAgICAgICAgICAgcjogMCxcbiAgICAgICAgICAgIHIwOiAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgICAgICAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyBzaGFwZS5yLCB5KTtcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgc2hhcGUuciwgMCwgUEkyLCBmYWxzZSk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyBzaGFwZS5yMCwgeSk7XG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHNoYXBlLnIwLCAwLCBQSTIsIHRydWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIOWkmui+ueW9olxuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL1BvbHlnb25cbiAqL1xuXG5cbiAgICB2YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoJy4uL2hlbHBlci9wb2x5Jyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuICAgICAgICBcbiAgICAgICAgdHlwZTogJ3BvbHlnb24nLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBwb2ludHM6IG51bGwsXG5cbiAgICAgICAgICAgIHNtb290aDogZmFsc2UsXG5cbiAgICAgICAgICAgIHNtb290aENvbnN0cmFpbnQ6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICBwb2x5SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlnb24uanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuXG4gICAgdmFyIHNtb290aFNwbGluZSA9IHJlcXVpcmUoJy4vc21vb3RoU3BsaW5lJyk7XG4gICAgdmFyIHNtb290aEJlemllciA9IHJlcXVpcmUoJy4vc21vb3RoQmV6aWVyJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSwgY2xvc2VQYXRoKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICAgICAgICAgICAgdmFyIHNtb290aCA9IHNoYXBlLnNtb290aDtcbiAgICAgICAgICAgIGlmIChwb2ludHMgJiYgcG9pbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNtb290aCAmJiBzbW9vdGggIT09ICdzcGxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sUG9pbnRzID0gc21vb3RoQmV6aWVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLCBzbW9vdGgsIGNsb3NlUGF0aCwgc2hhcGUuc21vb3RoQ29uc3RyYWludFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoY2xvc2VQYXRoID8gbGVuIDogbGVuIC0gMSk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNwMSA9IGNvbnRyb2xQb2ludHNbaSAqIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNwMiA9IGNvbnRyb2xQb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3AxWzBdLCBjcDFbMV0sIGNwMlswXSwgY3AyWzFdLCBwWzBdLCBwWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc21vb3RoID09PSAnc3BsaW5lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gc21vb3RoU3BsaW5lKHBvaW50cywgY2xvc2VQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2xvc2VQYXRoICYmIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3BvbHkuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ2F0bXVsbC1Sb20gc3BsaW5lIOaPkuWAvOaKmOe6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoU3BsaW5lXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqICAgICAgICAgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdmVjdG9yJyk7XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gICAgICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgICAgICAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICAgICAgICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzXG4gICAgICAgICAgICAgICAgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MlxuICAgICAgICAgICAgICAgICsgdjAgKiB0ICsgcDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoU3BsaW5lXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIOe6v+autemhtueCueaVsOe7hFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb29wXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocG9pbnRzLCBpc0xvb3ApIHtcbiAgICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSArPSB2ZWMyLmRpc3RhbmNlKHBvaW50c1tpIC0gMV0sIHBvaW50c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VncyA9IGRpc3RhbmNlIC8gMjtcbiAgICAgICAgc2VncyA9IHNlZ3MgPCBsZW4gPyBsZW4gOiBzZWdzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ3M7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvcyA9IGkgLyAoc2VncyAtIDEpICogKGlzTG9vcCA/IGxlbiA6IGxlbiAtIDEpO1xuICAgICAgICAgICAgdmFyIGlkeCA9IE1hdGguZmxvb3IocG9zKTtcblxuICAgICAgICAgICAgdmFyIHcgPSBwb3MgLSBpZHg7XG5cbiAgICAgICAgICAgIHZhciBwMDtcbiAgICAgICAgICAgIHZhciBwMSA9IHBvaW50c1tpZHggJSBsZW5dO1xuICAgICAgICAgICAgdmFyIHAyO1xuICAgICAgICAgICAgdmFyIHAzO1xuICAgICAgICAgICAgaWYgKCFpc0xvb3ApIHtcbiAgICAgICAgICAgICAgICBwMCA9IHBvaW50c1tpZHggPT09IDAgPyBpZHggOiBpZHggLSAxXTtcbiAgICAgICAgICAgICAgICBwMiA9IHBvaW50c1tpZHggPiBsZW4gLSAyID8gbGVuIC0gMSA6IGlkeCArIDFdO1xuICAgICAgICAgICAgICAgIHAzID0gcG9pbnRzW2lkeCA+IGxlbiAtIDMgPyBsZW4gLSAxIDogaWR4ICsgMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwMCA9IHBvaW50c1soaWR4IC0gMSArIGxlbikgJSBsZW5dO1xuICAgICAgICAgICAgICAgIHAyID0gcG9pbnRzWyhpZHggKyAxKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgcDMgPSBwb2ludHNbKGlkeCArIDIpICUgbGVuXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHcyID0gdyAqIHc7XG4gICAgICAgICAgICB2YXIgdzMgPSB3ICogdzI7XG5cbiAgICAgICAgICAgIHJldC5wdXNoKFtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShwMFswXSwgcDFbMF0sIHAyWzBdLCBwM1swXSwgdywgdzIsIHczKSxcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShwMFsxXSwgcDFbMV0sIHAyWzFdLCBwM1sxXSwgdywgdzIsIHczKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aFNwbGluZS5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiDotJ3loZ7lsJTlubPmu5Hmm7Lnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIHYyTWluID0gdmVjMi5taW47XG4gICAgdmFyIHYyTWF4ID0gdmVjMi5tYXg7XG4gICAgdmFyIHYyU2NhbGUgPSB2ZWMyLnNjYWxlO1xuICAgIHZhciB2MkRpc3RhbmNlID0gdmVjMi5kaXN0YW5jZTtcbiAgICB2YXIgdjJBZGQgPSB2ZWMyLmFkZDtcblxuICAgIC8qKlxuICAgICAqIOi0neWhnuWwlOW5s+a7keabsue6v1xuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyDnur/mrrXpobbngrnmlbDnu4RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc21vb3RoIOW5s+a7keetiee6pywgMC0xXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xvb3BcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25zdHJhaW50IOWwhuiuoeeul+WHuuadpeeahOaOp+WItueCuee6puadn+WcqOS4gOS4quWMheWbtOebkuWGhVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5q+U5aaCIFtbMCwgMF0sIFsxMDAsIDEwMF1dLCDov5nkuKrljIXlm7Tnm5LkvJrkuI5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOaVtOS4quaKmOe6v+eahOWMheWbtOebkuWBmuS4gOS4quW5tumbhueUqOadpee6puadn+aOp+WItueCueOAglxuICAgICAqIEBwYXJhbSB7QXJyYXl9IOiuoeeul+WHuuadpeeahOaOp+WItueCueaVsOe7hFxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBvaW50cywgc21vb3RoLCBpc0xvb3AsIGNvbnN0cmFpbnQpIHtcbiAgICAgICAgdmFyIGNwcyA9IFtdO1xuXG4gICAgICAgIHZhciB2ID0gW107XG4gICAgICAgIHZhciB2MSA9IFtdO1xuICAgICAgICB2YXIgdjIgPSBbXTtcbiAgICAgICAgdmFyIHByZXZQb2ludDtcbiAgICAgICAgdmFyIG5leHRQb2ludDtcblxuICAgICAgICB2YXIgbWluLCBtYXg7XG4gICAgICAgIGlmIChjb25zdHJhaW50KSB7XG4gICAgICAgICAgICBtaW4gPSBbSW5maW5pdHksIEluZmluaXR5XTtcbiAgICAgICAgICAgIG1heCA9IFstSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdjJNaW4obWluLCBtaW4sIHBvaW50c1tpXSk7XG4gICAgICAgICAgICAgICAgdjJNYXgobWF4LCBtYXgsIHBvaW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDkuI7mjIflrprnmoTljIXlm7Tnm5LlgZrlubbpm4ZcbiAgICAgICAgICAgIHYyTWluKG1pbiwgbWluLCBjb25zdHJhaW50WzBdKTtcbiAgICAgICAgICAgIHYyTWF4KG1heCwgbWF4LCBjb25zdHJhaW50WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcblxuICAgICAgICAgICAgaWYgKGlzTG9vcCkge1xuICAgICAgICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50c1tpID8gaSAtIDEgOiBsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbKGkgKyAxKSAlIGxlbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNwcy5wdXNoKHZlYzIuY2xvbmUocG9pbnRzW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZlYzIuc3ViKHYsIG5leHRQb2ludCwgcHJldlBvaW50KTtcblxuICAgICAgICAgICAgLy8gdXNlIGRlZ3JlZSB0byBzY2FsZSB0aGUgaGFuZGxlIGxlbmd0aFxuICAgICAgICAgICAgdjJTY2FsZSh2LCB2LCBzbW9vdGgpO1xuXG4gICAgICAgICAgICB2YXIgZDAgPSB2MkRpc3RhbmNlKHBvaW50LCBwcmV2UG9pbnQpO1xuICAgICAgICAgICAgdmFyIGQxID0gdjJEaXN0YW5jZShwb2ludCwgbmV4dFBvaW50KTtcbiAgICAgICAgICAgIHZhciBzdW0gPSBkMCArIGQxO1xuICAgICAgICAgICAgaWYgKHN1bSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGQwIC89IHN1bTtcbiAgICAgICAgICAgICAgICBkMSAvPSBzdW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHYyU2NhbGUodjEsIHYsIC1kMCk7XG4gICAgICAgICAgICB2MlNjYWxlKHYyLCB2LCBkMSk7XG4gICAgICAgICAgICB2YXIgY3AwID0gdjJBZGQoW10sIHBvaW50LCB2MSk7XG4gICAgICAgICAgICB2YXIgY3AxID0gdjJBZGQoW10sIHBvaW50LCB2Mik7XG4gICAgICAgICAgICBpZiAoY29uc3RyYWludCkge1xuICAgICAgICAgICAgICAgIHYyTWF4KGNwMCwgY3AwLCBtaW4pO1xuICAgICAgICAgICAgICAgIHYyTWluKGNwMCwgY3AwLCBtYXgpO1xuICAgICAgICAgICAgICAgIHYyTWF4KGNwMSwgY3AxLCBtaW4pO1xuICAgICAgICAgICAgICAgIHYyTWluKGNwMSwgY3AxLCBtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3BzLnB1c2goY3AwKTtcbiAgICAgICAgICAgIGNwcy5wdXNoKGNwMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNMb29wKSB7XG4gICAgICAgICAgICBjcHMucHVzaChjcHMuc2hpZnQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3BzO1xuICAgIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1BvbHlsaW5lXG4gKi9cblxuXG4gICAgdmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvcG9seScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcbiAgICAgICAgXG4gICAgICAgIHR5cGU6ICdwb2x5bGluZScsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHBvaW50czogbnVsbCxcblxuICAgICAgICAgICAgc21vb3RoOiBmYWxzZSxcblxuICAgICAgICAgICAgc21vb3RoQ29uc3RyYWludDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcblxuICAgICAgICAgICAgZmlsbDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHBvbHlIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIOefqeW9olxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmVjdFxuICovXG5cblxuICAgIHZhciByb3VuZFJlY3RIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvcm91bmRSZWN0Jyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdyZWN0JyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgLy8g5bem5LiK44CB5Y+z5LiK44CB5Y+z5LiL44CB5bem5LiL6KeS55qE5Y2K5b6E5L6d5qyh5Li6cjHjgIFyMuOAgXIz44CBcjRcbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLoxICAgICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ulsxXSAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6WzEsIDJdICAgIOebuOW9k+S6jiBbMSwgMiwgMSwgMl1cbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLpbMSwgMiwgM10g55u45b2T5LqOIFsxLCAyLCAzLCAyXVxuICAgICAgICAgICAgcjogMCxcblxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgICAgICAgICAgIGlmICghc2hhcGUucikge1xuICAgICAgICAgICAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm91bmRSZWN0SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiDnm7Tnur9cbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL0xpbmVcbiAqL1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnbGluZScsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHBvaW50XG4gICAgICAgICAgICB4MTogMCxcbiAgICAgICAgICAgIHkxOiAwLFxuICAgICAgICAgICAgLy8gRW5kIHBvaW50XG4gICAgICAgICAgICB4MjogMCxcbiAgICAgICAgICAgIHkyOiAwLFxuXG4gICAgICAgICAgICBwZXJjZW50OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuICAgICAgICAgICAgZmlsbDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4MSA9IHNoYXBlLngxO1xuICAgICAgICAgICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgICAgICAgICB2YXIgeDIgPSBzaGFwZS54MjtcbiAgICAgICAgICAgIHZhciB5MiA9IHNoYXBlLnkyO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xuXG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgICAgICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICB4MiA9IHgxICogKDEgLSBwZXJjZW50KSArIHgyICogcGVyY2VudDtcbiAgICAgICAgICAgICAgICB5MiA9IHkxICogKDEgLSBwZXJjZW50KSArIHkyICogcGVyY2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRBdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHNoYXBlLngxICogKDEgLSBwKSArIHNoYXBlLngyICogcCxcbiAgICAgICAgICAgICAgICBzaGFwZS55MSAqICgxIC0gcCkgKyBzaGFwZS55MiAqIHBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog6LSd5aGe5bCU5puy57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvQmV6aWVyQ3VydmVcbiAqL1xuXG5cbiAgICB2YXIgY3VydmVUb29sID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jdXJ2ZScpO1xuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi4vLi4vY29yZS92ZWN0b3InKTtcbiAgICB2YXIgcXVhZHJhdGljU3ViZGl2aWRlID0gY3VydmVUb29sLnF1YWRyYXRpY1N1YmRpdmlkZTtcbiAgICB2YXIgY3ViaWNTdWJkaXZpZGUgPSBjdXJ2ZVRvb2wuY3ViaWNTdWJkaXZpZGU7XG4gICAgdmFyIHF1YWRyYXRpY0F0ID0gY3VydmVUb29sLnF1YWRyYXRpY0F0O1xuICAgIHZhciBjdWJpY0F0ID0gY3VydmVUb29sLmN1YmljQXQ7XG4gICAgdmFyIHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IGN1cnZlVG9vbC5xdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XG4gICAgdmFyIGN1YmljRGVyaXZhdGl2ZUF0ID0gY3VydmVUb29sLmN1YmljRGVyaXZhdGl2ZUF0O1xuXG4gICAgdmFyIG91dCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gc29tZVZlY3RvckF0KHNoYXBlLCB0LCBpc1RhbmdlbnQpIHtcbiAgICAgICAgdmFyIGNweDIgPSBzaGFwZS5jcHgyO1xuICAgICAgICB2YXIgY3B5MiA9IHNoYXBlLmNweTI7XG4gICAgICAgIGlmIChjcHgyID09PSBudWxsIHx8IGNweTIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgKGlzVGFuZ2VudCA/IGN1YmljRGVyaXZhdGl2ZUF0IDogY3ViaWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLmNweDIsIHNoYXBlLngyLCB0KSxcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUuY3B5Miwgc2hhcGUueTIsIHQpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gcXVhZHJhdGljRGVyaXZhdGl2ZUF0IDogcXVhZHJhdGljQXQpKHNoYXBlLngxLCBzaGFwZS5jcHgxLCBzaGFwZS54MiwgdCksXG4gICAgICAgICAgICAgICAgKGlzVGFuZ2VudCA/IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA6IHF1YWRyYXRpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUueTIsIHQpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2Jlemllci1jdXJ2ZScsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgeTE6IDAsXG4gICAgICAgICAgICB4MjogMCxcbiAgICAgICAgICAgIHkyOiAwLFxuICAgICAgICAgICAgY3B4MTogMCxcbiAgICAgICAgICAgIGNweTE6IDAsXG4gICAgICAgICAgICAvLyBjcHgyOiAwLFxuICAgICAgICAgICAgLy8gY3B5MjogMFxuXG4gICAgICAgICAgICAvLyBDdXJ2ZSBzaG93IHBlcmNlbnQsIGZvciBhbmltYXRpbmdcbiAgICAgICAgICAgIHBlcmNlbnQ6IDFcbiAgICAgICAgfSxcblxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHgxID0gc2hhcGUueDE7XG4gICAgICAgICAgICB2YXIgeTEgPSBzaGFwZS55MTtcbiAgICAgICAgICAgIHZhciB4MiA9IHNoYXBlLngyO1xuICAgICAgICAgICAgdmFyIHkyID0gc2hhcGUueTI7XG4gICAgICAgICAgICB2YXIgY3B4MSA9IHNoYXBlLmNweDE7XG4gICAgICAgICAgICB2YXIgY3B5MSA9IHNoYXBlLmNweTE7XG4gICAgICAgICAgICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gICAgICAgICAgICB2YXIgY3B5MiA9IHNoYXBlLmNweTI7XG4gICAgICAgICAgICB2YXIgcGVyY2VudCA9IHNoYXBlLnBlcmNlbnQ7XG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgICAgICAgICBpZiAoY3B4MiA9PSBudWxsIHx8IGNweTIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSwgY3B4MSwgeDIsIHBlcmNlbnQsIG91dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjcHgxID0gb3V0WzFdO1xuICAgICAgICAgICAgICAgICAgICB4MiA9IG91dFsyXTtcbiAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeTEsIGNweTEsIHkyLCBwZXJjZW50LCBvdXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3B5MSA9IG91dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBvdXRbMl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgICAgIGNweDEsIGNweTEsXG4gICAgICAgICAgICAgICAgICAgIHgyLCB5MlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3ViaWNTdWJkaXZpZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSwgY3B4MSwgY3B4MiwgeDIsIHBlcmNlbnQsIG91dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjcHgxID0gb3V0WzFdO1xuICAgICAgICAgICAgICAgICAgICBjcHgyID0gb3V0WzJdO1xuICAgICAgICAgICAgICAgICAgICB4MiA9IG91dFszXTtcbiAgICAgICAgICAgICAgICAgICAgY3ViaWNTdWJkaXZpZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB5MSwgY3B5MSwgY3B5MiwgeTIsIHBlcmNlbnQsIG91dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjcHkxID0gb3V0WzFdO1xuICAgICAgICAgICAgICAgICAgICBjcHkyID0gb3V0WzJdO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IG91dFszXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgICAgICAgIGNweDEsIGNweTEsXG4gICAgICAgICAgICAgICAgICAgIGNweDIsIGNweTIsXG4gICAgICAgICAgICAgICAgICAgIHgyLCB5MlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBwb2ludCBhdCBwZXJjZW50XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHBvaW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRhbmdlbnQgYXQgcGVyY2VudFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0YW5nZW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHNvbWVWZWN0b3JBdCh0aGlzLnNoYXBlLCB0LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB2ZWMyLm5vcm1hbGl6ZShwLCBwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICog5ZyG5bynXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9BcmNcbiAqL1xuIFxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnYXJjJyxcblxuICAgICAgICBzaGFwZToge1xuXG4gICAgICAgICAgICBjeDogMCxcblxuICAgICAgICAgICAgY3k6IDAsXG5cbiAgICAgICAgICAgIHI6IDAsXG5cbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IDAsXG5cbiAgICAgICAgICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMixcblxuICAgICAgICAgICAgY2xvY2t3aXNlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcblxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG5cbiAgICAgICAgICAgIGZpbGw6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG5cbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcbiAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcblxuICAgICAgICAgICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIgKyB4LCB1bml0WSAqIHIgKyB5KTtcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFjbG9ja3dpc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJy4vR3JhZGllbnQnKTtcblxuICAgIC8qKlxuICAgICAqIHgsIHksIHgyLCB5MiBhcmUgYWxsIHBlcmNlbnQgZnJvbSAwIHRvIDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3gyPTFdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5Mj0wXVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtnbG9iYWxDb29yZD1mYWxzZV1cbiAgICAgKi9cbiAgICB2YXIgTGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgeDIsIHkyLCBjb2xvclN0b3BzLCBnbG9iYWxDb29yZCkge1xuICAgICAgICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gICAgICAgIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7dHlwZTogJ2xpbmVhcicsIGNvbG9yU3RvcHM6IC4uLn1gLCB3aGVyZVxuICAgICAgICAvLyB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cblxuICAgICAgICB0aGlzLnggPSB4ID09IG51bGwgPyAwIDogeDtcblxuICAgICAgICB0aGlzLnkgPSB5ID09IG51bGwgPyAwIDogeTtcblxuICAgICAgICB0aGlzLngyID0geDIgPT0gbnVsbCA/IDEgOiB4MjtcblxuICAgICAgICB0aGlzLnkyID0geTIgPT0gbnVsbCA/IDAgOiB5MjtcblxuICAgICAgICAvLyBDYW4gYmUgY2xvbmVkXG4gICAgICAgIHRoaXMudHlwZSA9ICdsaW5lYXInO1xuXG4gICAgICAgIC8vIElmIHVzZSBnbG9iYWwgY29vcmRcbiAgICAgICAgdGhpcy5nbG9iYWwgPSBnbG9iYWxDb29yZCB8fCBmYWxzZTtcblxuICAgICAgICBHcmFkaWVudC5jYWxsKHRoaXMsIGNvbG9yU3RvcHMpO1xuICAgIH07XG5cbiAgICBMaW5lYXJHcmFkaWVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IExpbmVhckdyYWRpZW50XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhMaW5lYXJHcmFkaWVudCwgR3JhZGllbnQpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaW5lYXJHcmFkaWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG5cbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCcuL0dyYWRpZW50Jyk7XG5cbiAgICAvKipcbiAgICAgKiB4LCB5LCByIGFyZSBhbGwgcGVyY2VudCBmcm9tIDAgdG8gMVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wLjVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTAuNV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3I9MC41XVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtjb2xvclN0b3BzXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbENvb3JkPWZhbHNlXVxuICAgICAqL1xuICAgIHZhciBSYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uICh4LCB5LCByLCBjb2xvclN0b3BzLCBnbG9iYWxDb29yZCkge1xuICAgICAgICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gICAgICAgIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7dHlwZTogJ3JhZGlhbCcsIGNvbG9yU3RvcHM6IC4uLn1gLCB3aGVyZVxuICAgICAgICAvLyB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cblxuICAgICAgICB0aGlzLnggPSB4ID09IG51bGwgPyAwLjUgOiB4O1xuXG4gICAgICAgIHRoaXMueSA9IHkgPT0gbnVsbCA/IDAuNSA6IHk7XG5cbiAgICAgICAgdGhpcy5yID0gciA9PSBudWxsID8gMC41IDogcjtcblxuICAgICAgICAvLyBDYW4gYmUgY2xvbmVkXG4gICAgICAgIHRoaXMudHlwZSA9ICdyYWRpYWwnO1xuXG4gICAgICAgIC8vIElmIHVzZSBnbG9iYWwgY29vcmRcbiAgICAgICAgdGhpcy5nbG9iYWwgPSBnbG9iYWxDb29yZCB8fCBmYWxzZTtcblxuICAgICAgICBHcmFkaWVudC5jYWxsKHRoaXMsIGNvbG9yU3RvcHMpO1xuICAgIH07XG5cbiAgICBSYWRpYWxHcmFkaWVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFJhZGlhbEdyYWRpZW50XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhSYWRpYWxHcmFkaWVudCwgR3JhZGllbnQpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSYWRpYWxHcmFkaWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBTdGF0ZXMgbWFjaGluZSBmb3IgbWFuYWdpbmcgZ3JhcGhpYyBzdGF0ZXNcbiAqL1xuXG5cblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IElHcmFwaGljU3RhdGVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3psZXZlbF1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3pdXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPn0ge3Bvc2l0aW9ufVxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVtYmVyfSB7cm90YXRpb259XG4gICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPn0ge3NjYWxlfVxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzdHlsZVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb25lbnRlclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG9ubGVhdmVcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvbnRyYW5zaXRpb25cbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxJR3JhcGhpY1N0YXRlVHJhbnNpdGlvbnxzdHJpbmc+fSB0cmFuc2l0aW9uXG4gICAgICogICAgICAgICAgIFRyYW5zaXRpb24gb2JqZWN0IG9yIGEgc3RyaW5nIGRlc2NyaXB0b3IgbGlrZSAnKiAzMCAwIExpbmVhcidcbiAgICAgKi9cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgU3R5bGUgPSByZXF1aXJlKCcuL1N0eWxlJyk7XG4gICAgdmFyIHZlYzJDb3B5ID0gcmVxdWlyZSgnLi4vY29yZS92ZWN0b3InKS5jb3B5O1xuXG4gICAgdmFyIHRyYW5zaXRpb25Qcm9wZXJ0aWVzID0gWydwb3NpdGlvbicsICdyb3RhdGlvbicsICdzY2FsZScsICdzdHlsZScsICdzaGFwZSddO1xuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL1N0YXRlc35UcmFuc2l0aW9uT2JqZWN0XG4gICAgICovXG4gICAgdmFyIFRyYW5zaXRpb25PYmplY3QgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zyb21TdHIob3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0cykge1xuICAgICAgICAgICAgb3B0cy5wcm9wZXJ0eSAmJiAodGhpcy5wcm9wZXJ0eSA9IG9wdHMucHJvcGVydHkpO1xuICAgICAgICAgICAgb3B0cy5kdXJhdGlvbiAhPSBudWxsICYmICh0aGlzLmR1cmF0aW9uID0gb3B0cy5kdXJhdGlvbik7XG4gICAgICAgICAgICBvcHRzLmVhc2luZyAmJiAodGhpcy5lYXNpbmcgPSBvcHRzLmVhc2luZyk7XG4gICAgICAgICAgICBvcHRzLmRlbGF5ICYmICh0aGlzLmRlbGF5ID0gb3B0cy5kZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcGVydHkgIT09ICcqJykge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHRoaXMucHJvcGVydHkuc3BsaXQoJywnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkgPSB0cmFuc2l0aW9uUHJvcGVydGllcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBUcmFuc2l0aW9uT2JqZWN0LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogVHJhbnNpdGlvbk9iamVjdCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBvZiBhbGwgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzLiBTcGxpdHRlZCBieSBjb21tYS4gTXVzdCBub3QgaGF2ZSBzcGFjZXMgaW4gdGhlIHN0cmluZy5cbiAgICAgICAgICogZS5nLiAncG9zaXRpb24sc3R5bGUuY29sb3InLiAnKicgd2lsbCBtYXRjaCBhbGwgdGhlIHZhbGlkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICpcbiAgICAgICAgICovXG4gICAgICAgIHByb3BlcnR5OiAnKicsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdMaW5lYXInXG4gICAgICAgICAqL1xuICAgICAgICBlYXNpbmc6ICdMaW5lYXInLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbnVtYmVyJ1xuICAgICAgICAgKi9cbiAgICAgICAgZHVyYXRpb246IDUwMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGRlbGF5OiAwLFxuXG4gICAgICAgIF9mcm9tU3RyOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gc3RyLnNwbGl0KC9cXHMrL2cpO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IGFyclswXTtcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSArYXJyWzFdO1xuICAgICAgICAgICAgdGhpcy5kZWxheSA9ICthcnJbMl07XG4gICAgICAgICAgICB0aGlzLmVhc2luZyA9IGFyclszXTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL1N0YXRlc1xuICAgICAqL1xuICAgIHZhciBHcmFwaGljU3RhdGVzID0gZnVuY3Rpb24gKG9wdHMpIHtcblxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICB0aGlzLl9zdGF0ZXMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICogQHR5cGUge3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZXx6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2VsID0gb3B0cy5lbDtcblxuICAgICAgICB0aGlzLl9zdWJTdGF0ZXMgPSBbXTtcblxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uQW5pbWF0b3JzID0gW107XG5cbiAgICAgICAgaWYgKG9wdHMuaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsU3RhdGUgPSBvcHRzLmluaXRpYWxTdGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRzU3RhdGVzID0gb3B0cy5zdGF0ZXM7XG4gICAgICAgIGlmIChvcHRzU3RhdGVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9wdHNTdGF0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0c1N0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBvcHRzU3RhdGVzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRTdGF0ZShuYW1lLCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLl9pbml0aWFsU3RhdGUpO1xuICAgIH07XG5cbiAgICBHcmFwaGljU3RhdGVzLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogR3JhcGhpY1N0YXRlcyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIG90aGVyIHN0YXRlIHdpbGwgYmUgZXh0ZW5kZWQgZnJvbSBpbml0aWFsIHN0YXRlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfaW5pdGlhbFN0YXRlOiAnbm9ybWFsJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2N1cnJlbnRTdGF0ZTogJycsXG5cbiAgICAgICAgZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbDtcbiAgICAgICAgfSxcblxuICAgICAgICBfYWRkU3RhdGU6IGZ1bmN0aW9uIChuYW1lLCBzdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVzW25hbWVdID0gc3RhdGU7XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uT2JqZWN0KHN0YXRlLnRyYW5zaXRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFeHRlbmQgZnJvbSBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gdGhpcy5faW5pdGlhbFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXh0ZW5kRnJvbUluaXRpYWwoc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5fZWw7XG4gICAgICAgICAgICAgICAgLy8gc2V0U3RhdGUg55qE5pe25YCZ6Ieq5bim55qEIHN0eWxlIOWSjCBzaGFwZSDpg73kvJrooqvnm7TmjqXopobnm5ZcbiAgICAgICAgICAgICAgICAvLyDmiYDku6Xov5novrnlhYjmioroh6rluKbnmoQgc3R5bGUg5ZKMIHNoYXBlIOaJqeWxleWIsOWIneWni+eKtuaAgeS4rVxuICAgICAgICAgICAgICAgIHpyVXRpbC5tZXJnZShzdGF0ZS5zdHlsZSwgZWwuc3R5bGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5tZXJnZShzdGF0ZS5zaGFwZSwgZWwuc2hhcGUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnNoYXBlID0genJVdGlsLmNsb25lKGVsLnNoYXBlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuX3N0YXRlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHRlbmRGcm9tSW5pdGlhbCh0aGlzLl9zdGF0ZXNbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9leHRlbmRGcm9tSW5pdGlhbDogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5fc3RhdGVzW3RoaXMuX2luaXRpYWxTdGF0ZV07XG4gICAgICAgICAgICBpZiAoaW5pdGlhbFN0YXRlICYmIHN0YXRlICE9PSBpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB6clV0aWwubWVyZ2Uoc3RhdGUsIGluaXRpYWxTdGF0ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldFN0YXRlOiBmdW5jdGlvbiAobmFtZSwgc2lsZW50KSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gdGhpcy5fY3VycmVudFN0YXRlXG4gICAgICAgICAgICAgICAgJiYgISB0aGlzLnRyYW5zaXRpbmcoKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZXNbbmFtZV07XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BUcmFuc2l0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoISBzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IHRoaXMuX3N0YXRlc1t0aGlzLl9jdXJyZW50U3RhdGVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldlN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2U3RhdGUub25sZWF2ZSAmJiBwcmV2U3RhdGUub25sZWF2ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUub25lbnRlciAmJiBzdGF0ZS5vbmVudGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlID0gbmFtZTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLl9lbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnpsZXZlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC56bGV2ZWwgPSBzdGF0ZS56bGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnogIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwueiA9IHN0YXRlLno7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTUlRcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucG9zaXRpb24gJiYgdmVjMkNvcHkoZWwucG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2NhbGUgJiYgdmVjMkNvcHkoZWwuc2NhbGUsIHN0YXRlLnNjYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnJvdGF0aW9uID0gc3RhdGUucm90YXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTdHlsZVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLl9zdGF0ZXNbdGhpcy5faW5pdGlhbFN0YXRlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlID0gbmV3IFN0eWxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuZXh0ZW5kRnJvbShpbml0aWFsU3RhdGUuc3R5bGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgaW5pdGlhbCBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgIT0gdGhpcy5faW5pdGlhbFN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGNvcGllZCBmcm9tIGluaXRpYWwgc3RhdGUgaW4gX2V4dGVuZEZyb21Jbml0aWFsIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGluaXRpYWxTdGF0ZS5zdHlsZSAhPT0gc3RhdGUuc3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmV4dGVuZEZyb20oc3RhdGUuc3R5bGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2hhcGUgPSB6clV0aWwuY2xvbmUoc3RhdGUuc2hhcGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZWwuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc3ViU3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3ViU3RhdGVzLnNldFN0YXRlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zaXRpb25TdGF0ZTogZnVuY3Rpb24gKHRhcmdldCwgZG9uZSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHRhcmdldCA9PT0gdGhpcy5fY3VycmVudFN0YXRlXG4gICAgICAgICAgICAgICAgJiYgISB0aGlzLnRyYW5zaXRpbmcoKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZXNbdGFyZ2V0XTtcbiAgICAgICAgICAgIHZhciBzdHlsZVNoYXBlUmVnID0gLyRbc3R5bGV8c2hhcGVdXFwuLztcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgLy8gQW5pbWF0aW9uIOWOu+mHjVxuICAgICAgICAgICAgdmFyIHByb3BQYXRoTWFwID0ge307XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgc2VsZi5fc3RvcFRyYW5zaXRpb24oKTtcblxuICAgICAgICAgICAgICAgIHZhciBlbCA9IHNlbGYuX2VsO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnRyYW5zaXRpb24gJiYgZWwgJiYgZWwuX196cikgey8vIEVsIGNhbiBiZSBhbmltYXRlZFxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNpdGlvbkNmZyA9IHN0YXRlLnRyYW5zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRyYW5zaXRpb25DZmcucHJvcGVydHk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGluZ0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkRvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpbmdDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRTdGF0ZSh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnR5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eVtpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW5pbWF0aW5nIGFsbCB0aGUgcHJvcGVydGllcyBpbiBzdHlsZSBvciBzaGFwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BOYW1lID09PSAnc3R5bGUnIHx8IHByb3BOYW1lID09PSAnc2hhcGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3RhdGVbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlW3Byb3BOYW1lXS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHByb3BOYW1lICsgJy4nICsga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BQYXRoTWFwW3BhdGhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wUGF0aE1hcFtwYXRoXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpbmdDb3VudCArPSBzZWxmLl9hbmltUHJvcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSwgcHJvcE5hbWUsIGtleSwgdHJhbnNpdGlvbkNmZywgYW5pbWF0aW9uRG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wUGF0aE1hcFtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BQYXRoTWFwW3Byb3BOYW1lXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW5pbWF0aW5nIHBhcnRpY3VsYXIgcHJvcGVydHkgaW4gc3R5bGUgb3Igc3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcE5hbWUubWF0Y2goc3R5bGVTaGFwZVJlZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlICdzdHlsZS4nLCAnc2hhcGUuJyBwcmVmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YlByb3AgPSBwcm9wTmFtZS5zbGljZSgwLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUgPSBwcm9wTmFtZS5zbGljZSg2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW5nQ291bnQgKz0gc2VsZi5fYW5pbVByb3AoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSwgc3ViUHJvcCwgcHJvcE5hbWUsIHRyYW5zaXRpb25DZmcsIGFuaW1hdGlvbkRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGluZ0NvdW50ICs9IHNlbGYuX2FuaW1Qcm9wKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUsICcnLCBwcm9wTmFtZSwgdHJhbnNpdGlvbkNmZywgYW5pbWF0aW9uRG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHRyYW5zaXRpb24gcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0U3RhdGUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldFN0YXRlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1YlN0YXRlcyA9IHNlbGYuX3N1YlN0YXRlcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ViU3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3ViU3RhdGVzLnRyYW5zaXRpb25TdGF0ZSh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEbyB0cmFuc2l0aW9uIGFuaW1hdGlvbiBvZiBwYXJ0aWN1bGFyIHByb3BlcnR5XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViUHJvcEtleVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2l0aW9uQ2ZnXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9hbmltUHJvcDogZnVuY3Rpb24gKHN0YXRlLCBzdWJQcm9wS2V5LCBrZXksIHRyYW5zaXRpb25DZmcsIGRvbmUpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuX2VsO1xuICAgICAgICAgICAgdmFyIHN0YXRlT2JqID0gc3ViUHJvcEtleSA/IHN0YXRlW3N1YlByb3BLZXldIDogc3RhdGU7XG4gICAgICAgICAgICB2YXIgZWxPYmogPSBzdWJQcm9wS2V5ID8gZWxbc3ViUHJvcEtleV0gOiBlbDtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVQcm9wID0gc3RhdGVPYmogJiYgKGtleSBpbiBzdGF0ZU9iailcbiAgICAgICAgICAgICAgICAmJiBlbE9iaiAmJiAoa2V5IGluIGVsT2JqKTtcblxuICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25BbmltYXRvcnMgPSB0aGlzLl90cmFuc2l0aW9uQW5pbWF0b3JzO1xuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZVByb3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlT2JqW2tleV0gPT09IGVsT2JqW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9ialtrZXldID0gc3RhdGVPYmpba2V5XTtcblxuICAgICAgICAgICAgICAgIHZhciBhbmltYXRvciA9IGVsLmFuaW1hdGUoc3ViUHJvcEtleSlcbiAgICAgICAgICAgICAgICAgICAgLndoZW4odHJhbnNpdGlvbkNmZy5kdXJhdGlvbiwgb2JqKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkodHJhbnNpdGlvbkNmZy5kZWFseSlcbiAgICAgICAgICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IHpyVXRpbC5pbmRleE9mKHRyYW5zaXRpb25BbmltYXRvcnMsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uQW5pbWF0b3JzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuc3RhcnQodHJhbnNpdGlvbkNmZy5lYXNpbmcpO1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25BbmltYXRvcnMucHVzaChhbmltYXRvcik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zdG9wVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25BbmltYXRvcnMgPSB0aGlzLl90cmFuc2l0aW9uQW5pbWF0b3JzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2l0aW9uQW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbkFuaW1hdG9yc1tpXS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2l0aW9uQW5pbWF0b3JzLmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNpdGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25BbmltYXRvcnMubGVuZ3RoID4gMDtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRTdWJTdGF0ZXM6IGZ1bmN0aW9uIChzdGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YlN0YXRlcy5wdXNoKHN0YXRlcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlU3ViU3RhdGVzOiBmdW5jdGlvbiAoc3RhdGVzKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0genJVdGlsLmluZGV4T2YodGhpcy5fc3ViU3RhdGVzLCBzdGF0ZXMpO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3ViU3RhdGVzLnNwbGljZShzdGF0ZXMsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR3JhcGhpY1N0YXRlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvZ3JhcGhpYy9TdGF0ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzJyk7XHJcbiAgICBmdW5jdGlvbiBNaW5pbWFwKGJpZ0NhbnZhcyxncm91cFBvc2l0aW9uLCBncm91cCxlYWdsZUV5ZU5vZGUsZGlzdGFuY2UsaW1nU3JjKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYmlnQ2FudmFzID0gYmlnQ2FudmFzO1xyXG4gICAgICAgIHRoaXMuZWFnbGVFeWVOb2RlID0gZWFnbGVFeWVOb2RlO1xyXG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICB0aGlzLmltZ1NyYyA9IGltZ1NyYztcclxuICAgICAgICB0aGlzLnJhdGlvO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBSYXRpbztcclxuICAgICAgICB0aGlzLmdyb3VwID0gZ3JvdXA7XHJcbiAgICAgICAgdGhpcy5pbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdGhpcy5ncm91cFBvc2l0aW9uID0genJVdGlsLmNsb25lKGdyb3VwUG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0UG9zaXRpb24gPSBbMCwwXTtcclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIE1pbmltYXAucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGF0LnJhdGlvID0gMC4xMjtcclxuICAgICAgICB2YXIgZWFnbGVFeWVOb2RlV2lkdGggPSB0aGF0Lmdyb3VwLndpZHRoICAqIHRoYXQucmF0aW87XHJcbiAgICAgICAgdmFyIGVhZ2xlRXllTm9kZUhlaWdodCA9IHRoYXQuZ3JvdXAuaGVpZ2h0ICAqIHRoYXQucmF0aW87XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUud2lkdGggPSBlYWdsZUV5ZU5vZGVXaWR0aCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUuaGVpZ2h0ID0gZWFnbGVFeWVOb2RlSGVpZ2h0K1wicHhcIjtcclxuICAgICAgICB0aGF0LmVhZ2xlRXllTm9kZS5zdHlsZS5tYXJnaW5Ub3AgPSAtZWFnbGVFeWVOb2RlSGVpZ2h0K1wicHhcIjtcclxuICAgICAgICB0aGF0LmVhZ2xlRXllTm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gdGhhdC5iaWdDYW52YXMuZ2V0V2lkdGgoKS1lYWdsZUV5ZU5vZGVXaWR0aCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUucG9zaXRpb249XCJyZWxhdGl2ZVwiO1xyXG4gICAgICAgIHRoYXQuZWFnbGVFeWVOb2RlLnN0eWxlLmJhY2tncm91bmQgPSBcInVybChcIit0aGF0LmltZ1NyYytcIikgbm8tcmVwZWF0XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUuYmFja2dyb3VuZFNpemUgPSBlYWdsZUV5ZU5vZGVXaWR0aC8odGhhdC5ncm91cC53aWR0aCp0aGF0LmRpc3RhbmNlWzJdL3RoYXQuYmlnQ2FudmFzLmdldFdpZHRoKCkpK1wicHhcIjtcclxuICAgICAgICB0aGF0LmJhY2tncm91bmRTaXplID0genJVdGlsLmNsb25lKHRoYXQuZWFnbGVFeWVOb2RlLnN0eWxlLmJhY2tncm91bmRTaXplKTtcclxuICAgICAgICB0aGF0LmVhZ2xlRXllTm9kZS5pbm5lckhUTUwgPSBcIlwiO1xyXG4gICAgICAgIHRoYXQuc2VsZWN0aW9uLnN0eWxlLmJvcmRlciA9IFwiMXB4IHNvbGlkICNmZjAwMDBcIjtcclxuICAgICAgICB0aGF0LnNlbGVjdGlvbi5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcclxuICAgICAgICB0aGF0LnNlbGVjdGlvbi5zdHlsZS53aWR0aCA9IHRoYXQuYmlnQ2FudmFzLmdldFdpZHRoKCkvdGhhdC5ncm91cC53aWR0aCplYWdsZUV5ZU5vZGVXaWR0aCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5zZWxlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gdGhhdC5iaWdDYW52YXMuZ2V0SGVpZ2h0KCkvdGhhdC5ncm91cC5oZWlnaHQqZWFnbGVFeWVOb2RlSGVpZ2h0K1wicHhcIjtcclxuICAgICAgICB0aGF0LnNlbGVjdFdpZHRoID0gdGhhdC5zZWxlY3Rpb24uc3R5bGUud2lkdGg7XHJcbiAgICAgICAgdGhhdC5zZWxlY3RIZWlnaHQgPSB0aGF0LnNlbGVjdGlvbi5zdHlsZS5oZWlnaHQ7XHJcbiAgICAgICAgdGhhdC5zZWxlY3Rpb24uc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiO1xyXG4gICAgICAgIHRoYXQuc2VsZWN0aW9uLnN0eWxlLnRvcCA9IDArXCJweFwiO1xyXG4gICAgICAgIHRoYXQuc2VsZWN0aW9uLnN0eWxlLmxlZnQgPSAwK1wicHhcIjtcclxuICAgICAgICB0aGF0LmVhZ2xlRXllTm9kZS5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdGlvbik7XHJcbiAgICB9O1xyXG4gICAgTWluaW1hcC5wcm90b3R5cGUudXBkYXRhU2VsZWN0aW9uID0gZnVuY3Rpb24ob2ZmZWN0TGVmdCxvZmZlY3RUb3Asem9vbVNjYWxlLG5vd1pvb20pe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGF0Lnpvb21TY2FsZSA9IHpvb21TY2FsZTtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zdHlsZS53aWR0aCA9IHRoaXMuc2VsZWN0aW9uLnN0eWxlLndpZHRoLnJlcGxhY2UoXCJweFwiLFwiXCIpL3pvb21TY2FsZStcInB4XCI7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc3R5bGUuaGVpZ2h0ID0gdGhpcy5zZWxlY3Rpb24uc3R5bGUuaGVpZ2h0LnJlcGxhY2UoXCJweFwiLFwiXCIpL3pvb21TY2FsZStcInB4XCI7XHJcbiAgICAgICAgdGhhdC5zZWxlY3RQb3NpdGlvblswXSA9IHpyVXRpbC5jbG9uZShvZmZlY3RMZWZ0KSp0aGF0LnJhdGlvL25vd1pvb207XHJcbiAgICAgICAgdGhhdC5zZWxlY3RQb3NpdGlvblsxXSA9IHpyVXRpbC5jbG9uZShvZmZlY3RUb3ApKnRoYXQucmF0aW8vbm93Wm9vbTtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zdHlsZS5sZWZ0ID0gLXRoYXQuc2VsZWN0UG9zaXRpb25bMF0rXCJweFwiO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnN0eWxlLnRvcCA9IC10aGF0LnNlbGVjdFBvc2l0aW9uWzFdK1wicHhcIjtcclxuICAgIH07XHJcbiAgICBNaW5pbWFwLnByb3RvdHlwZS51cGRhdGFNYXAgPSBmdW5jdGlvbihpbWdTcmMsbmV3R3JvdXApe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGF0LmVhZ2xlRXllTm9kZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBcInVybChcIitpbWdTcmMrXCIpXCI7XHJcbiAgICAgICAgdmFyIGVhZ2xlRXllTm9kZVdpZHRoID0gbmV3R3JvdXAud2lkdGggICogdGhhdC5yYXRpbztcclxuICAgICAgICB2YXIgZWFnbGVFeWVOb2RlSGVpZ2h0ID0gbmV3R3JvdXAuaGVpZ2h0ICAqIHRoYXQucmF0aW87XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUud2lkdGggPSBlYWdsZUV5ZU5vZGVXaWR0aCtcInB4XCI7XHJcbiAgICAgICAgdGhhdC5lYWdsZUV5ZU5vZGUuc3R5bGUuaGVpZ2h0ID0gZWFnbGVFeWVOb2RlSGVpZ2h0K1wicHhcIjtcclxuICAgICAgICB0aGF0LmVhZ2xlRXllTm9kZS5zdHlsZS5tYXJnaW5Ub3AgPSAtZWFnbGVFeWVOb2RlSGVpZ2h0K1wicHhcIjtcclxuICAgICAgICB0aGF0LmVhZ2xlRXllTm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gdGhhdC5iaWdDYW52YXMuZ2V0V2lkdGgoKS1lYWdsZUV5ZU5vZGVXaWR0aCtcInB4XCI7XHJcbiAgICB9O1xyXG4gICAgTWluaW1hcC5wcm90b3R5cGUudXBkYXRhU2VsZWN0aW9uUG9zaXRpb24gPSBmdW5jdGlvbihub3dHcm91cFBvc2l0aW9uLG5vd1pvb20pe1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGF0LnNlbGVjdFBvc2l0aW9uWzBdID0genJVdGlsLmNsb25lKG5vd0dyb3VwUG9zaXRpb25bMF0pKnRoYXQucmF0aW8vbm93Wm9vbTtcclxuICAgICAgICB0aGF0LnNlbGVjdFBvc2l0aW9uWzFdID0genJVdGlsLmNsb25lKG5vd0dyb3VwUG9zaXRpb25bMV0pKnRoYXQucmF0aW8vbm93Wm9vbTtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zdHlsZS5sZWZ0ID0gLXRoYXQuc2VsZWN0UG9zaXRpb25bMF0rXCJweFwiO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnN0eWxlLnRvcCA9IC10aGF0LnNlbGVjdFBvc2l0aW9uWzFdK1wicHhcIjtcclxuICAgIH07XHJcbiAgICBNaW5pbWFwLnByb3RvdHlwZS51cGRhdGFHcm91cFBvc2l0aW9uID0gZnVuY3Rpb24oZ3JvdXAsbm93Wm9vbSl7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwb3NpdGlvblggPSAtTnVtYmVyKHRoYXQuc2VsZWN0aW9uLnN0eWxlLmxlZnQuc3Vic3RyaW5nKDAsdGhhdC5zZWxlY3Rpb24uc3R5bGUubGVmdC5sZW5ndGgtMikpL3RoYXQucmF0aW8qbm93Wm9vbTtcclxuICAgICAgICB2YXIgcG9zaXRpb25ZID0gLU51bWJlcih0aGF0LnNlbGVjdGlvbi5zdHlsZS50b3Auc3Vic3RyaW5nKDAsdGhhdC5zZWxlY3Rpb24uc3R5bGUudG9wLmxlbmd0aC0yKSkvdGhhdC5yYXRpbypub3dab29tO1xyXG4gICAgICAgIGdyb3VwLmF0dHIoXCJwb3NpdGlvblwiLFtwb3NpdGlvblgscG9zaXRpb25ZXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gTWluaW1hcDtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9taW5pbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5bel5YW35pa55rOV57G7XHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIFBvaW50ID0gcmVxdWlyZShcIi4vUG9pbnQuanNcIik7XHJcbiAgICB2YXIgTGluZSA9IHJlcXVpcmUoXCIuL0xpbmVTdHJ1Y3QuanNcIik7XHJcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIC8qKlxyXG4gICAgICog5p6E6YCg57G757un5om/5YWz57O7XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xhenog5rqQ57G7XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlQ2xhenog5Z+657G7XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGluaGVyaXRzKGNsYXp6LCBiYXNlQ2xhenopIHtcclxuICAgICAgICB2YXIgY2xhenpQcm90b3R5cGUgPSBjbGF6ei5wcm90b3R5cGU7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxyXG4gICAgICAgIEYucHJvdG90eXBlID0gYmFzZUNsYXp6LnByb3RvdHlwZTtcclxuICAgICAgICBjbGF6ei5wcm90b3R5cGUgPSBuZXcgRigpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGNsYXp6UHJvdG90eXBlKSB7XHJcbiAgICAgICAgICAgIGNsYXp6LnByb3RvdHlwZVtwcm9wXSA9IGNsYXp6UHJvdG90eXBlW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGF6ei5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjbGF6ejtcclxuICAgICAgICBjbGF6ei5zdXBlckNsYXNzID0gYmFzZUNsYXp6O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFVVSUQoKSB7XHJcbiAgICAgICAgdmFyIGNoYXJzID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6Jy5zcGxpdCgnJyksXHJcbiAgICAgICAgICAgIHV1aWQgPSBuZXcgQXJyYXkoMzYpLFxyXG4gICAgICAgICAgICBybmQgPSAwLFxyXG4gICAgICAgICAgICByO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzY7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA9PSA4IHx8IGkgPT0gMTMgfHwgaSA9PSAxOCB8fCBpID09IDIzKSB7XHJcbiAgICAgICAgICAgICAgICB1dWlkW2ldID0gJy0nO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT0gMTQpIHtcclxuICAgICAgICAgICAgICAgIHV1aWRbaV0gPSAnNCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocm5kIDw9IDB4MDIpIHJuZCA9IDB4MjAwMDAwMCArIChNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwKSB8IDA7XHJcbiAgICAgICAgICAgICAgICByID0gcm5kICYgMHhmO1xyXG4gICAgICAgICAgICAgICAgcm5kID0gcm5kID4+IDQ7XHJcbiAgICAgICAgICAgICAgICB1dWlkW2ldID0gY2hhcnNbKGkgPT0gMTkpID8gKHIgJiAweDMpIHwgMHg4IDogcl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwic2lkLVwiICsgdXVpZC5qb2luKCcnKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorqHnrpfkuKTngrnkuYvpl7TnmoTot53nprtcclxuICAgICAqQHBhcmFtIHtQb2ludH0gcDEgLSBmaXJzdCB7UG9pbnR9XHJcbiAgICAgKkBwYXJhbSB7UG9pbnR9IHAyIC0gc2Vjb25kIHtQb2ludH1cclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRob3NlIDIgcG9pbnRzLiBJdCBpcyBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBkaXN0YW5jZShwMSwgcDIpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHAxLnggLSBwMi54LCAyKSArIE1hdGgucG93KHAxLnkgLSBwMi55LCAyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDov5Tlm57kuIDmnaHmipjnur8g5pyA6ZW/55qE5Lik5Liq54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHBvaW50cyBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldE1heExpbmVMZW5ndGgocG9pbnRzKSB7XHJcbiAgICAgICAgdmFyIG0gPSBkaXN0YW5jZShwb2ludHNbMF0sIHBvaW50c1sxXSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtwb2ludHNbMF0sIHBvaW50c1sxXV07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAobSA8IGRpc3RhbmNlKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSkpIHtcclxuICAgICAgICAgICAgICAgIG0gPSBkaXN0YW5jZShwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbcG9pbnRzW2ldLCBwb2ludHNbaSArIDFdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipSZXR1cm5zIHRoZSBsZW5ndGggb2YgYSBQb2x5bGluZSB0aGF0IHdvdWxkIGJlIGNyZWF0ZWQgd2l0aCBhIHNldCBvZiBwb2ludHNcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIGFuIHtBcnJheX0gb2Yge1BvaW50c31cclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIGEgcG9zaXRpdmUgbnVtYmVyIGVxdWFsIHdpdGggdG90YWwgbGVuZ3RoKi9cclxuICAgIGZ1bmN0aW9uIGdldFBvbHlsaW5lTGVuZ3RoKHYpIHtcclxuICAgICAgICB2YXIgbCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBsICs9IGRpc3RhbmNlKHZbaV0sIHZbaSArIDFdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBsO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipSZXR1cm5zIHRoZSBtYXggb2YgYSB2ZWN0b3JcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIHZlY3RvciBvZiB7TnVtYmVyfXNcclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIHRoZSBtYXhpbXVtIG51bWJlciBmcm9tIHRoZSB2ZWN0b3Igb3IgTmFOIGlmIHZlY3RvciBpcyBlbXB0eVxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gbWF4KHYpIHtcclxuICAgICAgICBpZiAodi5sZW5naHQgPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBtID0gdlswXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobSA8IHZbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtID0gdltpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipSZXR1cm5zIHRoZSBtaW4gb2YgYSB2ZWN0b3JcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIHZlY3RvciBvZiB7TnVtYmVyfXNcclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIHRoZSBtaW5pbXVtIG51bWJlciBmcm9tIHRoZSB2ZWN0b3Igb3IgTmFOIGlmIHZlY3RvciBpcyBlbXB0eVxyXG4gICAgICpAYXV0aG9yIGFsZXhAc2NyaXB0b2lkLmNvbVxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gbWluKHYpIHtcclxuICAgICAgICBpZiAodi5sZW5naHQgPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBtID0gdlswXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobSA+IHZbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtID0gdltpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yik5patIOeCueaVsOe7hCDmmK/lkKbmraPkuqTnm7Tnur/ot6/lvoRcclxuICAgICAqVGVzdHMgaWYgYSB2ZWN0b3Igb2YgcG9pbnRzIGlzIGFuIG9ydGhvZ29uYWwgcGF0aCAobW92aW5nIGluIG11bHRpcGxlcyBvZiA5MCBkZWdyZWVzKVxyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gYW4ge0FycmF5fSBvZiB7UG9pbnR9c1xyXG4gICAgICpAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgcGF0aCBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBvcnRob2dvbmFsUGF0aCh2KSB7XHJcbiAgICAgICAgaWYgKHYubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh2W2ldLnggIT0gdltpICsgMV0ueCAmJiB2W2ldLnkgIT0gdltpICsgMV0ueSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlRlc3QgdG8gc2VlIGlmIDIge0xpbmV9cyBpbnRlcnNlY3RzLiBUaGV5IGFyZSBjb25zaWRlcmVkIGZpbml0ZSBzZWdtZW50c1xyXG4gICAgICphbmQgbm90IHRoZSBpbmZpbml0ZSBsaW5lcyBmcm9tIGdlb21ldHJ5XHJcbiAgICAgKkBwYXJhbSB7TGluZX0gbDEgLSBmaXN0IGxpbmUvc2VnbWVudFxyXG4gICAgICpAcGFyYW0ge0xpbmV9IGwyIC0gbGFzdCBsaW5lL3NlZ21lbnRcclxuICAgICAqQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSAtIGlmIHRoZSBsaW5lcyBpbnRlcnNlY3Qgb3IgZmFsc2UgaWYgbm90XHJcbiAgICAgKiovXHJcbiAgICBmdW5jdGlvbiBsaW5lSW50ZXJzZWN0c0xpbmUobDEsIGwyKSB7XHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIHR3byB2ZXJ0aWNhbCBsaW5lc1xyXG4gICAgICAgIGlmIChsMS5zdGFydFBvaW50LnggPT0gbDEuZW5kUG9pbnQueCAmJiBsMi5zdGFydFBvaW50LnggPT0gbDIuZW5kUG9pbnQueCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbDEuc3RhcnRQb2ludC54ID09IGwyLnN0YXJ0UG9pbnQueCA/IC8vIGlmICdpbmZpbml0ZSAnbGluZXMgZG8gY29pbmNpZGUsXHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGNoZWNrIHNlZ21lbnQgYm91bmRzIGZvciBvdmVybGFwcGluZ1xyXG4gICAgICAgICAgICAgICAgbDEuY29udGFpbnMobDIuc3RhcnRQb2ludC54LCBsMi5zdGFydFBvaW50LnkpIHx8XHJcbiAgICAgICAgICAgICAgICBsMS5jb250YWlucyhsMi5lbmRQb2ludC54LCBsMi5lbmRQb2ludC55KSA6XHJcbiAgICAgICAgICAgICAgICAvLyBsaW5lcyBhcmUgcGFyYWxlbFxyXG4gICAgICAgICAgICAgICAgZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIG9uZSBsaW5lIGlzIHZlcnRpY2FsLCBhbmQgYW5vdGhlciBsaW5lIGlzIG5vdCB2ZXJ0aWNhbFxyXG4gICAgICAgIGVsc2UgaWYgKGwxLnN0YXJ0UG9pbnQueCA9PSBsMS5lbmRQb2ludC54IHx8IGwyLnN0YXJ0UG9pbnQueCA9PSBsMi5lbmRQb2ludC54KSB7XHJcbiAgICAgICAgICAgIC8vIGxldCBhc3N1bWUgbDIgaXMgdmVydGljYWwsIG90aGVyd2lzZSBleGNoYW5nZSB0aGVtXHJcbiAgICAgICAgICAgIGlmIChsMS5zdGFydFBvaW50LnggPT0gbDEuZW5kUG9pbnQueCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGwgPSBsMTtcclxuICAgICAgICAgICAgICAgIGwxID0gbDI7XHJcbiAgICAgICAgICAgICAgICBsMiA9IGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZmluZGluZyBpbnRlcnNlY3Rpb24gb2YgJ2luZmluaXRlJyBsaW5lc1xyXG4gICAgICAgICAgICAvLyBlcXVhdGlvbiBvZiB0aGUgZmlyc3QgbGluZSBpcyB5ID0gYXggKyBiLCBzZWNvbmQ6IHggPSBjXHJcbiAgICAgICAgICAgIHZhciBhID0gKGwxLmVuZFBvaW50LnkgLSBsMS5zdGFydFBvaW50LnkpIC8gKGwxLmVuZFBvaW50LnggLSBsMS5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICB2YXIgYiA9IGwxLnN0YXJ0UG9pbnQueSAtIGEgKiBsMS5zdGFydFBvaW50Lng7XHJcbiAgICAgICAgICAgIHZhciB4MCA9IGwyLnN0YXJ0UG9pbnQueDtcclxuICAgICAgICAgICAgdmFyIHkwID0gYSAqIHgwICsgYjtcclxuICAgICAgICAgICAgcmV0dXJuIGwxLmNvbnRhaW5zKHgwLCB5MCkgJiYgbDIuY29udGFpbnMoeDAsIHkwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIG5vcm1hbCBjYXNlIC0gYm90aCBsaW5lcyBhcmUgbm90IHZlcnRpY2FsXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vbGluZSBlcXVhdGlvbiBpcyA6IHkgPSBhKnggKyBiLCBiID0geSAtIGEgKiB4XHJcbiAgICAgICAgICAgIHZhciBhMSA9IChsMS5lbmRQb2ludC55IC0gbDEuc3RhcnRQb2ludC55KSAvIChsMS5lbmRQb2ludC54IC0gbDEuc3RhcnRQb2ludC54KTtcclxuICAgICAgICAgICAgdmFyIGIxID0gbDEuc3RhcnRQb2ludC55IC0gYTEgKiBsMS5zdGFydFBvaW50Lng7XHJcblxyXG4gICAgICAgICAgICB2YXIgYTIgPSAobDIuZW5kUG9pbnQueSAtIGwyLnN0YXJ0UG9pbnQueSkgLyAobDIuZW5kUG9pbnQueCAtIGwyLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHZhciBiMiA9IGwyLnN0YXJ0UG9pbnQueSAtIGEyICogbDIuc3RhcnRQb2ludC54O1xyXG5cclxuICAgICAgICAgICAgaWYgKGExID09IGEyKSB7IC8vcGFyYWxlbCBsaW5lc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIxID09IGIyID9cclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgY29pbmNpZGUgbGluZXMsIGNoZWNrIGZvciBzZWdtZW50IGJvdW5kcyBvdmVybGFwcGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGwxLmNvbnRhaW5zKGwyLnN0YXJ0UG9pbnQueCwgbDIuc3RhcnRQb2ludC55KSB8fCBsMS5jb250YWlucyhsMi5lbmRQb2ludC54LCBsMi5lbmRQb2ludC55KSA6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGNvaW5jaWRlIHBhcmFsZWwgbGluZXMgaGF2ZSBubyBjaGFuY2UgdG8gaW50ZXJzZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vdXN1YWwgY2FzZSAtIG5vbiBwYXJhbGVsLCB0aGUgJ2luZmluaXRlJyBsaW5lcyBpbnRlcnNlY3RzLi4ud2Ugb25seSBuZWVkIHRvIGtub3cgaWYgaW5zaWRlIHRoZSBzZWdtZW50XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIGlmIG9uZSBvZiB0aGUgbGluZXMgYXJlIHZlcnRpY2FsLCB0aGVuIHgwIGlzIGVxdWFsIHRvIHRoZWlyIHgsXHJcbiAgICAgICAgICAgICAgICAgKiBvdGhlcndpc2U6XHJcbiAgICAgICAgICAgICAgICAgKiB5MSA9IGExICogeCArIGIxXHJcbiAgICAgICAgICAgICAgICAgKiB5MiA9IGEyICogeCArIGIyXHJcbiAgICAgICAgICAgICAgICAgKiA9PiB4MCA9IChiMiAtIGIxKSAvIChhMSAtIGEyKVxyXG4gICAgICAgICAgICAgICAgICogPT4geTAgPSBhMSAqIHgwICsgYjFcclxuICAgICAgICAgICAgICAgICAqKi9cclxuICAgICAgICAgICAgICAgIHgwID0gKGIyIC0gYjEpIC8gKGExIC0gYTIpO1xyXG4gICAgICAgICAgICAgICAgeTAgPSBhMSAqIHgwICsgYjE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbDEuY29udGFpbnMoeDAsIHkwKSAmJiBsMi5jb250YWlucyh4MCwgeTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqVGVzdHMgaWYgYSBhIHBvbHlsaW5lIGRlZmluZWQgYnkgYSBzZXQgb2YgcG9pbnRzIGludGVyc2VjdHMgYSByZWN0YW5nbGVcclxuICAgICAqQHBhcmFtIHtBcnJheX0gcG9pbnRzIC0gYW5kIHtBcnJheX0gb2Yge1BvaW50fXNcclxuICAgICAqQHBhcmFtIHtBcnJheX0gYm91bmRzIC0gdGhlIGJvdW5kcyBvZiB0aGUgcmVjdGFuZ2xlIGRlZmluZWQgYnkgKHgxLCB5MSwgeDIsIHkyKVxyXG4gICAgICpAcGFyYW0ge0Jvb2xlYW59IGNsb3NlZFBvbHlsaW5lIC0gaW5jYXNlIHBvbHlsaW5lIGlzIGNsb3NlZCBmaWd1cmUgdGhlbiB0cnVlLCBlbHNlIGZhbHNlXHJcbiAgICAgKlxyXG4gICAgICpAcmV0dXJuIHRydWUgLSBpZiBsaW5lIGludGVyc2VjdHMgdGhlIHJlY3RhbmdsZSwgZmFsc2UgLSBpZiBub3RcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIHBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZShwb2ludHMsIGJvdW5kcywgY2xvc2VkUG9seWxpbmUpIHtcclxuXHJcblxyXG4gICAgICAgIC8vZ2V0IHRoZSA0IGxpbmVzL3NlZ21lbnRzIHJlcHJlc2VudGVkIGJ5IHRoZSBib3VuZHNcclxuICAgICAgICB2YXIgbGluZXMgPSBbXTtcclxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1sxXSksIG5ldyBQb2ludChib3VuZHNbMl0sIGJvdW5kc1sxXSkpKTtcclxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChib3VuZHNbMl0sIGJvdW5kc1sxXSksIG5ldyBQb2ludChib3VuZHNbMl0sIGJvdW5kc1szXSkpKTtcclxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChib3VuZHNbMl0sIGJvdW5kc1szXSksIG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1szXSkpKTtcclxuICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1szXSksIG5ldyBQb2ludChib3VuZHNbMF0sIGJvdW5kc1sxXSkpKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBwb2ludHMubGVuZ3RoIC0gMTsgaysrKSB7XHJcbiAgICAgICAgICAgIC8vY3JlYXRlIGEgbGluZSBvdXQgb2YgZWFjaCAyIGNvbnNlY3V0aXZlIHBvaW50c1xyXG4gICAgICAgICAgICB2YXIgdGVtcExpbmUgPSBuZXcgTGluZShwb2ludHNba10sIHBvaW50c1trICsgMV0pO1xyXG5cclxuICAgICAgICAgICAgLy9zZWUgaWYgdGhhdCBsaW5lIGludGVyc2VjdCBhbnkgb2YgdGhlIGxpbmUgb24gYm91bmRzIGJvcmRlclxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZUludGVyc2VjdHNMaW5lKHRlbXBMaW5lLCBsaW5lc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jaGVjayB0aGUgY2xvc2VkIGZpZ3VyZSAtIHRoYXQgaXMgbGFzdCBwb2ludCBjb25uZWN0ZWQgdG8gdGhlIGZpcnN0XHJcbiAgICAgICAgaWYgKGNsb3NlZFBvbHlsaW5lKSB7XHJcbiAgICAgICAgICAgIC8vY3JlYXRlIGEgbGluZSBvdXQgb2YgZWFjaCAyIGNvbnNlY3V0aXZlIHBvaW50c1xyXG4gICAgICAgICAgICB2YXIgdGVtcExpbmUxID0gbmV3IExpbmUocG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSwgcG9pbnRzWzBdKTtcclxuXHJcbiAgICAgICAgICAgIC8vc2VlIGlmIHRoYXQgbGluZSBpbnRlcnNlY3QgYW55IG9mIHRoZSBsaW5lIG9uIGJvdW5kcyBib3JkZXJcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVJbnRlcnNlY3RzTGluZSh0ZW1wTGluZTEsIGxpbmVzW2pdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorqHnrpfot6/lvoTnmoTliIbmlbBcclxuICAgICAqIFNjb3JlIGEgb3J0b2dvbmFsIHBhdGggbWFkZSBvdXQgb2YgUG9pbnRzXHJcbiAgICAgKkl0ZXJhdGVzIG92ZXIgYSBzZXQgb2YgcG9pbnRzIChtaW5pbXVtIDMpXHJcbiAgICAgKkZvciBlYWNoIDMgcG9pbnRzIChpLCBpKzEsIGkrMikgOlxyXG4gICAgICogIC0gaWYgdGhlIDNyZCBvbmUgaXMgYWZ0ZXIgdGhlIDJuZCBvbiB0aGUgc2FtZSBsaW5lIHdlIGFkZCArMVxyXG4gICAgICogIC0gaWYgdGhlIDNyZCBpcyB1cCBvciBkb3duIHJlbGF0ZWQgdG8gdGhlIDJuZCB3ZSBkbyBub3QgZG8gYW55dGhpbmcgKzBcclxuICAgICAqICAtIGlmIHRoZSAzcmQgZ29lcyBiYWNrIHdlIGltZWRpYXRlbGx5IHJldHVybiAtMVxyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gYW4gYXJyYXkgb2Yge1BvaW50fXNcclxuICAgICAqQHJldHVybiB7TnVtYmVyfSAtIC0xIGlmIHRoZSBwYXRoIGlzIHdyb25nIChnb2VzIGJhY2spIG9yIHNvbWV0aGluZyA+PSAwIGlmIGlzIGZpbmVcclxuICAgICAqICBUaGUgYmlnZ2VyIHRoZSBudW1iZXIgdGhlIHNtb290aCB0aGUgcGF0aCBpc1xyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gc2NvcmVQYXRoKHYpIHtcclxuICAgICAgICBpZiAodi5sZW5ndGggPD0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2NvcmUgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdi5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHZbaSAtIDFdLnggPT0gdltpXS54ICYmIHZbaV0ueCA9PSB2W2kgKyAxXS54KSB7IC8vb24gdGhlIHNhbWUgdmVydGljYWxcclxuICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueSAtIHZbaV0ueSkgPT0gc2lnbnVtKHZbaV0ueSAtIHZbaSAtIDFdLnkpKSB7IC8vc2FtZSBkaXJlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBzY29yZSsrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9nb2luZyBiYWNrIC0gbm8gZ29vZFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2W2kgLSAxXS55ID09IHZbaV0ueSAmJiB2W2ldLnkgPT0gdltpICsgMV0ueSkgeyAvL29uIHRoZSBzYW1lIGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueCAtIHZbaV0ueCkgPT0gc2lnbnVtKHZbaV0ueCAtIHZbaSAtIDFdLngpKSB7IC8vc2FtZSBkaXJlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBzY29yZSsrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9nb2luZyBiYWNrIC0gbm8gZ29vZFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHsgLy9ub3Qgb24gc2FtZSB2ZXJ0aWNhbCBub3IgaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAgICAgc2NvcmUtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNjb3JlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6L+U5Zue5pWw5a2X56ym5Y+377yIKyAtKVxyXG4gICAgICogUmV0dXJucyB0aGUgc2lnbiBvZiBhIG51bWJlclxyXG4gICAgICpAcGFyYW0ge051bWJlcn0geCAtIHRoZSBudW1iZXJcclxuICAgICAqQHJldHVybnMge051bWJlcn1cclxuICAgICAqQHNlZSA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaWduX2Z1bmN0aW9uXCI+aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaWduX2Z1bmN0aW9uPC9hPlxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gc2lnbnVtKHgpIHtcclxuICAgICAgICBpZiAoeCA+IDApXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIGVsc2UgaWYgKHggPCAwKVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIpOaWrSDngrnmlbDnu4Qg5piv5LiN5piv5pyJ5pWI6Lev5b6E77yI5rKh5pyJ5Zue6Lev77yJXHJcbiAgICAgKlRlc3RzIGlmIGEgdmVjdG9yIG9mIHBvaW50cyBpcyBhIHZhbGlkIHBhdGggKG5vdCBnb2luZyBiYWNrKVxyXG4gICAgICpUaGVyZSBhcmUgYSBmZXcgcHJvYmxlbXMgaGVyZS4gSWYgeW91IGhhdmUgcDEsIHAyLCBwMyBhbmQgcDQgYW5kIHAyID0gcDMgeW91IG5lZWQgdG8gaWdub3JlIHRoYXRcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIGFuIHtBcnJheX0gb2Yge1BvaW50fXNcclxuICAgICAqQHJldHVybiB7Qm9vbGVhbn0gLSB0cnVlIGlmIHBhdGggaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gZm9yd2FyZFBhdGgodikge1xyXG4gICAgICAgIGlmICh2Lmxlbmd0aCA8PSAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aCAtIDI7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodltpXS54ID09IHZbaSArIDFdLnggJiYgdltpICsgMV0ueCA9PSB2W2kgKyAyXS54KSB7IC8vb24gdGhlIHNhbWUgdmVydGljYWxcclxuICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueSAtIHZbaV0ueSkgIT0gMCkgeyAvL3Rlc3Qgb25seSB3ZSBoYXZlIGEgcHJvZ3Jlc3NpbmcgcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWdudW0odltpICsgMV0ueSAtIHZbaV0ueSkgPT0gLTEgKiBzaWdudW0odltpICsgMl0ueSAtIHZbaSArIDFdLnkpKSB7IC8vZ29pbmcgYmFjayAoaWdub3JlIHplcm8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodltpXS55ID09IHZbaSArIDFdLnkgJiYgdltpICsgMV0ueSA9PSB2W2kgKyAyXS55KSB7IC8vb24gdGhlIHNhbWUgaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICAgICAgaWYgKHNpZ251bSh2W2kgKyAxXS54IC0gdltpXS54KSAhPSAwKSB7IC8vdGVzdCBvbmx5IHdlIGhhdmUgYSBwcm9ncmVzc2luZyBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ251bSh2W2kgKyAxXS54IC0gdltpXS54KSA9PSAtMSAqIHNpZ251bSh2W2kgKyAyXS54IC0gdltpICsgMV0ueCkpIHsgLy9nb2luZyBiYWNrIChpZ25vcmUgemVybylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlsIZbeDowLHk6MF3ovazljJbkuLpbMCwgMF0gIOe7mXpyZW5kZXLkvb/nlKhcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcG9pbnRzIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gaXNSZXZlcnQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0cmFzbGF0ZVBvaW50cyhwb2ludHMsIGlzUmV2ZXJ0KSB7XHJcbiAgICAgICAgdmFyIG5ld1BvaW50cyA9IFtdO1xyXG4gICAgICAgIGlmIChpc1JldmVydCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2gobmV3IFBvaW50KHBvaW50WzBdLCBwb2ludFsxXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdQb2ludHM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2ludHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb2ludDEgPSBwb2ludHNbal07XHJcbiAgICAgICAgICAgICAgICBuZXdQb2ludHMucHVzaChbcG9pbnQxLngsIHBvaW50MS55XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ld1BvaW50cztcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByb3RhdGlvbk1hdHJpeChhbmdsZSkge1xyXG4gICAgICAgIHZhciBtUmV0dXJuID0gW1xyXG4gICAgICAgICAgICBbTWF0aC5jb3MoYW5nbGUpLCAtTWF0aC5zaW4oYW5nbGUpLCAwXSxcclxuICAgICAgICAgICAgW01hdGguc2luKGFuZ2xlKSwgTWF0aC5jb3MoYW5nbGUpLCAwXSxcclxuICAgICAgICAgICAgWzAsIDAsIDFdXHJcbiAgICAgICAgXTtcclxuICAgICAgICByZXR1cm4gbVJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0cmFuc2xhdGlvbk1hdHJpeChkeCwgZHkpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBbMSwgMCwgZHhdLFxyXG4gICAgICAgICAgICBbMCwgMSwgZHldLFxyXG4gICAgICAgICAgICBbMCwgMCwgMV1cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNjYWxlTWF0cml4KHN4LCBzeSkge1xyXG4gICAgICAgIGlmIChzeSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN5ID0gc3g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIFtzeCwgMCwgMF0sXHJcbiAgICAgICAgICAgIFswLCBzeSwgMF0sXHJcbiAgICAgICAgICAgIFswLCAwLCAxXVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEl0IHdpbGwgcmV0dXJuIHRoZSBlbmQgcG9pbnQgb2YgYSBsaW5lIG9uIGEgZ2l2ZW4gYW5nbGUgKGNsb2Nrd2lzZSkuXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBzdGFydFBvaW50IC0gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gdGhlIGxlbmd0aCBvZiB0aGUgbGluZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIC0gdGhlIGFuZ2xlIG9mIHRoZSBsaW5lIGluIHJhZGlhbnNcclxuICAgICAqIEByZXR1cm4ge1BvaW50fSAtIHRoZSBlbmRQb2ludCBvZiB0aGUgbGluZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRFbmRQb2ludChzdGFydFBvaW50LCBsZW5ndGgsIGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIGVuZFBvaW50ID0gc3RhcnRQb2ludC5jbG9uZSgpO1xyXG4gICAgICAgIGVuZFBvaW50LnRyYW5zZm9ybSh0cmFuc2xhdGlvbk1hdHJpeCgtc3RhcnRQb2ludC54LCAtc3RhcnRQb2ludC55KSk7XHJcbiAgICAgICAgZW5kUG9pbnQueSAtPSBsZW5ndGg7XHJcbiAgICAgICAgZW5kUG9pbnQudHJhbnNmb3JtKHJvdGF0aW9uTWF0cml4KGFuZ2xlKSk7XHJcbiAgICAgICAgZW5kUG9pbnQudHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KHN0YXJ0UG9pbnQueCwgc3RhcnRQb2ludC55KSk7XHJcbiAgICAgICAgcmV0dXJuIGVuZFBvaW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W6I635Y+W5Lik5Liq5Zu+5b2i55qE5aSW6Z2i5Zub5Liq6L+e5o6l54K5XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0Q29ubmVjdG9yUG9pbnRzKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsZWZ0OiBuZXcgUG9pbnQobm9kZS54LCBub2RlLnkgKyBub2RlLmhlaWdodCAvIDIpLCAvL+efqeW9oiDlt6bkuK3nmoTkvY3nva5cclxuICAgICAgICAgICAgdG9wOiBuZXcgUG9pbnQobm9kZS54ICsgbm9kZS53aWR0aCAvIDIsIG5vZGUueSksIC8v55+p5b2iIOS4iuS4reeahOS9jee9rlxyXG4gICAgICAgICAgICByaWdodDogbmV3IFBvaW50KG5vZGUueCArIG5vZGUud2lkdGgsIG5vZGUueSArIG5vZGUuaGVpZ2h0IC8gMiksIC8v55+p5b2iIOWPs+S4reeahOS9jee9rlxyXG4gICAgICAgICAgICBib3R0b206IG5ldyBQb2ludChub2RlLnggKyBub2RlLndpZHRoIC8gMiwgbm9kZS55ICsgbm9kZS5oZWlnaHQpLCAvL+efqeW9oiDkuIvkuK3nmoTkvY3nva5cclxuICAgICAgICAgICAgY2VudGVyOiBuZXcgUG9pbnQobm9kZS54ICsgbm9kZS53aWR0aCAvIDIsIG5vZGUueSArIG5vZGUuaGVpZ2h0IC8gMikgLy/kuK3pl7TkvY3nva5cclxuXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluiOt+WPluS4pOS4quWbvuW9oueahOWklumdouWbm+S4qui/nuaOpeeCuVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub2RlIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFNvbHRQb2ludHMobm9kZSkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIC8vdG9wXHJcbiAgICAgICAgICAgIFtNYXRoLnJvdW5kKG5vZGUuZ2V0UmVjdCgpLndpZHRoIC8gMyAvMTApKjEwLCAwIF0sXHJcbiAgICAgICAgICAgIFtNYXRoLnJvdW5kKDIqbm9kZS5nZXRSZWN0KCkud2lkdGggLyAzIC8xMCkqMTAsIDAgXSxcclxuICAgICAgICAgICAgLy9yaWdodFxyXG4gICAgICAgICAgICBbbm9kZS5nZXRSZWN0KCkud2lkdGgsIE1hdGgucm91bmQobm9kZS5nZXRSZWN0KCkuaGVpZ2h0IC8gMyAvMTApKjEwIF0sXHJcbiAgICAgICAgICAgIFtub2RlLmdldFJlY3QoKS53aWR0aCwgTWF0aC5yb3VuZCgyKm5vZGUuZ2V0UmVjdCgpLmhlaWdodCAvIDMgLzEwKSoxMCBdLFxyXG4gICAgICAgICAgICAvL2JvdHRvbVxyXG4gICAgICAgICAgICBbTWF0aC5yb3VuZChub2RlLmdldFJlY3QoKS53aWR0aCAvIDMgLzEwKSoxMCwgbm9kZS5nZXRSZWN0KCkuaGVpZ2h0IF0sXHJcbiAgICAgICAgICAgIFtNYXRoLnJvdW5kKDIqbm9kZS5nZXRSZWN0KCkud2lkdGggLyAzIC8xMCkqMTAsIG5vZGUuZ2V0UmVjdCgpLmhlaWdodCBdLFxyXG4gICAgICAgICAgICAvL2xlZnRcclxuICAgICAgICAgICAgWzAsIE1hdGgucm91bmQobm9kZS5nZXRSZWN0KCkuaGVpZ2h0IC8gMyAvMTApKjEwIF0sXHJcbiAgICAgICAgICAgIFswLCBNYXRoLnJvdW5kKDIqbm9kZS5nZXRSZWN0KCkuaGVpZ2h0IC8gMyAvMTApKjEwIF1cclxuXHJcbiAgICAgICAgXVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6h566XIHAxIHAy5Lik54K55omA6L+e5o6l55qE55u057q/55qE6KeS5bqmXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHAxIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcDIgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRhbmdlbnRSb3RhdGlvbihwMSwgcDIpIHtcclxuICAgICAgICByZXR1cm4gLU1hdGguUEkgLyAyIC0gTWF0aC5hdGFuMihcclxuICAgICAgICAgICAgcDIueSAtIHAxLnksIHAyLnggLSBwMS54XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIpOaWrTPngrnmmK/lkKblnKjkuIDmnaHnm7Tnur/kuIpcclxuICAgICAqIFRlc3RzIGlmIDMgcG9pbnRzIGFyZSBjb2xpbmlhciB3aXRoIG1hdHJpeCBkZXRlcm1pbmFudHMuXHJcbiAgICAgKiBJZiB0aGUgZGV0ZXJtaW5hdCBvZiBtYXRyaXhcclxuICAgICAqIC8gICAgICAgICBcXFxyXG4gICAgICogfCB4MSB5MSAxIHxcclxuICAgICAqIHwgeDIgeTIgMSB8XHJcbiAgICAgKiB8IHgzIHkzIDEgfFxyXG4gICAgICogXFwgICAgICAgICAvXHJcbiAgICAgKiBpcyB6ZXJvIGl0IG1lYW5zIHRoYXQgdGhlIHBvaW50cyBhcmUgY29saW5lYXJcclxuICAgICAqQHBhcmFtIHtQb2ludH0gcDEgLSBmaXJzdCBwb2ludFxyXG4gICAgICpAcGFyYW0ge1BvaW50fSBwMiAtIHNlY29uZCBwb2ludFxyXG4gICAgICpAcGFyYW0ge1BvaW50fSBwMyAtIHRoaXJkIHBvaW50XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzc2lvblxyXG4gICAgICpAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgY29saW5pYXIgYW5kIGZhbHNlIGlmIG5vdFxyXG4gICAgICpAYXV0aG9yIEFsZXhcclxuICAgICAqQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RldGVybWluYW50XHJcbiAgICAgKkBzZWUgaHR0cHM6Ly9wZW9wbGUucmljaGxhbmQuZWR1L2phbWVzL2xlY3R1cmUvbTExNi9tYXRyaWNlcy9hcHBsaWNhdGlvbnMuaHRtbFxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gY29sbGluZWFyaXR5KHAxLCBwMiwgcDMsIHByZWNpc3Npb24pIHtcclxuICAgICAgICB2YXIgZGV0ZXJtaW5hbnQgPSAocDEueCAqIHAyLnkgKyBwMS55ICogcDMueCArIHAyLnggKiBwMy55KSAtIChwMi55ICogcDMueCArIHAxLnkgKiBwMi54ICsgcDEueCAqIHAzLnkpO1xyXG5cclxuICAgICAgICBpZiAocHJlY2lzc2lvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoZGV0ZXJtaW5hbnQpIDw9IHByZWNpc3Npb247XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRldGVybWluYW50ID09PSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDlm5voiI3kupTlhaUg5L+d5a2YZGVjaW1hbHPnmoTlsI/mlbBcclxuICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIGVuaGFuY2VkUm91bmQobnVtYmVyLCBkZWNpbWFscykge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIE1hdGgucG93KDEwLCBkZWNpbWFscykpIC8gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluS4pOeCueS5i+mXtOeahOmVv+W6plxyXG4gICAgICoqL1xyXG4gICAgZnVuY3Rpb24gZ2V0TGVuZ3RoKHN0YXJ0UG9pbnQsIGVuZFBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhzdGFydFBvaW50LnggLSBlbmRQb2ludC54LCAyKSArIE1hdGgucG93KHN0YXJ0UG9pbnQueSAtIGVuZFBvaW50LnksIDIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluinkuW6plxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBjZW50ZXJQb2ludCAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBvdXRzaWRlUG9pbnQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSByb3VuZCAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRBbmdsZShjZW50ZXJQb2ludCwgb3V0c2lkZVBvaW50LCByb3VuZCkge1xyXG4gICAgICAgIGNlbnRlclBvaW50LnggPSBlbmhhbmNlZFJvdW5kKGNlbnRlclBvaW50LngsIDUpO1xyXG4gICAgICAgIGNlbnRlclBvaW50LnkgPSBlbmhhbmNlZFJvdW5kKGNlbnRlclBvaW50LnksIDUpO1xyXG4gICAgICAgIG91dHNpZGVQb2ludC54ID0gZW5oYW5jZWRSb3VuZChvdXRzaWRlUG9pbnQueCwgNSk7XHJcbiAgICAgICAgb3V0c2lkZVBvaW50LnkgPSBlbmhhbmNlZFJvdW5kKG91dHNpZGVQb2ludC55LCA1KTtcclxuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4oKG91dHNpZGVQb2ludC54IC0gY2VudGVyUG9pbnQueCkgLyAob3V0c2lkZVBvaW50LnkgLSBjZW50ZXJQb2ludC55KSk7XHJcbiAgICAgICAgYW5nbGUgPSAtYW5nbGU7XHJcblxyXG4gICAgICAgIC8vZW5kQW5nbGUrPTkwO1xyXG4gICAgICAgIGlmIChvdXRzaWRlUG9pbnQueCA+PSBjZW50ZXJQb2ludC54ICYmIG91dHNpZGVQb2ludC55ID49IGNlbnRlclBvaW50LnkpIHtcclxuICAgICAgICAgICAgYW5nbGUgKz0gTWF0aC5QSTtcclxuICAgICAgICB9IGVsc2UgaWYgKG91dHNpZGVQb2ludC54IDw9IGNlbnRlclBvaW50LnggJiYgb3V0c2lkZVBvaW50LnkgPj0gY2VudGVyUG9pbnQueSkge1xyXG4gICAgICAgICAgICBhbmdsZSArPSBNYXRoLlBJO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3V0c2lkZVBvaW50LnggPD0gY2VudGVyUG9pbnQueCAmJiBvdXRzaWRlUG9pbnQueSA8PSBjZW50ZXJQb2ludC55KSB7XHJcbiAgICAgICAgICAgIGFuZ2xlICs9IE1hdGguUEkgKiAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoYW5nbGUgPj0gTWF0aC5QSSAqIDIpIHtcclxuICAgICAgICAgICAgYW5nbGUgLT0gTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc05hTihhbmdsZSkpIHsgLy9OYW5cclxuICAgICAgICAgICAgYW5nbGUgPSAwOyAvL3dlIGFyZSBhdCBjZW50ZXIgcG9pbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb3VuZCkge1xyXG4gICAgICAgICAgICBhbmdsZSA9IE1hdGgucm91bmQoYW5nbGUgLyByb3VuZCkgKiByb3VuZFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYW5nbGU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UmVjdChub2RlLCBpc0NhbGNQYXJlbnQpIHtcclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAvL+WIm+W7uuacgOWwj+WMheWbtOebkuiZmue6v1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICBwb2ludHNbMF0gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgcG9pbnRzWzFdID0gW2JvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgcG9pbnRzWzJdID0gW2JvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICBwb2ludHNbM10gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICBwb2ludHNbNF0gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcblxyXG4gICAgICAgIHZhciBwb3NpdGlvblggPSBub2RlLnBvc2l0aW9uWzBdO1xyXG4gICAgICAgIHZhciBwb3NpdGlvblkgPSBub2RlLnBvc2l0aW9uWzFdO1xyXG4gICAgICAgIC8v6L+Z6YeM6KaB5b6q546v5Yik5pat5LiA5oqKIOacieayoeacieeItuiKgueCuSDlubbkuJTniLboioLngrnkuI3mmK/moLnoioLngrkg54S25ZCO6L+b6KGM55u45YqgXHJcbiAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiR3JvdXBOb2RlXCIgJiYgaXNDYWxjUGFyZW50KSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uWCA9IHBvc2l0aW9uWCArIG5vZGUucGFyZW50LnBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICBwb3NpdGlvblkgPSBwb3NpdGlvblkgKyBub2RlLnBhcmVudC5wb3NpdGlvblsxXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBib3VuZFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyKHBvc2l0aW9uWCArIGJvdW5kaW5nUmVjdC54KSwgICAvL+azqDog5Zug5LqL5Lu25Li65ZyG5b2iICDmiYDku6UgeCB5IOS4uuWchuW/g+eahOS9jee9riAg5YyF5Zu055+p5b2i6KaB5YeP5Y675a695bqm5LiA5Y2KXHJcbiAgICAgICAgICAgICAgICBOdW1iZXIocG9zaXRpb25ZICsgYm91bmRpbmdSZWN0LnkpLFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyKGJvdW5kaW5nUmVjdC53aWR0aCksXHJcbiAgICAgICAgICAgICAgICBOdW1iZXIoYm91bmRpbmdSZWN0LmhlaWdodClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAvL+S4reW/g+eCuVxyXG4gICAgICAgIHZhciBjeCA9IE51bWJlcihub2RlLnBvc2l0aW9uWzBdKSArIE51bWJlcihib3VuZGluZ1JlY3Qud2lkdGgpIC8gMiArIE51bWJlcihib3VuZGluZ1JlY3QueCk7XHJcbiAgICAgICAgdmFyIGN5ID0gTnVtYmVyKG5vZGUucG9zaXRpb25bMV0pICsgTnVtYmVyKGJvdW5kaW5nUmVjdC5oZWlnaHQpIC8gMiArIE51bWJlcihib3VuZGluZ1JlY3QueSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogTnVtYmVyKGN4KSxcclxuICAgICAgICAgICAgeTogTnVtYmVyKGN5KSxcclxuICAgICAgICAgICAgd2lkdGg6IE51bWJlcihib3VuZGluZ1JlY3Qud2lkdGgpLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IE51bWJlcihib3VuZGluZ1JlY3QuaGVpZ2h0KSxcclxuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgICAgICAgIGJvdW5kaW5nUmVjdDogYm91bmRSZWN0XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgU3RhY2tlZE1hcCA9IHtcclxuICAgICAgICBjcmVhdGVOZXc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyS2V5ID0gdGhpcy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBhcnJLZXkucHVzaCh2YWx1ZSlcclxuXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gc3RhY2tbaV0ua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tbaV0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy/lpoLmnpzmsqHmnInmib7liLDnmoTor53vvIzliJnliJvlu7rkuIDkuKrmlrDnmoTmlbDnu4RcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAga2V5czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChzdGFja1tpXS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0b3A6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gc3RhY2tbaV0ua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNwbGljZShpZHgsIDEpWzBdO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uKGtleSwgaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJLZXkgPSB0aGlzLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHpyVXRpbC5pbmRleE9mKGFycktleSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyS2V5LnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZVRvcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSAxLCAxKVswXTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFjay5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnNwbGljZSgwLCBzdGFjay5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcmFuZG9tQ29sb3IoKSB7XHJcbiAgICAgICAgdmFyIGFyckhleCA9IFtcIjBcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLCBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIl0sXHJcbiAgICAgICAgICAgIHN0ckhleCA9IFwiI1wiLFxyXG4gICAgICAgICAgICBpbmRleDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xyXG4gICAgICAgICAgICBpbmRleCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDE1KTtcclxuICAgICAgICAgICAgc3RySGV4ICs9IGFyckhleFtpbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHJIZXg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbGxpbmVhclJlZHVjdGlvbiAodikge1xyXG4gICAgICAgIHZhciByID0gW107XHJcblxyXG4gICAgICAgIGlmKHYubGVuZ3RoIDwgMyl7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5jbG9uZUFycmF5KHYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgci5wdXNoKCB2WzBdLmNsb25lKCkgKTtcclxuICAgICAgICBmb3IodmFyIGk9MTsgaSA8IHYubGVuZ3RoLTE7IGkrKyl7XHJcbiAgICAgICAgICAgIGlmKCAodltpLTFdLnggPT0gdltpXS54ICYmIHZbaV0ueCA9PSB2W2krMV0ueCkgIHx8ICAodltpLTFdLnkgPT0gdltpXS55ICYmIHZbaV0ueSA9PSB2W2krMV0ueSkgKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgci5wdXNoKCB2W2ldLmNsb25lKCkgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByLnB1c2goIHZbdi5sZW5ndGgtMV0uY2xvbmUoKSApO1xyXG5cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcclxuICAgIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cclxuICAgIHZhciB0ZW1wbGF0ZVNldHRpbmdzID0ge1xyXG4gICAgICAgIGV2YWx1YXRlOiAvPCUoW1xcc1xcU10rPyklPi9nLFxyXG4gICAgICAgIGludGVycG9sYXRlOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcclxuICAgICAgICBlc2NhcGU6IC88JS0oW1xcc1xcU10rPyklPi9nXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cclxuICAgIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcclxuICAgIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxyXG4gICAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XHJcblxyXG4gICAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcclxuICAgIC8vIHN0cmluZyBsaXRlcmFsLlxyXG4gICAgdmFyIGVzY2FwZXMgPSB7XHJcbiAgICAgICAgXCInXCI6IFwiJ1wiLFxyXG4gICAgICAgICdcXFxcJzogJ1xcXFwnLFxyXG4gICAgICAgICdcXHInOiAncicsXHJcbiAgICAgICAgJ1xcbic6ICduJyxcclxuICAgICAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXHJcbiAgICAgICAgJ1xcdTIwMjknOiAndTIwMjknXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xyXG5cclxuICAgIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXHJcbiAgICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXHJcbiAgICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cclxuICAgIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cclxuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xyXG4gICAgICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XHJcbiAgICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcclxuICAgICAgICBzZXR0aW5ncyA9IHpyVXRpbC5kZWZhdWx0cyhzZXR0aW5ncywgdGVtcGxhdGVTZXR0aW5ncywgdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxyXG4gICAgICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcclxuICAgICAgICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXHJcbiAgICAgICAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXHJcbiAgICAgICAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcclxuICAgICAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XHJcblxyXG4gICAgICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXHJcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcclxuICAgICAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVyLCBlc2NhcGVDaGFyKTtcclxuICAgICAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBpZiAoZXNjYXBlKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcclxuXHJcbiAgICAgICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cclxuICAgICAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xyXG5cclxuICAgICAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXHJcbiAgICAgICAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXHJcbiAgICAgICAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsIHNvdXJjZSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cclxuICAgICAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcclxuICAgICAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcclxuXHJcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XHJcbiAgICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAoenJVdGlsLmlzQXJyYXlMaWtlKG9iaikgJiYgKHpyVXRpbC5pc0FycmF5KG9iaikgfHwgenJVdGlsLmlzU3RyaW5nKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIENsYXNzKCkge31cclxuICAgIENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uKHByb3RvKSB7XHJcbiAgICAgICAgdmFyIGJhc2UgPSBmdW5jdGlvbigpIHt9LFxyXG4gICAgICAgICAgICBtZW1iZXIsXHJcbiAgICAgICAgICAgIHRoYXQgPSB0aGlzLFxyXG4gICAgICAgICAgICBzdWJjbGFzcyA9IHByb3RvICYmIHByb3RvLmluaXQgPyBwcm90by5pbml0IDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmbjtcclxuXHJcbiAgICAgICAgYmFzZS5wcm90b3R5cGUgPSB0aGF0LnByb3RvdHlwZTtcclxuICAgICAgICBmbiA9IHN1YmNsYXNzLmZuID0gc3ViY2xhc3MucHJvdG90eXBlID0gbmV3IGJhc2UoKTtcclxuXHJcbiAgICAgICAgZm9yIChtZW1iZXIgaW4gcHJvdG8pIHtcclxuICAgICAgICAgICAgaWYgKHByb3RvW21lbWJlcl0gIT0gbnVsbCAmJiBwcm90b1ttZW1iZXJdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1lcmdlIG9iamVjdCBtZW1iZXJzXHJcbiAgICAgICAgICAgICAgICBmblttZW1iZXJdID0genJVdGlsLm1lcmdlQWxsKFt7fSwgYmFzZS5wcm90b3R5cGVbbWVtYmVyXSwgcHJvdG9bbWVtYmVyXV0sdHJ1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmblttZW1iZXJdID0gcHJvdG9bbWVtYmVyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm4uY29uc3RydWN0b3IgPSBzdWJjbGFzcztcclxuICAgICAgICBzdWJjbGFzcy5leHRlbmQgPSB0aGF0LmV4dGVuZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN1YmNsYXNzO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICBpbmhlcml0czogaW5oZXJpdHMsXHJcbiAgICAgICAgZ2V0VVVJRDogZ2V0VVVJRCxcclxuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXHJcbiAgICAgICAgZ2V0UG9seWxpbmVMZW5ndGg6IGdldFBvbHlsaW5lTGVuZ3RoLFxyXG4gICAgICAgIG1heDogbWF4LFxyXG4gICAgICAgIG1pbjogbWluLFxyXG4gICAgICAgIGlzRW1wdHk6IGlzRW1wdHksXHJcbiAgICAgICAgb3J0aG9nb25hbFBhdGg6IG9ydGhvZ29uYWxQYXRoLFxyXG4gICAgICAgIHBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZTogcG9seWxpbmVJbnRlcnNlY3RzUmVjdGFuZ2xlLFxyXG4gICAgICAgIHNjb3JlUGF0aDogc2NvcmVQYXRoLFxyXG4gICAgICAgIGZvcndhcmRQYXRoOiBmb3J3YXJkUGF0aCxcclxuICAgICAgICB0cmFzbGF0ZVBvaW50czogdHJhc2xhdGVQb2ludHMsXHJcbiAgICAgICAgZ2V0RW5kUG9pbnQ6IGdldEVuZFBvaW50LFxyXG4gICAgICAgIGdldENvbm5lY3RvclBvaW50czogZ2V0Q29ubmVjdG9yUG9pbnRzLFxyXG4gICAgICAgIHRhbmdlbnRSb3RhdGlvbjogdGFuZ2VudFJvdGF0aW9uLFxyXG4gICAgICAgIGNvbGxpbmVhcml0eTogY29sbGluZWFyaXR5LFxyXG4gICAgICAgIHRyYW5zbGF0aW9uTWF0cml4OiB0cmFuc2xhdGlvbk1hdHJpeCxcclxuICAgICAgICBzY2FsZU1hdHJpeDogc2NhbGVNYXRyaXgsXHJcbiAgICAgICAgcm91bmQ6IGVuaGFuY2VkUm91bmQsXHJcbiAgICAgICAgZ2V0TGVuZ3RoOiBnZXRMZW5ndGgsXHJcbiAgICAgICAgZ2V0QW5nbGU6IGdldEFuZ2xlLFxyXG4gICAgICAgIGdldFJlY3Q6IGdldFJlY3QsXHJcbiAgICAgICAgU3RhY2tlZE1hcDogU3RhY2tlZE1hcCxcclxuICAgICAgICBnZXRNYXhMaW5lTGVuZ3RoOiBnZXRNYXhMaW5lTGVuZ3RoLFxyXG4gICAgICAgIHJhbmRvbUNvbG9yOiByYW5kb21Db2xvcixcclxuICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICAgICAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxyXG4gICAgICAgIGdldFNvbHRQb2ludHM6Z2V0U29sdFBvaW50cyxcclxuICAgICAgICBjb2xsaW5lYXJSZWR1Y3Rpb246IGNvbGxpbmVhclJlZHVjdGlvbixcclxuICAgICAgICBDbGFzczpDbGFzc1xyXG4gICAgfTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHJcbiAgICAvKipcclxuICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFBvaW50XHJcbiAgICAgICpcclxuICAgICAgKlxyXG4gICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAqIEB0aGlzIHtQb2ludH1cclxuICAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIG9mIHBvaW50LlxyXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgb2YgcG9pbnQuXHJcbiAgICAgICogTm90ZTogRXZlbiBpZiBpdCBpcyBuYW1lZCBQb2ludCB0aGlzIGNsYXNzIHNob3VsZCBiZSBuYW1lZCBEb3QgYXMgRG90IGlzIGNsb3NlclxyXG4gICAgICAqIHRoZW4gUG9pbnQgZnJvbSBtYXRoIHBlcnNwZWN0aXZlLlxyXG4gICAgICAqKi9cclxuICAgIGZ1bmN0aW9uIFBvaW50KHgsIHkpe1xyXG4gICAgICAgIC8qKlRoZSB4IGNvb3JkaW5hdGUgb2YgcG9pbnQqL1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgICAgIC8qKlRoZSB5IGNvb3JkaW5hdGUgb2YgcG9pbnQqL1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipDcmVhdGVzIGEge1BvaW50fSBvdXQgb2YgSlNPTiBwYXJzZWQgb2JqZWN0XHJcbiAgICAgKkBwYXJhbSB7SlNPTk9iamVjdH0gbyAtIHRoZSBKU09OIHBhcnNlZCBvYmplY3RcclxuICAgICAqQHJldHVybiB7UG9pbnR9IGEgbmV3bHkgY29uc3RydWN0ZWQgUG9pbnRcclxuICAgICAqKi9cclxuICAgIFBvaW50LmxvYWQgPSBmdW5jdGlvbihvKXtcclxuICAgICAgICB2YXIgbmV3UG9pbnQgPSBuZXcgUG9pbnQoTnVtYmVyKG8ueCksIE51bWJlcihvLnkpKTtcclxuICAgICAgICByZXR1cm4gbmV3UG9pbnQ7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipDcmVhdGVzIGFuIGFycmF5IG9mIHBvaW50cyBmcm9tIGFuIGFycmF5IG9mIHtKU09OT2JqZWN0fXNcclxuICAgICAqQHBhcmFtIHtBcnJheX0gdiAtIHRoZSBhcnJheSBvZiBKU09OT2JqZWN0c1xyXG4gICAgICpAcmV0dXJuIGFuIHtBcnJheX0gb2Yge1BvaW50fXNcclxuICAgICAqKi9cclxuICAgIFBvaW50LmxvYWRBcnJheSA9IGZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIHZhciBuZXdQb2ludHMgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTwgdi5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIG5ld1BvaW50cy5wdXNoKFBvaW50LmxvYWQodltpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3UG9pbnRzO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqQ2xvbmVzIGFuIGFycmF5IG9mIHBvaW50c1xyXG4gICAgICpAcGFyYW0ge0FycmF5fSB2IC0gdGhlIGFycmF5IG9mIHtQb2ludH1zXHJcbiAgICAgKkByZXR1cm4gYW4ge0FycmF5fSBvZiB7UG9pbnR9c1xyXG4gICAgICoqL1xyXG4gICAgUG9pbnQuY2xvbmVBcnJheSA9IGZ1bmN0aW9uKHYpe1xyXG4gICAgICAgIHZhciBuZXdQb2ludHMgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTwgdi5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIG5ld1BvaW50cy5wdXNoKHZbaV0uY2xvbmUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdQb2ludHM7XHJcbiAgICB9O1xyXG5cclxuICAgIFBvaW50LnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvciA6IFBvaW50LFxyXG5cclxuICAgICAgICB0cmFuc2Zvcm06ZnVuY3Rpb24obWF0cml4KXtcclxuICAgICAgICAgICAgdmFyIG9sZFggPSB0aGlzLng7XHJcbiAgICAgICAgICAgIHZhciBvbGRZID0gdGhpcy55O1xyXG4gICAgICAgICAgICB0aGlzLnggPSBtYXRyaXhbMF1bMF0gKiBvbGRYICsgbWF0cml4WzBdWzFdICogb2xkWSArIG1hdHJpeFswXVsyXTtcclxuICAgICAgICAgICAgdGhpcy55ID0gbWF0cml4WzFdWzBdICogb2xkWCArIG1hdHJpeFsxXVsxXSAqIG9sZFkgKyBtYXRyaXhbMV1bMl07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqVGVzdHMgaWYgdGhpcyBwb2ludCBpcyBzaW1pbGFyIHRvIG90aGVyIHBvaW50XHJcbiAgICAgICAgICpAcGFyYW0ge1BvaW50fSBhbm90aGVyUG9pbnQgLSB0aGUgb3RoZXIgcG9pbnRcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgZXF1YWxzOmZ1bmN0aW9uKGFub3RoZXJQb2ludCl7XHJcbiAgICAgICAgICAgIGlmKCEgKGFub3RoZXJQb2ludCBpbnN0YW5jZW9mIFBvaW50KSApe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy54ID09IGFub3RoZXJQb2ludC54KVxyXG4gICAgICAgICAgICAmJiAodGhpcy55ID09IGFub3RoZXJQb2ludC55KVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKkNsb25lIGN1cnJlbnQgUG9pbnRcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHZhciBuZXdQb2ludCA9IG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdQb2ludDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhZGQ6IGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMueCArIHBvaW50Lng7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSArIHBvaW50Lnk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlRlc3RzIHRvIHNlZSBpZiBhIHBvaW50ICh4LCB5KSBpcyB3aXRoaW4gYSByYW5nZSBvZiBjdXJyZW50IFBvaW50XHJcbiAgICAgICAgICpAcGFyYW0ge051bWVyaWN9IHggLSB0aGUgeCBjb29yZGluYXRlIG9mIHRlc3RlZCBwb2ludFxyXG4gICAgICAgICAqQHBhcmFtIHtOdW1lcmljfSB5IC0gdGhlIHggY29vcmRpbmF0ZSBvZiB0ZXN0ZWQgcG9pbnRcclxuICAgICAgICAgKkBwYXJhbSB7TnVtZXJpY30gcmFkaXVzIC0gdGhlIHJhZGl1cyBvZiB0aGUgdmljaW5pdHlcclxuICAgICAgICAgKiovXHJcbiAgICAgICAgbmVhcjpmdW5jdGlvbih4LCB5LCByYWRpdXMpe1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy54IC0geCwgMikgKyBNYXRoLnBvdyh0aGlzLnkgLSB5LCAyKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKGRpc3RhbmNlIDw9IHJhZGl1cyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uKHgseSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggPT0geCAmJiB0aGlzLnkgPT0geTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0b1N0cmluZzpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gJ1snICsgdGhpcy54ICsgJywnICsgdGhpcy55ICsgJ10nO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldFBvaW50czpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gW3RoaXNdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBMaW5lLiBBIExpbmUgaXMgYWN0dWFsbHkgYSBzZWdtZW50IGFuZCBub3QgYSBwdXJlXHJcbiAgICAgICogZ2VvbWV0cmljYWwgTGluZVxyXG4gICAgICAqXHJcbiAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICogQHRoaXMge0xpbmV9XHJcbiAgICAgICogQHBhcmFtIHtQb2ludH0gc3RhcnRQb2ludCAtIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBsaW5lXHJcbiAgICAgICogQHBhcmFtIHtQb2ludH0gZW5kUG9pbnQgLSB0aGUgZW5kaW5nIHBvaW50IG9mIHRoZSBsaW5lXHJcbiAgICAgICoqL1xyXG4gICAgZnVuY3Rpb24gTGluZShzdGFydFBvaW50LCBlbmRQb2ludCl7XHJcbiAgICAgICAgLyoqU3RhcnRpbmcge0BsaW5rIFBvaW50fSBvZiB0aGUgbGluZSovXHJcbiAgICAgICAgdGhpcy5zdGFydFBvaW50ID0gc3RhcnRQb2ludDtcclxuXHJcbiAgICAgICAgLyoqRW5kaW5nIHtAbGluayBQb2ludH0gb2YgdGhlIGxpbmUqL1xyXG4gICAgICAgIHRoaXMuZW5kUG9pbnQgPSBlbmRQb2ludDtcclxuXHJcbiAgICAgICAgLyoqU2VyaWFsaXphdGlvbiB0eXBlKi9cclxuICAgICAgICB0aGlzLm9UeXBlID0gJ0xpbmUnOyAvL29iamVjdCB0eXBlIHVzZWQgZm9yIEpTT04gZGVzZXJpYWxpemF0aW9uXHJcbiAgICB9XHJcblxyXG4gICAgLyoqQ3JlYXRlcyBhIHtMaW5lfSBvdXQgb2YgSlNPTiBwYXJzZWQgb2JqZWN0XHJcbiAgICAgKkBwYXJhbSB7SlNPTk9iamVjdH0gbyAtIHRoZSBKU09OIHBhcnNlZCBvYmplY3RcclxuICAgICAqQHJldHVybiB7TGluZX0gYSBuZXdseSBjb25zdHJ1Y3RlZCBMaW5lXHJcbiAgICAgKiovXHJcbiAgICBMaW5lLmxvYWQgPSBmdW5jdGlvbihvKXtcclxuICAgICAgICB2YXIgbmV3TGluZSA9IG5ldyBMaW5lKFxyXG4gICAgICAgICAgICBQb2ludC5sb2FkKG8uc3RhcnRQb2ludCksXHJcbiAgICAgICAgICAgIFBvaW50LmxvYWQoby5lbmRQb2ludClcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3TGluZTtcclxuICAgIH07XHJcblxyXG4gICAgTGluZS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY29udHJ1Y3RvcjogTGluZSxcclxuXHJcblxyXG5cclxuICAgICAgICBjbG9uZTpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IExpbmUodGhpcy5zdGFydFBvaW50LmNsb25lKCksIHRoaXMuZW5kUG9pbnQuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZXF1YWxzOmZ1bmN0aW9uKGFub3RoZXJMaW5lKXtcclxuICAgICAgICAgICAgaWYoIWFub3RoZXJMaW5lIGluc3RhbmNlb2YgTGluZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQb2ludC5lcXVhbHMoYW5vdGhlckxpbmUuc3RhcnRQb2ludClcclxuICAgICAgICAgICAgJiYgdGhpcy5lbmRQb2ludC5lcXVhbHMoYW5vdGhlckxpbmUuZW5kUG9pbnQpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqIFRlc3RzIHRvIHNlZSBpZiBhIHBvaW50IGJlbG9uZ3MgdG8gdGhpcyBsaW5lIChub3QgYXMgaW5maW5pdGUgbGluZSBidXQgbW9yZSBsaWtlIGEgc2VnbWVudClcclxuICAgICAgICAgKiBBbGdvcml0aG06IENvbXB1dGUgbGluZSdzIGVxdWF0aW9uIGFuZCBzZWUgaWYgKHgsIHkpIHZlcmlmaWVzIGl0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gdGhlIFggY29vcmRpbmF0ZXNcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geSAtIHRoZSBZIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGNvbnRhaW5zOiBmdW5jdGlvbih4LCB5KXtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIHBvaW50IGlzIGluc2lkZSByZWN0YW5nbGUgYm91bmRzIG9mIHRoZSBzZWdtZW50XHJcbiAgICAgICAgICAgIGlmIChNYXRoLm1pbih0aGlzLnN0YXJ0UG9pbnQueCwgdGhpcy5lbmRQb2ludC54KSA8PSB4XHJcbiAgICAgICAgICAgICAgICAmJiB4IDw9IE1hdGgubWF4KHRoaXMuc3RhcnRQb2ludC54LCB0aGlzLmVuZFBvaW50LngpXHJcbiAgICAgICAgICAgICAgICAmJiBNYXRoLm1pbih0aGlzLnN0YXJ0UG9pbnQueSwgdGhpcy5lbmRQb2ludC55KSA8PSB5XHJcbiAgICAgICAgICAgICAgICAmJiB5IDw9IE1hdGgubWF4KHRoaXMuc3RhcnRQb2ludC55LCB0aGlzLmVuZFBvaW50LnkpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHZlcnRpY2FsIGxpbmVcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0UG9pbnQueCA9PSB0aGlzLmVuZFBvaW50LngpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCA9PSB0aGlzLnN0YXJ0UG9pbnQueDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHVzdWFsIChub3QgdmVydGljYWwpIGxpbmUgY2FuIGJlIHJlcHJlc2VudGVkIGFzIHkgPSBhICogeCArIGJcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9ICh0aGlzLmVuZFBvaW50LnkgLSB0aGlzLnN0YXJ0UG9pbnQueSkgLyAodGhpcy5lbmRQb2ludC54IC0gdGhpcy5zdGFydFBvaW50LngpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdGhpcy5zdGFydFBvaW50LnkgLSBhICogdGhpcy5zdGFydFBvaW50Lng7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkgPT0gYSAqIHggKyBiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKlNlZSBpZiB3ZSBhcmUgbmVhciBhIHtMaW5lfSBieSBhIGNlcnRhaW4gcmFkaXVzIChhbHNvIGluY2x1ZGVzIHRoZSBleHRyZW1pdGllcyBpbnRvIGNvbXB1dGF0aW9uKVxyXG4gICAgICAgICAqQHBhcmFtIHtOdW1iZXJ9IHggLSB0aGUgeCBjb29yZGluYXRlc1xyXG4gICAgICAgICAqQHBhcmFtIHtOdW1iZXJ9IHkgLSB0aGUgeSBjb29yZGluYXRlc1xyXG4gICAgICAgICAqQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyAtIHRoZSByYWRpdXMgdG8gc2VhcmNoIGZvclxyXG4gICAgICAgICAqQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc3RhbmNlX2Zyb21fYV9wb2ludF90b19hX2xpbmVcclxuICAgICAgICAgKkBzZWUgXCJNYXRoZW1hdGljcyBmb3IgQ29tcHV0ZXIgR3JhcGhpY3MsIDJuZCBFZC4sIGJ5IEpvaG4gVmljZSwgcGFnZSAyMjdcIlxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBuZWFyOmZ1bmN0aW9uKHgseSxyYWRpdXMpe1xyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5lbmRQb2ludC54ID09PSB0aGlzLnN0YXJ0UG9pbnQueCl7IC8vVmVydGljYWwgbGluZSwgc28gdGhlIHZpY2luaXR5IGFyZWEgaXMgYSByZWN0YW5nbGVcclxuICAgICAgICAgICAgICAgIHJldHVybiAoICh0aGlzLnN0YXJ0UG9pbnQueS1yYWRpdXM8PXkgJiYgdGhpcy5lbmRQb2ludC55K3JhZGl1cz49eSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHRoaXMuZW5kUG9pbnQueS1yYWRpdXM8PXkgJiYgdGhpcy5zdGFydFBvaW50LnkrcmFkaXVzPj15KSlcclxuICAgICAgICAgICAgICAgICYmIHggPiB0aGlzLnN0YXJ0UG9pbnQueCAtIHJhZGl1cyAmJiB4IDwgdGhpcy5zdGFydFBvaW50LnggKyByYWRpdXMgO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLnN0YXJ0UG9pbnQueSA9PT0gdGhpcy5lbmRQb2ludC55KXsgLy9Ib3Jpem9udGFsIGxpbmUsIHNvIHRoZSB2aWNpbml0eSBhcmVhIGlzIGEgcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCAodGhpcy5zdGFydFBvaW50LnggLSByYWRpdXM8PXggJiYgdGhpcy5lbmRQb2ludC54K3JhZGl1cz49eClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHRoaXMuZW5kUG9pbnQueC1yYWRpdXM8PXggJiYgdGhpcy5zdGFydFBvaW50LngrcmFkaXVzPj14KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgeT50aGlzLnN0YXJ0UG9pbnQueS1yYWRpdXMgJiYgeTx0aGlzLnN0YXJ0UG9pbnQueStyYWRpdXMgO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IE1hdGgubWluKHRoaXMuZW5kUG9pbnQueCx0aGlzLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHZhciBzdGFydFkgPSBNYXRoLm1pbih0aGlzLmVuZFBvaW50LnksdGhpcy5zdGFydFBvaW50LnkpO1xyXG4gICAgICAgICAgICB2YXIgZW5kWCA9IE1hdGgubWF4KHRoaXMuZW5kUG9pbnQueCx0aGlzLnN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHZhciBlbmRZID0gTWF0aC5tYXgodGhpcy5lbmRQb2ludC55LHRoaXMuc3RhcnRQb2ludC55KTtcclxuXHJcbiAgICAgICAgICAgIC8qV2Ugd2lsbCBjb21wdXRlIHRoZSBkaXN0YW5jZSBmcm9tIHBvaW50IHRvIHRoZSBsaW5lXHJcbiAgICAgICAgICAgICAqIGJ5IHVzaW5nIHRoZSBhbGdvcml0aG0gZnJvbVxyXG4gICAgICAgICAgICAgKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc3RhbmNlX2Zyb21fYV9wb2ludF90b19hX2xpbmVcclxuICAgICAgICAgICAgICogKi9cclxuXHJcbiAgICAgICAgICAgIC8vRmlyc3Qgd2UgbmVlZCB0byBmaW5kIGEsYixjIG9mIHRoZSBsaW5lIGVxdWF0aW9uIGF4ICsgYnkgKyBjID0gMFxyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuZW5kUG9pbnQueSAtIHRoaXMuc3RhcnRQb2ludC55O1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuc3RhcnRQb2ludC54IC0gdGhpcy5lbmRQb2ludC54O1xyXG4gICAgICAgICAgICB2YXIgYyA9IC0odGhpcy5zdGFydFBvaW50LnggKiB0aGlzLmVuZFBvaW50LnkgLSB0aGlzLmVuZFBvaW50LnggKiB0aGlzLnN0YXJ0UG9pbnQueSk7XHJcblxyXG4gICAgICAgICAgICAvL1NlY29uZGx5IHdlIGdldCB0aGUgZGlzdGFuY2UgXCJNYXRoZW1hdGljcyBmb3IgQ29tcHV0ZXIgR3JhcGhpY3MsIDJuZCBFZC4sIGJ5IEpvaG4gVmljZSwgcGFnZSAyMjdcIlxyXG4gICAgICAgICAgICB2YXIgZCA9IE1hdGguYWJzKCAoYSp4ICsgYip5ICsgYykgLyBNYXRoLnNxcnQoTWF0aC5wb3coYSwyKSArIE1hdGgucG93KGIsMikpICk7XHJcblxyXG4gICAgICAgICAgICAvL1RoaXJkbHkgd2UgZ2V0IGNvb3JkaW5hdGVzIG9mIGNsb3Nlc3QgbGluZSdzIHBvaW50IHRvIHRhcmdldCBwb2ludFxyXG4gICAgICAgICAgICAvL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfZnJvbV9hX3BvaW50X3RvX2FfbGluZSNDYXJ0ZXNpYW5fY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgdmFyIGNsb3Nlc3RYID0gKGIgKiAoYip4IC0gYSp5KSAtIGEqYykgLyAoIE1hdGgucG93KGEsMikgKyBNYXRoLnBvdyhiLDIpICk7XHJcbiAgICAgICAgICAgIHZhciBjbG9zZXN0WSA9IChhICogKC1iKnggKyBhKnkpIC0gYipjKSAvICggTWF0aC5wb3coYSwyKSArIE1hdGgucG93KGIsMikgKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByID0gKCBkIDw9IHJhZGl1cyAmJiBlbmRYPj1jbG9zZXN0WCAmJiBjbG9zZXN0WD49c3RhcnRYICYmIGVuZFk+PWNsb3Nlc3RZICYmIGNsb3Nlc3RZPj1zdGFydFkgKSAvL3RoZSBwcm9qZWN0aW9uIG9mIHRoZSBwb2ludCBmYWxscyBJTlNJREUgb2YgdGhlIHNlZ21lbnRcclxuICAgICAgICAgICAgICAgIHx8IHRoaXMuc3RhcnRQb2ludC5uZWFyKHgseSxyYWRpdXMpIHx8IHRoaXMuZW5kUG9pbnQubmVhcih4LHkscmFkaXVzKTsgLy90aGUgcHJvamVjdGlvbiBvZiB0aGUgcG9pbnQgZmFsbHMgT1VUU0lERSBvZiB0aGUgc2VnbWVudFxyXG5cclxuICAgICAgICAgICAgcmV0dXJuICByO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKip3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBhcnJheSBlYWNoIHRpbWUsIG9yIHdlIHdpbGwgYWZmZWN0IHRoZSBhY3R1YWwgc2hhcGUqL1xyXG4gICAgICAgIGdldFBvaW50czpmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHRoaXMuc3RhcnRQb2ludCk7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHRoaXMuZW5kUG9pbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlJldHVybiB0aGUge1BvaW50fSBjb3JyZXNwb25kaW5nIHRoZSB0IGNlcnRhaW4gdCB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0IHRoZSB2YWx1ZSBvZiBwYXJhbWV0ZXIgdCwgd2hlcmUgdCBpbiBbMCwxXSwgdCBpcyBsaWtlIGEgcGVyY2VudCovXHJcbiAgICAgICAgZ2V0UG9pbnQ6IGZ1bmN0aW9uKHQpe1xyXG4gICAgICAgICAgICB2YXIgWHAgPSB0ICogKHRoaXMuZW5kUG9pbnQueCAtIHRoaXMuc3RhcnRQb2ludC54KSArIHRoaXMuc3RhcnRQb2ludC54O1xyXG4gICAgICAgICAgICB2YXIgWXAgPSB0ICogKHRoaXMuZW5kUG9pbnQueSAtIHRoaXMuc3RhcnRQb2ludC55KSArIHRoaXMuc3RhcnRQb2ludC55O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYcCwgWXApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIC8qKlxyXG4gICAgICAgIC8vICAqIFJldHVybnMgdGhlIG1pZGRsZSBvZiB0aGUgbGluZVxyXG4gICAgICAgIC8vICAqIEByZXR1cm4ge1BvaW50fSB0aGUgbWlkZGxlIHBvaW50XHJcbiAgICAgICAgLy8gICogKi9cclxuICAgICAgICAvLyBnZXRNaWRkbGUgOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gVXRpbC5nZXRNaWRkbGUodGhpcy5zdGFydFBvaW50LCB0aGlzLmVuZFBvaW50KTtcclxuICAgICAgICAvLyB9LFxyXG5cclxuXHJcbiAgICAgICAgLy8gZ2V0TGVuZ3RoIDogZnVuY3Rpb24oKXtcclxuICAgICAgICAvLyAgICAgcmV0dXJuIFV0aWwuZ2V0TGVuZ3RoKHRoaXMuc3RhcnRQb2ludCwgdGhpcy5lbmRQb2ludCk7XHJcbiAgICAgICAgLy8gfSxcclxuXHJcbiAgICAgICAgLy8gLyoqXHJcbiAgICAgICAgLy8gICpHZXQgYm91bmRzIGZvciB0aGlzIGxpbmVcclxuICAgICAgICAvLyAgKkBhdXRob3IgQWxleCBHaGVvcmdoaXUgPGFsZXhAc2NyaXB0b2lkLmNvbT5cclxuICAgICAgICAvLyAgKiovXHJcbiAgICAgICAgLy8gZ2V0Qm91bmRzOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgLy8gICAgIHJldHVybiBVdGlsLmdldEJvdW5kcyh0aGlzLmdldFBvaW50cygpKTtcclxuICAgICAgICAvLyB9LFxyXG5cclxuICAgICAgICAvKipTdHJpbmcgcmVwcmVzZW50YXRpb24qL1xyXG4gICAgICAgIHRvU3RyaW5nOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiAnbGluZSgnICsgdGhpcy5zdGFydFBvaW50ICsgJywnICsgdGhpcy5lbmRQb2ludCArICcpJztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xyXG5cclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9MaW5lU3RydWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblxyXG4gICAgdmFyIGFwaUxpc3QgPSBbXHJcbiAgICAgICAgJ2dldERvbScsICdnZXRacicsICdnZXRXaWR0aCcsICdnZXRIZWlnaHQnLCAnZGlzcGF0Y2hBY3Rpb24nLFxyXG4gICAgICAgICdvbicsICdvZmYnLCAndHJpZ2dlcicsICdnZXREYXRhVVJMJywgJ2dldENvbm5lY3RlZERhdGFVUkwnLCAnZ2V0TW9kZWwnLCAnZ2V0T3B0aW9uJyxcclxuICAgICAgICBcInJlbW92ZVwiLCBcIl9nZXRQYXJlbnRaclwiLCBcImNoYW5nZVNlbGVjdENvbm5lY3RvclR5cGVcIlxyXG4gICAgXTtcclxuXHJcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25BUEkoaW5zdGFuY2UpIHtcclxuICAgICAgICB6clV0aWwuZWFjaChhcGlMaXN0LCBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzW25hbWVdID0genJVdGlsLmJpbmQoaW5zdGFuY2VbbmFtZV0sIGluc3RhbmNlKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV4dGVuc2lvbkFQSTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9FeHRlbnNpb25BcGkuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogWlJlbmRlciwgYSBoaWdoIHBlcmZvcm1hbmNlIDJkIGRyYXdpbmcgbGlicmFyeS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJhaWR1IEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4gKi9cbi8vIEdsb2JhbCBkZWZpbmVzXG5cbiAgICB2YXIgZ3VpZCA9IHJlcXVpcmUoJy4vY29yZS9ndWlkJyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJy4vY29yZS9lbnYnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBIYW5kbGVyID0gcmVxdWlyZSgnLi9IYW5kbGVyJyk7XG4gICAgdmFyIFN0b3JhZ2UgPSByZXF1aXJlKCcuL1N0b3JhZ2UnKTtcbiAgICB2YXIgQW5pbWF0aW9uID0gcmVxdWlyZSgnLi9hbmltYXRpb24vQW5pbWF0aW9uJyk7XG4gICAgdmFyIEhhbmRsZXJQcm94eSA9IHJlcXVpcmUoJy4vZG9tL0hhbmRsZXJQcm94eScpO1xuXG4gICAgdmFyIHVzZVZNTCA9ICFlbnYuY2FudmFzU3VwcG9ydGVkO1xuXG4gICAgdmFyIHBhaW50ZXJDdG9ycyA9IHtcbiAgICAgICAgY2FudmFzOiByZXF1aXJlKCcuL1BhaW50ZXInKVxuICAgIH07XG5cbiAgICB2YXIgaW5zdGFuY2VzID0ge307ICAgIC8vIFpSZW5kZXLlrp7kvottYXDntKLlvJVcblxuICAgIHZhciB6cmVuZGVyID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHpyZW5kZXIudmVyc2lvbiA9ICczLjYuMyc7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXppbmcgYSB6cmVuZGVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAgICovXG4gICAgenJlbmRlci5pbml0ID0gZnVuY3Rpb24gKGRvbSwgb3B0cykge1xuICAgICAgICB2YXIgenIgPSBuZXcgWlJlbmRlcihndWlkKCksIGRvbSwgb3B0cyk7XG4gICAgICAgIGluc3RhbmNlc1t6ci5pZF0gPSB6cjtcbiAgICAgICAgcmV0dXJuIHpyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIHpyZW5kZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAgICovXG4gICAgenJlbmRlci5kaXNwb3NlID0gZnVuY3Rpb24gKHpyKSB7XG4gICAgICAgIGlmICh6cikge1xuICAgICAgICAgICAgenIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXNba2V5XS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2VzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4genJlbmRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHpyZW5kZXIgaW5zdGFuY2UgYnkgaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgenJlbmRlciBpbnN0YW5jZSBpZFxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAgICovXG4gICAgenJlbmRlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VzW2lkXTtcbiAgICB9O1xuXG4gICAgenJlbmRlci5yZWdpc3RlclBhaW50ZXIgPSBmdW5jdGlvbiAobmFtZSwgQ3Rvcikge1xuICAgICAgICBwYWludGVyQ3RvcnNbbmFtZV0gPSBDdG9yO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkZWxJbnN0YW5jZShpZCkge1xuICAgICAgICBkZWxldGUgaW5zdGFuY2VzW2lkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbW9kdWxlIHpyZW5kZXIvWlJlbmRlclxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9aUmVuZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgKi9cbiAgICB2YXIgWlJlbmRlciA9IGZ1bmN0aW9uIChpZCwgZG9tLCBvcHRzKSB7XG5cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRG9tRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZSgpO1xuXG4gICAgICAgIHZhciByZW5kZXJlclR5cGUgPSBvcHRzLnJlbmRlcmVyO1xuICAgICAgICAvLyBUT0RPIFdlYkdMXG4gICAgICAgIGlmICh1c2VWTUwpIHtcbiAgICAgICAgICAgIGlmICghcGFpbnRlckN0b3JzLnZtbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcmVxdWlyZSBcXCd6cmVuZGVyL3ZtbC92bWxcXCcgdG8gc3VwcG9ydCBJRTgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9ICd2bWwnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFyZW5kZXJlclR5cGUgfHwgIXBhaW50ZXJDdG9yc1tyZW5kZXJlclR5cGVdKSB7XG4gICAgICAgICAgICByZW5kZXJlclR5cGUgPSAnY2FudmFzJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFpbnRlciA9IG5ldyBwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXShkb20sIHN0b3JhZ2UsIG9wdHMpO1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG5cbiAgICAgICAgdmFyIGhhbmRlclByb3h5ID0gIWVudi5ub2RlID8gbmV3IEhhbmRsZXJQcm94eShwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKSA6IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IG5ldyBIYW5kbGVyKHN0b3JhZ2UsIHBhaW50ZXIsIGhhbmRlclByb3h5LCBwYWludGVyLnJvb3QpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih7XG4gICAgICAgICAgICBzdGFnZToge1xuICAgICAgICAgICAgICAgIHVwZGF0ZTogenJVdGlsLmJpbmQodGhpcy5mbHVzaCwgdGhpcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLnN0YXJ0KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoO1xuXG4gICAgICAgIC8vIOS/ruaUuSBzdG9yYWdlLmRlbEZyb21TdG9yYWdlLCDmr4/mrKHliKDpmaTlhYPntKDkuYvliY3liKDpmaTliqjnlLtcbiAgICAgICAgLy8gRklYTUUg5pyJ54K5dWdseVxuICAgICAgICB2YXIgb2xkRGVsRnJvbVN0b3JhZ2UgPSBzdG9yYWdlLmRlbEZyb21TdG9yYWdlO1xuICAgICAgICB2YXIgb2xkQWRkVG9TdG9yYWdlID0gc3RvcmFnZS5hZGRUb1N0b3JhZ2U7XG5cbiAgICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgb2xkRGVsRnJvbVN0b3JhZ2UuY2FsbChzdG9yYWdlLCBlbCk7XG5cbiAgICAgICAgICAgIGVsICYmIGVsLnJlbW92ZVNlbGZGcm9tWnIoc2VsZik7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIG9sZEFkZFRvU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcblxuICAgICAgICAgICAgZWwuYWRkU2VsZlRvWnIoc2VsZik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIFpSZW5kZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBaUmVuZGVyLFxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5a6e5L6L5ZSv5LiA5qCH6K+GXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldElkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmFkZFJvb3QoZWwpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoZWwpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlIGNvbmZpZ3VyYXRpb24gb2YgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHpMZXZlbFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0gQ2xlYXIgY29sb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubW90aW9uQmx1cj1mYWxzZV0gSWYgZW5hYmxlIG1vdGlvbiBibHVyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmxhc3RGcmFtZUFscGhhPTAuN10gTW90aW9uIGJsdXIgZmFjdG9yLiBMYXJnZXIgdmFsdWUgY2F1c2UgbG9uZ2VyIHRyYWlsZXJcbiAgICAgICAgKi9cbiAgICAgICAgY29uZmlnTGF5ZXI6IGZ1bmN0aW9uICh6TGV2ZWwsIGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLmNvbmZpZ0xheWVyKHpMZXZlbCwgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGFpbnQgdGhlIGNhbnZhcyBpbW1lZGlhdGVseVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaEltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgbmVlZHNSZWZyZXNoIGFoZWFkIHRvIGF2b2lkIHNvbWV0aGluZyB3cm9uZyBoYXBwZW5zIGluIHJlZnJlc2hcbiAgICAgICAgICAgIC8vIE9yIGl0IHdpbGwgY2F1c2UgenJlbmRlciByZWZyZXNoZXMgYWdhaW4gYW5kIGFnYWluLlxuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIucmVmcmVzaCgpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBdm9pZCB0cmlnZ2VyIHpyLnJlZnJlc2ggaW4gRWxlbWVudCNiZWZvcmVVcGRhdGUgaG9va1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHZhciBlbmQgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgICAgICAvLyB2YXIgbG9nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZycpO1xuICAgICAgICAgICAgLy8gaWYgKGxvZykge1xuICAgICAgICAgICAgLy8gICAgIGxvZy5pbm5lckhUTUwgPSBsb2cuaW5uZXJIVE1MICsgJzxicj4nICsgKGVuZCAtIHN0YXJ0KTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFyayBhbmQgcmVwYWludCB0aGUgY2FudmFzIGluIHRoZSBuZXh0IGZyYW1lIG9mIGJyb3dzZXJcbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybSBhbGwgcmVmcmVzaFxuICAgICAgICAgKi9cbiAgICAgICAgZmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9uZWVkc1JlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hJbW1lZGlhdGVseSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSG92ZXJJbW1lZGlhdGVseSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgZWxlbWVudCB0byBob3ZlciBsYXllclxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgICAgICovXG4gICAgICAgIGFkZEhvdmVyOiBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYWludGVyLmFkZEhvdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyLmFkZEhvdmVyKGVsLCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGVsZW1lbnQgZnJvbSBob3ZlciBsYXllclxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFpbnRlci5yZW1vdmVIb3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRlci5yZW1vdmVIb3ZlcihlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXIgYWxsIGhvdmVyIGVsZW1lbnRzIGluIGhvdmVyIGxheWVyXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYWludGVyLmNsZWFySG92ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIuY2xlYXJIb3ZlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZnJlc2ggaG92ZXIgaW4gbmV4dCBmcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaEhvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2hIb3ZlciA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZnJlc2ggaG92ZXIgaW1tZWRpYXRlbHlcbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2hIb3ZlckltbWVkaWF0ZWx5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2hIb3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlciAmJiB0aGlzLnBhaW50ZXIucmVmcmVzaEhvdmVyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZSB0aGUgY2FudmFzLlxuICAgICAgICAgKiBTaG91bGQgYmUgaW52b2tlZCB3aGVuIGNvbnRhaW5lciBzaXplIGlzIGNoYW5nZWRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy5oZWlnaHRdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbihvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5yZXNpemUob3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnJlc2l6ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wIGFuZCBjbGVhciBhbGwgYW5pbWF0aW9uIGltbWVkaWF0ZWx5XG4gICAgICAgICAqL1xuICAgICAgICBjbGVhckFuaW1hdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uY2xlYXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGNvbnRhaW5lciB3aWR0aFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRXaWR0aCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY29udGFpbmVyIGhlaWdodFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4cG9ydCB0aGUgY2FudmFzIGFzIEJhc2U2NCBVUkxcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtiYWNrZ3JvdW5kQ29sb3I9JyNmZmYnXVxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJhc2U2NCBVUkxcbiAgICAgICAgICovXG4gICAgICAgIC8vIHRvRGF0YVVSTDogZnVuY3Rpb24odHlwZSwgYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIC8vICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFJlbmRlcmVkQ2FudmFzKHtcbiAgICAgICAgLy8gICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAgICAgICAvLyAgICAgfSkudG9EYXRhVVJMKHR5cGUpO1xuICAgICAgICAvLyB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0aW5nIGEgcGF0aCB0byBpbWFnZS5cbiAgICAgICAgICogSXQgaGFzIG11Y2ggYmV0dGVyIHBlcmZvcm1hbmNlIG9mIGRyYXdpbmcgaW1hZ2UgcmF0aGVyIHRoYW4gZHJhd2luZyBhIHZlY3RvciBwYXRoLlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAgICAgKi9cbiAgICAgICAgcGF0aFRvSW1hZ2U6IGZ1bmN0aW9uKGUsIGRwcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5wYXRoVG9JbWFnZShlLCBkcHIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgZGVmYXVsdCBjdXJzb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JTdHlsZT0nZGVmYXVsdCddIOS+i+WmgiBjcm9zc2hhaXJcbiAgICAgICAgICovXG4gICAgICAgIHNldEN1cnNvclN0eWxlOiBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5zZXRDdXJzb3JTdHlsZShjdXJzb3JTdHlsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmQgaG92ZXJlZCBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0ge3RhcmdldCwgdG9wVGFyZ2V0fVxuICAgICAgICAgKi9cbiAgICAgICAgZmluZEhvdmVyOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5maW5kSG92ZXIoeCwgeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmQgZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50SGFuZGxlciBIYW5kbGVyIGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIG9uOiBmdW5jdGlvbihldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLm9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyLCBjb250ZXh0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5iaW5kIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXZlbnRIYW5kbGVyXSBIYW5kbGVyIGZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBvZmY6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIub2ZmKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZ2dlciBldmVudCBtYW51YWxseVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtldmVudD19IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnQpO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFyIGFsbCBvYmplY3RzIGFuZCB0aGUgY2FudmFzLlxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5kZWxSb290KCk7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIuY2xlYXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcG9zZSBzZWxmLlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uc3RvcCgpO1xuXG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID1cbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIgPVxuICAgICAgICAgICAgdGhpcy5oYW5kbGVyID0gbnVsbDtcblxuICAgICAgICAgICAgZGVsSW5zdGFuY2UodGhpcy5pZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB6cmVuZGVyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL3pyZW5kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogSGFuZGxlclxuICogQG1vZHVsZSB6cmVuZGVyL0hhbmRsZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChzaGVueWkuOTE0QGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIERyYWdnYWJsZSA9IHJlcXVpcmUoJy4vbWl4aW4vRHJhZ2dhYmxlJyk7XG5cbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuL21peGluL0V2ZW50ZnVsJyk7XG5cbiAgICB2YXIgU0lMRU5UID0gJ3NpbGVudCc7XG5cbiAgICBmdW5jdGlvbiBtYWtlRXZlbnRQYWNrZXQoZXZlVHlwZSwgdGFyZ2V0SW5mbywgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGV2ZVR5cGUsXG4gICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAvLyB0YXJnZXQgY2FuIG9ubHkgYmUgYW4gZWxlbWVudCB0aGF0IGlzIG5vdCBzaWxlbnQuXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldEluZm8udGFyZ2V0LFxuICAgICAgICAgICAgLy8gdG9wVGFyZ2V0IGNhbiBiZSBhIHNpbGVudCBlbGVtZW50LlxuICAgICAgICAgICAgdG9wVGFyZ2V0OiB0YXJnZXRJbmZvLnRvcFRhcmdldCxcbiAgICAgICAgICAgIGNhbmNlbEJ1YmJsZTogZmFsc2UsXG4gICAgICAgICAgICBvZmZzZXRYOiBldmVudC56clgsXG4gICAgICAgICAgICBvZmZzZXRZOiBldmVudC56clksXG4gICAgICAgICAgICBnZXN0dXJlRXZlbnQ6IGV2ZW50Lmdlc3R1cmVFdmVudCxcbiAgICAgICAgICAgIHBpbmNoWDogZXZlbnQucGluY2hYLFxuICAgICAgICAgICAgcGluY2hZOiBldmVudC5waW5jaFksXG4gICAgICAgICAgICBwaW5jaFNjYWxlOiBldmVudC5waW5jaFNjYWxlLFxuICAgICAgICAgICAgd2hlZWxEZWx0YTogZXZlbnQuenJEZWx0YSxcbiAgICAgICAgICAgIHpyQnlUb3VjaDogZXZlbnQuenJCeVRvdWNoLFxuICAgICAgICAgICAgd2hpY2g6IGV2ZW50LndoaWNoXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRW1wdHlQcm94eSAoKSB7fVxuICAgIEVtcHR5UHJveHkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHZhciBoYW5kbGVyTmFtZXMgPSBbXG4gICAgICAgICdjbGljaycsICdkYmxjbGljaycsICdtb3VzZXdoZWVsJywgJ21vdXNlb3V0JyxcbiAgICAgICAgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdjb250ZXh0bWVudSdcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9IYW5kbGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2UgU3RvcmFnZSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXIgUGFpbnRlciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2RvbS9IYW5kbGVyUHJveHl9IHByb3h5IEhhbmRsZXJQcm94eSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYWludGVyUm9vdCBwYWludGVyLnJvb3QgKG5vdCBwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKS5cbiAgICAgKi9cbiAgICB2YXIgSGFuZGxlciA9IGZ1bmN0aW9uKHN0b3JhZ2UsIHBhaW50ZXIsIHByb3h5LCBwYWludGVyUm9vdCkge1xuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG5cbiAgICAgICAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcblxuICAgICAgICB0aGlzLnBhaW50ZXJSb290ID0gcGFpbnRlclJvb3Q7XG5cbiAgICAgICAgcHJveHkgPSBwcm94eSB8fCBuZXcgRW1wdHlQcm94eSgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm94eSBvZiBldmVudC4gY2FuIGJlIERvbSwgV2ViR0xTdXJmYWNlLCBldGMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3h5ID0gcHJveHk7XG5cbiAgICAgICAgLy8gQXR0YWNoIGhhbmRsZXJcbiAgICAgICAgcHJveHkuaGFuZGxlciA9IHRoaXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHt0YXJnZXQsIHRvcFRhcmdldCwgeCwgeX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hvdmVyZWQgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0RhdGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXN0VG91Y2hNb21lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXN0WDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xhc3RZO1xuXG5cbiAgICAgICAgRHJhZ2dhYmxlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdXRpbC5lYWNoKGhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHByb3h5Lm9uICYmIHByb3h5Lm9uKG5hbWUsIHRoaXNbbmFtZV0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gICAgSGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEhhbmRsZXIsXG5cbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB4ID0gZXZlbnQuenJYO1xuICAgICAgICAgICAgdmFyIHkgPSBldmVudC56clk7XG5cbiAgICAgICAgICAgIHZhciBsYXN0SG92ZXJlZCA9IHRoaXMuX2hvdmVyZWQ7XG4gICAgICAgICAgICB2YXIgbGFzdEhvdmVyZWRUYXJnZXQgPSBsYXN0SG92ZXJlZC50YXJnZXQ7XG5cbiAgICAgICAgICAgIC8vIElmIGxhc3RIb3ZlcmVkVGFyZ2V0IGlzIHJlbW92ZWQgZnJvbSB6ciAoZGV0ZWN0ZWQgYnkgJ19fenInKSBieSBzb21lIEFQSSBjYWxsXG4gICAgICAgICAgICAvLyAobGlrZSAnc2V0T3B0aW9uJyBvciAnZGlzcGF0Y2hBY3Rpb24nKSBpbiBldmVudCBoYW5kbGVycywgd2Ugc2hvdWxkIGZpbmRcbiAgICAgICAgICAgIC8vIGxhc3RIb3ZlcmVkIGFnYWluIGhlcmUuIE90aGVyd2lzZSAnbW91c2VvdXQnIGNhbiBub3QgYmUgdHJpZ2dlcmVkIG5vcm1hbGx5LlxuICAgICAgICAgICAgLy8gU2VlICM2MTk4LlxuICAgICAgICAgICAgaWYgKGxhc3RIb3ZlcmVkVGFyZ2V0ICYmICFsYXN0SG92ZXJlZFRhcmdldC5fX3pyKSB7XG4gICAgICAgICAgICAgICAgbGFzdEhvdmVyZWQgPSB0aGlzLmZpbmRIb3ZlcihsYXN0SG92ZXJlZC54LCBsYXN0SG92ZXJlZC55KTtcbiAgICAgICAgICAgICAgICBsYXN0SG92ZXJlZFRhcmdldCA9IGxhc3RIb3ZlcmVkLnRhcmdldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGhvdmVyZWQgPSB0aGlzLl9ob3ZlcmVkID0gdGhpcy5maW5kSG92ZXIoeCwgeSk7XG4gICAgICAgICAgICB2YXIgaG92ZXJlZFRhcmdldCA9IGhvdmVyZWQudGFyZ2V0O1xuXG4gICAgICAgICAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgICAgICAgICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihob3ZlcmVkVGFyZ2V0ID8gaG92ZXJlZFRhcmdldC5jdXJzb3IgOiAnZGVmYXVsdCcpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBvdXQgb24gcHJldmlvdXMgaG92ZXJlZCBlbGVtZW50XG4gICAgICAgICAgICBpZiAobGFzdEhvdmVyZWRUYXJnZXQgJiYgaG92ZXJlZFRhcmdldCAhPT0gbGFzdEhvdmVyZWRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGxhc3RIb3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1vdXNlIG1vdmluZyBvbiBvbmUgZWxlbWVudFxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCAnbW91c2Vtb3ZlJywgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBvdmVyIG9uIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChob3ZlcmVkVGFyZ2V0ICYmIGhvdmVyZWRUYXJnZXQgIT09IGxhc3RIb3ZlcmVkVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCAnbW91c2VvdmVyJywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQodGhpcy5faG92ZXJlZCwgJ21vdXNlb3V0JywgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBUaGVyZSBtaWdodCBiZSBzb21lIGRvbXMgY3JlYXRlZCBieSB1cHBlciBsYXllciBhcHBsaWNhdGlvblxuICAgICAgICAgICAgLy8gYXQgdGhlIHNhbWUgbGV2ZWwgb2YgcGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSAoZS5nLiwgdG9vbHRpcFxuICAgICAgICAgICAgLy8gZG9tIGNyZWF0ZWQgYnkgZWNoYXJ0cyksIHdoZXJlICdnbG9iYWxvdXQnIGV2ZW50IHNob3VsZCBub3RcbiAgICAgICAgICAgIC8vIGJlIHRyaWdnZXJlZCB3aGVuIG1vdXNlIGVudGVycyB0aGVzZSBkb21zLiAoQnV0ICdtb3VzZW91dCdcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSB0cmlnZ2VyZWQgYXQgdGhlIG9yaWdpbmFsIGhvdmVyZWQgZWxlbWVudCBhcyB1c3VhbCkuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGlubmVyRG9tO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgIT0gOSAmJiAhKFxuICAgICAgICAgICAgICAgIGlubmVyRG9tID0gZWxlbWVudCA9PT0gdGhpcy5wYWludGVyUm9vdFxuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgICFpbm5lckRvbSAmJiB0aGlzLnRyaWdnZXIoJ2dsb2JhbG91dCcsIHtldmVudDogZXZlbnR9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzaXplXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5faG92ZXJlZCA9IHt9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaCBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAgICAgICAqIEBwYXJhbSB7ZXZlbnQ9fSBldmVudEFyZ3NcbiAgICAgICAgICovXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgaGFuZGxlciAmJiBoYW5kbGVyLmNhbGwodGhpcywgZXZlbnRBcmdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB0aGlzLnByb3h5LmRpc3Bvc2UoKTtcblxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID1cbiAgICAgICAgICAgIHRoaXMucHJveHkgPVxuICAgICAgICAgICAgdGhpcy5wYWludGVyID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u6buY6K6k55qEY3Vyc29yIHN0eWxlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3R5bGU9J2RlZmF1bHQnXSDkvovlpoIgY3Jvc3NoYWlyXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDdXJzb3JTdHlsZTogZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgICAgICAgICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihjdXJzb3JTdHlsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS6i+S7tuWIhuWPkeS7o+eQhlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0SW5mbyB7dGFyZ2V0LCB0b3BUYXJnZXR9IOebruagh+WbvuW9ouWFg+e0oFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIOS6i+S7tuWQjeensFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwYXRjaFRvRWxlbWVudDogZnVuY3Rpb24gKHRhcmdldEluZm8sIGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHRhcmdldEluZm8gPSB0YXJnZXRJbmZvIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGVsID0gdGFyZ2V0SW5mby50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoZWwgJiYgZWwuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9ICdvbicgKyBldmVudE5hbWU7XG4gICAgICAgICAgICB2YXIgZXZlbnRQYWNrZXQgPSBtYWtlRXZlbnRQYWNrZXQoZXZlbnROYW1lLCB0YXJnZXRJbmZvLCBldmVudCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgICAgIGVsW2V2ZW50SGFuZGxlcl1cbiAgICAgICAgICAgICAgICAgICAgJiYgKGV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSA9IGVsW2V2ZW50SGFuZGxlcl0uY2FsbChlbCwgZXZlbnRQYWNrZXQpKTtcblxuICAgICAgICAgICAgICAgIGVsLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG5cbiAgICAgICAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgICAgICAgICAgIC8vIOWGkuazoeWIsOmhtue6pyB6cmVuZGVyIOWvueixoVxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgICAgICAgICAvLyDliIblj5Hkuovku7bliLDnlKjmiLfoh6rlrprkuYnlsYJcbiAgICAgICAgICAgICAgICAvLyDnlKjmiLfmnInlj6/og73lnKjlhajlsYAgY2xpY2sg5LqL5Lu25LitIGRpc3Bvc2XvvIzmiYDku6XpnIDopoHliKTmlq3kuIsgcGFpbnRlciDmmK/lkKblrZjlnKhcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIgJiYgdGhpcy5wYWludGVyLmVhY2hPdGhlckxheWVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGxheWVyW2V2ZW50SGFuZGxlcl0pID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyW2V2ZW50SGFuZGxlcl0uY2FsbChsYXllciwgZXZlbnRQYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXllci50cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZX0gZXhjbHVkZVxuICAgICAgICAgKiBAcmV0dXJuIHttb2RlbDp6cmVuZGVyL0VsZW1lbnR9XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICovXG4gICAgICAgIGZpbmRIb3ZlcjogZnVuY3Rpb24oeCwgeSwgZXhjbHVkZSkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKTtcbiAgICAgICAgICAgIHZhciBvdXQgPSB7eDogeCwgeTogeX07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMCA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBob3ZlckNoZWNrUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChsaXN0W2ldICE9PSBleGNsdWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldERpc3BsYXlMaXN0IG1heSBpbmNsdWRlIGlnbm9yZWQgaXRlbSBpbiBWTUwgbW9kZVxuICAgICAgICAgICAgICAgICAgICAmJiAhbGlzdFtpXS5pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgJiYgKGhvdmVyQ2hlY2tSZXN1bHQgPSBpc0hvdmVyKGxpc3RbaV0sIHgsIHkpKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAhb3V0LnRvcFRhcmdldCAmJiAob3V0LnRvcFRhcmdldCA9IGxpc3RbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaG92ZXJDaGVja1Jlc3VsdCAhPT0gU0lMRU5UKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQudGFyZ2V0ID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIENvbW1vbiBoYW5kbGVyc1xuICAgIHV0aWwuZWFjaChbJ2NsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNld2hlZWwnLCAnZGJsY2xpY2snLCAnY29udGV4dG1lbnUnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgSGFuZGxlci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgaG92ZXIgYWdhaW4gdG8gYXZvaWQgY2xpY2sgZXZlbnQgaXMgZGlzcGF0Y2hlZCBtYW51YWxseS4gT3IgY2xpY2sgaXMgdHJpZ2dlcmVkIHdpdGhvdXQgbW91c2VvdmVyXG4gICAgICAgICAgICB2YXIgaG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKGV2ZW50LnpyWCwgZXZlbnQuenJZKTtcbiAgICAgICAgICAgIHZhciBob3ZlcmVkVGFyZ2V0ID0gaG92ZXJlZC50YXJnZXQ7XG5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rvd25FbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG93blBvaW50ID0gW2V2ZW50LnpyWCwgZXZlbnQuenJZXTtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIGNsaWNrIHRyaWdnZXJlZCBiZWZvcmUgbW91c2V1cFxuICAgICAgICAgICAgICAgIHRoaXMuX3VwRWwgPSBob3ZlcmVkVGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ21vc3VldXAnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBFbCA9IGhvdmVyZWRUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Rvd25FbCAhPT0gdGhpcy5fdXBFbFxuICAgICAgICAgICAgICAgICAgICAvLyBPcmlnaW5hbCBjbGljayBldmVudCBpcyB0cmlnZ2VyZWQgb24gdGhlIHdob2xlIGNhbnZhcyBlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAvLyBpbmNsdWRpbmcgdGhlIGNhc2UgdGhhdCBgbW91c2Vkb3duYCAtIGBtb3VzZW1vdmVgIC0gYG1vdXNldXBgLFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBzaG91bGQgYmUgZmlsdGVyZWQsIG90aGVyd2lzZSBpdCB3aWxsIGJyaW5nIHRyb3VibGUgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gcGFuIGFuZCB6b29tLlxuICAgICAgICAgICAgICAgICAgICB8fCAhdGhpcy5fZG93blBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vIEFyYml0cmFyeSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB8fCB2ZWMyLmRpc3QodGhpcy5fZG93blBvaW50LCBbZXZlbnQuenJYLCBldmVudC56clldKSA+IDRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kb3duUG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsIG5hbWUsIGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGlzSG92ZXIoZGlzcGxheWFibGUsIHgsIHkpIHtcbiAgICAgICAgaWYgKGRpc3BsYXlhYmxlW2Rpc3BsYXlhYmxlLnJlY3RIb3ZlciA/ICdyZWN0Q29udGFpbicgOiAnY29udGFpbiddKHgsIHkpKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBkaXNwbGF5YWJsZTtcbiAgICAgICAgICAgIHZhciBpc1NpbGVudDtcbiAgICAgICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGNsaXBwZWQgYnkgYW5jZXN0b3IuXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IElmIGNsaXBQYXRoIGhhcyBuZWl0aGVyIHN0cm9rZSBub3IgZmlsbCxcbiAgICAgICAgICAgICAgICAvLyBlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZS5cbiAgICAgICAgICAgICAgICBpZiAoZWwuY2xpcFBhdGggJiYgIWVsLmNsaXBQYXRoLmNvbnRhaW4oeCwgeSkpICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVsLnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICBpc1NpbGVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsID0gZWwucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzU2lsZW50ID8gU0lMRU5UIDogdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB1dGlsLm1peGluKEhhbmRsZXIsIEV2ZW50ZnVsKTtcbiAgICB1dGlsLm1peGluKEhhbmRsZXIsIERyYWdnYWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhhbmRsZXI7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvSGFuZGxlci5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBTdG9yYWdl5YaF5a655LuT5bqT5qih5Z2XXG4gKiBAbW9kdWxlIHpyZW5kZXIvU3RvcmFnZVxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nLylcbiAqL1xuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJy4vY29yZS9lbnYnKTtcblxuICAgIHZhciBHcm91cCA9IHJlcXVpcmUoJy4vY29udGFpbmVyL0dyb3VwJyk7XG5cbiAgICAvLyBVc2UgdGltc29ydCBiZWNhdXNlIGluIG1vc3QgY2FzZSBlbGVtZW50cyBhcmUgcGFydGlhbGx5IHNvcnRlZFxuICAgIC8vIGh0dHBzOi8vanNmaWRkbGUubmV0L3Bpc3NhbmcvanI0eDdtZG0vOC9cbiAgICB2YXIgdGltc29ydCA9IHJlcXVpcmUoJy4vY29yZS90aW1zb3J0Jyk7XG5cbiAgICBmdW5jdGlvbiBzaGFwZUNvbXBhcmVGdW5jKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuemxldmVsID09PSBiLnpsZXZlbCkge1xuICAgICAgICAgICAgaWYgKGEueiA9PT0gYi56KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKGEuejIgPT09IGIuejIpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gRklYTUUgU2xvdyBoYXMgcmVuZGVyaWR4IGNvbXBhcmVcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDg4MzQyMS9zb3J0aW5nLWluLWphdmFzY3JpcHQtc2hvdWxkLWV2ZXJ5LWNvbXBhcmUtZnVuY3Rpb24taGF2ZS1hLXJldHVybi0wLXN0YXRlbWVudFxuICAgICAgICAgICAgICAgIC8vICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdjgvdjgvYmxvYi80N2NjZTU0NGEzMWVkNTU3N2ZmZTI5NjNmNjdhY2I0MTQ0ZWUwMjMyL3NyYy9qcy9hcnJheS5qcyNMMTAxMlxuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gYS5fX3JlbmRlcmlkeCAtIGIuX19yZW5kZXJpZHg7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIHJldHVybiBhLnoyIC0gYi56MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhLnogLSBiLno7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEuemxldmVsIC0gYi56bGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWGheWuueS7k+W6kyAoTSlcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvU3RvcmFnZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBTdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yb290cyA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0ID0gW107XG5cbiAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuICAgIH07XG5cbiAgICBTdG9yYWdlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogU3RvcmFnZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdHNbaV0udHJhdmVyc2UoY2IsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDov5Tlm57miYDmnInlm77lvaLnmoTnu5jliLbpmJ/liJdcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlPWZhbHNlXSDmmK/lkKblnKjov5Tlm57liY3mm7TmlrDor6XmlbDnu4RcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUlnbm9yZT1mYWxzZV0g5piv5ZCm5YyF5ZCrIGlnbm9yZSDnmoTmlbDnu4QsIOWcqCB1cGRhdGUg5Li6IHRydWUg55qE5pe25YCZ5pyJ5pWIXG4gICAgICAgICAqXG4gICAgICAgICAqIOivpuingXtAbGluayBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5TGlzdH1cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGU+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RGlzcGxheUxpc3Q6IGZ1bmN0aW9uICh1cGRhdGUsIGluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgICAgIGluY2x1ZGVJZ25vcmUgPSBpbmNsdWRlSWdub3JlIHx8IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRGlzcGxheUxpc3QoaW5jbHVkZUlnbm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGxheUxpc3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOabtOaWsOWbvuW9oueahOe7mOWItumYn+WIl+OAglxuICAgICAgICAgKiDmr4/mrKHnu5jliLbliY3pg73kvJrosIPnlKjvvIzor6Xmlrnms5XkvJrlhYjmt7HluqbkvJjlhYjpgY3ljobmlbTkuKrmoJHvvIzmm7TmlrDmiYDmnIlHcm91cOWSjFNoYXBl55qE5Y+Y5o2i5bm25LiU5oqK5omA5pyJ5Y+v6KeB55qEU2hhcGXkv53lrZjliLDmlbDnu4TkuK3vvIxcbiAgICAgICAgICog5pyA5ZCO5qC55o2u57uY5Yi255qE5LyY5YWI57qn77yIemxldmVsID4geiA+IOaPkuWFpemhuuW6j++8ieaOkuW6j+W+l+WIsOe7mOWItumYn+WIl1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSWdub3JlPWZhbHNlXSDmmK/lkKbljIXlkKsgaWdub3JlIOeahOaVsOe7hFxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlRGlzcGxheUxpc3Q6IGZ1bmN0aW9uIChpbmNsdWRlSWdub3JlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgICAgICAgICB2YXIgcm9vdHMgPSB0aGlzLl9yb290cztcbiAgICAgICAgICAgIHZhciBkaXNwbGF5TGlzdCA9IHRoaXMuX2Rpc3BsYXlMaXN0O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvb3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQW5kQWRkRGlzcGxheWFibGUocm9vdHNbaV0sIG51bGwsIGluY2x1ZGVJZ25vcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGxheUxpc3QubGVuZ3RoID0gdGhpcy5fZGlzcGxheUxpc3RMZW47XG5cbiAgICAgICAgICAgIC8vIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkaXNwbGF5TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgLy8gICAgIGRpc3BsYXlMaXN0W2ldLl9fcmVuZGVyaWR4ID0gaTtcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgLy8gZGlzcGxheUxpc3Quc29ydChzaGFwZUNvbXBhcmVGdW5jKTtcbiAgICAgICAgICAgIGVudi5jYW52YXNTdXBwb3J0ZWQgJiYgdGltc29ydChkaXNwbGF5TGlzdCwgc2hhcGVDb21wYXJlRnVuYyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZUFuZEFkZERpc3BsYXlhYmxlOiBmdW5jdGlvbiAoZWwsIGNsaXBQYXRocywgaW5jbHVkZUlnbm9yZSkge1xuXG4gICAgICAgICAgICBpZiAoZWwuaWdub3JlICYmICFpbmNsdWRlSWdub3JlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbC5iZWZvcmVVcGRhdGUoKTtcblxuICAgICAgICAgICAgaWYgKGVsLl9fZGlydHkpIHtcblxuICAgICAgICAgICAgICAgIGVsLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLmFmdGVyVXBkYXRlKCk7XG5cbiAgICAgICAgICAgIHZhciB1c2VyU2V0Q2xpcFBhdGggPSBlbC5jbGlwUGF0aDtcbiAgICAgICAgICAgIGlmICh1c2VyU2V0Q2xpcFBhdGgpIHtcblxuICAgICAgICAgICAgICAgIC8vIEZJWE1FIOaViOeOh+W9seWTjVxuICAgICAgICAgICAgICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcFBhdGhzID0gY2xpcFBhdGhzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudENsaXBQYXRoID0gdXNlclNldENsaXBQYXRoO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRDbGlwUGF0aCA9IGVsO1xuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGFkZCBjbGlwIHBhdGhcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudENsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaXBQYXRoIOeahOWPmOaNouaYr+WfuuS6juS9v+eUqOi/meS4qiBjbGlwUGF0aCDnmoTlhYPntKBcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENsaXBQYXRoLnBhcmVudCA9IHBhcmVudENsaXBQYXRoO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2xpcFBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2xpcFBhdGhzLnB1c2goY3VycmVudENsaXBQYXRoKTtcblxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDbGlwUGF0aCA9IGN1cnJlbnRDbGlwUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENsaXBQYXRoID0gY3VycmVudENsaXBQYXRoLmNsaXBQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsLmlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbC5fY2hpbGRyZW47XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIHRvIG1hcmsgYXMgZGlydHkgaWYgZ3JvdXAgaXMgZGlydHlcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgX19kaXJ0eVBhdGggP1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShjaGlsZCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYXJrIGdyb3VwIGNsZWFuIGhlcmVcbiAgICAgICAgICAgICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLl9fY2xpcFBhdGhzID0gY2xpcFBhdGhzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RbdGhpcy5fZGlzcGxheUxpc3RMZW4rK10gPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5Zu+5b2iKFNoYXBlKeaIluiAhee7hChHcm91cCnliLDmoLnoioLngrlcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkUm9vdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwuX19zdG9yYWdlID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgIGVsLmFkZENoaWxkcmVuVG9TdG9yYWdlKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFkZFRvU3RvcmFnZShlbCk7XG4gICAgICAgICAgICB0aGlzLl9yb290cy5wdXNoKGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5oyH5a6a55qE5Zu+5b2iKFNoYXBlKeaIluiAhee7hChHcm91cClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtlbF0g5aaC5p6c5Li656m65riF56m65pW05LiqU3RvcmFnZVxuICAgICAgICAgKi9cbiAgICAgICAgZGVsUm9vdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIOS4jeaMh+WummVs5riF56m6XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3RzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAocm9vdCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290LmRlbENoaWxkcmVuRnJvbVN0b3JhZ2UodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yb290cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsUm9vdChlbFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB2YXIgaWR4ID0gdXRpbC5pbmRleE9mKHRoaXMuX3Jvb3RzLCBlbCk7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbEZyb21TdG9yYWdlKGVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZGRUb1N0b3JhZ2U6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgZWwuX19zdG9yYWdlID0gdGhpcztcbiAgICAgICAgICAgIGVsLmRpcnR5KGZhbHNlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsRnJvbVN0b3JhZ2U6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgZWwuX19zdG9yYWdlID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4heepuuW5tuS4lOmHiuaUvlN0b3JhZ2VcbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckxpc3QgPVxuICAgICAgICAgICAgdGhpcy5fcm9vdHMgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3BsYXlhYmxlU29ydEZ1bmM6IHNoYXBlQ29tcGFyZUZ1bmNcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTdG9yYWdlO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL1N0b3JhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9temljY2FyZC9ub2RlLXRpbXNvcnRcblxuICAgIHZhciBERUZBVUxUX01JTl9NRVJHRSA9IDMyO1xuXG4gICAgdmFyIERFRkFVTFRfTUlOX0dBTExPUElORyA9IDc7XG5cbiAgICB2YXIgREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEggPSAyNTY7XG5cbiAgICBmdW5jdGlvbiBtaW5SdW5MZW5ndGgobikge1xuICAgICAgICB2YXIgciA9IDA7XG5cbiAgICAgICAgd2hpbGUgKG4gPj0gREVGQVVMVF9NSU5fTUVSR0UpIHtcbiAgICAgICAgICAgIHIgfD0gbiAmIDE7XG4gICAgICAgICAgICBuID4+PSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG4gKyByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSkge1xuICAgICAgICB2YXIgcnVuSGkgPSBsbyArIDE7XG5cbiAgICAgICAgaWYgKHJ1bkhpID09PSBoaSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGFyZShhcnJheVtydW5IaSsrXSwgYXJyYXlbbG9dKSA8IDApIHtcbiAgICAgICAgICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA8IDApIHtcbiAgICAgICAgICAgICAgICBydW5IaSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXZlcnNlUnVuKGFycmF5LCBsbywgcnVuSGkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKHJ1bkhpIDwgaGkgJiYgY29tcGFyZShhcnJheVtydW5IaV0sIGFycmF5W3J1bkhpIC0gMV0pID49IDApIHtcbiAgICAgICAgICAgICAgICBydW5IaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJ1bkhpIC0gbG87XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmV2ZXJzZVJ1bihhcnJheSwgbG8sIGhpKSB7XG4gICAgICAgIGhpLS07XG5cbiAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICAgIHZhciB0ID0gYXJyYXlbbG9dO1xuICAgICAgICAgICAgYXJyYXlbbG8rK10gPSBhcnJheVtoaV07XG4gICAgICAgICAgICBhcnJheVtoaS0tXSA9IHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgaGksIHN0YXJ0LCBjb21wYXJlKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gbG8pIHtcbiAgICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgc3RhcnQgPCBoaTsgc3RhcnQrKykge1xuICAgICAgICAgICAgdmFyIHBpdm90ID0gYXJyYXlbc3RhcnRdO1xuXG4gICAgICAgICAgICB2YXIgbGVmdCA9IGxvO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gc3RhcnQ7XG4gICAgICAgICAgICB2YXIgbWlkO1xuXG4gICAgICAgICAgICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgbWlkID0gbGVmdCArIHJpZ2h0ID4+PiAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUocGl2b3QsIGFycmF5W21pZF0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IG1pZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG4gPSBzdGFydCAtIGxlZnQ7XG5cbiAgICAgICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIDNdID0gYXJyYXlbbGVmdCArIDJdO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBhcnJheVtsZWZ0ICsgMl0gPSBhcnJheVtsZWZ0ICsgMV07XG5cbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2xlZnQgKyAxXSA9IGFycmF5W2xlZnRdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2xlZnQgKyBuXSA9IGFycmF5W2xlZnQgKyBuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJyYXlbbGVmdF0gPSBwaXZvdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdhbGxvcExlZnQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gICAgICAgIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG1heE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSAxO1xuXG4gICAgICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA+IDApIHtcbiAgICAgICAgICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0T2Zmc2V0ICs9IGhpbnQ7XG4gICAgICAgICAgICBvZmZzZXQgKz0gaGludDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRtcCA9IGxhc3RPZmZzZXQ7XG4gICAgICAgICAgICBsYXN0T2Zmc2V0ID0gaGludCAtIG9mZnNldDtcbiAgICAgICAgICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0T2Zmc2V0Kys7XG4gICAgICAgIHdoaWxlIChsYXN0T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICAgICAgICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIG1dKSA+IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gbSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2FsbG9wUmlnaHQodmFsdWUsIGFycmF5LCBzdGFydCwgbGVuZ3RoLCBoaW50LCBjb21wYXJlKSB7XG4gICAgICAgIHZhciBsYXN0T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG1heE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSAxO1xuXG4gICAgICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnRdKSA8IDApIHtcbiAgICAgICAgICAgIG1heE9mZnNldCA9IGhpbnQgKyAxO1xuXG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCAtIG9mZnNldF0pIDwgMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRtcCA9IGxhc3RPZmZzZXQ7XG4gICAgICAgICAgICBsYXN0T2Zmc2V0ID0gaGludCAtIG9mZnNldDtcbiAgICAgICAgICAgIG9mZnNldCA9IGhpbnQgLSB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXhPZmZzZXQgPSBsZW5ndGggLSBoaW50O1xuXG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCArIG9mZnNldF0pID49IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RPZmZzZXQgKz0gaGludDtcbiAgICAgICAgICAgIG9mZnNldCArPSBoaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdE9mZnNldCsrO1xuXG4gICAgICAgIHdoaWxlIChsYXN0T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgbSA9IGxhc3RPZmZzZXQgKyAob2Zmc2V0IC0gbGFzdE9mZnNldCA+Pj4gMSk7XG5cbiAgICAgICAgICAgIGlmIChjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIG1dKSA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBUaW1Tb3J0KGFycmF5LCBjb21wYXJlKSB7XG4gICAgICAgIHZhciBtaW5HYWxsb3AgPSBERUZBVUxUX01JTl9HQUxMT1BJTkc7XG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgICB2YXIgdG1wU3RvcmFnZUxlbmd0aCA9IERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIO1xuICAgICAgICB2YXIgc3RhY2tMZW5ndGggPSAwO1xuICAgICAgICB2YXIgcnVuU3RhcnQ7XG4gICAgICAgIHZhciBydW5MZW5ndGg7XG4gICAgICAgIHZhciBzdGFja1NpemUgPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMiAqIERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIKSB7XG4gICAgICAgICAgICB0bXBTdG9yYWdlTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRtcCA9IFtdO1xuXG4gICAgICAgIHN0YWNrTGVuZ3RoID0gbGVuZ3RoIDwgMTIwID8gNSA6IGxlbmd0aCA8IDE1NDIgPyAxMCA6IGxlbmd0aCA8IDExOTE1MSA/IDE5IDogNDA7XG5cbiAgICAgICAgcnVuU3RhcnQgPSBbXTtcbiAgICAgICAgcnVuTGVuZ3RoID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gcHVzaFJ1bihfcnVuU3RhcnQsIF9ydW5MZW5ndGgpIHtcbiAgICAgICAgICAgIHJ1blN0YXJ0W3N0YWNrU2l6ZV0gPSBfcnVuU3RhcnQ7XG4gICAgICAgICAgICBydW5MZW5ndGhbc3RhY2tTaXplXSA9IF9ydW5MZW5ndGg7XG4gICAgICAgICAgICBzdGFja1NpemUgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlUnVucygpIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFja1NpemUgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBzdGFja1NpemUgLSAyO1xuXG4gICAgICAgICAgICAgICAgaWYgKG4gPj0gMSAmJiBydW5MZW5ndGhbbiAtIDFdIDw9IHJ1bkxlbmd0aFtuXSArIHJ1bkxlbmd0aFtuICsgMV0gfHwgbiA+PSAyICYmIHJ1bkxlbmd0aFtuIC0gMl0gPD0gcnVuTGVuZ3RoW25dICsgcnVuTGVuZ3RoW24gLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVuTGVuZ3RoW24gLSAxXSA8IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChydW5MZW5ndGhbbl0gPiBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXJnZUF0KG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZm9yY2VNZXJnZVJ1bnMoKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2tTaXplID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gc3RhY2tTaXplIC0gMjtcblxuICAgICAgICAgICAgICAgIGlmIChuID4gMCAmJiBydW5MZW5ndGhbbiAtIDFdIDwgcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWVyZ2VBdChuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlQXQoaSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0MSA9IHJ1blN0YXJ0W2ldO1xuICAgICAgICAgICAgdmFyIGxlbmd0aDEgPSBydW5MZW5ndGhbaV07XG4gICAgICAgICAgICB2YXIgc3RhcnQyID0gcnVuU3RhcnRbaSArIDFdO1xuICAgICAgICAgICAgdmFyIGxlbmd0aDIgPSBydW5MZW5ndGhbaSArIDFdO1xuXG4gICAgICAgICAgICBydW5MZW5ndGhbaV0gPSBsZW5ndGgxICsgbGVuZ3RoMjtcblxuICAgICAgICAgICAgaWYgKGkgPT09IHN0YWNrU2l6ZSAtIDMpIHtcbiAgICAgICAgICAgICAgICBydW5TdGFydFtpICsgMV0gPSBydW5TdGFydFtpICsgMl07XG4gICAgICAgICAgICAgICAgcnVuTGVuZ3RoW2kgKyAxXSA9IHJ1bkxlbmd0aFtpICsgMl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YWNrU2l6ZS0tO1xuXG4gICAgICAgICAgICB2YXIgayA9IGdhbGxvcFJpZ2h0KGFycmF5W3N0YXJ0Ml0sIGFycmF5LCBzdGFydDEsIGxlbmd0aDEsIDAsIGNvbXBhcmUpO1xuICAgICAgICAgICAgc3RhcnQxICs9IGs7XG4gICAgICAgICAgICBsZW5ndGgxIC09IGs7XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZW5ndGgyID0gZ2FsbG9wTGVmdChhcnJheVtzdGFydDEgKyBsZW5ndGgxIC0gMV0sIGFycmF5LCBzdGFydDIsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgxIDw9IGxlbmd0aDIpIHtcbiAgICAgICAgICAgICAgICBtZXJnZUxvdyhzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZUhpZ2goc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpIHtcbiAgICAgICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHRtcFtpXSA9IGFycmF5W3N0YXJ0MSArIGldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3Vyc29yMSA9IDA7XG4gICAgICAgICAgICB2YXIgY3Vyc29yMiA9IHN0YXJ0MjtcbiAgICAgICAgICAgIHZhciBkZXN0ID0gc3RhcnQxO1xuXG4gICAgICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcblxuICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX21pbkdhbGxvcCA9IG1pbkdhbGxvcDtcbiAgICAgICAgICAgIHZhciBjb3VudDEsIGNvdW50MiwgZXhpdDtcblxuICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICBjb3VudDEgPSAwO1xuICAgICAgICAgICAgICAgIGNvdW50MiA9IDA7XG4gICAgICAgICAgICAgICAgZXhpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShhcnJheVtjdXJzb3IyXSwgdG1wW2N1cnNvcjFdKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDEgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0KytdID0gdG1wW2N1cnNvcjErK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDErKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICgoY291bnQxIHwgY291bnQyKSA8IF9taW5HYWxsb3ApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDEgPSBnYWxsb3BSaWdodChhcnJheVtjdXJzb3IyXSwgdG1wLCBjdXJzb3IxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0ICs9IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjEgKz0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY291bnQyID0gZ2FsbG9wTGVmdCh0bXBbY3Vyc29yMV0sIGFycmF5LCBjdXJzb3IyLCBsZW5ndGgyLCAwLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3QgKz0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yMiArPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGgyIC09IGNvdW50MjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0KytdID0gdG1wW2N1cnNvcjErK107XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9taW5HYWxsb3AtLTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9taW5HYWxsb3AgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF9taW5HYWxsb3AgPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9taW5HYWxsb3AgKz0gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWluR2FsbG9wID0gX21pbkdhbGxvcDtcblxuICAgICAgICAgICAgbWluR2FsbG9wIDwgMSAmJiAobWluR2FsbG9wID0gMSk7XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSBhcnJheVtjdXJzb3IyICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBsZW5ndGgyXSA9IHRtcFtjdXJzb3IxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ21lcmdlTG93IHByZWNvbmRpdGlvbnMgd2VyZSBub3QgcmVzcGVjdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VIaWdoIChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQyICsgaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjdXJzb3IxID0gc3RhcnQxICsgbGVuZ3RoMSAtIDE7XG4gICAgICAgICAgICB2YXIgY3Vyc29yMiA9IGxlbmd0aDIgLSAxO1xuICAgICAgICAgICAgdmFyIGRlc3QgPSBzdGFydDIgKyBsZW5ndGgyIC0gMTtcbiAgICAgICAgICAgIHZhciBjdXN0b21DdXJzb3IgPSAwO1xuICAgICAgICAgICAgdmFyIGN1c3RvbURlc3QgPSAwO1xuXG4gICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21DdXJzb3IgKyBpXSA9IHRtcFtpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGVzdCAtPSBsZW5ndGgxO1xuICAgICAgICAgICAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMSArIDE7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdF0gPSB0bXBbY3Vyc29yMl07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX21pbkdhbGxvcCA9IG1pbkdhbGxvcDtcblxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQxID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQyID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgZXhpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZSh0bXBbY3Vyc29yMl0sIGFycmF5W2N1cnNvcjFdKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IHRtcFtjdXJzb3IyLS1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDEgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBfbWluR2FsbG9wKTtcblxuICAgICAgICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQxID0gbGVuZ3RoMSAtIGdhbGxvcFJpZ2h0KHRtcFtjdXJzb3IyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgbGVuZ3RoMSAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3QgLT0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yMSAtPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGgxIC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBjb3VudDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IHRtcFtjdXJzb3IyLS1dO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb3VudDIgPSBsZW5ndGgyIC0gZ2FsbG9wTGVmdChhcnJheVtjdXJzb3IxXSwgdG1wLCAwLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCAtPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IyIC09IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDIgLT0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMiArIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IHRtcFtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9taW5HYWxsb3AtLTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9taW5HYWxsb3AgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF9taW5HYWxsb3AgPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9taW5HYWxsb3AgKz0gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWluR2FsbG9wID0gX21pbkdhbGxvcDtcblxuICAgICAgICAgICAgaWYgKG1pbkdhbGxvcCA8IDEpIHtcbiAgICAgICAgICAgICAgICBtaW5HYWxsb3AgPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRlc3QgLT0gbGVuZ3RoMTtcbiAgICAgICAgICAgICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICAgICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcignbWVyZ2VIaWdoIHByZWNvbmRpdGlvbnMgd2VyZSBub3QgcmVzcGVjdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBkZXN0IC0gKGxlbmd0aDIgLSAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWVyZ2VSdW5zID0gbWVyZ2VSdW5zO1xuICAgICAgICB0aGlzLmZvcmNlTWVyZ2VSdW5zID0gZm9yY2VNZXJnZVJ1bnM7XG4gICAgICAgIHRoaXMucHVzaFJ1biA9IHB1c2hSdW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydChhcnJheSwgY29tcGFyZSwgbG8sIGhpKSB7XG4gICAgICAgIGlmICghbG8pIHtcbiAgICAgICAgICAgIGxvID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhpKSB7XG4gICAgICAgICAgICBoaSA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW1haW5pbmcgPSBoaSAtIGxvO1xuXG4gICAgICAgIGlmIChyZW1haW5pbmcgPCAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcnVuTGVuZ3RoID0gMDtcblxuICAgICAgICBpZiAocmVtYWluaW5nIDwgREVGQVVMVF9NSU5fTUVSR0UpIHtcbiAgICAgICAgICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG4gICAgICAgICAgICBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgaGksIGxvICsgcnVuTGVuZ3RoLCBjb21wYXJlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0cyA9IG5ldyBUaW1Tb3J0KGFycmF5LCBjb21wYXJlKTtcblxuICAgICAgICB2YXIgbWluUnVuID0gbWluUnVuTGVuZ3RoKHJlbWFpbmluZyk7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcnVuTGVuZ3RoID0gbWFrZUFzY2VuZGluZ1J1bihhcnJheSwgbG8sIGhpLCBjb21wYXJlKTtcbiAgICAgICAgICAgIGlmIChydW5MZW5ndGggPCBtaW5SdW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9yY2UgPSByZW1haW5pbmc7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlID4gbWluUnVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlID0gbWluUnVuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBsbyArIGZvcmNlLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgICAgICAgICAgICAgcnVuTGVuZ3RoID0gZm9yY2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRzLnB1c2hSdW4obG8sIHJ1bkxlbmd0aCk7XG4gICAgICAgICAgICB0cy5tZXJnZVJ1bnMoKTtcblxuICAgICAgICAgICAgcmVtYWluaW5nIC09IHJ1bkxlbmd0aDtcbiAgICAgICAgICAgIGxvICs9IHJ1bkxlbmd0aDtcbiAgICAgICAgfSB3aGlsZSAocmVtYWluaW5nICE9PSAwKTtcblxuICAgICAgICB0cy5mb3JjZU1lcmdlUnVucygpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gc29ydDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvY29yZS90aW1zb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOWKqOeUu+S4u+exuywg6LCD5bqm5ZKM566h55CG5omA5pyJ5Yqo55S75o6n5Yi25ZmoXG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25cbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuLy8gVE9ETyBBZGRpdGl2ZSBhbmltYXRpb25cbi8vIGh0dHA6Ly9pb3NvdGVyaWMuY29tL2FkZGl0aXZlLWFuaW1hdGlvbnMtYW5pbWF0ZXdpdGhkdXJhdGlvbi1pbi1pb3MtOC9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS92aWRlb3Mvd3dkYzIwMTQvIzIzNlxuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpLkRpc3BhdGNoZXI7XG5cbiAgICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgnLi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcblxuICAgIHZhciBBbmltYXRvciA9IHJlcXVpcmUoJy4vQW5pbWF0b3InKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBJWlJlbmRlclN0YWdlXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXBkYXRlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbmZyYW1lXVxuICAgICAqIEBwYXJhbSB7SVpSZW5kZXJTdGFnZX0gW29wdGlvbnMuc3RhZ2VdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgdmFyIGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oKTtcbiAgICAgKiAgICAgdmFyIG9iaiA9IHtcbiAgICAgKiAgICAgICAgIHg6IDEwMCxcbiAgICAgKiAgICAgICAgIHk6IDEwMFxuICAgICAqICAgICB9O1xuICAgICAqICAgICBhbmltYXRpb24uYW5pbWF0ZShub2RlLnBvc2l0aW9uKVxuICAgICAqICAgICAgICAgLndoZW4oMTAwMCwge1xuICAgICAqICAgICAgICAgICAgIHg6IDUwMCxcbiAgICAgKiAgICAgICAgICAgICB5OiA1MDBcbiAgICAgKiAgICAgICAgIH0pXG4gICAgICogICAgICAgICAud2hlbigyMDAwLCB7XG4gICAgICogICAgICAgICAgICAgeDogMTAwLFxuICAgICAqICAgICAgICAgICAgIHk6IDEwMFxuICAgICAqICAgICAgICAgfSlcbiAgICAgKiAgICAgICAgIC5zdGFydCgnc3BsaW5lJyk7XG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5zdGFnZSA9IG9wdGlvbnMuc3RhZ2UgfHwge307XG5cbiAgICAgICAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICAgICAgLy8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMuX2NsaXBzID0gW107XG5cbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3RpbWU7XG5cbiAgICAgICAgdGhpcy5fcGF1c2VkVGltZTtcblxuICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0O1xuXG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIERpc3BhdGNoZXIuY2FsbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQW5pbWF0aW9uLFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75YqgIGNsaXBcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQ2xpcDogZnVuY3Rpb24gKGNsaXApIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaXBzLnB1c2goY2xpcCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqAgYW5pbWF0b3JcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9IGFuaW1hdG9yXG4gICAgICAgICAqL1xuICAgICAgICBhZGRBbmltYXRvcjogZnVuY3Rpb24gKGFuaW1hdG9yKSB7XG4gICAgICAgICAgICBhbmltYXRvci5hbmltYXRpb24gPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNsaXBzID0gYW5pbWF0b3IuZ2V0Q2xpcHMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENsaXAoY2xpcHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXB9IGNsaXBcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNsaXA6IGZ1bmN0aW9uKGNsaXApIHtcbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fY2xpcHMsIGNsaXApO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpcHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIoOmZpOWKqOeUu+eJh+autVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICAgICAgICAgIHZhciBjbGlwcyA9IGFuaW1hdG9yLmdldENsaXBzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDbGlwKGNsaXBzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHZhciB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9wYXVzZWRUaW1lO1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gdGltZSAtIHRoaXMuX3RpbWU7XG4gICAgICAgICAgICB2YXIgY2xpcHMgPSB0aGlzLl9jbGlwcztcbiAgICAgICAgICAgIHZhciBsZW4gPSBjbGlwcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHZhciBkZWZlcnJlZEV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkQ2xpcHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IGNsaXBzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBlID0gY2xpcC5zdGVwKHRpbWUsIGRlbHRhKTtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBvdXQgdGhlIGV2ZW50cyBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlclxuICAgICAgICAgICAgICAgIC8vIHN0YWdlLnVwZGF0ZSwgbGlrZSBkZXN0cm95XG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRFdmVudHMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDbGlwcy5wdXNoKGNsaXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBmaW5pc2hlZCBjbGlwXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xpcHNbaV0uX25lZWRzUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBzW2ldID0gY2xpcHNbbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGNsaXBzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlbiA9IGRlZmVycmVkRXZlbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZENsaXBzW2ldLmZpcmUoZGVmZXJyZWRFdmVudHNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl90aW1lID0gdGltZTtcblxuICAgICAgICAgICAgdGhpcy5vbmZyYW1lKGRlbHRhKTtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdmcmFtZScsIGRlbHRhKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhZ2UudXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfc3RhcnRMb29wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9ydW5uaW5nKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLl9wYXVzZWQgJiYgc2VsZi5fdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8gOWni+i/kOihjOWKqOeUu1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdGhpcy5fdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0TG9vcCgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5YGc5q2i6L+Q6KGM5Yqo55S7XG4gICAgICAgICAqL1xuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhdXNlXG4gICAgICAgICAqL1xuICAgICAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzdW1lXG4gICAgICAgICAqL1xuICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZWRUaW1lICs9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSkgLSB0aGlzLl9wYXVzZVN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaTmiYDmnInliqjnlLvniYfmrrVcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGlwcyA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5a+55LiA5Liq55uu5qCH5Yib5bu65LiA5LiqYW5pbWF0b3Llr7nosaHvvIzlj6/ku6XmjIflrprnm67moIfkuK3nmoTlsZ7mgKfkvb/nlKjliqjnlLtcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmxvb3A9ZmFsc2VdIOaYr+WQpuW+queOr+aSreaUvuWKqOeUu1xuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2V0dGVyPW51bGxdXG4gICAgICAgICAqICAgICAgICAg5aaC5p6c5oyH5a6aZ2V0dGVy5Ye95pWw77yM5Lya6YCa6L+HZ2V0dGVy5Ye95pWw5Y+W5bGe5oCn5YC8XG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb3B0aW9ucy5zZXR0ZXI9bnVsbF1cbiAgICAgICAgICogICAgICAgICDlpoLmnpzmjIflrppzZXR0ZXLlh73mlbDvvIzkvJrpgJrov4dzZXR0ZXLlh73mlbDorr7nva7lsZ7mgKflgLxcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvbn5BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE8gR2FwXG4gICAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9vcCxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmdldHRlcixcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNldHRlclxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5hZGRBbmltYXRvcihhbmltYXRvcik7XG5cbiAgICAgICAgICAgIHJldHVybiBhbmltYXRvcjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB1dGlsLm1peGluKEFuaW1hdGlvbiwgRGlzcGF0Y2hlcik7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGlvbjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOS6i+S7tui+heWKqeexu1xuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvZXZlbnRcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICovXG5cblxuICAgIHZhciBFdmVudGZ1bCA9IHJlcXVpcmUoJy4uL21peGluL0V2ZW50ZnVsJyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJy4vZW52Jyk7XG5cbiAgICB2YXIgaXNEb21MZXZlbDIgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpICYmICEhd2luZG93LmFkZEV2ZW50TGlzdGVuZXI7XG5cbiAgICB2YXIgTU9VU0VfRVZFTlRfUkVHID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svO1xuXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gICAgICAgIC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSkgZG9uJ3QgaGF2ZSBnZXRCb3VuZGluZ1JlY3RcbiAgICAgICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge2xlZnQ6IDAsIHRvcDogMH07XG4gICAgfVxuXG4gICAgLy8gYGNhbGN1bGF0ZWAgaXMgb3B0aW9uYWwsIGRlZmF1bHQgZmFsc2VcbiAgICBmdW5jdGlvbiBjbGllbnRUb0xvY2FsKGVsLCBlLCBvdXQsIGNhbGN1bGF0ZSkge1xuICAgICAgICBvdXQgPSBvdXQgfHwge307XG5cbiAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBXM0MgV29ya2luZyBEcmFmdCwgb2Zmc2V0WCBhbmQgb2Zmc2V0WSBzaG91bGQgYmUgcmVsYXRpdmVcbiAgICAgICAgLy8gdG8gdGhlIHBhZGRpbmcgZWRnZSBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuIFRoZSBvbmx5IGJyb3dzZXIgdXNpbmcgdGhpcyBjb252ZW50aW9uXG4gICAgICAgIC8vIGlzIElFLiBXZWJraXQgdXNlcyB0aGUgYm9yZGVyIGVkZ2UsIE9wZXJhIHVzZXMgdGhlIGNvbnRlbnQgZWRnZSwgYW5kIEZpcmVGb3ggZG9lc1xuICAgICAgICAvLyBub3Qgc3VwcG9ydCB0aGUgcHJvcGVydGllcy5cbiAgICAgICAgLy8gKHNlZSBodHRwOi8vd3d3LmphY2tsbW9vcmUuY29tL25vdGVzL21vdXNlLXBvc2l0aW9uLylcbiAgICAgICAgLy8gSW4genIgcGFpbnRlci5kb20sIHBhZGRpbmcgZWRnZSBlcXVhbHMgdG8gYm9yZGVyIGVkZ2UuXG5cbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgLy8gV2hlbiBtb3VzZW1vdmUgZXZlbnQgdHJpZ2dlcmVkIG9uIGVjIHRvb2x0aXAsIHRhcmdldCBpcyBub3QgenIgcGFpbnRlci5kb20sIGFuZFxuICAgICAgICAvLyBvZmZzZXRYL1kgaXMgcmVsYXRpdmUgdG8gZS50YXJnZXQsIHdoZXJlIHRoZSBjYWxjdWxhdGlvbiBvZiB6clgvWSB2aWEgb2Zmc2V0WC9ZXG4gICAgICAgIC8vIGlzIHRvbyBjb21wbGV4LiBTbyBjc3MtdHJhbnNmcm9tIGRvbnQgc3VwcG9ydCBpbiB0aGlzIGNhc2UgdGVtcG9yYXJpbHkuXG4gICAgICAgIGlmIChjYWxjdWxhdGUgfHwgIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhdXRpb246IEluIEZpcmVGb3gsIGxheWVyWC9sYXllclkgTW91c2UgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGNsb3Nlc3QgcG9zaXRpb25lZFxuICAgICAgICAvLyBhbmNlc3RvciBlbGVtZW50LCBzbyB3ZSBzaG91bGQgbWFrZSBzdXJlIGVsIGlzIHBvc2l0aW9uZWQgKGUuZy4sIG5vdCBwb3NpdGlvbjpzdGF0aWMpLlxuICAgICAgICAvLyBCVFcxLCBXZWJraXQgZG9uJ3QgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdHMgYXMgRkYgaW4gbm9uLXNpbXBsZSBjYXNlcyAobGlrZSBhZGRcbiAgICAgICAgLy8gem9vbS1mYWN0b3IsIG92ZXJmbG93IC8gb3BhY2l0eSBsYXllcnMsIHRyYW5zZm9ybXMgLi4uKVxuICAgICAgICAvLyBCVFcyLCAoZXYub2Zmc2V0WSB8fCBldi5wYWdlWSAtICQoZXYudGFyZ2V0KS5vZmZzZXQoKS50b3ApIGlzIG5vdCBjb3JyZWN0IGluIHByZXNlcnZlLTNkLlxuICAgICAgICAvLyA8aHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzg1MjMjY29tbWVudDoxND5cbiAgICAgICAgLy8gQlRXMywgSW4gZmYsIG9mZnNldFgvb2Zmc2V0WSBpcyBhbHdheXMgMC5cbiAgICAgICAgZWxzZSBpZiAoZW52LmJyb3dzZXIuZmlyZWZveCAmJiBlLmxheWVyWCAhPSBudWxsICYmIGUubGF5ZXJYICE9PSBlLm9mZnNldFgpIHtcbiAgICAgICAgICAgIG91dC56clggPSBlLmxheWVyWDtcbiAgICAgICAgICAgIG91dC56clkgPSBlLmxheWVyWTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgSUU2KywgY2hyb21lLCBzYWZhcmksIG9wZXJhLiAoV2hlbiB3aWxsIGZmIHN1cHBvcnQgb2Zmc2V0WD8pXG4gICAgICAgIGVsc2UgaWYgKGUub2Zmc2V0WCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvdXQuenJYID0gZS5vZmZzZXRYO1xuICAgICAgICAgICAgb3V0LnpyWSA9IGUub2Zmc2V0WTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3Igc29tZSBvdGhlciBkZXZpY2UsIGUuZy4sIElPUyBzYWZhcmkuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmYXVsdEdldFpyWFkoZWwsIGUsIG91dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRHZXRaclhZKGVsLCBlLCBvdXQpIHtcbiAgICAgICAgLy8gVGhpcyB3ZWxsLWtub3duIG1ldGhvZCBiZWxvdyBkb2VzIG5vdCBzdXBwb3J0IGNzcyB0cmFuc2Zvcm0uXG4gICAgICAgIHZhciBib3ggPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpO1xuICAgICAgICBvdXQuenJYID0gZS5jbGllbnRYIC0gYm94LmxlZnQ7XG4gICAgICAgIG91dC56clkgPSBlLmNsaWVudFkgLSBib3gudG9wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWmguaenOWtmOWcqOesrOS4ieaWueW1jOWFpeeahOS4gOS6m2RvbeinpuWPkeeahOS6i+S7tu+8jOaIlnRvdWNo5LqL5Lu277yM6ZyA6KaB6L2s5o2i5LiA5LiL5LqL5Lu25Z2Q5qCHLlxuICAgICAqIGBjYWxjdWxhdGVgIGlzIG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50KGVsLCBlLCBjYWxjdWxhdGUpIHtcblxuICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgaWYgKGUuenJYICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGUudHlwZTtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSBldmVudFR5cGUgJiYgZXZlbnRUeXBlLmluZGV4T2YoJ3RvdWNoJykgPj0gMDtcblxuICAgICAgICBpZiAoIWlzVG91Y2gpIHtcbiAgICAgICAgICAgIGNsaWVudFRvTG9jYWwoZWwsIGUsIGUsIGNhbGN1bGF0ZSk7XG4gICAgICAgICAgICBlLnpyRGVsdGEgPSAoZS53aGVlbERlbHRhKSA/IGUud2hlZWxEZWx0YSAvIDEyMCA6IC0oZS5kZXRhaWwgfHwgMCkgLyAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRvdWNoID0gZXZlbnRUeXBlICE9ICd0b3VjaGVuZCdcbiAgICAgICAgICAgICAgICA/IGUudGFyZ2V0VG91Y2hlc1swXVxuICAgICAgICAgICAgICAgIDogZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgICAgIHRvdWNoICYmIGNsaWVudFRvTG9jYWwoZWwsIHRvdWNoLCBlLCBjYWxjdWxhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodDsgb3RoZXJ3aXNlOiAwO1xuICAgICAgICAvLyBTZWUgalF1ZXJ5OiBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL21hc3Rlci9zcmMvZXZlbnQuanNcbiAgICAgICAgLy8gSWYgZS53aGljaCBoYXMgYmVlbiBkZWZpbmVkLCBpZiBtYXkgYmUgcmVhZG9ubHksXG4gICAgICAgIC8vIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvd2hpY2hcbiAgICAgICAgdmFyIGJ1dHRvbiA9IGUuYnV0dG9uO1xuICAgICAgICBpZiAoZS53aGljaCA9PSBudWxsICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIE1PVVNFX0VWRU5UX1JFRy50ZXN0KGUudHlwZSkpIHtcbiAgICAgICAgICAgIGUud2hpY2ggPSAoYnV0dG9uICYgMSA/IDEgOiAoYnV0dG9uICYgMiA/IDMgOiAoYnV0dG9uICYgNCA/IDIgOiAwKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAoaXNEb21MZXZlbDIpIHtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgbmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChpc0RvbUxldmVsMikge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLmRldGFjaEV2ZW50KCdvbicgKyBuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByZXZlbnREZWZhdWx0IGFuZCBzdG9wUHJvcGFnYXRpb24uXG4gICAgICogTm90aWNlOiBkbyBub3QgZG8gdGhhdCBpbiB6cmVuZGVyLiBVcHBlciBhcHBsaWNhdGlvblxuICAgICAqIGRvIHRoYXQgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvZXZlbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSA6IGV2ZW505a+56LGhXG4gICAgICovXG4gICAgdmFyIHN0b3AgPSBpc0RvbUxldmVsMlxuICAgICAgICA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgIGZ1bmN0aW9uIG5vdExlZnRNb3VzZShlKSB7XG4gICAgICAgIC8vIElmIGUud2hpY2ggaXMgdW5kZWZpbmVkLCBjb25zaWRlcmVkIGFzIGxlZnQgbW91c2UgZXZlbnQuXG4gICAgICAgIHJldHVybiBlLndoaWNoID4gMTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgY2xpZW50VG9Mb2NhbDogY2xpZW50VG9Mb2NhbCxcbiAgICAgICAgbm9ybWFsaXplRXZlbnQ6IG5vcm1hbGl6ZUV2ZW50LFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBhZGRFdmVudExpc3RlbmVyLFxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiByZW1vdmVFdmVudExpc3RlbmVyLFxuICAgICAgICBub3RMZWZ0TW91c2U6IG5vdExlZnRNb3VzZSxcblxuICAgICAgICBzdG9wOiBzdG9wLFxuICAgICAgICAvLyDlgZrlkJHkuIrlhbzlrrlcbiAgICAgICAgRGlzcGF0Y2hlcjogRXZlbnRmdWxcbiAgICB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2NvcmUvZXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAoKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykpXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2lzc3Vlcy8xODkjaXNzdWVjb21tZW50LTIyNDkxOTgwOVxuICAgICAgICAgICAgICAgIHx8ICh3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSlcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHx8IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jLCAxNik7XG4gICAgICAgICAgICB9O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuXG4gICAgdmFyIGV2ZW50VG9vbCA9IHJlcXVpcmUoJy4uL2NvcmUvZXZlbnQnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi4vbWl4aW4vRXZlbnRmdWwnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi4vY29yZS9lbnYnKTtcbiAgICB2YXIgR2VzdHVyZU1nciA9IHJlcXVpcmUoJy4uL2NvcmUvR2VzdHVyZU1ncicpO1xuXG4gICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBldmVudFRvb2wuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGV2ZW50VG9vbC5yZW1vdmVFdmVudExpc3RlbmVyO1xuICAgIHZhciBub3JtYWxpemVFdmVudCA9IGV2ZW50VG9vbC5ub3JtYWxpemVFdmVudDtcblxuICAgIHZhciBUT1VDSF9DTElDS19ERUxBWSA9IDMwMDtcblxuICAgIHZhciBtb3VzZUhhbmRsZXJOYW1lcyA9IFtcbiAgICAgICAgJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLFxuICAgICAgICAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J1xuICAgIF07XG5cbiAgICB2YXIgdG91Y2hIYW5kbGVyTmFtZXMgPSBbXG4gICAgICAgICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZSdcbiAgICBdO1xuXG4gICAgdmFyIHBvaW50ZXJFdmVudE5hbWVzID0ge1xuICAgICAgICBwb2ludGVyZG93bjogMSwgcG9pbnRlcnVwOiAxLCBwb2ludGVybW92ZTogMSwgcG9pbnRlcm91dDogMVxuICAgIH07XG5cbiAgICB2YXIgcG9pbnRlckhhbmRsZXJOYW1lcyA9IHpyVXRpbC5tYXAobW91c2VIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBubSA9IG5hbWUucmVwbGFjZSgnbW91c2UnLCAncG9pbnRlcicpO1xuICAgICAgICByZXR1cm4gcG9pbnRlckV2ZW50TmFtZXNbbm1dID8gbm0gOiBuYW1lO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZXZlbnROYW1lRml4KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIChuYW1lID09PSAnbW91c2V3aGVlbCcgJiYgZW52LmJyb3dzZXIuZmlyZWZveCkgPyAnRE9NTW91c2VTY3JvbGwnIDogbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzR2VzdHVyZShwcm94eSwgZXZlbnQsIHN0YWdlKSB7XG4gICAgICAgIHZhciBnZXN0dXJlTWdyID0gcHJveHkuX2dlc3R1cmVNZ3I7XG5cbiAgICAgICAgc3RhZ2UgPT09ICdzdGFydCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpO1xuXG4gICAgICAgIHZhciBnZXN0dXJlSW5mbyA9IGdlc3R1cmVNZ3IucmVjb2duaXplKFxuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBwcm94eS5oYW5kbGVyLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbCkudGFyZ2V0LFxuICAgICAgICAgICAgcHJveHkuZG9tXG4gICAgICAgICk7XG5cbiAgICAgICAgc3RhZ2UgPT09ICdlbmQnICYmIGdlc3R1cmVNZ3IuY2xlYXIoKTtcblxuICAgICAgICAvLyBEbyBub3QgZG8gYW55IHByZXZlbnREZWZhdWx0IGhlcmUuIFVwcGVyIGFwcGxpY2F0aW9uIGRvIHRoYXQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAoZ2VzdHVyZUluZm8pIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZ2VzdHVyZUluZm8udHlwZTtcbiAgICAgICAgICAgIGV2ZW50Lmdlc3R1cmVFdmVudCA9IHR5cGU7XG5cbiAgICAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoe3RhcmdldDogZ2VzdHVyZUluZm8udGFyZ2V0fSwgdHlwZSwgZ2VzdHVyZUluZm8uZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24gb25NU0dlc3R1cmVDaGFuZ2UocHJveHksIGV2ZW50KSB7XG4gICAgLy8gICAgIGlmIChldmVudC50cmFuc2xhdGlvblggfHwgZXZlbnQudHJhbnNsYXRpb25ZKSB7XG4gICAgLy8gICAgICAgICAvLyBtb3VzZW1vdmUgaXMgY2FycmllZCBieSBNU0dlc3R1cmUgdG8gcmVkdWNlIHRoZSBzZW5zaXRpdml0eS5cbiAgICAvLyAgICAgICAgIHByb3h5LmhhbmRsZXIuZGlzcGF0Y2hUb0VsZW1lbnQoZXZlbnQudGFyZ2V0LCAnbW91c2Vtb3ZlJywgZXZlbnQpO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmIChldmVudC5zY2FsZSAhPT0gMSkge1xuICAgIC8vICAgICAgICAgZXZlbnQucGluY2hYID0gZXZlbnQub2Zmc2V0WDtcbiAgICAvLyAgICAgICAgIGV2ZW50LnBpbmNoWSA9IGV2ZW50Lm9mZnNldFk7XG4gICAgLy8gICAgICAgICBldmVudC5waW5jaFNjYWxlID0gZXZlbnQuc2NhbGU7XG4gICAgLy8gICAgICAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KGV2ZW50LnRhcmdldCwgJ3BpbmNoJywgZXZlbnQpO1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gICAgLyoqXG4gICAgICogUHJldmVudCBtb3VzZSBldmVudCBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgYWZ0ZXIgVG91Y2ggRXZlbnRzIGFjdGlvblxuICAgICAqIEBzZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9kZWx0YWtvc2gvaGFuZGpzL2Jsb2IvbWFzdGVyL3NyYy9oYW5kLmJhc2UuanM+XG4gICAgICogMS4gTW9iaWxlIGJyb3dzZXJzIGRpc3BhdGNoIG1vdXNlIGV2ZW50cyAzMDBtcyBhZnRlciB0b3VjaGVuZC5cbiAgICAgKiAyLiBDaHJvbWUgZm9yIEFuZHJvaWQgZGlzcGF0Y2ggbW91c2Vkb3duIGZvciBsb25nLXRvdWNoIGFib3V0IDY1MG1zXG4gICAgICogUmVzdWx0OiBCbG9ja2luZyBNb3VzZSBFdmVudHMgZm9yIDcwMG1zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFRvdWNoVGltZXIoaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UuX3RvdWNoaW5nID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGluc3RhbmNlLl90b3VjaFRpbWVyKTtcbiAgICAgICAgaW5zdGFuY2UuX3RvdWNoVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl90b3VjaGluZyA9IGZhbHNlO1xuICAgICAgICB9LCA3MDApO1xuICAgIH1cblxuXG4gICAgdmFyIGRvbUhhbmRsZXJzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogTW91c2UgbW92ZSBoYW5kbGVyXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdtb3VzZW1vdmUnLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIG91dCBoYW5kbGVyXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5b+955Wl5YyF5ZCr5Zyocm9vdOS4reeahGRvbeW8lei1t+eahG1vdXNlT3V0XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2VvdXQnLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvdWNo5byA5aeL5ZON5bqU5Ye95pWwXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hzdGFydDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IG1vdXNlIGJlaGF2aW91ciBzaG91bGQgbm90IGJlIGRpc2FibGVkIGhlcmUuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgcGFnZSBtYXkgbmVlZHMgdG8gYmUgc2xpZGVkLlxuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgICAgICAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cbiAgICAgICAgICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnc3RhcnQnKTtcblxuICAgICAgICAgICAgLy8gSW4gdG91Y2ggZGV2aWNlLCB0cmlnZ2VyIGBtb3VzZW1vdmVgKGBtb3VzZW92ZXJgKSBzaG91bGRcbiAgICAgICAgICAgIC8vIGJlIHRyaWdnZXJlZCwgYW5kIG11c3QgYmVmb3JlIGBtb3VzZWRvd25gIHRyaWdnZXJlZC5cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOenu+WKqOWTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgLy8gTWFyayB0b3VjaCwgd2hpY2ggaXMgdXNlZnVsIGluIGRpc3Rpbmd1aXNoIHRvdWNoIGFuZFxuICAgICAgICAgICAgLy8gbW91c2UgZXZlbnQgaW4gdXBwZXIgYXBwbGljYXRvaW4uXG4gICAgICAgICAgICBldmVudC56ckJ5VG91Y2ggPSB0cnVlO1xuXG4gICAgICAgICAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ2NoYW5nZScpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBtb3ZlIHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBnZXN0cnVlIGV2ZW50LCBiZWNhdXNlIG1vdXNlIG1vdmUgYW5kIHBpbmNoIG1heVxuICAgICAgICAgICAgLy8gYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOe7k+adn+WTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoZW5kOiBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBNYXJrIHRvdWNoLCB3aGljaCBpcyB1c2VmdWwgaW4gZGlzdGluZ3Vpc2ggdG91Y2ggYW5kXG4gICAgICAgICAgICAvLyBtb3VzZSBldmVudCBpbiB1cHBlciBhcHBsaWNhdG9pbi5cbiAgICAgICAgICAgIGV2ZW50LnpyQnlUb3VjaCA9IHRydWU7XG5cbiAgICAgICAgICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnZW5kJyk7XG5cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNldXAuY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICAgICAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIGBtb3VzZW91dGAgaGVyZSwgaW4gc3BpdGUgb2YgYG1vdXNlbW92ZWAoYG1vdXNlb3ZlcmApIGlzXG4gICAgICAgICAgICAvLyB0cmlnZ2VyZWQgaW4gYHRvdWNoc3RhcnRgLiBUaGlzIHNlZW1zIHRvIGJlIGlsbG9naWNhbCwgYnV0IGJ5IHRoaXMgbWVjaGFuaXNtLFxuICAgICAgICAgICAgLy8gd2UgY2FuIGNvbnZlbmllbnRseSBpbXBsZW1lbnQgXCJob3ZlciBzdHlsZVwiIGluIGJvdGggUEMgYW5kIHRvdWNoIGRldmljZSBqdXN0XG4gICAgICAgICAgICAvLyBieSBsaXN0ZW5pbmcgdG8gYG1vdXNlb3ZlcmAgdG8gYWRkIFwiaG92ZXIgc3R5bGVcIiBhbmQgbGlzdGVuaW5nIHRvIGBtb3VzZW91dGBcbiAgICAgICAgICAgIC8vIHRvIHJlbW92ZSBcImhvdmVyIHN0eWxlXCIgb24gYW4gZWxlbWVudCwgd2l0aG91dCBhbnkgYWRkaXRpb25hbCBjb2RlIGZvclxuICAgICAgICAgICAgLy8gY29tcGF0aWJpbGl0eS4gKGBtb3VzZW91dGAgd2lsbCBub3QgYmUgdHJpZ2dlcmVkIGluIGB0b3VjaGVuZGAsIHNvIFwiaG92ZXJcbiAgICAgICAgICAgIC8vIHN0eWxlXCIgd2lsbCByZW1haW4gZm9yIHVzZXIgdmlldylcblxuICAgICAgICAgICAgLy8gY2xpY2sgZXZlbnQgc2hvdWxkIGFsd2F5cyBiZSB0cmlnZ2VyZWQgbm8gbWF0dGVyIHdoZXRoZXJcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQuIFN5c3RlbSBjbGljayBjYW4gbm90IGJlIHByZXZlbnRlZC5cbiAgICAgICAgICAgIGlmICgrbmV3IERhdGUoKSAtIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA8IFRPVUNIX0NMSUNLX0RFTEFZKSB7XG4gICAgICAgICAgICAgICAgZG9tSGFuZGxlcnMuY2xpY2suY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9pbnRlcmRvd246IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBpZiAodXNlTVNHdWVzdHVyZSh0aGlzLCBldmVudCkpIHtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLl9tc0dlc3R1cmUuYWRkUG9pbnRlcihldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyBwb2ludGVybW92ZSBpcyBzbyBzZW5zaXRpdmUgdGhhdCBpdCBhbHdheXMgdHJpZ2dlcmVkIHdoZW5cbiAgICAgICAgICAgIC8vIHRhcChjbGljaykgb24gdG91Y2ggc2NyZWVuLCB3aGljaCBhZmZlY3Qgc29tZSBqdWRnZW1lbnQgaW5cbiAgICAgICAgICAgIC8vIHVwcGVyIGFwcGxpY2F0aW9uLiBTbywgd2UgZG9udCBzdXBwb3J0IG1vdXNlbW92ZSBvbiBNUyB0b3VjaFxuICAgICAgICAgICAgLy8gZGV2aWNlIHlldC5cbiAgICAgICAgICAgIGlmICghaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludGVydXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludGVyb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIHBvaW50ZXJvdXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0YXAgb24gdG91Y2ggc2NyZWVuXG4gICAgICAgICAgICAvLyAoSUUxMSsvRWRnZSBvbiBNUyBTdXJmYWNlKSBhZnRlciBjbGljayBldmVudCB0cmlnZ2VyZWQsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgbW91c291dCBiZWhhdmlvciB3ZSBkZWZpbmVkXG4gICAgICAgICAgICAvLyBpbiB0b3VjaGVuZC4gU28gd2UgdW5pZnkgdGhlbS5cbiAgICAgICAgICAgIC8vIChjaGVjayBkb21IYW5kbGVycy50b3VjaGVuZCBmb3IgZGV0YWlsZWQgZXhwbGFuYXRpb24pXG4gICAgICAgICAgICBpZiAoIWlzUG9pbnRlckZyb21Ub3VjaChldmVudCkpIHtcbiAgICAgICAgICAgICAgICBkb21IYW5kbGVycy5tb3VzZW91dC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICAgIHJldHVybiBwb2ludGVyVHlwZSA9PT0gJ3BlbicgfHwgcG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24gdXNlTVNHdWVzdHVyZShoYW5kbGVyUHJveHksIGV2ZW50KSB7XG4gICAgLy8gICAgIHJldHVybiBpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpICYmICEhaGFuZGxlclByb3h5Ll9tc0dlc3R1cmU7XG4gICAgLy8gfVxuXG4gICAgLy8gQ29tbW9uIGhhbmRsZXJzXG4gICAgenJVdGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJywgJ2NvbnRleHRtZW51J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGRvbUhhbmRsZXJzW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobmFtZSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICog5Li65o6n5Yi257G75a6e5L6L5Yid5aeL5YyWZG9tIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAqXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9IYW5kbGVyfSBpbnN0YW5jZSDmjqfliLbnsbvlrp7kvotcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0RG9tSGFuZGxlcihpbnN0YW5jZSkge1xuICAgICAgICB6clV0aWwuZWFjaCh0b3VjaEhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IHpyVXRpbC5iaW5kKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHpyVXRpbC5lYWNoKHBvaW50ZXJIYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSB6clV0aWwuYmluZChkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICB6clV0aWwuZWFjaChtb3VzZUhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IG1ha2VNb3VzZUhhbmRsZXIoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZU1vdXNlSGFuZGxlcihmbiwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLl90b3VjaGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIEhhbmRsZXJEb21Qcm94eShkb20pIHtcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90b3VjaGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdG91Y2hUaW1lcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvR2VzdHVyZU1ncn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2dlc3R1cmVNZ3IgPSBuZXcgR2VzdHVyZU1ncigpO1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XG5cbiAgICAgICAgaW5pdERvbUhhbmRsZXIodGhpcyk7XG5cbiAgICAgICAgaWYgKGVudi5wb2ludGVyRXZlbnRzU3VwcG9ydGVkKSB7IC8vIE9ubHkgSUUxMSsvRWRnZVxuICAgICAgICAgICAgLy8gMS4gT24gZGV2aWNlcyB0aGF0IGJvdGggZW5hYmxlIHRvdWNoIGFuZCBtb3VzZSAoZS5nLiwgTVMgU3VyZmFjZSBhbmQgbGVub3ZvIFgyNDApLFxuICAgICAgICAgICAgLy8gSUUxMSsvRWRnZSBkbyBub3QgdHJpZ2dlciB0b3VjaCBldmVudCwgYnV0IHRyaWdnZXIgcG9pbnRlciBldmVudCBhbmQgbW91c2UgZXZlbnRcbiAgICAgICAgICAgIC8vIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgICAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBpdCBwcm9iYWJsZWx5IG9ubHkgdHJpZ2dlciBtb3VzZWRvd24gYnV0IG5vIG1vdXNldXAgd2hlbiB0YXAgb25cbiAgICAgICAgICAgIC8vIHNjcmVlbiwgd2hpY2ggZG8gbm90IG9jY3VycyBpbiBwb2ludGVyIGV2ZW50LlxuICAgICAgICAgICAgLy8gU28gd2UgdXNlIHBvaW50ZXIgZXZlbnQgdG8gYm90aCBkZXRlY3QgdG91Y2ggZ2VzdHVyZSBhbmQgbW91c2UgYmVoYXZpb3IuXG4gICAgICAgICAgICBtb3VudEhhbmRsZXJzKHBvaW50ZXJIYW5kbGVyTmFtZXMsIHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgLy8gTm90ZTogTVMgR2VzdHVyZSByZXF1aXJlIENTUyB0b3VjaC1hY3Rpb24gc2V0LiBCdXQgdG91Y2gtYWN0aW9uIGlzIG5vdCByZWxpYWJsZSxcbiAgICAgICAgICAgIC8vIHdoaWNoIGRvZXMgbm90IHByZXZlbnQgZGVmdWF1bHQgYmVoYXZpb3Igb2NjYXNpb25hbGx5ICh3aGljaCBtYXkgY2F1c2UgdmlldyBwb3J0XG4gICAgICAgICAgICAvLyB6b29tZWQgaW4gYnV0IHVzZSBjYW4gbm90IHpvb20gaXQgYmFjaykuIEFuZCBldmVudC5wcmV2ZW50RGVmYXVsdCgpIGRvZXMgbm90IHdvcmsuXG4gICAgICAgICAgICAvLyBTbyB3ZSBoYXZlIHRvIG5vdCB0byB1c2UgTVNHZXN0dXJlIGFuZCBub3QgdG8gc3VwcG9ydCB0b3VjaG1vdmUgYW5kIHBpbmNoIG9uIE1TXG4gICAgICAgICAgICAvLyB0b3VjaCBzY3JlZW4uIEFuZCB3ZSBvbmx5IHN1cHBvcnQgY2xpY2sgYmVoYXZpb3Igb24gTVMgdG91Y2ggc2NyZWVuIG5vdy5cblxuICAgICAgICAgICAgLy8gTVMgR2VzdHVyZSBFdmVudCBpcyBvbmx5IHN1cHBvcnRlZCBvbiBJRTExKy9FZGdlIGFuZCBvbiBXaW5kb3dzIDgrLlxuICAgICAgICAgICAgLy8gV2UgZG9udCBzdXBwb3J0IHRvdWNoIG9uIElFIG9uIHdpbjcuXG4gICAgICAgICAgICAvLyBTZWUgPGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDModj12cy44NSkuYXNweD5cbiAgICAgICAgICAgIC8vIGlmICh0eXBlb2YgTVNHZXN0dXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyAgICAgKHRoaXMuX21zR2VzdHVyZSA9IG5ldyBNU0dlc3R1cmUoKSkudGFyZ2V0ID0gZG9tOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgIC8vICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignTVNHZXN0dXJlQ2hhbmdlJywgb25NU0dlc3R1cmVDaGFuZ2UpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVudi50b3VjaEV2ZW50c1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIG1vdW50SGFuZGxlcnModG91Y2hIYW5kbGVyTmFtZXMsIHRoaXMpO1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZXIgb2YgJ21vdXNlb3V0JyBldmVudCBpcyBuZWVkZWQgaW4gdG91Y2ggbW9kZSwgd2hpY2ggd2lsbCBiZSBtb3VudGVkIGJlbG93LlxuICAgICAgICAgICAgICAgIC8vIGFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ21vdXNlb3V0JywgdGhpcy5fbW91c2VvdXRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMS4gQ29uc2lkZXJpbmcgc29tZSBkZXZpY2VzIHRoYXQgYm90aCBlbmFibGUgdG91Y2ggYW5kIG1vdXNlIGV2ZW50IChsaWtlIG9uIE1TIFN1cmZhY2VcbiAgICAgICAgICAgIC8vIGFuZCBsZW5vdm8gWDI0MCwgQHNlZSAjMjM1MCksIHdlIG1ha2UgbW91c2UgZXZlbnQgYmUgYWx3YXlzIGxpc3RlbmVkLCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIG1vdXNlIGV2ZW50IGNhbiBub3QgYmUgaGFuZGxlIGluIHRob3NlIGRldmljZXMuXG4gICAgICAgICAgICAvLyAyLiBPbiBNUyBTdXJmYWNlLCBDaHJvbWUgd2lsbCB0cmlnZ2VyIGJvdGggdG91Y2ggZXZlbnQgYW5kIG1vdXNlIGV2ZW50LiBIb3cgdG8gcHJldmVudFxuICAgICAgICAgICAgLy8gbW91c2VldmVudCBhZnRlciB0b3VjaCBldmVudCB0cmlnZ2VyZWQsIHNlZSBgc2V0VG91Y2hUaW1lcmAuXG4gICAgICAgICAgICBtb3VudEhhbmRsZXJzKG1vdXNlSGFuZGxlck5hbWVzLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1vdW50SGFuZGxlcnMoaGFuZGxlck5hbWVzLCBpbnN0YW5jZSkge1xuICAgICAgICAgICAgenJVdGlsLmVhY2goaGFuZGxlck5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZG9tLCBldmVudE5hbWVGaXgobmFtZSksIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSk7XG4gICAgICAgICAgICB9LCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlckRvbVByb3h5UHJvdG8gPSBIYW5kbGVyRG9tUHJveHkucHJvdG90eXBlO1xuICAgIGhhbmRsZXJEb21Qcm94eVByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYW5kbGVyTmFtZXMgPSBtb3VzZUhhbmRsZXJOYW1lcy5jb25jYXQodG91Y2hIYW5kbGVyTmFtZXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGhhbmRsZXJOYW1lc1tpXTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5kb20sIGV2ZW50TmFtZUZpeChuYW1lKSwgdGhpcy5faGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGhhbmRsZXJEb21Qcm94eVByb3RvLnNldEN1cnNvciA9IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS5jdXJzb3IgPSBjdXJzb3JTdHlsZSB8fCAnZGVmYXVsdCc7XG4gICAgfTtcblxuICAgIHpyVXRpbC5taXhpbihIYW5kbGVyRG9tUHJveHksIEV2ZW50ZnVsKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlckRvbVByb3h5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9kb20vSGFuZGxlclByb3h5LmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIE9ubHkgaW1wbGVtZW50cyBuZWVkZWQgZ2VzdHVyZXMgZm9yIG1vYmlsZS5cbiAqL1xuXG5cbiAgICB2YXIgZXZlbnRVdGlsID0gcmVxdWlyZSgnLi9ldmVudCcpO1xuXG4gICAgdmFyIEdlc3R1cmVNZ3IgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RyYWNrID0gW107XG4gICAgfTtcblxuICAgIEdlc3R1cmVNZ3IucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBHZXN0dXJlTWdyLFxuXG4gICAgICAgIHJlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2RvVHJhY2soZXZlbnQsIHRhcmdldCwgcm9vdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjb2duaXplKGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2subGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb1RyYWNrOiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCwgcm9vdCkge1xuICAgICAgICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuXG4gICAgICAgICAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0cmFja0l0ZW0gPSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXSxcbiAgICAgICAgICAgICAgICB0b3VjaGVzOiBbXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b3VjaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoID0gdG91Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gZXZlbnRVdGlsLmNsaWVudFRvTG9jYWwocm9vdCwgdG91Y2gsIHt9KTtcbiAgICAgICAgICAgICAgICB0cmFja0l0ZW0ucG9pbnRzLnB1c2goW3Bvcy56clgsIHBvcy56clldKTtcbiAgICAgICAgICAgICAgICB0cmFja0l0ZW0udG91Y2hlcy5wdXNoKHRvdWNoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdHJhY2sucHVzaCh0cmFja0l0ZW0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9yZWNvZ25pemU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHJlY29nbml6ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29nbml6ZXJzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdlc3R1cmVJbmZvID0gcmVjb2duaXplcnNbZXZlbnROYW1lXSh0aGlzLl90cmFjaywgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2VzdHVyZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXN0dXJlSW5mbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkaXN0KHBvaW50UGFpcikge1xuICAgICAgICB2YXIgZHggPSBwb2ludFBhaXJbMV1bMF0gLSBwb2ludFBhaXJbMF1bMF07XG4gICAgICAgIHZhciBkeSA9IHBvaW50UGFpclsxXVsxXSAtIHBvaW50UGFpclswXVsxXTtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjZW50ZXIocG9pbnRQYWlyKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAocG9pbnRQYWlyWzBdWzBdICsgcG9pbnRQYWlyWzFdWzBdKSAvIDIsXG4gICAgICAgICAgICAocG9pbnRQYWlyWzBdWzFdICsgcG9pbnRQYWlyWzFdWzFdKSAvIDJcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICB2YXIgcmVjb2duaXplcnMgPSB7XG5cbiAgICAgICAgcGluY2g6IGZ1bmN0aW9uICh0cmFjaywgZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0cmFja0xlbiA9IHRyYWNrLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKCF0cmFja0xlbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBpbmNoRW5kID0gKHRyYWNrW3RyYWNrTGVuIC0gMV0gfHwge30pLnBvaW50cztcbiAgICAgICAgICAgIHZhciBwaW5jaFByZSA9ICh0cmFja1t0cmFja0xlbiAtIDJdIHx8IHt9KS5wb2ludHMgfHwgcGluY2hFbmQ7XG5cbiAgICAgICAgICAgIGlmIChwaW5jaFByZVxuICAgICAgICAgICAgICAgICYmIHBpbmNoUHJlLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAmJiBwaW5jaEVuZFxuICAgICAgICAgICAgICAgICYmIHBpbmNoRW5kLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBwaW5jaFNjYWxlID0gZGlzdChwaW5jaEVuZCkgLyBkaXN0KHBpbmNoUHJlKTtcbiAgICAgICAgICAgICAgICAhaXNGaW5pdGUocGluY2hTY2FsZSkgJiYgKHBpbmNoU2NhbGUgPSAxKTtcblxuICAgICAgICAgICAgICAgIGV2ZW50LnBpbmNoU2NhbGUgPSBwaW5jaFNjYWxlO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBpbmNoQ2VudGVyID0gY2VudGVyKHBpbmNoRW5kKTtcbiAgICAgICAgICAgICAgICBldmVudC5waW5jaFggPSBwaW5jaENlbnRlclswXTtcbiAgICAgICAgICAgICAgICBldmVudC5waW5jaFkgPSBwaW5jaENlbnRlclsxXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwaW5jaCcsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdHJhY2tbMF0udGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBwaW5jaCBjdXJyZW50bHkuXG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gR2VzdHVyZU1ncjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogRGVmYXVsdCBjYW52YXMgcGFpbnRlclxuICogQG1vZHVsZSB6cmVuZGVyL1BhaW50ZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbiBcblxuICAgIHZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbG9nID0gcmVxdWlyZSgnLi9jb3JlL2xvZycpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIHRpbXNvcnQgPSByZXF1aXJlKCcuL2NvcmUvdGltc29ydCcpO1xuXG4gICAgdmFyIExheWVyID0gcmVxdWlyZSgnLi9MYXllcicpO1xuXG4gICAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZScpO1xuXG4gICAgLy8gUEVORElHTlxuICAgIC8vIExheWVyIGV4Y2VlZHMgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUiBtYXkgaGF2ZSBzb21lIHByb2JsZW0gd2hlbiBmbHVzaCBkaXJlY3RseSBzZWNvbmQgdGltZS5cbiAgICAvL1xuICAgIC8vIE1heGltdW0gcHJvZ3Jlc3NpdmUgbGF5ZXIuIFdoZW4gZXhjZWVkaW5nIHRoaXMgbnVtYmVyLiBBbGwgZWxlbWVudHMgd2lsbCBiZSBkcmF3ZWQgaW4gdGhlIGxhc3QgbGF5ZXIuXG4gICAgdmFyIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgPSA1O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQxMCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGF5ZXJWYWxpZChsYXllcikge1xuICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihsYXllci5yZXNpemUpICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICB8fCB0eXBlb2YobGF5ZXIucmVmcmVzaCkgIT09ICdmdW5jdGlvbidcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuX191bnVzZWRDb3VudCsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc3RQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgaWYgKGxheWVyLl9fdW51c2VkQ291bnQgPT0gMSkge1xuICAgICAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICB2YXIgdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgIGZ1bmN0aW9uIGlzRGlzcGxheWFibGVDdWxsZWQoZWwsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KGVsLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgaWYgKGVsLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHZpZXdSZWN0LndpZHRoID0gd2lkdGg7XG4gICAgICAgIHZpZXdSZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuICF0bXBSZWN0LmludGVyc2VjdCh2aWV3UmVjdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBwcmV2Q2xpcFBhdGhzKSB7XG4gICAgICAgIGlmIChjbGlwUGF0aHMgPT0gcHJldkNsaXBQYXRocykgeyAvLyBDYW4gYm90aCBiZSBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjbGlwUGF0aHMgfHwgIXByZXZDbGlwUGF0aHMgfHwgKGNsaXBQYXRocy5sZW5ndGggIT09IHByZXZDbGlwUGF0aHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvQ2xpcChjbGlwUGF0aHMsIGN0eCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gY2xpcFBhdGhzW2ldO1xuXG4gICAgICAgICAgICBjbGlwUGF0aC5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNsaXBQYXRoLmJ1aWxkUGF0aChjdHgsIGNsaXBQYXRoLnNoYXBlKTtcbiAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gYmFja1xuICAgICAgICAgICAgY2xpcFBhdGgucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUm9vdCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBkb21Sb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgLy8gZG9tUm9vdC5vbnNlbGVjdHN0YXJ0ID0gcmV0dXJuRmFsc2U7IC8vIOmBv+WFjemhtemdoumAieS4reeahOWwtOWwrFxuICAgICAgICBkb21Sb290LnN0eWxlLmNzc1RleHQgPSBbXG4gICAgICAgICAgICAncG9zaXRpb246cmVsYXRpdmUnLFxuICAgICAgICAgICAgJ292ZXJmbG93OmhpZGRlbicsXG4gICAgICAgICAgICAnd2lkdGg6JyArIHdpZHRoICsgJ3B4JyxcbiAgICAgICAgICAgICdoZWlnaHQ6JyArIGhlaWdodCArICdweCcsXG4gICAgICAgICAgICAncGFkZGluZzowJyxcbiAgICAgICAgICAgICdtYXJnaW46MCcsXG4gICAgICAgICAgICAnYm9yZGVyLXdpZHRoOjAnXG4gICAgICAgIF0uam9pbignOycpICsgJzsnO1xuXG4gICAgICAgIHJldHVybiBkb21Sb290O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9QYWludGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcm9vdCDnu5jlm77lrrnlmahcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIHZhciBQYWludGVyID0gZnVuY3Rpb24gKHJvb3QsIHN0b3JhZ2UsIG9wdHMpIHtcblxuICAgICAgICB0aGlzLnR5cGUgPSAnY2FudmFzJztcblxuICAgICAgICAvLyBJbiBub2RlIGVudmlyb25tZW50IHVzaW5nIG5vZGUtY2FudmFzXG4gICAgICAgIHZhciBzaW5nbGVDYW52YXMgPSAhcm9vdC5ub2RlTmFtZSAvLyBJbiBub2RlID9cbiAgICAgICAgICAgIHx8IHJvb3Qubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0NBTlZBUyc7XG5cbiAgICAgICAgdGhpcy5fb3B0cyA9IG9wdHMgPSB1dGlsLmV4dGVuZCh7fSwgb3B0cyB8fCB7fSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRwciA9IG9wdHMuZGV2aWNlUGl4ZWxSYXRpbyB8fCBjb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2luZ2xlQ2FudmFzID0gc2luZ2xlQ2FudmFzO1xuICAgICAgICAvKipcbiAgICAgICAgICog57uY5Zu+5a655ZmoXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG5cbiAgICAgICAgdmFyIHJvb3RTdHlsZSA9IHJvb3Quc3R5bGU7XG5cbiAgICAgICAgaWYgKHJvb3RTdHlsZSkge1xuICAgICAgICAgICAgcm9vdFN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICByb290U3R5bGVbJy13ZWJraXQtdXNlci1zZWxlY3QnXSA9XG4gICAgICAgICAgICByb290U3R5bGVbJ3VzZXItc2VsZWN0J10gPVxuICAgICAgICAgICAgcm9vdFN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcblxuICAgICAgICAgICAgcm9vdC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdCA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp6cmVuZGVyL0xheWVyPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBPYmplY3Q+fVxuICAgICAgICAgKiBAdHlwZSB7cHJpdmF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xheWVyQ29uZmlnID0ge307XG5cbiAgICAgICAgaWYgKCFzaW5nbGVDYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdGhpcy5fZ2V0U2l6ZSgwKTtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX2dldFNpemUoMSk7XG5cbiAgICAgICAgICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdCA9IGNyZWF0ZVJvb3QoXG4gICAgICAgICAgICAgICAgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoZG9tUm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAob3B0cy53aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcm9vdC53aWR0aCA9IG9wdHMud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJvb3QuaGVpZ2h0ID0gb3B0cy5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2UgY2FudmFzIHdpZHRoIGFuZCBoZWlnaHQgZGlyZWN0bHlcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJvb3Qud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcm9vdC5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgbGF5ZXIgaWYgb25seSBvbmUgZ2l2ZW4gY2FudmFzXG4gICAgICAgICAgICAvLyBEZXZpY2UgcGl4ZWwgcmF0aW8gaXMgZml4ZWQgdG8gMSBiZWNhdXNlIGdpdmVuIGNhbnZhcyBoYXMgaXRzIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgICB2YXIgbWFpbkxheWVyID0gbmV3IExheWVyKHJvb3QsIHRoaXMsIDEpO1xuICAgICAgICAgICAgbWFpbkxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgICAvLyBGSVhNRSBVc2UgY2FudmFzIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgICAgIC8vIG1haW5MYXllci5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBsYXllcnNbMF0gPSBtYWluTGF5ZXI7XG4gICAgICAgICAgICB6bGV2ZWxMaXN0LnB1c2goMCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2RvbVJvb3QgPSByb290O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGF5ZXJzIGZvciBwcm9ncmVzc2l2ZSByZW5kZXJpbmdcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL0xheWVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faG92ZXJsYXllcjtcblxuICAgICAgICB0aGlzLl9ob3ZlckVsZW1lbnRzID0gW107XG4gICAgfTtcblxuICAgIFBhaW50ZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBQYWludGVyLFxuXG4gICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnY2FudmFzJztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgcGFpbnRlciB1c2UgYSBzaW5nbGUgY2FudmFzXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc1NpbmdsZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbmdsZUNhbnZhcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0hUTUxEaXZFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9tUm9vdDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRWaWV3cG9ydFJvb3RPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydFJvb3QgPSB0aGlzLmdldFZpZXdwb3J0Um9vdCgpO1xuICAgICAgICAgICAgaWYgKHZpZXdwb3J0Um9vdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQ6IHZpZXdwb3J0Um9vdC5vZmZzZXRMZWZ0IHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcDogdmlld3BvcnRSb290Lm9mZnNldFRvcCB8fCAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yi35pawXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhaW50QWxsPWZhbHNlXSDlvLrliLbnu5jliLbmiYDmnIlkaXNwbGF5YWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24gKHBhaW50QWxsKSB7XG5cbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG5cbiAgICAgICAgICAgIHRoaXMuX3BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICAgICAgICAgIC8vIFBhaW50IGN1c3R1bSBsYXllcnNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllci5fX2J1aWx0aW5fXyAmJiBsYXllci5yZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFByb2dlc3NpdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkSG92ZXI6IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSkge1xuICAgICAgICAgICAgaWYgKGVsLl9faG92ZXJNaXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZWxNaXJyb3IgPSBuZXcgZWwuY29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgICAgIHN0eWxlOiBlbC5zdHlsZSxcbiAgICAgICAgICAgICAgICBzaGFwZTogZWwuc2hhcGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWxNaXJyb3IuX19mcm9tID0gZWw7XG4gICAgICAgICAgICBlbC5fX2hvdmVyTWlyID0gZWxNaXJyb3I7XG4gICAgICAgICAgICBlbE1pcnJvci5zZXRTdHlsZShob3ZlclN0eWxlKTtcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyRWxlbWVudHMucHVzaChlbE1pcnJvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGVsTWlycm9yID0gZWwuX19ob3Zlck1pcjtcbiAgICAgICAgICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YoaG92ZXJFbGVtZW50cywgZWxNaXJyb3IpO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFySG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3ZlckVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSBob3ZlckVsZW1lbnRzW2ldLl9fZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvdmVyRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgfSxcblxuICAgICAgICByZWZyZXNoSG92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICAgICAgICAgIHZhciBsZW4gPSBob3ZlckVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllcjtcbiAgICAgICAgICAgIGhvdmVyTGF5ZXIgJiYgaG92ZXJMYXllci5jbGVhcigpO1xuXG4gICAgICAgICAgICBpZiAoIWxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbXNvcnQoaG92ZXJFbGVtZW50cywgdGhpcy5zdG9yYWdlLmRpc3BsYXlhYmxlU29ydEZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBVc2UgYSBleHRyZWFtIGxhcmdlIHpsZXZlbFxuICAgICAgICAgICAgLy8gRklYTUU/XG4gICAgICAgICAgICBpZiAoIWhvdmVyTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllciA9IHRoaXMuZ2V0TGF5ZXIoMWU1KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNjb3BlID0ge307XG4gICAgICAgICAgICBob3ZlckxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBob3ZlckVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEVsID0gZWwuX19mcm9tO1xuICAgICAgICAgICAgICAgIC8vIE9yaWdpbmFsIGVsIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAgICAgaWYgKCEob3JpZ2luYWxFbCAmJiBvcmlnaW5hbEVsLl9fenIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvdmVyRWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVsLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcblxuICAgICAgICAgICAgICAgIC8vIFVzZSB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBzdHlsZSBhbmQgc2hhcGUgP1xuICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxFbC5pbnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwudHJhbnNmb3JtID0gb3JpZ2luYWxFbC50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICAgIGVsLmludlRyYW5zZm9ybSA9IG9yaWdpbmFsRWwuaW52VHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICBlbC5fX2NsaXBQYXRocyA9IG9yaWdpbmFsRWwuX19jbGlwUGF0aHM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGhvdmVyTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob3ZlckxheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3N0YXJ0UHJvZ2Vzc2l2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIGEgdG9rZW4gdG8gc3RvcCBwcm9ncmVzcyBzdGVwcyB0cmlnZ2VyZWQgYnlcbiAgICAgICAgICAgIC8vIHByZXZpb3VzIHpyLnJlZnJlc2ggY2FsbGluZy5cbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSArbmV3IERhdGUoKTtcblxuICAgICAgICAgICAgc2VsZi5fcHJvZ3Jlc3MrKztcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHJlZnJlc2hlZCBvciBkaXNwb3NlZFxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gc2VsZi5fcHJvZ3Jlc3NpdmVUb2tlbiAmJiBzZWxmLnN0b3JhZ2UpIHtcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kb1BhaW50TGlzdChzZWxmLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcHJvZ3Jlc3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfY2xlYXJQcm9ncmVzc2l2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NpdmVUb2tlbiA9IC0xO1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBsYXllci5fX2RpcnR5ICYmIGxheWVyLmNsZWFyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCwgcGFpbnRBbGwpIHtcblxuICAgICAgICAgICAgaWYgKHBhaW50QWxsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYWludEFsbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMYXllclN0YXR1cyhsaXN0KTtcblxuICAgICAgICAgICAgdGhpcy5fY2xlYXJQcm9ncmVzc2l2ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIocHJlUHJvY2Vzc0xheWVyKTtcblxuICAgICAgICAgICAgdGhpcy5fZG9QYWludExpc3QobGlzdCwgcGFpbnRBbGwpO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIocG9zdFByb2Nlc3NMYXllcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvUGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCwgcGFpbnRBbGwpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TGF5ZXI7XG4gICAgICAgICAgICB2YXIgY3VycmVudFpMZXZlbDtcbiAgICAgICAgICAgIHZhciBjdHg7XG5cbiAgICAgICAgICAgIC8vIHZhciBpbnZUcmFuc2Zvcm0gPSBbXTtcbiAgICAgICAgICAgIHZhciBzY29wZTtcblxuICAgICAgICAgICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJJZHggPSAwO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyO1xuXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbGF5ZXJQcm9ncmVzcztcbiAgICAgICAgICAgIHZhciBmcmFtZSA9IHRoaXMuX3Byb2dyZXNzO1xuICAgICAgICAgICAgZnVuY3Rpb24gZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIGxheWVyIGRvbid0IGNsZWFyIGluIG5leHQgcHJvZ3Jlc3NpdmUgZnJhbWVcbiAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGxheWVyLmRvbSwgMCwgMCwgd2lkdGggKiBkcHIsIGhlaWdodCAqIGRwcik7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgdmFyIGVsWkxldmVsID0gdGhpcy5fc2luZ2xlQ2FudmFzID8gMCA6IGVsLnpsZXZlbDtcblxuICAgICAgICAgICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZTtcblxuICAgICAgICAgICAgICAgIC8vIEZsdXNoIGF0IGN1cnJlbnQgY29udGV4dFxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgICAgICBpZiAoZWxGcmFtZSA8IDAgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSBkcmF3IGxheWVyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRaTGV2ZWwgIT09IGVsWkxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBzY29wZVxuICAgICAgICAgICAgICAgICAgICBzY29wZSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgMCB6bGV2ZWwgaWYgb25seSBoYXMgb25lIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50WkxldmVsID0gZWxaTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllciA9IHRoaXMuZ2V0TGF5ZXIoY3VycmVudFpMZXZlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50TGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWkxldmVsICcgKyBjdXJyZW50WkxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnIGhhcyBiZWVuIHVzZWQgYnkgdW5rb3duIGxheWVyICcgKyBjdXJyZW50TGF5ZXIuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdHggPSBjdXJyZW50TGF5ZXIuY3R4O1xuICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjb3VudFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIuX191bnVzZWRDb3VudCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IHBhaW50QWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxGcmFtZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb2dyZXNzaXZlIGxheWVyIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSB0aGlzLl9wcm9ncmVzc2l2ZUxheWVyc1tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVySWR4KyssIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgLSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLnJlbmRlclNjb3BlID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzID4gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUXVpY2sganVtcCBhbGwgcHJvZ3Jlc3NpdmUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgcHJvZ3Jlc3NpdmUgZWxlbWVudCBhcmUgbm90IGRpcnR5LCBqdW1wIG92ZXIgYW5kIGZsdXNoIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJQcm9ncmVzcyA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fcHJvZ3Jlc3M7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBsYXllclByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzID0gZnJhbWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsRnJhbWUgPT09IGZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLCB0cnVlLCBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5yZW5kZXJTY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgY3VycmVudExheWVyLCBwYWludEFsbCwgc2NvcGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgbGFzdExheWVyIGN0eFxuICAgICAgICAgICAgY3R4ICYmIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAvLyBJZiBzdGlsbCBoYXMgY2xpcHBpbmcgc3RhdGVcbiAgICAgICAgICAgIC8vIGlmIChzY29wZS5wcmV2RWxDbGlwUGF0aHMpIHtcbiAgICAgICAgICAgIC8vICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICB0aGlzLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLl9fbWF4UHJvZ3Jlc3MgPj0gbGF5ZXIuX19wcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mdXJ0aGVyUHJvZ3Jlc3NpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kb1BhaW50RWw6IGZ1bmN0aW9uIChlbCwgY3VycmVudExheWVyLCBmb3JjZVBhaW50LCBzY29wZSkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IGN1cnJlbnRMYXllci5jdHg7XG4gICAgICAgICAgICB2YXIgbSA9IGVsLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoY3VycmVudExheWVyLl9fZGlydHkgfHwgZm9yY2VQYWludClcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgaW52aXNpYmxlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJiAhZWwuaW52aXNpYmxlXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHRyYW5zcGFyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJiBlbC5zdHlsZS5vcGFjaXR5ICE9PSAwXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHNjYWxlIDAgZWxlbWVudCwgaW4gc29tZSBlbnZpcm9ubWVudCBsaWtlIG5vZGUtY2FudmFzXG4gICAgICAgICAgICAgICAgLy8gRHJhdyBhIHNjYWxlIDAgZWxlbWVudCBjYW4gY2F1c2UgYWxsIGZvbGxvd2luZyBkcmF3IHdyb25nXG4gICAgICAgICAgICAgICAgLy8gQW5kIHNldFRyYW5zZm9ybSB3aXRoIHNjYWxlIDAgd2lsbCBjYXVzZSBzZXQgYmFjayB0cmFuc2Zvcm0gZmFpbGVkLlxuICAgICAgICAgICAgICAgICYmICEobSAmJiAhbVswXSAmJiAhbVszXSlcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgY3VsbGVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAmJiAhKGVsLmN1bGxpbmcgJiYgaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCkpXG4gICAgICAgICAgICApIHtcblxuICAgICAgICAgICAgICAgIHZhciBjbGlwUGF0aHMgPSBlbC5fX2NsaXBQYXRocztcblxuICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIHdoZW4gY2xpcHBpbmcgb24gZ3JvdXAgd2l0aCBzZXZlcmFsIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlLnByZXZDbGlwTGF5ZXIgIT09IGN1cnJlbnRMYXllclxuICAgICAgICAgICAgICAgICAgICB8fCBpc0NsaXBQYXRoQ2hhbmdlZChjbGlwUGF0aHMsIHNjb3BlLnByZXZFbENsaXBQYXRocylcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaGFzIHByZXZpb3VzIGNsaXBwaW5nIHN0YXRlLCByZXN0b3JlIGZyb20gaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLnByZXZFbENsaXBQYXRocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkNsaXBMYXllciA9IHNjb3BlLnByZXZFbENsaXBQYXRocyA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHByZXZFbCBzaW5jZSBjb250ZXh0IGhhcyBiZWVuIHJlc3RvcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2RWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyBjbGlwcGluZyBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9DbGlwKGNsaXBQYXRocywgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZDbGlwTGF5ZXIgPSBjdXJyZW50TGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2RWxDbGlwUGF0aHMgPSBjbGlwUGF0aHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWwuYmVmb3JlQnJ1c2ggJiYgZWwuYmVmb3JlQnJ1c2goY3R4KTtcblxuICAgICAgICAgICAgICAgIGVsLmJydXNoKGN0eCwgc2NvcGUucHJldkVsIHx8IG51bGwpO1xuICAgICAgICAgICAgICAgIHNjb3BlLnByZXZFbCA9IGVsO1xuXG4gICAgICAgICAgICAgICAgZWwuYWZ0ZXJCcnVzaCAmJiBlbC5hZnRlckJydXNoKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPliB6bGV2ZWwg5omA5Zyo5bGC77yM5aaC5p6c5LiN5a2Y5Zyo5YiZ5Lya5Yib5bu65LiA5Liq5paw55qE5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBsYXllclxuICAgICAgICAgICAgICAgIGxheWVyID0gbmV3IExheWVyKCd6cl8nICsgemxldmVsLCB0aGlzLCB0aGlzLmRwcik7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19idWlsdGluX18gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllciwgdGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRMYXllcih6bGV2ZWwsIGxheWVyKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnRleHQgaXMgY3JlYXRlZCBhZnRlciBkb20gaW5zZXJ0ZWQgdG8gZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyBPciBleGNhbnZhcyB3aWxsIGdldCAwcHggY2xpZW50V2lkdGggYW5kIGNsaWVudEhlaWdodFxuICAgICAgICAgICAgICAgIGxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnNlcnRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgbGF5ZXIpIHtcblxuICAgICAgICAgICAgdmFyIGxheWVyc01hcCA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsZW4gPSB6bGV2ZWxMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBwcmV2TGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdDtcblxuICAgICAgICAgICAgaWYgKGxheWVyc01hcFt6bGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdaTGV2ZWwgJyArIHpsZXZlbCArICcgaGFzIGJlZW4gdXNlZCBhbHJlYWR5Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXMgYSB2YWxpZCBsYXllclxuICAgICAgICAgICAgaWYgKCFpc0xheWVyVmFsaWQobGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdMYXllciBvZiB6bGV2ZWwgJyArIHpsZXZlbCArICcgaXMgbm90IHZhbGlkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuID4gMCAmJiB6bGV2ZWwgPiB6bGV2ZWxMaXN0WzBdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB6bGV2ZWxMaXN0W2ldIDwgemxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB6bGV2ZWxMaXN0W2kgKyAxXSA+IHpsZXZlbFxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZMYXllciA9IGxheWVyc01hcFt6bGV2ZWxMaXN0W2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKGkgKyAxLCAwLCB6bGV2ZWwpO1xuXG4gICAgICAgICAgICBsYXllcnNNYXBbemxldmVsXSA9IGxheWVyO1xuXG4gICAgICAgICAgICAvLyBWaXR1YWwgbGF5ZXIgd2lsbCBub3QgZGlyZWN0bHkgc2hvdyBvbiB0aGUgc2NyZWVuLlxuICAgICAgICAgICAgLy8gKEl0IGNhbiBiZSBhIFdlYkdMIGxheWVyIGFuZCBhc3NpZ25lZCB0byBhIFpJbWFnZSBlbGVtZW50KVxuICAgICAgICAgICAgLy8gQnV0IGl0IHN0aWxsIHVuZGVyIG1hbmFnZW1lbnQgb2YgenJlbmRlci5cbiAgICAgICAgICAgIGlmICghbGF5ZXIudmlydHVhbCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZEb20gPSBwcmV2TGF5ZXIuZG9tO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldkRvbS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEb20ubmV4dFNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21Sb290LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKGxheWVyLmRvbSwgZG9tUm9vdC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdGVyYXRlIGVhY2ggbGF5ZXJcbiAgICAgICAgZWFjaExheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW3pdLCB6KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdGVyYXRlIGVhY2ggYnVpbGRpbiBsYXllclxuICAgICAgICBlYWNoQnVpbHRpbkxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllcjtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5fX2J1aWx0aW5fXykge1xuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGxheWVyLCB6KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSXRlcmF0ZSBlYWNoIG90aGVyIGxheWVyIGV4Y2VwdCBidWlsZGluIGxheWVyXG4gICAgICAgIGVhY2hPdGhlckxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllcjtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmiYDmnInlt7LliJvlu7rnmoTlsYJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvTGF5ZXI+fSBbcHJldkxheWVyXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVMYXllclN0YXR1czogZnVuY3Rpb24gKGxpc3QpIHtcblxuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUxheWVycyA9IHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzO1xuXG4gICAgICAgICAgICB2YXIgZWxDb3VudHNMYXN0RnJhbWUgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lID0ge307XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcihmdW5jdGlvbiAobGF5ZXIsIHopIHtcbiAgICAgICAgICAgICAgICBlbENvdW50c0xhc3RGcmFtZVt6XSA9IGxheWVyLmVsQ291bnQ7XG4gICAgICAgICAgICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHV0aWwuZWFjaChwcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gPSBsYXllci5lbENvdW50O1xuICAgICAgICAgICAgICAgIGxheWVyLmVsQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NpdmVMYXllckNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcjtcbiAgICAgICAgICAgIHZhciBsYXN0UHJvZ3Jlc3NpdmVLZXk7XG4gICAgICAgICAgICB2YXIgZnJhbWVDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgemxldmVsID0gdGhpcy5fc2luZ2xlQ2FudmFzID8gMCA6IGVsLnpsZXZlbDtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbemxldmVsXTtcbiAgICAgICAgICAgICAgICB2YXIgZWxQcm9ncmVzcyA9IGVsLnByb2dyZXNzaXZlO1xuICAgICAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5lbENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBsYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8vLy8vLyBVcGRhdGUgcHJvZ3Jlc3NpdmVcbiAgICAgICAgICAgICAgICBpZiAoZWxQcm9ncmVzcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCB3cm9uZyBwcm9ncmVzc2l2ZSBzZXF1ZW5jZSBwcm9ibGVtLlxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFByb2dyZXNzaXZlS2V5ICE9PSBlbFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvZ3Jlc3NpdmVLZXkgPSBlbFByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZSA9IGZyYW1lQ291bnQgLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllckNvdW50LCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHByb2dyZXNzaXZlTGF5ZXJzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBwcm9ncmVzc2l2ZUxheWVyc1tpZHhdID0gbmV3IExheWVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJvZ3Jlc3NpdmUnLCB0aGlzLCB0aGlzLmRwclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuaW5pdENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fZGlydHkgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX2RpcnR5IHx8IGVsLl9fZGlydHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmVsQ291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX21heFByb2dyZXNzLCBlbEZyYW1lXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPj0gY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGtlZXAgcmVuZGVyaW5nIHRoaXMgIGxheWVyIGJlY2F1c2UgcHJvZ3Jlc3NpdmUgcmVuZGVyaW5nIGlzIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbC5fX2ZyYW1lID0gLTE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVyQ291bnQrKztcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nID0gaTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g5bGC5Lit55qE5YWD57Sg5pWw6YeP5pyJ5Y+R55Sf5Y+Y5YyWXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsdGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsQ291bnRzTGFzdEZyYW1lW3pdICE9PSBsYXllci5lbENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcm9ncmVzc2l2ZUxheWVycy5sZW5ndGggPSBNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVyQ291bnQsIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIpO1xuICAgICAgICAgICAgdXRpbC5lYWNoKHByb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc2l2ZUVsQ291bnRzTGFzdEZyYW1lW2lkeF0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXllci5fX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fcHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaRob3ZlcuWxguWkluaJgOacieWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcih0aGlzLl9jbGVhckxheWVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jbGVhckxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS/ruaUueaMh+WumnpsZXZlbOeahOe7mOWItuWPguaVsFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gemxldmVsXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcg6YWN572u5a+56LGhXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0g5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIOaYr+WQpuW8gOWQr+WKqOaAgeaooeezilxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddXG4gICAgICAgICAqICAgICAgICAgICAgICAgICDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAgICAgKi9cbiAgICAgICAgY29uZmlnTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwsIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllckNvbmZpZyA9IHRoaXMuX2xheWVyQ29uZmlnO1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllckNvbmZpZ1t6bGV2ZWxdID0gY29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllckNvbmZpZ1t6bGV2ZWxdLCBjb25maWcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIGxheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5oyH5a6a5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWwg5bGC5omA5Zyo55qEemxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBkZWxMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxheWVyLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICBkZWxldGUgbGF5ZXJzW3psZXZlbF07XG5cbiAgICAgICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yy65Z+f5aSn5bCP5Y+Y5YyW5ZCO6YeN57uYXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG4gICAgICAgICAgICAvLyBGSVhNRSBXaHkgP1xuICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgICAgICAvLyBTYXZlIGlucHV0IHcvaFxuICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgICAgICAgICAgd2lkdGggIT0gbnVsbCAmJiAob3B0cy53aWR0aCA9IHdpZHRoKTtcbiAgICAgICAgICAgIGhlaWdodCAhPSBudWxsICYmIChvcHRzLmhlaWdodCA9IGhlaWdodCk7XG5cbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5fZ2V0U2l6ZSgwKTtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2dldFNpemUoMSk7XG5cbiAgICAgICAgICAgIGRvbVJvb3Quc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICAgICAgICAvLyDkvJjljJbmsqHmnInlrp7pmYXmlLnlj5jnmoRyZXNpemVcbiAgICAgICAgICAgIGlmICh0aGlzLl93aWR0aCAhPSB3aWR0aCB8fCBoZWlnaHQgIT0gdGhpcy5faGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICBkb21Sb290LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyc1tpZF0ucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHV0aWwuZWFjaCh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4hemZpOWNleeLrOeahOS4gOS4quWxglxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhckxheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcbiAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOmHiuaUvlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5yb290LmlubmVySFRNTCA9ICcnO1xuXG4gICAgICAgICAgICB0aGlzLnJvb3QgPVxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID1cblxuICAgICAgICAgICAgdGhpcy5fZG9tUm9vdCA9XG4gICAgICAgICAgICB0aGlzLl9sYXllcnMgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY2FudmFzIHdoaWNoIGhhcyBhbGwgdGhpbmcgcmVuZGVyZWRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cbiAgICAgICAgICovXG4gICAgICAgIGdldFJlbmRlcmVkQ2FudmFzOiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgICAgICBpZiAodGhpcy5fc2luZ2xlQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1swXS5kb207XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbWFnZUxheWVyID0gbmV3IExheWVyKCdpbWFnZScsIHRoaXMsIG9wdHMucGl4ZWxSYXRpbyB8fCB0aGlzLmRwcik7XG4gICAgICAgICAgICBpbWFnZUxheWVyLmluaXRDb250ZXh0KCk7XG5cbiAgICAgICAgICAgIGltYWdlTGF5ZXIuY2xlYXJDb2xvciA9IG9wdHMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgaW1hZ2VMYXllci5jbGVhcigpO1xuXG4gICAgICAgICAgICB2YXIgZGlzcGxheUxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBzY29wZSA9IHt9O1xuICAgICAgICAgICAgdmFyIHpsZXZlbDtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgZnVuY3Rpb24gZmluZEFuZERyYXdPdGhlckxheWVyKHNtYWxsZXIsIGxhcmdlcikge1xuICAgICAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gc2VsZi5femxldmVsTGlzdDtcbiAgICAgICAgICAgICAgICBpZiAoc21hbGxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXIgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbnRlcm1lZGlhdGVMYXllcjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBzZWxmLl9sYXllcnNbel07XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18gJiYgeiA+IHNtYWxsZXIgJiYgeiA8IGxhcmdlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlTGF5ZXIgPSBsYXllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm1lZGlhdGVMYXllciAmJiBpbnRlcm1lZGlhdGVMYXllci5yZW5kZXJUb0NhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZUxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZUxheWVyLnJlbmRlclRvQ2FudmFzKGltYWdlTGF5ZXIuY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VMYXllci5jdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBkaXNwbGF5TGlzdFtpXTtcblxuICAgICAgICAgICAgICAgIGlmIChlbC56bGV2ZWwgIT09IHpsZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBmaW5kQW5kRHJhd090aGVyTGF5ZXIoemxldmVsLCBlbC56bGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICB6bGV2ZWwgPSBlbC56bGV2ZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgaW1hZ2VMYXllciwgdHJ1ZSwgc2NvcGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaW5kQW5kRHJhd090aGVyTGF5ZXIoemxldmVsLCBJbmZpbml0eSk7XG5cbiAgICAgICAgICAgIHJldHVybiBpbWFnZUxheWVyLmRvbTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPlue7mOWbvuWMuuWfn+WuveW6plxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W57uY5Zu+5Yy65Z+f6auY5bqmXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFNpemU6IGZ1bmN0aW9uICh3aElkeCkge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgICAgICAgICAgdmFyIHdoID0gWyd3aWR0aCcsICdoZWlnaHQnXVt3aElkeF07XG4gICAgICAgICAgICB2YXIgY3doID0gWydjbGllbnRXaWR0aCcsICdjbGllbnRIZWlnaHQnXVt3aElkeF07XG4gICAgICAgICAgICB2YXIgcGx0ID0gWydwYWRkaW5nTGVmdCcsICdwYWRkaW5nVG9wJ11bd2hJZHhdO1xuICAgICAgICAgICAgdmFyIHByYiA9IFsncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdCb3R0b20nXVt3aElkeF07XG5cbiAgICAgICAgICAgIGlmIChvcHRzW3doXSAhPSBudWxsICYmIG9wdHNbd2hdICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChvcHRzW3doXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgICAgICAgICAgLy8gSUU4IGRvZXMgbm90IHN1cHBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSwgYnV0IGl0IHVzZSBWTUwuXG4gICAgICAgICAgICB2YXIgc3RsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShyb290KTtcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAocm9vdFtjd2hdIHx8IHBhcnNlSW50MTAoc3RsW3doXSkgfHwgcGFyc2VJbnQxMChyb290LnN0eWxlW3doXSkpXG4gICAgICAgICAgICAgICAgLSAocGFyc2VJbnQxMChzdGxbcGx0XSkgfHwgMClcbiAgICAgICAgICAgICAgICAtIChwYXJzZUludDEwKHN0bFtwcmJdKSB8fCAwKVxuICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF0aFRvSW1hZ2U6IGZ1bmN0aW9uIChwYXRoLCBkcHIpIHtcbiAgICAgICAgICAgIGRwciA9IGRwciB8fCB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gcGF0aC5zdHlsZTtcbiAgICAgICAgICAgIHZhciBzaGFkb3dCbHVyU2l6ZSA9IHN0eWxlLnNoYWRvd0JsdXI7XG4gICAgICAgICAgICB2YXIgc2hhZG93T2Zmc2V0WCA9IHN0eWxlLnNoYWRvd09mZnNldFg7XG4gICAgICAgICAgICB2YXIgc2hhZG93T2Zmc2V0WSA9IHN0eWxlLnNoYWRvd09mZnNldFk7XG4gICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUuaGFzU3Ryb2tlKCkgPyBzdHlsZS5saW5lV2lkdGggOiAwO1xuXG4gICAgICAgICAgICB2YXIgbGVmdE1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIC1zaGFkb3dPZmZzZXRYICsgc2hhZG93Qmx1clNpemUpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0TWFyZ2luID0gTWF0aC5tYXgobGluZVdpZHRoIC8gMiwgc2hhZG93T2Zmc2V0WCArIHNoYWRvd0JsdXJTaXplKTtcbiAgICAgICAgICAgIHZhciB0b3BNYXJnaW4gPSBNYXRoLm1heChsaW5lV2lkdGggLyAyLCAtc2hhZG93T2Zmc2V0WSArIHNoYWRvd0JsdXJTaXplKTtcbiAgICAgICAgICAgIHZhciBib3R0b21NYXJnaW4gPSBNYXRoLm1heChsaW5lV2lkdGggLyAyLCBzaGFkb3dPZmZzZXRZICsgc2hhZG93Qmx1clNpemUpO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aCArIGxlZnRNYXJnaW4gKyByaWdodE1hcmdpbjtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodCArIHRvcE1hcmdpbiArIGJvdHRvbU1hcmdpbjtcblxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgICAgICBjdHguc2NhbGUoZHByLCBkcHIpO1xuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5kcHIgPSBkcHI7XG5cbiAgICAgICAgICAgIHZhciBwYXRoVHJhbnNmb3JtID0ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwYXRoLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBwYXRoLnJvdGF0aW9uLFxuICAgICAgICAgICAgICAgIHNjYWxlOiBwYXRoLnNjYWxlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGF0aC5wb3NpdGlvbiA9IFtsZWZ0TWFyZ2luIC0gcmVjdC54LCB0b3BNYXJnaW4gLSByZWN0LnldO1xuICAgICAgICAgICAgcGF0aC5yb3RhdGlvbiA9IDA7XG4gICAgICAgICAgICBwYXRoLnNjYWxlID0gWzEsIDFdO1xuICAgICAgICAgICAgcGF0aC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5icnVzaChjdHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgSW1hZ2VTaGFwZSA9IHJlcXVpcmUoJy4vZ3JhcGhpYy9JbWFnZScpO1xuICAgICAgICAgICAgdmFyIGltZ1NoYXBlID0gbmV3IEltYWdlU2hhcGUoe1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiBjYW52YXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHBhdGhUcmFuc2Zvcm0ucG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGltZ1NoYXBlLnBvc2l0aW9uID0gcGF0aC5wb3NpdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXRoVHJhbnNmb3JtLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbWdTaGFwZS5yb3RhdGlvbiA9IHBhdGgucm90YXRpb24gPSBwYXRoVHJhbnNmb3JtLnJvdGF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGF0aFRyYW5zZm9ybS5zY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW1nU2hhcGUuc2NhbGUgPSBwYXRoLnNjYWxlID0gcGF0aFRyYW5zZm9ybS5zY2FsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGltZ1NoYXBlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gUGFpbnRlcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9QYWludGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9MYXllclxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG4gICAgdmFyIFN0eWxlID0gcmVxdWlyZSgnLi9ncmFwaGljL1N0eWxlJyk7XG4gICAgdmFyIFBhdHRlcm4gPSByZXF1aXJlKCcuL2dyYXBoaWMvUGF0dGVybicpO1xuXG4gICAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDliJvlu7pkb21cbiAgICAgKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBkb20gaWQg5b6F55SoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgZG9tIHR5cGXvvIxzdWNoIGFzIGNhbnZhcywgZGl2IGV0Yy5cbiAgICAgKiBAcGFyYW0ge1BhaW50ZXJ9IHBhaW50ZXIgcGFpbnRlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVEb20oaWQsIHR5cGUsIHBhaW50ZXIsIGRwcikge1xuICAgICAgICB2YXIgbmV3RG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICAgICAgdmFyIHdpZHRoID0gcGFpbnRlci5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcGFpbnRlci5nZXRIZWlnaHQoKTtcblxuICAgICAgICB2YXIgbmV3RG9tU3R5bGUgPSBuZXdEb20uc3R5bGU7XG4gICAgICAgIC8vIOayoWFwcGVuZOWRou+8jOivt+WOn+iwheaIkei/meagt+WGme+8jOa4heaZsH5cbiAgICAgICAgbmV3RG9tU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBuZXdEb21TdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgbmV3RG9tU3R5bGUudG9wID0gMDtcbiAgICAgICAgbmV3RG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIG5ld0RvbVN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgIG5ld0RvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICBuZXdEb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgIC8vIGlk5LiN5L2c5Li657Si5byV55So77yM6YG/5YWN5Y+v6IO96YCg5oiQ55qE6YeN5ZCN77yM5a6a5LmJ5Li656eB5pyJ5bGe5oCnXG4gICAgICAgIG5ld0RvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtenItZG9tLWlkJywgaWQpO1xuICAgICAgICByZXR1cm4gbmV3RG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9MYXllclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Rwcl1cbiAgICAgKi9cbiAgICB2YXIgTGF5ZXIgPSBmdW5jdGlvbihpZCwgcGFpbnRlciwgZHByKSB7XG4gICAgICAgIHZhciBkb207XG4gICAgICAgIGRwciA9IGRwciB8fCBjb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRvbSA9IGNyZWF0ZURvbShpZCwgJ2NhbnZhcycsIHBhaW50ZXIsIGRwcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IHVzaW5nIGlzRG9tIGJlY2F1c2UgaW4gbm9kZSBpdCB3aWxsIHJldHVybiBmYWxzZVxuICAgICAgICBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGlkKSkge1xuICAgICAgICAgICAgZG9tID0gaWQ7XG4gICAgICAgICAgICBpZCA9IGRvbS5pZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuXG4gICAgICAgIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgICAgICAgaWYgKGRvbVN0eWxlKSB7IC8vIE5vdCBpbiBub2RlXG4gICAgICAgICAgICBkb20ub25zZWxlY3RzdGFydCA9IHJldHVybkZhbHNlOyAvLyDpgb/lhY3pobXpnaLpgInkuK3nmoTlsLTlsKxcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXVzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgICAgICAgICBkb21TdHlsZVsndXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgICAgIGRvbVN0eWxlWydwYWRkaW5nJ10gPSAwO1xuICAgICAgICAgICAgZG9tU3R5bGVbJ21hcmdpbiddID0gMDtcbiAgICAgICAgICAgIGRvbVN0eWxlWydib3JkZXItd2lkdGgnXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRvbUJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmN0eEJhY2sgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG5cbiAgICAgICAgdGhpcy5jb25maWcgPSBudWxsO1xuXG4gICAgICAgIC8vIENvbmZpZ3NcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOavj+asoea4heepuueUu+W4g+eahOminOiJslxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwLjdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdEZyYW1lQWxwaGEgPSAwLjc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExheWVyIGRwclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcHIgPSBkcHI7XG4gICAgfTtcblxuICAgIExheWVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogTGF5ZXIsXG5cbiAgICAgICAgZWxDb3VudDogMCxcblxuICAgICAgICBfX2RpcnR5OiB0cnVlLFxuXG4gICAgICAgIGluaXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuZG9tLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICB0aGlzLmN0eC5fX2N1cnJlbnRWYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY3R4LmRwciA9IHRoaXMuZHByO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUJhY2tCdWZmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdGhpcy5kb21CYWNrID0gY3JlYXRlRG9tKCdiYWNrLScgKyB0aGlzLmlkLCAnY2FudmFzJywgdGhpcy5wYWludGVyLCBkcHIpO1xuICAgICAgICAgICAgdGhpcy5jdHhCYWNrID0gdGhpcy5kb21CYWNrLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICB0aGlzLmN0eEJhY2suX19jdXJyZW50VmFsdWVzID0ge307XG5cbiAgICAgICAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5zY2FsZShkcHIsIGRwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgICAgICAgICAgdmFyIGRvbVN0eWxlID0gZG9tLnN0eWxlO1xuICAgICAgICAgICAgdmFyIGRvbUJhY2sgPSB0aGlzLmRvbUJhY2s7XG5cbiAgICAgICAgICAgIGRvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgZG9tU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAgICAgZG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgICAgICBkb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgICAgICBpZiAoZG9tQmFjaykge1xuICAgICAgICAgICAgICAgIGRvbUJhY2sud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgICAgICAgICBkb21CYWNrLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAgICAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suc2NhbGUoZHByLCBkcHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF56m66K+l5bGC55S75biDXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJBbGwgQ2xlYXIgYWxsIHdpdGggb3V0IG1vdGlvbiBibHVyXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKGNsZWFyQWxsKSB7XG4gICAgICAgICAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBkb20ud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZG9tLmhlaWdodDtcblxuICAgICAgICAgICAgdmFyIGNsZWFyQ29sb3IgPSB0aGlzLmNsZWFyQ29sb3I7XG4gICAgICAgICAgICB2YXIgaGF2ZU1vdGlvbkJMdXIgPSB0aGlzLm1vdGlvbkJsdXIgJiYgIWNsZWFyQWxsO1xuICAgICAgICAgICAgdmFyIGxhc3RGcmFtZUFscGhhID0gdGhpcy5sYXN0RnJhbWVBbHBoYTtcblxuICAgICAgICAgICAgdmFyIGRwciA9IHRoaXMuZHByO1xuXG4gICAgICAgICAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZG9tQmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUJhY2tCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgIGRvbSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggLyBkcHIsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAvIGRwclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBpZiAoY2xlYXJDb2xvcikge1xuICAgICAgICAgICAgICAgIHZhciBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47XG4gICAgICAgICAgICAgICAgLy8gR3JhZGllbnRcbiAgICAgICAgICAgICAgICBpZiAoY2xlYXJDb2xvci5jb2xvclN0b3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIGNhbnZhcyBncmFkaWVudFxuICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBjbGVhckNvbG9yLl9fY2FudmFzR3JhZGllbnQgfHwgU3R5bGUuZ2V0R3JhZGllbnQoY3R4LCBjbGVhckNvbG9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGF0dGVyblxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsZWFyQ29sb3IuaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuID0gUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybi5jYWxsKGNsZWFyQ29sb3IsIGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiB8fCBjbGVhckNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGxhc3RGcmFtZUFscGhhO1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoZG9tQmFjaywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IExheWVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4zLjYuM0B6cmVuZGVyL2xpYi9MYXllci5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOmAieS4reiKgueCueWQju+8jOWHuueOsOeahOaTjeS9nOahhuWPiuaMiemSrlxyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuICAgIHZhciBOb2RlID0gcmVxdWlyZShcIi4uL05vZGVcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XHJcbiAgICB2YXIgaWNvbiA9IHJlcXVpcmUoJy4vSWNvbk9wZXJhdGlvbicpO1xyXG4gICAgdmFyIHN5bWJvbFV0aWwgPSByZXF1aXJlKCcuLi9zaGFwZXMvU3ltYm9sJyk7XHJcbiAgICBmdW5jdGlvbiBPcGVyYXRpb25Ob2RlKG5vZGUsIHpyLCBhcGksZm9yYmlkRWRpdCkge1xyXG4gICAgICAgIE5vZGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMuenIgPSB6cjtcclxuICAgICAgICB0aGlzLmZvcmJpZEVkaXQgPSBmb3JiaWRFZGl0O1xyXG4gICAgICAgIHRoaXMuX2FwaSA9IGFwaTtcclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8v5LqL5Lu2XHJcbiAgICBPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUdFTkQgPSBcIk9wZXJhdGlvbk5vZGU6ZHJhZ2VuZEFycm93XCI7XHJcbiAgICBPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUcgPSBcIk9wZXJhdGlvbk5vZGU6ZHJhZ0Fycm93XCI7XHJcbiAgICBPcGVyYXRpb25Ob2RlLkFSUk9XX0RSQUdTVEFSVCA9IFwiT3BlcmF0aW9uTm9kZTpkcmFnc3RhcnRBcnJvd1wiO1xyXG4gICAgT3BlcmF0aW9uTm9kZS5ERUxFVEVfQ0xJQ0sgPSBcIk9wZXJhdGlvbk5vZGU6ZGVsZXRlQ2xpY2tcIjtcclxuICAgIE9wZXJhdGlvbk5vZGUuREVMID0gXCJERUxcIjtcclxuICAgIGlmKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7Ly9JRTjkuI3mlK/mjIFjYW52YXMg5Lul5Y+KYmFzZTY0ICDmraTlpITmmK/kuLrkuoblhbzlrrlJRTguIOWunumZhemDveWPr+S7peeUqFNWR+WbvuaghyzkvYbmsqHmnInmib7liLDlpb3nmoRTVkflm77moIcsIOWmguaenOacieeahOivnemCo+WwseayoeacieW/heimgeeUqOi/meS6m2Jhc2U2NOS6hlxyXG4gICAgICAgIC8v5YaF572u5pON5L2c5Zu+5qCH55qE5Zu+5YOPXHJcbiAgICAgICAgT3BlcmF0aW9uTm9kZS5vcGljb25zID0ge1xyXG4gICAgICAgICAgICBTVFJBSUdIVDogaWNvbi5TVFJBSUdIVF9TVkcsXHJcbiAgICAgICAgICAgIEpBR0dFRDogaWNvbi5KQUdHRURfU1ZHLFxyXG4gICAgICAgICAgICBDVVJWRTogaWNvbi5DVVJWRV9TVkcsXHJcbiAgICAgICAgICAgIERFTDogaWNvbi5ERUxfU1ZHXHJcbiAgICAgICAgfTtcclxuICAgIH1lbHNle1xyXG4gICAgICAgIE9wZXJhdGlvbk5vZGUub3BpY29ucyA9IHtcclxuICAgICAgICAgICAgU1RSQUlHSFQ6IGljb24uU1RSQUlHSFRfSU1HLFxyXG4gICAgICAgICAgICBKQUdHRUQ6IGljb24uSkFHR0VEX0lNRyxcclxuICAgICAgICAgICAgQ1VSVkU6IGljb24uQ1VSVkVfSU1HLFxyXG4gICAgICAgICAgICBERUw6IGljb24uREVMX1NWR1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJCYXNlKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZvcmJpZEVkaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJPdGhlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVuZGVyQmFzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlT3BlcmF0aW9uKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIE9wZXJhdGlvbk5vZGUucHJvdG90eXBlLmNyZWF0ZU9wZXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vZGUuc2VsZWN0U3R5bGUpIHtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsUmVjdCA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHsgc3R5bGU6IHsgbGluZURhc2g6IFsyXSB9IH0pO1xyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxSZWN0LmlzU2VsZkNvbXB1dGVQb3MgPSB0cnVlOyAgLy8g6Ieq5bex6K6h566X5L2N572uXHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMudmlydHVhbFJlY3QpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwaS5nZXRacigpLmFkZEhvdmVyKHRoaXMubm9kZSwgdGhpcy5ub2RlLnNlbGVjdFN0eWxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm5vZGUub3BlcmF0aW9uSWNvbnMpIHtcclxuICAgICAgICAgICAgenJVdGlsLmVhY2godGhpcy5ub2RlLm9wZXJhdGlvbkljb25zLCBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAvL+ajgOafpeaYr+WQpuaYr+WGhee9ruWbvuagh1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wSWNvbkluc3RhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciBvcGVyYXRpb25JY29uID0gT3BlcmF0aW9uTm9kZS5vcGljb25zW2l0ZW0ubmFtZS50b1VwcGVyQ2FzZSgpICsgXCJcIl1cclxuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb25JY29uKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvcmJpZEVkaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5uYW1lID09IE9wZXJhdGlvbk5vZGUuREVMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5Z6D5Zy+5qG2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wSWNvbkluc3RhbmNlID0gZ3JhcGhpYy5tYWtlUGF0aChvcGVyYXRpb25JY29uLCB7IHN0eWxlOiB7IGZpbGw6ICcjMDAwMDAwJyB9LHo6bWUubm9kZS56KzEscmVjdEhvdmVyOiB0cnVlIH0sIHsgeDogMCwgeTogMCwgd2lkdGg6IDEwLCBoZWlnaHQ6IDE1IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihpdGVtLmljb25QYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZSA9IG5ldyBncmFwaGljLkltYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTppdGVtLmljb25QYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDoxNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OjE1XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6OiBtZS5ub2RlLnogKyAyIC8vekluZGV4IOe9ruS4uiDoioLngrkrMiDoioLngrkrMeS4uue7hFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0uY2FsbGJhY2spe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2Uub24oXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm5vZGUgPSBtZS5ub2RlOyAgLy8g5bCG5omA6ZmE55qE6IqC54K55Lmf5Lyg6YCS5Ye65Y67XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jYWxsYmFjayhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IE9wZXJhdGlvbk5vZGUuREVMRVRFX0NMSUNLO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnRyaWdnZXIocGFyYW1zLnR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWVudi5jYW52YXNTdXBwb3J0ZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAxNSwgaGVpZ2h0OiAxNSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2UgPSBncmFwaGljLm1ha2VQYXRoKG9wZXJhdGlvbkljb24sIHsgc3R5bGU6IHsgZmlsbDogJyMwMDAwMDAnIH0sZHJhZ2dhYmxlOnRydWUsejptZS5ub2RlLnorMixsaW5lVHlwZTogQ29ubmVjdG9yW1wiVFlQRV9cIiArIGl0ZW0ubmFtZS50b1VwcGVyQ2FzZSgpXSxyZWN0SG92ZXI6IHRydWUgfSwgcmVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlVXJsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybC5zcmMgPSBpdGVtLmljb25QYXRoIHx8IG9wZXJhdGlvbkljb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZSA9IG5ldyBncmFwaGljLkltYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTppbWFnZVVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6MTUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDoxNVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHo6IG1lLm5vZGUueiArIDIsIC8vekluZGV4IOe9ruS4uiDoioLngrkrMiDoioLngrkrMeS4uue7hFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVUeXBlOiBDb25uZWN0b3JbXCJUWVBFX1wiICsgaXRlbS5uYW1lLnRvVXBwZXJDYXNlKCldIC8v5Yy65YiG5LiN5ZCM55qE57q/5q61XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydkcmFnc3RhcnQnLCAnZHJhZycsICdkcmFnZW5kJ107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKE1PVVNFX0VWRU5UX05BTUVTLCBmdW5jdGlvbihldmVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZS5vbihldmVOYW1lLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmRhdGEgPSBpdGVtLm9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiT3BlcmF0aW9uTm9kZTpcIiArIGV2ZU5hbWUgKyBcIkFycm93XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZSA9IHN5bWJvbFV0aWwuY3JlYXRlU3ltYm9sKGl0ZW0uaWNvblBhdGgsIDAsIDAsIGl0ZW0ud2lkdGggfHwgMTUsIGl0ZW0uaGVpZ2h0IHx8IDE1LCBtZS5ub2RlLnorMSwgaXRlbS5jb2xvcnx8JyMwMDAnKTtcclxuICAgICAgICAgICAgICAgICAgICBvcEljb25JbnN0YW5jZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhID0gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5ub2RlID0gbWUubm9kZTsgIC8vIOWwhuaJgOmZhOeahOiKgueCueS5n+S8oOmAkuWHuuWOu1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5jYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jYWxsYmFjayhlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSB7ZXZlbnQ6ZSwgdHlwZTpcIk9wZXJhdGlvbk5vZGU6XCIgKyBpdGVtLm5hbWUgKyBcIkNsaWNrXCJ9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5fYXBpLnRyaWdnZXIocGFyYW0udHlwZSwgcGFyYW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3BJY29uSW5zdGFuY2UubmFtZSA9IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgICAgIG1lLmFkZChvcEljb25JbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVmcmVzaFBvc3Rpb24gPSBmdW5jdGlvbihub2RlLG5vZGVSZWN0KSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciByYlBvaW50ID0gbm9kZVJlY3QucG9pbnRzWzJdOyAvL+WPluWPs+S4i+inkuWdkOagh1xyXG4gICAgICAgIC8vMS7lrprkvY3omZrmoYZcclxuICAgICAgICB0aGlzLnZpcnR1YWxSZWN0ICYmIHRoaXMudmlydHVhbFJlY3Quc2V0U2hhcGUoeyBwb2ludHM6IG5vZGVSZWN0LnBvaW50cyB9KTtcclxuICAgICAgICAvLzIu5a6a5L2N5q+P5Liq5bCP5Zu+5qCHXHJcbiAgICAgICAgdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24obm9kZUl0ZW0pIHtcclxuICAgICAgICAgICAgaWYgKCFub2RlSXRlbS5pc1NlbGZDb21wdXRlUG9zKSB7XHJcbiAgICAgICAgICAgICAgICAvLyA4cHjmmK/nrKzkuIDkuKrmk43kvZzmjInpkq7lm77moIfnmoTot53nprsg6Z2g5aSq6L+R5LiN5aW955yLICAgIDIwcHjmmK/mr4/kuKrlm77moIfnmoTpl7TpmpQgIDEwcHjmmK/lm77moIflkJHlgY/nmoTot53nprtcclxuICAgICAgICAgICAgICAgIG5vZGVJdGVtLmF0dHIoXCJwb3NpdGlvblwiLCBbcmJQb2ludFswXSArIDggKyAoaSsrICogMjApLCByYlBvaW50WzFdIC0gMTBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbk90aGVyKG5vZGUsbm9kZVJlY3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICBPcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5yZW5kZXJPdGhlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8v55WZ57uZ5omp5bGV5L2/55SoXHJcbiAgICB9O1xyXG4gICAgT3BlcmF0aW9uTm9kZS5wcm90b3R5cGUucmVmcmVzaFBvc2l0aW9uT3RoZXIgPSBmdW5jdGlvbihub2RlLG5vZGVSZWN0KSB7XHJcbiAgICAgICAgLy/nlZnnu5nmianlsZXkvb/nlKhcclxuICAgICAgICAvLzMu5a6a5L2N5pW05Liqb3BlcmF0aW9uTm9kZVxyXG4gICAgICAgIGlmIChub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC5pc0JnICYmIG5vZGUucGFyZW50LmlzQmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmF0dHIoXCJwb3NpdGlvblwiLCBbbm9kZVJlY3QueCwgbm9kZVJlY3QueV0pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG5vZGVTaGFwZVggPSBub2RlLnNoYXBlPyBub2RlLnNoYXBlLng6MDtcclxuICAgICAgICAgICAgdmFyIG5vZGVTYWhwZVkgPSBub2RlLnNoYXBlPyBub2RlLnNoYXBlLnk6MDtcclxuICAgICAgICAgICAgdGhpcy5hdHRyKFwicG9zaXRpb25cIiwgW25vZGVSZWN0LnggKyBub2RlLnBhcmVudC5wb3NpdGlvblswXStub2RlU2hhcGVYLCBub2RlUmVjdC55ICsgbm9kZS5wYXJlbnQucG9zaXRpb25bMV0rbm9kZVNhaHBlWV0pXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBPcGVyYXRpb25Ob2RlLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYodGhpcy5ub2RlLnNlbGVjdFN0eWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwaS5nZXRacigpLnJlbW92ZUhvdmVyKHRoaXMubm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoT3BlcmF0aW9uTm9kZSwgTm9kZSk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE9wZXJhdGlvbk5vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9PcGVyYXRpb25Ob2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi9ncmFwaGljJyk7XHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIilcclxuICAgIC8v5Yib5bu6Tm9kZeexuyDmiYDmnInlvaLnirbpg73nu6fmib9Ob2RlICDljIXmi6xmcm9tSlNPTiB0b0pTT05cclxuICAgIGZ1bmN0aW9uIE5vZGUoKSB7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZUlkID0gdXRpbC5nZXRVVUlEKCk7IC8vIOeUn+aIkOiKgueCuUlEXHJcbiAgICAgICAgZ3JhcGhpYy5Hcm91cC5jYWxsKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog55Sx54i257G75a6e546wXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgTm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOeUseeItuexu+WunueOsFxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBqc29uIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLmdldFJlY3QgPSBmdW5jdGlvbihqc29uKSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGRyYXdUZXh0XHJcbiAgICAgKiBAZGVzY3JpcHRpb24g55S75LiA5Liq5paH5pysXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLmRyYXdUZXh0ID0gZnVuY3Rpb24obmFtZSxjb2xvcikge1xyXG4gICAgICAgIHZhciB0ZXh0TmFtZSA9IHRoaXMuYnBtbkluZm8ubmFtZTtcclxuICAgICAgICBpZihuYW1lICE9IG51bGwpe1xyXG4gICAgICAgICAgICB0ZXh0TmFtZSA9IG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0TmFtZSxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvciA/IGNvbG9yIDogdGhpcy5vcHRpb25zLnRleHQuY29sb3IsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzEycHggTWljcm9zb2Z0IFlhSGVpJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6bGV2ZWw6IDIwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy/mloflrZfnu5jliLbnmoTkvY3nva4gIFxyXG4gICAgICAgIC8veCA9IOS4reW/g+eCuS54IC0g6LW35aeL5L2N572uLnggLSDmloflrZflrr3luqbnmoTkuIDljYpcclxuICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0UmVjdCgpLnggLSB0aGlzLnBvc2l0aW9uWzBdIC0gdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAvIDI7XHJcbiAgICAgICAgLy95ID0g5Lit5b+D54K5LnkgLSDotbflp4vkvY3nva4ueSArIOiKgueCuemrmOW6pueahOS4gOWNiiArIOWBj+enu+WAvO+8iDbvvIlcclxuICAgICAgICB2YXIgeSA9IHRoaXMuZ2V0UmVjdCgpLnkgLSB0aGlzLnBvc2l0aW9uWzFdICsgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyICsgdGV4dC5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgKyA2O1xyXG4gICAgICAgIHRleHQuYXR0cihcInN0eWxlXCIsIHsgeDogeCwgeTogeSB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICAgICAgICByZWN0OiB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIHJlZnJlc2hUZXh0XHJcbiAgICAgKiBAZGVzY3JpcHRpb24g5Yi35paw5paH5pysXHJcbiAgICAgKi9cclxuICAgIE5vZGUucHJvdG90eXBlLnJlZnJlc2hUZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmNoaWxkT2ZOYW1lKFwiVGl0bGVcIik7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLmdldFJlY3QoKS54IC0gdGhpcy5wb3NpdGlvblswXSAtIHRleHQuZ2V0Qm91bmRpbmdSZWN0KCkud2lkdGggLyAyO1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRSZWN0KCkueSAtIHRoaXMucG9zaXRpb25bMV0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAvIDIgKyB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCArIDY7XHJcbiAgICAgICAgdGV4dC5hdHRyKFwic3R5bGVcIiwgeyB4OiB4LCB5OiB5IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog55Sx54i257G75a6e546wXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgTm9kZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICBncmFwaGljLlV0aWwuaW5oZXJpdHMoTm9kZSwgZ3JhcGhpYy5Hcm91cCk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE5vZGU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOi/nuaOpee6v1xyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuICAgIHZhciBVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi9ncmFwaGljLmpzXCIpO1xyXG4gICAgdmFyIE5vZGUgPSByZXF1aXJlKFwiLi4vTm9kZS5qc1wiKTtcclxuICAgIHZhciBzeW1ib2xVdGlsID0gcmVxdWlyZShcIi4vU3ltYm9sLmpzXCIpO1xyXG4gICAgdmFyIEhhbmRsZSA9IHJlcXVpcmUoXCIuL0hhbmRsZS5qc1wiKTtcclxuICAgIHZhciBFZmZlY3RMaW5lID0gcmVxdWlyZShcIi4vRWZmZWN0TGluZS5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0aW9uUG9pbnQgPSByZXF1aXJlKFwiLi9Db25uZWN0aW9uUG9pbnQuanNcIik7XHJcbiAgICB2YXIgUG9pbnQgPSByZXF1aXJlKFwiLi4vUG9pbnQuanNcIik7XHJcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKFwiLi4vbW9kZWwuanNcIik7XHJcblxyXG4gICAgQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQgPSAnc3RyYWlnaHQnO1xyXG4gICAgQ29ubmVjdG9yLlRZUEVfSkFHR0VEID0gJ2phZ2dlZCc7XHJcbiAgICBDb25uZWN0b3IuVFlQRV9DVVJWRSA9ICdjdXJ2ZSc7XHJcbiAgICBDb25uZWN0b3IuUkFESVVTID0gMztcclxuICAgIENvbm5lY3Rvci5TVEFSVF9OT0RFID0gXCJzdGFydE5vZGVcIjtcclxuICAgIENvbm5lY3Rvci5FTkRfTk9ERSA9IFwiZW5kTm9kZVwiO1xyXG4gICAgQ29ubmVjdG9yLkxFRlQgPSBcImxlZnRcIjtcclxuICAgIENvbm5lY3Rvci5SSUdIVCA9IFwicmlnaHRcIjtcclxuICAgIENvbm5lY3Rvci5UT1AgPSBcInRvcFwiO1xyXG4gICAgQ29ubmVjdG9yLkJPVFRPTSA9IFwiYm90dG9tXCI7XHJcbiAgICBDb25uZWN0b3IuQk9UVE9NID0gXCJib3R0b21cIjtcclxuICAgIENvbm5lY3Rvci5TRVBFUkFUT1IgPSBcIi1cIjtcclxuICAgIENvbm5lY3Rvci5OT1JNQUxfQ09MT1IgPSBcIiNCQkJCQkJcIjtcclxuICAgIENvbm5lY3Rvci5TRUxFQ1RFRF9DT0xPUiA9ICcjNzRCN0UwJztcclxuICAgIC8qKlxyXG4gICAgICog5p6E6YCg5Ye95pWwXHJcbiAgICAgKiBAcGFyYW0ge1t0eXBlXX0gb3B0aW9ucyBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENvbm5lY3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgTm9kZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIGlmIChvcHQubW9kZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZUlkID0gb3B0Lm1vZGVsLmdldChcInJlc291cmNlSWRcIik7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSBvcHQubW9kZWw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZUlkID0gVXRpbC5nZXRVVUlEKCk7IC8vIOeUn+aIkOiKgueCuUlEXHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSBuZXcgTW9kZWwoe30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHN5bWJvbDogeyB0eXBlOiBcImFycm93XCIsIHNpemU6IDEwLCBjb2xvcjogQ29ubmVjdG9yLk5PUk1BTF9DT0xPUiwgYm90aDpmYWxzZSB9LCAvL+eureWktCAg5Y+v6YCJ5YC85Li677yaICdjaXJjbGUnLCAncmVjdCcsICdyb3VuZFJlY3QnLCAndHJpYW5nbGUnLCAnZGlhbW9uZCcsICdwaW4nLCAnYXJyb3cnXHJcbiAgICAgICAgICAgIHN0eWxlOiB7IGxpbmVXaWR0aDogMSwgc3Ryb2tlOiBDb25uZWN0b3IuTk9STUFMX0NPTE9SLCBsaW5lVHlwZTogQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQgfSwgLy/moLflvI9cclxuICAgICAgICAgICAgaG92ZXJTdHlsZTogeyBsaW5lV2lkdGg6IDIsIHN0cm9rZTogQ29ubmVjdG9yLlNFTEVDVEVEX0NPTE9SIH0sIC8v56e75LiK5Y6755qE5qC35byPXHJcbiAgICAgICAgICAgIGFycm93SG92ZXJTdHlsZTogeyBmaWxsOiBDb25uZWN0b3IuU0VMRUNURURfQ09MT1J9LFxyXG4gICAgICAgICAgICBzaGFwZTogeyBwb2ludHM6IG51bGwsIHNtb290aDogZmFsc2UsIHNtb290aENvbnN0cmFpbnQ6IG51bGwgfSwgLy/lvaLnirZcclxuICAgICAgICAgICAgcG9zaXRpb246IHsgc3RhcnRQb3M6bnVsbCwgZW5kUG9zOm51bGwsICAvL+aMh+Wumue6v+autei1t+Wni+S4jue7iOatoiDlnKjoioLngrnnmoTku4DkuYjkvY3nva4g6buY6K6k5YC85Li6J2xlZnQscmlnaHQnICDlj6/lj5blgLzlm5vkuKrmlrnlkJF0b3AsYm90dG9tLGxlZnQscmlnaHQg5pa55ZCR5Y+v5Yqg5YGP56e76YeP5aaC5aaCIFwibGVmdCsxMCx0b3BcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE9mZnNldDpbMCwwXSwgIC8vIOi1t+Wni+e6v+auteemu+iKgueCueeahOWBj+enu1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRPZmZzZXQ6WzAsMF0sICAgIC8vIOe7iOatoue6v+auteemu+iKgueCueeahOWBj+enu1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVEaXN0YW5jZTpbMzAsMzBdLCAvLyDnrKzkuIDmnaHmipjnur/nmoTplb/luqbvvIzmnIDlkI7kuIDmnaHmipjnur/nmoTplb/luqZcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOm51bGwgICAgLy/kuI3kvb/nlKjoh6rliqjorqHnrpcg5oyH5a6a6L+e57q/55qE5oqY54K55L2N572u5pWw57uE77yM6aaW5bC+5Y+v5Lul5L2/55SobGVmdCxyaWdodCx0b3AsYm90dG9tXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXV0b0NoYW5nZVBvc2l0aW9uOiBmYWxzZSxcclxuICAgICAgICAgICAgaXNFZGl0OiB0cnVlLCAvL+aYr+WQpuWPr+e8lui+kVxyXG4gICAgICAgICAgICB0ZXh0OiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMDAwMDAwJywgLy8g5paH5pys6aKc6ImyXHJcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogJzEycHggTWljcm9zb2Z0IFlhSGVpJyxcclxuICAgICAgICAgICAgICAgIHRleHRQb3M6ICdjZW50ZXInXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHo6IDBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHpyVXRpbC5tZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0LCB0cnVlKTtcclxuICAgICAgICB0aGlzLmhhbmRsZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvblBvaW50c0dyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcclxuICAgICAgICB0aGlzLnN0YXJ0Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbmROb2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxpbmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZSA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgdGhpcy5pY29ucyA9IFtdOyAvLyDnlKjkuo7lrZjlgqjnur/mrrXkuIrpnaLnmoTmk43kvZzlm77moIdcclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOmHjeaWsOeUu+e6v++8jOWmguaenOS8oOepuuWImeagueaNrnR1cm5pbmdQb2ludHMg6YeN5paw55S757q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHBvaW50cyBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKGFyclBvaW50cykge1xyXG4gICAgICAgIGlmIChhcnJQb2ludHMpIHtcclxuICAgICAgICAgICAgdGhpcy50dXJuaW5nUG9pbnRzID0gYXJyUG9pbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+Wwhlt4OjAseTowXei9rOWMluS4ulswLCAwXSAg57uZenJlbmRlcuS9v+eUqFxyXG4gICAgICAgIHZhciBwb2ludHMgPSBVdGlsLnRyYXNsYXRlUG9pbnRzKHRoaXMudHVybmluZ1BvaW50cyk7XHJcblxyXG4gICAgICAgIGlmICgodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSAmJiAocG9pbnRzLmxlbmd0aCA+IDIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5Q3VydmUodGhpcy50dXJuaW5nUG9pbnRzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmUuYXR0cignc2hhcGUnLCB7IHBvaW50czogcG9pbnRzIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICAvL+W8gOWni+ayoeacieWIm+W7uuaWh+acrO+8jOWQjuadpeS8oOi/m+adpXRleHTkuobvvIzpnIDopoHlhYjliJvlu7rmlofmnKxcclxuICAgICAgICBpZiAoIWxpbmVUZXh0ICYmIHRoaXMub3B0aW9ucy50ZXh0LnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmRyYXdUZXh0KFwibGluZVRleHRcIiwgdGhpcy5vcHRpb25zLnRleHQudGV4dCwgMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHRleHQudGV4dCk7XHJcbiAgICAgICAgICAgIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpbmVUZXh0KSB7XHJcbiAgICAgICAgICAgIGxpbmVUZXh0LnNldFN0eWxlKFwidGV4dFwiLCB0aGlzLm9wdGlvbnMudGV4dC50ZXh0KTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZXh0UG9pbnQgPSB0aGlzLmdldFRleHRQb3N0aW9uKHRoaXMub3B0aW9ucy50ZXh0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfU1RSQUlHSFQgKSB7XHJcbiAgICAgICAgICAgIC8vICAgICBsaW5lVGV4dC5hdHRyKCdyb3RhdGlvbicsIHRoaXMuZ2V0VGV4dFJvdGF0aW9uKHRleHRQb2ludCkpO1xyXG4gICAgICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgICAgICBsaW5lVGV4dC5hdHRyKFwicG9zaXRpb25cIiwgdGV4dFBvaW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVmcmVzaEZyb21Ub1N5bWJvbChwb2ludHMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5riy5p+TXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgLy8xLuWIm+W7uueureWktFxyXG4gICAgICAgIHRoaXMucmVuZGVyRnJvbVRvU3ltYm9sKCk7XHJcblxyXG4gICAgICAgIC8vMi7liJvlu7rnur9cclxuICAgICAgICB0aGlzLmN1cnZlTGluZSA9IG5ldyBncmFwaGljLkJlemllckN1cnZlKHtcclxuICAgICAgICAgICAgLy9wb3NpdGlvbjogdGhpcy5vcHRpb25zLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICBzdHlsZTogdGhpcy5vcHRpb25zLnN0eWxlLFxyXG4gICAgICAgICAgICB6OiB0aGlzLm9wdGlvbnMuelxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZS5hZGQodGhpcy5jdXJ2ZUxpbmUpO1xyXG4gICAgICAgIHRoaXMuYWRkKHRoaXMuZ3JvdXBDdXJ2ZSk7XHJcbiAgICAgICAgdGhpcy5hZGQodGhpcy5jb25Qb2ludHNHcm91cCk7XHJcblxyXG4gICAgICAgIHRoaXMucG9seUxpbmUgPSBuZXcgZ3JhcGhpYy5Qb2x5bGluZSh7XHJcbiAgICAgICAgICAgIC8vcG9zaXRpb246IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcclxuICAgICAgICAgICAgc2hhcGU6IHRoaXMub3B0aW9ucy5zaGFwZSxcclxuICAgICAgICAgICAgc3R5bGU6IHRoaXMub3B0aW9ucy5zdHlsZSxcclxuICAgICAgICAgICAgejogdGhpcy5vcHRpb25zLnpcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZCh0aGlzLnBvbHlMaW5lKTtcclxuXHJcbiAgICAgICAgaWYgKCh0aGlzLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfQ1VSVkUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZSA9IHRoaXMuZ3JvdXBDdXJ2ZTtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVIb3ZlclN0eWxlKHRoaXMuY3VydmVMaW5lKTtcclxuICAgICAgICAgICAgdGhpcy5wb2x5TGluZS5oaWRlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lID0gdGhpcy5wb2x5TGluZTtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVIb3ZlclN0eWxlKHRoaXMucG9seUxpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnZlTGluZS5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLzMu5L6m5ZCs57q/5LqL5Lu2XHJcbiAgICAgICAgdmFyIE1PVVNFX0VWRU5UX05BTUVTID0gWydkYmxjbGljaycsICdjbGljayddOyAvLydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnXHJcbiAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lLm9uKGV2ZU5hbWUsIHpyVXRpbC5iaW5kKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudHlwZSA9IFwiQ29ubmVjdG9yOlwiICsgZXZlTmFtZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGF0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdHlsZSh7Y29sb3I6Q29ubmVjdG9yLlNFTEVDVEVEX0NPTE9SfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlzRWRpdCA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNFZGl0ICYmIHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlQWxsY29ubmVjdGlvblBvaW50KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhbmRsZXMubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcGVTZXRIYW5kbGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgLy80LuWIm+W7uue6v+S4iuaWh+acrFxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dC50ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5kcmF3VGV4dChcImxpbmVUZXh0XCIsIHRoaXMub3B0aW9ucy50ZXh0LnRleHQsIDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmFkZCh0ZXh0LnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5yZW5kZXJGcm9tVG9TeW1ib2wgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHN5bWJvbFRvID0gdGhpcy5jcmVhdGVTeW1ib2woJ3RvU3ltYm9sJywgdGhpcy5vcHRpb25zKTsgLy9hcnJvdyx0cmlhbmdsZVxyXG4gICAgICAgIGlmIChzeW1ib2xUbykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZChzeW1ib2xUbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5aaC5p6c5Y+M5ZCR566t5aS0IOWImeWGjeWIm+W7uummlueureWktFxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3ltYm9sLmJvdGgpIHtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbEZyb20gPSB0aGlzLmNyZWF0ZVN5bWJvbCgnZnJvbVN5bWJvbCcsIHRoaXMub3B0aW9ucyk7IC8vYXJyb3csdHJpYW5nbGVcclxuICAgICAgICAgICAgaWYgKHN5bWJvbEZyb20pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHN5bWJvbEZyb20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUucmVmcmVzaEZyb21Ub1N5bWJvbCA9IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICAgIHZhciBzeW1ib2xUbyA9IHRoaXMuY2hpbGRPZk5hbWUoJ3RvU3ltYm9sJyk7XHJcbiAgICAgICAgdmFyIHN5bWJvbEZyb20gPSB0aGlzLmNoaWxkT2ZOYW1lKCdmcm9tU3ltYm9sJyk7XHJcbiAgICAgICAgaWYgKHN5bWJvbFRvKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWZmZWN0ICYmIHRoaXMub3B0aW9ucy5lZmZlY3Quc2hvdykge1xyXG4gICAgICAgICAgICAgICAgbmV3IEVmZmVjdExpbmUoc3ltYm9sVG8sIHRoaXMub3B0aW9ucywgdGhpcy5ncm91cEN1cnZlLCB0aGlzLnBvbHlMaW5lKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFRvLmF0dHIoJ3Bvc2l0aW9uJywgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUby5hdHRyKCdyb3RhdGlvbicsIFV0aWwudGFuZ2VudFJvdGF0aW9uKHRoaXMudHVybmluZ1BvaW50c1t0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMl0sIHRoaXMudHVybmluZ1BvaW50c1t0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN5bWJvbEZyb20pIHtcclxuICAgICAgICAgICAgc3ltYm9sRnJvbS5hdHRyKCdwb3NpdGlvbicsIHBvaW50c1swXSk7XHJcbiAgICAgICAgICAgIHN5bWJvbEZyb20uYXR0cigncm90YXRpb24nLCBVdGlsLnRhbmdlbnRSb3RhdGlvbih0aGlzLnR1cm5pbmdQb2ludHNbMV0sIHRoaXMudHVybmluZ1BvaW50c1swXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8v6K6+572uc3R5bGVcclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHN5bWJvbFRvID0gbnVsbDtcclxuICAgICAgICBpZiAob3B0aW9ucy5jb2xvcikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuZWFjaENoaWxkKGZ1bmN0aW9uKGN1cnZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VydmUuYXR0cihcInN0eWxlXCIsIHsgc3Ryb2tlOiBvcHRpb25zLmNvbG9yIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUoY3VydmUsIHsgc3Ryb2tlOiBvcHRpb25zLmNvbG9yIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvbHlMaW5lLmF0dHIoXCJzdHlsZVwiLCB7IHN0cm9rZTogb3B0aW9ucy5jb2xvciB9KTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0Tm9ybWFsU3R5bGUodGhpcy5wb2x5TGluZSwgeyBzdHJva2U6IG9wdGlvbnMuY29sb3IgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3ltYm9sVG8gPSB0aGlzLmNoaWxkT2ZOYW1lKCd0b1N5bWJvbCcpO1xyXG4gICAgICAgICAgICBpZiAoc3ltYm9sVG8pIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFRvLmF0dHIoXCJzdHlsZVwiLCB7IGZpbGw6IG9wdGlvbnMuY29sb3IgfSk7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljLnNldE5vcm1hbFN0eWxlKHN5bWJvbFRvLCB7IGZpbGw6IG9wdGlvbnMuY29sb3IgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN0eWxlLnN0cm9rZSA9IG9wdGlvbnMuY29sb3I7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5zdHlsZS5zdHJva2VcIiwgb3B0aW9ucy5jb2xvcik7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KFwib3B0aW9ucy5zeW1ib2wuY29sb3JcIiwgb3B0aW9ucy5jb2xvcik7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zeW1ib2wuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMudGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgbGluZVRleHQgPSB0aGlzLmNoaWxkT2ZOYW1lKCdsaW5lVGV4dCcpO1xyXG4gICAgICAgICAgICAvL+W8gOWni+ayoeacieWIm+W7uuaWh+acrO+8jOWQjuadpeS8oOi/m+adpXRleHTkuobvvIzpnIDopoHlhYjliJvlu7rmlofmnKxcclxuICAgICAgICAgICAgaWYgKCFsaW5lVGV4dCAmJiBvcHRpb25zLnRleHQudGV4dCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmRyYXdUZXh0KFwibGluZVRleHRcIiwgb3B0aW9ucy50ZXh0LnRleHQsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQodGV4dC50ZXh0KTtcclxuICAgICAgICAgICAgICAgIGxpbmVUZXh0ID0gdGhpcy5jaGlsZE9mTmFtZSgnbGluZVRleHQnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGV4dC50ZXh0IHx8IG9wdGlvbnMudGV4dC50ZXh0ID09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVUZXh0LnNldFN0eWxlKFwidGV4dFwiLCBvcHRpb25zLnRleHQudGV4dCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGV4dC50ZXh0ID0gb3B0aW9ucy50ZXh0LnRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRleHRQb2ludCA9IHRoaXMuZ2V0VGV4dFBvc3Rpb24ob3B0aW9ucy50ZXh0KTtcclxuICAgICAgICAgICAgbGluZVRleHQuYXR0cihcInBvc2l0aW9uXCIsIHRleHRQb2ludCk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRleHQudGV4dFBvcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRleHQudGV4dFBvcyA9IG9wdGlvbnMudGV4dC50ZXh0UG9zO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50ZXh0LmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lVGV4dC5hdHRyKFwic3R5bGVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IG9wdGlvbnMudGV4dC5jb2xvclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGV4dC5jb2xvciA9IG9wdGlvbnMudGV4dC5jb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMudGV4dFwiLCBvcHRpb25zLnRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN5bWJvbC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3ltYm9sLnR5cGUgPSBvcHRpb25zLnN5bWJvbC50eXBlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zLnN5bWJvbC50eXBlXCIsIG9wdGlvbnMuc3ltYm9sLnR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN5bWJvbC5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3ltYm9sLnNpemUgPSBvcHRpb25zLnN5bWJvbC5zaXplO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zLnN5bWJvbC5zaXplXCIsIG9wdGlvbnMuc3ltYm9sLnNpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN5bWJvbC5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN5bWJvbC5jb2xvciA9IG9wdGlvbnMuc3ltYm9sLmNvbG9yO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zLnN5bWJvbC5jb2xvclwiLCBvcHRpb25zLnN5bWJvbC5jb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3ltYm9sLnopIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zeW1ib2wueiA9IG9wdGlvbnMuc3ltYm9sLno7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuc3ltYm9sLnpcIiwgb3B0aW9ucy5zeW1ib2wueik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN5bWJvbFRvID0gdGhpcy5jaGlsZE9mTmFtZSgndG9TeW1ib2wnKTtcclxuICAgICAgICAgICAgaWYgKHN5bWJvbFRvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShzeW1ib2xUbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHRoaXMuY3JlYXRlU3ltYm9sKFwidG9TeW1ib2xcIiwgdGhpcy5tb2RlbC5nZXQoXCJvcHRpb25zXCIpKVxyXG4gICAgICAgICAgICBpZiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChzeW1ib2wpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bnur/mrrXnmoTkvY3nva5cclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gdGV4dCB7dGV4dDonJywgY29sb3I6JycsIHRleHRQb3M6Jyd9XHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAge3gseX1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5nZXRUZXh0UG9zdGlvbiA9IGZ1bmN0aW9uKHRleHQpIHtcclxuICAgICAgICB2YXIgdGV4dFBvc3Rpb24gPSBbXTtcclxuICAgICAgICB2YXIgdGV4dFdpZHRoID0gZ3JhcGhpYy50ZXh0Q29udGFpbi5nZXRXaWR0aCh0ZXh0LnRleHQsIHRleHQudGV4dEZvbnQpO1xyXG4gICAgICAgIGlmICh0ZXh0ICYmIHRleHQudGV4dFBvcykge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGV4dC5vZmZzZXQgfHwgMDtcclxuICAgICAgICAgICAgdmFyIGFyck9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShvZmZzZXQpKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJPZmZzZXQgPSBbb2Zmc2V0LCAwXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGV4dC50ZXh0UG9zID09ICdzdGFydCcpIHtcclxuICAgICAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW3RoaXMudHVybmluZ1BvaW50c1swXS54ICsgYXJyT2Zmc2V0WzBdLCB0aGlzLnR1cm5pbmdQb2ludHNbMF0ueSArIGFyck9mZnNldFsxXV07XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dC50ZXh0UG9zID09ICdlbmQnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gVXRpbC5nZXRNYXhMaW5lTGVuZ3RoKFt0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCAtIDJdLCB0aGlzLnR1cm5pbmdQb2ludHNbdGhpcy50dXJuaW5nUG9pbnRzLmxlbmd0aCAtIDFdXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBVdGlsLmdldEFuZ2xlKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBVdGlsLmRpc3RhbmNlKHBvaW50c1swXSwgcG9pbnRzWzFdKSAtIHRleHRXaWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdQb2ludCA9IFV0aWwuZ2V0RW5kUG9pbnQocG9pbnRzWzBdLCBsZW5ndGgsIGFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW25ld1BvaW50LnggKyBhcnJPZmZzZXRbMF0sIG5ld1BvaW50LnkgKyBhcnJPZmZzZXRbMV1dO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pZFBvaW50ID0gdGhpcy5taWRkbGUodGV4dCk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0UG9zdGlvbiA9IFttaWRQb2ludFswXSArIGFyck9mZnNldFswXSwgbWlkUG9pbnRbMV0gKyBhcnJPZmZzZXRbMV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5taWRkbGUodGV4dCk7XHJcbiAgICAgICAgICAgIHRleHRQb3N0aW9uID0gW3Bvc2l0aW9uWzBdIC0gdGV4dFdpZHRoIC8gMiwgcG9zaXRpb25bMV1dO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHRQb3N0aW9uO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPlue6v+auteeahOaXi+i9rOinkuW6plxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSB0ZXh0UG9zdGlvbiB7eCx5fVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICDop5LluqblgLxcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5nZXRUZXh0Um90YXRpb24gPSBmdW5jdGlvbih0ZXh0UG9zdGlvbikge1xyXG4gICAgICAgIC8v6K6h566X5Ye65p6B5Z2Q5qCH55qE6KeS5bqmXHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFV0aWwuZ2V0TWF4TGluZUxlbmd0aCh0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgIHZhciBhbmdsZSA9IC1NYXRoLmF0YW4yKHBvaW50c1sxXS55IC0gdGV4dFBvc3Rpb25bMV0sIHBvaW50c1sxXS54IC0gdGV4dFBvc3Rpb25bMF0pOyAvLyxNYXRoLlBJLzJcclxuICAgICAgICByZXR1cm4gYW5nbGU7XHJcbiAgICB9O1xyXG5cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY3JlYXRlSG92ZXJTdHlsZSA9IGZ1bmN0aW9uKGVsKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob3ZlclN0eWxlKSB7XHJcbiAgICAgICAgICAgIGdyYXBoaWMuc2V0RWxlbWVudEhvdmVyU3RsKGVsLCB0aGlzLm9wdGlvbnMuaG92ZXJTdHlsZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3ltYm9sVG8gPSB0aGlzLmNoaWxkT2ZOYW1lKCd0b1N5bWJvbCcpO1xyXG4gICAgICAgICAgICBpZiAoc3ltYm9sVG8pIHsgZ3JhcGhpYy5zZXRFbGVtZW50SG92ZXJTdGwoc3ltYm9sVG8sIHRoaXMub3B0aW9ucy5hcnJvd0hvdmVyU3R5bGUpOyB9XHJcblxyXG4gICAgICAgICAgICBlbC5vbignbW91c2VvdmVyJywgenJVdGlsLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5kb0VudGVySG92ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzeW1ib2xUbykgeyBncmFwaGljLmRvRW50ZXJIb3ZlcihzeW1ib2xUbyk7IH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlLmVhY2hDaGlsZChmdW5jdGlvbihsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWMuZG9FbnRlckhvdmVyKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgenJVdGlsLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5kb0xlYXZlSG92ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzeW1ib2xUbykgeyBncmFwaGljLmRvTGVhdmVIb3ZlcihzeW1ib2xUbyk7IH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuZWFjaENoaWxkKGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5kb0xlYXZlSG92ZXIobGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu6Tm9kZeeahOi/nuaOpeeCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5jcmVhdGVBbGxjb25uZWN0aW9uUG9pbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc1JlY3QgPSB0aGlzLnN0YXJ0Tm9kZS5nZXRSZWN0ID8gdGhpcy5zdGFydE5vZGUuZ2V0UmVjdCgpLmJvdW5kaW5nUmVjdCA6IFV0aWwuZ2V0UmVjdCh0aGlzLnN0YXJ0Tm9kZSkuYm91bmRpbmdSZWN0O1xyXG5cclxuICAgICAgICB2YXIgZVJlY3QgPSB0aGlzLmVuZE5vZGUuZ2V0UmVjdCA/IHRoaXMuZW5kTm9kZS5nZXRSZWN0KCkuYm91bmRpbmdSZWN0IDogVXRpbC5nZXRSZWN0KHRoaXMuZW5kTm9kZSkuYm91bmRpbmdSZWN0O1xyXG5cclxuICAgICAgICB2YXIgc0Nvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoc1JlY3QpO1xyXG4gICAgICAgIHZhciBlQ29ubmVjdG9yUG9pbnQgPSBVdGlsLmdldENvbm5lY3RvclBvaW50cyhlUmVjdCk7XHJcblxyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuc3RhcnROb2RlLCBzQ29ubmVjdG9yUG9pbnQubGVmdCwgQ29ubmVjdG9yLlNUQVJUX05PREUgKyBDb25uZWN0b3IuU0VQRVJBVE9SICsgQ29ubmVjdG9yLkxFRlQpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuc3RhcnROb2RlLCBzQ29ubmVjdG9yUG9pbnQucmlnaHQsIENvbm5lY3Rvci5TVEFSVF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5SSUdIVCk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcy5zdGFydE5vZGUsIHNDb25uZWN0b3JQb2ludC50b3AsIENvbm5lY3Rvci5TVEFSVF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5UT1ApO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvaW50Q3JlYXRlKHRoaXMuc3RhcnROb2RlLCBzQ29ubmVjdG9yUG9pbnQuYm90dG9tLCBDb25uZWN0b3IuU1RBUlRfTk9ERSArIENvbm5lY3Rvci5TRVBFUkFUT1IgKyBDb25uZWN0b3IuQk9UVE9NKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcy5lbmROb2RlLCBlQ29ubmVjdG9yUG9pbnQubGVmdCwgQ29ubmVjdG9yLkVORF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5MRUZUKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLmVuZE5vZGUsIGVDb25uZWN0b3JQb2ludC5yaWdodCwgQ29ubmVjdG9yLkVORF9OT0RFICsgQ29ubmVjdG9yLlNFUEVSQVRPUiArIENvbm5lY3Rvci5SSUdIVCk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcy5lbmROb2RlLCBlQ29ubmVjdG9yUG9pbnQudG9wLCBDb25uZWN0b3IuRU5EX05PREUgKyBDb25uZWN0b3IuU0VQRVJBVE9SICsgQ29ubmVjdG9yLlRPUCk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcy5lbmROb2RlLCBlQ29ubmVjdG9yUG9pbnQuYm90dG9tLCBDb25uZWN0b3IuRU5EX05PREUgKyBDb25uZWN0b3IuU0VQRVJBVE9SICsgQ29ubmVjdG9yLkJPVFRPTSk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSh0aGlzLCB0aGlzLnR1cm5pbmdQb2ludHNbMF0uY2xvbmUoKSwgQ29ubmVjdGlvblBvaW50LlRZUEVfQ09OTkVDVE9SKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9pbnRDcmVhdGUodGhpcywgdGhpcy50dXJuaW5nUG9pbnRzW3RoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxXS5jbG9uZSgpLCBDb25uZWN0aW9uUG9pbnQuVFlQRV9DT05ORUNUT1IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uui/nuaOpeeCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc2hhcGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBwb2ludCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHR5cGUgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmNvbm5lY3Rpb25Qb2ludENyZWF0ZSA9IGZ1bmN0aW9uKHNoYXBlLCBwb2ludCwgdHlwZSkge1xyXG4gICAgICAgIHZhciBjb25Qb2ludCA9IG5ldyBDb25uZWN0aW9uUG9pbnQodGhpcywgcG9pbnQsIHR5cGUsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cC5hZGQoY29uUG9pbnQuc2hhcGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOa4heepuuaOp+WItueCuVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY2xlYXJIYW5kbGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhhbmRsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhpcy5oYW5kbGVzW2ldLmhhbmRsZVNoYXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oYW5kbGVzID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuY29uUG9pbnRzR3JvdXApIHtcclxuICAgICAgICAgICAgdGhpcy5jb25Qb2ludHNHcm91cC5yZW1vdmVBbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/mgaLlpI3ljp/mnaXnmoTpopzoibJcclxuICAgICAgICB0aGlzLnNldFN0eWxlKHtjb2xvcjp0aGlzLm9wdGlvbnMuc3R5bGUuc3Ryb2tlfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu65ouG57q/IOe6v+aWreeahOaOp+WItueCuVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuc2hhcGVTZXRIYW5kbGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAyOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGg7XHJcbiAgICAgICAgICAgIHZhciB4LCB5O1xyXG4gICAgICAgICAgICAvL+aYr+WQpuWcqOS4gOadoee6v+S4ilxyXG4gICAgICAgICAgICB2YXIgaXNDb2xsaW5lYWl0eUZpcnN0ID0gVXRpbC5jb2xsaW5lYXJpdHkodGhpcy50dXJuaW5nUG9pbnRzW2kgLSAxXSwgdGhpcy50dXJuaW5nUG9pbnRzW2ldLCB0aGlzLnR1cm5pbmdQb2ludHNbaSArIDFdKTtcclxuICAgICAgICAgICAgdmFyIGlzQ29sbGluZWFpdHlTZWNvbmQgPSBVdGlsLmNvbGxpbmVhcml0eSh0aGlzLnR1cm5pbmdQb2ludHNbaV0sIHRoaXMudHVybmluZ1BvaW50c1tpICsgMV0sIHRoaXMudHVybmluZ1BvaW50c1tpICsgMl0pO1xyXG4gICAgICAgICAgICBpZiAoKCFpc0NvbGxpbmVhaXR5Rmlyc3QgJiYgKCFpc0NvbGxpbmVhaXR5U2Vjb25kIHx8IHRoaXMudHVybmluZ1BvaW50c1tpICsgMV0uZXF1YWxzKHRoaXMudHVybmluZ1BvaW50c1tpICsgMl0pKSkgfHwgKCghaXNDb2xsaW5lYWl0eUZpcnN0IHx8IHRoaXMudHVybmluZ1BvaW50c1tpIC0gMV0uZXF1YWxzKHRoaXMudHVybmluZ1BvaW50c1tpXSkpICYmICFpc0NvbGxpbmVhaXR5U2Vjb25kKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR1cm5pbmdQb2ludHNbaV0ueCA9PT0gdGhpcy50dXJuaW5nUG9pbnRzW2kgKyAxXS54KSB7IC8vc2FtZSB2ZXJ0aWNhbFxyXG4gICAgICAgICAgICAgICAgICAgIHggPSB0aGlzLnR1cm5pbmdQb2ludHNbaV0ueDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gKHRoaXMudHVybmluZ1BvaW50c1tpXS55ICsgdGhpcy50dXJuaW5nUG9pbnRzW2kgKyAxXS55KSAvIDI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGggPSBuZXcgSGFuZGxlKCdoJywgeCwgeSwgdGhpcyk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50dXJuaW5nUG9pbnRzW2ldLnkgPT09IHRoaXMudHVybmluZ1BvaW50c1tpICsgMV0ueSkgeyAvLyBzYW1lIGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgICAgICB4ID0gKHRoaXMudHVybmluZ1BvaW50c1tpXS54ICsgdGhpcy50dXJuaW5nUG9pbnRzW2kgKyAxXS54KSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHRoaXMudHVybmluZ1BvaW50c1tpXS55O1xyXG4gICAgICAgICAgICAgICAgICAgIGggPSBuZXcgSGFuZGxlKCd2JywgeCwgeSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKGguaGFuZGxlU2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcy5wdXNoKGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yib5bu6566t5aS0XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5hbWUgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBvcHRpb25zIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuY3JlYXRlU3ltYm9sID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBzeW1ib2xUeXBlID0gb3B0aW9ucy5zeW1ib2wudHlwZTtcclxuICAgICAgICB2YXIgc3ltYm9sU2l6ZSA9IG9wdGlvbnMuc3ltYm9sLnNpemU7XHJcbiAgICAgICAgaWYgKHN5bWJvbFR5cGUgPT09ICdub25lJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHN5bWJvbFNpemUpKSB7XHJcbiAgICAgICAgICAgIHN5bWJvbFNpemUgPSBbc3ltYm9sU2l6ZSwgc3ltYm9sU2l6ZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc3ltYm9sWkluZGV4ID0gb3B0aW9ucy56O1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zeW1ib2wueikgeyBzeW1ib2xaSW5kZXggPSBvcHRpb25zLnN5bWJvbC56IH1cclxuXHJcbiAgICAgICAgdmFyIHN5bWJvbFBhdGggPSBzeW1ib2xVdGlsLmNyZWF0ZVN5bWJvbChcclxuICAgICAgICAgICAgc3ltYm9sVHlwZSwgLXN5bWJvbFNpemVbMF0gLyAyLCAtc3ltYm9sU2l6ZVsxXSAvIDIsXHJcbiAgICAgICAgICAgIHN5bWJvbFNpemVbMF0sIHN5bWJvbFNpemVbMV0sIHN5bWJvbFpJbmRleCwgb3B0aW9ucy5zeW1ib2wuY29sb3JcclxuICAgICAgICApO1xyXG4gICAgICAgIHN5bWJvbFBhdGgubmFtZSA9IG5hbWU7XHJcblxyXG4gICAgICAgIHJldHVybiBzeW1ib2xQYXRoO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOe7mOWItue6v+auteS4iueahOaWh+acrFxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBjb250ZW50IFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbmFtZSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHggICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSB5ICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gY29sb3IgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLmRyYXdUZXh0ID0gZnVuY3Rpb24obmFtZSwgY29udGVudCwgeCwgeSwgY29sb3IpIHtcclxuICAgICAgICB2YXIgdGV4dFN0eWxlID0genJVdGlsLmRlZmF1bHRzKHRoaXMub3B0aW9ucy50ZXh0LCB7dGV4dDpjb250ZW50LCB4OngsIHk6eSwgZmlsbDpjb2xvcn0sIHRydWUpO1xyXG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgIHN0eWxlOiB0ZXh0U3R5bGUsXHJcbiAgICAgICAgICAgIHpsZXZlbDogMjAsXHJcbiAgICAgICAgICAgIG5hbWUgOiBuYW1lXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgcmVjdDogdGV4dC5nZXRCb3VuZGluZ1JlY3QoKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W57q/5q6155qE5Lit6Ze05YC8XHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19IHRleHRcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdG9yLnByb3RvdHlwZS5taWRkbGUgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9TVFJBSUdIVCkge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gVXRpbC5nZXRNYXhMaW5lTGVuZ3RoKHRoaXMudHVybmluZ1BvaW50cyk7XHJcbiAgICAgICAgICAgIC8v5aaC5p6c5piv5rGC57q/5q615LiK55qE5paH5a2X55qE5Lit6Ze05YC8XHJcbiAgICAgICAgICAgIC8vIGlmKHRleHQpIHtcclxuICAgICAgICAgICAgLy8gICAgIC8v5Y+W5Ye65a2X55qE6ZW/5bqm77yM6K6h566X6KeS5bqm77yMXHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgdGV4dFdpZHRoID0gZ3JhcGhpYy50ZXh0Q29udGFpbi5nZXRXaWR0aCh0ZXh0LnRleHQsIHRleHQudGV4dEZvbnQpO1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIGFuZ2xlID0gVXRpbC5nZXRBbmdsZShwb2ludHNbMF0scG9pbnRzWzFdKTtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBsZW5ndGggPSAgVXRpbC5kaXN0YW5jZShwb2ludHNbMF0scG9pbnRzWzFdKS8yIC0gdGV4dFdpZHRoLzI7XHJcbiAgICAgICAgICAgIC8vICAgICB2YXIgbmV3UG9pbnQgPSBVdGlsLmdldEVuZFBvaW50KHBvaW50c1swXSwgbGVuZ3RoLCBhbmdsZSk7XHJcbiAgICAgICAgICAgIC8vICAgICByZXR1cm4gW25ld1BvaW50LngsIG5ld1BvaW50LnldO1xyXG4gICAgICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyAgICAgdmFyIG1pZGRsZVggPSAocG9pbnRzWzBdLnggKyBwb2ludHNbMV0ueCkvMjtcclxuICAgICAgICAgICAgLy8gICAgIHZhciBtaWRkbGVZID0gKHBvaW50c1swXS55ICsgcG9pbnRzWzFdLnkpIC8yO1xyXG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuIFttaWRkbGVYLCBtaWRkbGVZXTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICB2YXIgbWlkZGxlWCA9IChwb2ludHNbMF0ueCArIHBvaW50c1sxXS54KSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBtaWRkbGVZID0gKHBvaW50c1swXS55ICsgcG9pbnRzWzFdLnkpIC8gMjtcclxuICAgICAgICAgICAgcmV0dXJuIFttaWRkbGVYLCBtaWRkbGVZXTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9PSBDb25uZWN0b3IuVFlQRV9KQUdHRUQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vZmluZCB0b3RhbCBkaXN0YW5jZVxyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLmdldExlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgLy9maW5kIGJldHdlZW4gd2hhdCB0dXJuaW5nIHBvaW50cyB0aGUgaGFsZiBkaXN0YW5jZSBpc1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcclxuICAgICAgICAgICAgdmFyIGVsbGFwc2VkRGlzdGFuY2UgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gVXRpbC5nZXRMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzW2ldLCB0aGlzLnR1cm5pbmdQb2ludHNbaSArIDFdKTtcclxuICAgICAgICAgICAgICAgIGlmIChlbGxhcHNlZERpc3RhbmNlICsgc2VnbWVudCA8IGRpc3RhbmNlIC8gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsbGFwc2VkRGlzdGFuY2UgKz0gc2VnbWVudDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vd2UgaGF2ZSB0aGUgbWlkZGxlIGRpc3RhbmNlIHNvbWV3aGVyZSBiZXR3ZWVuIGkobmRleCkgYW5kIGkobmRleCkrMVxyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtaXNzaW5nRGlzdGFuY2UgPSBkaXN0YW5jZSAvIDIgLSBlbGxhcHNlZERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKFV0aWwucm91bmQodGhpcy50dXJuaW5nUG9pbnRzW2luZGV4XS54LCAzKSA9PSBVdGlsLnJvdW5kKHRoaXMudHVybmluZ1BvaW50c1tpbmRleCArIDFdLngsIDMpKSB7IC8vdmVydGljYWwgc2VnbWVudCAoc2FtZSB4KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4XS54LCBNYXRoLm1pbih0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLnksIHRoaXMudHVybmluZ1BvaW50c1tpbmRleCArIDFdLnkpICsgbWlzc2luZ0Rpc3RhbmNlXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbC5yb3VuZCh0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdLnksIDMpID09IFV0aWwucm91bmQodGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueSwgMykpIHsgLy9ob3Jpem9udGFsIHNlZ21lbnQgKHNhbWUgeSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW01hdGgubWluKHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueCwgdGhpcy50dXJuaW5nUG9pbnRzW2luZGV4ICsgMV0ueCkgKyBtaXNzaW5nRGlzdGFuY2UsIHRoaXMudHVybmluZ1BvaW50c1tpbmRleF0ueV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb25uZWN0b3I6bWlkZGxlKCkgLSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4gXCIgKyB0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXhdICsgXCIgXCIgKyB0aGlzLnR1cm5pbmdQb2ludHNbaW5kZXggKyAxXSArIFwiIG5yIG9mIHBvaW50cyBcIiArIHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID09IENvbm5lY3Rvci5UWVBFX0NVUlZFKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gMC41O1xyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgd2Fsa2VkID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2Fsa2VkICsgVXRpbC5kaXN0YW5jZSh0aGlzLnR1cm5pbmdQb2ludHNbal0sIHRoaXMudHVybmluZ1BvaW50c1tqICsgMV0pID4gbCAqIHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB3YWxrZWQgKz0gVXRpbC5kaXN0YW5jZSh0aGlzLnR1cm5pbmdQb2ludHNbal0sIHRoaXMudHVybmluZ1BvaW50c1tqICsgMV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdCA9IGwgKiB0IC0gd2Fsa2VkO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFNlZ21lbnRMZW5ndGggPSBVdGlsLmRpc3RhbmNlKHRoaXMudHVybmluZ1BvaW50c1tqXSwgdGhpcy50dXJuaW5nUG9pbnRzW2ogKyAxXSk7XHJcblxyXG4gICAgICAgICAgICAvL2ZpbmQgdGhlIHBvc2l0aW9uL3JhdGlvbiBvZiB0aGUgbWlkZGxlIG9mIFBvbHlsaW5lIG9uIGN1cnJlbnQgc2VnbWVudFxyXG4gICAgICAgICAgICB2YXIgc2VnbWVudFBlcmNlbnQgPSByZXN0IC8gY3VycmVudFNlZ21lbnRMZW5ndGg7XHJcblxyXG4gICAgICAgICAgICB2YXIgWHAgPSBzZWdtZW50UGVyY2VudCAqICh0aGlzLnR1cm5pbmdQb2ludHNbaiArIDFdLnggLSB0aGlzLnR1cm5pbmdQb2ludHNbal0ueCkgKyB0aGlzLnR1cm5pbmdQb2ludHNbal0ueDtcclxuICAgICAgICAgICAgdmFyIFlwID0gc2VnbWVudFBlcmNlbnQgKiAodGhpcy50dXJuaW5nUG9pbnRzW2ogKyAxXS55IC0gdGhpcy50dXJuaW5nUG9pbnRzW2pdLnkpICsgdGhpcy50dXJuaW5nUG9pbnRzW2pdLnk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW1hwLCBZcF07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZmluZCB0b3RhbCBkaXN0YW5jZVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy9maW5kIHRvdGFsIGRpc3RhbmNlXHJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHVybmluZ1BvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gVXRpbC5nZXRMZW5ndGgodGhpcy50dXJuaW5nUG9pbnRzW2ldLCB0aGlzLnR1cm5pbmdQb2ludHNbaSArIDFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOi9rEpTT07lr7nosaEgYnBtbuS9v+eUqFxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwicmVzb3VyY2VJZFwiLCB0aGlzLnJlc291cmNlSWQpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwicHJvcGVydGllcy50eXBlXCIsIDE0KTtcclxuXHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnhcIiwgdGhpcy5wb3NpdGlvblswXSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMudXBwZXJMZWZ0LnlcIiwgdGhpcy5wb3NpdGlvblsxXSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC54XCIsIHBhcnNlSW50KHRoaXMucG9zaXRpb25bMF0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoKSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJib3VuZHMubG93ZXJSaWdodC55XCIsIHBhcnNlSW50KHRoaXMucG9zaXRpb25bMV0gKyB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCkpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwic3R5bGUuc1Bvc1wiLCB0aGlzLm9wdGlvbnMucG9zaXRpb24uc3RhcnRQb3MpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KFwic3R5bGUuZVBvc1wiLCB0aGlzLm9wdGlvbnMucG9zaXRpb24uZW5kUG9zKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImRvY2tlcnNcIiwgdGhpcy50dXJuaW5nUG9pbnRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5vcHRpb247XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVmcmVzaE1vZGVsICBmbG935b2T5bqP5YiX5YyW55qE5pe25YCZ6LCD55SoIOabtOaWsOe6v+auteeahOS9jee9riDlj4rnur/kuIrnmoRpY29uc1xyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUucmVmcmVzaE1vZGVsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zZXQoXCJvcHRpb25zXCIsIHpyVXRpbC5jbG9uZSh0aGlzLm9wdGlvbnMpKTtcclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcIm9wdGlvbnMuZG9ja2Vyc1wiLCB0aGlzLnR1cm5pbmdQb2ludHMpO1xyXG4gICAgICAgIHZhciBpY29ucyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pY29ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgaWNvbk5vZGUgPSB0aGlzLmljb25zW2ldO1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gW2ljb25Ob2RlLmtleSwge1xyXG4gICAgICAgICAgICAgICAgaWNvbjogaWNvbk5vZGUuc3R5bGUuaW1hZ2UsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogaWNvbk5vZGUuc3R5bGUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGljb25Ob2RlLnN0eWxlLmhlaWdodFxyXG4gICAgICAgICAgICB9XTtcclxuICAgICAgICAgICAgaWNvbnMucHVzaChvcHRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vZGVsLnNldChcImljb25zXCIsIGljb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDosIPmlbTmm7Lnur/nmoTlvaLnirZcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBwb2ludHMg54K55pWw57uEXHJcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0b3IucHJvdG90eXBlLm1vZGlmeUN1cnZlID0gZnVuY3Rpb24ocG9pbnRzKSB7XHJcbiAgICAgICAgdmFyIHNvbCA9IHRoaXMuZ2V0Q3VydmVQb2ludChwb2ludHMpO1xyXG5cclxuICAgICAgICAvLyAxLiDlpoLmnpzmm7Lnur/nmoTmlbDph48g5q+U5pWw6YeP55qE5Lit5pWw6YeP6KaB5bCRIOWImeWIoOmZpOWkmuS9meeahOe6v+autVxyXG4gICAgICAgIHZhciB3aWxsRGVsQ3VydmVzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IHNvbC5sZW5ndGgsIGNudEN1cnZlID0gdGhpcy5ncm91cEN1cnZlLmNoaWxkQ291bnQoKTsgaiA8IGNudEN1cnZlOyBqKyspIHtcclxuICAgICAgICAgICAgd2lsbERlbEN1cnZlcy5wdXNoKHRoaXMuZ3JvdXBDdXJ2ZS5jaGlsZEF0KGopKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgenJVdGlsLmVhY2god2lsbERlbEN1cnZlcywgZnVuY3Rpb24oY3VydmUpIHtcclxuICAgICAgICAgICAgdGhpcy5ncm91cEN1cnZlLnJlbW92ZShjdXJ2ZSk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgLy8gMi4g6YGN5Y6G5puy57q/ICAg5aaC5p6c5a2Y5Zyo5YiZ55u05o6l6K6+572u5b2i54q277yM5ZCm5YiZ5Yib5bu6XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb2wubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdyb3VwQ3VydmUuY2hpbGRBdChpKTtcclxuICAgICAgICAgICAgaWYgKGxpbmUpIHtcclxuICAgICAgICAgICAgICAgIGxpbmUuYXR0cignc2hhcGUnLCBzb2xbaV0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cmUgPSBuZXcgZ3JhcGhpYy5CZXppZXJDdXJ2ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbjogdGhpcy5vcHRpb25zLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB0aGlzLm9wdGlvbnMuc3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHNvbFtpXSxcclxuICAgICAgICAgICAgICAgICAgICB6OiB0aGlzLm9wdGlvbnMuelxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwQ3VydmUuYWRkKGN1cmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVIb3ZlclN0eWxlKGN1cmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmoLnmja7kvKDlhaXnmoTngrnmlbDnu4TorqHnrpfmm7Lnur/nmoTngrlcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBQIOeCueaVsOe7hFxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAg5puy57q/55qE54K55pWw57uEXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rvci5wcm90b3R5cGUuZ2V0Q3VydmVQb2ludCA9IGZ1bmN0aW9uKFApIHtcclxuICAgICAgICB2YXIgbiA9IFAubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzb2wgPSBbXTtcclxuICAgICAgICBpZiAobiA9PT0gMykge1xyXG4gICAgICAgICAgICBzb2wucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB4MTogUFswXS54LFxyXG4gICAgICAgICAgICAgICAgeTE6IFBbMF0ueSxcclxuICAgICAgICAgICAgICAgIGNweDE6IFBbMV0ueCxcclxuICAgICAgICAgICAgICAgIGNweTE6IFBbMV0ueSxcclxuICAgICAgICAgICAgICAgIHgyOiBQWzJdLngsXHJcbiAgICAgICAgICAgICAgICB5MjogUFsyXS55XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gc29sO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobiA9PT0gNCkge1xyXG4gICAgICAgICAgICBzb2wucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB4MTogUFswXS54LFxyXG4gICAgICAgICAgICAgICAgeTE6IFBbMF0ueSxcclxuICAgICAgICAgICAgICAgIGNweDE6IFBbMV0ueCxcclxuICAgICAgICAgICAgICAgIGNweTE6IFBbMV0ueSxcclxuICAgICAgICAgICAgICAgIGNweDI6IFBbMl0ueCxcclxuICAgICAgICAgICAgICAgIGNweTI6IFBbMl0ueSxcclxuICAgICAgICAgICAgICAgIHgyOiBQWzNdLngsXHJcbiAgICAgICAgICAgICAgICB5MjogUFszXS55XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gc29sO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKkNvbXB1dGVzIHRoZSBzdW0gYmV0d2VlbiB0d28gcG9pbnRcclxuICAgICAgICAgKkBwYXJhbSBwMSAtIHtQb2ludH1cclxuICAgICAgICAgKkBwYXJhbSBwMiAtIHtQb2ludH1cclxuICAgICAgICAgKkByZXR1cm4ge1BvaW50fSB0aGUgc3VtIG9mIGluaXRpYWwgcG9pbnRzXHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHN1bShwMSwgcDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwMS54ICsgcDIueCwgcDEueSArIHAyLnkpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qKkNvbXB1dGVzIHRoZSBkaXZpc2lvbiBvZiBhIHtQb2ludH0gYnkgYSBudW1iZXJcclxuICAgICAgICAgKkBwYXJhbSBwIC0ge1BvaW50fVxyXG4gICAgICAgICAqQHBhcmFtIG5yIC0ge051bWJlcn1cclxuICAgICAgICAgKkByZXR1cm4ge1BvaW50fVxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBmdW5jdGlvbiBkaXZpZGUocCwgbnIpIHtcclxuICAgICAgICAgICAgaWYgKG5yID09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFwiRGl2aXNpb24gYnkgemVybyBub3QgYWxsb3dlZCAoeWV0IDopIFwiICsgdGhpcy5jYWxsZWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwLnggLyBuciwgcC55IC8gbnIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqQ29tcHV0ZXMgdGhlIG11bHRpcGxpY2F0aW9uIG9mIGEge1BvaW50fSBieSBhIG51bWJlclxyXG4gICAgICAgICAqQHBhcmFtIHAgLSB7UG9pbnR9XHJcbiAgICAgICAgICpAcGFyYW0gbnIgLSB7TnVtYmVyfVxyXG4gICAgICAgICAqQHJldHVybiB7UG9pbnR9XHJcbiAgICAgICAgICoqL1xyXG4gICAgICAgIGZ1bmN0aW9uIG11bHRpcGx5KHAsIG5yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocC54ICogbnIsIHAueSAqIG5yKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICpJIGRvIG5vdCBnZXQgd2h5IGZpcnN0IDQgbXVzdCBiZSAwIGFuZCBsYXN0IDMgb2Ygc2FtZSB2YWx1ZS4uLi4uXHJcbiAgICAgICAgICpidXQgb3RoZXJ3aXNlIHdlIHdpbGwgZ2V0IGRpdmlzaW9uIGJ5IHplcm9cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgayA9IFswLCAwLCAwXTtcclxuXHJcbiAgICAgICAgdmFyIGo7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8PSBuIC0gMzsgaisrKSB7XHJcbiAgICAgICAgICAgIGsucHVzaChqKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGsucHVzaChuIC0gMywgbiAtIDMpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG4gLSAzOyBpKyspIHtcclxuICAgICAgICAgICAgLy9xMSAtIGNvbXB1dGUgc3RhcnQgcG9pbnRcclxuICAgICAgICAgICAgdmFyIHExID0gZGl2aWRlKHN1bShtdWx0aXBseShQW2ldLCBrW2kgKyA0XSAtIGtbaSArIDJdKSwgbXVsdGlwbHkoUFtpICsgMV0sIGtbaSArIDJdIC0ga1tpICsgMV0pKSwga1tpICsgNF0gLSBrW2kgKyAxXSk7XHJcblxyXG4gICAgICAgICAgICAvL3EwIC0gY29tcHV0ZSAxc3QgY29udHJvbGwgcG9pbnRcclxuICAgICAgICAgICAgdmFyIHFfMDEgPSAoa1tpICsgM10gLSBrW2kgKyAyXSkgLyAoa1tpICsgM10gLSBrW2kgKyAxXSk7XHJcbiAgICAgICAgICAgIHZhciBxXzAyID0gZGl2aWRlKHN1bShtdWx0aXBseShQW2kgLSAxXSwga1tpICsgM10gLSBrW2kgKyAyXSksIG11bHRpcGx5KFBbaV0sIGtbaSArIDJdIC0ga1tpXSkpLCBrW2kgKyAzXSAtIGtbaV0pO1xyXG4gICAgICAgICAgICB2YXIgcV8wMyA9IG11bHRpcGx5KHExLCAoa1tpICsgMl0gLSBrW2kgKyAxXSkgLyAoa1tpICsgM10gLSBrW2kgKyAxXSkpO1xyXG4gICAgICAgICAgICB2YXIgcTAgPSBzdW0obXVsdGlwbHkocV8wMiwgcV8wMSksIHFfMDMpO1xyXG5cclxuICAgICAgICAgICAgLy9xMiAtIGNvbXB1dGUgMm5kIGNvbnRyb2xsIHBvaW50XHJcbiAgICAgICAgICAgIHZhciBxMiA9IGRpdmlkZShzdW0obXVsdGlwbHkoUFtpXSwga1tpICsgNF0gLSBrW2kgKyAzXSksIG11bHRpcGx5KFBbaSArIDFdLCBrW2kgKyAzXSAtIGtbaSArIDFdKSksIGtbaSArIDRdIC0ga1tpICsgMV0pO1xyXG5cclxuICAgICAgICAgICAgLy9xMyAtIGNvbXB1dGUgZW5kIHBvaW50XHJcbiAgICAgICAgICAgIHZhciBxXzMxID0gKGtbaSArIDNdIC0ga1tpICsgMl0pIC8gKGtbaSArIDRdIC0ga1tpICsgMl0pO1xyXG4gICAgICAgICAgICB2YXIgcV8zMiA9IGRpdmlkZShzdW0obXVsdGlwbHkoUFtpICsgMV0sIGtbaSArIDVdIC0ga1tpICsgM10pLCBtdWx0aXBseShQW2kgKyAyXSwga1tpICsgM10gLSBrW2kgKyAyXSkpLCBrW2kgKyA1XSAtIGtbaSArIDJdKTtcclxuICAgICAgICAgICAgdmFyIHFfMzMgPSBtdWx0aXBseShxMiwgKGtbaSArIDRdIC0ga1tpICsgM10pIC8gKGtbaSArIDRdIC0ga1tpICsgMl0pKTtcclxuICAgICAgICAgICAgdmFyIHEzID0gc3VtKG11bHRpcGx5KHFfMzIsIHFfMzEpLCBxXzMzKTtcclxuXHJcbiAgICAgICAgICAgIC8vc3RvcmUgc29sdXRpb25cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgc29sLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgeDE6IHEwLngsXHJcbiAgICAgICAgICAgICAgICB5MTogcTAueSxcclxuICAgICAgICAgICAgICAgIGNweDE6IHExLngsXHJcbiAgICAgICAgICAgICAgICBjcHkxOiBxMS55LFxyXG4gICAgICAgICAgICAgICAgY3B4MjogcTIueCxcclxuICAgICAgICAgICAgICAgIGNweTI6IHEyLnksXHJcbiAgICAgICAgICAgICAgICB4MjogcTMueCxcclxuICAgICAgICAgICAgICAgIHkyOiBxMy55XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNvbDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFV0aWwuaW5oZXJpdHMoQ29ubmVjdG9yLCBOb2RlKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbm5lY3RvcjtcclxuXHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gU3ltYm9sIGZhY3RvcnlcclxuXHJcblxyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi9ncmFwaGljJyk7XHJcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcclxuICAgIC8qKlxyXG4gICAgICogVHJpYW5nbGUgc2hhcGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVHJpYW5nbGUgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcclxuICAgICAgICB0eXBlOiAndHJpYW5nbGUnLFxyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIGN4ID0gc2hhcGUuY3g7XHJcbiAgICAgICAgICAgIHZhciBjeSA9IHNoYXBlLmN5O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBwYXRoLm1vdmVUbyhjeCwgY3kgLSBoZWlnaHQpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCArIHdpZHRoLCBjeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4IC0gd2lkdGgsIGN5ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogRGlhbW9uZCBzaGFwZVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBEaWFtb25kID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcbiAgICAgICAgdHlwZTogJ2RpYW1vbmQnLFxyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIGN4ID0gc2hhcGUuY3g7XHJcbiAgICAgICAgICAgIHZhciBjeSA9IHNoYXBlLmN5O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBwYXRoLm1vdmVUbyhjeCwgY3kgLSBoZWlnaHQpO1xyXG4gICAgICAgICAgICBwYXRoLmxpbmVUbyhjeCArIHdpZHRoLCBjeSk7XHJcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4LCBjeSArIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHBhdGgubGluZVRvKGN4IC0gd2lkdGgsIGN5KTtcclxuICAgICAgICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBpbiBzaGFwZVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBQaW4gPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcclxuICAgICAgICB0eXBlOiAncGluJyxcclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAvLyB4LCB5IG9uIHRoZSBjdXNwXHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLng7XHJcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcclxuICAgICAgICAgICAgdmFyIHcgPSBzaGFwZS53aWR0aCAvIDUgKiAzO1xyXG4gICAgICAgICAgICAvLyBIZWlnaHQgbXVzdCBiZSBsYXJnZXIgdGhhbiB3aWR0aFxyXG4gICAgICAgICAgICB2YXIgaCA9IE1hdGgubWF4KHcsIHNoYXBlLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHZhciByID0gdyAvIDI7XHJcblxyXG4gICAgICAgICAgICAvLyBEaXN0IG9uIHkgd2l0aCB0YW5nZW50IHBvaW50IGFuZCBjaXJjbGUgY2VudGVyXHJcbiAgICAgICAgICAgIHZhciBkeSA9IHIgKiByIC8gKGggLSByKTtcclxuICAgICAgICAgICAgdmFyIGN5ID0geSAtIGggKyByICsgZHk7XHJcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXNpbihkeSAvIHIpO1xyXG4gICAgICAgICAgICAvLyBEaXN0IG9uIHggd2l0aCB0YW5nZW50IHBvaW50IGFuZCBjaXJjbGUgY2VudGVyXHJcbiAgICAgICAgICAgIHZhciBkeCA9IE1hdGguY29zKGFuZ2xlKSAqIHI7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGFuWCA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICAgICAgdmFyIHRhblkgPSBNYXRoLmNvcyhhbmdsZSk7XHJcblxyXG4gICAgICAgICAgICBwYXRoLmFyYyhcclxuICAgICAgICAgICAgICAgIHgsIGN5LCByLFxyXG4gICAgICAgICAgICAgICAgTWF0aC5QSSAtIGFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgTWF0aC5QSSAqIDIgKyBhbmdsZVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNwTGVuID0gciAqIDAuNjtcclxuICAgICAgICAgICAgdmFyIGNwTGVuMiA9IHIgKiAwLjc7XHJcbiAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgIHggKyBkeCAtIHRhblggKiBjcExlbiwgY3kgKyBkeSArIHRhblkgKiBjcExlbixcclxuICAgICAgICAgICAgICAgIHgsIHkgLSBjcExlbjIsXHJcbiAgICAgICAgICAgICAgICB4LCB5XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHBhdGguYmV6aWVyQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgIHgsIHkgLSBjcExlbjIsXHJcbiAgICAgICAgICAgICAgICB4IC0gZHggKyB0YW5YICogY3BMZW4sIGN5ICsgZHkgKyB0YW5ZICogY3BMZW4sXHJcbiAgICAgICAgICAgICAgICB4IC0gZHgsIGN5ICsgZHlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycm93IHNoYXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIEFycm93ID0gZ3JhcGhpYy5leHRlbmRTaGFwZSh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdhcnJvdycsXHJcblxyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xyXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLng7XHJcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcclxuICAgICAgICAgICAgdmFyIGR4ID0gd2lkdGggLyAzICogMjtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgZHgsIHkgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkgKyBoZWlnaHQgLyA0ICogMyk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCAtIGR4LCB5ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIG9mIHBhdGggY29udHJ1Y3RvcnNcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRoPn1cclxuICAgICAqL1xyXG4gICAgdmFyIHN5bWJvbEN0b3JzID0ge1xyXG4gICAgICAgIGxpbmU6IGdyYXBoaWMuTGluZSxcclxuXHJcbiAgICAgICAgcmVjdDogZ3JhcGhpYy5SZWN0LFxyXG5cclxuICAgICAgICByb3VuZFJlY3Q6IGdyYXBoaWMuUmVjdCxcclxuXHJcbiAgICAgICAgc3F1YXJlOiBncmFwaGljLlJlY3QsXHJcblxyXG4gICAgICAgIGNpcmNsZTogZ3JhcGhpYy5DaXJjbGUsXHJcblxyXG4gICAgICAgIGRpYW1vbmQ6IERpYW1vbmQsXHJcblxyXG4gICAgICAgIHBpbjogUGluLFxyXG5cclxuICAgICAgICBhcnJvdzogQXJyb3csXHJcblxyXG4gICAgICAgIHRyaWFuZ2xlOiBUcmlhbmdsZVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgc3ltYm9sU2hhcGVNYWtlcnMgPSB7XHJcblxyXG4gICAgICAgIGxpbmU6IGZ1bmN0aW9uICh4LCB5LCB3LCBoLCBzaGFwZSkge1xyXG4gICAgICAgICAgICAvLyBGSVhNRVxyXG4gICAgICAgICAgICBzaGFwZS54MSA9IHg7XHJcbiAgICAgICAgICAgIHNoYXBlLnkxID0geSArIGggLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS54MiA9IHggKyB3O1xyXG4gICAgICAgICAgICBzaGFwZS55MiA9IHkgKyBoIC8gMjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgc2hhcGUueCA9IHg7XHJcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5O1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcm91bmRSZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgc2hhcGUueCA9IHg7XHJcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5O1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHc7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IGg7XHJcbiAgICAgICAgICAgIHNoYXBlLnIgPSBNYXRoLm1pbih3LCBoKSAvIDQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3F1YXJlOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbih3LCBoKTtcclxuICAgICAgICAgICAgc2hhcGUueCA9IHg7XHJcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5O1xyXG4gICAgICAgICAgICBzaGFwZS53aWR0aCA9IHNpemU7XHJcbiAgICAgICAgICAgIHNoYXBlLmhlaWdodCA9IHNpemU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2lyY2xlOiBmdW5jdGlvbiAoeCwgeSwgdywgaCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgLy8gUHV0IGNpcmNsZSBpbiB0aGUgY2VudGVyIG9mIHNxdWFyZVxyXG4gICAgICAgICAgICBzaGFwZS5jeCA9IHggKyB3IC8gMjtcclxuICAgICAgICAgICAgc2hhcGUuY3kgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLnIgPSBNYXRoLm1pbih3LCBoKSAvIDI7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGlhbW9uZDogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLmN4ID0geCArIHcgLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS5jeSA9IHkgKyBoIC8gMjtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHBpbjogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4ICsgdyAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhcnJvdzogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLnggPSB4ICsgdyAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLnkgPSB5ICsgaCAvIDI7XHJcbiAgICAgICAgICAgIHNoYXBlLndpZHRoID0gdztcclxuICAgICAgICAgICAgc2hhcGUuaGVpZ2h0ID0gaDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0cmlhbmdsZTogZnVuY3Rpb24gKHgsIHksIHcsIGgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLmN4ID0geCArIHcgLyAyO1xyXG4gICAgICAgICAgICBzaGFwZS5jeSA9IHkgKyBoIC8gMjtcclxuICAgICAgICAgICAgc2hhcGUud2lkdGggPSB3O1xyXG4gICAgICAgICAgICBzaGFwZS5oZWlnaHQgPSBoO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHN5bWJvbEJ1aWxkUHJveGllcyA9IHt9O1xyXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzeW1ib2xDdG9ycykge1xyXG4gICAgICAgIHN5bWJvbEJ1aWxkUHJveGllc1tuYW1lXSA9IG5ldyBzeW1ib2xDdG9yc1tuYW1lXSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBTeW1ib2wgPSBncmFwaGljLmV4dGVuZFNoYXBlKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ3N5bWJvbCcsXHJcblxyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIHN5bWJvbFR5cGU6ICcnLFxyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYmVmb3JlQnJ1c2g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5zaGFwZTtcclxuICAgICAgICAgICAgLy8gRklYTUVcclxuICAgICAgICAgICAgaWYgKHNoYXBlLnN5bWJvbFR5cGUgPT09ICdwaW4nICYmIHN0eWxlLnRleHRQb3NpdGlvbiA9PT0gJ2luc2lkZScpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnRleHRQb3NpdGlvbiA9IFsnNTAlJywgJzQwJSddO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgc3ltYm9sVHlwZSA9IHNoYXBlLnN5bWJvbFR5cGU7XHJcbiAgICAgICAgICAgIHZhciBwcm94eVN5bWJvbCA9IHN5bWJvbEJ1aWxkUHJveGllc1tzeW1ib2xUeXBlXTtcclxuICAgICAgICAgICAgaWYgKHNoYXBlLnN5bWJvbFR5cGUgIT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwcm94eVN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgcmVjdFxyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbFR5cGUgPSAncmVjdCc7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJveHlTeW1ib2wgPSBzeW1ib2xCdWlsZFByb3hpZXNbc3ltYm9sVHlwZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xTaGFwZU1ha2Vyc1tzeW1ib2xUeXBlXShcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZS54LCBzaGFwZS55LCBzaGFwZS53aWR0aCwgc2hhcGUuaGVpZ2h0LCBwcm94eVN5bWJvbC5zaGFwZVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHByb3h5U3ltYm9sLmJ1aWxkUGF0aChjdHgsIHByb3h5U3ltYm9sLnNoYXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFByb3ZpZGUgc2V0Q29sb3IgaGVscGVyIG1ldGhvZCB0byBhdm9pZCBkZXRlcm1pbmUgaWYgc2V0IHRoZSBmaWxsIG9yIHN0cm9rZSBvdXRzaWRlXHJcbiAgICB2YXIgc3ltYm9sUGF0aFNldENvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ2ltYWdlJykge1xyXG4gICAgICAgICAgICB2YXIgc3ltYm9sU3R5bGUgPSB0aGlzLnN0eWxlO1xyXG4gICAgICAgICAgICB2YXIgc3ltYm9sU2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICBpZiAoc3ltYm9sU2hhcGUgJiYgc3ltYm9sU2hhcGUuc3ltYm9sVHlwZSA9PT0gJ2xpbmUnKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5zdHJva2UgPSBjb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9faXNFbXB0eUJydXNoKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5zdHJva2UgPSBjb2xvcjtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFN0eWxlLmZpbGwgPSAnI2ZmZic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSDliKTmlq3lm77lvaLpu5jorqTmmK/loavlhYXov5jmmK/mj4/ovrnvvIzkvb/nlKggb25seVN0cm9rZSA/XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xTdHlsZS5maWxsICYmIChzeW1ib2xTdHlsZS5maWxsID0gY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sU3R5bGUuc3Ryb2tlICYmIChzeW1ib2xTdHlsZS5zdHJva2UgPSBjb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHN5bWJvbFV0aWwgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlIGEgc3ltYm9sIGVsZW1lbnQgd2l0aCBnaXZlbiBzeW1ib2wgY29uZmlndXJhdGlvbjogc2hhcGUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG9yXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbFR5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaFxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6XHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JlYXRlU3ltYm9sOiBmdW5jdGlvbiAoc3ltYm9sVHlwZSwgeCwgeSwgdywgaCwgeiwgY29sb3IpIHtcclxuICAgICAgICAgICAgdmFyIGlzRW1wdHkgPSBzeW1ib2xUeXBlLmluZGV4T2YoJ2VtcHR5JykgPT09IDA7XHJcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2xUeXBlID0gc3ltYm9sVHlwZS5zdWJzdHIoNSwgMSkudG9Mb3dlckNhc2UoKSArIHN5bWJvbFR5cGUuc3Vic3RyKDYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzeW1ib2xQYXRoO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN5bWJvbFR5cGUuaW5kZXhPZignaW1hZ2U6Ly8nKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sUGF0aCA9IG5ldyBncmFwaGljLkltYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogc3ltYm9sVHlwZS5zbGljZSg4KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgejogelxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc3ltYm9sVHlwZS5pbmRleE9mKCdwYXRoOi8vJykgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFBhdGggPSBncmFwaGljLm1ha2VQYXRoKHN5bWJvbFR5cGUuc2xpY2UoNyksIHt6OiB6LCByZWN0SG92ZXI6IHRydWV9LCBuZXcgQm91bmRpbmdSZWN0KHgsIHksIHcsIGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbFBhdGggPSBuZXcgU3ltYm9sKHtcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xUeXBlOiBzeW1ib2xUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB6OiB6XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3ltYm9sUGF0aC5fX2lzRW1wdHlCcnVzaCA9IGlzRW1wdHk7XHJcblxyXG4gICAgICAgICAgICBzeW1ib2xQYXRoLnNldENvbG9yID0gc3ltYm9sUGF0aFNldENvbG9yO1xyXG5cclxuICAgICAgICAgICAgc3ltYm9sUGF0aC5zZXRDb2xvcihjb2xvcik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sUGF0aDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gc3ltYm9sVXRpbDtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvU3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog55S75Y+l5p+EXHJcbiAqIEBhdXRob3Igd2FuZy54aWFvaHVcclxuICovXHJcblxyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBVdGlsID0gcmVxdWlyZShcIi4uL3V0aWwuanNcIik7XHJcbiAgICBmdW5jdGlvbiBIYW5kbGUodHlwZSwgeCwgeSwgY29ubmVjdG9yKXtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG5cclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcclxuXHJcbiAgICAgICAgdGhpcy5oYW5kbGVTaGFwZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogeCxcclxuICAgICAgICAgICAgICAgIGN5OiB5LFxyXG4gICAgICAgICAgICAgICAgcjogSGFuZGxlLlJBRElVU1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IFwicmdiKDAsMjU1LDApXCIsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6XCJyZ2IoMCwwLDApXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgeiA6IGNvbm5lY3Rvci5vcHRpb25zLnogKyAyLCAgLy/oioLngrla5Li6MSDnur/mrrXkuLowO1xyXG4gICAgICAgICAgICBkcmFnZ2FibGU6dHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVTaGFwZS5vbihcImRyYWdcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB0aGF0LmFjdGlvbkNvbm5lY3RvcihlLm9mZnNldFgsZS5vZmZzZXRZKTtcclxuICAgICAgICB9KTtcclxuICAgICAgIC8vIHJldHVybiB0aGlzLmNpcmNsZTtcclxuICAgIH1cclxuXHJcbiAgICBIYW5kbGUuUkFESVVTID0gNDtcclxuXHJcbiAgICBIYW5kbGUucHJvdG90eXBlID0ge1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvciA6IEhhbmRsZSxcclxuXHJcbiAgICAgICAgZXF1YWxzIDogZnVuY3Rpb24oYW5vdGhlckhhbmRsZSl7XHJcbiAgICAgICAgICAgIGlmKCFhbm90aGVySGFuZGxlIGluc3RhbmNlb2YgSGFuZGxlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBhbm90aGVySGFuZGxlLnR5cGVcclxuICAgICAgICAgICAgJiYgdGhpcy54ID09IGFub3RoZXJIYW5kbGUueFxyXG4gICAgICAgICAgICAmJiB0aGlzLnkgPT0gYW5vdGhlckhhbmRsZS55XHJcbiAgICAgICAgICAgICYmIHRoaXMudmlzaWJsZSA9PSBhbm90aGVySGFuZGxlLnZpc2libGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog56e75Yqo5Y+l5p+EXHJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBuZXdYIFtkZXNjcmlwdGlvbl1cclxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5ld1kgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWN0aW9uQ29ubmVjdG9yOiBmdW5jdGlvbihuZXdYLCBuZXdZKXtcclxuICAgICAgICAgICAgc3dpdGNoKHRoaXMudHlwZSl7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd2JzpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5om+5Ye65Lik5Liq6L2s5oqY54K577yI5Y+v56e75Yqo5Y+l5p+E5Zyo6L+Z5Lik5Liq6L2s5oqY54K55Lit6Ze077yJXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHMubGVuZ3RoLTE7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS55ID09IHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS55ID09IHRoaXMueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgTWF0aC5taW4odGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS54LCB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ktMV0ueCkgPD0gdGhpcy54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLm1heCh0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLngsIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS54KSA+PSB0aGlzLngpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFZID0gbmV3WSAtIHRoaXMueTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRpb25NYXRyaXggPSBVdGlsLnRyYW5zbGF0aW9uTWF0cml4KDAsIGRlbHRhWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaW5kZXgtMV0udHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2luZGV4XS50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSBuZXdZOyAgLy/lsIblj6Xmn4TmlrDnmoTkvY3nva7otYvlgLznu5l5XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmib7lh7rkuKTkuKrovazmipjngrnvvIjlj6/np7vliqjlj6Xmn4TlnKjov5nkuKTkuKrovazmipjngrnkuK3pl7TvvIlcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50cy5sZW5ndGgtMTsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLnggPT0gdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpXS54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnggPT0gdGhpcy54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBNYXRoLm1pbih0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2ldLnksIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaS0xXS55KSA8PSB0aGlzLnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGgubWF4KHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaV0ueSwgdGhpcy5jb25uZWN0b3IudHVybmluZ1BvaW50c1tpLTFdLnkpID49IHRoaXMueSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFYID0gbmV3WC10aGlzLng7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uTWF0cml4ID0gVXRpbC50cmFuc2xhdGlvbk1hdHJpeChkZWx0YVgsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnR1cm5pbmdQb2ludHNbaW5kZXgtMV0udHJhbnNmb3JtKHRyYW5zbGF0aW9uTWF0cml4KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci50dXJuaW5nUG9pbnRzW2luZGV4XS50cmFuc2Zvcm0odHJhbnNsYXRpb25NYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSBuZXdYOyAvL+WwhuWPpeafhOaWsOeahOS9jee9rui1i+WAvOe7mXhcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAvLy4gdGhpcy5zaGFwZS51cGRhdGVNaWRkbGVUZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlO1xyXG5cclxuXHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0hhbmRsZS5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOi/nue6v+WKqOaAgeaViOaenFxyXG4gKiBAYXV0aG9yIG1pYW8uY3VuemhpXHJcbiAqL1xyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcclxuICAgIHZhciBjdXJ2ZVV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2N1cnZlJyk7XHJcbiAgICB2YXIgc3ltYm9sVXRpbCA9IHJlcXVpcmUoJy4vU3ltYm9sLmpzJyk7XHJcblxyXG4gICAgZnVuY3Rpb24gRWZmZWN0TGluZShzeW1ib2wsIG9wdGlvbnMsIGdyb3VwQ3VydmUsIHBvbHlMaW5lKSB7XHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gMDtcclxuICAgICAgICB0aGlzLl9sYXN0RnJhbWVQZXJjZW50ID0gMDtcclxuICAgICAgICB0aGlzLnN5bWJvbCA9IHN5bWJvbDtcclxuICAgICAgICB0aGlzLmdyb3VwQ3VydmUgPSBncm91cEN1cnZlO1xyXG4gICAgICAgIHRoaXMuaW5pdFN5bWJvbChvcHRpb25zLCBwb2x5TGluZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgRWZmZWN0TGluZVByb3RvID0gRWZmZWN0TGluZS5wcm90b3R5cGU7XHJcblxyXG4gICAgRWZmZWN0TGluZVByb3RvLmluaXRTeW1ib2wgPSBmdW5jdGlvbihvcHRpb25zLCBwb2x5TGluZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGlzLnN5bWJvbC56MiA9IDEwMDtcclxuICAgICAgICB0aGlzLnN5bWJvbC5jdWxsaW5nID0gdHJ1ZTtcclxuICAgICAgICB2YXIgcGVyaW9kID0gb3B0aW9ucy5lZmZlY3QucGVyaW9kICogMTAwMDtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX3QgPSAwO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLnN0b3BBbmltYXRpb24oKTtcclxuICAgICAgICBpZiAoKG9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gXCJjdXJ2ZVwiKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ncm91cEN1cnZlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBwZXJpb2QgPSBwZXJpb2QgLyB0aGlzLmdyb3VwQ3VydmUuX2NoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBDdXJ2ZUFuaW1hdGUodGhpcy5ncm91cEN1cnZlLl9jaGlsZHJlblswXSwgaSwgcGVyaW9kKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN5bWJvbC5hbmltYXRlKCcnLCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgLndoZW4ocGVyaW9kLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgX190OiAxXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmRlbGF5KDApXHJcbiAgICAgICAgICAgICAgICAuZHVyaW5nKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlU3ltYm9sUG9zaXRpb25Qb2x5bGluZSgpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5zdGFydCgpO1xyXG4gICAgICAgICAgICB0aGlzLnNldEFuaW1hdGlvblBvaW50c1BvbHlsaW5lKHBvbHlMaW5lLnNoYXBlLnBvaW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgRWZmZWN0TGluZVByb3RvLmdyb3VwQ3VydmVBbmltYXRlID0gZnVuY3Rpb24oY3VydmVMaW5lLCBpLCBwZXJpb2QpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGN1cnZlTGluZSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY3VydmVMaW5lID0gdGhpcy5ncm91cEN1cnZlLl9jaGlsZHJlblswXTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwb2ludHM7XHJcbiAgICAgICAgdmFyIHBvcyA9IGN1cnZlTGluZS5zaGFwZTtcclxuICAgICAgICBwb2ludHMgPSBbXHJcbiAgICAgICAgICAgIFtwb3MueDEsIHBvcy55MV0sXHJcbiAgICAgICAgICAgIFtwb3MueDIsIHBvcy55Ml0sXHJcbiAgICAgICAgICAgIFtwb3MuY3B4MSwgcG9zLmNweTFdLFxyXG4gICAgICAgICAgICBbcG9zLmNweDIsIHBvcy5jcHkyXVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5zZXRBbmltYXRpb25Qb2ludHNCZXppZXJDdXJ2ZShwb2ludHMpO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLmFuaW1hdGUoJycpXHJcbiAgICAgICAgICAgIC53aGVuKHBlcmlvZCwge1xyXG4gICAgICAgICAgICAgICAgX190OiAxXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5kZWxheSgwKVxyXG4gICAgICAgICAgICAuZHVyaW5nKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC51cGRhdGVTeW1ib2xQb3NpdGlvbkJlemllckN1cnZlKCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5kb25lKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5zeW1ib2wuX190ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoYXQuZ3JvdXBDdXJ2ZUFuaW1hdGUodGhhdC5ncm91cEN1cnZlLl9jaGlsZHJlbltpICsgMV0sIGkgKyAxLCBwZXJpb2QpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3RhcnQoKTtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBFZmZlY3RMaW5lUHJvdG8uc2V0QW5pbWF0aW9uUG9pbnRzQmV6aWVyQ3VydmUgPSBmdW5jdGlvbihwb2ludHMpIHtcclxuICAgICAgICB0aGlzLnN5bWJvbC5fX3AxID0gcG9pbnRzWzBdO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLl9fcDIgPSBwb2ludHNbMV07XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX19jcDEgPSBwb2ludHNbMl0gfHwgW1xyXG4gICAgICAgICAgICAocG9pbnRzWzBdWzBdICsgcG9pbnRzWzFdWzBdKSAvIDIsXHJcbiAgICAgICAgICAgIChwb2ludHNbMF1bMV0gKyBwb2ludHNbMV1bMV0pIC8gMlxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX19jcDIgPSBwb2ludHNbM107XHJcbiAgICB9O1xyXG5cclxuICAgIEVmZmVjdExpbmVQcm90by51cGRhdGVTeW1ib2xQb3NpdGlvbkJlemllckN1cnZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHAxID0gdGhpcy5zeW1ib2wuX19wMTtcclxuICAgICAgICB2YXIgcDIgPSB0aGlzLnN5bWJvbC5fX3AyO1xyXG4gICAgICAgIHZhciBjcDEgPSB0aGlzLnN5bWJvbC5fX2NwMTtcclxuICAgICAgICB2YXIgY3AyID0gdGhpcy5zeW1ib2wuX19jcDI7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLnN5bWJvbC5fX3Q7XHJcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuc3ltYm9sLnBvc2l0aW9uO1xyXG4gICAgICAgIHZhciB0eCwgdHk7XHJcbiAgICAgICAgaWYgKGNwMlswXSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFyIGN1YmljQXQgPSBjdXJ2ZVV0aWwuY3ViaWNBdDtcclxuICAgICAgICAgICAgdmFyIGN1YmljRGVyaXZhdGl2ZUF0ID0gY3VydmVVdGlsLmN1YmljRGVyaXZhdGl2ZUF0O1xyXG4gICAgICAgICAgICBwb3NbMF0gPSBjdWJpY0F0KHAxWzBdLCBjcDFbMF0sIGNwMlswXSwgcDJbMF0sIHQpO1xyXG4gICAgICAgICAgICBwb3NbMV0gPSBjdWJpY0F0KHAxWzFdLCBjcDFbMV0sIGNwMlsxXSwgcDJbMV0sIHQpO1xyXG4gICAgICAgICAgICAvLyBUYW5nZW50XHJcbiAgICAgICAgICAgIHR4ID0gY3ViaWNEZXJpdmF0aXZlQXQocDFbMF0sIGNwMVswXSwgY3AyWzBdLCBwMlswXSwgdCk7XHJcbiAgICAgICAgICAgIHR5ID0gY3ViaWNEZXJpdmF0aXZlQXQocDFbMV0sIGNwMVsxXSwgY3AyWzFdLCBwMlsxXSwgdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHF1YWRyYXRpY0F0ID0gY3VydmVVdGlsLnF1YWRyYXRpY0F0O1xyXG4gICAgICAgICAgICB2YXIgcXVhZHJhdGljRGVyaXZhdGl2ZUF0ID0gY3VydmVVdGlsLnF1YWRyYXRpY0Rlcml2YXRpdmVBdDtcclxuICAgICAgICAgICAgcG9zWzBdID0gcXVhZHJhdGljQXQocDFbMF0sIGNwMVswXSwgcDJbMF0sIHQpO1xyXG4gICAgICAgICAgICBwb3NbMV0gPSBxdWFkcmF0aWNBdChwMVsxXSwgY3AxWzFdLCBwMlsxXSwgdCk7XHJcbiAgICAgICAgICAgIC8vIFRhbmdlbnRcclxuICAgICAgICAgICAgdHggPSBxdWFkcmF0aWNEZXJpdmF0aXZlQXQocDFbMF0sIGNwMVswXSwgcDJbMF0sIHQpO1xyXG4gICAgICAgICAgICB0eSA9IHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMVsxXSwgY3AxWzFdLCBwMlsxXSwgdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3ltYm9sLnJvdGF0aW9uID0gLU1hdGguYXRhbjIodHksIHR4KSAtIE1hdGguUEkgLyAyO1xyXG5cclxuICAgICAgICB0aGlzLnN5bWJvbC5pZ25vcmUgPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgRWZmZWN0TGluZVByb3RvLnNldEFuaW1hdGlvblBvaW50c1BvbHlsaW5lID0gZnVuY3Rpb24ocG9pbnRzKSB7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xyXG4gICAgICAgIHZhciBhY2NMZW5BcnIgPSBbMF07XHJcbiAgICAgICAgdmFyIGxlbiA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHAxID0gcG9pbnRzW2kgLSAxXTtcclxuICAgICAgICAgICAgdmFyIHAyID0gcG9pbnRzW2ldO1xyXG4gICAgICAgICAgICBsZW4gKz0gdmVjMi5kaXN0KHAxLCBwMik7XHJcbiAgICAgICAgICAgIGFjY0xlbkFyci5wdXNoKGxlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhY2NMZW5BcnIubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgYWNjTGVuQXJyW2pdIC89IGxlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fb2Zmc2V0cyA9IGFjY0xlbkFycjtcclxuICAgICAgICB0aGlzLl9sZW5ndGggPSBsZW47XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX2xhc3RGcmFtZSA9IDA7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wuX19sYXN0RnJhbWVQZXJjZW50ID0gMDtcclxuICAgIH07XHJcblxyXG4gICAgRWZmZWN0TGluZVByb3RvLnVwZGF0ZVN5bWJvbFBvc2l0aW9uUG9seWxpbmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXMuc3ltYm9sLl9fdDtcclxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5fcG9pbnRzO1xyXG4gICAgICAgIHZhciBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcclxuICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKCFvZmZzZXRzKSB7XHJcbiAgICAgICAgICAgIC8vIEhhcyBsZW5ndGggMFxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbGFzdEZyYW1lID0gdGhpcy5fbGFzdEZyYW1lO1xyXG4gICAgICAgIHZhciBmcmFtZTtcclxuXHJcbiAgICAgICAgaWYgKHQgPCB0aGlzLl9sYXN0RnJhbWVQZXJjZW50KSB7XHJcbiAgICAgICAgICAgIC8vIFN0YXJ0IGZyb20gdGhlIG5leHQgZnJhbWVcclxuICAgICAgICAgICAgLy8gUEVORElORyBzdGFydCBmcm9tIGxhc3RGcmFtZSA/XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IE1hdGgubWluKGxhc3RGcmFtZSArIDEsIGxlbiAtIDEpO1xyXG4gICAgICAgICAgICBmb3IgKGZyYW1lID0gc3RhcnQ7IGZyYW1lID49IDA7IGZyYW1lLS0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRzW2ZyYW1lXSA8PSB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUEVORElORyByZWFsbHkgbmVlZCB0byBkbyB0aGlzID9cclxuICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSwgbGVuIC0gMik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZnJhbWUgPSBsYXN0RnJhbWU7IGZyYW1lIDwgbGVuOyBmcmFtZSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0c1tmcmFtZV0gPiB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSAtIDEsIGxlbiAtIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2ZWMyLmxlcnAoXHJcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sLnBvc2l0aW9uLCBwb2ludHNbZnJhbWVdLCBwb2ludHNbZnJhbWUgKyAxXSxcclxuICAgICAgICAgICAgKHQgLSBvZmZzZXRzW2ZyYW1lXSkgLyAob2Zmc2V0c1tmcmFtZSArIDFdIC0gb2Zmc2V0c1tmcmFtZV0pXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gZnJhbWU7XHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lUGVyY2VudCA9IHQ7XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gLU1hdGguYXRhbjIocG9pbnRzW2ZyYW1lICsgMV1bMV0gLSBwb2ludHNbZnJhbWVdWzFdLCBwb2ludHNbZnJhbWUgKyAxXVswXSAtIHBvaW50c1tmcmFtZV1bMF0pO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sLnJvdGF0aW9uID0gYW5nbGUgLSBNYXRoLlBJIC8gMjtcclxuICAgICAgICB0aGlzLnN5bWJvbC5pZ25vcmUgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEVmZmVjdExpbmU7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0VmZmVjdExpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDmjqfliLbngrlcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi9ncmFwaGljLmpzXCIpO1xyXG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvblBvaW50KGNvbm5lY3RvciwgcG9pbnQsIHR5cGUsIG9wdGlvbnMpe1xyXG4gICAgICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yO1xyXG5cclxuICAgICAgICB0aGlzLnBvaW50ID0gcG9pbnQuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IENvbm5lY3Rpb25Qb2ludC5OT1JNQUxfQ09MT1I7XHJcblxyXG4gICAgICAgIHRoaXMub1R5cGUgPSAnQ29ubmVjdGlvblBvaW50JztcclxuXHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBncmFwaGljLkNpcmNsZSh7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICBjeDogdGhpcy5wb2ludC54LFxyXG4gICAgICAgICAgICAgICAgY3k6IHRoaXMucG9pbnQueSxcclxuICAgICAgICAgICAgICAgIHI6IENvbm5lY3Rpb25Qb2ludC5SQURJVVNcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiB0aGlzLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOicjMDAwMDAwJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB6IDogb3B0aW9ucy56ICsgMiAgLy/oioLngrla5Li6MSDnur/mrrXkuLowO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2hhcGUudHlwZSA9ICB0aGlzLnR5cGU7XHJcblxyXG4gICAgICAgIHRoaXMuc2hhcGUuY29ubmVjdG9yID0gY29ubmVjdG9yO1xyXG4gICAgICAgIC8vcmV0dXJuIHRoaXMuY2lyY2xlO1xyXG4gICAgfVxyXG5cclxuICAgIENvbm5lY3Rpb25Qb2ludC5OT1JNQUxfQ09MT1IgPSBcIiNGRkZGMzNcIjsgLy95ZWxsb3cuXHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50Lk9WRVJfQ09MT1IgPSBcIiNGRjk5MDBcIjsgLy9vcmFuZ2VcclxuXHJcbiAgICBDb25uZWN0aW9uUG9pbnQuQ09OTkVDVEVEX0NPTE9SID0gXCIjZmYwMDAwXCI7IC8vcmVkXHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlJBRElVUyA9IDQ7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlRZUEVfRklHVVJFID0gJ2ZpZ3VyZSc7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LlRZUEVfQ09OTkVDVE9SID0gJ2Nvbm5lY3Rvcic7XHJcblxyXG4gICAgQ29ubmVjdGlvblBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3IgOiBDb25uZWN0aW9uUG9pbnQsXHJcblxyXG4gICAgICAgIGVxdWFscyA6IGZ1bmN0aW9uKGFub3RoZXJDb25uZWN0aW9uUG9pbnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb2ludC5lcXVhbHMoYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5wb2ludClcclxuICAgICAgICAgICAgJiYgdGhpcy5jb25uZWN0b3IgPT0gYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5jb25uZWN0b3JcclxuICAgICAgICAgICAgJiYgdGhpcy50eXBlID09IGFub3RoZXJDb25uZWN0aW9uUG9pbnQudHlwZVxyXG4gICAgICAgICAgICAmJiB0aGlzLmNvbG9yID09IGFub3RoZXJDb25uZWN0aW9uUG9pbnQuY29sb3JcclxuICAgICAgICAgICAgJiYgdGhpcy5yYWRpdXMgPT0gYW5vdGhlckNvbm5lY3Rpb25Qb2ludC5yYWRpdXM7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uUG9pbnQ7XHJcblxyXG5cclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdGlvblBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog6IqC54K5562J55qE5qih5Z6LXHJcbiAqIOmHjOmdouWtmOeahOaVsOaNrueUqOadpeWkhOeQhuW6j+WIl+WMluWSjOWPjeW6j+WIl+WMllxyXG4gKiBAY2xhc3MgZmlzaC50b3BvLm1vZGVsXHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi9jbGF6eicpO1xyXG5cclxuICAgIGZ1bmN0aW9uIE1vZGVsKG9wdGlvbiwgcGFyZW50TW9kZWwsICBleHRyYU9wdCkge1xyXG4gICAgICAgIHRoaXMucGFyZW50TW9kZWwgPSBwYXJlbnRNb2RlbDtcclxuICAgICAgICB0aGlzLm9wdGlvbiA9IG9wdGlvbjtcclxuXHJcbiAgICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxyXG4gICAgICAgIGlmICh0aGlzLmluaXQpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KG9wdGlvbiwgcGFyZW50TW9kZWwsICBleHRyYU9wdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBNb2RlbC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBNb2RlbCxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTW9kZWwg55qE5Yid5aeL5YyW5Ye95pWwXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICB6clV0aWwubWVyZ2Uob3B0aW9uLCB0aGlzLmdldERlZmF1bHRPcHRpb24oKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0RGVmYXVsdE9wdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ19fZGVmYXVsdE9wdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0TGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIENsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHQgPSBDbGFzcy5wcm90b3R5cGUuZGVmYXVsdE9wdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBvcHQgJiYgb3B0TGlzdC5wdXNoKG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgQ2xhc3MgPSBDbGFzcy5zdXBlckNsYXNzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0T3B0aW9uID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gb3B0TGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb24gPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbiwgb3B0TGlzdFtpXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGVmYXVsdE9wdGlvbiA9IGRlZmF1bHRPcHRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kZWZhdWx0T3B0aW9uO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICAgICAgenJVdGlsLm1lcmdlKHRoaXMub3B0aW9uLCBvcHRpb24sIHRydWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPlm1vZGVs55qE5p+Q5Liq5bGe5oCn55qE5YC8XHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggbW9kZWzkuK3nmoTlsZ7mgKdcclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAgICAgbm9kZS5tb2RlbC5nZXQoXCJvcHRpb25zLnRleHRcIik7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAocGF0aCwgaWdub3JlUGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghcGF0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5vcHRpb247XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRNb2RlbCA9IHRoaXMucGFyZW50TW9kZWw7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gb2JqIGNvdWxkIGJlIG51bWJlci9zdHJpbmcvLi4uIChsaWtlIDApXHJcbiAgICAgICAgICAgICAgICBvYmogPSAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSA/IG9ialtwYXRoW2ldXSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2JqID09IG51bGwgJiYgcGFyZW50TW9kZWwgJiYgIWlnbm9yZVBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgb2JqID0gcGFyZW50TW9kZWwuZ2V0KHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6K6+572ubW9kZWznmoTmn5DkuKrlsZ7mgKfnmoTlgLxcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBtb2RlbOS4reeahOWxnuaAp1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSDmiYDpnIDopoHorr7nva7nmoTlgLxcclxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAgICAgbm9kZS5tb2RlbC5zZXQoXCJvcHRpb25zLnRleHRcIixcIuS+i+WtkFwiKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXRoLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5vcHRpb247XHJcblxyXG4gICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKFwiLlwiKSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgb2JqW3BhdGhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRBcnJheSAgPSBwYXRoLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGZpZWxkQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRSZWYgPSBvYmo7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGROYW1lO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkQXJyYXlbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudFJlZltmaWVsZE5hbWVdID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlZltmaWVsZE5hbWVdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZWYgPSBjdXJyZW50UmVmW2ZpZWxkTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWUgPSBmaWVsZEFycmF5W24tMV07XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVmW2ZpZWxkTmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0U2hhbGxvdzogZnVuY3Rpb24gKGtleSwgaWdub3JlUGFyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IG9wdGlvbiAmJiBvcHRpb25ba2V5XTtcclxuICAgICAgICAgICAgdmFyIHBhcmVudE1vZGVsID0gdGhpcy5wYXJlbnRNb2RlbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsICYmIHBhcmVudE1vZGVsICYmICFpZ25vcmVQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IHBhcmVudE1vZGVsLmdldFNoYWxsb3coa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0TW9kZWw6IGZ1bmN0aW9uIChwYXRoLCBwYXJlbnRNb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXQocGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciB0aGlzUGFyZW50TW9kZWwgPSB0aGlzLnBhcmVudE1vZGVsO1xyXG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoXHJcbiAgICAgICAgICAgICAgICBvYmosIHBhcmVudE1vZGVsIHx8ICh0aGlzUGFyZW50TW9kZWwgJiYgdGhpc1BhcmVudE1vZGVsLmdldE1vZGVsKHBhdGgpKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kZWw7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICrmuIXnqbptb2RlbOeahG9wdGlvblxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb24gPT0gbnVsbDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKCkge30sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIEN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoenJVdGlsLmNsb25lKHRoaXMub3B0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFbmFibGUgTW9kZWwuZXh0ZW5kLlxyXG4gICAgY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKE1vZGVsKTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1vZGVsO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21vZGVsLmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcblxyXG4gICAgdmFyIGNsYXp6ID0ge307XHJcblxyXG4gICAgdmFyIFRZUEVfREVMSU1JVEVSID0gJy4nO1xyXG4gICAgdmFyIElTX0NPTlRBSU5FUiA9ICdfX19GVF9fQ09NUE9ORU5UX19DT05UQUlORVJfX18nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHZhciBwYXJzZUNsYXNzVHlwZSA9IGNsYXp6LnBhcnNlQ2xhc3NUeXBlID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICB2YXIgcmV0ID0ge21haW46ICcnLCBzdWI6ICcnfTtcclxuICAgICAgICBpZiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZS5zcGxpdChUWVBFX0RFTElNSVRFUik7XHJcbiAgICAgICAgICAgIHJldC5tYWluID0gY29tcG9uZW50VHlwZVswXSB8fCAnJztcclxuICAgICAgICAgICAgcmV0LnN1YiA9IGNvbXBvbmVudFR5cGVbMV0gfHwgJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHVibGljICDnm7jmr5Qg55u05o6l55SoenJVdGlsLmluaGVyaXRzIOWlveWkhOaYryAg5Y+v5Lul55u05o6l6LCD55So54i257G755qE5p6E6YCg5Ye95pWwXHJcbiAgICAgKi9cclxuICAgIGNsYXp6LmVuYWJsZUNsYXNzRXh0ZW5kID0gZnVuY3Rpb24gKFJvb3RDbGFzcywgcHJlQ29uc3RydWN0KSB7XHJcbiAgICAgICAgUm9vdENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xyXG4gICAgICAgICAgICB2YXIgRXh0ZW5kZWRDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHByZUNvbnN0cnVjdCAmJiBwcmVDb25zdHJ1Y3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIFJvb3RDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgenJVdGlsLmV4dGVuZChFeHRlbmRlZENsYXNzLnByb3RvdHlwZSwgcHJvdG8pO1xyXG5cclxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5leHRlbmQgPSB0aGlzLmV4dGVuZDtcclxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckNhbGwgPSBzdXBlckNhbGw7XHJcbiAgICAgICAgICAgIEV4dGVuZGVkQ2xhc3Muc3VwZXJBcHBseSA9IHN1cGVyQXBwbHk7XHJcbiAgICAgICAgICAgIHpyVXRpbC5pbmhlcml0cyhFeHRlbmRlZENsYXNzLCB0aGlzKTtcclxuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckNsYXNzID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBFeHRlbmRlZENsYXNzO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHN1cGVyQ2FsbCBzaG91bGQgaGF2ZSBjbGFzcyBpbmZvLCB3aGljaCBjYW4gbm90IGJlIGZldGNoIGZyb20gJ3RoaXMnLlxyXG4gICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOlxyXG4gICAgLy8gY2xhc3MgQSBoYXMgbWV0aG9kIGYsXHJcbiAgICAvLyBjbGFzcyBCIGluaGVyaXRzIGNsYXNzIEEsIG92ZXJyaWRlcyBtZXRob2QgZiwgZiBjYWxsIHN1cGVyQXBwbHkoJ2YnKSxcclxuICAgIC8vIGNsYXNzIEMgaW5oZXJpdHMgY2xhc3MgQiwgZG8gbm90IG92ZXJyaWRlcyBtZXRob2QgZixcclxuICAgIC8vIHRoZW4gd2hlbiBtZXRob2Qgb2YgY2xhc3MgQyBpcyBjYWxsZWQsIGRlYWQgbG9vcCBvY2N1cmVkLlxyXG4gICAgZnVuY3Rpb24gc3VwZXJDYWxsKGNvbnRleHQsIG1ldGhvZE5hbWUpIHtcclxuICAgICAgICB2YXIgYXJncyA9IHpyVXRpbC5zbGljZShhcmd1bWVudHMsIDIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1cGVyQXBwbHkoY29udGV4dCwgbWV0aG9kTmFtZSwgYXJncykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudGl0eVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVnaXN0ZXJXaGVuRXh0ZW5kXVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjbGF6ei5lbmFibGVDbGFzc01hbmFnZW1lbnQgPSBmdW5jdGlvbiAoZW50aXR5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbXBvbmVudCBtb2RlbCBjbGFzc2VzXHJcbiAgICAgICAgICoga2V5OiBjb21wb25lbnRUeXBlLFxyXG4gICAgICAgICAqIHZhbHVlOlxyXG4gICAgICAgICAqICAgICBjb21wb25lbnRDbGFzcywgd2hlbiBjb21wb25lbnRUeXBlIGlzICd4eHgnXHJcbiAgICAgICAgICogICAgIG9yIE9iamVjdC48c3ViS2V5LCBjb21wb25lbnRDbGFzcz4sIHdoZW4gY29tcG9uZW50VHlwZSBpcyAneHh4Lnl5J1xyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB7fTtcclxuXHJcbiAgICAgICAgZW50aXR5LnJlZ2lzdGVyQ2xhc3MgPSBmdW5jdGlvbiAoQ2xhenosIGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudFR5cGUuc3ViKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+W3sue7j+azqOWGjOi/h+S6hu+8jOebtOaOpei/lOWbnlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXSA9IENsYXp6O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50VHlwZS5zdWIgIT09IElTX0NPTlRBSU5FUikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBtYWtlQ29udGFpbmVyKGNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcltjb21wb25lbnRUeXBlLnN1Yl0gPSBDbGF6ejtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gQ2xheno7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZW50aXR5LmdldENsYXNzID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGVNYWluLCBzdWJUeXBlLCB0aHJvd1doZW5Ob3RGb3VuZCkge1xyXG4gICAgICAgICAgICB2YXIgQ2xhenogPSBzdG9yYWdlW2NvbXBvbmVudFR5cGVNYWluXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChDbGF6eiAmJiBDbGF6eltJU19DT05UQUlORVJdKSB7XHJcbiAgICAgICAgICAgICAgICBDbGF6eiA9IHN1YlR5cGUgPyBDbGF6eltzdWJUeXBlXSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aHJvd1doZW5Ob3RGb3VuZCAmJiAhQ2xhenopIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAnQ29tcG9uZW50ICcgKyBjb21wb25lbnRUeXBlTWFpbiArICcuJyArIChzdWJUeXBlIHx8ICcnKSArICcgbm90IGV4aXN0cy4gTG9hZCBpdCBmaXJzdC4nXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gQ2xheno7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZW50aXR5LmdldENsYXNzZXNCeU1haW5UeXBlID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmpbSVNfQ09OVEFJTkVSXSkge1xyXG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2gob2JqLCBmdW5jdGlvbiAobywgdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgIT09IElTX0NPTlRBSU5FUiAmJiByZXN1bHQucHVzaChvKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBlbnRpdHkuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xyXG4gICAgICAgICAgICAvLyBKdXN0IGNvbnNpZGVyIGNvbXBvbmVudFR5cGUubWFpbi5cclxuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gISFzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IExpa2UgWydhYScsICdiYiddLCBidXQgY2FuIG5vdCBiZSBbJ2FhLnh4J11cclxuICAgICAgICAgKi9cclxuICAgICAgICBlbnRpdHkuZ2V0QWxsQ2xhc3NNYWluVHlwZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0eXBlcyA9IFtdO1xyXG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdG9yYWdlLCBmdW5jdGlvbiAob2JqLCB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKHR5cGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIGEgbWFpbiB0eXBlIGlzIGNvbnRhaW5lciBhbmQgaGFzIHN1YiB0eXBlc1xyXG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gIGNvbXBvbmVudFR5cGVcclxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVudGl0eS5oYXNTdWJUeXBlcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcclxuICAgICAgICAgICAgdmFyIG9iaiA9IHN0b3JhZ2VbY29tcG9uZW50VHlwZS5tYWluXTtcclxuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmpbSVNfQ09OVEFJTkVSXTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBlbnRpdHkucGFyc2VDbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbWFrZUNvbnRhaW5lcihjb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XHJcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyIHx8ICFjb250YWluZXJbSVNfQ09OVEFJTkVSXSkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dID0ge307XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJbSVNfQ09OVEFJTkVSXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnJlZ2lzdGVyV2hlbkV4dGVuZCkge1xyXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxFeHRlbmQgPSBlbnRpdHkuZXh0ZW5kO1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxFeHRlbmQpIHtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5leHRlbmQgPSBmdW5jdGlvbiAocHJvdG8pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgRXh0ZW5kZWRDbGFzcyA9IG9yaWdpbmFsRXh0ZW5kLmNhbGwodGhpcywgcHJvdG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRpdHkucmVnaXN0ZXJDbGFzcyhFeHRlbmRlZENsYXNzLCBwcm90by50eXBlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBlbnRpdHk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gY2xheno7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvY2xhenouanNcbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDmk43kvZzlm77moIfnsbtcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIEljb25PcGVyYXRpb24gPSB7XHJcbiAgICAgICAgU1RSQUlHSFRfU1ZHOiAnTTEzLjk2MSwyLjMwOWMtMC4wNTEtMC4xMjItMC4xNDgtMC4yMi0wLjI3LTAuMjdMMTMuNSwyaC01QzguMjI0LDIsOCwyLjIyNCw4LDIuNVM4LjIyNCwzLDguNSwzaDMuNzkzTDIuMTQ2LDEzLjE0NmMtMC4xOTUsMC4xOTUtMC4xOTUsMC41MTIsMCwwLjcwN3MwLjUxMiwwLjE5NSwwLjcwNywwTDEzLDMuNzA3VjcuNUMxMyw3Ljc3NiwxMy4yMjUsOCwxMy41LDhTMTQsNy43NzYsMTQsNy41di01TDEzLjk2MSwyLjMwOXonLFxyXG4gICAgICAgIEpBR0dFRF9TVkc6ICdNNjUzLjYwNDU3MSA0NDAuOTA1MTQzbDI4OS40OTk0MjkgMzM5LjUyOTE0MyA0MTQuMTM0ODU3LTUzOC40MDQ1NzJ2MTk1LjgwMzQyOWgxMDQuMTU1NDI5VjBsLTM4MS44MDU3MTUgMTQ0Ljk2OTE0MyAzNy4wODM0MjkgOTcuNDI2Mjg2IDE1My41MjY4NTctNTguMjk0ODU4LTMzMS4xOTA4NTcgNDMwLjczODI4Ni0yNzkuNjk4Mjg2LTMyNy43NTMxNDMtNjU3Ljg0Njg1NyA2NjMuNTUyTDc1LjQ4MzQyOSAxMDI0eicsXHJcbiAgICAgICAgQ1VSVkVfU1ZHOiAnTTk1Ni45IDY3LjZoLTI0MHYyNDBoOTIuNWMxLjYgMjIuNiAzLjYgNjguMy0wLjggMTE2LjdDODAzLjMgNDgzIDc4Ny41IDU1OCA3NDIuNCA1ODJjLTQ1LjUgMjQuMi0xMjEuMS02LjYtMjE4LjctODktNTcuNS00OC41LTEwOS41LTgwLjYtMTU0LjMtOTUuMy00My43LTE0LjMtODIuMy0xMy0xMTQuNiA0LTUzLjYgMjguMi04Ni4yIDk2LjgtOTYuNyAyMDQtNC4zIDQzLjUtNCA4NC4yLTIuOSAxMTEuNUg2OC4zdjI0MGgyNDB2LTI0MEgyMDUuMmMtMS4xLTI1LjYtMS41LTY1IDIuNi0xMDYuNiA2LjEtNjEuNSAyMy4xLTE0MCA3MC4yLTE2NC43IDQ1LjMtMjMuOCAxMTkuMSA1LjcgMjEzLjUgODUuMyA1OS40IDUwLjEgMTEyLjcgODMuMyAxNTguNSA5OC41IDQ0LjUgMTQuOSA4My41IDEzLjYgMTE2LTMuNiA1Mi4yLTI3LjcgODMuMy05NC40IDkyLjYtMTk4LjEgNC40LTQ5LjUgMi43LTk1LjIgMS4xLTEyMC40aDk3LjR2LTI0MHpNMjU4LjMgOTA3LjJoLTE0MHYtMTQwaDE0MHYxNDB6IG02NDguNi02NDkuNmgtMTQwdi0xNDBoMTQwdjE0MHonLFxyXG4gICAgICAgIERFTF9TVkc6ICdNNzMuNjQxLDQ1Ljk1N2wtMC4wMjEsMC4yNTJjMCwwLjAzMiwwLjAyMSwwLjA2LDAuMDIxLDAuMDg4YzAsMC4wNjUtMC4wMjIsMC4xMjYtMC4wMjYsMC4xOTFsLTIuNjg1LDU0Ljg3OEg3MC45MWMtMC4yMzEsNC4zMDQtNS4xNjYsMTAuODEtMzEuNzQ4LDEwLjgxYy0yNi41OCwwLTMxLjUwOS02LjUwNi0zMS43NDYtMTAuODFINy40MUw0LjczMSw0Ni40ODhjLTAuMDA5LTAuMDYtMC4wMjgtMC4xMjYtMC4wMjgtMC4xOTFjMC0wLjAzMiwwLjAxLTAuMDYsMC4wMS0wLjA4OGwtMC4wMS0wLjI1MmgwLjAyOGMwLjA5OS0wLjQ2NiwwLjM2NC0wLjkxOSwwLjc4NC0xLjM1M2MzLjQzOSwzLjQ3NywxNy4xOTEsNC4wNTEsMzMuNjQ2LDQuMDUxczMwLjIyMS0wLjU3NCwzMy42NDItNC4wNTFjMC40MjYsMC40MzQsMC43MTEsMC44ODcsMC43ODQsMS4zNTNINzMuNjQxeiBNNzguMzM1LDI1LjEwMnY2LjQwN2MwLDEuMzE2LTEuMzQsMi41NjctMy43MTUsMy42OTZjLTYuMjY2LDIuOTM2LTE5Ljc3Nyw0Ljk3NS0zNS40NTksNC45NzVjLTE1LjY2NiwwLTI5LjE4OS0yLjAzOS0zNS40NDItNC45NzVDMS4zMywzNC4wNzUsMCwzMi44MjUsMCwzMS41MDl2LTYuNDA3YzAtMy4zNzQsOC42ODEtNi4yODYsMjEuMzU5LTcuNzI0VjMuOTI5YzAtMi4xNiwxLjc2OC0zLjkyOSwzLjkzLTMuOTI5aDI2LjMxNGMyLjE2NCwwLDMuOTM4LDEuNzczLDMuOTM4LDMuOTM4djEzLjI5NkM2OC45OCwxOC42MDYsNzguMzMzLDIxLjYxMSw3OC4zMzUsMjUuMTAyeiBNNDguNDE2LDExLjM5NWMwLTIuMzQ4LTAuMzIxLTQuMjctMC43MTUtNC4yN2MtMC4zOTMsMC0yLjY0MSwwLTQuOTc5LDBoLTguNTQ1Yy0yLjM1MiwwLTQuNTkyLDAtNC45ODksMGMtMC4zODgsMC0wLjcxNCwxLjkyMi0wLjcxNCw0LjI3djUuMzY3bDEuMDgzLTAuMDY1YzMuMDY3LTAuMTczLDYuMjg2LTAuMjcsOS41OTUtMC4yNzFjMy4yMDIsMCw2LjI5MiwwLjA5OCw5LjI2NCwwLjI1MlYxMS4zOTV6JyxcclxuICAgICAgICBTVFJBSUdIVF9JTUc6ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUF3QUFBQU1DQVlBQUFCV2RWem5BQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1RXbERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk4zV0pQM0ZqN2Y5MlVQVmtMWThMR1hiSUVBSWlPc0NNZ1FXYUlRa2dCaGhCQVNRTVdGaUFwV0ZCVVJuRWhWeElMVkNraWRpT0tnS0xoblFZcUlXb3RWWERqdUg5eW50WDE2NyszdCs5Zjd2T2VjNS96T2VjOFBnQkVTSnBIbW9tb0FPVktGUERyWUg0OVBTTVRKdllBQ0ZVamdCQ0FRNXN2Q1p3WEZBQUR3QTNsNGZuU3dQL3dCcjI4QUFnQncxUzRrRXNmaC80TzZVQ1pYQUNDUkFPQWlFdWNMQVpCU0FNZ3VWTWdVQU1nWUFMQlRzMlFLQUpRQUFHeDVmRUlpQUtvTkFPejBTVDRGQU5pcGs5d1hBTmlpSEtrSUFJMEJBSmtvUnlRQ1FMc0FZRldCVWl3Q3dNSUFvS3hBSWk0RXdLNEJnRm0yTWtjQ2dMMEZBSGFPV0pBUFFHQUFnSmxDTE13QUlEZ0NBRU1lRTgwRElFd0RvRERTditDcFgzQ0Z1RWdCQU1ETGxjMlhTOUl6RkxpVjBCcDM4dkRnNGlIaXdteXhRbUVYS1JCbUNlUWluSmViSXhOSTV3Tk16Z3dBQUJyNTBjSCtPRCtRNStiazRlWm01Mnp2OU1XaS9tdndieUkrSWZIZi9yeU1BZ1FBRUU3UDc5cGY1ZVhXQTNESEFiQjF2MnVwV3dEYVZnQm8zL2xkTTlzSm9Gb0swSHI1aTNrNC9FQWVucUZReUR3ZEhBb0xDKzBsWXFHOU1PT0xQdjh6NFcvZ2kzNzIvRUFlL3R0NjhBQnhta0NacmNDamcvMXhZVzUycmxLTzU4c0VRakZ1OStjai9zZUZmLzJPS2RIaU5MRmNMQldLOFZpSnVGQWlUY2Q1dVZLUlJDSEpsZUlTNlg4eThSK1cvUW1UZHcwQXJJWlB3RTYyQjdYTGJNQis3Z0VDaXc1WTBuWUFRSDd6TFl3YUM1RUFFR2MwTW5uM0FBQ1R2L21QUUNzQkFNMlhwT01BQUx6b0dGeW9sQmRNeGdnQUFFU2dnU3F3UVFjTXdSU3N3QTZjd1IyOHdCY0NZUVpFUUF3a3dEd1FRZ2JrZ0J3S29SaVdRUmxVd0RyWUJMV3dBeHFnRVpyaEVMVEJNVGdONStBU1hJSHJjQmNHWUJpZXdoaThoZ2tFUWNnSUUyRWhPb2dSWW83WUlzNElGNW1PQkNKaFNEU1NnS1FnNllnVVVTTEZ5SEtrQXFsQ2FwRmRTQ1B5TFhJVU9ZMWNRUHFRMjhnZ01vcjhpcnhITVpTQnNsRUQxQUoxUUxtb0h4cUt4cUJ6MFhRMEQxMkFscUpyMFJxMEhqMkF0cUtuMFV2b2RYUUFmWXFPWTREUk1RNW1qTmxoWEl5SFJXQ0pXQm9teHhaajVWZzFWbzgxWXgxWU4zWVZHOENlWWU4SUpBS0xnQlBzQ0Y2RUVNSnNncENRUjFoTVdFT29KZXdqdEJLNkNGY0pnNFF4d2ljaWs2aFB0Q1Y2RXZuRWVHSTZzWkJZUnF3bTdpRWVJWjRsWGljT0UxK1RTQ1FPeVpMa1Rnb2hKWkF5U1F0SmEwamJTQzJrVTZRKzBoQnBuRXdtNjVCdHlkN2tDTEtBckNDWGtiZVFENUJQa3Z2SncrUzNGRHJGaU9KTUNhSWtVcVNVRWtvMVpUL2xCS1dmTWtLWm9LcFJ6YW1lMUFpcWlEcWZXa2x0b0haUUwxT0hxUk0wZFpvbHpac1dROHVrTGFQVjBKcHBaMm4zYUMvcGRMb0ozWU1lUlpmUWw5SnI2QWZwNSttRDlIY01EWVlOZzhkSVlpZ1pheGw3R2FjWXR4a3ZtVXltQmRPWG1jaFVNTmN5RzVsbm1BK1liMVZZS3ZZcWZCV1J5aEtWT3BWV2xYNlY1NnBVVlhOVlA5VjVxZ3RVcTFVUHExNVdmYVpHVmJOUTQ2a0oxQmFyMWFrZFZidXBOcTdPVW5kU2oxRFBVVitqdmwvOWd2cGpEYktHaFVhZ2hraWpWR08zeGhtTklSYkdNbVh4V0VMV2NsWUQ2eXhybUUxaVc3TDU3RXgyQmZzYmRpOTdURk5EYzZwbXJHYVJacDNtY2MwQkRzYXg0UEE1Mlp4S3ppSE9EYzU3TFFNdFB5MngxbXF0WnExK3JUZmFldHErMm1MdGN1MFc3ZXZhNzNWd25VQ2RMSjMxT20wNjkzVUp1amE2VWJxRnV0dDF6K28rMDJQcmVla0o5Y3IxRHVuZDBVZjFiZlNqOVJmcTc5YnYwUjgzTURRSU5wQVpiREU0WS9ETWtHUG9hNWhwdU5Id2hPR29FY3RvdXBIRWFLUFJTYU1udUNidWgyZmpOWGdYUG1hc2J4eGlyRFRlWmR4clBHRmlhVExicE1Ta3hlUytLYzJVYTVwbXV0RzAwM1RNek1nczNLellyTW5zampuVm5HdWVZYjdadk52OGpZV2xSWnpGU29zMmk4ZVcycFo4eXdXV1RaYjNySmhXUGxaNVZ2VlcxNnhKMWx6ckxPdHQxbGRzVUJ0WG13eWJPcHZMdHFpdG02M0VkcHR0M3hUaUZJOHAwaW4xVTI3YU1lejg3QXJzbXV3RzdUbjJZZllsOW0zMnp4M01IQklkMWp0ME8zeHlkSFhNZG14d3ZPdWs0VFREcWNTcHcrbFhaeHRub1hPZDh6VVhwa3VReXhLWGRwY1hVMjJuaXFkdW4zckxsZVVhN3JyU3RkUDFvNXU3bTl5dDJXM1UzY3c5eFgyciswMHVteHZKWGNNOTcwSDA4UGRZNG5ITTQ1Mm5tNmZDODVEbkwxNTJYbGxlKzcwZVQ3T2NKcDdXTUczSTI4UmI0TDNMZTJBNlBqMWwrczdwQXo3R1BnS2ZlcCtIdnFhK0l0ODl2aU4rMW42WmZnZjhudnM3K3N2OWovaS80WG55RnZGT0JXQUJ3UUhsQWIyQkdvR3pBMnNESHdTWkJLVUhOUVdOQmJzR0x3dytGVUlNQ1ExWkgzS1RiOEFYOGh2NVl6UGNaeXlhMFJYS0NKMFZXaHY2TU13bVRCN1dFWTZHendqZkVINXZwdmxNNmN5MkNJamdSMnlJdUI5cEdaa1grWDBVS1NveXFpN3FVYlJUZEhGMDl5eldyT1JaKzJlOWp2R1BxWXk1Tzl0cXRuSjJaNnhxYkZKc1kreWJ1SUM0cXJpQmVJZjRSZkdYRW5RVEpBbnRpZVRFMk1ROWllTnpBdWRzbWpPYzVKcFVsblJqcnVYY29ya1g1dW5PeTU1M1BGazFXWkI4T0lXWUVwZXlQK1dESUVKUUx4aFA1YWR1VFIwVDhvU2JoVTlGdnFLTm9sR3h0N2hLUEpMbW5WYVY5ampkTzMxRCttaUdUMFoxeGpNSlQxSXJlWkVaa3JrajgwMVdSTmJlck0vWmNka3RPWlNjbEp5alVnMXBsclFyMXpDM0tMZFBaaXNya3cza2VlWnR5aHVUaDhyMzVDUDVjL1BiRld5RlROR2p0Rkt1VUE0V1RDK29LM2hiR0Z0NHVFaTlTRnJVTTk5bS91cjVJd3VDRm55OWtMQlF1TEN6MkxoNFdmSGdJcjlGdXhZamkxTVhkeTR4WFZLNlpIaHA4Tko5eTJqTHNwYjlVT0pZVWxYeWFubmM4bzVTZzlLbHBVTXJnbGMwbGFtVXljdHVydlJhdVdNVllaVmtWZTlxbDlWYlZuOHFGNVZmckhDc3FLNzRzRWE0NXVKWFRsL1ZmUFY1YmRyYTNrcTN5dTNyU091azYyNnM5MW0vcjBxOWFrSFYwSWJ3RGEwYjhZM2xHMTl0U3Q1MG9YcHE5WTdOdE0zS3pRTTFZVFh0Vzh5MnJOdnlvVGFqOW5xZGYxM0xWdjJ0cTdlKzJTYmExci9kZDN2ekRvTWRGVHZlNzVUc3ZMVXJlRmRydlVWOTlXN1M3b0xkanhwaUc3cS81bjdkdUVkM1Q4V2VqM3VsZXdmMlJlL3JhblJ2Yk55dnY3K3lDVzFTTm8wZVNEcHc1WnVBYjlxYjdacDN0WEJhS2c3Q1FlWEJKOSttZkh2alVPaWh6c1BjdzgzZm1YKzM5UWpyU0hrcjBqcS9kYXd0bzIyZ1BhRzk3K2lNbzUwZFhoMUh2cmYvZnU4eDQyTjF4eldQVjU2Z25TZzk4Zm5rZ3BQanAyU25ucDFPUHozVW1keDU5MHo4bVd0ZFVWMjlaMFBQbmo4WGRPNU10MS8zeWZQZTU0OWQ4THh3OUNMM1l0c2x0MHV0UGE0OVIzNXcvZUZJcjF0djYyWDN5KzFYUEs1MDlFM3JPOUh2MDMvNmFzRFZjOWY0MXk1ZG4zbTk3OGJzRzdkdUp0MGN1Q1c2OWZoMjl1MFhkd3J1VE54ZGVvOTRyL3krMnYzcUIvb1A2biswL3JGbHdHM2crR0RBWU0vRFdRL3ZEZ21IbnY2VS85T0g0ZEpIekVmVkkwWWpqWStkSHg4YkRScTk4bVRPaytHbnNxY1R6OHArVnY5NTYzT3I1OS85NHZ0THoxajgyUEFMK1l2UHY2NTVxZk55NzZ1cHJ6ckhJOGNmdk01NVBmR20vSzNPMjMzdnVPKzYzOGU5SDVrby9FRCtVUFBSK21QSHA5QlA5ejduZlA3OEwvZUU4L3NsMHA4ekFBQUFJR05JVWswQUFIb2xBQUNBZ3dBQStmOEFBSURwQUFCMU1BQUE2bUFBQURxWUFBQVhiNUpmeFVZQUFBQlFTVVJCVkhqYWxKRkJEb0F3Q01DcUg1ZWYxd3NoSWVxR1N6Z3N0RUFBbGE4QUFyREZTbmlUVHZiUC9sdFh2MUtJNmpTQjIzaFR1SEovNElld2c1c3dnVXVZd3NuT1laVWo5NHNhZ3lOeUR3RGExaG43WkNPS3d3QUFBQUJKUlU1RXJrSmdnZz09JyxcclxuICAgICAgICBKQUdHRURfSU1HOiAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBd0FBQUFNQ0FZQUFBQldkVnpuQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUV2xEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOM1dKUDNGajdmOTJVUFZrTFk4TEdYYklFQUlpT3NDTWdRV2FJUWtnQmhoQkFTUU1XRmlBcFdGQlVSbkVoVnhJTFZDa2lkaU9LZ0tMaG5RWXFJV290VlhEanVIOXludFgxNjcrM3QrOWY3dk9lYzUvek9lYzhQZ0JFU0pwSG1vbW9BT1ZLRlBEcllINDlQU01USnZZQUNGVWpnQkNBUTVzdkNad1hGQUFEd0EzbDRmblN3UC93QnIyOEFBZ0J3MVM0a0VzZmgvNE82VUNaWEFDQ1JBT0FpRXVjTEFaQlNBTWd1Vk1nVUFNZ1lBTEJUczJRS0FKUUFBR3g1ZkVJaUFLb05BT3owU1Q0RkFOaXBrOXdYQU5paUhLa0lBSTBCQUprb1J5UUNRTHNBWUZXQlVpd0N3TUlBb0t4QUlpNEV3SzRCZ0ZtMk1rY0NnTDBGQUhhT1dKQVBRR0FBZ0psQ0xNd0FJRGdDQUVNZUU4MERJRXdEb0REU3YrQ3BYM0NGdUVnQkFNRExsYzJYUzlJekZMaVYwQnAzOHZEZzRpSGl3bXl4UW1FWEtSQm1DZVFpbkplYkl4Tkk1d05Nemd3QUFCcjUwY0grT0QrUTUrYms0ZVptNTJ6djlNV2kvbXZ3YnlJK0lmSGYvcnlNQWdRQUVFN1A3OXBmNWVYV0EzREhBYkIxdjJ1cFd3RGFWZ0JvMy9sZE05c0pvRm9LMEhyNWkzazQvRUFlbnFGUXlEd2RIQW9MQyswbFlxRzlNT09MUHY4ejRXL2dpMzcyL0VBZS90dDY4QUJ4bWtDWnJjQ2pnLzF4WVc1MnJsS081OHNFUWpGdTkrY2ovc2VGZi8yT0tkSGlOTEZjTEJXSzhWaUp1RkFpVGNkNXVWS1JSQ0hKbGVJUzZYOHk4UitXL1FtVGR3MEFySVpQd0U2MkI3WExiTUIrN2dFQ2l3NVkwbllBUUg3ekxZd2FDNUVBRUdjME1ubjNBQUNUdi9tUFFDc0JBTTJYcE9NQUFMem9HRnlvbEJkTXhnZ0FBRVNnZ1Nxd1FRY013UlNzd0E2Y3dSMjh3QmNDWVFaRVFBd2t3RHdRUWdia2dCd0tvUmlXUVJsVXdEcllCTFd3QXhxZ0VacmhFTFRCTVRnTjUrQVNYSUhyY0JjR1lCaWV3aGk4aGdrRVFjZ0lFMkVoT29nUllvN1lJczRJRjVtT0JDSmhTRFNTZ0tRZzZZZ1VVU0xGeUhLa0FxbENhcEZkU0NQeUxYSVVPWTFjUVBxUTI4Z2dNb3I4aXJ4SE1aU0JzbEVEMUFKMVFMbW9IeHFLeHFCejBYUTBEMTJBbHFKcjBScTBIajJBdHFLbjBVdm9kWFFBZllxT1k0RFJNUTVtak5saFhJeUhSV0NKV0JvbXh4Wmo1VmcxVm84MVl4MVlOM1lWRzhDZVllOElKQUtMZ0JQc0NGNkVFTUpzZ3BDUVIxaE1XRU9vSmV3anRCSzZDRmNKZzRReHdpY2lrNmhQdENWNkV2bkVlR0k2c1pCWVJxd203aUVlSVo0bFhpY09FMStUU0NRT3laTGtUZ29oSlpBeVNRdEphMGpiU0Mya1U2USswaEJwbkV3bTY1QnR5ZDdrQ0xLQXJDQ1hrYmVRRDVCUGt2dkp3K1MzRkRyRmlPSk1DYUlrVXFTVUVrbzFaVC9sQktXZk1rS1pvS3BSemFtZTFBaXFpRHFmV2tsdG9IWlFMMU9IcVJNMGRab2x6WnNXUTh1a0xhUFYwSnBwWjJuM2FDL3BkTG9KM1lNZVJaZlFsOUpyNkFmcDUrbUQ5SGNNRFlZTmc4ZElZaWdaYXhsN0dhY1l0eGt2bVV5bUJkT1htY2hVTU5jeUc1bG5tQStZYjFWWUt2WXFmQldSeWhLVk9wVldsWDZWNTZwVVZYTlZQOVY1cWd0VXExVVBxMTVXZmFaR1ZiTlE0NmtKMUJhcjFha2RWYnVwTnE3T1VuZFNqMURQVVYranZsLzlndnBqRGJLR2hVYWdoa2lqVkdPM3hobU5JUmJHTW1YeFdFTFdjbFlENnl4cm1FMWlXN0w1N0V4MkJmc2JkaTk3VEZORGM2cG1yR2FSWnAzbWNjMEJEc2F4NFBBNTJaeEt6aUhPRGM1N0xRTXRQeTJ4MW1xdFpxMStyVGZhZXRxKzJtTHRjdTBXN2V2YTczVnduVUNkTEozMU9tMDY5M1VKdWphNlVicUZ1dHQxeitvKzAyUHJlZWtKOWNyMUR1bmQwVWYxYmZTajlSZnE3OWJ2MFI4M01EUUlOcEFaYkRFNFkvRE1rR1BvYTVocHVOSHdoT0dvRWN0b3VwSEVhS1BSU2FNbnVDYnVoMmZqTlhnWFBtYXNieHhpckRUZVpkeHJQR0ZpYVRMYnBNU2t4ZVMrS2MyVWE1cG11dEcwMDNUTXpNZ3MzS3pZck1uc2pqblZuR3VlWWI3WnZOdjhqWVdsUlp6RlNvczJpOGVXMnBaOHl3V1dUWmIzckpoV1BsWjVWdlZXMTZ4SjFsenJMT3R0MWxkc1VCdFhtd3liT3B2THRxaXRtNjNFZHB0dDN4VGlGSThwMGluMVUyN2FNZXo4N0Fyc211d0c3VG4yWWZZbDltMzJ6eDNNSEJJZDFqdDBPM3h5ZEhYTWRteHd2T3VrNFRURHFjU3B3K2xYWnh0bm9YT2Q4elVYcGt1UXl4S1hkcGNYVTIybmlxZHVuM3JMbGVVYTdyclN0ZFAxbzV1N205eXQyVzNVM2N3OXhYMnIrMDB1bXh2SlhjTTk3MEgwOFBkWTRuSE00NTJubTZmQzg1RG5MMTUyWGxsZSs3MGVUN09jSnA3V01HM0kyOFJiNEwzTGUyQTZQajFsK3M3cEF6N0dQZ0tmZXArSHZxYStJdDg5dmlOKzFuNlpmZ2Y4bnZzNytzdjlqL2kvNFhueUZ2Rk9CV0FCd1FIbEFiMkJHb0d6QTJzREh3U1pCS1VITlFXTkJic0dMd3crRlVJTUNRMVpIM0tUYjhBWDhodjVZelBjWnl5YTBSWEtDSjBWV2h2Nk1Nd21UQjdXRVk2R3p3amZFSDV2cHZsTTZjeTJDSWpnUjJ5SXVCOXBHWmtYK1gwVUtTb3lxaTdxVWJSVGRIRjA5eXpXck9SWisyZTlqdkdQcVl5NU85dHF0bkoyWjZ4cWJGSnNZK3lidUlDNHFyaUJlSWY0UmZHWEVuUVRKQW50aWVURTJNUTlpZU56QXVkc21qT2M1SnBVbG5SanJ1WGNvcmtYNXVuT3k1NTNQRmsxV1pCOE9JV1lFcGV5UCtXRElFSlFMeGhQNWFkdVRSMFQ4b1NiaFU5RnZxS05vbEd4dDdoS1BKTG1uVmFWOWpqZE8zMUQrbWlHVDBaMXhqTUpUMUlyZVpFWmtya2o4MDFXUk5iZXJNL1pjZGt0T1pTY2xKeWpVZzFwbHJRcjF6QzNLTGRQWmlzcmt3M2tlZVp0eWh1VGg4cjM1Q1A1Yy9QYkZXeUZUTkdqdEZLdVVBNFdUQytvSzNoYkdGdDR1RWk5U0ZyVU05OW0vdXI1SXd1Q0ZueTlrTEJRdUxDejJMaDRXZkhnSXI5RnV4WWppMU1YZHk0eFhWSzZaSGhwOE5KOXkyakxzcGI5VU9KWVVsWHlhbm5jOG81U2c5S2xwVU1yZ2xjMGxhbVV5Y3R1cnZSYXVXTVZZWlZrVmU5cWw5VmJWbjhxRjVWZnJIQ3NxSzc0c0VhNDV1SlhUbC9WZlBWNWJkcmEza3EzeXUzclNPdWs2MjZzOTFtL3IwcTlha0hWMElid0RhMGI4WTNsRzE5dFN0NTBvWHBxOVk3TnRNM0t6UU0xWVRYdFc4eTJyTnZ5b1RhajlucWRmMTNMVnYydHE3ZSsyU2JhMXIvZGQzdnpEb01kRlR2ZTc1VHN2TFVyZUZkcnZVVjk5VzdTN29MZGp4cGlHN3EvNW43ZHVFZDNUOFdlajN1bGV3ZjJSZS9yYW5SdmJOeXZ2Nyt5Q1cxU05vMGVTRHB3NVp1QWI5cWI3WnAzdFhCYUtnN0NRZVhCSjkrbWZIdmpVT2loenNQY3c4M2ZtWCszOVFqclNIa3IwanEvZGF3dG8yMmdQYUc5NytpTW81MGRYaDFIdnJmL2Z1OHg0Mk4xeHpXUFY1NmduU2c5OGZua2dwUGpwMlNubnAxT1B6M1VtZHg1OTB6OG1XdGRVVjI5WjBQUG5qOFhkTzVNdDEvM3lmUGU1NDlkOEx4dzlDTDNZdHNsdDB1dFBhNDlSMzV3L2VGSXIxdHY2MlgzeSsxWFBLNTA5RTNyTzlIdjAzLzZhc0RWYzlmNDF5NWRuM205Nzhic0c3ZHVKdDBjdUNXNjlmaDI5dTBYZHdydVROeGRlbzk0ci95KzJ2M3FCL29QNm4rMC9yRmx3RzNnK0dEQVlNL0RXUS92RGdtSG52NlUvOU9INGRKSHpFZlZJMFlqalkrZEh4OGJEUnE5OG1UT2srR25zcWNUejhwK1Z2OTU2M09yNTkvOTR2dEx6MWo4MlBBTCtZdlB2NjU1cWZOeTc2dXByenJISThjZnZNNTVQZkdtL0szTzIzM3Z1Tys2MzhlOUg1a28vRUQrVVBQUittUEhwOUJQOXo3bmZQNzhML2VFOC9zbDBwOHpBQUFBSUdOSVVrMEFBSG9sQUFDQWd3QUErZjhBQUlEcEFBQjFNQUFBNm1BQUFEcVlBQUFYYjVKZnhVWUFBQUNnU1VSQlZIamFoTkd4RGNKQURJWGhMNkdLUkVkRmlWZ2tJNUE5YUJFRkRRVkRNQVVMVUxBQkV5RFJJN29JMnFPeGtBaVg1Q1EzSjcvbjM4OVNTdm9LZTZTZkdoTGtSS1dCVnhURkJBKzh2NThEempXdTRYekJNWXVFQlU3UmVFZnpnOWRwWHNmNEZqdFVmNFlkd1NxY3Q3Mm9HYVF6bnBqbEJHVW5sVGxlbUdHVGpTNWNxMkJ1WTRjRHBqM3BhWEFMOWhPV0k0ZVVJdTk2N09vcEpaOEJBUGRXL3VET3V3cnpBQUFBQUVsRlRrU3VRbUNDJyxcclxuICAgICAgICBDVVJWRV9JTUc6ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUF3QUFBQU1DQVlBQUFCV2RWem5BQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBS1RXbERRMUJRYUc5MGIzTm9iM0FnU1VORElIQnliMlpwYkdVQUFIamFuVk4zV0pQM0ZqN2Y5MlVQVmtMWThMR1hiSUVBSWlPc0NNZ1FXYUlRa2dCaGhCQVNRTVdGaUFwV0ZCVVJuRWhWeElMVkNraWRpT0tnS0xoblFZcUlXb3RWWERqdUg5eW50WDE2NyszdCs5Zjd2T2VjNS96T2VjOFBnQkVTSnBIbW9tb0FPVktGUERyWUg0OVBTTVRKdllBQ0ZVamdCQ0FRNXN2Q1p3WEZBQUR3QTNsNGZuU3dQL3dCcjI4QUFnQncxUzRrRXNmaC80TzZVQ1pYQUNDUkFPQWlFdWNMQVpCU0FNZ3VWTWdVQU1nWUFMQlRzMlFLQUpRQUFHeDVmRUlpQUtvTkFPejBTVDRGQU5pcGs5d1hBTmlpSEtrSUFJMEJBSmtvUnlRQ1FMc0FZRldCVWl3Q3dNSUFvS3hBSWk0RXdLNEJnRm0yTWtjQ2dMMEZBSGFPV0pBUFFHQUFnSmxDTE13QUlEZ0NBRU1lRTgwRElFd0RvRERTditDcFgzQ0Z1RWdCQU1ETGxjMlhTOUl6RkxpVjBCcDM4dkRnNGlIaXdteXhRbUVYS1JCbUNlUWluSmViSXhOSTV3Tk16Z3dBQUJyNTBjSCtPRCtRNStiazRlWm01Mnp2OU1XaS9tdndieUkrSWZIZi9yeU1BZ1FBRUU3UDc5cGY1ZVhXQTNESEFiQjF2MnVwV3dEYVZnQm8zL2xkTTlzSm9Gb0swSHI1aTNrNC9FQWVucUZReUR3ZEhBb0xDKzBsWXFHOU1PT0xQdjh6NFcvZ2kzNzIvRUFlL3R0NjhBQnhta0NacmNDamcvMXhZVzUycmxLTzU4c0VRakZ1OStjai9zZUZmLzJPS2RIaU5MRmNMQldLOFZpSnVGQWlUY2Q1dVZLUlJDSEpsZUlTNlg4eThSK1cvUW1UZHcwQXJJWlB3RTYyQjdYTGJNQis3Z0VDaXc1WTBuWUFRSDd6TFl3YUM1RUFFR2MwTW5uM0FBQ1R2L21QUUNzQkFNMlhwT01BQUx6b0dGeW9sQmRNeGdnQUFFU2dnU3F3UVFjTXdSU3N3QTZjd1IyOHdCY0NZUVpFUUF3a3dEd1FRZ2JrZ0J3S29SaVdRUmxVd0RyWUJMV3dBeHFnRVpyaEVMVEJNVGdONStBU1hJSHJjQmNHWUJpZXdoaThoZ2tFUWNnSUUyRWhPb2dSWW83WUlzNElGNW1PQkNKaFNEU1NnS1FnNllnVVVTTEZ5SEtrQXFsQ2FwRmRTQ1B5TFhJVU9ZMWNRUHFRMjhnZ01vcjhpcnhITVpTQnNsRUQxQUoxUUxtb0h4cUt4cUJ6MFhRMEQxMkFscUpyMFJxMEhqMkF0cUtuMFV2b2RYUUFmWXFPWTREUk1RNW1qTmxoWEl5SFJXQ0pXQm9teHhaajVWZzFWbzgxWXgxWU4zWVZHOENlWWU4SUpBS0xnQlBzQ0Y2RUVNSnNncENRUjFoTVdFT29KZXdqdEJLNkNGY0pnNFF4d2ljaWs2aFB0Q1Y2RXZuRWVHSTZzWkJZUnF3bTdpRWVJWjRsWGljT0UxK1RTQ1FPeVpMa1Rnb2hKWkF5U1F0SmEwamJTQzJrVTZRKzBoQnBuRXdtNjVCdHlkN2tDTEtBckNDWGtiZVFENUJQa3Z2SncrUzNGRHJGaU9KTUNhSWtVcVNVRWtvMVpUL2xCS1dmTWtLWm9LcFJ6YW1lMUFpcWlEcWZXa2x0b0haUUwxT0hxUk0wZFpvbHpac1dROHVrTGFQVjBKcHBaMm4zYUMvcGRMb0ozWU1lUlpmUWw5SnI2QWZwNSttRDlIY01EWVlOZzhkSVlpZ1pheGw3R2FjWXR4a3ZtVXltQmRPWG1jaFVNTmN5RzVsbm1BK1liMVZZS3ZZcWZCV1J5aEtWT3BWV2xYNlY1NnBVVlhOVlA5VjVxZ3RVcTFVUHExNVdmYVpHVmJOUTQ2a0oxQmFyMWFrZFZidXBOcTdPVW5kU2oxRFBVVitqdmwvOWd2cGpEYktHaFVhZ2hraWpWR08zeGhtTklSYkdNbVh4V0VMV2NsWUQ2eXhybUUxaVc3TDU3RXgyQmZzYmRpOTdURk5EYzZwbXJHYVJacDNtY2MwQkRzYXg0UEE1Mlp4S3ppSE9EYzU3TFFNdFB5MngxbXF0WnExK3JUZmFldHErMm1MdGN1MFc3ZXZhNzNWd25VQ2RMSjMxT20wNjkzVUp1amE2VWJxRnV0dDF6K28rMDJQcmVla0o5Y3IxRHVuZDBVZjFiZlNqOVJmcTc5YnYwUjgzTURRSU5wQVpiREU0WS9ETWtHUG9hNWhwdU5Id2hPR29FY3RvdXBIRWFLUFJTYU1udUNidWgyZmpOWGdYUG1hc2J4eGlyRFRlWmR4clBHRmlhVExicE1Ta3hlUytLYzJVYTVwbXV0RzAwM1RNek1nczNLellyTW5zampuVm5HdWVZYjdadk52OGpZV2xSWnpGU29zMmk4ZVcycFo4eXdXV1RaYjNySmhXUGxaNVZ2VlcxNnhKMWx6ckxPdHQxbGRzVUJ0WG13eWJPcHZMdHFpdG02M0VkcHR0M3hUaUZJOHAwaW4xVTI3YU1lejg3QXJzbXV3RzdUbjJZZllsOW0zMnp4M01IQklkMWp0ME8zeHlkSFhNZG14d3ZPdWs0VFREcWNTcHcrbFhaeHRub1hPZDh6VVhwa3VReXhLWGRwY1hVMjJuaXFkdW4zckxsZVVhN3JyU3RkUDFvNXU3bTl5dDJXM1UzY3c5eFgyciswMHVteHZKWGNNOTcwSDA4UGRZNG5ITTQ1Mm5tNmZDODVEbkwxNTJYbGxlKzcwZVQ3T2NKcDdXTUczSTI4UmI0TDNMZTJBNlBqMWwrczdwQXo3R1BnS2ZlcCtIdnFhK0l0ODl2aU4rMW42WmZnZjhudnM3K3N2OWovaS80WG55RnZGT0JXQUJ3UUhsQWIyQkdvR3pBMnNESHdTWkJLVUhOUVdOQmJzR0x3dytGVUlNQ1ExWkgzS1RiOEFYOGh2NVl6UGNaeXlhMFJYS0NKMFZXaHY2TU13bVRCN1dFWTZHendqZkVINXZwdmxNNmN5MkNJamdSMnlJdUI5cEdaa1grWDBVS1NveXFpN3FVYlJUZEhGMDl5eldyT1JaKzJlOWp2R1BxWXk1Tzl0cXRuSjJaNnhxYkZKc1kreWJ1SUM0cXJpQmVJZjRSZkdYRW5RVEpBbnRpZVRFMk1ROWllTnpBdWRzbWpPYzVKcFVsblJqcnVYY29ya1g1dW5PeTU1M1BGazFXWkI4T0lXWUVwZXlQK1dESUVKUUx4aFA1YWR1VFIwVDhvU2JoVTlGdnFLTm9sR3h0N2hLUEpMbW5WYVY5ampkTzMxRCttaUdUMFoxeGpNSlQxSXJlWkVaa3JrajgwMVdSTmJlck0vWmNka3RPWlNjbEp5alVnMXBsclFyMXpDM0tMZFBaaXNya3cza2VlWnR5aHVUaDhyMzVDUDVjL1BiRld5RlROR2p0Rkt1VUE0V1RDK29LM2hiR0Z0NHVFaTlTRnJVTTk5bS91cjVJd3VDRm55OWtMQlF1TEN6MkxoNFdmSGdJcjlGdXhZamkxTVhkeTR4WFZLNlpIaHA4Tko5eTJqTHNwYjlVT0pZVWxYeWFubmM4bzVTZzlLbHBVTXJnbGMwbGFtVXljdHVydlJhdVdNVllaVmtWZTlxbDlWYlZuOHFGNVZmckhDc3FLNzRzRWE0NXVKWFRsL1ZmUFY1YmRyYTNrcTN5dTNyU091azYyNnM5MW0vcjBxOWFrSFYwSWJ3RGEwYjhZM2xHMTl0U3Q1MG9YcHE5WTdOdE0zS3pRTTFZVFh0Vzh5MnJOdnlvVGFqOW5xZGYxM0xWdjJ0cTdlKzJTYmExci9kZDN2ekRvTWRGVHZlNzVUc3ZMVXJlRmRydlVWOTlXN1M3b0xkanhwaUc3cS81bjdkdUVkM1Q4V2VqM3VsZXdmMlJlL3JhblJ2Yk55dnY3K3lDVzFTTm8wZVNEcHc1WnVBYjlxYjdacDN0WEJhS2c3Q1FlWEJKOSttZkh2alVPaWh6c1BjdzgzZm1YKzM5UWpyU0hrcjBqcS9kYXd0bzIyZ1BhRzk3K2lNbzUwZFhoMUh2cmYvZnU4eDQyTjF4eldQVjU2Z25TZzk4Zm5rZ3BQanAyU25ucDFPUHozVW1keDU5MHo4bVd0ZFVWMjlaMFBQbmo4WGRPNU10MS8zeWZQZTU0OWQ4THh3OUNMM1l0c2x0MHV0UGE0OVIzNXcvZUZJcjF0djYyWDN5KzFYUEs1MDlFM3JPOUh2MDMvNmFzRFZjOWY0MXk1ZG4zbTk3OGJzRzdkdUp0MGN1Q1c2OWZoMjl1MFhkd3J1VE54ZGVvOTRyL3krMnYzcUIvb1A2biswL3JGbHdHM2crR0RBWU0vRFdRL3ZEZ21IbnY2VS85T0g0ZEpIekVmVkkwWWpqWStkSHg4YkRScTk4bVRPaytHbnNxY1R6OHArVnY5NTYzT3I1OS85NHZ0THoxajgyUEFMK1l2UHY2NTVxZk55NzZ1cHJ6ckhJOGNmdk01NVBmR20vSzNPMjMzdnVPKzYzOGU5SDVrby9FRCtVUFBSK21QSHA5QlA5ejduZlA3OEwvZUU4L3NsMHA4ekFBQUFJR05JVWswQUFIb2xBQUNBZ3dBQStmOEFBSURwQUFCMU1BQUE2bUFBQURxWUFBQVhiNUpmeFVZQUFBQ2FTVVJCVkhqYWpOQTlEZ0VCRUliaFowVVVvaGVSS0YxQnEzVWVGMWlWUXFWUWFTUU80Z0NpNUFJU2pVWXBoTkVzeVNhN2RpZVpZcjdNKzgyUGlGQ1dTQkc1L0FjVVFRM1YwY2I3VzlRQnVyaGdCczBhd0FpbmlFaVRKRkcxL3pEYmZmclRLb0FON3VoVkFwaGt4eTV5ZWtuekdEY2MwQ29GTU1BU1R4elJMekF6eHhwN3ZQREFDcDJpNlVubWRzMGNkOWhHeExuc3g1OEJBRzhjM3BacGJNOC9BQUFBQUVsRlRrU3VRbUNDJyxcclxuICAgICAgICBERUxfSU1HOiAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBd0FBQUFPQkFNQUFBRHBrK0RmQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFGelVrZENBSzdPSE9rQUFBQXRVRXhVUlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1HZ0tENEFBQUFQZEZKT1V3REgvZythZ0VTajRZNnpVaVJuaDdsbndia0FBQUJMU1VSQlZBalhZMkJnWURaZ0FJRW5ua0NhN2E1Y1lHd0N3d2tsSU9oaE1CRUVnbUlHbmxBZ09NREFwcmhRVUdnREE1dldkSmNpWEpSR1IwZFRBZ1B6UTBGQlNhQnB6TWJHQmd3QUlvVVczc1EyRWRrQUFBQUFTVVZPUks1Q1lJST0nLFxyXG4gICAgICAgIENIQU5HRV9MSU5FX1RZUEVfSU1HOiAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCY0FBQUFQQkFNQUFBRDlnVWxsQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFGelVrZENBSzdPSE9rQUFBQXFVRXhVUlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQW9Uem9nQUFBQU9kRkpPVXdEK0NDM3V1UjdnVlhlZUZFbk1SSUVESndBQUFHUkpSRUZVQ05kallPQ1p3SUFBN1l1VVFBRE0xblFzRFFXQkJCQm5vU0FZaUJpQU9HZVJPV3dMSXpwQVlBTkVFN0pwREJ0UUtBaVlxUUNtbEkxQllPRnFNTWZjQlFRRVJjRUdta0JNRnd3QWNXekxRY0JSQ3V3SXRUUVFXRDRKeWJRNURBd0FPNzRiMFM4M095TUFBQUFBU1VWT1JLNUNZSUk9J1xyXG4gICAgfVxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBJY29uT3BlcmF0aW9uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9JY29uT3BlcmF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogZmxvd+i/nue6v+euoeeQhuexu1xyXG4gKiBAYXV0aG9yIG1pYW8uY3VuemhpXHJcbiAqL1xyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9Db25uZWN0aW9uTWFuYWdlci5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi91dGlsJyk7XHJcbiAgICB2YXIgUG9pbnQgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL1BvaW50LmpzXCIpO1xyXG4gICAgdmFyIENvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi91dGlsL0Zsb3dDb25zdGFudHMuanNcIik7XHJcblxyXG4gICAgZnVuY3Rpb24gRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyKGFwaSkge1xyXG4gICAgICAgIENvbm5lY3Rpb25NYW5hZ2VyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5idW5kbGVPZmZzZXQgPSAzMDsgLy/lpJrnur/mrrXnmoTlgY/np7tcclxuICAgICAgICB0aGlzLmJ1bmRsZUdhcCA9IDIwOyAvLyDlpJrnur/mrrXnmoTpl7TpmpRcclxuICAgICAgICB0aGlzLmNvbm5lY3Rvck1hcCA9IFV0aWwuU3RhY2tlZE1hcC5jcmVhdGVOZXcoKTsgLy/lrZjmlL7lpJrnur/mrrVcclxuICAgICAgICB0aGlzLl9hcGkgPSBhcGk7XHJcbiAgICB9XHJcblxyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihjb25uZWN0b3IpIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3RvcnMucHVzaChjb25uZWN0b3IpO1xyXG4gICAgICAgIC8vMS7lpITnkIbkuovku7ZcclxuICAgICAgICB0aGlzLmhhbmRsZUNvbm5lY3RvckV2ZW50KGNvbm5lY3Rvcik7XHJcbiAgICAgICAgLy8yLuWIpOaWreaYr+WQpuS4pOiKgueCueebuOiBlFxyXG4gICAgICAgIGlmKGNvbm5lY3Rvci5zdGFydE5vZGUgJiYgY29ubmVjdG9yLmVuZE5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0VHdvTm9kZUlkKGNvbm5lY3Rvci5zdGFydE5vZGUsIGNvbm5lY3Rvci5lbmROb2RlKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JNYXAuYWRkKGtleSwgY29ubmVjdG9yKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ29ubmVjdG9yU2hyaW5rKGNvbm5lY3Rvcik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJ1bmRsZU9mZnNldCA9IGNvbm5lY3Rvci5vcHRpb25zLmJ1bmRsZU9mZnNldCB8fCB0aGlzLmJ1bmRsZU9mZnNldDtcclxuICAgICAgICAgICAgdGhpcy5idW5kbGVHYXAgPSBjb25uZWN0b3Iub3B0aW9ucy5idW5kbGVHYXAgfHwgdGhpcy5idW5kbGVHYXA7XHJcbiAgICAgICAgICAgIC8vMi4g6I635Y+W6L+Z5Liqa2V55a+55bqU55qE57q/5q615pWw57uEXHJcbiAgICAgICAgICAgIHZhciBhcnJDb25zID0gdGhpcy5jb25uZWN0b3JNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGlmIChhcnJDb25zLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAvL+S4pOS4quiKgueCueWPquacieS4gOS4qui/nue6v+eahOaDheWGtVxyXG4gICAgICAgICAgICAgICAgLy/liKTmlq3kuIDkuIsgbW9kZWzph4zmnInmsqHmnIlkb2NrZXJz77yM5aaC5p6c5pyJ5YiZ6LCD55So5p6E6YCgcG9pbnTmlbDnu4QgIOaIluiAheiwg+eUqHJlZnJlc2hDb25uZWN0b3LorqHnrpflpoLkvZXnlLvnur9cclxuICAgICAgICAgICAgICAgIHZhciBkb2NrZXJzID0gY29ubmVjdG9yLm9wdGlvbnMuZG9ja2VycztcclxuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGlmIChkb2NrZXJzICYmIGRvY2tlcnMubGVuZ3RoID49IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBQb2ludC5sb2FkQXJyYXkoZG9ja2Vycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yLnJlZnJlc2gocG9pbnRzKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uLnBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyU3RhcnRFbmRQb2ludCA9IHRoaXMuZ2V0U3RhcnRFbmRQb2ludChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbi5wb2ludHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy51bnNoaWZ0KGFyclN0YXJ0RW5kUG9pbnRbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChhcnJTdGFydEVuZFBvaW50WzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yLnJlZnJlc2gocG9pbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25uZWN0b3IoYXJyQ29uc1swXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyckNvbnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgLy/kuKTkuKroioLngrnmnInlpJrkuKrov57nur/nmoTmg4XlhrVcclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbnMoYXJyQ29ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL+WkhOeQhuayoeaciSDotbflp4voioLngrnkuI7nu4jmraLoioLngrnml7bnmoTov57nur9cclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVDb25uZWN0b3JQb2ludHMoY29ubmVjdG9yKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8zLuiuvue9ruaooeWei1xyXG4gICAgICAgIHRoaXMuaGFuZGxlQ29ubmVjdG9yTW9kZWwoY29ubmVjdG9yKTtcclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuaGFuZGxlQ29ubmVjdG9yRXZlbnQgPSBmdW5jdGlvbihjb25uZWN0b3IpIHtcclxuICAgICAgICBpZiAoY29ubmVjdG9yLmNvblBvaW50c0dyb3VwKSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rvci5jb25Qb2ludHNHcm91cC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcnJTcGxpdCA9IGUudGFyZ2V0LnR5cGUuc3BsaXQoQ29ubmVjdG9yLlNFUEVSQVRPUik7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdG9yID0gZS50YXJnZXQuY29ubmVjdG9yO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyclNwbGl0WzBdID09PSBDb25uZWN0b3IuU1RBUlRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5vcHRpb25zLnBvc2l0aW9uLnN0YXJ0UG9zID0gYXJyU3BsaXRbMV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyclNwbGl0WzBdID09PSBDb25uZWN0b3IuRU5EX05PREUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbi5lbmRQb3MgPSBhcnJTcGxpdFsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbm5lY3Rvcihjb25uZWN0b3IsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gXCJjb25Qb2ludHNHcm91cDpjbGlja1wiO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmxpbmVOb2RlID0gdGhpcy5zZWxDb25uZWN0b3I7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcGkudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB2YXIgTU9VU0VfRVZFTlRfTkFNRVMgPSBbJ2NsaWNrJywgJ2RibGNsaWNrJ107XHJcbiAgICAgICAgenJVdGlsLmVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uKGV2ZU5hbWUpIHtcclxuICAgICAgICAgICAgY29ubmVjdG9yLm9uKFwiQ29ubmVjdG9yOlwiICsgZXZlTmFtZSwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gZS50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxDb25uZWN0b3IgIT09IHNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxDb25uZWN0b3IgJiYgdGhpcy5yZWZyZXNoQ29ubmVjdG9yKHRoaXMuc2VsQ29ubmVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbENvbm5lY3RvciA9IHNlbGVjdGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmV2ZW50ID0gZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gZXZlTmFtZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50YXJnZXQgPSB0aGlzLnNlbENvbm5lY3RvcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwaS50cmlnZ2VyKHBhcmFtcy50eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5oYW5kbGVDb25uZWN0b3JNb2RlbCA9IGZ1bmN0aW9uKGNvbm5lY3Rvcikge1xyXG4gICAgICAgIGNvbm5lY3Rvci5tb2RlbC5zZXQoQ29uc3RhbnRzLkVMRU1FTlRfVFlQRSwgQ29uc3RhbnRzLkNPTk5FQ1RJT04pO1xyXG4gICAgICAgIGlmKGNvbm5lY3Rvci5zdGFydE5vZGUgJiYgY29ubmVjdG9yLmVuZE5vZGUpIHtcclxuICAgICAgICAgICAgY29ubmVjdG9yLm1vZGVsLnNldChDb25zdGFudHMuU1RBUlRfSUQsIGNvbm5lY3Rvci5zdGFydE5vZGUuaWQpO1xyXG4gICAgICAgICAgICBjb25uZWN0b3IubW9kZWwuc2V0KENvbnN0YW50cy5FTkRfSUQsIGNvbm5lY3Rvci5lbmROb2RlLmlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29ubmVjdG9yLm1vZGVsLnNldChDb25zdGFudHMuT1BUSU9OUywgenJVdGlsLmNsb25lKGNvbm5lY3Rvci5vcHRpb25zKSk7XHJcbiAgICB9XHJcblxyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5oYW5kbGVDb25uZWN0b3JTaHJpbmsgPSBmdW5jdGlvbihjb25uZWN0b3IpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgLy/lj4zlh7vmlLbntKfkuLrkuIDmnaHnur9cclxuICAgICAgICBjb25uZWN0b3IubGluZS5vbihcImRibGNsaWNrXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoY29ubmVjdG9yLm9wdGlvbnMuaXNTaHJpbmsgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29uID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgIHZhciBzdGFydE5vZGUgPSBjb24uc3RhcnROb2RlO1xyXG4gICAgICAgICAgICB2YXIgZW5kTm9kZSA9IGNvbi5lbmROb2RlO1xyXG4gICAgICAgICAgICAvLzEu6I635Y+W5omA5pyJ55qE57q/5q61XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGF0LmdldFR3b05vZGVJZChzdGFydE5vZGUsIGVuZE5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgY29ucyA9IHRoYXQuY29ubmVjdG9yTWFwLmdldChrZXkpO1xyXG4gICAgICAgICAgICBpZiAoY29ucy5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8yLuWIpOaWree6v+aYr+WQpuWkhOS6jumakOiXj+eKtuaAgVxyXG4gICAgICAgICAgICAvLzIu5bCG6Zmk5Lit6Ze055qE5LiA5p2h57q/6L+b6KGM6ZqQ6JePXHJcbiAgICAgICAgICAgIHZhciBoYWxmID0gcGFyc2VJbnQoY29ucy5sZW5ndGggLyAyKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSAhPSAoaGFsZikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc1tpXS5pZ25vcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc1tpXS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc1tpXS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvL+WkhOeQhuayoeaciSDotbflp4voioLngrnkuI7nu4jmraLoioLngrnml7bnmoTov57nur9cclxuICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuaGFuZGxlQ29ubmVjdG9yUG9pbnRzID0gZnVuY3Rpb24oY29ubmVjdG9yKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb25uZWN0b3Iub3B0aW9ucztcclxuICAgICAgICB2YXIgZG9ja2VycyA9IGNvbm5lY3Rvci5vcHRpb25zLmRvY2tlcnM7XHJcbiAgICAgICAgaWYgKGRvY2tlcnMgJiYgZG9ja2Vycy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gUG9pbnQubG9hZEFycmF5KGRvY2tlcnMpO1xyXG4gICAgICAgICAgICBjb25uZWN0b3IucmVmcmVzaChwb2ludHMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uICYmIG9wdGlvbnMucG9zaXRpb24ucG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb1BvaW50cyA9IG9wdGlvbnMucG9zaXRpb24ucG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLnJlZnJlc2gob1BvaW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRUd29Ob2RlSWQgPSBmdW5jdGlvbihzdGFydE5vZGUsIGVuZE5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0Tm9kZS5pZCArIFwiLFwiICsgZW5kTm9kZS5pZDtcclxuICAgIH1cclxuICAgICAgICAvL+WkhOeQhuWkmuadoee6v+autVxyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZWZyZXNoQ29ucyA9IGZ1bmN0aW9uKGFyckNvbnMpIHtcclxuICAgICAgICAvL+WmguaenOaYr+aKmOe6v+eahOivnVxyXG4gICAgICAgIGlmIChhcnJDb25zWzBdLm9wdGlvbnMuc3R5bGUubGluZVR5cGUgPT0gQ29ubmVjdG9yLlRZUEVfSkFHR0VEKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyQ29ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29ubmVjdG9yKGFyckNvbnNbaV0sIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29uc1N0cmFpZ2h0KGFyckNvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL+WkhOeQhuWkmuadoee6v+autSjnm7Tnur8pXHJcbiAgICBGbG93Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlZnJlc2hDb25zU3RyYWlnaHQgPSBmdW5jdGlvbihhcnJDb25zKSB7XHJcbiAgICAgICAgdmFyIGhhbGYgPSBwYXJzZUludChhcnJDb25zLmxlbmd0aCAvIDIpO1xyXG4gICAgICAgIHZhciBhcnJDb25uZWN0UmVzdWx0ID0gW11cclxuXHJcbiAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IGFyckNvbnNbMF0uc3RhcnROb2RlO1xyXG4gICAgICAgIHZhciBlbmROb2RlID0gYXJyQ29uc1swXS5lbmROb2RlO1xyXG4gICAgICAgIHZhciBzUmVjdCA9IFV0aWwuZ2V0UmVjdChzdGFydE5vZGUpLmJvdW5kaW5nUmVjdDtcclxuICAgICAgICB2YXIgZVJlY3QgPSBVdGlsLmdldFJlY3QoZW5kTm9kZSkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgIHZhciBzQ29ubmVjdG9yUG9pbnQgPSBVdGlsLmdldENvbm5lY3RvclBvaW50cyhzUmVjdCk7XHJcbiAgICAgICAgdmFyIGVDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKGVSZWN0KTtcclxuICAgICAgICAvL+WIpOaWreWmguaenOayoeacieaMh+WumuS9jee9rueahOivnSwg5Yik5pat5byA5aeL6IqC54K55Zyo57uT5p2f57uT5p6c5bem6L655YiZ6YeH55SoIHJpZ2h0LWxlZnQg5ZCm5YiZ6YeH55SobGVmdC1yaWdodFxyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGFyckNvbnNbMF0ub3B0aW9ucy5wb3NpdGlvbjtcclxuICAgICAgICBpZiAoIXBvc2l0aW9uLnN0YXJ0UG9zIHx8ICFwb3NpdGlvbi5lbmRQb3MpIHtcclxuICAgICAgICAgICAgaWYgKHNSZWN0LnggPCBlUmVjdC54KSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5zdGFydFBvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLmVuZFBvcyA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24uc3RhcnRQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLmVuZFBvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBzQ29ubmVjdG9yUG9pbnRbcG9zaXRpb24uc3RhcnRQb3NdO1xyXG4gICAgICAgIHZhciBlbmRQb2ludCA9IGVDb25uZWN0b3JQb2ludFtwb3NpdGlvbi5lbmRQb3NdO1xyXG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZW5kUG9pbnQueSAtIHN0YXJ0UG9pbnQueSwgZW5kUG9pbnQueCAtIHN0YXJ0UG9pbnQueCk7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBoYWxmOyBpID49IDE7IGktLSkge1xyXG4gICAgICAgICAgICBwb2ludHMgPSBbXTsgLy92YXIgcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHN0YXJ0UG9pbnQpOyAvL1xyXG4gICAgICAgICAgICAvLyBwb2ludHMucHVzaChuZXcgUG9pbnQoc3RhcnRQb2ludC54ICsgYnVuZGxlT2Zmc2V0ICwgc3RhcnRQb2ludC55ICsgaSAqIGJ1bmRsZUdhcCkpO1xyXG4gICAgICAgICAgICAvLyBwb2ludHMucHVzaChuZXcgUG9pbnQoZW5kUG9pbnQueCAtIGJ1bmRsZU9mZnNldCAsIHN0YXJ0UG9pbnQueSArIGkgKiBidW5kbGVHYXApKTsgLy9zdGFydFBvaW50LnggKyBidW5kbGVPZmZzZXRcclxuICAgICAgICAgICAgdmFyIHNlY29uZFBvaW50ID0gc3RhcnRQb2ludC5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgLy9zZWNvbmRQb2ludC54ID0gIHNlY29uZFBvaW50LnggKyB0aGlzLmJ1bmRsZU9mZnNldDtcclxuICAgICAgICAgICAgc2Vjb25kUG9pbnQudHJhbnNmb3JtKFV0aWwudHJhbnNsYXRpb25NYXRyaXgoMCwgdGhpcy5idW5kbGVHYXAgKiBpKSk7XHJcbiAgICAgICAgICAgIC8vc2Vjb25kUG9pbnQgPSB0aGlzLmJvdW5kT2Zmc2V0WFkoc2Vjb25kUG9pbnQsIHRydWUpO1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvL+ebtOinkuWdkOaghyB4LCDlkowgeSwg6K6h566X5Ye65p6B5Z2Q5qCHXHJcblxyXG5cclxuICAgICAgICAgICAgLy/ku47mnoHlnZDmoIforqHnrpflh7rnm7Top5LlnZDmoIdcclxuICAgICAgICAgICAgc2Vjb25kUG9pbnQueCA9IHNlY29uZFBvaW50LnggKyB0aGlzLmJ1bmRsZU9mZnNldCAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICAgICAgc2Vjb25kUG9pbnQueSA9IHNlY29uZFBvaW50LnkgKyB0aGlzLmJ1bmRsZU9mZnNldCAqIE1hdGguc2luKGFuZ2xlKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy9zZWNvbmRQb2ludC50cmFuc2Zvcm0oVXRpbC5zY2FsZU1hdHJpeCgwLjUpKTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goc2Vjb25kUG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRoaXJkUG9pbnQgPSBlbmRQb2ludC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAvL3RoaXJkUG9pbnQueCA9ICB0aGlyZFBvaW50LnggLSB0aGlzLmJ1bmRsZU9mZnNldDtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgdGhpcmRQb2ludC50cmFuc2Zvcm0oVXRpbC50cmFuc2xhdGlvbk1hdHJpeCgwLCB0aGlzLmJ1bmRsZUdhcCAqIGkpKTtcclxuICAgICAgICAgICAgLy90aGlyZFBvaW50ID0gdGhpcy5ib3VuZE9mZnNldFhZKHRoaXJkUG9pbnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgLy9zZWNvbmRQb2ludC50cmFuc2Zvcm0oVXRpbC5zY2FsZU1hdHJpeCgwLjUpKTtcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy/nm7Top5LlnZDmoIcgeCwg5ZKMIHksIOiuoeeul+WHuuaegeWdkOagh1xyXG5cclxuICAgICAgICAgICAgLy/ku47mnoHlnZDmoIforqHnrpflh7rnm7Top5LlnZDmoIdcclxuICAgICAgICAgICAgdGhpcmRQb2ludC54ID0gdGhpcmRQb2ludC54IC0gdGhpcy5idW5kbGVPZmZzZXQgKiBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgICAgIHRoaXJkUG9pbnQueSA9IHRoaXJkUG9pbnQueSAtIHRoaXMuYnVuZGxlT2Zmc2V0ICogTWF0aC5zaW4oYW5nbGUpO1xyXG5cclxuICAgICAgICAgICAgcG9pbnRzLnB1c2godGhpcmRQb2ludCk7XHJcblxyXG4gICAgICAgICAgICBwb2ludHMucHVzaChlbmRQb2ludCk7XHJcbiAgICAgICAgICAgIGFyckNvbm5lY3RSZXN1bHQucHVzaChwb2ludHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXJyQ29ubmVjdFJlc3VsdC5wdXNoKFtzdGFydFBvaW50LCBlbmRQb2ludF0pO1xyXG5cclxuICAgICAgICB2YXIgdXBIYWxmID0gTWF0aC5jZWlsKGFyckNvbnMubGVuZ3RoIC8gMik7XHJcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHVwSGFsZjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBvaW50cyA9IFtdOyAvL3ZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goc3RhcnRQb2ludCk7XHJcbiAgICAgICAgICAgIHZhciBzZWNQb2ludCA9IHN0YXJ0UG9pbnQuY2xvbmUoKTtcclxuICAgICAgICAgICAgLy9zZWNQb2ludC54ID0gIHNlY1BvaW50LnggKyB0aGlzLmJ1bmRsZU9mZnNldDtcclxuICAgICAgICAgICAgc2VjUG9pbnQudHJhbnNmb3JtKFV0aWwudHJhbnNsYXRpb25NYXRyaXgoMCwgLXRoaXMuYnVuZGxlR2FwICogaSkpO1xyXG4gICAgICAgICAgICBzZWNQb2ludC54ID0gc2VjUG9pbnQueCArIHRoaXMuYnVuZGxlT2Zmc2V0ICogTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgICAgICBzZWNQb2ludC55ID0gc2VjUG9pbnQueSArIHRoaXMuYnVuZGxlT2Zmc2V0ICogTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaChzZWNQb2ludCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdGhkUG9pbnQgPSBlbmRQb2ludC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAvL3RoZFBvaW50LnggPSAgdGhkUG9pbnQueCAtIHRoaXMuYnVuZGxlT2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGRQb2ludC50cmFuc2Zvcm0oVXRpbC50cmFuc2xhdGlvbk1hdHJpeCgwLCAtdGhpcy5idW5kbGVHYXAgKiBpKSk7XHJcbiAgICAgICAgICAgIC8v5LuO5p6B5Z2Q5qCH6K6h566X5Ye655u06KeS5Z2Q5qCHXHJcbiAgICAgICAgICAgIHRoZFBvaW50LnggPSB0aGRQb2ludC54IC0gdGhpcy5idW5kbGVPZmZzZXQgKiBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgICAgIHRoZFBvaW50LnkgPSB0aGRQb2ludC55IC0gdGhpcy5idW5kbGVPZmZzZXQgKiBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgICAgIC8vc2Vjb25kUG9pbnQudHJhbnNmb3JtKFV0aWwuc2NhbGVNYXRyaXgoMC41KSk7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHRoZFBvaW50KTtcclxuXHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGVuZFBvaW50KTtcclxuICAgICAgICAgICAgYXJyQ29ubmVjdFJlc3VsdC5wdXNoKHBvaW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyckNvbm5lY3RSZXN1bHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYXJyQ29uc1tpXS5yZWZyZXNoKGFyckNvbm5lY3RSZXN1bHRbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5ib3VuZE9mZnNldFhZID0gZnVuY3Rpb24ocG9pbnQsIGlzUG9zaXRpdmUpIHtcclxuICAgICAgICB2YXIgcmVzdWx0UG9pbnQgPSBwb2ludC5jbG9uZSgpO1xyXG4gICAgICAgIC8v55u06KeS5Z2Q5qCHIHgsIOWSjCB5LCDorqHnrpflh7rmnoHlnZDmoIdcclxuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHJlc3VsdFBvaW50LnksIHJlc3VsdFBvaW50LngpO1xyXG4gICAgICAgIHZhciByID0gTWF0aC5zcXJ0KE1hdGgucG93KHJlc3VsdFBvaW50LngsIDIpICsgTWF0aC5wb3cocmVzdWx0UG9pbnQueSwgMikpO1xyXG4gICAgICAgIGlmIChpc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgIHIgPSByICsgdGhpcy5idW5kbGVPZmZzZXQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgciA9IHIgLSB0aGlzLmJ1bmRsZU9mZnNldDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvL+S7juaegeWdkOagh+iuoeeul+WHuuebtOinkuWdkOagh1xyXG4gICAgICAgIHJlc3VsdFBvaW50LnggPSByICogTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgIHJlc3VsdFBvaW50LnkgPSByICogTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRQb2ludDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuvue9rue6v+auteeahOaooeWei+aVsOaNriAgKOexu+WeiyDmloflrZcpXHJcbiAgICAgKiBAcGFyYW0ge1t0eXBlXX0gY29ubmVjdG9yIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSB7W3R5cGVdfSBvcHRpb24gICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBGbG93Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldE1vZGVsID0gZnVuY3Rpb24oY29ubmVjdG9yLCBvcHRpb24pIHtcclxuICAgICAgICB2YXIgb3JpZ2luTGluZVR5cGUgPSBjb25uZWN0b3IubW9kZWwuZ2V0KFwic3R5bGUubGluZVR5cGVcIik7XHJcbiAgICAgICAgY29ubmVjdG9yLm1vZGVsLm1lcmdlT3B0aW9uKG9wdGlvbik7XHJcbiAgICAgICAgenJVdGlsLm1lcmdlKGNvbm5lY3Rvci5tb2RlbC5nZXQoXCJvcHRpb25zXCIpLCBvcHRpb24sIHRydWUpO1xyXG4gICAgICAgIGlmIChvcmlnaW5MaW5lVHlwZSAhPT0gb3B0aW9uLnN0eWxlLmxpbmVUeXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbm5lY3Rvcihjb25uZWN0b3IsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIoOmZpOaMh+WumueahOe6v1xyXG4gICAgICogQHBhcmFtIGNvbm5lY3RvciDmrLLliKDpmaTnmoTov57nur9cclxuICAgICAqIEBwYXJhbSBfenIgenJcclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZUJ5TGluZSA9IGZ1bmN0aW9uIChjb25uZWN0b3IsX3pyKSB7XHJcbiAgICAgICAgLy8xLuWwhue6vyDmiYDogZTnmoRzdGFydE5vZGXnmoRvdXRnb2luZ+aVsOaNruWIoOmZpFxyXG4gICAgICAgIGlmKGNvbm5lY3Rvci5zdGFydE5vZGUpe1xyXG4gICAgICAgICAgICB2YXIgc3RhcnROb2RlT3V0Z29pbmcgPSBjb25uZWN0b3Iuc3RhcnROb2RlLm1vZGVsLmdldChcIm91dGdvaW5nXCIpO1xyXG4gICAgICAgICAgICBpbmRleCA9IHpyVXRpbC5pbmRleE9mKHN0YXJ0Tm9kZU91dGdvaW5nLCBjb25uZWN0b3IucmVzb3VyY2VJZCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnROb2RlT3V0Z29pbmcuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yTWFwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5nZXRUd29Ob2RlSWQoY29ubmVjdG9yLnN0YXJ0Tm9kZSwgY29ubmVjdG9yLmVuZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JNYXAucmVtb3ZlSXRlbShrZXksIGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLzIu5LuOX3py5LiK5Yig6ZmkXHJcbiAgICAgICAgX3pyLnJlbW92ZShjb25uZWN0b3IpO1xyXG5cclxuXHJcbiAgICAgICAgLy8zLuS7jue6v+aVsOaNruS4reWIoOmZpFxyXG4gICAgICAgIHZhciBpbmRleCA9IHpyVXRpbC5pbmRleE9mKHRoaXMuY29ubmVjdG9ycywgY29ubmVjdG9yKTtcclxuICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNlbENvbm5lY3RvciA9PT0gY29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsQ29ubmVjdG9yID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWIt+aWsOi/nuaOpee6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub2RlIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIEZsb3dDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVmcmVzaExpbmVCeU5vZGUgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgLy8g5Yik5pat6L+Z5Liq6IqC54K55piv5ZCm5pyJ5aSa5p2h57q/5q61XHJcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmNvbm5lY3Rvck1hcC5rZXlzKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2Yobm9kZS5pZCkgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcnJDb25zID0gdGhpcy5jb25uZWN0b3JNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50TGluZVBvcyhhcnJDb25zKVxyXG4gICAgICAgICAgICAgICAgaWYgKGFyckNvbnMubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL+S4pOS4quiKgueCueWPquacieS4gOS4qui/nue6v+eahOaDheWGtVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaENvbm5lY3RvcihhcnJDb25zWzBdLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyQ29ucy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy/kuKTkuKroioLngrnmnInlpJrkuKrov57nur/nmoTmg4XlhrVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hDb25zKGFyckNvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yi35paw6L+e5o6l57q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vZGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS50b2dnbGVMaW5lQnlOb2RlID0gZnVuY3Rpb24obm9kZSwgaXNTaG93KSB7XHJcbiAgICAgICAgLy8g5Yik5pat6L+Z5Liq6IqC54K55piv5ZCm5pyJ5aSa5p2h57q/5q61XHJcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmNvbm5lY3Rvck1hcC5rZXlzKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2Yobm9kZS5pZCkgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcnJDb25zID0gdGhpcy5jb25uZWN0b3JNYXAuZ2V0KGtleSk7XHJcblxyXG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2goYXJyQ29ucywgZnVuY3Rpb24oY29ubmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGlzU2hvdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDph43mlrDosIPmlbTnur/nmoTkvY3nva5cclxuICAgICAqL1xyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb3VudExpbmVQb3MgPSBmdW5jdGlvbihhcnJDb25zKSB7XHJcbiAgICAgICAgenJVdGlsLmVhY2goYXJyQ29ucywgZnVuY3Rpb24oY29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gY29ubmVjdG9yLm9wdGlvbnM7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmF1dG9DaGFuZ2VQb3NpdGlvbiA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc1JlY3QgPSBVdGlsLmdldFJlY3QoY29ubmVjdG9yLnN0YXJ0Tm9kZSkuYm91bmRpbmdSZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGVSZWN0ID0gVXRpbC5nZXRSZWN0KGNvbm5lY3Rvci5lbmROb2RlKS5ib3VuZGluZ1JlY3Q7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRQb3MgPSBvcHRpb25zLnBvc2l0aW9uLnN0YXJ0UG9zO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZFBvcyA9IG9wdGlvbnMucG9zaXRpb24uZW5kUG9zO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0UG9zTm93ID0gdGhpcy5wb3NJc0NoYW5nZShzdGFydFBvcywgc1JlY3QsIGVSZWN0LCBcInN0YXJ0Tm9kZVwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRQb3NOb3cgPSB0aGlzLnBvc0lzQ2hhbmdlKGVuZFBvcywgc1JlY3QsIGVSZWN0LCBcImVuZE5vZGVcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRQb3MgIT0gc3RhcnRQb3NOb3cgfHwgZW5kUG9zICE9IGVuZFBvc05vdykge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24uc3RhcnRQb3MgPSBzdGFydFBvc05vdztcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uLmVuZFBvcyA9IGVuZFBvc05vdztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgRmxvd0Nvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wb3NJc0NoYW5nZSA9IGZ1bmN0aW9uKHBvcywgc1JlY3QsIGVSZWN0LCBub2RlVHlwZSkge1xyXG4gICAgICAgIHZhciBuZXdQb3NcclxuICAgICAgICBpZiAocG9zLmluZGV4T2YoXCJ0b3BcIikgIT0gLTEgfHwgcG9zLmluZGV4T2YoXCJib3R0b21cIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgaWYgKHNSZWN0LnkgKyBzUmVjdC5oZWlnaHQgPCBlUmVjdC55KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT0gXCJzdGFydE5vZGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8odG9wfGJvdHRvbSkvZywgXCJib3R0b21cIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8odG9wfGJvdHRvbSkvZywgXCJ0b3BcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZVJlY3QueSArIGVSZWN0LmhlaWdodCA8IHNSZWN0LnkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PSBcImVuZE5vZGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8odG9wfGJvdHRvbSkvZywgXCJib3R0b21cIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8odG9wfGJvdHRvbSkvZywgXCJ0b3BcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSBwb3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHBvcy5pbmRleE9mKFwibGVmdFwiKSAhPSAtMSB8fCBwb3MuaW5kZXhPZihcInJpZ2h0XCIpICE9IC0xKSB7XHJcbiAgICAgICAgICAgIGlmIChzUmVjdC54ICsgc1JlY3Qud2lkdGggPCBlUmVjdC54KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT0gXCJzdGFydE5vZGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcy5yZXBsYWNlKC8ocmlnaHR8bGVmdCkvZywgXCJyaWdodFwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zID0gcG9zLnJlcGxhY2UoLyhyaWdodHxsZWZ0KS9nLCBcImxlZnRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZVJlY3QueCArIGVSZWN0LndpZHRoIDwgc1JlY3QueCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09IFwiZW5kTm9kZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UG9zID0gcG9zLnJlcGxhY2UoLyhyaWdodHxsZWZ0KS9nLCBcInJpZ2h0XCIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQb3MgPSBwb3MucmVwbGFjZSgvKHJpZ2h0fGxlZnQpL2csIFwibGVmdFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld1BvcyA9IHBvcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1BvcyA9IHBvcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld1BvcztcclxuICAgIH1cclxuXHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKEZsb3dDb25uZWN0aW9uTWFuYWdlciwgQ29ubmVjdGlvbk1hbmFnZXIpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBGbG93Q29ubmVjdGlvbk1hbmFnZXI7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbWFuYWdlci9GbG93Q29ubmVjdGlvbk1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDov57nur/nrqHnkIbnsbtcclxuICogQGF1dGhvciB3YW5nLnhpYW9odVxyXG4gKi9cclxuXHJcbiAgICB2YXIgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcclxuICAgIHZhciBQb2ludCA9IHJlcXVpcmUoXCIuLi9Qb2ludC5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuICAgIHZhciBMb2cgPSByZXF1aXJlKFwiLi4vTG9nLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25NYW5hZ2VyKCkge1xyXG4gICAgICAgIHRoaXMuY29ubmVjdG9ycyA9IFtdOyAvL+W9k+WJjeeUu+W4g+aJgOacieeahOe6v+autVxyXG4gICAgICAgIHRoaXMuc2VsQ29ubmVjdG9yID0gbnVsbDsgLy/lvZPliY3pgInkuK3nmoTnur/mrrVcclxuICAgICAgICB0aGlzLnRlbXBDb25uZWN0b3IgPSBudWxsOyAvL+S4tOaXtue6v+autVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572u57q/55qE5LiN5Y+v57yW6L6RXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGZvcmJpZEVkaXQgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3RvckZvcmJpZEVkaXQgPSBmdW5jdGlvbiAoZm9yYmlkRWRpdCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25uZWN0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yc1tpXS5vcHRpb25zLmlzRWRpdCA9ICFmb3JiaWRFZGl0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmuIXnqbrov57mjqXnur/kuIrnmoTosIPmlbTkvY3nva7mjInpkq5cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2xlYXJTZWxlY3RDb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsQ29ubmVjdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ29ubmVjdG9yKHRoaXMuc2VsQ29ubmVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWIoOmZpOWSjOiKgueCueebuOWFs+iBlOeahOi/nuaOpee6v1xyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXHJcbiAgICAgKi9cclxuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVTZWxlY3RDb24gPSBmdW5jdGlvbiAobm9kZSwgX3pyKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbm5lY3RvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yc1tpXS5zdGFydE5vZGUgPT0gbm9kZSB8fCB0aGlzLmNvbm5lY3RvcnNbaV0uZW5kTm9kZSA9PSBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAvLzEu5bCG57q/IOaJgOiBlOeahHN0YXJ0Tm9kZeeahG91dGdvaW5n5pWw5o2u5Yig6ZmkXHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnROb2RlT3V0Z29pbmcgPSB0aGlzLmNvbm5lY3RvcnNbaV0uc3RhcnROb2RlLm1vZGVsLmdldChcIm91dGdvaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0genJVdGlsLmluZGV4T2Yoc3RhcnROb2RlT3V0Z29pbmcsIHRoaXMuY29ubmVjdG9yc1tpXS5yZXNvdXJjZUlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZU91dGdvaW5nLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLzIu5LuOX3py5LiK5Yig6ZmkXHJcbiAgICAgICAgICAgICAgICBfenIucmVtb3ZlKHRoaXMuY29ubmVjdG9yc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RvcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxDb25uZWN0b3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDliKDpmaTpgInlrprnmoTnur9cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlTGluZSA9IGZ1bmN0aW9uIChfenIpIHtcclxuICAgICAgICAvLzEu5bCG57q/IOaJgOiBlOeahHN0YXJ0Tm9kZeeahG91dGdvaW5n5pWw5o2u5Yig6ZmkXHJcbiAgICAgICAgaWYodGhpcy5zZWxDb25uZWN0b3Iuc3RhcnROb2RlKXtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZU91dGdvaW5nID0gdGhpcy5zZWxDb25uZWN0b3Iuc3RhcnROb2RlLm1vZGVsLmdldChcIm91dGdvaW5nXCIpO1xyXG4gICAgICAgICAgICBpbmRleCA9IHpyVXRpbC5pbmRleE9mKHN0YXJ0Tm9kZU91dGdvaW5nLCB0aGlzLnNlbENvbm5lY3Rvci5yZXNvdXJjZUlkKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE5vZGVPdXRnb2luZy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0b3JNYXApIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmdldFR3b05vZGVJZCh0aGlzLnNlbENvbm5lY3Rvci5zdGFydE5vZGUsIHRoaXMuc2VsQ29ubmVjdG9yLmVuZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JNYXAucmVtb3ZlSXRlbShrZXksIHRoaXMuc2VsQ29ubmVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vMi7ku45fenLkuIrliKDpmaRcclxuICAgICAgICBfenIucmVtb3ZlKHRoaXMuc2VsQ29ubmVjdG9yKTtcclxuXHJcblxyXG4gICAgICAgIC8vMy7ku47nur/mlbDmja7kuK3liKDpmaRcclxuICAgICAgICB2YXIgaW5kZXggPSB6clV0aWwuaW5kZXhPZih0aGlzLmNvbm5lY3RvcnMsIHRoaXMuc2VsQ29ubmVjdG9yKTtcclxuICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsQ29ubmVjdG9yID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOmHjeaWsOeUu+e6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBjb25uZWN0b3IgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBmb3JjZVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVmcmVzaENvbm5lY3RvciA9IGZ1bmN0aW9uIChjb25uZWN0b3IsIGZvcmNlKSB7XHJcbiAgICAgICAgLy8g5Y+q5pyJ6ZyA6KaB5by65Yi25Yi35pawICDmiJbogIUg6L+e57q/5Li656m677yIPDIp5pe2IOaJjei/m+ihjOmHjeaWsOiuoeeul+mHjee7mFxyXG4gICAgICAgIGlmIChmb3JjZSB8fCAoIWNvbm5lY3Rvci50dXJuaW5nUG9pbnRzKSB8fCAoY29ubmVjdG9yLnR1cm5pbmdQb2ludHMubGVuZ3RoIDwgMikpIHtcclxuICAgICAgICAgICAgaWYgKGNvbm5lY3Rvci5tb2RlbCAmJiBjb25uZWN0b3IubW9kZWwuZ2V0KFwic3R5bGUubGluZVR5cGVcIikpIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5vcHRpb25zLnN0eWxlLmxpbmVUeXBlID0gY29ubmVjdG9yLm1vZGVsLmdldChcInN0eWxlLmxpbmVUeXBlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhcnJTdGFydEVuZFBvaW50ID0gdGhpcy5nZXRTdGFydEVuZFBvaW50KGNvbm5lY3Rvcik7XHJcbiAgICAgICAgICAgIHZhciBlc2NhcGVEaXN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbiAmJiBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbi5lc2NhcGVEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgZXNjYXBlRGlzdGFuY2UgPSBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbi5lc2NhcGVEaXN0YW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc29sdXRpb25zID0gdGhpcy5jb25uZWN0b3IyUG9pbnRzKGNvbm5lY3Rvci5vcHRpb25zLnN0eWxlLmxpbmVUeXBlLCBhcnJTdGFydEVuZFBvaW50WzBdLFxyXG4gICAgICAgICAgICAgICAgYXJyU3RhcnRFbmRQb2ludFsxXSxcclxuICAgICAgICAgICAgICAgIGFyclN0YXJ0RW5kUG9pbnRbMl0sIGFyclN0YXJ0RW5kUG9pbnRbM10sIGVzY2FwZURpc3RhbmNlKTsgLy8gVFlQRV9TVFJBSUdIVCBUWVBFX0pBR0dFRFxyXG5cclxuICAgICAgICAgICAgY29ubmVjdG9yLnJlZnJlc2goc29sdXRpb25zWzBdWzJdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbm5lY3Rvci5jbGVhckhhbmRsZXMoKTsgLy/muIXnqbpoYW5kbGVcclxuICAgIH1cclxuXHJcblxyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFN0YXJ0RW5kUG9pbnQgPSBmdW5jdGlvbiAoY29ubmVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IGNvbm5lY3Rvci5zdGFydE5vZGU7XHJcbiAgICAgICAgdmFyIGVuZE5vZGUgPSBjb25uZWN0b3IuZW5kTm9kZTtcclxuXHJcbiAgICAgICAgdmFyIGlzTm90SW5TYW1lR3JvdXAgPSBzdGFydE5vZGUucGFyZW50ICE9PSBlbmROb2RlLnBhcmVudDtcclxuXHJcbiAgICAgICAgdmFyIHNSZWN0ID0gc3RhcnROb2RlLmdldFJlY3QgPyBzdGFydE5vZGUuZ2V0UmVjdCgpLmJvdW5kaW5nUmVjdCA6IFV0aWwuZ2V0UmVjdChzdGFydE5vZGUsIGlzTm90SW5TYW1lR3JvdXApLmJvdW5kaW5nUmVjdDtcclxuICAgICAgICB2YXIgc0JvdW5kcyA9IFtOdW1iZXIoc1JlY3QueCksIE51bWJlcihzUmVjdC55KSwgTnVtYmVyKHNSZWN0LngpICsgTnVtYmVyKHNSZWN0LndpZHRoKSwgTnVtYmVyKFxyXG4gICAgICAgICAgICBzUmVjdC55KSArIE51bWJlcihzUmVjdC5oZWlnaHQpXTtcclxuXHJcbiAgICAgICAgdmFyIGVSZWN0ID0gZW5kTm9kZS5nZXRSZWN0ID8gZW5kTm9kZS5nZXRSZWN0KCkuYm91bmRpbmdSZWN0IDogVXRpbC5nZXRSZWN0KGVuZE5vZGUsIGlzTm90SW5TYW1lR3JvdXApLmJvdW5kaW5nUmVjdDtcclxuICAgICAgICB2YXIgZUJvdW5kcyA9IFtOdW1iZXIoZVJlY3QueCksIE51bWJlcihlUmVjdC55KSwgTnVtYmVyKGVSZWN0LngpICsgTnVtYmVyKGVSZWN0LndpZHRoKSwgTnVtYmVyKFxyXG4gICAgICAgICAgICBlUmVjdC55KSArIE51bWJlcihlUmVjdC5oZWlnaHQpXTtcclxuXHJcblxyXG4gICAgICAgIHZhciBzQ29ubmVjdG9yUG9pbnQgPSBVdGlsLmdldENvbm5lY3RvclBvaW50cyhzUmVjdCk7XHJcbiAgICAgICAgdmFyIGVDb25uZWN0b3JQb2ludCA9IFV0aWwuZ2V0Q29ubmVjdG9yUG9pbnRzKGVSZWN0KTtcclxuXHJcbiAgICAgICAgLy/liKTmlq3lpoLmnpzmsqHmnInmjIflrprkvY3nva7nmoTor50sIOWIpOaWreW8gOWni+iKgueCueWcqOe7k+adn+e7k+aenOW3pui+ueWImemHh+eUqCByaWdodC1sZWZ0IOWQpuWImemHh+eUqGxlZnQtcmlnaHRcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbjtcclxuICAgICAgICBpZiAoIXBvc2l0aW9uLnN0YXJ0UG9zIHx8ICFwb3NpdGlvbi5lbmRQb3MpIHtcclxuICAgICAgICAgICAgaWYgKHNSZWN0LnggPCBlUmVjdC54KSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5zdGFydFBvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLmVuZFBvcyA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24uc3RhcnRQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLmVuZFBvcyA9IFwicmlnaHRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhcnRQb2ludCA9IHRoaXMuY2FsY1BvaW50RXhwcmVzc2lvbihwb3NpdGlvbi5zdGFydFBvcywgc0Nvbm5lY3RvclBvaW50KTtcclxuICAgICAgICB2YXIgZW5kUG9pbnQgPSB0aGlzLmNhbGNQb2ludEV4cHJlc3Npb24ocG9zaXRpb24uZW5kUG9zLCBlQ29ubmVjdG9yUG9pbnQpO1xyXG4gICAgICAgIHN0YXJ0UG9pbnQuYWRkKG5ldyBQb2ludChwb3NpdGlvbi5zdGFydE9mZnNldFswXSwgcG9zaXRpb24uc3RhcnRPZmZzZXRbMV0pKTtcclxuICAgICAgICBlbmRQb2ludC5hZGQobmV3IFBvaW50KHBvc2l0aW9uLmVuZE9mZnNldFswXSwgcG9zaXRpb24uZW5kT2Zmc2V0WzFdKSk7XHJcbiAgICAgICAgcmV0dXJuIFtzdGFydFBvaW50LCBlbmRQb2ludCwgc0JvdW5kcywgZUJvdW5kc107XHJcbiAgICB9XHJcblxyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNhbGNQb2ludEV4cHJlc3Npb24gPSBmdW5jdGlvbiAocG9zLCBwb2ludCkge1xyXG4gICAgICAgIHZhciB2YXJpYWJsZSA9IHtcclxuICAgICAgICAgICAgdG9wOiBwb2ludC50b3AueCxcclxuICAgICAgICAgICAgbGVmdDogcG9pbnQubGVmdC55LFxyXG4gICAgICAgICAgICByaWdodDogcG9pbnQucmlnaHQueSxcclxuICAgICAgICAgICAgYm90dG9tOiBwb2ludC5ib3R0b20ueCxcclxuICAgICAgICAgICAgY2VudGVyOiBwb2ludC5jZW50ZXIueFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBleHByZXNzaW9uID0gXCI8JSBwcmludChcIiArIHBvcyArIFwiKSAlPlwiO1xyXG4gICAgICAgIHZhciB2YWwgPSBwYXJzZUludChVdGlsLnRlbXBsYXRlKGV4cHJlc3Npb24pKHZhcmlhYmxlKSk7XHJcbiAgICAgICAgaWYgKHBvcy5pbmRleE9mKFwidG9wXCIpICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodmFsLCBwb2ludC50b3AueSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwb3MuaW5kZXhPZihcImxlZnRcIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwb2ludC5sZWZ0LngsIHZhbCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwb3MuaW5kZXhPZihcInJpZ2h0XCIpICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocG9pbnQucmlnaHQueCwgdmFsKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBvcy5pbmRleE9mKFwiYm90dG9tXCIpICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodmFsLCBwb2ludC5ib3R0b20ueSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwb3MuaW5kZXhPZihcImNlbnRlclwiKSAhPSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHZhbCwgcG9pbnQuYm90dG9tLnkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBvc+WPguaVsOmUmeivr1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rmiJbkv67mlLnkuLTml7bnur9cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhcnROb2RlICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gckVuZFBvaW50ICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbGluZVR5cGUgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUubWFuYWdlVGVtcENvbm5lY3RvciA9IGZ1bmN0aW9uIChzdGFydE5vZGUsIHJFbmRQb2ludCwgbGluZVR5cGUpIHtcclxuXHJcbiAgICAgICAgdmFyIHNSZWN0ID0gc3RhcnROb2RlLmdldFJlY3QgPyBzdGFydE5vZGUuZ2V0UmVjdCgpLmJvdW5kaW5nUmVjdCA6IFV0aWwuZ2V0UmVjdChzdGFydE5vZGUpLmJvdW5kaW5nUmVjdDtcclxuXHJcbiAgICAgICAgdmFyIHNCb3VuZHMgPSBbc1JlY3QueCwgc1JlY3QueSwgc1JlY3QueCArIHNSZWN0LndpZHRoLCBzUmVjdC55ICsgc1JlY3QuaGVpZ2h0XTtcclxuICAgICAgICB2YXIgc0Nvbm5lY3RvclBvaW50ID0gVXRpbC5nZXRDb25uZWN0b3JQb2ludHMoc1JlY3QpO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMudGVtcENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBDb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKHtcclxuICAgICAgICAgICAgICAgIGlzRWRpdDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVUeXBlOiBsaW5lVHlwZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjb25uZWN0b3IgPSB0aGlzLnRlbXBDb25uZWN0b3I7XHJcbiAgICAgICAgLy/liKTmlq3lpoLmnpzmsqHmnInmjIflrprkvY3nva7nmoTor50sIOWIpOaWreW8gOWni+iKgueCueWcqOe7k+adn+e7k+aenOW3pui+ueWImemHh+eUqCByaWdodC1sZWZ0IOWQpuWImemHh+eUqGxlZnQtcmlnaHRcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBjb25uZWN0b3Iub3B0aW9ucy5wb3NpdGlvbjtcclxuICAgICAgICBpZiAoc1JlY3QueCA8IHJFbmRQb2ludC54KSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0UG9zID0gXCJyaWdodFwiO1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5lbmRQb3MgPSBcImxlZnRcIjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydFBvcyA9IFwibGVmdFwiO1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5lbmRQb3MgPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25uZWN0b3Iub3B0aW9ucy5zdHlsZS5saW5lVHlwZSA9IGxpbmVUeXBlO1xyXG4gICAgICAgIHZhciBzb2x1dGlvbnMgPSB0aGlzLmNvbm5lY3RvcjJQb2ludHMobGluZVR5cGUsIHNDb25uZWN0b3JQb2ludFtwb3NpdGlvbi5zdGFydFBvc10sIHJFbmRQb2ludCxcclxuICAgICAgICAgICAgc0JvdW5kcywgbnVsbCk7IC8vIFRZUEVfU1RSQUlHSFQgVFlQRV9KQUdHRURcclxuXHJcbiAgICAgICAgY29ubmVjdG9yLnJlZnJlc2goc29sdXRpb25zWzBdWzJdKTtcclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yig6Zmk5Li05pe257q/XHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHpyICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZVRlbXBDb25uZWN0b3IgPSBmdW5jdGlvbiAoenIpIHtcclxuICAgICAgICBpZiAodGhpcy50ZW1wQ29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHpyLnJlbW92ZSh0aGlzLnRlbXBDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBDb25uZWN0b3IgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnrpflh7og5Lik5Liq6IqC54K5IOaMh+WumuS4pOS4queCueWmguS9leiBlOe6v1xyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSB0eXBlICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhcnRQb2ludCBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGVuZFBvaW50ICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzQm91bmRzICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZUJvdW5kcyAgICBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdG9yMlBvaW50cyA9IGZ1bmN0aW9uICh0eXBlLCBzdGFydFBvaW50LCBlbmRQb2ludCwgc0JvdW5kcywgZUJvdW5kcyxcclxuICAgICAgICBlc2NhcGVEaXN0YW5jZSkge1xyXG4gICAgICAgIHZhciBmaWd1cmVFc2NhcGVEaXN0YW5jZSA9IFszMCwgMzBdO1xyXG4gICAgICAgIGlmIChlc2NhcGVEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGVzY2FwZURpc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgZmlndXJlRXNjYXBlRGlzdGFuY2UgPSBbZXNjYXBlRGlzdGFuY2UsIGVzY2FwZURpc3RhbmNlXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZpZ3VyZUVzY2FwZURpc3RhbmNlID0gZXNjYXBlRGlzdGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIExvZy5ncm91cChcImNvbm5lY3Rpb25NYW5hZ2VyOiBjb25uZWN0b3IyUG9pbnRzXCIpO1xyXG5cclxuXHJcbiAgICAgICAgTG9nLmluZm8oXCJDb25uZWN0aW9uTWFuYWdlcjogY29ubmVjdG9yMlBvaW50cyAoXCIgKyB0eXBlICsgXCIsIFwiICsgc3RhcnRQb2ludCArIFwiLCBcIiArIGVuZFBvaW50ICtcclxuICAgICAgICAgICAgXCIsIFwiICsgc0JvdW5kcyArIFwiLCBcIiArIGVCb3VuZHMgKyAnKScpO1xyXG4gICAgICAgIHZhciBzb2x1dGlvbnMgPSBbXTtcclxuXHJcblxyXG5cclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBDb25uZWN0b3IuVFlQRV9TVFJBSUdIVDogLy/nm7Tnur9cclxuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBbc3RhcnRQb2ludC5jbG9uZSgpLCBlbmRQb2ludC5jbG9uZSgpXTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnc3RyYWlnaHQnLCAnc3RyYWlnaHQnLCBwb2ludHNdKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBDb25uZWN0b3IuVFlQRV9DVVJWRTogLy/mm7Lnur9cclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ29ubmVjdG9yLlRZUEVfSkFHR0VEOiAvL+aKmOe6v1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0RXhpdFBvaW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRFeGl0UG9pbnQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZmluZCBzdGFydCBleGl0IHBvaW50ICDlr7vmib7lvIDlp4vlh7rlj6NcclxuICAgICAgICAgICAgICAgIGlmIChzQm91bmRzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG90ZW50aWFsRXhpdHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsRXhpdHMucHVzaChuZXcgUG9pbnQoc3RhcnRQb2ludC54LCBzQm91bmRzWzFdIC0gZmlndXJlRXNjYXBlRGlzdGFuY2VbMF0pKTsgLy9ub3J0aCDljJdcclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChzQm91bmRzWzJdICsgZmlndXJlRXNjYXBlRGlzdGFuY2VbMF0sIHN0YXJ0UG9pbnQueSkpOyAvL2Vhc3QgIOS4nFxyXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KHN0YXJ0UG9pbnQueCwgc0JvdW5kc1szXSArIGZpZ3VyZUVzY2FwZURpc3RhbmNlWzBdKSk7IC8vc291dGggIOWNl1xyXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KHNCb3VuZHNbMF0gLSBmaWd1cmVFc2NhcGVEaXN0YW5jZVswXSwgc3RhcnRQb2ludC55KSk7IC8vd2VzdCAg6KW/XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcGljayBjbG9zZXN0IGV4aXQgcG9pbnQgIOWvu+aJvuS4jiBzdGFydFBvaW50IOacgOmdoOi/keeahOWHuuWPo+eCuVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RXhpdFBvaW50ID0gcG90ZW50aWFsRXhpdHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb3RlbnRpYWxFeGl0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbC5kaXN0YW5jZShzdGFydFBvaW50LCBwb3RlbnRpYWxFeGl0c1tpXSkgPCBVdGlsLmRpc3RhbmNlKHN0YXJ0UG9pbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRFeGl0UG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEV4aXRQb2ludCA9IHBvdGVudGlhbEV4aXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL2ZpbmQgZW5kIGV4aXQgcG9pbnQgIOWvu+aJvue7k+adn+WHuuWPo1xyXG4gICAgICAgICAgICAgICAgaWYgKGVCb3VuZHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3RlbnRpYWxFeGl0cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChlbmRQb2ludC54LCBlQm91bmRzWzFdIC0gZmlndXJlRXNjYXBlRGlzdGFuY2VbMV0pKTsgLy9ub3J0aFxyXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KGVCb3VuZHNbMl0gKyBmaWd1cmVFc2NhcGVEaXN0YW5jZVsxXSwgZW5kUG9pbnQueSkpOyAvL2Vhc3RcclxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxFeGl0cy5wdXNoKG5ldyBQb2ludChlbmRQb2ludC54LCBlQm91bmRzWzNdICsgZmlndXJlRXNjYXBlRGlzdGFuY2VbMV0pKTsgLy9zb3V0aFxyXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbEV4aXRzLnB1c2gobmV3IFBvaW50KGVCb3VuZHNbMF0gLSBmaWd1cmVFc2NhcGVEaXN0YW5jZVsxXSwgZW5kUG9pbnQueSkpOyAvL3dlc3RcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9waWNrIGNsb3Nlc3QgZXhpdCBwb2ludCAg5a+75om+5LiOIGVuZFBvaW50IOacgOmdoOi/keeahOWHuuWPo+eCuVxyXG4gICAgICAgICAgICAgICAgICAgIGVuZEV4aXRQb2ludCA9IHBvdGVudGlhbEV4aXRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG90ZW50aWFsRXhpdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWwuZGlzdGFuY2UoZW5kUG9pbnQsIHBvdGVudGlhbEV4aXRzW2ldKSA8IFV0aWwuZGlzdGFuY2UoZW5kUG9pbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRXhpdFBvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRXhpdFBvaW50ID0gcG90ZW50aWFsRXhpdHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9CYXNpYyBzb2x1dGlvbiDmnIDln7rmnKznmoTop6PlhrPmlrnmoYggICDkuLrlhbbku5bop6PlhrPmlrnmoYjlgZrlh4blpIdcclxuICAgICAgICAgICAgICAgIHZhciBzID0gW3N0YXJ0UG9pbnRdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdhcEluZGV4ID0gMDsgLy90aGUgaW5kZXggb2YgdGhlIGdhcCAod2hlcmUgZG8gd2UgbmVlZCB0byBpbnNlcnQgbmV3IHBvaW50cykgRE8gTk9UIENIQU5HRSBJVFxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0RXhpdFBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcy5wdXNoKHN0YXJ0RXhpdFBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICBnYXBJbmRleCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kRXhpdFBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcy5wdXNoKGVuZEV4aXRQb2ludCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzLnB1c2goZW5kUG9pbnQpO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9TTyAtIG5vIGFkZGl0aW9uYWwgcG9pbnRzICAgICBTMCDop6PlhrPmlrnmoYgg5LiN5re75Yqg5Lu75L2V54K5ICDln7rmnKzkuI3kvJrooqvph4fnlKhcclxuICAgICAgICAgICAgICAgIHZhciBzMCA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MwJywgJ3MwJywgczBdKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vUzEgICBTMSDop6PlhrPmlrnmoYggIOWPquacieS4gOS4quaKmOeCuVxyXG4gICAgICAgICAgICAgICAgdmFyIHMxID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2ZpcnN0IHZhcmlhbnQgICDnrKzkuIDkuKrlj5jkvZMgczEgczFfMeaWueahiCAg5oqY57q/54K55ZyoIHN0YXJ0RXhpdFBvaW5055qEWCDkuI4gZW5kRXhpdFBvaW5055qEIFnkvY3nva5cclxuICAgICAgICAgICAgICAgIHZhciBzMV8xID0gUG9pbnQuY2xvbmVBcnJheShzMSk7XHJcbiAgICAgICAgICAgICAgICBzMV8xLnNwbGljZShnYXBJbmRleCArIDEsIDAsIG5ldyBQb2ludChzMV8xW2dhcEluZGV4XS54LCBzMV8xW2dhcEluZGV4ICsgMV0ueSkpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMScsICdzMV8xJywgczFfMV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vc2Vjb25kIHZhcmlhbnQgIOesrOS6jOWPmOS9kyBzMSBzMS0y5pa55qGIICDmipjnur/ngrnlnKggZW5kRXhpdFBvaW5055qEWCDkuI4gIHN0YXJ0RXhpdFBvaW5055qEWeS9jee9rlxyXG4gICAgICAgICAgICAgICAgdmFyIHMxXzIgPSBQb2ludC5jbG9uZUFycmF5KHMxKTtcclxuICAgICAgICAgICAgICAgIHMxXzIuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgbmV3IFBvaW50KHMxXzJbZ2FwSW5kZXggKyAxXS54LCBzMV8yW2dhcEluZGV4XS55KSk7XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MxJywgJ3MxXzInLCBzMV8yXSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vUzIgIFMyIOino+WGs+aWueahiCAg5re75Yqg5Lik5Liq5oqY54K5XHJcblxyXG4gICAgICAgICAgICAgICAgLy9WYXJpYW50IEkgICBzMl8x5pa55qGIXHJcbiAgICAgICAgICAgICAgICB2YXIgczJfMSA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfMV8xID0gbmV3IFBvaW50KChzMl8xW2dhcEluZGV4XS54ICsgczJfMVtnYXBJbmRleCArIDFdLngpIC8gMiwgczJfMVtnYXBJbmRleF0ueSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfMV8yID0gbmV3IFBvaW50KChzMl8xW2dhcEluZGV4XS54ICsgczJfMVtnYXBJbmRleCArIDFdLngpIC8gMiwgczJfMVtnYXBJbmRleCArIDFdLnkpO1xyXG4gICAgICAgICAgICAgICAgczJfMS5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBzMl8xXzEsIHMyXzFfMik7XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MyJywgJ3MyXzEnLCBzMl8xXSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vVmFyaWFudCBJSSAgczJfMeaWueahiCAgMeaKmOe6v+eCuSB4OiBzdGFydEV4aXRQb2ludOeahFgg5L2N572uIHk6IHN0YXJ0RXhpdFBvaW5055qEeStlbmRFeGl0UG9pbnTnmoR5LzJcclxuICAgICAgICAgICAgICAgIC8vMeaKmOe6v+eCuSB4OmVuZEV4aXRQb2ludOeahHggIHk6c3RhcnRFeGl0UG9pbnTnmoR5K2VuZEV4aXRQb2ludOeahHkvMlxyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzIgPSBQb2ludC5jbG9uZUFycmF5KHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzJfMSA9IG5ldyBQb2ludChzMl8yW2dhcEluZGV4XS54LCAoczJfMltnYXBJbmRleF0ueSArIHMyXzJbZ2FwSW5kZXggKyAxXS55KSAvIDIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzJfMiA9IG5ldyBQb2ludChzMl8yW2dhcEluZGV4ICsgMV0ueCwgKHMyXzJbZ2FwSW5kZXhdLnkgKyBzMl8yW2dhcEluZGV4ICsgMV0ueSkgLyAyKTtcclxuICAgICAgICAgICAgICAgIHMyXzIuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgczJfMl8xLCBzMl8yXzIpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl8yJywgczJfMl0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgSUlJXHJcbiAgICAgICAgICAgICAgICB2YXIgczJfMyA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICAvL2ZpbmQgdGhlIGFtb3VudCAoc3RvcmVkIGluIGRlbHRhKSBvZiBwaXhlbHMgd2UgbmVlZCB0byBtb3ZlIHJpZ2h0IHNvIG5vIGludGVyc2VjdGlvbiB3aXRoIGEgZmlndXJlIHdpbGwgYmUgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgLy8hU2VlOiAgL2RvY3VtZW50cy9zcGVjcy9jb25uZWN0ZWRfZmlndXJlc19kZWx0YXMuanBnIGZpbGVcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZWFzdEV4aXRzID0gW3MyXzNbZ2FwSW5kZXhdLnggKyAyMCwgczJfM1tnYXBJbmRleCArIDFdLnggKyAyMF07IC8vYWRkIHBvaW50cyBYIGNvb3JkaW5hdGVzIHRvIGJlIGFibGUgdG8gZ2VuZXJhdGUgVmFyaWFudCBJSUkgZXZlbiBpbiB0aGUgYWJzZW5jZSBvZiBmaWd1cmVzIDpwXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBlYXN0RXhpdHMucHVzaChzQm91bmRzWzJdICsgMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWFzdEV4aXRzLnB1c2goZUJvdW5kc1syXSArIDIwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZWFzdEV4aXQgPSBVdGlsLm1heChlYXN0RXhpdHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzNfMSA9IG5ldyBQb2ludChlYXN0RXhpdCwgczJfM1tnYXBJbmRleF0ueSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfM18yID0gbmV3IFBvaW50KGVhc3RFeGl0LCBzMl8zW2dhcEluZGV4ICsgMV0ueSk7XHJcbiAgICAgICAgICAgICAgICBzMl8zLnNwbGljZShnYXBJbmRleCArIDEsIDAsIHMyXzNfMSwgczJfM18yKTtcclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKFsnczInLCAnczJfMycsIHMyXzNdKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9WYXJpYW50IElWICBzMl805pa55qGIXHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNCA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICAvL2ZpbmQgdGhlIGFtb3VudCAoc3RvcmVkIGluIGRlbHRhKSBvZiBwaXhlbHMgd2UgbmVlZCB0byBtb3ZlIHVwIHNvIG5vIGludGVyc2VjdGlvbiB3aXRoIGEgZmlndXJlIHdpbGwgYmUgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgLy8hU2VlOiAgL2RvY3VtZW50cy9zcGVjcy9jb25uZWN0ZWRfZmlndXJlc19kZWx0YXMuanBnIGZpbGVcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbm9ydGhFeGl0cyA9IFtzMl80W2dhcEluZGV4XS55IC0gMjAsIHMyXzRbZ2FwSW5kZXggKyAxXS55IC0gMjBdOyAvL2FkZCBwb2ludHMgeSBjb29yZGluYXRlcyB0byBiZSBhYmxlIHRvIGdlbmVyYXRlIFZhcmlhbnQgSUlJIGV2ZW4gaW4gdGhlIGFic2VuY2Ugb2YgZmlndXJlcyA6cFxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ydGhFeGl0cy5wdXNoKHNCb3VuZHNbMV0gLSAyMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBub3J0aEV4aXRzLnB1c2goZUJvdW5kc1sxXSAtIDIwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbm9ydGhFeGl0ID0gVXRpbC5taW4obm9ydGhFeGl0cyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNF8xID0gbmV3IFBvaW50KHMyXzRbZ2FwSW5kZXhdLngsIG5vcnRoRXhpdCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNF8yID0gbmV3IFBvaW50KHMyXzRbZ2FwSW5kZXggKyAxXS54LCBub3J0aEV4aXQpO1xyXG4gICAgICAgICAgICAgICAgczJfNC5zcGxpY2UoZ2FwSW5kZXggKyAxLCAwLCBzMl80XzEsIHMyXzRfMik7XHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbJ3MyJywgJ3MyXzQnLCBzMl80XSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vVmFyaWFudCBWXHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNSA9IFBvaW50LmNsb25lQXJyYXkocyk7XHJcbiAgICAgICAgICAgICAgICAvL2ZpbmQgdGhlIGFtb3VudCAoc3RvcmVkIGluIGRlbHRhKSBvZiBwaXhlbHMgd2UgbmVlZCB0byBtb3ZlIGxlZnQgc28gbm8gaW50ZXJzZWN0aW9uIHdpdGggYSBmaWd1cmUgd2lsbCBiZSBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAvLyFTZWU6ICAvZG9jdW1lbnRzL3NwZWNzL2Nvbm5lY3RlZF9maWd1cmVzX2RlbHRhcy5qcGcgZmlsZVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB3ZXN0RXhpdHMgPSBbczJfNVtnYXBJbmRleF0ueCAtIDIwLCBzMl81W2dhcEluZGV4ICsgMV0ueCAtIDIwXTsgLy9hZGQgcG9pbnRzIHggY29vcmRpbmF0ZXMgdG8gYmUgYWJsZSB0byBnZW5lcmF0ZSBWYXJpYW50IElJSSBldmVuIGluIHRoZSBhYnNlbmNlIG9mIGZpZ3VyZXMgOnBcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc0JvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdlc3RFeGl0cy5wdXNoKHNCb3VuZHNbMF0gLSAyMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB3ZXN0RXhpdHMucHVzaChlQm91bmRzWzBdIC0gMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB3ZXN0RXhpdCA9IFV0aWwubWluKHdlc3RFeGl0cyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgczJfNV8xID0gbmV3IFBvaW50KHdlc3RFeGl0LCBzMl81W2dhcEluZGV4XS55KTtcclxuICAgICAgICAgICAgICAgIHZhciBzMl81XzIgPSBuZXcgUG9pbnQod2VzdEV4aXQsIHMyXzVbZ2FwSW5kZXggKyAxXS55KTtcclxuICAgICAgICAgICAgICAgIHMyXzUuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgczJfNV8xLCBzMl81XzIpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl81JywgczJfNV0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1ZhcmlhbnQgVklcclxuICAgICAgICAgICAgICAgIHZhciBzMl82ID0gUG9pbnQuY2xvbmVBcnJheShzKTtcclxuICAgICAgICAgICAgICAgIC8vZmluZCB0aGUgYW1vdW50IChzdG9yZWQgaW4gZGVsdGEpIG9mIHBpeGVscyB3ZSBuZWVkIHRvIG1vdmUgZG93biBzbyBubyBpbnRlcnNlY3Rpb24gd2l0aCBhIGZpZ3VyZSB3aWxsIGJlIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIC8vIVNlZTogIC9kb2N1bWVudHMvc3BlY3MvY29ubmVjdGVkX2ZpZ3VyZXNfZGVsdGFzLmpwZyBmaWxlXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNvdXRoRXhpdHMgPSBbczJfNltnYXBJbmRleF0ueSArIDIwLCBzMl82W2dhcEluZGV4ICsgMV0ueSArIDIwXTsgLy9hZGQgcG9pbnRzIHkgY29vcmRpbmF0ZXMgdG8gYmUgYWJsZSB0byBnZW5lcmF0ZSBWYXJpYW50IElJSSBldmVuIGluIHRoZSBhYnNlbmNlIG9mIGZpZ3VyZXMgOnBcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc0JvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvdXRoRXhpdHMucHVzaChzQm91bmRzWzNdICsgMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc291dGhFeGl0cy5wdXNoKGVCb3VuZHNbM10gKyAyMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNvdXRoRXhpdCA9IFV0aWwubWF4KHNvdXRoRXhpdHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzZfMSA9IG5ldyBQb2ludChzMl82W2dhcEluZGV4XS54LCBzb3V0aEV4aXQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMyXzZfMiA9IG5ldyBQb2ludChzMl82W2dhcEluZGV4ICsgMV0ueCwgc291dGhFeGl0KTtcclxuICAgICAgICAgICAgICAgIHMyXzYuc3BsaWNlKGdhcEluZGV4ICsgMSwgMCwgczJfNl8xLCBzMl82XzIpO1xyXG4gICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goWydzMicsICdzMl82JywgczJfNl0pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9GSUxURVIgc29sdXRpb25zXHJcblxyXG4gICAgICAgICAgICAgICAgLypBbGdvcml0aG1cclxuICAgICAgICAgICAgICAgICAqIDAuIHNvbHV0aW9ucyBhcmUgb3JkZXJlZCBmcm9tIG1pbmltbXVuIG5yIG9mIHBvaW50cyB0byBtYXhpbXVtID46KVxyXG4gICAgICAgICAgICAgICAgICogMS4gcmVtb3ZlIGFsbCBzb2x1dGlvbnMgdGhhdCBhcmUgbm90IG9ydGhvZ29uYWwgKG1haW5seSBzMCBzb2x1dGlvbilcclxuICAgICAgICAgICAgICAgICAqIDIuIHJlbW92ZSBhbGwgc29sdXRpb25zIHRoYXQgZ28gYmFja3dhcmQgKHdlIHdpbGwgbm90IG5lZWQgdGhlbSBldmVyKVxyXG4gICAgICAgICAgICAgICAgICogMy4gcmVtb3ZlIGFsbCBzb2x1dGlvbnMgd2l0aCBpbnRlcnNlY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgKiA0LiBwaWNrIGZpcnN0IGNsYXNzIG9mIHNvbHV0aW9ucyB3aXRoIHNhbWUgbnIgb2YgcG9pbnRzIChleDogMilcclxuICAgICAgICAgICAgICAgICAqIDUuIHBpY2sgdGhlIGZpcnN0IHNvbHV0aW9uIHdpdGggOTAgZGVncmVlIGFuZ2xlcyAobGVzcyB0dXJuYXJvdW5kcylcclxuICAgICAgICAgICAgICAgICAqIChub3QgaW50ZXJlc3RldGVkKSBzb3J0IGJ5IGxlbmd0aCA6cFxyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgLy8xLiBmaWx0ZXIgbm9uIG9ydG9nb25hbCBzb2x1dGlvbnMg5Yig6Zmk5LiN5piv5q2j5Lqk55u057q/55qE5pa55qGIXHJcbiAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIkZpbHRlciBvcnRob2dvbmFsIHNvbHV0aW9ucy4gSW5pdGlhbCBudW1iZXIgb2Ygc29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHZhciBvcnRob2dvbmFsU29sdXRpb24gPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgc29sdXRpb25zLmxlbmd0aDsgbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gc29sdXRpb25zW2xdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChVdGlsLm9ydGhvZ29uYWxQYXRoKHNvbHV0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcnRob2dvbmFsU29sdXRpb24ucHVzaChzb2x1dGlvbnNbbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucyA9IG9ydGhvZ29uYWxTb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiXFxuXFx0T3J0aG9nb25hbFNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8yLiBmaWx0ZXIgYmFja3dhcmQgc29sdXRpb25zICDov4fmu6Qg5YCS6YCA55qE5pa55qGIXHJcbiAgICAgICAgICAgICAgICAvL2RvIG5vdCBhbGxvdyBzdGFydCBhbmQgZW5kIHBvaW50cyB0byBjb2luY2lkZSAtIGlnbm9yZSB0aGVtXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRQb2ludC5lcXVhbHMoZW5kUG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nLmluZm8oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiU3RhcnQgYW5kIGVuZCBwb2ludCBjb2luY2lkZS4uLnNraXAgYmFja3dhcmQgc29sdXRpb24uIEkgdGhpbmsgd2Ugd2lsbCBqdXN0IGZhbGwgb24gczAgOilcIlxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiRmlsdGVyIGJhY2t3YXJkIHNvbHV0aW9ucy4gSW5pdGlhbCBudW1iZXIgb2Ygc29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZm9yd2FyZFNvbHV0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBzb2x1dGlvbnMubGVuZ3RoOyBsKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gc29sdXRpb25zW2xdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbC5mb3J3YXJkUGF0aChzb2x1dGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcndhcmRTb2x1dGlvbnMucHVzaChzb2x1dGlvbnNbbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHRlbXAgKyBcIlxcblxcdFwiICsgc29sdXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zID0gZm9yd2FyZFNvbHV0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIlxcblxcdCBGb3J3YXJkU29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc29sdXRpb25zLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZy5pbmZvKFwiRGlzY2FyZGVkIHNvbHV0aW9uczogXCIgKyB0ZW1wKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vMy4gRmlsdGVyIG5vbiBpbnRlcnNlY3Rpbmcgc29sdXRpb25zICDljrvpmaTmsqHmnInkuqTpm4YoKeeahOaWueahiFxyXG4gICAgICAgICAgICAgICAgTG9nLmluZm8oXCJGaWx0ZXIgbm9uIGludGVyc2VjdGluZyBzb2x1dGlvbnMuIEluaXRpYWwgbnVtYmVyIG9mIHNvbHV0aW9ucyA9IFwiICsgc29sdXRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9uSW50ZXJzZWN0aW9uU29sdXRpb25zID0gW11cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgc29sdXRpb25zLmxlbmd0aDsgbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gc29sdXRpb25zW2xdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vTG9nLmluZm8oXCJTb2x1dGlvbiBpZD0gXCIgKyBzb2x1dGlvbnNbbF1bMV0gKyAnIG5yIHBvaW50cyA9ICcgKyBzb2x1dGlvbi5sZW5ndGggKyBcIiwgcG9pbnRzID0gXCIgKyBzb2x1dGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5uZXJMaW5lcyA9IHNvbHV0aW9uLnNsaWNlKCk7IC8vanVzdCBhIHNoYWxsb3cgY29weVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKklmIGFueSBib3VuZHMganVzdCB0cmltIHRoZSBzb2x1dGlvbi4gU28gd2UgYXZvaWQgdGhlIHN0cmFuZ2UgY2FzZSB3aGVuIGEgY29ubmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqc3RhcnRlcyBmcm9tIGEgcG9pbnQgb24gYSBmaWd1cmUgYW5kIGVuZHMgaW5zaWRlIG9mIHRoZSBzYW1lIGZpZ3VyZSwgYnV0IG5vdCBvbiBhIGNvbm5lY3Rpb24gcG9pbnQqL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlQm91bmRzIHx8IHNCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pMG5uZXJMaW5lcyA9IGlubmVyTGluZXMuc2xpY2UoMCwgaW5uZXJMaW5lcy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJMaW5lcyA9IGlubmVyTGluZXMuc2xpY2UoMSwgaW5uZXJMaW5lcy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9Mb2cuaW5mbyhcIlxcdCBlQm91bmRzIHByZXNlbnQsaW5uZXJMaW5lcyBuci4gcG9pbnRzID0gXCIgKyBpbm5lckxpbmVzLmxlbmd0aCArIFwiLCBwb2ludHMgPSBcIiArIGlubmVyTGluZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL25vdyB0ZXN0IGZvciBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc0JvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3QgPSBpbnRlcnNlY3QgfHwgVXRpbC5wb2x5bGluZUludGVyc2VjdHNSZWN0YW5nbGUoaW5uZXJMaW5lcywgc0JvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdCA9IGludGVyc2VjdCB8fCBVdGlsLnBvbHlsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZShpbm5lckxpbmVzLCBlQm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW50ZXJzZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vbkludGVyc2VjdGlvblNvbHV0aW9ucy5wdXNoKHNvbHV0aW9uc1tsXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vSWYgYWxsIHNvbHV0aW9ucyBpbnRlcnNlY3QgdGhhbiB0aGlzIGlzIGRlc3RpbnkgIDopIGFuZCBqdXN0IGlnbm9yZSB0aGUgaW50ZXJzZWN0aW9uIGZpbHRlclxyXG4gICAgICAgICAgICAgICAgaWYgKG5vbkludGVyc2VjdGlvblNvbHV0aW9ucy5sZW5ndGggIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVhc2lnbiB0byBzb2x1dGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSBub25JbnRlcnNlY3Rpb25Tb2x1dGlvbnM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgTG9nLmluZm8oXCJcXG5cXHQgbm9uSW50ZXJzZWN0aW9uU29sdXRpb25zID0gXCIgKyBzb2x1dGlvbnMubGVuZ3RoKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy80LiBnZXQgZmlyc3QgY2xhc3Mgb2Ygc29sdXRpb25zIHdpdGggc2FtZSBuciBvZiBwb2ludHMg6YCJ5oup5LiO56ys5LiA5Liq5pa55qGI54K55pWw5LiA5qC35aSa55qE5pa55qGI77yI5Zug5Li656ys5LiA5Liq5pa55qGI54K55pWw5pyA5bCR77yJXHJcbiAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIkdldCBmaXJzdCBjbGFzcyBvZiBzb2x1dGlvbnMgd2l0aCBzYW1lIG5yIG9mIHBvaW50c1wiKTtcclxuICAgICAgICAgICAgICAgIGlmIChzb2x1dGlvbnMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2cuaW5mbyhcIlRoaXMgaXMgbm90IHBvc3NpYmxlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBmaXJzdFNvbHV0aW9uID0gc29sdXRpb25zWzBdWzJdOyAvL3BpY2sgZmlyc3Qgc29sdXRpb25cclxuICAgICAgICAgICAgICAgIHZhciBuck9mUG9pbnRzID0gZmlyc3RTb2x1dGlvbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2FtZU5yUG9pbnRzU29sdXRpb24gPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHNvbHV0aW9ucy5sZW5ndGg7IGwrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IHNvbHV0aW9uc1tsXVsyXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc29sdXRpb24ubGVuZ3RoID09IG5yT2ZQb2ludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtZU5yUG9pbnRzU29sdXRpb24ucHVzaChzb2x1dGlvbnNbbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSBzYW1lTnJQb2ludHNTb2x1dGlvbjtcclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvKjUuICDorqHnrpfot6/lvoTliIbmlbAg77yM5Y+W5pyA5YiG5pWw6auY55qEXHJcbiAgICAgICAgICAgICAgICAgUGljayB0aGUgZmlyc3Qgc29sdXRpb24gd2l0aCA5MCBkZWdyZWUgYW5nbGVzIChsZXNzIHR1cm5hcm91bmRzKVxyXG4gICAgICAgICAgICAgICAgICppbiBjYXNlIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBzb2x1dGlvbiBpbiBvdXIgY2xhc3NcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTG9nLmluZm8oXCJwaWNrIHRoZSBmaXJzdCBzb2x1dGlvbiB3aXRoIDkwIGRlZ3JlZSBhbmdsZXMgKGxlc3MgdHVybmFyb3VuZHMpXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvbEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgc29sdXRpb25zLmxlbmd0aDsgbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gc29sdXRpb25zW2xdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChVdGlsLnNjb3JlUGF0aChzb2x1dGlvbnNbc29sSW5kZXhdWzJdKSA8IFV0aWwuc2NvcmVQYXRoKHNvbHV0aW9uc1tsXVsyXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29sSW5kZXggPSBsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucyA9IFtzb2x1dGlvbnNbc29sSW5kZXhdXTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1NNT09USElORyBjdXJ2ZVxyXG4gICAgICAgIGlmICh0eXBlID09PSBDb25uZWN0b3IuVFlQRV9DVVJWRSkge1xyXG4gICAgICAgICAgICB0aGlzLnNtb290aEN1cnZlKHNvbHV0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vRU5EIFNNT09USElORyBjdXJ2ZVxyXG5cclxuICAgICAgICBMb2cuZ3JvdXBFbmQoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNvbHV0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc21vb3RoQ3VydmUgPSBmdW5jdGlvbiAoc29sdXRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbiA9IDM7XHJcblxyXG4gICAgICAgIHN3aXRjaCAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIC8vZG8gbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDE6IC8vYWRkIGludGVybWVkaWF0ZSBwb2ludHNcclxuICAgICAgICAgICAgICAgIC8vQWRkIHRoZSBtaWRkbGUgcG9pbnQgZm9yIHN0YXJ0IGFuZCBlbmQgc2VnbWVudCBzbyB0aGF0IHdlIFwiZm9yY2VcIiB0aGVcclxuICAgICAgICAgICAgICAgIC8vY3VydmUgdG8gYm90aCBjb21lIFwicGVycGVuZGljdWxhclwiIG9uIGJvdW5kcyBhbmQgYWxzbyBtYWtlIHRoZSBjdXJ2ZVxyXG4gICAgICAgICAgICAgICAgLy9cImZsZWVcIiBtb3JlIGZyb20gYm91bmRzIChvbiBleGl0KVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzb2x1dGlvbnMubGVuZ3RoOyBzKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc29sVHVybmluZ1BvaW50cyA9IHNvbHV0aW9uc1tzXVsyXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9maXJzdCBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGExID0gc29sVHVybmluZ1BvaW50c1swXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYTIgPSBzb2xUdXJuaW5nUG9pbnRzWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydE1pZGRsZVBvaW50ID0gVXRpbC5nZXRNaWRkbGUoYTEsIGEyKTtcclxuICAgICAgICAgICAgICAgICAgICBzb2xUdXJuaW5nUG9pbnRzLnNwbGljZSgxLCAwLCBzdGFydE1pZGRsZVBvaW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9sYXN0IHNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYTMgPSBzb2xUdXJuaW5nUG9pbnRzW3NvbFR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMl07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGE0ID0gc29sVHVybmluZ1BvaW50c1tzb2xUdXJuaW5nUG9pbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRNaWRkbGVQb2ludCA9IFV0aWwuZ2V0TWlkZGxlKGEzLCBhNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc29sVHVybmluZ1BvaW50cy5zcGxpY2Uoc29sVHVybmluZ1BvaW50cy5sZW5ndGggLSAxLCAwLCBlbmRNaWRkbGVQb2ludCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMjogLy9yZW1vdmUgcG9pbnRzXHJcblxyXG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2goc29sdXRpb25zLCBmdW5jdGlvbihzb2x1dGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2xUeXBlID0gc29sdXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvbFR5cGUgPT0gJ3MxJyB8fCBzb2xUeXBlID09ICdzMicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvbFR1cm5pbmdQb2ludHMgPSBzb2x1dGlvblsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29sVHVybmluZ1BvaW50cy5zcGxpY2UoMSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbFR1cm5pbmdQb2ludHMuc3BsaWNlKHNvbFR1cm5pbmdQb2ludHMubGVuZ3RoIC0gMiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIC8qcmVtb3ZlIGNvbGluZWFyIHBvaW50IGZvciBzMSBhcyBpdCBzZWVtcyB0aGF0IG1vcmUgY29saW5lYXIgcG9pbnRzIGRvIG5vdCBsb29rIGdvb2RcclxuICAgICAgICAgICAgICAgICAqIG9uIG9yZ2FuaWMgc29sdXRpb25zID46RCovXHJcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChzb2x1dGlvbnMsIGZ1bmN0aW9uKHNvbHV0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbFR5cGUgPSBzb2x1dGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc29sVHlwZSA9PSAnczEnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb2xUdXJuaW5nUG9pbnRzID0gc29sdXRpb25bMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWR1Y2VkU29sdXRpb24gPSBVdGlsLmNvbGxpbmVhclJlZHVjdGlvbihzb2xUdXJuaW5nUG9pbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29sdXRpb25bMl0gPSByZWR1Y2VkU29sdXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IC8vZW5kIHN3aXRjaFxyXG5cclxuICAgIH1cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvbWFuYWdlci9Db25uZWN0aW9uTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOaXpeW/l+exu1xyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1XHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgTG9nICA9IHtcclxuICAgICAgICBMT0dfTEVWRUxfTk9ORSAgOiAwLFxyXG5cclxuICAgICAgICBMT0dfTEVWRUxfREVCVUcgOiAxLFxyXG5cclxuICAgICAgICBMT0dfTEVWRUxfSU5GTyA6IDIsXHJcblxyXG4gICAgICAgIExPR19MRVZFTF9FUlJPUiA6IDMsXHJcblxyXG4gICAgICAgIGxldmVsIDogdGhpcy5MT0dfTEVWRUxfRVJST1IsXHJcbiAgICAgICAgXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBUaGUgbGVzcyBpbXBvcnRhbnQgb2YgYWxsIG1lc3NhZ2VzXHJcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZFxyXG4gICAgICAgICoqL1xyXG4gICAgICAgIGRlYnVnOiBmdW5jdGlvbiAobWVzc2FnZSl7XHJcbiAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxldmVsIDw9IHRoaXMuTE9HX0xFVkVMX0RFQlVHKXtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvL2luIEZGIGlzIGRlYnVnXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUuZGVidWcgPT0gJ2Z1bmN0aW9uJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2V7Ly9UT0RPOiBpbiBJRSBpcyBsb2dcclxuICAgIC8vICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8obWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIGNvbW1vbmx5IHVzZWQgbG9nIG1lc3NhZ2VcclxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIC0gdGhlIG1lc3NhZ2UgdG8gYmUgbG9nZ2VkXHJcbiAgICAgICAgKiovXHJcbiAgICAgICAgaW5mbyA6IGZ1bmN0aW9uIChtZXNzYWdlKXtcclxuICAgICAgICAgICAgaWYodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMubGV2ZWwgPD0gdGhpcy5MT0dfTEVWRUxfSU5GTyl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBUaGUgd29yc2Uga2luZCBvZiBtZXNzYWdlLiBVc3VhbGx5IGEgY3Jhc2hcclxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIC0gdGhlIG1lc3NhZ2UgdG8gYmUgbG9nZ2VkXHJcbiAgICAgICAgKiovXHJcbiAgICAgICAgZXJyb3IgOiBmdW5jdGlvbiAobWVzc2FnZSl7XHJcbiAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxldmVsIDw9IHRoaXMuTE9HX0xFVkVMX0VSUk9SKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpTdGFydCBncm91cGluZyB0aGUgbG9nIG1lc3NhZ2VzXHJcbiAgICAgICAgICpAcGFyYW0ge1N0cmluZ30gdGl0bGUgLSB0aGUgdGl0bGUgb2YgdGhlIGdyb3VwXHJcbiAgICAgICAgICpAc2VlIDxhIGhyZWY9XCJodHRwOi8vZ2V0ZmlyZWJ1Zy5jb20vbG9nZ2luZ1wiPmh0dHA6Ly9nZXRmaXJlYnVnLmNvbS9sb2dnaW5nPC9hPlxyXG4gICAgICAgICAqKi9cclxuICAgICAgICBncm91cCA6IGZ1bmN0aW9uKHRpdGxlKXtcclxuICAgICAgICAgICAgaWYodGhpcy5sZXZlbCA8PSB0aGlzLkxPR19MRVZFTF9JTkZPKXsgLy9pZ25vcmUgZ3JvdXAgaWYgbGV2ZWwgbm90IGRlYnVnIG9yIGluZm9cclxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyl7ICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvKipJZiB3ZSBkbyBub3QgdGVzdCBmb3IgZ3JvdXAoKSBmdW5jdGlvbiB5b3Ugd2lsbCBnZXQgYW4gZXJyb3IgaW4gT3BlcmFcclxuICAgICAgICAgICAgICAgICAgICAgKmFzIE9wZXJhIGhhcyBpdCdzIG93biBjb25zb2xlLi4ud2hpY2ggZG9lcyBub3QgaGF2ZSBhIGdyb3VwKCkgZnVuY3Rpb24qL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlLmdyb3VwID09PSAnZnVuY3Rpb24nKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5ncm91cCh0aXRsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqRW5kcyBjdXJyZW50IG1lc3NhZ2UgZ3JvdXBpbmcqL1xyXG4gICAgICAgIGdyb3VwRW5kIDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgaWYodGhpcy5sZXZlbCA8PSB0aGlzLkxPR19MRVZFTF9JTkZPKXsgLy9pZ25vcmUgZ3JvdXAgaWYgbGV2ZWwgbm90IGRlYnVnIG9yIGluZm9cclxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqSWYgd2UgZG8gbm90IHRlc3QgZm9yIGdyb3VwRW5kKCkgZnVuY3Rpb24geW91IHdpbGwgZ2V0IGFuIGVycm9yIGluIE9wZXJhXHJcbiAgICAgICAgICAgICAgICAgICAgICphcyBPcGVyYSBoYXMgaXQncyBvd24gY29uc29sZS4uLndoaWNoIGRvZXMgbm90IGhhdmUgYSBncm91cCgpIGZ1bmN0aW9uKi9cclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29uc29sZS5ncm91cEVuZCA9PT0gJ2Z1bmN0aW9uJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvL0xvZy5sZXZlbCA9IExvZy5MT0dfTEVWRUxfREVCVUc7IFxyXG4gICAgTG9nLmxldmVsID0gTG9nLkxPR19MRVZFTF9FUlJPUjsgXHJcbiAgICAvL0xvZy5sZXZlbCA9IExvZy5MT0dfTEVWRUxfRVJST1I7XHJcbiAgICAvL0xvZy5sZXZlbCA9IExvZy5MT0dfTEVWRUxfTk9ORTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gTG9nO1xyXG4gICAgXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9Mb2cuanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDluLjph4/lrprkuYlcclxuICovXHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gXHR7XHJcblx0XHRFTEVNRU5UX1RZUEU6IFwiZWxlbWVudFR5cGVcIixcclxuXHRcdE1PREU6IFwibW9kZVwiLFxyXG5cdFx0QkFDS0dST1VORDogXCJiYWNrZ3JvdWRcIixcclxuXHRcdE9QVElPTlM6IFwib3B0aW9uc1wiLFxyXG5cdFx0VVNFUkRBVEE6IFwidXNlckRhdGFcIixcclxuXHRcdElEOiBcImlkXCIsXHJcblx0XHRTVEFSVF9JRDogXCJzdGFydE5vZGVJZFwiLFxyXG5cdFx0RU5EX0lEOiBcImVuZE5vZGVJZFwiLFxyXG5cdFx0QUxBUk06IFwiQWxhcm1cIixcclxuXHRcdFJFTEFUSU9OSUQ6XCJyZWxhdGlvbklkXCIsXHJcblx0XHRSRUxBVElPTl9JTUFHRTpcInJlbGF0aW9uSW1hZ2VcIixcclxuXHRcdEdST1VQOiBcIkdyb3VwXCIsXHJcblx0XHRDT05ORUNUSU9OOiBcImNvbm5lY3Rpb25cIixcclxuXHRcdENISUxEUzogXCJjaGlsZHNcIixcclxuXHRcdFRSRUVfUk9PVDogXCJ0cmVlUm9vdFwiLFxyXG5cdFx0RE9DS0VSUzpcIm9wdGlvbnMuZG9ja2Vyc1wiLFxyXG5cdFx0U1RZTEVfTElORVRZUEU6XCJzdHlsZS5saW5lVHlwZVwiLFxyXG5cdFx0TElORU9QRVJBVElPTklDT046XCJMaW5lT3BlcmF0aW9uSWNvblwiLFxyXG5cdFx0REVMOlwiREVMXCIsXHJcblx0XHRMSU5LOlwic3RyYWlnaHRcIixcclxuXHRcdEZPTEQ6XCJqYWdnZWRcIixcclxuXHRcdENVUlZFOlwiY3VydmVcIlxyXG5cdH07XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvdXRpbC9GbG93Q29uc3RhbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogRmxvd+W3peWFt+exu1xyXG4gKiBAYXV0aG9yIHdhbmcueGlhb2h1OVxyXG4gKi9cclxuXHJcbiAgICB2YXIgQ29uc3RhbnRzID0gcmVxdWlyZShcIi4vRmxvd0NvbnN0YW50cy5qc1wiKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBHcm91cE5vZGUgPSByZXF1aXJlKFwiLi4vbm9kZS9Hcm91cE5vZGUuanNcIik7XHJcbiAgICB2YXIgUmVjdCA9IHJlcXVpcmUoXCIuLi9ub2RlL1JlY3QuanNcIik7XHJcbiAgICB2YXIgQ2lyY2xlID0gcmVxdWlyZShcIi4uL25vZGUvQ2lyY2xlLmpzXCIpO1xyXG4gICAgdmFyIEltYWdlID0gcmVxdWlyZShcIi4uL25vZGUvSW1hZ2UuanNcIik7XHJcbiAgICB2YXIgVGV4dCA9IHJlcXVpcmUoXCIuLi9ub2RlL1RleHQuanNcIik7XHJcbiAgICB2YXIgU2VjdG9yID0gcmVxdWlyZShcIi4uL25vZGUvU2VjdG9yLmpzXCIpO1xyXG4gICAgdmFyIFJpbmcgPSByZXF1aXJlKFwiLi4vbm9kZS9SaW5nLmpzXCIpO1xyXG4gICAgdmFyIEVsbGlwc2UgPSByZXF1aXJlKFwiLi4vbm9kZS9FbGxpcHNlLmpzXCIpO1xyXG4gICAgdmFyIEhlYXJ0ID0gcmVxdWlyZShcIi4uL25vZGUvSGVhcnQuanNcIik7XHJcbiAgICB2YXIgRHJvcGxldCA9IHJlcXVpcmUoXCIuLi9ub2RlL0Ryb3BsZXQuanNcIik7XHJcbiAgICB2YXIgUm9zZSA9IHJlcXVpcmUoXCIuLi9ub2RlL1Jvc2UuanNcIik7XHJcbiAgICB2YXIgSXNvZ29uID0gcmVxdWlyZShcIi4uL25vZGUvSXNvZ29uLmpzXCIpO1xyXG4gICAgdmFyIFBvbHlnb24gPSByZXF1aXJlKFwiLi4vbm9kZS9Qb2x5Z29uLmpzXCIpO1xyXG4gICAgdmFyIExpbmUgPSByZXF1aXJlKFwiLi4vbm9kZS9MaW5lLmpzXCIpO1xyXG4gICAgdmFyIFBvbHlsaW5lID0gcmVxdWlyZShcIi4uL25vZGUvUG9seWxpbmUuanNcIik7XHJcbiAgICB2YXIgQmV6aWVyQ3VydmUgPSByZXF1aXJlKFwiLi4vbm9kZS9CZXppZXJDdXJ2ZS5qc1wiKTtcclxuICAgIHZhciBBcmMgPSByZXF1aXJlKFwiLi4vbm9kZS9BcmMuanNcIik7XHJcbiAgICB2YXIgU3RhciA9IHJlcXVpcmUoXCIuLi9ub2RlL1N0YXIuanNcIik7XHJcbiAgICB2YXIgVHJvY2hvaWQgPSByZXF1aXJlKFwiLi4vbm9kZS9Ucm9jaG9pZC5qc1wiKTtcclxuICAgIHZhciBQYXRoID0gcmVxdWlyZShcIi4uL25vZGUvUGF0aC5qc1wiKTtcclxuICAgIHZhciBJY29uQnV0dG9uID0gcmVxdWlyZShcIi4uL25vZGUvSWNvbkJ1dHRvblwiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICB2YXIgZmxvd0xpbmsgPSByZXF1aXJlKFwiLi4vbGluay9mbG93TGlua1wiKTtcclxuICAgIC8qKlxyXG4gICAgICog5qC55o2u57uT54K55pWw57uEIOWvvOWHukpTT07moLzlvI/nmoTmlbDmja5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtb2RlbCDmgLvnmoTmqKHlnotcclxuICAgICAqIEByZXR1cm4ge0pTT059IEpTT07moLzlvI/nmoTmlbDmja5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdG9Kc29uKG1vZGVsLCBncm91cCkge1xyXG4gICAgICAgIHZhciBqc29uQXJyID0gW107XHJcbiAgICAgICAgZ3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLm1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICAvL+WmguaenOaYr+e7hOeahOivnVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBHcm91cE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRBcnIgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUubW9kZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkQXJyLnB1c2goY2hpbGROb2RlLm1vZGVsLm9wdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLm1vZGVsLnNldChDb25zdGFudHMuQ0hJTERTLCBjaGlsZEFycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVmcmVzaE1vZGVsKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBqc29uQXJyLnB1c2gobm9kZS5tb2RlbC5vcHRpb24pO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgfSlcclxuICAgICAgICBtb2RlbC5zZXQoQ29uc3RhbnRzLkNISUxEUywganNvbkFycik7XHJcbiAgICAgICAgcmV0dXJuIG1vZGVsLm9wdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNriBKU09OIOeUn+aIkOiKgueCuVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBmaXNoVG9wb2Zsb3cgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBqc29uICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tSnNvbihmaXNoVG9wb2Zsb3csIGdyb3VwLCBjaGlsZFNoYXBlcywgaXNDaGlsZCwgbGF5b3V0Um9vdE5vZGUpIHtcclxuICAgICAgICB2YXIgY29ubmVjdG9ycyA9IFtdO1xyXG4gICAgICAgIC8vIDEu5YWI5Yib5bu66IqC54K5ICDpgY3ljoblvaLnirYg6I635Y+W5qih5Z6LXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZFNoYXBlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBjaGlsZFNoYXBlc1tpXTtcclxuICAgICAgICAgICAgaWYgKHNoYXBlLmVsZW1lbnRUeXBlID09PSBDb25zdGFudHMuQ09OTkVDVElPTikge1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9ycy5wdXNoKHNoYXBlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZS5lbGVtZW50VHlwZSA9PT0gQ29uc3RhbnRzLkFMQVJNKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRpb25Ob2RlID0gZmluZE5vZGVCeUlkKGZpc2hUb3BvZmxvdy5ncm91cCwgc2hhcGUucmVsYXRpb25JZCk7XHJcbiAgICAgICAgICAgICAgICBmaXNoVG9wb2Zsb3cuY3JlYXRlQWxhcm0ocmVsYXRpb25Ob2RlLCBzaGFwZS5vcHRpb25zKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZS5lbGVtZW50VHlwZSA9PT0gQ29uc3RhbnRzLkdST1VQKSB7XHJcbiAgICAgICAgICAgICAgICBzaGFwZS5vcHRpb25zLmlkID0gc2hhcGUuaWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3JlYXRlZEdyb3VwID0gZmlzaFRvcG9mbG93LmNyZWF0ZU5vZGUoc2hhcGUuZWxlbWVudFR5cGUsIHNoYXBlLm9wdGlvbnMsIHNoYXBlLnVzZXJEYXRhKTtcclxuICAgICAgICAgICAgICAgIGZyb21Kc29uKGZpc2hUb3BvZmxvdywgY3JlYXRlZEdyb3VwLCBzaGFwZS5jaGlsZHMsIHRydWUsIGxheW91dFJvb3ROb2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmaXNoVG9wb2Zsb3cuYWRkTm9kZShjcmVhdGVkR3JvdXApO1xyXG5cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyDmoLnmja5vcHRpb25z5Yib5bu66IqC54K5XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvZmxvdy5jcmVhdGVOb2RlKHNoYXBlLmVsZW1lbnRUeXBlLCBzaGFwZS5vcHRpb25zLCBzaGFwZS51c2VyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmFkZChub2RlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlzaFRvcG9mbG93LmFkZE5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlLm9wdGlvbnMubGF5b3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlLm9wdGlvbnMubGF5b3V0LmxheW91dCA9PT0gQ29uc3RhbnRzLlRSRUVfUk9PVCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUZvckxheW91dCA9IGZpbmROb2RlQnlJZChncm91cCwgc2hhcGUuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dFJvb3ROb2RlLnB1c2gobm9kZUZvckxheW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBmaXNoVG9wby5sYXlvdXROb2RlKFwidHJlZVwiLHtcIm5vZGVcIjpub2RlfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMi4g5YaN5Yib5bu657q/XHJcbiAgICAgICAgenJVdGlsLmVhY2goY29ubmVjdG9ycywgZnVuY3Rpb24gKGxpbmUpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IGZpbmROb2RlQnlJZChncm91cCwgbGluZS5zdGFydE5vZGVJZCk7XHJcbiAgICAgICAgICAgIHZhciBlbmROb2RlID0gZmluZE5vZGVCeUlkKGdyb3VwLCBsaW5lLmVuZE5vZGVJZCk7XHJcbiAgICAgICAgICAgIGlmIChzdGFydE5vZGUgJiYgZW5kTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpbmsgPSBmaXNoVG9wb2Zsb3cuY3JlYXRlTGluayhzdGFydE5vZGUsIGVuZE5vZGUsIGxpbmUub3B0aW9ucywgbGluZS51c2VyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmFkZChsaW5rKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlzaFRvcG9mbG93LmFkZE5vZGUobGluayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoaXNMaW5rID0gZmxvd0xpbmsuTGluay5jcmVhdGVCeVBvaW50KGxpbmUub3B0aW9ucyxsaW5lLnVzZXJEYXRhKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0NoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKHRoaXNMaW5rKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlzaFRvcG9mbG93LmFkZE5vZGUodGhpc0xpbmspO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOagueaNrmlk5ZyoZ3JvdXDkuK3mn6Xmib5cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZ3JvdXAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbm9kZUlkIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZmluZE5vZGVCeUlkKGdyb3VwLCBub2RlSWQpIHtcclxuICAgICAgICB2YXIgcmV0Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgZ3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmlkID09PSBub2RlSWQpIHtcclxuICAgICAgICAgICAgICAgIHJldE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gcmV0Tm9kZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgY2FudmFzIHdoaWNoIGhhcyBhbGwgdGhpbmcgcmVuZGVyZWRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRSZW5kZXJlZENhbnZhcyh6ciwgb3B0cykge1xyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG4gICAgICAgIG9wdHMucGl4ZWxSYXRpbyA9IG9wdHMucGl4ZWxSYXRpbyB8fCAxO1xyXG4gICAgICAgIG9wdHMuYmFja2dyb3VuZENvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3IgfHxcclxuICAgICAgICAgICAgXCIjRkZGRkZGXCI7XHJcbiAgICAgICAgdmFyIGxpc3QgPSB6ci5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCk7XHJcbiAgICAgICAgLy8gU3RvcCBhbmltYXRpb25zXHJcbiAgICAgICAgenJVdGlsLmVhY2gobGlzdCwgZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgIGVsLnN0b3BBbmltYXRpb24odHJ1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHpyLnBhaW50ZXIuZ2V0UmVuZGVyZWRDYW52YXMob3B0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9EYXRhVVJMKHpyLCBvcHRzKSB7XHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XHJcbiAgICAgICAgdmFyIHVybCA9IGdldFJlbmRlcmVkQ2FudmFzKHpyLCBvcHRzKS50b0RhdGFVUkwoXHJcbiAgICAgICAgICAgICdpbWFnZS8nICsgKG9wdHMgJiYgb3B0cy50eXBlIHx8ICdwbmcnKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIHVybDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0cnVuY1Bvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIHggPSBwYXJzZUludChwb3NpdGlvblswXSwgMTApO1xyXG4gICAgICAgIHZhciB5ID0gcGFyc2VJbnQocG9zaXRpb25bMV0sIDEwKTtcclxuICAgICAgICBpZiAoeCA8IDApIHtcclxuICAgICAgICAgICAgeCA9IDBcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHkgPCAwKSB7XHJcbiAgICAgICAgICAgIHkgPSAwXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJGbG93Tm9kZShmbG93Tm9kZSkge1xyXG4gICAgICAgIHZhciBub2RlQ3RvcnMgPSB7XHJcbiAgICAgICAgICAgIFJlY3Q6IFJlY3QsXHJcbiAgICAgICAgICAgIENpcmNsZTogQ2lyY2xlLFxyXG4gICAgICAgICAgICBJbWFnZTogSW1hZ2UsXHJcbiAgICAgICAgICAgIFRleHQ6IFRleHQsXHJcbiAgICAgICAgICAgIFNlY3RvcjogU2VjdG9yLFxyXG4gICAgICAgICAgICBSaW5nOiBSaW5nLFxyXG4gICAgICAgICAgICBFbGxpcHNlOiBFbGxpcHNlLFxyXG4gICAgICAgICAgICBIZWFydDogSGVhcnQsXHJcbiAgICAgICAgICAgIERyb3BsZXQ6IERyb3BsZXQsXHJcbiAgICAgICAgICAgIFJvc2U6IFJvc2UsXHJcbiAgICAgICAgICAgIElzb2dvbjogSXNvZ29uLFxyXG4gICAgICAgICAgICBQb2x5Z29uOiBQb2x5Z29uLFxyXG4gICAgICAgICAgICBMaW5lOiBMaW5lLFxyXG4gICAgICAgICAgICBQb2x5bGluZTogUG9seWxpbmUsXHJcbiAgICAgICAgICAgIEJlemllckN1cnZlOiBCZXppZXJDdXJ2ZSxcclxuICAgICAgICAgICAgQXJjOiBBcmMsXHJcbiAgICAgICAgICAgIFN0YXI6IFN0YXIsXHJcbiAgICAgICAgICAgIFRyb2Nob2lkOiBUcm9jaG9pZCxcclxuICAgICAgICAgICAgUGF0aDogUGF0aCxcclxuICAgICAgICAgICAgR3JvdXA6IEdyb3VwTm9kZSxcclxuICAgICAgICAgICAgSWNvbkJ1dHRvbjogSWNvbkJ1dHRvblxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIG5vZGVDdG9ycykge1xyXG4gICAgICAgICAgICBmbG93Tm9kZVtuYW1lXSA9IG5vZGVDdG9yc1tuYW1lXVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmxvd05vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWxpemUgY3NzIGxpa2VkIGFycmF5IGNvbmZpZ3VyYXRpb25cclxuICAgICAqIGUuZy5cclxuICAgICAqICAzID0+IFszLCAzLCAzLCAzXVxyXG4gICAgICogIFs0LCAyXSA9PiBbNCwgMiwgNCwgMl1cclxuICAgICAqICBbNCwgMywgMl0gPT4gWzQsIDMsIDIsIDNdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gdmFsXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUNzc0FycmF5KHZhbCkge1xyXG4gICAgICAgIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xyXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbCkgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbdmFsLCB2YWwsIHZhbCwgdmFsXTtcclxuICAgICAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xyXG4gICAgICAgICAgICAvLyB2ZXJ0aWNhbCB8IGhvcml6b250YWxcclxuICAgICAgICAgICAgcmV0dXJuIFt2YWxbMF0sIHZhbFsxXSwgdmFsWzBdLCB2YWxbMV1dO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobGVuID09PSAzKSB7XHJcbiAgICAgICAgICAgIC8vIHRvcCB8IGhvcml6b250YWwgfCBib3R0b21cclxuICAgICAgICAgICAgcmV0dXJuIFt2YWxbMF0sIHZhbFsxXSwgdmFsWzJdLCB2YWxbMV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF90cmltKHN0cikge1xyXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VQZXJjZW50KHBlcmNlbnQsIGFsbCkge1xyXG4gICAgICAgIHN3aXRjaCAocGVyY2VudCkge1xyXG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxyXG4gICAgICAgICAgICAgICAgcGVyY2VudCA9ICc1MCUnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgICAgICAgcGVyY2VudCA9ICcwJSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgICAgcGVyY2VudCA9ICcxMDAlJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHBlcmNlbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmIChfdHJpbShwZXJjZW50KS5tYXRjaCgvJSQvKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocGVyY2VudCkgLyAxMDAgKiBhbGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHBlcmNlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBlcmNlbnQgPT0gbnVsbCA/IE5hTiA6ICtwZXJjZW50O1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cHBlckNhc2VGaXJzdD1mYWxzZV1cclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gc3RyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0ciwgdXBwZXJDYXNlRmlyc3QpIHtcclxuICAgICAgICBzdHIgPSAoc3RyIHx8ICcnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oLikvZywgZnVuY3Rpb24gKG1hdGNoLCBncm91cDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwMS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAodXBwZXJDYXNlRmlyc3QgJiYgc3RyKSB7XHJcbiAgICAgICAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZSBwcm9wZXJ0eSBzdG9yYWdlIHRvIGFueSBob3N0IG9iamVjdC5cclxuICAgICAqIE5vdGljZTogU2VyaWFsaXphdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICpcclxuICAgICAqIEZvciBleGFtcGxlOlxyXG4gICAgICogdmFyIGdldCA9IG1vZGVsVWl0bC5tYWtlR2V0dGVyKCk7XHJcbiAgICAgKlxyXG4gICAgICogZnVuY3Rpb24gc29tZShob3N0T2JqKSB7XHJcbiAgICAgKiAgICAgIGdldChob3N0T2JqKS5fc29tZVByb3BlcnR5ID0gMTIxMjtcclxuICAgICAqICAgICAgLi4uXHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XHJcbiAgICAgKi9cclxuICAgIHZhciBtYWtlR2V0dGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSAnXFwwX190b3BvX3Byb3BfZ2V0dGVyXycgKyBpbmRleCsrO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGhvc3RPYmopIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBob3N0T2JqW2tleV0gfHwgKGhvc3RPYmpba2V5XSA9IHt9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgfSkoKTtcclxuICAgIHZhciBlbmNvZGVIVE1MID0gZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcoc291cmNlKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvJy9nLCAnJiMzOTsnKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFRQTF9WQVJfQUxJQVMgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnXTtcclxuXHJcbiAgICB2YXIgd3JhcFZhciA9IGZ1bmN0aW9uICh2YXJOYW1lLCBzZXJpZXNJZHgpIHtcclxuICAgICAgICByZXR1cm4gJ3snICsgdmFyTmFtZSArIChzZXJpZXNJZHggPT0gbnVsbCA/ICcnIDogc2VyaWVzSWR4KSArICd9JztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRlbXBsYXRlIGZvcm1hdHRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRwbFxyXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0PnxPYmplY3R9IHBhcmFtc0xpc3RcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuY29kZT1mYWxzZV1cclxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0VHBsKHRwbCwgcGFyYW1zTGlzdCwgZW5jb2RlKSB7XHJcbiAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShwYXJhbXNMaXN0KSkge1xyXG4gICAgICAgICAgICBwYXJhbXNMaXN0ID0gW3BhcmFtc0xpc3RdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2VyaWVzTGVuID0gcGFyYW1zTGlzdC5sZW5ndGg7XHJcbiAgICAgICAgaWYgKCFzZXJpZXNMZW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyICR2YXJzID0gcGFyYW1zTGlzdFswXS4kdmFycyB8fCBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR2YXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhbGlhcyA9IFRQTF9WQVJfQUxJQVNbaV07XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSB3cmFwVmFyKGFsaWFzLCAwKTtcclxuICAgICAgICAgICAgdHBsID0gdHBsLnJlcGxhY2Uod3JhcFZhcihhbGlhcyksIGVuY29kZSA/IGVuY29kZUhUTUwodmFsKSA6IHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIHNlcmllc0lkeCA9IDA7IHNlcmllc0lkeCA8IHNlcmllc0xlbjsgc2VyaWVzSWR4KyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCAkdmFycy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHBhcmFtc0xpc3Rbc2VyaWVzSWR4XVskdmFyc1trXV07XHJcbiAgICAgICAgICAgICAgICB0cGwgPSB0cGwucmVwbGFjZShcclxuICAgICAgICAgICAgICAgICAgICB3cmFwVmFyKFRQTF9WQVJfQUxJQVNba10sIHNlcmllc0lkeCksXHJcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlID8gZW5jb2RlSFRNTChyZXQpIDogcmV0XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHBsO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICB0b0pzb246IHRvSnNvbixcclxuICAgICAgICBmcm9tSnNvbjogZnJvbUpzb24sXHJcbiAgICAgICAgdG9EYXRhVVJMOiB0b0RhdGFVUkwsXHJcbiAgICAgICAgdHJ1bmNQb3NpdGlvbjogdHJ1bmNQb3NpdGlvbixcclxuICAgICAgICByZWdpc3RlckZsb3dOb2RlOiByZWdpc3RlckZsb3dOb2RlLFxyXG4gICAgICAgIG5vcm1hbGl6ZUNzc0FycmF5OiBub3JtYWxpemVDc3NBcnJheSxcclxuICAgICAgICBwYXJzZVBlcmNlbnQ6IHBhcnNlUGVyY2VudCxcclxuICAgICAgICB0b0NhbWVsQ2FzZTogdG9DYW1lbENhc2UsXHJcbiAgICAgICAgbWFrZUdldHRlcjogbWFrZUdldHRlcixcclxuICAgICAgICBmb3JtYXRUcGw6IGZvcm1hdFRwbCxcclxuICAgICAgICBmaW5kTm9kZUJ5SWQ6IGZpbmROb2RlQnlJZFxyXG4gICAgfTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL3V0aWwvRmxvd1V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDnu4TvvIwg57uE5Lit5YWD57Sg55qE5Z2Q5qCH6YO95piv55u45a+55LqO6L+Z5Liq57uE55qEPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuR3JvdXBOb2RlXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciBncm91cDEgPSBuZXcgbm9kZS5Hcm91cCh7XHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbNjAsNTBdXHJcbiAqICAgICAgIH0pO1xyXG4gKlxyXG4gKiAgICAgICB2YXIgcmVjdDEgPSBuZXcgbm9kZS5SZWN0KHtcclxuICogICAgICAgICAgIHNoYXBlOnt3aWR0aDoxMjAsaGVpZ2h0OjMwfSxcclxuICogICAgICAgICAgIHN0eWxlOnt0ZXh0Olwi5qCH6aKYXCIsIGZpbGw6XCIjRkZCOTBGXCIsc3Ryb2tlOlwiI2JiYmJiYlwifSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOlswLDBdLFxyXG4gKiAgICAgICAgICAgc2VsZWN0YWJsZTpmYWxzZVxyXG4gKiAgICAgICB9KTtcclxuICpcclxuICogICAgICAgdmFyIHJlY3QyID0gbmV3IG5vZGUuUmVjdCh7XHJcbiAqICAgICAgICAgICBzaGFwZTp7d2lkdGg6MTIwLGhlaWdodDo2MH0sXHJcbiAqICAgICAgICAgICBzdHlsZTp7dGV4dDpcIuWGheWuuVwiLCBmaWxsOlwiI0ZGRkZGRlwiLHN0cm9rZTpcIiNiYmJiYmJcIn0sXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbMCwzMF0sXHJcbiAqICAgICAgICAgICBzZWxlY3RhYmxlOmZhbHNlXHJcbiAqICAgICAgIH0pO1xyXG4gKlxyXG4gKiAgICAgICBncm91cDEuYWRkKHJlY3QxKTtcclxuICogICAgICAgZ3JvdXAxLmFkZChyZWN0Mik7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChncm91cDEpO1xyXG4gKi9cclxuXHJcblxyXG5cclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcycpO1xyXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL2dyYXBoaWMuanNcIik7XHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1wiKTtcclxuICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICB2YXIgZmxvd05vZGUgPXJlcXVpcmUoJy4vZmxvd05vZGUnKTtcclxuXHJcbiAgICBmdW5jdGlvbiBHcm91cE5vZGUob3B0cykge1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBmbG93Tm9kZS5nZW5Nb2RlbChcIkdyb3VwTm9kZVwiLCBvcHRzKTtcclxuICAgICAgICBncmFwaGljLkdyb3VwLmNhbGwodGhpcywgb3B0cyk7XHJcblxyXG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiA1LFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1LFxyXG4gICAgICAgICAgICAgICAgcjogNVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogJ3JnYmEoMCwwLDAsMCknLC8vJyNmOWY5ZjknLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAncmdiYSgwLDAsMCwwKScvLycjYmJiYmJiJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogWzAsIDBdXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdHMsIHRydWUpO1xyXG4gICAgICAgIC8v5Ye95pWw5peg5rOVY2xvbmUg5Y6f5Z6LY2xvbmXkuI3kuIpcclxuICAgICAgICB0aGlzLm9wdGlvbnMubGF5b3V0ID0gb3B0cy5sYXlvdXQ7XHJcbiAgICAgICAgdGhpcy5tYXggPSBbMTAyNCwgOTYwXTtcclxuICAgICAgICB0aGlzLnJlbmRlcih0aGlzLm9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgR3JvdXBOb2RlLlJFQ1RfTkFNRSA9IFwiR1JPVVBfUkVDVF9OQU1FXCI7XHJcbiAgICBHcm91cE5vZGUucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBHcm91cE5vZGUsXHJcbiAgICAgICAgdHlwZTogXCJHcm91cE5vZGVcIixcclxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IG1vZGVsLnNoYXBlLFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IG1vZGVsLnN0eWxlLFxyXG4gICAgICAgICAgICAgICAgLy9zaWxlbnQ6dHJ1ZSwgLy/liqDkuIrlkI4g5ouW5YqoIOe7hOS4reayoeacieWtkOWFg+e0oOeahOWcsOaWuSDml6Dms5XmiYvliqjkuoZcclxuICAgICAgICAgICAgICAgIHoyOi0xXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZWN0Lm5hbWUgPSBHcm91cE5vZGUuUkVDVF9OQU1FO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChyZWN0KTtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG1vZGVsLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLm1lcmdlZEltYWdlID0gbW9kZWwubWVyZ2VkSW1hZ2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWN0Q29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSB1dGlsLmdldFJlY3QodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZWN0LmJvdW5kaW5nUmVjdC5jb250YWluKHgsIHkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOmBjeWOhue7hOS4reavj+S4gOS4quWtkOiKgueCuVxyXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYiDlm57osIPlh73mlbBjYlxyXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gY29udGV4dCAgIOS4iuS4i+aWh2NvbnRleHRcclxuICAgICAgICAgKi9cclxuICAgICAgICBlYWNoOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5hbWUgIT0gR3JvdXBOb2RlLlJFQ1RfTkFNRSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8g6K6+572uIGdyb3Vw5Lit5qGG5b2i5aSn5bCP5Li6IGdyb3Vw55qE5YyF5Zu05ZKMXHJcbiAgICAgICAgd2lsbFJlbmRlcjpmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF5b3V0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldExheW91dCh0aGlzLm9wdGlvbnMubGF5b3V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNldFByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldExheW91dDogZnVuY3Rpb24oTGF5b3V0KSB7XHJcbiAgICAgICAgICAgIExheW91dC5ydW4odGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0UmVjdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAgICAgLy/liJvlu7rmnIDlsI/ljIXlm7Tnm5LomZrnur9cclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICBwb2ludHNbMF0gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIC1ib3VuZGluZ1JlY3QuaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgICAgIHBvaW50c1sxXSA9IFtib3VuZGluZ1JlY3Qud2lkdGggLyAyLCAtYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG4gICAgICAgICAgICBwb2ludHNbMl0gPSBbYm91bmRpbmdSZWN0LndpZHRoIC8gMiwgYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG4gICAgICAgICAgICBwb2ludHNbM10gPSBbLWJvdW5kaW5nUmVjdC53aWR0aCAvIDIsIGJvdW5kaW5nUmVjdC5oZWlnaHQgLyAyXTtcclxuICAgICAgICAgICAgcG9pbnRzWzRdID0gWy1ib3VuZGluZ1JlY3Qud2lkdGggLyAyLCAtYm91bmRpbmdSZWN0LmhlaWdodCAvIDJdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJvdW5kUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QodGhpcy5wb3NpdGlvblswXSxcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0sXHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3Qud2lkdGgsIGJvdW5kaW5nUmVjdC5oZWlnaHQpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogdGhpcy5wb3NpdGlvblswXSArIGJvdW5kaW5nUmVjdC53aWR0aCAvIDIsXHJcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnBvc2l0aW9uWzFdICsgYm91bmRpbmdSZWN0LmhlaWdodCAvIDIsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ1JlY3QuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ1JlY3Q6IGJvdW5kUmVjdFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5ouW5ou957uE5YaF6IqC54K555qE5pe25YCZ77yM5Yqo5oCB5pu05pS56IOM5pmvcmVjdOeahOWkp+Wwj1xyXG4gICAgICAgICAqIEBwYXJhbSBub2RlTWVzc2FnZSDmi5bmi73nmoTnu4TlhoXoioLngrnnmoTkv6Hmga9cclxuICAgICAgICAgKi9cclxuICAgICAgICBtb2RpZnlHcm91cFJlY3Q6IGZ1bmN0aW9uIChub2RlTWVzc2FnZSkge1xyXG4gICAgICAgICAgICAvLzEu6YeN572u6IOM5pmvcmVjdCDnmoTplb/lrr1cclxuICAgICAgICAgICAgdmFyIG1pbkxlbmd0aCA9IHRoaXMub3B0aW9ucy5zaGFwZS5yO1xyXG4gICAgICAgICAgICB0aGlzLnNldFByb3BlcnRpZXMoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbWluTGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogbWluTGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIHI6IG1pbkxlbmd0aFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5jaGlsZE9mTmFtZShHcm91cE5vZGUuUkVDVF9OQU1FKTtcclxuICAgICAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGJvdW5kaW5nUmVjdC53aWR0aDtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGJvdW5kaW5nUmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciByeCA9IHJlY3QucG9zaXRpb25bMF0sLy9yZWN0LnNoYXBlLngsXHJcbiAgICAgICAgICAgICAgICByeSA9IHJlY3QucG9zaXRpb25bMV07Ly9yZWN0LnNoYXBlLnk7XHJcbiAgICAgICAgICAgIC8vMi7lj5Zncm91cOS4reaJgOacieiKgueCueacgOmdoOS4iui+ueWSjOacgOmrmOW3pui+ueeahOWAvO+8jOS4jeWMheaLrOiDjOaZr3JlY3TnmoTlgLxcclxuICAgICAgICAgICAgdmFyIG1pblggPSB0aGlzLl9jaGlsZHJlblsxXS5wb3NpdGlvblswXSxcclxuICAgICAgICAgICAgICAgIG1pblkgPSB0aGlzLl9jaGlsZHJlblsxXS5wb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgdmFyIG1heFggPSB0aGlzLl9jaGlsZHJlblsxXS5wb3NpdGlvblswXSxcclxuICAgICAgICAgICAgICAgIG1heFkgPSB0aGlzLl9jaGlsZHJlblsxXS5wb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgdmFyIG5vd05vZGVQb3NpdGlvbiA9IHpyVXRpbC5jbG9uZShub2RlTWVzc2FnZS5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbltpXSBpbnN0YW5jZW9mIENvbm5lY3RvciB8fCB0aGlzLl9jaGlsZHJlbltpXS5pc0ljb24gPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWluWCA+IHRoaXMuX2NoaWxkcmVuW2ldLnBvc2l0aW9uWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblggPSB0aGlzLl9jaGlsZHJlbltpXS5wb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heFggPCB0aGlzLl9jaGlsZHJlbltpXS5wb3NpdGlvblswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhYID0gdGhpcy5fY2hpbGRyZW5baV0ucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5ZID4gdGhpcy5fY2hpbGRyZW5baV0ucG9zaXRpb25bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluWSA9IHRoaXMuX2NoaWxkcmVuW2ldLnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF4WSA8IHRoaXMuX2NoaWxkcmVuW2ldLnBvc2l0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFkgPSB0aGlzLl9jaGlsZHJlbltpXS5wb3NpdGlvblsxXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIDMuIOWuveW6puWkp+S6juacgOWkp+WuveW6plxyXG4gICAgICAgICAgICBpZiAod2lkdGggPiB0aGlzLm1heFswXSkge1xyXG4gICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLm1heFswXSAtIDI7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZU1lc3NhZ2UucG9zaXRpb25bMF0gPiBtaW5YKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm93Tm9kZVBvc2l0aW9uWzBdID0gbWluWCArIHRoaXMubWF4WzBdIC0gbm9kZU1lc3NhZ2Uud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vd05vZGVQb3NpdGlvblswXSA9IG1heFggLSB0aGlzLm1heFswXSArIG5vZGVNZXNzYWdlLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy/np7vliqjoioLngrnmlLnlj5hncm91cOS4reiDjOaZr3JlY3TnmoR45L2N572u77yM5LiN6LaF6L+H5pyA5bCP55qE5YC8XHJcbiAgICAgICAgICAgICAgICByeCA9IHJlY3QucG9zaXRpb25bMF0gKyBub2RlTWVzc2FnZS5wb3NpdGlvblswXTtcclxuICAgICAgICAgICAgICAgIGlmIChyeCA+IG1pblgpIHtcclxuICAgICAgICAgICAgICAgICAgICByeCA9IG1pblg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub3dOb2RlUG9zaXRpb25bMF0gPSBub2RlTWVzc2FnZS5tb3ZlUG9zaXRpb25bMF0gKyBub2RlTWVzc2FnZS5tb3ZlWDtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlTWVzc2FnZS5wb3NpdGlvblswXSA+IG1pblgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm93Tm9kZVBvc2l0aW9uWzBdID4gbWluWCArIHRoaXMubWF4WzBdIC0gbm9kZU1lc3NhZ2Uud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm93Tm9kZVBvc2l0aW9uWzBdID0gbWluWCArIHRoaXMubWF4WzBdIC0gbm9kZU1lc3NhZ2Uud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm93Tm9kZVBvc2l0aW9uWzBdIDwgbWF4WCAtIHRoaXMubWF4WzBdICsgbm9kZU1lc3NhZ2Uud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm93Tm9kZVBvc2l0aW9uWzBdID0gbWF4WCAtIHRoaXMubWF4WzBdICsgbm9kZU1lc3NhZ2Uud2lkdGhcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhlaWdodCA+IHRoaXMubWF4WzFdKSB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLm1heFsxXSAtIDI7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZU1lc3NhZ2UucG9zaXRpb25bMV0gPiBtaW5ZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm93Tm9kZVBvc2l0aW9uWzFdID0gbWluWSArIHRoaXMubWF4WzFdIC0gbm9kZU1lc3NhZ2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub3dOb2RlUG9zaXRpb25bMV0gPSBtYXhZIC0gdGhpcy5tYXhbMV0gKyBub2RlTWVzc2FnZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL+enu+WKqOiKgueCueaUueWPmGdyb3Vw5Lit6IOM5pmvcmVjdOeahHnkvY3nva7vvIzkuI3otoXov4fmnIDlsI/nmoTlgLxcclxuICAgICAgICAgICAgICAgIHJ5ID0gcmVjdC5wb3NpdGlvblsxXSArIChub2RlTWVzc2FnZS5wb3NpdGlvblsxXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocnkgPiBtaW5ZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnkgPSBtaW5ZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbm93Tm9kZVBvc2l0aW9uWzFdID0gbm9kZU1lc3NhZ2UubW92ZVBvc2l0aW9uWzFdICsgbm9kZU1lc3NhZ2UubW92ZVk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZU1lc3NhZ2UucG9zaXRpb25bMV0gPiBtaW5ZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vd05vZGVQb3NpdGlvblsxXSA+IG1pblkgKyB0aGlzLm1heFsxXSAtIG5vZGVNZXNzYWdlLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3dOb2RlUG9zaXRpb25bMV0gPSBtaW5ZICsgdGhpcy5tYXhbMV0gLSBub2RlTWVzc2FnZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm93Tm9kZVBvc2l0aW9uWzFdIDwgbWF4WSAtIHRoaXMubWF4WzFdICsgbm9kZU1lc3NhZ2UuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vd05vZGVQb3NpdGlvblsxXSA9IG1heFkgLSB0aGlzLm1heFsxXSArIG5vZGVNZXNzYWdlLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZU1lc3NhZ2Uubm9kZS5hbGFybSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0FsYXJtUG9zaXRpb24gPSBbbm93Tm9kZVBvc2l0aW9uWzBdICsgbm9kZU1lc3NhZ2Uubm9kZS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAtIChub2RlTWVzc2FnZS5ub2RlLmFsYXJtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAtIDYpLCBub3dOb2RlUG9zaXRpb25bMV0gLSBub2RlTWVzc2FnZS5ub2RlLmFsYXJtLmdldEJvdW5kaW5nUmVjdCgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmhlaWdodCAtIDNcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBub2RlTWVzc2FnZS5ub2RlLmFsYXJtLmF0dHIoXCJwb3NpdGlvblwiLCBuZXdBbGFybVBvc2l0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL+aUueWPmOiDjOaZr3JlY3TnmoTplb/lrr3lkozkvY3nva5cclxuICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIHg6IHJ4LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHJ5XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbiAob3B0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5jaGlsZE9mTmFtZShHcm91cE5vZGUuUkVDVF9OQU1FKTtcclxuICAgICAgICAgICAgcmVjdC5zZXRTaGFwZShvcHQuc2hhcGUpO1xyXG4gICAgICAgICAgIC8vIHJlY3QuYXR0cihcInN0eWxlXCIsIG9wdC5zdHlsZSk7XHJcbiAgICAgICAgICAgIHJlY3QuYXR0cigncG9zaXRpb24nLCBvcHQucG9zaXRpb24pO1xyXG4gICAgICAgICAgIC8vIHRoaXMuYXR0cihcInNoYXBlXCIsIG9wdC5zaGFwZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbWVyZ2VkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgLy/kv53nlZlncm91cOeahOWIneWni+S9jee9rlxyXG4gICAgICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvbiA9IHpyVXRpbC5jbG9uZSh0aGlzLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgLy/nu5nlsI/lm77niYforr7nva7lsZ7mgKfvvIzpmpDol49ncm91cFxyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl9yZWxhdGlvbkltYWdlLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5fcmVsYXRpb25JbWFnZS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIC8v6K6h566X5ZCI5bm25ZCO55qE5bCP5Zu+54mH55qEcG9zaXRpb25cclxuICAgICAgICAgICAgdmFyIHJlbGF0aW9uSW1hZ2VQb3NpdGlvbiA9IFt0aGlzLnBvc2l0aW9uWzBdICsgdGhpcy5jaGlsZE9mTmFtZShHcm91cE5vZGUuUkVDVF9OQU1FKS5zaGFwZS54ICsgKHRoaXMuZ2V0Qm91bmRpbmdSZWN0KClcclxuICAgICAgICAgICAgICAgICAgICAud2lkdGggLyAyIC0gd2lkdGggLyAyKSwgdGhpcy5wb3NpdGlvblsxXSArIHRoaXMuY2hpbGRPZk5hbWUoR3JvdXBOb2RlLlJFQ1RfTkFNRSkuc2hhcGUueSArXHJcbiAgICAgICAgICAgICAgICAodGhpcy5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyIC0gaGVpZ2h0IC8gMilcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgLy/lsIblsI/lm77niYfnmoTkvY3nva7kv53nlZnkuIvmnaVcclxuICAgICAgICAgICAgdmFyIGNsb25lSW1hZ2VQb3NpdGlvbiA9IHpyVXRpbC5jbG9uZShyZWxhdGlvbkltYWdlUG9zaXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWxhdGlvbkltYWdlLmF0dHIoXCJzdHlsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICBpbWFnZTogdGhpcy5tZXJnZWRJbWFnZSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWxhdGlvbkltYWdlLmF0dHIoXCJwb3NpdGlvblwiLCByZWxhdGlvbkltYWdlUG9zaXRpb24pO1xyXG4gICAgICAgICAgICBpZiAod2lkdGggPiAwICYmIGhlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVsYXRpb25JbWFnZS5zaG93KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8v5Y+M5Ye75Zu+54mH5pS+5Ye657uEXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbGF0aW9uSW1hZ2Uub24oXCJkYmxjbGlja1wiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvL+iuvue9rue7hOeahOS9jee9ruagueaNruWwj+WbvueJh+eahOWBj+enu+mHj+adpeiuoeeul1xyXG4gICAgICAgICAgICAgICAgdGhhdC5hdHRyKCdwb3NpdGlvbicsW2dyb3VwUG9zaXRpb25bMF0gKyAodGhpcy5wb3NpdGlvblswXSAtY2xvbmVJbWFnZVBvc2l0aW9uWzBdKSxcclxuICAgICAgICAgICAgICAgICAgICBncm91cFBvc2l0aW9uWzFdICsgKHRoaXMucG9zaXRpb25bMV0gLSBjbG9uZUltYWdlUG9zaXRpb25bMV0pXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIHRoYXQuc2hvdygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbGF0aW9uSW1hZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHpyVXRpbC5pbmhlcml0cyhHcm91cE5vZGUsIGdyYXBoaWMuR3JvdXApO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHcm91cE5vZGU7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBhZGRcclxuICog5bCG6IqC54K55Yqg5YWl5Yiw6L+Z5Liq57uE5Lit5pyA5ZCOXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIOassua3u+WKoOWIsOe7hOeahOiKgueCuVxyXG4gKi9cclxuLyoqXHJcbiAqIEBtZXRob2QgcmVtb3ZlQWxsXHJcbiAqIOenu+mZpOaJgOacieWtkOiKgueCuVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHJlbW92ZVxyXG4gKiDnp7vpmaTmiYDmnInlrZDoioLngrlcclxuICogQHBhcmFtIHtPYmplY3R9IGNoaWxkIOWtkOiKgueCuVxyXG4gKi9cclxuLyoqXHJcbiAqIEBtZXRob2QgY2hpbGRPZk5hbWVcclxuICog6I635Y+W5oyH5a6a5ZCN5a2X55qE5YS/5a2Q6IqC54K5XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAqIEByZXR1cm4ge09iamVjdH0g6IqC54K5XHJcbiAqL1xyXG4vKipcclxuICogQG1ldGhvZCB0cmF2ZXJzZVxyXG4gKiDmt7HluqbkvJjlhYjpgY3ljobmiYDmnInlrZDlrZnoioLngrnvvIhlYWNo5Y+q6YGN5Y6G5a2Q6IqC54K577yJXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAqIEByZXR1cm4ge09iamVjdH0g6IqC54K5XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjZmcge1N0cmluZ30gbWVyZ2VkSW1hZ2U9JycgIOaOp+WItuW9k+WPjOWHu+aXtiDnu4Tlj6/ku6XnvKnlsI/kuLrmjIflrprnmoTlm77lvaLjgIJcclxuICovXHJcblxyXG4vKipcclxuICogQGNmZyB7Qm9vbGVhbn0gY2hpbGREcmFnZ2FibGU9ZmFsc2UgIOaOp+WItue7hOWGheaIkOWRmOaYr+WQpuWPr+S7peaLluWKqFxyXG4gKi9cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0dyb3VwTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXHJcbiAqIGZpc2hUb3BvRmxvd+eahG5vZGXlr7nosaHvvIzmoYbmnrbmj5DkvpvnmoToioLngrnpg73mlL7lnKjov5nkuKrlr7nosaHkuIvjgILpgJrov4dleHRlbmTmlrnms5XliJvlu7roh6rlrprkuYnoioLngrk8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKiBAYWJzdHJhY3RcclxuICpcclxuICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgKlxyXG4gICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAgICAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICAgICogICAgICB2YXIgRGlhbW9uZCA9IG5vZGUuZXh0ZW5kKHtcclxuICAgICogICAgICAgICAgdHlwZTogJ0RpYW1vbmQnLFxyXG4gICAgKiAgICAgICAgICBzaGFwZToge1xyXG4gICAgKiAgICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAqICAgICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICogICAgICAgICAgfSxcclxuICAgICogICAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAocGF0aCwgc2hhcGUpIHtcclxuICAgICogICAgICAgICAgICAgIHZhciBjeCA9IDA7XHJcbiAgICAqICAgICAgICAgICAgICB2YXIgY3kgPSAwO1xyXG4gICAgKiAgICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGggLyAyO1xyXG4gICAgKiAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodCAvIDI7XHJcbiAgICAqICAgICAgICAgICAgICBwYXRoLm1vdmVUbyhjeCwgY3kgLSBoZWlnaHQpO1xyXG4gICAgKiAgICAgICAgICAgICAgcGF0aC5saW5lVG8oY3ggKyB3aWR0aCwgY3kpO1xyXG4gICAgKiAgICAgICAgICAgICAgcGF0aC5saW5lVG8oY3gsIGN5ICsgaGVpZ2h0KTtcclxuICAgICogICAgICAgICAgICAgIHBhdGgubGluZVRvKGN4IC0gd2lkdGgsIGN5KTtcclxuICAgICogICAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XHJcbiAgICAqICAgICAgICAgIH1cclxuICAgICogICAgICB9KTtcclxuICAgICogICAgICAgIHZhciBkaWFtb2QgPSBuZXcgRGlhbW9uZCh7XHJcbiAgICAqICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICogICAgICAgICAgICAgICAgd2lkdGg6NTAsXHJcbiAgICAqICAgICAgICAgICAgICAgIGhlaWdodDo1MFxyXG4gICAgKiAgICAgICAgICAgIH0sXHJcbiAgICAqICAgICAgICAgICAgcG9zaXRpb246WzYwLDYwXVxyXG4gICAgKiAgICAgICAgfSlcclxuICAgICogICAgICAgIGZpc2hUb3BvLmFkZChkaWFtb2QpO1xyXG4gKi9cclxuXHJcbiAgICB2YXIgUGF0aCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aCcpO1xyXG4gICAgdmFyIENvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi91dGlsL0Zsb3dDb25zdGFudHMuanNcIik7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvdXRpbC5qc1wiKTtcclxuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvbW9kZWwuanNcIik7XHJcbiAgICB2YXIgZmxvd05vZGUgPSB7fTtcclxuICAgIC8qKlxyXG4gICAgICog5p6E6YCg5qih5Z6LXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmbG93Tm9kZS5nZW5Nb2RlbCA9IGZ1bmN0aW9uICh0eXBlLCBvcHRzKSB7XHJcbiAgICAgICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKHt9KTtcclxuICAgICAgICAvLyDmsqHmnIlpZOeahOaXtuWAme+8jOe8uuWwkee7meS4gOS4qlVVSUTjgILliJvlu7roioLngrnmiJbogIXlj43luo/liJfljJbnmoTml7blgJkg6IqC54K555qESUTlj5bnmoTmmK9vcHRzLmlkXHJcblx0XHRpZiAoIW9wdHMuaWQpIHtcclxuXHRcdFx0b3B0cy5pZCA9IHV0aWwuZ2V0VVVJRCgpO1xyXG5cdFx0fVxyXG4gICAgICAgIG1vZGVsLnNldChDb25zdGFudHMuRUxFTUVOVF9UWVBFLCB0eXBlKTtcclxuICAgICAgICAvLyDpmLLmraIgbmV3IGVsLmNvbnN0cnVjdG9yKHsgc3R5bGU6IGVsLnN0eWxlLHNoYXBlOiBlbC5zaGFwZSB9KTsgenJVdGlsLmNsb25l5oql6ZSZXHJcbiAgICAgICAgaWYgKG9wdHMuc3R5bGUgJiYgb3B0cy5zdHlsZS5ob3N0KSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRzLnN0eWxlLmhvc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1vZGVsLnNldChDb25zdGFudHMuT1BUSU9OUywgenJVdGlsLmNsb25lKG9wdHMpKTtcclxuICAgICAgICBpZiAoXCJkcmFnZ2FibGVcIiBpbiBvcHRzKSB7XHJcbiAgICAgICAgICAgIG9wdHMuaXNkcmFnZ2FibGUgPSBvcHRzLmRyYWdnYWJsZTtcclxuICAgICAgICAgICAgZGVsZXRlIG9wdHMuZHJhZ2dhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9wdHMueikge1xyXG4gICAgICAgICAgICBvcHRzLnogPSAxOyAvL+iKgueCuem7mOiupOS4ujHvvIznur/mrrUwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQob3B0cy5ob3ZlckFuaW1hdGlvbikpIHtcclxuICAgICAgICAgICAgb3B0cy5ob3ZlckFuaW1hdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHV0aWwuaXNVbmRlZmluZWQob3B0cy5zZWxlY3RhYmxlKSkge1xyXG4gICAgICAgICAgICBvcHRzLnNlbGVjdGFibGUgPSB0cnVlOyAgLy/pu5jorqTlj6/ku6XpgInkuK1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xyXG4gICAgfVxyXG5cclxuICAgIGZsb3dOb2RlLmFkZEhvdmVyQW5pbWF0aW9uID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHpyVXRpbC5jbG9uZShub2RlLnNjYWxlKSB8fCBbMSwxXTtcclxuICAgICAgICB2YXIgb25FbXBoYXNpcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVUbyh7XHJcbiAgICAgICAgICAgICAgICBzY2FsZTogW3NjYWxlWzBdICogMS4xLCBzY2FsZVsxXSAqIDEuMV1cclxuICAgICAgICAgICAgfSwgNDAwLCAnZWxhc3RpY091dCcpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIG9uTm9ybWFsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZVRvKHtcclxuICAgICAgICAgICAgICAgIHNjYWxlOiBzY2FsZVxyXG4gICAgICAgICAgICB9LCA0MDAsICdlbGFzdGljT3V0Jyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBub2RlLm9uKCdtb3VzZW92ZXInLCBvbkVtcGhhc2lzKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0Jywgb25Ob3JtYWwpXHJcbiAgICAgICAgICAgIC5vbignZW1waGFzaXMnLCBvbkVtcGhhc2lzKVxyXG4gICAgICAgICAgICAub24oJ25vcm1hbCcsIG9uTm9ybWFsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBleHRlbmRcclxuICAgICAqIOaJqeWxleS4gOS4qiDoh6rlrprkuYnoioLngrksIOavlOWmgumSu+efs+W9ouetieOAglxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMudHlwZSDoh6rlrprkuYnnu5PoioLnmoTlkI3np7AgUGF0aCB0eXBlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcHMuaW5pdF0g5Yid5aeL5YyWIEluaXRpYWxpemVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByb3BzLmJ1aWxkUGF0aCDov5vooYzmnoTlu7roioLngrkgT3ZlcndyaXRlIGJ1aWxkUGF0aCBtZXRob2RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc3R5bGVdIOe8uuecgeagt+W8jyBFeHRlbmRlZCBkZWZhdWx0IHN0eWxlIGNvbmZpZ1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5zaGFwZV0g57y655yB6IqC54K55Y+C5pWwIEV4dGVuZGVkIGRlZmF1bHQgc2hhcGUgY29uZmlnXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBmbG93Tm9kZS5leHRlbmQgPSBmdW5jdGlvbiAoZGVmYXVsdHMpIHtcclxuICAgICAgICB2YXIgU3ViID0gZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IGZsb3dOb2RlLmdlbk1vZGVsKGRlZmF1bHRzLnR5cGUsIG9wdHMpO1xyXG4gICAgICAgICAgICBQYXRoLmNhbGwodGhpcywgb3B0cyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGVmYXVsdHMuc3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4dGVuZCBkZWZhdWx0IHN0eWxlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLmV4dGVuZEZyb20oZGVmYXVsdHMuc3R5bGUsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRXh0ZW5kIGRlZmF1bHQgc2hhcGVcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRTaGFwZSA9IGRlZmF1bHRzLnNoYXBlO1xyXG4gICAgICAgICAgICBpZiAoZGVmYXVsdFNoYXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gdGhpcy5zaGFwZSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIHZhciB0aGlzU2hhcGUgPSB0aGlzLnNoYXBlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0U2hhcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzU2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgZGVmYXVsdFNoYXBlLmhhc093blByb3BlcnR5KG5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNTaGFwZVtuYW1lXSA9IGRlZmF1bHRTaGFwZVtuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRlZmF1bHRzLmluaXQgJiYgZGVmYXVsdHMuaW5pdC5jYWxsKHRoaXMsIG9wdHMpO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB6clV0aWwuaW5oZXJpdHMoU3ViLCBQYXRoKTtcclxuXHJcbiAgICAgICAgLy8gRklYTUUg5LiN6IO9IGV4dGVuZCBwb3NpdGlvbiwgcm90YXRpb24g562J5byV55So5a+56LGhXHJcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0cykge1xyXG4gICAgICAgICAgICAvLyBFeHRlbmRpbmcgcHJvdG90eXBlIHZhbHVlcyBhbmQgbWV0aG9kc1xyXG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gJ3N0eWxlJyAmJiBuYW1lICE9PSAnc2hhcGUnKSB7XHJcbiAgICAgICAgICAgICAgICBTdWIucHJvdG90eXBlW25hbWVdID0gZGVmYXVsdHNbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBTdWI7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmxvd05vZGU7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBjZmcge0FycmF5fSBwb3NpdGlvbiDoioLngrnnmoTkvY3nva4s57uf5LiA5L2/55SocG9zaXRpb27ov5vooYzlrprkvY1beCx5XSBlZy4gWzEwMCwxMDBdXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjZmcge09iamVjdH0gc3R5bGUg5qC35byP5Y+C5pWwXHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUuZmlsbD0jMDAwIOWhq+WFheiJsiBlZy4jNUM5QUQzIHwgcmdiKDAsMjAwLDI1NSkgfCByZ2JhKDAsMjAwLDI1NSwwLjYpIHwgcmVkIHwgZ3JhZGllbnRcclxuICogQGNmZyB7c3RyaW5nfSBzdHlsZS5zdHJva2U9bnVsbCDnrJTnlLvpopzoibIgZWcuIzVDOUFEMyB8IHJnYigwLDIwMCwyNTUpIHwgcmdiYSgwLDIwMCwyNTUsMC42KSB8IHJlZCB8IGdyYWRpZW50XHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUubGluZVdpZHRoPTEg56yU55S75a695bqmXHJcbiAqIEBjZmcge0FycmF5fSBzdHlsZS5saW5lRGFzaD1udWxsIOeslOeUu+eahOiZmue6v+mXtOmalO+8jOWPguaVsOS4uuS6pOabv+e7mOWItue6v+auteWSjOmXtOi3nemVv+W6pueahOaVsOWtlyDlj4Lop4FbbGluZURhc2hPZmZzZXRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gpIGVnLiBsaW5lRGFzaDpbNiwxMF1cclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS5saW5lRGFzaE9mZnNldD0wICDnrJTnlLvnmoTomZrnur/lgY/np7vph48g5Y+C6KeBW2xpbmVEYXNoT2Zmc2V0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2xpbmVEYXNoT2Zmc2V0KVxyXG4gKiBAY2ZnIHtzdHJpbmd9IHN0eWxlLnRleHQ9XCJcIiDoioLngrnkuIrmmL7npLrnmoTmlofmnKws5Y+v5Lul5L2/55SoIFxcbiDmnaXmjaLooYxcclxuICogQGNmZyB7c3RyaW5nfSBzdHlsZS50ZXh0Rm9udD0nMTJweCBzYW5zLXNlcmlmJyDlrZfkvZPlpKflsI/jgIHlrZfkvZPnsbvlnovjgIHnspfnu4bjgIHlrZfkvZPmoLflvI/jgILmoLzlvI/lj4Lop4FbY3NzIGZvbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250KSBlZy50ZXh0Rm9udDogJ2l0YWxpYyBib2xkZXIgMTRweCBNaWNyb3NvZnQgWWFIZWknXHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUuZm9udFN0eWxlPW51bGwg5a2X5L2T5qC35byPXHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUuZm9udFdlaWdodD0jMDAwIOWtl+S9k+eyl+e7hlxyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLmZvbnRTaXplPW51bGwg5a2X5L2T5aSn5bCPXHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUuZm9udEZhbWlseT1udWxsIOWtl+S9k+exu+Wei1xyXG4gKiBAY2ZnIHtzdHJpbmd9IHN0eWxlLnRleHRGaWxsPSMwMDAg6IqC54K55LiK5paH5pys55qE5aGr5YWF6ImyIGVnLiM1QzlBRDMgfCByZ2IoMCwyMDAsMjU1KSB8IHJnYmEoMCwyMDAsMjU1LDAuNikgfCByZWRcclxuICogQGNmZyB7c3RyaW5nfSBzdHlsZS50ZXh0U3Rva2U9bnVsbCDoioLngrnkuIrmlofmnKznmoTmj4/ovrnoibIgZWcuIzVDOUFEMyB8IHJnYigwLDIwMCwyNTUpIHwgcmdiYSgwLDIwMCwyNTUsMC42KSB8IHJlZFxyXG4gKiBAY2ZnIHtzdHJpbmd8QXJyYXl9IHN0eWxlLnRleHRQb3NpdGlvbj1cIlwiIOaWh+acrOWcqOiKgueCueS4reeahOS9jee9rmxlZnR8cmlnaHR8dG9wfGJvdHRvbXxpbnNpZGV8aW5zaWRlTGVmdHxpbnNpZGVSaWdodHxpbnNpZGVUb3B8aW5zaWRlQm90dG9tfGluc2lkZVRvcExlZnR8aW5zaWRlVG9wUmlnaHR8aW5zaWRlQm90dG9tTGVmdHxpbnNpZGVCb3R0b21SaWdodHxbeCx5XXxbJSwlXVxyXG4gKiBAY2ZnIHtzdHJpbmd9IHN0eWxlLnRleHRCYXNlbGluZT1cImFscGhhYmV0aWNcIiDlvZPliY3mlofmnKzln7rnur/nmoTlsZ7mgKcgXCJ0b3BcIiB8fCBcImhhbmdpbmdcIiB8fCBcIm1pZGRsZVwiIHx8IFwiYWxwaGFiZXRpY1wiIHx8IFwiaWRlb2dyYXBoaWNcIiB8fCBcImJvdHRvbVwiIOWPguingVtjc3MgZm9udF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC90ZXh0QmFzZWxpbmUpXHJcbiAqIEBjZmcge0FycmF5fSBzdHlsZS50ZXh0T2Zmc2V0PW51bGwg5paH5pys5Zyo6IqC54K555qE5YGP56e75YC8W3gseV0gZWcuIFsxMCwxMF1cclxuICogQGNmZyB7c3RyaW5nfSBzdHlsZS50ZXh0QWxpZ249XCJcIiDmlofmnKzlnKjoioLngrnkuK3nmoTlr7npvZDmlrnlvI8gbGVmdCB8IGNlbnRlciB8IHJpZ2h0XHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ249bnVsbCDmlofmnKzlnKjoioLngrnkuK3nmoTlnoLnm7Tlr7npvZDmlrnlvI8gdG9wIHwgbWlkZGxlIHwgYm90dG9tXHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUudGV4dERpc3RhbmNlPTUg5paH5a2X55qE55u45a+5dGV4dFBvc+eahOWBj+enu+mHjyBlZy4gdGV4dFBvc2l0aW9uPSdsZWZ0JyB0ZXh0RGlzdGFuY2U9NSDliJnmloflrZfnmoR45Z2Q5qCH55qE5YC85Li6IChsZWZ055qE5Z2Q5qCHeOWAvCkgLTVcclxuICogQGNmZyB7c3RyaW5nfSBzdHlsZS50ZXh0U2hhZG93Q29sb3I9J3RyYW5zcGFyZW50JyDmloflrZfpmLTlvbHpopzoibJcclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS50ZXh0U2hhZG93Qmx1cj0wIOaWh+acrOmYtOW9seWuveW6piDlj4Lop4Fbc2hhZG93Qmx1cl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zaGFkb3dCbHVyKVxyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLnRleHRTaGFkb3dPZmZzZXRYPTAg5paH5pys6Zi05b2xIFgg5pa55ZCR5YGP56e7IOWPguingXNoYWRvd09mZnNldFhbaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zaGFkb3dPZmZzZXRYXVxyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZPTAg5paH5pys6Zi05b2xIFkg5pa55ZCR5YGP56e7IOWPguingXNoYWRvd09mZnNldFlbaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zaGFkb3dPZmZzZXRZXVxyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLnRleHRSb3RhdGlvbj0wIOaWh+acrOaXi+i9rOeahOinkuW6plxyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLnRleHRCb3JkZXJXaWR0aD0wIOaWh+Wtl+aPj+i+ueWuveW6plxyXG4gKiBAY2ZnIHtzdHJpbmd9IHN0eWxlLnRleHRCb3JkZXJDb2xvcj1udWxsIOaWh+Wtl+aPj+i+ueminOiJslxyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLnRleHRCb3JkZXJSYWRpdXM9MCDmloflrZfmj4/ovrnljYrlvoRcclxuICogQGNmZyB7c3RyaW5nfE9iamVjdH0gc3R5bGUudGV4dEJhY2tncm91bmRDb2xvcj1udWxsIOaWh+Wtl+iDjOaZryjpopzoibLmiJblm77niYcpIGVnLiAnIzMzMycgfCB7aW1hZ2U6Jy4vYXNzZXQvaW1nL2NsdW5kLnBuZyd9XHJcbiAqIEBjZmcge251bWJlcnxBcnJheX0gc3R5bGUudGV4dFBhZGRpbmc9bnVsbCDmloflrZdwYWRkaW5nICBlZy4gYDJgIG9yIGBbMiwgNF1gIG9yIGBbMiwgMywgNCwgNV1gXHJcbiAqIEBjZmcge09iamVjdH0gc3R5bGUucmljaD1udWxsIOWvjOaWh+acrOagt+W8j+WxnuaAp1xyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLnRleHRMaW5lSGVpZ2h0PTAg5paH5a2X55qE6KGM6auYXHJcbiAqIEBjZmcge251bWJlcn0gc3R5bGUub3BhY2l0eT0xIOWbvuW9oumAj+aYjuW6puOAguaUr+aMgeS7jiAwIOWIsCAxIOeahOaVsOWtl++8jOS4uiAwIOaXtuS4jee7mOWItuivpeWbvuW9ouOAglxyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLnNoYWRvd0JsdXI9MCDpmLTlvbHlrr3luqYg5Y+C6KeBW3NoYWRvd0JsdXJdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2hhZG93Qmx1cilcclxuICogQGNmZyB7bnVtYmVyfSBzdHlsZS5zaGFkb3dPZmZzZXRYPTAg6Zi05b2xIFgg5pa55ZCR5YGP56e7IOWPguingXNoYWRvd09mZnNldFhbaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zaGFkb3dPZmZzZXRYXVxyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLnNoYWRvd09mZnNldFk9MCDpmLTlvbEgWSDmlrnlkJHlgY/np7sg5Y+C6KeBc2hhZG93T2Zmc2V0WVtodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NoYWRvd09mZnNldFldXHJcbiAqIEBjZmcge3N0cmluZ30gc3R5bGUuc2hhZG93Q29sb3I9JyMwMDAnIOmYtOW9seminOiJsiBlZy4jNUM5QUQzIHwgcmdiKDAsMjAwLDI1NSkgfCByZ2JhKDAsMjAwLDI1NSwwLjYpIHwgcmVkIOWPguingVtzaGFkb3dDb2xvcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zaGFkb3dDb2xvcilcclxuICogQGNmZyB7c3RyaW5nfSBzdHlsZS5pbWFnZT1cIlwiIOWbvueJh+eahOi3r+W+hCDnlKjkuo5JbWFnZVxyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLndpZHRoIOWbvueJh+eahOWuveW6piDnlKjkuo5JbWFnZVxyXG4gKiBAY2ZnIHtudW1iZXJ9IHN0eWxlLmhlaWdodCDlm77niYfnmoTpq5jluqYg55So5LqOSW1hZ2VcclxuICovXHJcblxyXG4gLyoqXHJcbiAqIEBjZmcge09iamVjdH0gaG92ZXJTdHlsZSBob3Zlcuagt+W8jywg5Y+C5pWw6KeBc3R5bGVcclxuICAqL1xyXG4gLyoqXHJcbiAqIEBjZmcge09iamVjdH0gc2VsZWN0U3R5bGUg6YCJ5Lit6IqC54K555qE5qC35byPLCDlj4LmlbDop4FzdHlsZTsgIOm7mOiupOaYr+S4gOS4quiZmueahOi+ueahhjsgIOiuvuS4uuepuuWvueixoeWImeS4jeaYvuekuumAieS4rei+ueahhjtcclxuKi9cclxuLyoqXHJcbiAqIEBjZmcge0Jvb2xlYW59IGRyYWdnYWJsZT10cnVlIOaYr+WQpuWPr+S7peiiq+aLluaLveOAglxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtCb29sZWFufSBzZWxlY3RhYmxlPXRydWUg6IqC54K55piv5ZCm5Y+v6YCJ5Lit77yM6buY6K6k5pivdHJ1ZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtTdHJpbmd9IGlkIOS4uuS6humBv+WFjemHjeWkje+8jOebruWJjeeUseezu+e7n+iHquWKqOeUn+aIkO+8jOWmguaenOS4jemcgOimgeeUqOWPr+S7peW/veeVpeOAguW7uuiuruS9v+eUqG5tYWVcclxuICovXHJcblxyXG4vKipcclxuICogIEBjZmcge0Jvb2xlYW59IGhvdmVyQW5pbWF0aW9uPWZhbHNlIOaYr+WQpuW8gOWQryBob3ZlciDlnKjoioLngrnkuIrnmoTmj5DnpLrliqjnlLvmlYjmnpzjgILvvIzpu5jorqTmmK9mYWxzZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtTdHJpbmd9IG5hbWUg5oyH5a6a6IqC54K555qEbmFtZSwg5Y+v5Lul5L2/55SoY2hpbGRPZk5hbWXnrYnlh73mlbDmoLnmja5uYW1l5p+l5om+6IqC54K5XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjZmcge1N0cmluZ30gdG9vbHRpcCDoioLngrnnmoR0b29sdGlwIOWGheWuueWPr+S7peWMheaLrEhUTUzmoIfnrb5cclxuICovXHJcblxyXG4vKipcclxuICogQGNmZyB7T2JqZWN0fSByZWxhdGl2ZSByZWxhdGl2ZeaPj+i/sOaAjuS5iOagueaNrueItuWFg+e0oOi/m+ihjOWumuS9je+8jOiuvue9ruS6hnJlbGF0aXZl5bGe5oCnIOWwseS4jemcgOimgeiuvue9rnBvc2l0aW9u44CC5pSv5oyB77yabGVmdOOAgXJpZ2h044CBdG9w44CBYm90dG9tXHJcbiAqIEBjZmcge051bWJlcnxTdHJpbmd9IHJlbGF0aXZlLmxlZnQgIOi3neemu+eItuWFg+e0oOW3pui+ueeahOS9jee9ruOAguWAvOeahOexu+Wei+WPr+S7peaYr++8mjEubnVtYmVy77ya6KGo56S65YOP57Sg5YC877ybMi7nmb7liIbmr5TlgLzvvJrlpoIgJzMzJSfvvIznlKjniLblhYPntKDnmoTpq5jlkozmraTnmb7liIbmr5TorqHnrpflh7rmnIDnu4jlgLzjgIIzLidjZW50ZXIn77ya6KGo56S66Ieq5Yqo5bGF5Lit44CCNC5sZWZ0IOWSjCByaWdodCDlj6rmnInkuIDkuKrlj6/ku6XnlJ/mlYjjgIJcclxuICogQGNmZyB7TnVtYmVyfFN0cmluZ30gcmVsYXRpdmUucmlnaHQgIOi3neemu+eItuWFg+e0oOWPs+i+ueeahOS9jee9ruOAguWAvOeahOexu+Wei+WPr+S7peaYr++8mjEubnVtYmVy77ya6KGo56S65YOP57Sg5YC877ybMi7nmb7liIbmr5TlgLzvvJrlpoIgJzMzJSfvvIznlKjniLblhYPntKDnmoTpq5jlkozmraTnmb7liIbmr5TorqHnrpflh7rmnIDnu4jlgLzjgIIzLidjZW50ZXIn77ya6KGo56S66Ieq5Yqo5bGF5Lit44CCNC5sZWZ0IOWSjCByaWdodCDlj6rmnInkuIDkuKrlj6/ku6XnlJ/mlYjjgIJcclxuICogQGNmZyB7TnVtYmVyfFN0cmluZ30gcmVsYXRpdmUudG9wICDot53nprvniLblhYPntKDpobbpg6jnmoTkvY3nva7jgILlgLznmoTnsbvlnovlj6/ku6XmmK/vvJoxLm51bWJlcu+8muihqOekuuWDj+e0oOWAvO+8mzIu55m+5YiG5q+U5YC877ya5aaCICczMyUn77yM55So54i25YWD57Sg55qE6auY5ZKM5q2k55m+5YiG5q+U6K6h566X5Ye65pyA57uI5YC844CCMy4nY2VudGVyJ++8muihqOekuuiHquWKqOWxheS4reOAgjQudG9wIOWSjCBib3R0b20g5Y+q5pyJ5LiA5Liq5Y+v5Lul55Sf5pWI44CCXHJcbiAqIEBjZmcge051bWJlcnxTdHJpbmd9IHJlbGF0aXZlLmJvdHRvbSAg6Led56a754i25YWD57Sg5bqV6YOo55qE5L2N572u44CC5YC855qE57G75Z6L5Y+v5Lul5piv77yaMS5udW1iZXLvvJrooajnpLrlg4/ntKDlgLzvvJsyLueZvuWIhuavlOWAvO+8muWmgiAnMzMlJ++8jOeUqOeItuWFg+e0oOeahOmrmOWSjOatpOeZvuWIhuavlOiuoeeul+WHuuacgOe7iOWAvOOAgjMuJ2NlbnRlcifvvJrooajnpLroh6rliqjlsYXkuK3jgII0LnRvcCDlkowgYm90dG9tIOWPquacieS4gOS4quWPr+S7peeUn+aViOOAglxyXG4gKiBAY2ZnIHtTdHJpbmd9IFtib3VuZGluZz0nYWxsJ10g5Yaz5a6a5q2k5Zu+5b2i5YWD57Sg5Zyo5a6a5L2N5pe277yM5a+56Ieq6Lqr55qE5YyF5Zu055uS6K6h566X5pa55byP44CCIDEuJ2FsbCfvvJrvvIjpu5jorqTvvIkg6KGo56S655So6Ieq6Lqr5Lul5Y+K5a2Q6IqC54K55pW05L2T55qE57uP6L+HIHRyYW5zZm9ybSDlkI7nmoTljIXlm7Tnm5Lov5vooYzlrprkvY3jgIIg6L+Z56eN5pa55byP5piT5LqO5L2/5pW05L2T6YO96ZmQ5Yi25Zyo54i25YWD57Sg6IyD5Zu05Lit44CCMi4ncmF3J++8miDooajnpLrku4Xku4XnlKjoh6rouqvvvIjkuI3ljIXmi6zlrZDoioLngrnvvInnmoTmsqHnu4/ov4cgdHJhbmZvcm0g55qE5YyF5Zu055uS6L+b6KGM5a6a5L2N44CCIOi/meenjeaWueW8j+aYk+S6juWGheWuuei2heWHuueItuWFg+e0oOiMg+WbtOeahOWumuS9jeaWueW8j+OAglxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtBcnJheX0gc2NhbGUg6IqC54K555qE57yp5pS+5Zug5a2QLCBbeCx5XSDmsLTlubPkuI7lnoLnm7TmlrnlkJHnmoQgZWcuIFsxLDFdXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjZmcge251bWJlcn0gcm90YXRpb24g6IqC54K555qE5peL6L2s5Zug5a2QLCDljZXkvY3mmK/op5LluqYgZWcuIDAuNSogTWF0aC5QSVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtBcnJheX0gb3JpZ2luIOaXi+i9rOWSjOe8qeaUvueahOWOn+eCuSwgW3gseV0gZWcuIFs3NSw3NV1cclxuICovXHJcblxyXG4vKipcclxuICogQGNmZyB7bnVtYmVyfSB6PTAgIHrmlrnlkJHnmoTpq5jluqbvvIzlhrPlrprlsYLlj6DlhbPns7vjgILnsbvkvLxjc3MgekluZGV4XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjZmcge251bWJlcn0gemxldmVsPTAgIOWGs+WumuatpOWFg+e0oOe7mOWItuWcqOWTquS4qiBjYW52YXMg5bGC5Lit44CC5rOo5oSP77yM6LaK5aSaIGNhbnZhcyDlsYLkvJrljaDnlKjotorlpJrotYTmupDjgIJcclxuICovXHJcblxyXG4vKipcclxuICogQGNmZyB7Qm9vbGVhbn0gc2lsZW50PWZhbHNlICDmmK/lkKbkuI3lk43lupTpvKDmoIfku6Xlj4rop6bmkbjkuovku7bjgIJcclxuICovXHJcbi8qKlxyXG4gKiBAY2ZnIHtCb29sZWFufSBpbnZpc2libGU9ZmFsc2UgIOiKgueCueaYr+WQpuWPr+ingeOAglxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2ZnIHtPYmplY3R9IHBhcmVudCAg6IqC54K555qE54i25YWD57SgXHJcbiAqL1xyXG4vKipcclxuICogQGNmZyB7T2JqZWN0fSBvcGVyYXRpb25JY29ucyAg6IqC54K55pON5L2c5Li66YCJ5Lit55qE6IqC54K577yM5o+Q5L6b6buY6K6k5pON5L2c5oiW55So5oi36Ieq5a6a5pON5L2c44CCIOm7mOiupOaPkOS+m+eahOaTjeS9nO+8mnsgbmFtZTogY29uc3RhbnRzLkRFTCB9IOWIoOmZpOiKgueCuSwgeyBjb25zdGFudHMuTElOS30g55u057q/LCB7IGNvbnN0YW50cy5GT0xEfSDmipjnur8sIHsgY29uc3RhbnRzLkNVUlZFIH0g5puy57q/44CC5Lmf5Y+v5Lul6Ieq5a6a5LmJ5pON5L2cXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgaW1hZ2UxID0gbmV3IG5vZGUuSW1hZ2Uoe1xyXG4gKiAgICAgICAgICAgc3R5bGU6IHtcclxuICogICAgICAgICAgICAgICBpbWFnZTogXCJpbWcvaW1nLWNpYy9pY29uLXNlbmQtc21zLnN2Z1wiLFxyXG4gKiAgICAgICAgICAgICAgIHdpZHRoOjEyMCxcclxuICogICAgICAgICAgICAgICBoZWlnaHQ6NzAsXHJcbiAqICAgICAgICAgICAgICAgdGV4dDpcIuaTjeS9nDrnur/mrrVcIixcclxuICogICAgICAgICAgICAgICB0ZXh0UG9zaXRpb246XCJpbnNpZGVCb3R0b21cIlxyXG4gKiAgICAgICAgICAgfSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF0sXHJcbiAqICAgICAgICAgICBvcGVyYXRpb25JY29uczogW1xyXG4gKiAgICAgICAgICAgICAgIHsgbmFtZTogY29uc3RhbnRzLkxJTkt9ICxcclxuICogICAgICAgICAgICAgICB7IG5hbWU6IGNvbnN0YW50cy5GT0xEIH0sXHJcbiAqICAgICAgICAgICAgICAgeyBuYW1lOiBjb25zdGFudHMuQ1VSVkUgfVxyXG4gKiAgICAgICAgICAgXVxyXG4gKiAgICAgICB9KTtcclxuICovXHJcblxyXG4vKipcclxuICogQHByb3BlcnR5IHtPYmplY3R9IHN0YXRlc1xyXG4gKiDnlKjkuo7orr7nva7oioLngrnnmoTnirbmgIFcclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtb2RlbFxyXG4gKiDoioLngrnnmoTmqKHlnovvvIznlKjkuo7lrZjlgqjluo/liJfljJbmlbDmja4g5Lul5Y+K55So5oi36Ieq5a6a5LmJ5pWw5o2uXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc2V0U3R5bGVcclxuICog5Yib5bu66IqC54K55ZCO77yM6K6+572u6IqC54K555qE5qC35byP77yIc3R5bGXlsZ7mgKfvvIlcclxuICogQHBhcmFtIHtTdHJpbmd9IGtleSDplK7lkI1cclxuICogQHBhcmFtIHsqfSB2YWx1ZSDplK7lgLxcclxuICogQHJldHVybiB7T2JqZWN0fSDov5Tlm57oioLngrnlr7nosaHoh6rouqtcclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBzZXRTaGFwZVxyXG4gKiDliJvlu7roioLngrnlkI7vvIzorr7nva7oioLngrnnmoTlvaLnirbvvIhzaGFwZeWxnuaAp++8iVxyXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IOmUruWQjVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIOmUruWAvFxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IOi/lOWbnuiKgueCueWvueixoeiHqui6q1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGhpZGVcclxuICog6ZqQ6JeP6IqC54K5XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc2hvd1xyXG4gKiDmmL7npLroioLngrlcclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgb25cclxuICog57uR5a6a5LqL5Lu2XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCDkuovku7blkI1cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDkuovku7blpITnkIblh73mlbBcclxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSDkuIrkuIvmlodcclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBvZmZcclxuICog6Kej57uR5LqL5Lu2XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCDkuovku7blkI1cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDkuovku7blpITnkIblh73mlbBcclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBvbmVcclxuICog5Y2V5qyh6Kem5Y+R57uR5a6aLHRyaWdnZXLlkI7plIDmr4FcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIOS4iuS4i+aWh1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIHRyaWdnZXJcclxuICog5LqL5Lu25YiG5Y+RXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGlzU2lsZW50XHJcbiAqIOaYr+WQpue7keWumuS6huS6i+S7tlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgYW5pbWF0ZVxyXG4gKiDliqjnlLtcclxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGgg6ZyA6KaB5re75Yqg5Yqo55S755qE5bGe5oCn6I635Y+W6Lev5b6E77yM5Y+v5Lul6YCa6L+HYS5iLmPmnaXojrflj5bmt7HlsYLnmoTlsZ7mgKdcclxuICogQHBhcmFtIHtCb29sZWFufSBbbG9vcF0g5Yqo55S75piv5ZCm5b6q546vXHJcbiAqIEByZXR1cm4ge09iamVjdH0g6L+U5ZueQW5pbWF0b3Llr7nosaFcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgZWwuYW5pbWF0ZSgnc3R5bGUnLCBmYWxzZSlcclxuICogICAgICAgICAud2hlbigxMDAwLCB7eDogMTB9IClcclxuICogICAgICAgICAuZG9uZShmdW5jdGlvbigpeyAvLyBBbmltYXRpb24gZG9uZSB9KVxyXG4gKiAgICAgICAgIC5zdGFydCgpXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc3RvcEFuaW1hdGlvblxyXG4gKiDlgZzmraLliqjnlLtcclxuICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IOaYr+WQpuWcqOWBnOatouWJjeenu+WKqOWIsOacgOWQjuS4gOW4p1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGFuaW1hdGVUb1xyXG4gKiDku47kuIDliqjlsZ7mgKfov4fmuKHliLDlj6bkuIDnp43lsZ7mgKfnmoTliqjnlLtcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCDnm67liY3lsZ7mgKdcclxuICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF0g5Yqo55S75pe26Ze0IOWNleS9jW1zXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZWFzaW5nPSdsaW5lYXInXSDliqjnlLvlh73mlbAg5Y+C6KeBW+e8k+WKqOekuuS+i10oaHR0cDovL2VjaGFydHMuYmFpZHUuY29tL2dhbGxlcnkvZWRpdG9yLmh0bWw/Yz1saW5lLWVhc2luZylcclxuICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXSDlu7bml7bml7bpl7RcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSDliqjnlLvnu5PmnZ/lm57osINcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgICAgIC8vIEFuaW1hdGUgcG9zaXRpb25cclxuICogICAgICAgICAgZWwuYW5pbWF0ZVRvKHtcclxuICogICAgICAgICAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxyXG4gKiAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcclxuICpcclxuICogICAgICAgICAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zLCB3aXRoIGN1YmljT3V0IGVhc2luZ1xyXG4gKiAgICAgICAgICBlbC5hbmltYXRlVG8oe1xyXG4gKiAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICogICAgICAgICAgICAgICAgICB3aWR0aDogNTAwXHJcbiAqICAgICAgICAgICAgICB9LFxyXG4gKiAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICogICAgICAgICAgICAgICAgICBmaWxsOiAncmVkJ1xyXG4gKiAgICAgICAgICAgICAgfVxyXG4gKiAgICAgICAgICAgICAgcG9zaXRpb246IFsxMCwgMTBdXHJcbiAqICAgICAgICAgIH0sIDEwMCwgMTAwLCAnY3ViaWNPdXQnLCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGNsaWNrXHJcbiAqIOWNleWHu+S6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YXJnZXQg55uu5qCH5a+56LGhXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5ldmVudCDlrp7pmYXnmoTmtY/op4jlmajkuovku7blr7nosaFcclxuICogPHByZT5cclxuICogbm9kZS5vbignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgZGJsY2xpY2tcclxuICog5b2T5Y+M5Ye75YWD57Sg5pe277yM5Lya5Y+R55SfIGRibGNsaWNrIOS6i+S7tuOAglxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YXJnZXQg55uu5qCH5a+56LGhXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5ldmVudCDlrp7pmYXnmoTmtY/op4jlmajkuovku7blr7nosaFcclxuICogPHByZT5cclxuICogbm9kZS5vbignZGJsY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgbW91c2VvdmVyXHJcbiAqIOW9k+m8oOagh+aMh+mSiOS9jeS6juWFg+e0oOS4iuaWueaXtu+8jOS8muWPkeeUnyBtb3VzZW92ZXIg5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhcmdldCDnm67moIflr7nosaFcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmV2ZW50IOWunumZheeahOa1j+iniOWZqOS6i+S7tuWvueixoVxyXG4gKiA8cHJlPlxyXG4gKiBub2RlLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgbW91c2VvdXRcclxuICog5b2T6byg5qCH5oyH6ZKI5LuO5YWD57Sg5LiK56e75byA5pe277yM5Y+R55SfIG1vdXNlb3V0IOS6i+S7tuOAglxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YXJnZXQg55uu5qCH5a+56LGhXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5ldmVudCDlrp7pmYXnmoTmtY/op4jlmajkuovku7blr7nosaFcclxuICogPHByZT5cclxuICogbm9kZS5vbignbW91c2VvdXQnLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQGV2ZW50IG1vdXNlbW92ZVxyXG4gKiDlvZPpvKDmoIfmjIfpkojlnKjmjIflrprnmoTlhYPntKDkuK3np7vliqjml7bvvIzlsLHkvJrlj5HnlJ8gbW91c2Vtb3ZlIOS6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YXJnZXQg55uu5qCH5a+56LGhXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5ldmVudCDlrp7pmYXnmoTmtY/op4jlmajkuovku7blr7nosaFcclxuICogPHByZT5cclxuICogbm9kZS5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICogICAvL2RvIHNvbWV0aGluZ1xyXG4gKiB9KVxyXG4gKiA8L3ByZT5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBldmVudCBtb3VzZXdoZWVsXHJcbiAqIOW9k+eUqOaIt+WcqOaMh+WumueahOWFg+e0oOaXtua7muWKqOm8oOagh+a7kei9ruaXtizlsLHkvJrlj5HnlJ8gbW91c2V3aGVlbOS6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YXJnZXQg55uu5qCH5a+56LGhXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5ldmVudCDlrp7pmYXnmoTmtY/op4jlmajkuovku7blr7nosaFcclxuICogPHByZT5cclxuICogbm9kZS5vbignbW91c2V3aGVlbCcsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAqICAgLy9kbyBzb21ldGhpbmdcclxuICogfSlcclxuICogPC9wcmU+XHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgbW91c2Vkb3duXHJcbiAqIOW9k+m8oOagh+aMh+mSiOenu+WKqOWIsOWFg+e0oOS4iuaWue+8jOW5tuaMieS4i+m8oOagh+aMiemUruaXtu+8jOS8muWPkeeUnyBtb3VzZWRvd24g5LqL5Lu2XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhcmdldCDnm67moIflr7nosaFcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmV2ZW50IOWunumZheeahOa1j+iniOWZqOS6i+S7tuWvueixoVxyXG4gKiA8cHJlPlxyXG4gKiBub2RlLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQGV2ZW50IG1vdXNldXBcclxuICog5b2T5Zyo5YWD57Sg5LiK5pS+5p2+6byg5qCH5oyJ6ZKu5pe277yM5Lya5Y+R55SfIG1vdXNldXAg5LqL5Lu244CCXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCDkuovku7ZcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhcmdldCDnm67moIflr7nosaFcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmV2ZW50IOWunumZheeahOa1j+iniOWZqOS6i+S7tuWvueixoVxyXG4gKiA8cHJlPlxyXG4gKiBub2RlLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICogICAvL2RvIHNvbWV0aGluZ1xyXG4gKiB9KVxyXG4gKiA8L3ByZT5cclxuICovXHJcblxyXG4vKipcclxuICogQGV2ZW50IGNvbnRleHRtZW51XHJcbiAqIOW9k+WcqOWFg+e0oOS4iueCueWHu+m8oOagh+WPs+mUruaXtu+8jOS8muWPkeeUnyBjb250ZXh0bWVudSDkuovku7bjgIJcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IOS6i+S7tlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudGFyZ2V0IOebruagh+WvueixoVxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZXZlbnQg5a6e6ZmF55qE5rWP6KeI5Zmo5LqL5Lu25a+56LGh77yM5aaC5p6c5oOz6Zi75q2i6buY6K6k55qE5rWP6KeI5Zmo5Y+z6ZSu6I+c5Y2V6K+35L2/55SoIGV2ZW50LmV2ZW50LnByZXZlbnREZWZhdWx0KCk7IGV2ZW50LmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICogPHByZT5cclxuICogbm9kZS5vbignY29udGV4dG1lbnUnLCBmdW5jdGlvbihldmVudCkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgZHJhZ3N0YXJ0XHJcbiAqIOW9k+W8gOWni+aLluWKqOiKgueCueeahOaXtuWAme+8jOS8muWPkeeUnyBkcmFnc3RhcnQg5LqL5Lu244CCXHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqIG5vZGUub24oJ2RyYWdzdGFydCcsIGZ1bmN0aW9uKGUpIHtcclxuICogICAvL2RvIHNvbWV0aGluZ1xyXG4gKiB9KVxyXG4gKiA8L3ByZT5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBldmVudCBkcmFnXHJcbiAqIOW9k+aLluWKqOiKgueCueeahOaXtuWAme+8jOS8muWPkeeUnyBkcmFnIOS6i+S7tuOAglxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiBub2RlLm9uKCdkcmFnJywgZnVuY3Rpb24oZSkge1xyXG4gKiAgIC8vZG8gc29tZXRoaW5nXHJcbiAqIH0pXHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgZHJhZ2VuZFxyXG4gKiDlvZPmi5bliqjoioLngrnnu5PmnZ/nmoTml7blgJnvvIzkvJrlj5HnlJ8gZHJhZ2VuZCDkuovku7bjgIJcclxuICpcclxuICogPHByZT5cclxuICogbm9kZS5vbignZHJhZ2VuZCcsIGZ1bmN0aW9uKGUpIHtcclxuICogICAvL2RvIHNvbWV0aGluZ1xyXG4gKiB9KVxyXG4gKiA8L3ByZT5cclxuICovXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL2Zsb3dOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog55+p5b2iPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuUmVjdFxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgcmVjdCA9IG5ldyBub2RlLlJlY3Qoe1xyXG4gKiAgICAgICAgICAgc2hhcGU6e3dpZHRoOjEwMCxoZWlnaHQ6NjB9LFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzIwLDIwXVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKHJlY3QpO1xyXG4gKi9cclxuXHJcbiAgICB2YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcm91bmRSZWN0Jyk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJykuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ1JlY3QnLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7QXJyYXl9IHNoYXBlLnBvaW50cz1udWxsIOaLhue6v+eCueeahOWdkOaghyDlj6/ku6Xku45BSeS4reiOt+WPluOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcnxTdHJpbmd8Qm9vbGVhbn0gW3NoYXBlLnNtb290aD1mYWxzZV0g5piv5ZCm5bmz5ruR5puy57q/5pi+56S644CC5aaC5p6c5Li6IG51bWJlcu+8muihqOekuui0neWhnuWwlCAoYmV6aWVyKSDlt67lgLzlubPmu5HvvIxzbW9vdGgg5oyH5a6a5LqG5bmz5ruR562J57qn77yM6IyD5Zu0IFswLCAxXTvlpoLmnpzkuLogJ3NwbGluZSfvvJrooajnpLogQ2F0bXVsbC1Sb20gc3BsaW5lIOW3ruWAvOW5s+a7kVxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUuc21vb3RoQ29uc3RyYWludD1udWxsIOaYr+WQpuWwhuW5s+a7keabsue6v+e6puadn+WcqOWMheWbtOebkuS4reOAgnNtb290aCDkuLogbnVtYmVy77yIYmV6aWVy77yJ5pe255Sf5pWIXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgLy8g5bem5LiK44CB5Y+z5LiK44CB5Y+z5LiL44CB5bem5LiL6KeS55qE5Y2K5b6E5L6d5qyh5Li6cjHjgIFyMuOAgXIz44CBcjRcclxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ujEgICAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXHJcbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLpbMV0gICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxyXG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6WzEsIDJdICAgIOebuOW9k+S6jiBbMSwgMiwgMSwgMl1cclxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ulsxLCAyLCAzXSDnm7jlvZPkuo4gWzEsIDIsIDMsIDJdXHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgIHI6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiA1MCxcclxuICAgICAgICAgICAgaGVpZ2h0OiA1MFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSAwO1xyXG4gICAgICAgICAgICB2YXIgeSA9IDA7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xyXG4gICAgICAgICAgICBpZiAoIXNoYXBlLnIpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcm91bmRSZWN0SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBleHRlbmRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvUmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXHJcbiAqIOWchuW9ojxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLkNpcmNsZVxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgY2lyY2xlID0gbmV3IG5vZGUuQ2lyY2xlKHtcclxuICogICAgICAgICAgIHNoYXBlOntyOjI0fSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChjaXJjbGUpO1xyXG4gKi9cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAnQ2lyY2xlJyxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IHNoYXBlIOW9oueKtuWPguaVsFxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUucj0yMCDljYrlvoTjgIJcclxuICAgICAgICAgKi9cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICByOiAyMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aCA6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBpbkJ1bmRsZSkge1xyXG4gICAgICAgICAgICAvLyBCZXR0ZXIgc3Ryb2tpbmcgaW4gU2hhcGVCdW5kbGVcclxuICAgICAgICAgICAgLy8gQWx3YXlzIGRvIGl0IG1heSBoYXZlIHBlcmZvcm1lbmNlIGlzc3VlICggZmlsbCBtYXkgYmUgMnggbW9yZSBjb3N0KVxyXG4gICAgICAgICAgICBpZiAoaW5CdW5kbGUpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc2hhcGUuciwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXHJcbiAgICAgICAgICAgIC8vIGN0eC5tb3ZlVG8oc2hhcGUuY3ggKyBzaGFwZS5yLCBzaGFwZS5jeSk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgc2hhcGUuciwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0NpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOWbvueJh+iKgueCuTxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLkltYWdlXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciBpbWFnZSA9IG5ldyBub2RlLkltYWdlKHtcclxuICogICAgICAgICAgIHN0eWxlOiB7XHJcbiAqICAgICAgICAgICAgICAgaW1hZ2U6IFwiLi4vLi4vZXhhbXBsZXMvZmxvdy9pbWcvaW1nLWNpYy9zdGFydC5zdmdcIixcclxuICogICAgICAgICAgICAgICB3aWR0aDoxMjAsXHJcbiAqICAgICAgICAgICAgICAgaGVpZ2h0OjcwLFxyXG4gKiAgICAgICAgICAgICAgIHRleHQ6XCJFdmVudCBOYW1lXCJcclxuICogICAgICAgICAgIH0sXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbNjAsNjBdXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQoaW1hZ2UpO1xyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZScpO1xyXG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0Jyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZmxvd05vZGUgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJyk7XHJcbiAgICB2YXIgTFJVID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9MUlUnKTtcclxuICAgIHZhciBnbG9iYWxJbWFnZUNhY2hlID0gbmV3IExSVSg1MCk7XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIFpJbWFnZShvcHRzKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IGZsb3dOb2RlLmdlbk1vZGVsKFwiSW1hZ2VcIiwgb3B0cyk7XHJcbiAgICAgICAgRGlzcGxheWFibGUuY2FsbCh0aGlzLCBvcHRzKTtcclxuXHJcbiAgICAgICAgaWYgKHdpbmRvdy5qUXVlcnkpIHsgICAvL+WIpOaWrWpRdWVyeeaYr+WQpuWtmOWcqFxyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdERlZmVycmQgPSBqUXVlcnkuRGVmZXJyZWQoKTtcclxuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLnJlc3VsdERlZmVycmQucHJvbWlzZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBaSW1hZ2UucHJvdG90eXBlID0ge1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvcjogWkltYWdlLFxyXG5cclxuICAgICAgICB0eXBlOiAnSW1hZ2UnLFxyXG5cclxuICAgICAgICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XHJcbiAgICAgICAgICAgIHZhciBzcmMgPSBzdHlsZS5pbWFnZTtcclxuICAgICAgICAgICAgdmFyIGltYWdlO1xyXG5cclxuICAgICAgICAgICAgLy8gTXVzdCBiaW5kIGVhY2ggdGltZVxyXG4gICAgICAgICAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcywgcHJldkVsKTtcclxuICAgICAgICAgICAgLy8gc3R5bGUuaW1hZ2UgaXMgYSB1cmwgc3RyaW5nXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2UgPSB0aGlzLl9pbWFnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBzdHlsZS5pbWFnZSBpcyBhbiBIVE1MSW1hZ2VFbGVtZW50IG9yIEhUTUxDYW52YXNFbGVtZW50IG9yIENhbnZhc1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGltYWdlID0gc3JjO1xyXG4gICAgICAgICAgICAgICAgaW1hZ2UuaXNMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEZJWE1FIENhc2UgY3JlYXRlIG1hbnkgaW1hZ2VzIHdpdGggc3JjXHJcbiAgICAgICAgICAgIGlmICghaW1hZ2UgJiYgc3JjKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUcnkgZ2V0IGZyb20gZ2xvYmFsIGltYWdlIGNhY2hlXHJcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQoc3JjKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2FjaGVkSW1nT2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGltYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZS5pc0xvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UuaXNMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlZEltZ09iai5wZW5kaW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRJbWdPYmoucGVuZGluZ1tpXS5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZWRJbWdPYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZzogW3RoaXNdXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZS5zcmMgPSBzcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsSW1hZ2VDYWNoZS5wdXQoc3JjLCBjYWNoZWRJbWdPYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlID0gaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBjYWNoZWRJbWdPYmouaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJbWFnZSBpcyBub3QgY29tcGxldGUgZmluaXNoLCBhZGQgdG8gcGVuZGluZyBsaXN0ICDlpoLmnpzkvb/nlKjnmoRzdmflm77niYcsIElFMTHkuIvlsLHnrpfliqDovb3miJDlip9pbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h05Lmf6YO95piv5Li6MFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoIWltYWdlLndpZHRoIHx8ICFpbWFnZS5oZWlnaHQpICYmICghaW1hZ2Uuc3JjLmVuZHNXaXRoKFwic3ZnXCIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRJbWdPYmoucGVuZGluZy5wdXNoKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIOWbvueJh+W3sue7j+WKoOi9veWujOaIkFxyXG4gICAgICAgICAgICAgICAgLy8gaWYgKGltYWdlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gJ0lNRycpIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICBpZiAoIWltYWdlLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICAvLyBFbHNlIGlzIGNhbnZhc1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB4ID0gc3R5bGUueCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XHJcbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzkvb/nlKjnmoRzdmflm77niYcsIElFMTHkuIvlsLHnrpfliqDovb3miJDlip9pbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h05Lmf6YO95piv5Li6MFxyXG4gICAgICAgICAgICAgICAgLy/mraTlpITlpoLkuI3ms6jph4osIOS8muWvvOiHtElFMTHkuItzdmflm77niYfml6Dms5Xkvb/nlKhcclxuICAgICAgICAgICAgICAgIC8vIOWbvueJh+WKoOi9veWksei0pVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgKCFpbWFnZS53aWR0aCB8fCAhaW1hZ2UuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpbWFnZS5pc0xvYWRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cualF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0RGVmZXJyZC5yZWplY3QoaW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc3R5bGUuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGFzcGVjdCA9IGltYWdlLndpZHRoIC8gaW1hZ2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoID09IG51bGwgJiYgaGVpZ2h0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGltYWdlL2hlaWdodCByYXRpb1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwgJiYgd2lkdGggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1hZ2Uud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIOiuvue9rnRyYW5zZm9ybVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc1dpZHRoICYmIHN0eWxlLnNIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ggPSBzdHlsZS5zeCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzeSA9IHN0eWxlLnN5IHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN4LCBzeSwgc3R5bGUuc1dpZHRoLCBzdHlsZS5zSGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCB3aWR0aCwgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlLnN4ICYmIHN0eWxlLnN5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4MiA9IHN0eWxlLnN4O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzeTIgPSBzdHlsZS5zeTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc1dpZHRoID0gd2lkdGggLSBzeDI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNIZWlnaHQgPSBoZWlnaHQgLSBzeTI7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN4Miwgc3kyLCBzV2lkdGgsIHNIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsIHksIHdpZHRoLCBoZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzmsqHorr7nva7lrr3lkozpq5jnmoTor53oh6rliqjmoLnmja7lm77niYflrr3pq5jorr7nva5cclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS53aWR0aCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oZWlnaHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEcmF3IHJlY3QgdGV4dFxyXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmpRdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0RGVmZXJyZC5yZXNvbHZlKGltYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xyXG4gICAgICAgICAgICBpZiAoISB0aGlzLl9yZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZS54IHx8IDAsIHN0eWxlLnkgfHwgMCwgc3R5bGUud2lkdGggfHwgMCwgc3R5bGUuaGVpZ2h0IHx8IDBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB6clV0aWwuaW5oZXJpdHMoWkltYWdlLCBEaXNwbGF5YWJsZSk7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBaSW1hZ2U7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBleHRlbmRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvSW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDmlofmnKw8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5UZXh0XHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIikpO1xyXG4gKiAgICAgICB2YXIgdGV4dCA9IG5ldyBub2RlLlRleHQoe1xyXG4gKiAgICAgICAgICAgc3R5bGU6e3RleHQ6XCLmlofmnKzkuZ/lj6/ku6XkvZzkuLrni6znq4vnmoToioLngrnov5vooYzmi5bmi71cIixmaWxsOlwiI2ZmMDAwMFwiLCB0ZXh0Rm9udDpcIjE2cHggTWljcm9zb2Z0IFlhSGVpXCJ9LFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzYwLDYwXVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKHRleHQpO1xyXG4gKi9cclxuXHJcbiAgICB2YXIgVGV4dCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dCcpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGZsb3dOb2RlID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpO1xyXG4gICAgZnVuY3Rpb24gWlRleHQob3B0cykge1xyXG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgc3R5bGU6e3RleHRCYXNlbGluZTpcInRvcFwifSAgIC8vIOm7mOiupOWAvCAg6L+Z5qC36YCJ5Lit5pe255qE5qGG5omN5q2j56GuXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHpyVXRpbC5tZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0cywgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IGZsb3dOb2RlLmdlbk1vZGVsKFwiVGV4dFwiLCBvcHRzKTtcclxuICAgICAgICBUZXh0LmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICB6clV0aWwuaW5oZXJpdHMoWlRleHQsIFRleHQpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBaVGV4dDtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9UZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOaJh+W9ojxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLlNlY3RvclxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpKTtcclxuICogICAgICAgdmFyIHNlY3RvciA9IG5ldyBub2RlLlNlY3Rvcih7XHJcbiAqICAgICAgICAgICBzaGFwZToge3I6MzAsIHN0YXJ0QW5nbGU6MCwgZW5kQW5nbGU6TWF0aC5QSSAqIDAuNX0sIC8vIHN0YXJ0QW5nbGVcXGVuZEFuZ2xl5piv5byn5bqm5Y2V5L2NXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbNjAsNjBdXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQoc2VjdG9yKTtcclxuICovXHJcblxyXG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XHJcbiAgICB2YXIgUGF0aCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvUGF0aCcpO1xyXG5cclxuICAgIHZhciBzaGFkb3dUZW1wID0gW1xyXG4gICAgICAgIFsnc2hhZG93Qmx1cicsIDBdLFxyXG4gICAgICAgIFsnc2hhZG93Q29sb3InLCAnIzAwMCddLFxyXG4gICAgICAgIFsnc2hhZG93T2Zmc2V0WCcsIDBdLFxyXG4gICAgICAgIFsnc2hhZG93T2Zmc2V0WScsIDBdXHJcbiAgICBdO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJykuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ1NlY3RvcicsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnI9MCDlpJbljYrlvoTjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnIwPTAg5YaF5Y2K5b6E44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5zdGFydEFuZ2xlPTAg5byA5aeL5byn5bqm44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5lbmRBbmdsZT1NYXRoLlBJICogMiAg57uT5p2f5byn5bqm44CCXHJcbiAgICAgICAgICogQGNmZyB7Qm9vbGVhbn0gc2hhcGUuY2xvY2t3aXNlPXRydWUg5piv5ZCm6aG65pe26ZKI44CCXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgY3g6IDAsXHJcblxyXG4gICAgICAgICAgICBjeTogMCxcclxuXHJcbiAgICAgICAgICAgIHIwOiAwLFxyXG5cclxuICAgICAgICAgICAgcjogMCxcclxuXHJcbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IDAsXHJcblxyXG4gICAgICAgICAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXHJcblxyXG4gICAgICAgICAgICBjbG9ja3dpc2U6IHRydWVcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBicnVzaDogKGVudi5icm93c2VyLmllICYmIGVudi5icm93c2VyLnZlcnNpb24gPj0gMTEpIC8vIHZlcnNpb246ICcxMS4wJ1xyXG4gICAgICAgICAgICAvLyBGaXggd2VpcmQgYnVnIGluIHNvbWUgdmVyc2lvbiBvZiBJRTExIChsaWtlIDExLjAuOTYwMC4xNzgwMSksXHJcbiAgICAgICAgICAgIC8vIHdoZXJlIGV4Y2VwdGlvbiBcInVuZXhwZWN0ZWQgY2FsbCB0byBtZXRob2Qgb3IgcHJvcGVydHkgYWNjZXNzXCJcclxuICAgICAgICAgICAgLy8gbWlnaHQgYmUgdGhyb3duIHdoZW4gY2FsbGluZyBjdHguZmlsbCBhZnRlciBhIHBhdGggd2hvc2UgYXJlYSBzaXplXHJcbiAgICAgICAgICAgIC8vIGlzIHplcm8gaXMgZHJhd24gYW5kIGN0eC5jbGlwKCkgaXMgY2FsbGVkIGFuZCBzaGFkb3dCbHVyIGlzIHNldC5cclxuICAgICAgICAgICAgLy8gKGUuZy4sXHJcbiAgICAgICAgICAgIC8vICBjdHgubW92ZVRvKDEwLCAxMCk7XHJcbiAgICAgICAgICAgIC8vICBjdHgubGluZVRvKDIwLCAxMCk7XHJcbiAgICAgICAgICAgIC8vICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIC8vICBjdHguY2xpcCgpO1xyXG4gICAgICAgICAgICAvLyAgY3R4LnNoYWRvd0JsdXIgPSAxMDtcclxuICAgICAgICAgICAgLy8gIC4uLlxyXG4gICAgICAgICAgICAvLyAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgLy8gKVxyXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjbGlwUGF0aHMgPSB0aGlzLl9fY2xpcFBhdGhzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcclxuICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gY2xpcFBhdGhzW2ldICYmIGNsaXBQYXRoc1tpXS5zaGFwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLnN0YXJ0QW5nbGUgPT09IHNoYXBlLmVuZEFuZ2xlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dUZW1wW2pdWzJdID0gc3R5bGVbc2hhZG93VGVtcFtqXVswXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbc2hhZG93VGVtcFtqXVswXV0gPSBzaGFkb3dUZW1wW2pdWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgUGF0aC5wcm90b3R5cGUuYnJ1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNoYWRvd1RlbXAubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbc2hhZG93VGVtcFtrXVswXV0gPSBzaGFkb3dUZW1wW2tdWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IFBhdGgucHJvdG90eXBlLmJydXNoLFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xyXG4gICAgICAgICAgICB2YXIgcjAgPSBNYXRoLm1heChzaGFwZS5yMCB8fCAwLCAwKTtcclxuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xyXG4gICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcclxuICAgICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcclxuXHJcbiAgICAgICAgICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odW5pdFggKiByMCArIHgsIHVuaXRZICogcjAgKyB5KTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XHJcblxyXG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhY2xvY2t3aXNlKTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oXHJcbiAgICAgICAgICAgICAgICBNYXRoLmNvcyhlbmRBbmdsZSkgKiByMCArIHgsXHJcbiAgICAgICAgICAgICAgICBNYXRoLnNpbihlbmRBbmdsZSkgKiByMCArIHlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyMCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByMCwgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsIGNsb2Nrd2lzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9TZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog546v5b2iPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuUmluZ1xyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpKTtcclxuICogICAgICAgdmFyIHJpbmcgPSBuZXcgbm9kZS5SaW5nKHtcclxuICogICAgICAgICAgIHNoYXBlOiB7cjozMCwgIHIwOjEwfSwgIC8vIHIwIOWGheWNiuW+hFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzYwLDYwXVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKHJpbmcpO1xyXG4gKi9cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICAgdHlwZTogJ1JpbmcnLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5yPTAg5aSW5Y2K5b6E44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5yMD0wIOWGheWNiuW+hOOAglxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgcjogMCxcclxuICAgICAgICAgICAgcjA6IDBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XHJcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUuY3k7XHJcbiAgICAgICAgICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUuciwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgc2hhcGUuciwgMCwgUEkyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHNoYXBlLnIwLCB5KTtcclxuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yMCwgMCwgUEkyLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9SaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXHJcbiAqIOakreWchjxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLkRyb3BsZXRcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93Lm5vZGVcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgdmFyIGVsbGlwc2UgPSBuZXcgbm9kZS5FbGxpcHNlKHtcclxuICogICAgICAgICAgIHNoYXBlOiB7cng6NzAsICByeTozMH0sICAvLyByeDrmpK3lnIbmqKrljYrovbTplb8gcnk65qSt5ZyG57q15Y2K6L206ZW/XHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbNjAsNjBdXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQoZWxsaXBzZSk7XHJcbiAqL1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdFbGxpcHNlJyxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IHNoYXBlIOW9oueKtuWPguaVsFxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUucng9MCDmpK3lnIbmqKrljYrovbTplb9cclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnJ5PTAg5qSt5ZyG57q15Y2K6L206ZW/XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgcng6IDAsIHJ5OiAwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgayA9IDAuNTUyMjg0ODtcclxuICAgICAgICAgICAgdmFyIHggPSAwO1xyXG4gICAgICAgICAgICB2YXIgeSA9IDA7XHJcbiAgICAgICAgICAgIHZhciBhID0gc2hhcGUucng7XHJcbiAgICAgICAgICAgIHZhciBiID0gc2hhcGUucnk7XHJcbiAgICAgICAgICAgIHZhciBveCA9IGEgKiBrOyAvLyDmsLTlubPmjqfliLbngrnlgY/np7vph49cclxuICAgICAgICAgICAgdmFyIG95ID0gYiAqIGs7IC8vIOWeguebtOaOp+WItueCueWBj+enu+mHj1xyXG4gICAgICAgICAgICAvLyDku47mpK3lnIbnmoTlt6bnq6/ngrnlvIDlp4vpobrml7bpkojnu5jliLblm5vmnaHkuInmrKHotJ3loZ7lsJTmm7Lnur9cclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4IC0gYSwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggLSBhLCB5IC0gb3ksIHggLSBveCwgeSAtIGIsIHgsIHkgLSBiKTtcclxuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCArIG94LCB5IC0gYiwgeCArIGEsIHkgLSBveSwgeCArIGEsIHkpO1xyXG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4ICsgYSwgeSArIG95LCB4ICsgb3gsIHkgKyBiLCB4LCB5ICsgYik7XHJcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggLSBveCwgeSArIGIsIHggLSBhLCB5ICsgb3ksIHggLSBhLCB5KTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0VsbGlwc2UuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5b+D5b2iPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuSGVhcnRcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93Lm5vZGVcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgdmFyIGhlYXJ0ICA9IG5ldyBub2RlLkhlYXJ0KHtcclxuICogICAgICAgICAgIHNoYXBlOiB7d2lkdGg6NDAsICBoZWlnaHQ6NTB9LFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzYwLDYwXVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKGhlYXJ0ICk7XHJcbiAqL1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdIZWFydCcsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLmN4PTAg5Lit5b+D5Zyo54i26IqC54K55Z2Q5qCH57O777yI5Lul54i26IqC54K55bem5LiK6KeS5Li65Y6f54K577yJ5Lit55qE5qiq5Z2Q5qCH5YC844CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5jeT0wIOS4reW/g+WcqOeItuiKgueCueWdkOagh+ezu++8iOS7peeItuiKgueCueW3puS4iuinkuS4uuWOn+eCue+8ieS4reeahOe6teWdkOagh+WAvOOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUud2lkdGg9MCDlrr3luqbjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLmhlaWdodD0wIOmrmOW6puOAglxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcclxuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIGEgPSBzaGFwZS53aWR0aDtcclxuICAgICAgICAgICAgdmFyIGIgPSBzaGFwZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxyXG4gICAgICAgICAgICAgICAgeCArIGEgLyAyLCB5IC0gYiAqIDIgLyAzLFxyXG4gICAgICAgICAgICAgICAgeCArIGEgKiAyLCB5ICsgYiAvIDMsXHJcbiAgICAgICAgICAgICAgICB4LCB5ICsgYlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgIHggLSBhICogIDIsIHkgKyBiIC8gMyxcclxuICAgICAgICAgICAgICAgIHggLSBhIC8gMiwgeSAtIGIgKiAyIC8gMyxcclxuICAgICAgICAgICAgICAgIHgsIHlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9IZWFydC5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxyXG4gKiDmsLTmu7TlvaI8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5Ecm9wbGV0XHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciBkcm9wbGV0ID0gbmV3IG5vZGUuRHJvcGxldCh7XHJcbiAqICAgICAgICAgICBzaGFwZToge3dpZHRoOjEwLCAgaGVpZ2h0OjMwfSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChkcm9wbGV0KTtcclxuICovXHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJykuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ0Ryb3BsZXQnLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS53aWR0aD0wIOWuveW6puOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUuaGVpZ2h0PTAg6auY5bqm44CCXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgY3g6IDAsIGN5OiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMCwgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoIDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcclxuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIGEgPSBzaGFwZS53aWR0aDtcclxuICAgICAgICAgICAgdmFyIGIgPSBzaGFwZS5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkgKyBhKTtcclxuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXHJcbiAgICAgICAgICAgICAgICB4ICsgYSxcclxuICAgICAgICAgICAgICAgIHkgKyBhLFxyXG4gICAgICAgICAgICAgICAgeCArIGEgKiAzIC8gMixcclxuICAgICAgICAgICAgICAgIHkgLSBhIC8gMyxcclxuICAgICAgICAgICAgICAgIHgsXHJcbiAgICAgICAgICAgICAgICB5IC0gYlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgIHggLSBhICogMyAvIDIsXHJcbiAgICAgICAgICAgICAgICB5IC0gYSAvIDMsXHJcbiAgICAgICAgICAgICAgICB4IC0gYSxcclxuICAgICAgICAgICAgICAgIHkgKyBhLFxyXG4gICAgICAgICAgICAgICAgeCxcclxuICAgICAgICAgICAgICAgIHkgKyBhXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9Ecm9wbGV0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOeOq+eRsOW9ojxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLlJvc2VcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93Lm5vZGVcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSk7XHJcbiAqICAgICAgIHZhciByb3NlID0gbmV3IG5vZGUuUm9zZSh7XHJcbiAqICAgICAgICAgICBzaGFwZToge3I6WzM1XSwgazo3LCBuOjR9LFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzYwLDYwXVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKHJvc2UpO1xyXG4gKi9cclxuXHJcbiAgICB2YXIgc2luID0gTWF0aC5zaW47XHJcbiAgICB2YXIgY29zID0gTWF0aC5jb3M7XHJcbiAgICB2YXIgcmFkaWFuID0gTWF0aC5QSSAvIDE4MDtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdSb3NlJyxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IHNoYXBlIOW9oueKtuWPguaVsFxyXG4gICAgICAgICAqIEBjZmcge0FycmF5fSBzaGFwZS5yPVtdXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5rPTBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLm49MVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgcjogW10sXHJcbiAgICAgICAgICAgIGs6IDAsXHJcbiAgICAgICAgICAgIG46IDFcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcclxuICAgICAgICAgICAgZmlsbDogbnVsbCxcclxuICAgICAgICAgICAgbGluZVdpZHRoOiAyXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgeDtcclxuICAgICAgICAgICAgdmFyIHk7XHJcbiAgICAgICAgICAgIHZhciBSID0gc2hhcGUucjtcclxuICAgICAgICAgICAgdmFyIHI7XHJcbiAgICAgICAgICAgIHZhciBrID0gc2hhcGUuaztcclxuICAgICAgICAgICAgdmFyIG4gPSBzaGFwZS5uO1xyXG5cclxuICAgICAgICAgICAgdmFyIHgwID0gc2hhcGUuY3g7XHJcbiAgICAgICAgICAgIHZhciB5MCA9IHNoYXBlLmN5O1xyXG5cclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MCwgeTApO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IFIubGVuZ3RoOyBpIDwgbGVuIDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByID0gUltpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAzNjAgKiBuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzaW4oayAvIG4gKiBqICUgMzYwICogcmFkaWFuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBjb3MoaiAqIHJhZGlhbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICsgeDA7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogc2luKGsgLyBuICogaiAlIDM2MCAqIHJhZGlhbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogc2luKGogKiByYWRpYW4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICArIHkwO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9Sb3NlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOato+Wkmui+ueW9ojxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLklzb2dvblxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgaXNvZ29uID0gbmV3IG5vZGUuSXNvZ29uKHtcclxuICogICAgICAgICAgIHNoYXBlOiB7cjo0MCwgIG46OX0sICAvLyBy5Y2K5b6EIG7lh6DkuKrovrlcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw1MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChpc29nb24pO1xyXG4gKi9cclxuXHJcbiAgICB2YXIgUEkgPSBNYXRoLlBJO1xyXG4gICAgdmFyIHNpbiA9IE1hdGguc2luO1xyXG4gICAgdmFyIGNvcyA9IE1hdGguY29zO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Zsb3dOb2RlJykuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgdHlwZTogJ0lzb2dvbicsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnI9MCDljYrlvoRcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLm49MCDlh6DkuKrovrlcclxuICAgICAgICAgKi9cclxuICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIHg6IDAsIHk6IDAsXHJcbiAgICAgICAgICAgIHI6IDAsIG46IDBcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gc2hhcGUubjtcclxuICAgICAgICAgICAgaWYgKCFuIHx8IG4gPCAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcclxuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55O1xyXG4gICAgICAgICAgICB2YXIgciA9IHNoYXBlLnI7XHJcblxyXG4gICAgICAgICAgICB2YXIgZFN0ZXAgPSAyICogUEkgLyBuO1xyXG4gICAgICAgICAgICB2YXIgZGVnID0gLVBJIC8gMjtcclxuXHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHIgKiBjb3MoZGVnKSwgeSArIHIgKiBzaW4oZGVnKSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlbmQgPSBuIC0gMTsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBkZWcgKz0gZFN0ZXA7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyByICogY29zKGRlZyksIHkgKyByICogc2luKGRlZykpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4vKipcclxuICogQG1ldGhvZCBleHRlbmRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvSXNvZ29uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOWkmui+ueW9ojxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLlBvbHlnb25cclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93Lm5vZGVcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgdmFyIHBvbHlnb24gPSBuZXcgbm9kZS5Qb2x5Z29uKHtcclxuICogICAgICAgICAgIHNoYXBlOiB7cG9pbnRzOltbODUuMjc1LDBdLCBbMTAwLDI1LjQxXSwgWzg1LjI3NSw1MC44MjFdLCBbMTQuMTM4LDUwLjgyMV0sIFswLDI1LjQxXSwgWzE0LjEzOCwwXV19LCAgLy8gcuWNiuW+hCBu5Yeg5Liq6L65XHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbNjAsNjBdXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQocG9seWdvbik7XHJcbiAqL1xyXG5cclxuICAgIHZhciBwb2x5SGVscGVyID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seScpO1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpLmV4dGVuZCh7XHJcblxyXG4gICAgICAgdHlwZTogJ1BvbHlnb24nLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gc2hhcGUg5b2i54q25Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7QXJyYXl9IHNoYXBlLnBvaW50cz1udWxsIOWkmui+ueW9oueCueeahOWdkOaghyDlj6/ku6Xku45BSeS4reiOt+WPluOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcnxTdHJpbmd8Qm9vbGVhbn0gW3NoYXBlLnNtb290aD1mYWxzZV0g5piv5ZCm5bmz5ruR5puy57q/5pi+56S644CC5aaC5p6c5Li6IG51bWJlcu+8muihqOekuui0neWhnuWwlCAoYmV6aWVyKSDlt67lgLzlubPmu5HvvIxzbW9vdGgg5oyH5a6a5LqG5bmz5ruR562J57qn77yM6IyD5Zu0IFswLCAxXTvlpoLmnpzkuLogJ3NwbGluZSfvvJrooajnpLogQ2F0bXVsbC1Sb20gc3BsaW5lIOW3ruWAvOW5s+a7kVxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUuc21vb3RoQ29uc3RyYWludD1udWxsIOaYr+WQpuWwhuW5s+a7keabsue6v+e6puadn+WcqOWMheWbtOebkuS4reOAgnNtb290aCDkuLogbnVtYmVy77yIYmV6aWVy77yJ5pe255Sf5pWIXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgcG9pbnRzOiBudWxsLFxyXG5cclxuICAgICAgICAgICAgc21vb3RoOiBmYWxzZSxcclxuXHJcbiAgICAgICAgICAgIHNtb290aENvbnN0cmFpbnQ6IG51bGxcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XHJcbiAgICAgICAgICAgIHBvbHlIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1BvbHlnb24uanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog55u057q/PGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93Lm5vZGUuTGluZVxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgbGluZSA9IG5ldyBub2RlLkxpbmUoe1xyXG4gKiAgICAgICAgICAgc2hhcGU6IHt4MTo2MCwgIHkxOjYwLCB4MjoxMDAsIHkyOjEwMH0sICAvLyB4IOi1t+eCuSB557uI54K5XHJcbiAqICAgICAgICAgICBzdHlsZToge2xpbmVXaWR0aDozfVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKGxpbmUpO1xyXG4gKi9cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAnTGluZScsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLngxPTAg6LW35aeL54K555qE5qiq5Z2Q5qCH5YC844CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS55MT0wIOi1t+Wni+eCueeahOe6teWdkOagh+WAvOOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUueDI9MCDnu4jmraLngrnnmoTmqKrlnZDmoIflgLzjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnkyPTAg57uI5q2i54K555qE57q15Z2Q5qCH5YC844CCXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgLy8gU3RhcnQgcG9pbnRcclxuICAgICAgICAgICAgeDE6IDAsXHJcbiAgICAgICAgICAgIHkxOiAwLFxyXG4gICAgICAgICAgICAvLyBFbmQgcG9pbnRcclxuICAgICAgICAgICAgeDI6IDAsXHJcbiAgICAgICAgICAgIHkyOiAwLFxyXG5cclxuICAgICAgICAgICAgcGVyY2VudDogMVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxyXG4gICAgICAgICAgICBmaWxsOiBudWxsXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgeDEgPSBzaGFwZS54MTtcclxuICAgICAgICAgICAgdmFyIHkxID0gc2hhcGUueTE7XHJcbiAgICAgICAgICAgIHZhciB4MiA9IHNoYXBlLngyO1xyXG4gICAgICAgICAgICB2YXIgeTIgPSBzaGFwZS55MjtcclxuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICB4MiA9IHgxICogKDEgLSBwZXJjZW50KSArIHgyICogcGVyY2VudDtcclxuICAgICAgICAgICAgICAgIHkyID0geTEgKiAoMSAtIHBlcmNlbnQpICsgeTIgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgcG9pbnQgYXQgcGVyY2VudFxyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxyXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBvaW50QXQ6IGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBzaGFwZS54MSAqICgxIC0gcCkgKyBzaGFwZS54MiAqIHAsXHJcbiAgICAgICAgICAgICAgICBzaGFwZS55MSAqICgxIC0gcCkgKyBzaGFwZS55MiAqIHBcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9MaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXHJcbiAqIOaLhue6vzxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLlBvbHlsaW5lXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciBwb2x5bGluZSA9IG5ldyBub2RlLlBvbHlsaW5lKHtcclxuICogICAgICAgICAgIHNoYXBlOiB7cG9pbnRzOltbNTcsMTM4XSxbOTUsMTg0XSxbMTE1LDE2Nl0sWzE1MSwxODRdIF19XHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQocG9seWxpbmUpO1xyXG4gKi9cclxuXHJcbiAgICB2YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3BvbHknKTtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdQb2x5bGluZScsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtBcnJheX0gc2hhcGUucG9pbnRzPW51bGwg5ouG57q/54K555qE5Z2Q5qCHIOWPr+S7peS7jkFJ5Lit6I635Y+W44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfFN0cmluZ3xCb29sZWFufSBbc2hhcGUuc21vb3RoPWZhbHNlXSDmmK/lkKblubPmu5Hmm7Lnur/mmL7npLrjgILlpoLmnpzkuLogbnVtYmVy77ya6KGo56S66LSd5aGe5bCUIChiZXppZXIpIOW3ruWAvOW5s+a7ke+8jHNtb290aCDmjIflrprkuoblubPmu5HnrYnnuqfvvIzojIPlm7QgWzAsIDFdO+WmguaenOS4uiAnc3BsaW5lJ++8muihqOekuiBDYXRtdWxsLVJvbSBzcGxpbmUg5beu5YC85bmz5ruRXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5zbW9vdGhDb25zdHJhaW50PW51bGwg5piv5ZCm5bCG5bmz5ruR5puy57q/57qm5p2f5Zyo5YyF5Zu055uS5Lit44CCc21vb3RoIOS4uiBudW1iZXLvvIhiZXppZXLvvInml7bnlJ/mlYhcclxuICAgICAgICAgKi9cclxuICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICBwb2ludHM6IG51bGwsXHJcblxyXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgc21vb3RoQ29uc3RyYWludDogbnVsbFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxyXG5cclxuICAgICAgICAgICAgZmlsbDogbnVsbFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL1BvbHlsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXHJcbiAqIOi0neWhnuWwlOabsue6vzxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLkJlemllckN1cnZlXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciBiZXppZXJDdXJ2ZSA9IG5ldyBub2RlLkJlemllckN1cnZlKHtcclxuICogICAgICAgICAgIHNoYXBlOiB7eDE6MCwgeTE6MTAwLCBjcHgxOjAsIGNweTE6MCwgY3B4MjowLCBjcHkyOjAsIHgyOjEwMCwgeTI6MH0sXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjogWzYwLCA2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChiZXppZXJDdXJ2ZSk7XHJcbiAqL1xyXG5cclxuXHJcbiAgICB2YXIgY3VydmVUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9jdXJ2ZScpO1xyXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xyXG4gICAgdmFyIHF1YWRyYXRpY1N1YmRpdmlkZSA9IGN1cnZlVG9vbC5xdWFkcmF0aWNTdWJkaXZpZGU7XHJcbiAgICB2YXIgY3ViaWNTdWJkaXZpZGUgPSBjdXJ2ZVRvb2wuY3ViaWNTdWJkaXZpZGU7XHJcbiAgICB2YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZVRvb2wucXVhZHJhdGljQXQ7XHJcbiAgICB2YXIgY3ViaWNBdCA9IGN1cnZlVG9vbC5jdWJpY0F0O1xyXG4gICAgdmFyIHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IGN1cnZlVG9vbC5xdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XHJcbiAgICB2YXIgY3ViaWNEZXJpdmF0aXZlQXQgPSBjdXJ2ZVRvb2wuY3ViaWNEZXJpdmF0aXZlQXQ7XHJcblxyXG4gICAgdmFyIG91dCA9IFtdO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNvbWVWZWN0b3JBdChzaGFwZSwgdCwgaXNUYW5nZW50KSB7XHJcbiAgICAgICAgdmFyIGNweDIgPSBzaGFwZS5jcHgyO1xyXG4gICAgICAgIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcclxuICAgICAgICBpZiAoY3B4MiA9PT0gbnVsbCB8fCBjcHkyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUuY3B4Miwgc2hhcGUueDIsIHQpLFxyXG4gICAgICAgICAgICAgICAgKGlzVGFuZ2VudCA/IGN1YmljRGVyaXZhdGl2ZUF0IDogY3ViaWNBdCkoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLmNweTIsIHNoYXBlLnkyLCB0KVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLngyLCB0KSxcclxuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLnkyLCB0KVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdCZXppZXJDdXJ2ZScsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLngxPTAg6LW35aeL54K555qE5qiq5Z2Q5qCH5YC844CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS55MT0wIOi1t+Wni+eCueeahOe6teWdkOagh+WAvOOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUueDI9MCDnu4jmraLngrnnmoTmqKrlnZDmoIflgLzjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnkyPTAg57uI5q2i54K555qE57q15Z2Q5qCH5YC844CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5jcHgxPTAg5o6n5Yi254K555qE5qiq5Z2Q5qCH5YC844CCXHJcbiAgICAgICAgICogQGNmZyB7Qm9vbGVhbn0gc2hhcGUuY3B4Mj0wIOaOp+WItueCueeahOe6teWdkOagh+WAvOOAglxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIHgxOiAwLFxyXG4gICAgICAgICAgICB5MTogMCxcclxuICAgICAgICAgICAgeDI6IDAsXHJcbiAgICAgICAgICAgIHkyOiAwLFxyXG4gICAgICAgICAgICBjcHgxOiAwLFxyXG4gICAgICAgICAgICBjcHkxOiAwLFxyXG5cclxuICAgICAgICAgICAgLy8gQ3VydmUgc2hvdyBwZXJjZW50LCBmb3IgYW5pbWF0aW5nXHJcbiAgICAgICAgICAgIHBlcmNlbnQ6IDFcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcclxuICAgICAgICAgICAgZmlsbDogbnVsbFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuICAgICAgICAgICAgdmFyIHgxID0gc2hhcGUueDE7XHJcbiAgICAgICAgICAgIHZhciB5MSA9IHNoYXBlLnkxO1xyXG4gICAgICAgICAgICB2YXIgeDIgPSBzaGFwZS54MjtcclxuICAgICAgICAgICAgdmFyIHkyID0gc2hhcGUueTI7XHJcbiAgICAgICAgICAgIHZhciBjcHgxID0gc2hhcGUuY3B4MTtcclxuICAgICAgICAgICAgdmFyIGNweTEgPSBzaGFwZS5jcHkxO1xyXG4gICAgICAgICAgICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XHJcbiAgICAgICAgICAgIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcclxuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xyXG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY3B4MiA9PSBudWxsIHx8IGNweTIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSwgY3B4MSwgeDIsIHBlcmNlbnQsIG91dFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3B4MSA9IG91dFsxXTtcclxuICAgICAgICAgICAgICAgICAgICB4MiA9IG91dFsyXTtcclxuICAgICAgICAgICAgICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxLCBjcHkxLCB5MiwgcGVyY2VudCwgb3V0XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBjcHkxID0gb3V0WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHkyID0gb3V0WzJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxyXG4gICAgICAgICAgICAgICAgICAgIGNweDEsIGNweTEsXHJcbiAgICAgICAgICAgICAgICAgICAgeDIsIHkyXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3ViaWNTdWJkaXZpZGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxLCBjcHgxLCBjcHgyLCB4MiwgcGVyY2VudCwgb3V0XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBjcHgxID0gb3V0WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNweDIgPSBvdXRbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBvdXRbM107XHJcbiAgICAgICAgICAgICAgICAgICAgY3ViaWNTdWJkaXZpZGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxLCBjcHkxLCBjcHkyLCB5MiwgcGVyY2VudCwgb3V0XHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBjcHkxID0gb3V0WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNweTIgPSBvdXRbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBvdXRbM107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcclxuICAgICAgICAgICAgICAgICAgICBjcHgxLCBjcHkxLFxyXG4gICAgICAgICAgICAgICAgICAgIGNweDIsIGNweTIsXHJcbiAgICAgICAgICAgICAgICAgICAgeDIsIHkyXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcclxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBwb2ludEF0OiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIGZhbHNlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgdGFuZ2VudCBhdCBwZXJjZW50XHJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0XHJcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGFuZ2VudEF0OiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICB2YXIgcCA9IHNvbWVWZWN0b3JBdCh0aGlzLnNoYXBlLCB0LCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZlYzIubm9ybWFsaXplKHAsIHApO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0JlemllckN1cnZlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXHJcbiAqIOWchuW8pzxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLkFyY1xyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubm9kZVxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICB2YXIgYXJjID0gbmV3IG5vZGUuQXJjKHtcclxuICogICAgICAgICAgIHNoYXBlOiB7cjo1MCwgc3RhcnRBbmdsZTowLCBlbmRBbmdsZToxLjIqTWF0aC5QSX0sXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjogWzYwLCA2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChhcmMpO1xyXG4gKi9cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAnQXJjJyxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IHNoYXBlIOW9oueKtuWPguaVsFxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUucj0wIOWNiuW+hOOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUuc3RhcnRBbmdsZT0wIOW8gOWni+W8p+W6puOAglxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gc2hhcGUuZW5kQW5nbGU9TWF0aC5QSSAqIDIgIOe7k+adn+W8p+W6puOAglxyXG4gICAgICAgICAqIEBjZmcge0Jvb2xlYW59IHNoYXBlLmNsb2Nrd2lzZT10cnVlIOaYr+WQpumhuuaXtumSiOOAglxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNoYXBlOiB7XHJcbiAgICAgICAgICAgIGN4OiAwLFxyXG4gICAgICAgICAgICBjeTogMCxcclxuICAgICAgICAgICAgcjogMCxcclxuICAgICAgICAgICAgc3RhcnRBbmdsZTogMCxcclxuICAgICAgICAgICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxyXG4gICAgICAgICAgICBjbG9ja3dpc2U6IHRydWVcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzdHlsZToge1xyXG5cclxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXHJcblxyXG4gICAgICAgICAgICBmaWxsOiBudWxsXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS5jeDtcclxuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcclxuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xyXG4gICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcclxuICAgICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcclxuXHJcbiAgICAgICAgICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFjbG9ja3dpc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0FyYy5qc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8qKlxyXG4gKiDmmJ/lvaI8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5TdGFyXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIikpO1xyXG4gKiAgICAgICB2YXIgc3RhciA9IG5ldyBub2RlLlN0YXIoe1xyXG4gKiAgICAgICAgICAgc2hhcGU6IHtuOjcsIHI6MzB9LCAgLy9y5Y2K5b6EIG7lh6DkuKrop5JcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChzdGFyKTtcclxuICovXHJcblxyXG4gICAgdmFyIFBJID0gTWF0aC5QSTtcclxuXHJcbiAgICB2YXIgY29zID0gTWF0aC5jb3M7XHJcbiAgICB2YXIgc2luID0gTWF0aC5zaW47XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKS5leHRlbmQoe1xyXG5cclxuICAgICAgICB0eXBlOiAnU3RhcicsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLm49MyDlh6DkuKrop5LjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnI9MCDlpJbljYrlvoTjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnIwPTAg5YaF5Y2K5b6E44CCXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICBuOiAzLFxyXG4gICAgICAgICAgICByMDogbnVsbCxcclxuICAgICAgICAgICAgcjogMFxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBuID0gc2hhcGUubjtcclxuICAgICAgICAgICAgaWYgKCFuIHx8IG4gPCAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XHJcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUuY3k7XHJcbiAgICAgICAgICAgIHZhciByID0gc2hhcGUucjtcclxuICAgICAgICAgICAgdmFyIHIwID0gc2hhcGUucjA7XHJcblxyXG4gICAgICAgICAgICAvLyDlpoLmnpzmnKrmjIflrprlhoXpg6jpobbngrnlpJbmjqXlnIbljYrlvoTvvIzliJnoh6rliqjorqHnrpdcclxuICAgICAgICAgICAgaWYgKHIwID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHIwID0gbiA+IDRcclxuICAgICAgICAgICAgICAgICAgICAvLyDnm7jpmpTnmoTlpJbpg6jpobbngrnnmoTov57nur/nmoTkuqTngrnvvIxcclxuICAgICAgICAgICAgICAgICAgICAvLyDooqvlj5bkuLrlhoXpg6jkuqTngrnvvIzku6XmraTorqHnrpdyMFxyXG4gICAgICAgICAgICAgICAgICAgID8gciAqIGNvcygyICogUEkgLyBuKSAvIGNvcyhQSSAvIG4pXHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5LqM5LiJ5Zub6KeS5pif55qE54m55q6K5aSE55CGXHJcbiAgICAgICAgICAgICAgICAgICAgOiByIC8gMztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRTdGVwID0gUEkgLyBuO1xyXG4gICAgICAgICAgICB2YXIgZGVnID0gLVBJIC8gMjtcclxuICAgICAgICAgICAgdmFyIHhTdGFydCA9IHggKyByICogY29zKGRlZyk7XHJcbiAgICAgICAgICAgIHZhciB5U3RhcnQgPSB5ICsgciAqIHNpbihkZWcpO1xyXG4gICAgICAgICAgICBkZWcgKz0gZFN0ZXA7XHJcblxyXG4gICAgICAgICAgICAvLyDorrDlvZXovrnnlYzngrnvvIznlKjkuo7liKTmlq1pbnNpZGVcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4U3RhcnQsIHlTdGFydCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlbmQgPSBuICogMiAtIDEsIHJpOyBpIDwgZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJpID0gaSAlIDIgPT09IDAgPyByMCA6IHI7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyByaSAqIGNvcyhkZWcpLCB5ICsgcmkgKiBzaW4oZGVnKSk7XHJcbiAgICAgICAgICAgICAgICBkZWcgKz0gZFN0ZXA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9TdGFyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXHJcbiAqIOaXi+i9ruabsue6vzxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5ub2RlLlRyb2Nob2lkXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIikpO1xyXG4gKiAgICAgICB2YXIgdHJvY2hvaWQgPSBuZXcgbm9kZS5Ucm9jaG9pZCh7XHJcbiAqICAgICAgICAgICBzaGFwZToge3I6NTAsIHIwOjM1LCBkOjMwLCBsb2NhdGlvbjpudWxsfSwgIC8vcuWNiuW+hCBu5Yeg5Liq6KeSXHJcbiAqICAgICAgICAgICBwb3NpdGlvbjpbNjAsNjBdLFxyXG4gKiAgICAgICAgICAgdG9vbHRpcDogXCLml4vova7mm7Lnur9cIlxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgZmlzaFRvcG8uYWRkKHRyb2Nob2lkKTtcclxuICovXHJcblxyXG5cclxuICAgIHZhciBjb3MgPSBNYXRoLmNvcztcclxuICAgIHZhciBzaW4gPSBNYXRoLnNpbjtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIHR5cGU6ICdUcm9jaG9pZCcsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBzaGFwZSDlvaLnirblj4LmlbBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnI9MCDlpJbljYrlvoTjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLnIwPTAg5YaF5Y2K5b6E44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBzaGFwZS5kPTBcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IHNoYXBlLmxvY2F0aW9uPSdvdXQnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgY3g6IDAsXHJcbiAgICAgICAgICAgIGN5OiAwLFxyXG4gICAgICAgICAgICByOiAwLFxyXG4gICAgICAgICAgICByMDogMCxcclxuICAgICAgICAgICAgZDogMCxcclxuICAgICAgICAgICAgbG9jYXRpb246ICdvdXQnXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXHJcblxyXG4gICAgICAgICAgICBmaWxsOiBudWxsXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xyXG4gICAgICAgICAgICB2YXIgeDE7XHJcbiAgICAgICAgICAgIHZhciB5MTtcclxuICAgICAgICAgICAgdmFyIHgyO1xyXG4gICAgICAgICAgICB2YXIgeTI7XHJcbiAgICAgICAgICAgIHZhciBSID0gc2hhcGUucjtcclxuICAgICAgICAgICAgdmFyIHIgPSBzaGFwZS5yMDtcclxuICAgICAgICAgICAgdmFyIGQgPSBzaGFwZS5kO1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0WCA9IHNoYXBlLmN4O1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0WSA9IHNoYXBlLmN5O1xyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBzaGFwZS5sb2NhdGlvbiA9PSAnb3V0JyA/IDEgOiAtMTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzaGFwZS5sb2NhdGlvbiAmJiBSIDw9IHIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG51bSA9IDA7XHJcbiAgICAgICAgICAgIHZhciBpID0gMTtcclxuICAgICAgICAgICAgdmFyIHRoZXRhO1xyXG5cclxuICAgICAgICAgICAgeDEgPSAoUiArIGRlbHRhICogcikgKiBjb3MoMClcclxuICAgICAgICAgICAgICAgIC0gZGVsdGEgKiBkICogY29zKDApICsgb2Zmc2V0WDtcclxuICAgICAgICAgICAgeTEgPSAoUiArIGRlbHRhICogcikgKiBzaW4oMClcclxuICAgICAgICAgICAgICAgIC0gZCAqIHNpbigwKSArIG9mZnNldFk7XHJcblxyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XHJcblxyXG4gICAgICAgICAgICAvLyDorqHnrpfnu5PmnZ/ml7bnmoRpXHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIG51bSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlICgociAqIG51bSkgJSAoUiArIGRlbHRhICogcikgIT09IDApO1xyXG5cclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgdGhldGEgPSBNYXRoLlBJIC8gMTgwICogaTtcclxuICAgICAgICAgICAgICAgIHgyID0gKFIgKyBkZWx0YSAqIHIpICogY29zKHRoZXRhKVxyXG4gICAgICAgICAgICAgICAgICAgICAtIGRlbHRhICogZCAqIGNvcygoUiAvIHIgKyAgZGVsdGEpICogdGhldGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICsgb2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgIHkyID0gKFIgKyBkZWx0YSAqIHIpICogc2luKHRoZXRhKVxyXG4gICAgICAgICAgICAgICAgICAgICAtIGQgKiBzaW4oKFIgLyByICsgZGVsdGEpICogdGhldGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICsgb2Zmc2V0WTtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoaSA8PSAociAqIG51bSkgLyAoUiArIGRlbHRhICogcikgKiAzNjApO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGV4dGVuZFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbm9kZS9Ucm9jaG9pZC5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDot6/lvoQ8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5QYXRoXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciBwYXRoID0gbmV3IG5vZGUuUGF0aCh7XHJcbiAqICAgICAgICAgICBwYXRoRGF0YTogJ005IDBsOCA4LTE3IDE3IDcgNyAxNy0xNyA4IDh2LTIzaC0yM3onLFxyXG4gKiAgICAgICAgICAgcmVjdDoge3g6MCx5OjAsd2lkdGg6MzAsaGVpZ2h0OjMwfSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOiBbNjAsNjBdXHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgICBmaXNoVG9wby5hZGQocGF0aCk7XHJcbiAqL1xyXG5cclxuICAgIHZhciBwYXRoVG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvcGF0aCcpO1xyXG4gICAgdmFyIERyYWdnYWJsZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZScpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIGZsb3dOb2RlID0gcmVxdWlyZSgnLi9mbG93Tm9kZScpO1xyXG5cclxuICAgIGZ1bmN0aW9uIFpQYXRoKG9wdHMpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IG9wdGlvbnMg5Y+C5pWwXHJcbiAgICAgICAgICogQGNmZyB7U3RyaW5nfSBvcHRpb25zLnBhdGhEYXRhIHBhdGjmlbDmja7jgIJcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IG9wdGlvbnMucmVjdCDlm77lvaLnmoTlpKflsI/jgIJcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IG9wdGlvbnMucmVjdC53aWR0aCDlm77lvaLnmoTlrr3luqbjgIJcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IG9wdGlvbnMucmVjdC5oZWlnaHQg5Zu+5b2i55qE6auY5bqm44CCXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBbb3B0aW9ucy5sYXlvdXQ9bnVsbF0g6buY6K6k5Li6bnVsbCAg5LuF5pSv5oyBXCJjZW50ZXJcIlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBzdHlsZTp7IGZpbGw6ICdub25lJyxzdHJva2U6ICcjMmMyYzJjJ30sXHJcbiAgICAgICAgICAgIHJlY3Q6e3g6MCx5OjAsd2lkdGg6MCxoZWlnaHQ6MH0sXHJcbiAgICAgICAgICAgIHJlY3RIb3ZlcjogdHJ1ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBhdGhEYXRhID0gb3B0cy5wYXRoRGF0YTtcclxuICAgICAgICB2YXIgbW9kZWwgPSBmbG93Tm9kZS5nZW5Nb2RlbChcIlBhdGhcIiwgb3B0cyk7XHJcbiAgICAgICAgZGVsZXRlIG9wdHMucGF0aERhdGE7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0genJVdGlsLm1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRzLCB0cnVlKTtcclxuICAgICAgICB2YXIgcGF0aCA9IHBhdGhUb29sLmNyZWF0ZUZyb21TdHJpbmcocGF0aERhdGEsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgcGF0aC5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIERyYWdnYWJsZS5jYWxsKHBhdGgpO1xyXG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5vcHRpb25zLnJlY3Q7XHJcbiAgICAgICAgdmFyIGxheW91dCA9IG9wdHMubGF5b3V0O1xyXG4gICAgICAgIGlmIChyZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhc3BlY3QgPSBib3VuZGluZ1JlY3Qud2lkdGggLyBib3VuZGluZ1JlY3QuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGxheW91dCA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNldCByZWN0IHRvIGNlbnRlciwga2VlcCB3aWR0aCAvIGhlaWdodCByYXRpby5cclxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlY3QuaGVpZ2h0ICogYXNwZWN0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodDtcclxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCA8PSByZWN0LndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSByZWN0LnggKyByZWN0LndpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHZhciBjeSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMjtcclxuXHJcbiAgICAgICAgICAgICAgICByZWN0LnggPSBjeCAtIHdpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHJlY3QueSA9IGN5IC0gaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgIHJlY3Qud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgIHJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVBhdGgocGF0aCwgcmVjdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH1cclxuXHJcbiAgICBaUGF0aC5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBaUGF0aCxcclxuXHJcbiAgICAgICAgdHlwZTogJ1BhdGgnLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc2l6ZSBhIHBhdGggdG8gZml0IHRoZSByZWN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVzaXplUGF0aDogZnVuY3Rpb24gKHBhdGgsIHJlY3QpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcGF0aC5hcHBseVRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcGF0aFJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtID0gcGF0aFJlY3QuY2FsY3VsYXRlVHJhbnNmb3JtKHJlY3QpO1xyXG5cclxuICAgICAgICAgICAgICAgIHBhdGguYXBwbHlUcmFuc2Zvcm0obSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgenJVdGlsLmluaGVyaXRzKFpQYXRoLCBEcmFnZ2FibGUpO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBaUGF0aDtcclxuXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBleHRlbmRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL25vZGUvUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDlm77lvaLmjInpkq48YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubm9kZS5JY29uQnV0dG9uXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5ub2RlXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIHZhciBpY29uQnV0dG9uICAgPSBuZXcgbm9kZS5JY29uQnV0dG9uKHtcclxuICogICAgICAgICAgdGl0bGU6J0ljb25CdXR0b24nLFxyXG4gKiAgICAgICAgICBpY29uOidwYXRoOi8vTTQzMi40NSw1OTUuNDQ0YzAsMi4xNzctNC42NjEsNi44Mi0xMS4zMDUsNi44MmMtNi40NzUsMC0xMS4zMDYtNC41NjctMTEuMzA2LTYuODJzNC44NTItNi44MTIsMTEuMzA2LTYuODEyQzQyNy44NDEsNTg4LjYzMiw0MzIuNDUyLDU5My4xOTEsNDMyLjQ1LDU5NS40NDRMNDMyLjQ1LDU5NS40NDR6IE00MjEuMTU1LDU4OS44NzZjLTMuMDA5LDAtNS40NDgsMi40OTUtNS40NDgsNS41NzJzMi40MzksNS41NzIsNS40NDgsNS41NzJjMy4wMSwwLDUuNDQ5LTIuNDk1LDUuNDQ5LTUuNTcyQzQyNi42MDQsNTkyLjM3MSw0MjQuMTY1LDU4OS44NzYsNDIxLjE1NSw1ODkuODc2TDQyMS4xNTUsNTg5Ljg3NnogTTQyMS4xNDYsNTkxLjg5MWMtMS45MTYsMC0zLjQ3LDEuNTg5LTMuNDcsMy41NDljMCwxLjk1OSwxLjU1NCwzLjU0OCwzLjQ3LDMuNTQ4czMuNDY5LTEuNTg5LDMuNDY5LTMuNTQ4QzQyNC42MTQsNTkzLjQ3OSw0MjMuMDYyLDU5MS44OTEsNDIxLjE0Niw1OTEuODkxTDQyMS4xNDYsNTkxLjg5MXpNNDIxLjE0Niw1OTEuODkxJyxcclxuICogICAgICAgICAgaXRlbVNpemU6NTAsXHJcbiAqICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF1cclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChpY29uQnV0dG9uKTtcclxuICovXHJcblxyXG5cclxuXHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBmbG93Tm9kZSA9IHJlcXVpcmUoJy4vZmxvd05vZGUnKTtcclxuXHJcbiAgICBmdW5jdGlvbiBJY29uQnV0dG9uKG9wdHMpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBvcHRpb25zIOaehOmAoOWPguaVsFxyXG4gICAgICAgICAqIEBjZmcge1N0cmluZ30gb3B0aW9ucy50aXRsZT1cIlwiIOm8oOagh+enu+S4iuWOu+aYvuekuueahOaWh+Wtl1xyXG4gICAgICAgICAqIEBjZmcge1N0cmluZ30gb3B0aW9ucy5pY29uPVwiXCIgSWNvbiDnmoQgcGF0aCDlrZfnrKbkuLLvvIzmlK/mjIHkvb/nlKjoh6rlrprkuYnnmoQgc3ZnIHBhdGgg5L2c5Li6IGljb27vvIzmoLzlvI/lj4Lop4EgW1NWRyBQYXRoRGF0YV0oaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhKeOAguWPr+S7peS7jiBBZG9iZSBJbGx1c3RyYXRvciDnrYnlt6XlhbfnvJbovpHlr7zlh7rjgIJcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IG9wdGlvbnMuaXRlbVNpemU9MTUgIGljb24g55qE5aSn5bCPXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBvcHRpb25zLmljb25TdHlsZSAg5Zu+5qCH5qC35byPXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBvcHRpb25zLmljb25TdHlsZS5ub3JtYWwg5q2j5bi455qE5qC35byPXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBvcHRpb25zLmljb25TdHlsZS5ub3JtYWwuc3Ryb2tlPScjNjY2JyDmraPluLjnmoTmoLflvI/vvIjmj4/ovrnoibLvvIlcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IG9wdGlvbnMuaWNvblN0eWxlLm5vcm1hbC5maWxsPSdub25lJyDmraPluLjnmoTmoLflvI/vvIjloavlhYXoibLvvIlcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IG9wdGlvbnMuaWNvblN0eWxlLmVtcGhhc2lzIOmrmOS6rueKtuaAgeS4i+eahOagt+W8j1xyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gb3B0aW9ucy5pY29uU3R5bGUuZW1waGFzaXMuc3Ryb2tlPScjNjY2JyDpq5jkuq7nirbmgIHkuIvnmoTmoLflvI/vvIjmj4/ovrnoibLvvIlcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IG9wdGlvbnMuaWNvblN0eWxlLmVtcGhhc2lzLmZpbGw9J25vbmUnIOmrmOS6rueKtuaAgeS4i+eahOagt+W8j++8iOWhq+WFheiJsu+8iVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyNjY2MnLFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6ZmFsc2UsXHJcbiAgICAgICAgICAgIHNlbGVjdGFibGU6ZmFsc2UsXHJcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAwLFxyXG4gICAgICAgICAgICBpdGVtU2l6ZTogMTUsXHJcbiAgICAgICAgICAgIHNob3dUaXRsZTogdHJ1ZSxcclxuICAgICAgICAgICAgaWNvbjpcIlwiLCAgLy9JY29uIOeahCBwYXRoIOWtl+espuS4su+8jOaUr+aMgeS9v+eUqOiHquWumuS5ieeahCBzdmcgcGF0aCDkvZzkuLogaWNvbu+8jOagvOW8j+WPguingSBTVkcgUGF0aERhdGHjgILlj6/ku6Xku44gQWRvYmUgSWxsdXN0cmF0b3Ig562J5bel5YW357yW6L6R5a+85Ye644CCXHJcbiAgICAgICAgICAgIGljb25TdHlsZToge1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzY2NicsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW1waGFzaXM6IHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICcjM0U5OGM1J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdHMsIHRydWUpO1xyXG5cclxuICAgICAgICB0aGlzLm1vZGVsID0gZmxvd05vZGUuZ2VuTW9kZWwoXCJJY29uQnV0dG9uXCIsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgZ3JhcGhpYy5Hcm91cC5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgIH1cclxuICAgIEljb25CdXR0b24ucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBJY29uQnV0dG9uLFxyXG4gICAgICAgIHR5cGU6IFwiSWNvbkJ1dHRvblwiLFxyXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbm9ybWFsU3R5bGUgPSB0aGlzLm9wdGlvbnMuaWNvblN0eWxlLm5vcm1hbDtcclxuICAgICAgICAgICAgdmFyIGhvdmVyU3R5bGUgPSB0aGlzLm9wdGlvbnMuaWNvblN0eWxlLmVtcGhhc2lzO1xyXG4gICAgICAgICAgICB2YXIgaXRlbVNpemUgPSB0aGlzLm9wdGlvbnMuaXRlbVNpemU7XHJcbiAgICAgICAgICAgIHZhciBpY29uID0gdGhpcy5vcHRpb25zLmljb247XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHtcclxuICAgICAgICAgICAgICAgIHg6IC1pdGVtU2l6ZSAvIDIsXHJcbiAgICAgICAgICAgICAgICB5OiAtaXRlbVNpemUgLyAyLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGl0ZW1TaXplLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBpdGVtU2l6ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgcGF0aCA9IGljb24uaW5kZXhPZignaW1hZ2U6Ly8nKSA9PT0gMCA/XHJcbiAgICAgICAgICAgICAgICAoXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaW1hZ2UgPSBpY29uLnNsaWNlKDgpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBncmFwaGljLkltYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICkgOlxyXG4gICAgICAgICAgICAgICAgZ3JhcGhpYy5tYWtlUGF0aChcclxuICAgICAgICAgICAgICAgICAgICBpY29uLnJlcGxhY2UoJ3BhdGg6Ly8nLCAnJyksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IG5vcm1hbFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3ZlclN0eWxlOiBob3ZlclN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0SG92ZXI6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICdjZW50ZXInXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKHBhdGgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93VGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIHBhdGguX190aXRsZSA9IHRoaXMub3B0aW9ucy50aXRsZTtcclxuICAgICAgICAgICAgICAgIHBhdGgub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCByZXVzZSBhYm92ZSBob3ZlclN0eWxlLCB3aGljaCBtaWdodCBiZSBtb2RpZmllZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRTdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLm9wdGlvbnMudGl0bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb246IGhvdmVyU3R5bGUudGV4dFBvc2l0aW9uIHx8ICdib3R0b20nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEZpbGw6IGhvdmVyU3R5bGUuZmlsbCB8fCBob3ZlclN0eWxlLnN0cm9rZSB8fCAnIzAwMCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IGhvdmVyU3R5bGUudGV4dEFsaWduIHx8ICdjZW50ZXInXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnNldFN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRGaWxsOiBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYXRoLnRyaWdnZXIoJ25vcm1hbCcpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgenJVdGlsLmluaGVyaXRzKEljb25CdXR0b24sIGdyYXBoaWMuR3JvdXApO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBJY29uQnV0dG9uO1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgZXh0ZW5kXHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9ub2RlL0ljb25CdXR0b24uanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKipcclxuICogZmlzaFRvcG9GbG9355qEbGlua+Wvueixoe+8jOahhuaetuaPkOS+m+eahOi/nue6v+mDveaUvuWcqOi/meS4quWvueixoeS4i+OAglxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93LmxpbmtcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5cclxuICAgIHZhciBMaW5rID0gcmVxdWlyZSgnLi9MaW5rJyk7XHJcbiAgICB2YXIgRm9sZCA9IHJlcXVpcmUoJy4vRm9sZCcpO1xyXG4gICAgdmFyIEN1cnZlID0gcmVxdWlyZSgnLi9DdXJ2ZScpO1xyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuICAgIHZhciBmbG93TGluayA9IHt9O1xyXG4gICAgZmxvd0xpbmsuTGluayA9IGZsb3dMaW5rW0Nvbm5lY3Rvci5UWVBFX1NUUkFJR0hUXSA9IExpbms7XHJcbiAgICBmbG93TGluay5Gb2xkID0gZmxvd0xpbmtbQ29ubmVjdG9yLlRZUEVfSkFHR0VEXSA9IEZvbGQ7XHJcbiAgICBmbG93TGluay5DdXJ2ZSA9IGZsb3dMaW5rW0Nvbm5lY3Rvci5UWVBFX0NVUlZFXSA9IEN1cnZlO1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmbG93TGluaztcclxuXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBjb25zdHJ1Y3RvclxyXG4gKiDov57nur/nmoTmnoTpgKDlh73mlbBcclxuICogQHBhcmFtICB7T2JqZWN0fSBzdGFydE5vZGUg5byA5aeL6IqC54K5XHJcbiAqIEBwYXJhbSAge09iamVjdH0gZW5kTm9kZSAgIOe7k+adn+iKgueCuVxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMg57q/5q616YCJ6aG5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zdHlsZV0g6IqC54K555qE5qC35byPXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdHlsZS5saW5lV2lkdGg9MV0g57q/5q6155qE5a695bqmXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZS5saW5lVHlwZT0nc3RyYWlnaHQnXSDnur/mrrXnmoTnsbvlnosgZWcuICdzdHJhaWdodCcsICdqYWdnZWQnLCdjdXJ2ZSdcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN0eWxlLnN0cm9rZT1cIiMwMDAwMDBcIl0g57q/5q6155qE6aKc6Imy5YC8IGVnLiAnIzE1N2NmZicgICdyZ2IoMTIyLDEyMiwxMjIpJ1xyXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMuc3R5bGUubGluZURhc2hdIOiZmue6v+eahOmXtOmalCBlZy4gWzMsM11cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN5bWJvbF0g57q/5q6155qE566t5aS0XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wudHlwZT0nYXJyb3cnXSDnur/mrrXnmoTnrq3lpLTnmoTnsbvlnosg5Y+v6YCJ5YC85Li677yaICdjaXJjbGUnLCAncmVjdCcsICdyb3VuZFJlY3QnLCAndHJpYW5nbGUnLCAnZGlhbW9uZCcsICdwaW4nLCAnYXJyb3cnXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zeW1ib2wuc2l6ZT0xMF0g57q/5q6155qE566t5aS055qE5bC65a+4XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wuY29sb3I9JyMwMDAwMDAnXSDnur/mrrXnmoTnrq3lpLTnmoTpopzoibJcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN5bWJvbC56XSBb566t5aS055qE5bGC57qn77yM6LaK5aSn6LaK5Zyo5YmN6Z2i5pi+56S6XVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN5bWJvbC5ib3RoXSBb5oyH5a6a5piv5ZCm5Zyo6L+e57q/55qE6aaW5LiO5bC+6YO955S7566t5aS0IOm7mOiupOaYr2ZhbHNlXVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudGV4dF0g57q/5q615LiK55qE5paH5a2XXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LnRleHRdIOe6v+auteS4iueahOaWh+Wtl+WGheWuuVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC5jb2xvcl0g57q/5q615LiK55qE5paH5a2X6aKc6ImyXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LnRleHRQb3NdIOaWh+Wtl+S9jee9ruWPr+mAieWAvCAnc3RhcnQnLCdjZW50ZXInLCdlbmQnLOm7mOiupOWAvOS4umNlbnRlclxyXG4gKiBAcGFyYW0ge051bWJlcnxBcnJheX0gW29wdGlvbnMudGV4dC5vZmZzZXRdIOaWh+Wtl+S9jee9ruWBj+enu+mHjyzkuLpudW1iZXLliJnmmK945YGP56e7IGFycmF55YiZ5Li6W3gseV1cclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc10g5L+d55WZIOivt+S9v+eUqG9wdGlvbnMucG9zaXRpb24uZGlyZWN0aW9uIOaMh+Wumue6v+autei1t+Wni+S4jue7iOatoiDlnKjoioLngrnnmoTku4DkuYjkvY3nva4g6buY6K6k5YC85Li6J2xlZnQscmlnaHQnICDlj6/lj5blgLzlm5vkuKrmlrnlkJF0b3AsYm90dG9tLGxlZnQscmlnaHQg5pa55ZCR5Y+v5Yqg5YGP56e76YeP5aaC5aaCIFwibGVmdCsxMCx0b3BcIlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb25dIOaMh+Wumue6v+auteS9jee9rlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucG9zaXRpb24uZGlyZWN0aW9uXSDmjIflrprnur/mrrXotbflp4vkuI7nu4jmraIg5Zyo6IqC54K555qE5LuA5LmI5L2N572uIOm7mOiupOWAvOS4uidsZWZ0LHJpZ2h0JyAg5Y+v5Y+W5YC85Zub5Liq5pa55ZCRdG9wLGJvdHRvbSxsZWZ0LHJpZ2h0IOaWueWQkeWPr+WKoOWBj+enu+mHj+WmguWmgiBcImxlZnQrMTAsdG9wXCJcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLnN0YXJ0T2Zmc2V0XSDnur/mrrXlvIDlp4vkvY3nva7nmoTlgY/np7tcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLmVuZE9mZnNldF0g57q/5q6157uT5p2f5L2N572u55qE5YGP56e7XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbi5lc2NhcGVEaXN0YW5jZV0g5oyH5a6a57q/5q6156ys5LiA5p2h5oqY57q/55qE6ZW/5bqm77yM5pyA5ZCO5LiA5p2h5oqY57q/55qE6ZW/5bqm77yM6buY6K6k5YC85Li6WzMwLCAzMF1cclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uLnBvaW50c10g5LiN5L2/55So6Ieq5Yqo6K6h566XIOaMh+Wumui/nue6v+eahOaKmOeCueS9jee9ruaVsOe7hO+8jOmmluWwvuWPr+S7peS9v+eUqGxlZnQscmlnaHQsdG9wLGJvdHRvbVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZWZmZWN0XSDnur/kuIrliqjmgIHmlYjmnpxcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmVmZmVjdC5zaG93XSDmmK/lkKbmmL7npLrnrq3lpLTliqjmlYhcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVmZmVjdC5wZXJpb2RdIOWKqOaViOenu+WKqOmAn+W6plxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9DaGFuZ2VQb3NpdGlvbl0g6L+e57q/55qE6L+e5o6l54K56ZqPbm9kZeenu+WKqOiHquWKqOWIh+aNouS9jee9ru+8jOm7mOiupOS4umZsYXNlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy56XSDov57nur/nmoTlsYLnuqfvvIzotorlpKfotorlnKjliY3pnaLmmL7npLpcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ1bmRsZU9mZnNldD0zMF0g5ouG57q/5ouQ6KeS5aSE55qE6ZW/5bqmKOeUqOS6jui/nue6v+e7hClcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ1bmRsZUdhcD0yMF0g5aSa57q/5q6155qE6Ze06ZqUKOeUqOS6jui/nue6v+e7hClcclxuICogQHJldHVybiB7T2JqZWN0fSDov5Tlm57liJvlu7rmiJDlip/nmoTov57nur/lr7nosaFcclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgc2V0U3R5bGVcclxuICog5Yib5bu66L+e57q/5ZCO77yM6K6+572u6L+e57q/55qE5qC35byPXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIOWvueW6lOWIm+W7uuiKgueCue+8jOS8oOmAkueahG9wdGlvbnPlj4LmlbBcclxuICovXHJcbi8qKlxyXG4gKiBAbWV0aG9kIG9uXHJcbiAqIOe7keWumuS6i+S7tlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5LqL5Lu25aSE55CG5Ye95pWwXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0g5LiK5LiL5paHXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgb2ZmXHJcbiAqIOino+e7keS6i+S7tlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5LqL5Lu25aSE55CG5Ye95pWwXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2Qgb25lXHJcbiAqIOWNleasoeinpuWPkee7keWumix0cmlnZ2Vy5ZCO6ZSA5q+BXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCDkuovku7blkI1cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDkuovku7blpITnkIblh73mlbBcclxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSDkuIrkuIvmlodcclxuICovXHJcblxyXG4vKipcclxuICogQG1ldGhvZCB0cmlnZ2VyXHJcbiAqIOS6i+S7tuWIhuWPkVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcclxuICovXHJcbi8qKlxyXG4gKiBAZXZlbnQgY2xpY2tcclxuICog5Y2V5Ye75LqL5Lu2XHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqIGZsaW5rLm9uKCdDb25uZWN0b3I6Y2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAqICAgLy9kbyBzb21ldGhpbmdcclxuICogfSlcclxuICogPC9wcmU+XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBldmVudCBkYmxjbGlja1xyXG4gKiDlvZPlj4zlh7vlhYPntKDml7bvvIzkvJrlj5HnlJ8gZGJsY2xpY2sg5LqL5Lu244CCXHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqIGZsaW5rLm9uKCdDb25uZWN0b3I6ZGJsY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAqICAgLy9kbyBzb21ldGhpbmdcclxuICogfSlcclxuICogPC9wcmU+XHJcbiAqL1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGluay9mbG93TGluay5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDnm7Tnur88YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubGluay5MaW5rXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5saW5rXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgbGluayA9IGZpc2hUb3BvRmxvdy5saW5rO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIC8v6IqC54K5XHJcbiAqICAgICAgIGZ1bmN0aW9uIG5ld05vZGUoeCwgeSwgdywgaCkge1xyXG4gKiAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgbm9kZS5SZWN0KHtcclxuICogICAgICAgICAgICAgICBzaGFwZToge3dpZHRoOiB3LGhlaWdodDogaH0sXHJcbiAqICAgICAgICAgICAgICAgcG9zaXRpb246IFt4LCB5XSxcclxuICogICAgICAgICAgICAgICBzdHlsZToge2ZpbGw6IFwiIzE2N0NGRlwifVxyXG4gKiAgICAgICAgICAgfSk7XHJcbiAqICAgICAgICAgICBmaXNoVG9wby5hZGQocmVjdCk7XHJcbiAqICAgICAgICAgICByZXR1cm4gcmVjdDtcclxuICogICAgICAgfVxyXG4gKiAgICAgICAvL+eugOWNlei/nue6v1xyXG4gKiAgICAgICBmdW5jdGlvbiBuZXdMaW5rKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgdGV4dCwgZGFzaGVkUGF0dGVybikge1xyXG4gKiAgICAgICAgICAgdmFyIHNsaW5rID0gbmV3IGxpbmsuTGluayhzdGFydE5vZGUsIGVuZE5vZGUsIHtcclxuICogICAgICAgICAgICAgICBzdHlsZToge2xpbmVEYXNoOiBbZGFzaGVkUGF0dGVybl19LFxyXG4gKiAgICAgICAgICAgICAgIHRleHQ6IHt0ZXh0OiB0ZXh0fVxyXG4gKiAgICAgICAgICAgfSlcclxuICogICAgICAgICAgIGZpc2hUb3BvLmFkZChzbGluayk7XHJcbiAqICAgICAgICAgICByZXR1cm4gc2xpbms7XHJcbiAqICAgICAgIH1cclxuICogICAgICAgdmFyIGZyb20gPSBuZXdOb2RlKDEwMCwgNjAsIDMwLCAzMCk7XHJcbiAqICAgICAgIHZhciB0byA9IG5ld05vZGUoMzAwLCA2MCwgMzAsIDMwKTtcclxuICogICAgICAgbmV3TGluayhmcm9tLCB0bywgJ+iZmue6v+W4pueureWktCcsIDUpO1xyXG4gKi9cclxuXHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIEZsb3cgPSByZXF1aXJlKFwiLi4vRmxvd1wiKTtcclxuXHJcbiAgICBmdW5jdGlvbiBMaW5rKHN0YXJ0Tm9kZSxlbmROb2RlLG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgb3B0ID0gRmxvdy50cmFuc2xhdGVMaW5rT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAvL+m7mOiupOWwseaYr+ebtOe6v1xyXG4gICAgICAgIHZhciBjb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKG9wdCk7XHJcbiAgICAgICAgY29ubmVjdG9yLnN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZTtcclxuICAgICAgICBjb25uZWN0b3IuZW5kTm9kZSA9IGVuZE5vZGU7XHJcblxyXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgY3JlYXRlQnlQb2ludFxyXG4gICAgICog55So5oi35oyH5a6a6L+e57q/55qE54K577yM5p2l6L+b6KGM55S757q/XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMg57q/5q616YCJ6aG5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc3R5bGVdIOiKgueCueeahOagt+W8j1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN0eWxlLmxpbmVXaWR0aD0xXSDnur/mrrXnmoTlrr3luqZcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZS5saW5lVHlwZT0nc3RyYWlnaHQnXSDnur/mrrXnmoTnsbvlnosgZWcuICdzdHJhaWdodCcsICdqYWdnZWQnLCdjdXJ2ZSdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZS5zdHJva2U9XCIjMDAwMDAwXCJdIOe6v+auteeahOminOiJsuWAvCBlZy4gJyMxNTdjZmYnICAncmdiKDEyMiwxMjIsMTIyKSdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5zdHlsZS5saW5lRGFzaF0g6Jma57q/55qE6Ze06ZqUIGVnLiBbMywzXVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN5bWJvbF0g57q/5q6155qE566t5aS0XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLnR5cGU9J2Fycm93J10g57q/5q6155qE566t5aS055qE57G75Z6LIOWPr+mAieWAvOS4uu+8miAnY2lyY2xlJywgJ3JlY3QnLCAncm91bmRSZWN0JywgJ3RyaWFuZ2xlJywgJ2RpYW1vbmQnLCAncGluJywgJ2Fycm93J1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN5bWJvbC5zaXplPTEwXSDnur/mrrXnmoTnrq3lpLTnmoTlsLrlr7hcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wuY29sb3I9JyMwMDAwMDAnXSDnur/mrrXnmoTnrq3lpLTnmoTpopzoibJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wuel0gW+eureWktOeahOWxgue6p++8jOi2iuWkp+i2iuWcqOWJjemdouaYvuekul1cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3ltYm9sLmJvdGhdIFvmjIflrprmmK/lkKblnKjov57nur/nmoTpppbkuI7lsL7pg73nlLvnrq3lpLQg6buY6K6k5pivZmFsc2VdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudGV4dF0g57q/5q615LiK55qE5paH5a2XXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC50ZXh0XSDnur/mrrXkuIrnmoTmloflrZflhoXlrrlcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LmNvbG9yXSDnur/mrrXkuIrnmoTmloflrZfpopzoibJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LnRleHRQb3NdIOaWh+Wtl+S9jee9ruWPr+mAieWAvCAnc3RhcnQnLCdjZW50ZXInLCdlbmQnLOm7mOiupOWAvOS4umNlbnRlclxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8QXJyYXl9IFtvcHRpb25zLnRleHQub2Zmc2V0XSDmloflrZfkvY3nva7lgY/np7vph48s5Li6bnVtYmVy5YiZ5piveOWBj+enuyBhcnJheeWImeS4ult4LHldXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zXSDkv53nlZkg6K+35L2/55Sob3B0aW9ucy5wb3NpdGlvbi5kaXJlY3Rpb24g5oyH5a6a57q/5q616LW35aeL5LiO57uI5q2iIOWcqOiKgueCueeahOS7gOS5iOS9jee9riDpu5jorqTlgLzkuLonbGVmdCxyaWdodCcgIOWPr+WPluWAvOWbm+S4quaWueWQkXRvcCxib3R0b20sbGVmdCxyaWdodCDmlrnlkJHlj6/liqDlgY/np7vph4/lpoLlpoIgXCJsZWZ0KzEwLHRvcFwiXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb25dIOaMh+Wumue6v+auteS9jee9rlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLmRpcmVjdGlvbl0g5oyH5a6a57q/5q616LW35aeL5LiO57uI5q2iIOWcqOiKgueCueeahOS7gOS5iOS9jee9riDpu5jorqTlgLzkuLonbGVmdCxyaWdodCcgIOWPr+WPluWAvOWbm+S4quaWueWQkXRvcCxib3R0b20sbGVmdCxyaWdodCDmlrnlkJHlj6/liqDlgY/np7vph4/lpoLlpoIgXCJsZWZ0KzEwLHRvcFwiXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucG9zaXRpb24uc3RhcnRPZmZzZXRdIOe6v+auteW8gOWni+S9jee9rueahOWBj+enu1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLmVuZE9mZnNldF0g57q/5q6157uT5p2f5L2N572u55qE5YGP56e7XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb24uZXNjYXBlRGlzdGFuY2VdIOaMh+Wumue6v+auteesrOS4gOadoeaKmOe6v+eahOmVv+W6pu+8jOacgOWQjuS4gOadoeaKmOe6v+eahOmVv+W6pu+8jOm7mOiupOWAvOS4ulszMCwgMzBdXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb24ucG9pbnRzXSDkuI3kvb/nlKjoh6rliqjorqHnrpcg5oyH5a6a6L+e57q/55qE5oqY54K55L2N572u5pWw57uE77yM6aaW5bC+5Y+v5Lul5L2/55SobGVmdCxyaWdodCx0b3AsYm90dG9tXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZWZmZWN0XSDnur/kuIrliqjmgIHmlYjmnpxcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5lZmZlY3Quc2hvd10g5piv5ZCm5pi+56S6566t5aS05Yqo5pWIXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZWZmZWN0LnBlcmlvZF0g5Yqo5pWI56e75Yqo6YCf5bqmXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9DaGFuZ2VQb3NpdGlvbl0g6L+e57q/55qE6L+e5o6l54K56ZqPbm9kZeenu+WKqOiHquWKqOWIh+aNouS9jee9ru+8jOm7mOiupOS4umZsYXNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuel0g6L+e57q/55qE5bGC57qn77yM6LaK5aSn6LaK5Zyo5YmN6Z2i5pi+56S6XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnVuZGxlT2Zmc2V0PTMwXSDmi4bnur/mi5Dop5LlpITnmoTplb/luqYo55So5LqO6L+e57q/57uEKVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ1bmRsZUdhcD0yMF0g5aSa57q/5q6155qE6Ze06ZqUKOeUqOS6jui/nue6v+e7hClcclxuICAgICAqL1xyXG4gICAgTGluay5jcmVhdGVCeVBvaW50ID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBvcHQgPSBGbG93LnRyYW5zbGF0ZUxpbmtPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgIC8v6buY6K6k5bCx5piv55u057q/XHJcbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IG5ldyBDb25uZWN0b3Iob3B0KTtcclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gTGluaztcclxuXHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGluay9MaW5rLmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEZsb3fpnZnmgIHmlrnms5XnsbtcclxuICogQGNsYXNzIGZpc2gudG9wby5GaXNoVG9wb0Zsb3cuRmxvd1xyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL3V0aWwvRmxvd0NvbnN0YW50cy5qc1wiKTtcclxuICAgIHZhciBHcm91cE5vZGUgPSByZXF1aXJlKFwiLi9ub2RlL0dyb3VwTm9kZS5qc1wiKTtcclxuICAgIHZhciBGbG93ID0ge1xyXG4gICAgICAgIEZMT1dfVFlQRTogXCJlbGVtZW50VHlwZVwiLFxyXG4gICAgICAgIExJTks6IFwiY29ubmVjdGlvblwiLFxyXG4gICAgICAgIFJFQ1Q6IFwiUmVjdFwiLFxyXG4gICAgICAgIEdyb3VwOiAnR3JvdXAnLFxyXG4gICAgICAgIElNQUdFOiAnSW1hZ2UnLFxyXG4gICAgICAgIFRFWFQ6ICdUZXh0JyxcclxuICAgICAgICBDSVJDTEU6ICdDaXJjbGUnLFxyXG4gICAgICAgIFNFQ1RPUjogJ1NlY3RvcicsXHJcbiAgICAgICAgUklORzogJ1JpbmcnLFxyXG4gICAgICAgIFBPTFlHT046ICdQb2x5Z29uJyxcclxuICAgICAgICBQT0xZTElORTogJ1BvbHlsaW5lJyxcclxuICAgICAgICBMSU5FOiAnTGluZScsXHJcbiAgICAgICAgQkVaSUVSQ1VSVkU6ICdCZXppZXJjdXJ2ZScsXHJcbiAgICAgICAgQVJDOiAnQXJjJyxcclxuICAgICAgICBTQ0VORTonc2NlbmUnLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWV0aG9kIHNldFVzZXJEYXRhXHJcbiAgICAgICAgICog6K6+572u55So5oi35pWw5o2uXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUg6ZyA6KaB6K6+572u5pWw5o2u55qE6IqC54K5XHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiDmlbDmja5cclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAvL+iuvue9ruiHquWumuS5ieaVsOaNrlxyXG4gICAgICAgICAqICAgICAgdGhpcy5maXNoVG9wby5GbG93LnNldFVzZXJEYXRhKHJlY3QsIHsgY3VzdG9tT2JqOiBcInJlY3RcIiB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRVc2VyRGF0YTogZnVuY3Rpb24obm9kZSwgb2JqKSB7XHJcbiAgICAgICAgICAgIG5vZGUubW9kZWwuc2V0KENvbnN0YW50cy5VU0VSREFUQSwgb2JqKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPluiuvue9rueahOeUqOaIt+aVsOaNrlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIOmcgOimgeiOt+WPluaVsOaNrueahOiKgueCuVxyXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICDmlbDmja5cclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAvL+iOt+WPluiHquWumuS5ieaVsOaNrlxyXG4gICAgICAgICAqICAgICAgdGhpcy5maXNoVG9wby5GbG93LmdldFVzZXJEYXRhKHJlY3QpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFVzZXJEYXRhOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLm1vZGVsLmdldChDb25zdGFudHMuVVNFUkRBVEEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yik5pat5piv5ZCm5piv6L+e57q/XHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIOWvueixoeeahG1vZGVsXHJcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcbiAgICAgICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAgLy/liKTmlq3mmK/lkKbmmK/ov57nur9cclxuICAgICAgICAgKiAgICAgIHZhciBub2RlTW9kZWwgPSBlLnRhcmdldC5tb2RlbDtcclxuICAgICAgICAgKiAgICAgIGlmICh0aGlzLmZpc2hUb3BvLkZsb3cuaXNMaW5rKG5vZGVNb2RlbCkpIHsgcmV0dXJuIHRydWU7fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzTGluazogZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gbW9kZWwuZ2V0KEZsb3cuRkxPV19UWVBFKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRUeXBlID09IEZsb3cuTElOSztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWIpOaWreaYr+WQpuaYr+iKgueCuVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCDlr7nosaHnmoRtb2RlbFxyXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgIC8v5Yik5pat5piv5ZCm5piv6IqC54K5XHJcbiAgICAgICAgICogICAgICB2YXIgbm9kZU1vZGVsID0gZS50YXJnZXQubW9kZWw7XHJcbiAgICAgICAgICogICAgICBpZiAodGhpcy5maXNoVG9wby5GbG93LmlzTm9kZShub2RlTW9kZWwpKSB7IHJldHVybiB0cnVlO31cclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgaXNOb2RlOiBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBtb2RlbC5nZXQoRmxvdy5GTE9XX1RZUEUpO1xyXG4gICAgICAgICAgICB2YXIgaXNOb2RlO1xyXG4gICAgICAgICAgICBpZihlbGVtZW50VHlwZSAhPSAgRmxvdy5MSU5LICYmIGVsZW1lbnRUeXBlICE9ICBGbG93LlNDRU5FKXtcclxuICAgICAgICAgICAgICAgIGlzTm9kZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgaXNOb2RlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGlzTm9kZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc0luR3JvdXA6IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50IGluc3RhbmNlb2YgR3JvdXBOb2RlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzR3JvdXBOb2RlOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgR3JvdXBOb2RlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWIpOaWreiKgueCueaYr+WQpuaYr+efqeW9ouiKgueCuVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCDoioLngrnnmoRtb2RlbFxyXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgIC8v5Yik5pat5piv5ZCm5piv55+p5b2i6IqC54K5XHJcbiAgICAgICAgICogICAgICB2YXIgbm9kZU1vZGVsID0gZS50YXJnZXQubW9kZWw7XHJcbiAgICAgICAgICogICAgICBpZiAodGhpcy5maXNoVG9wby5GbG93LmlzUmVjdChub2RlTW9kZWwpKSB7IHJldHVybiB0cnVlO31cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc1JlY3Q6IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IG1vZGVsLmdldChGbG93LkZMT1dfVFlQRSk7XHJcbiAgICAgICAgICAgIHJldHVybiAgZWxlbWVudFR5cGUgPT0gRmxvdy5SRUNUO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yik5pat6IqC54K55piv5ZCm5piv5Zu+54mH6IqC54K5XHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIOiKgueCueeahG1vZGVsXHJcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICDmmK8g5ZCmXHJcbiAgICAgICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAgLy/liKTmlq3mmK/lkKbmmK/lm77niYfoioLngrlcclxuICAgICAgICAgKiAgICAgIHZhciBub2RlTW9kZWwgPSBlLnRhcmdldC5tb2RlbDtcclxuICAgICAgICAgKiAgICAgIGlmICh0aGlzLmZpc2hUb3BvLkZsb3cuaXNJbWFnZShub2RlTW9kZWwpKSB7IHJldHVybiB0cnVlO31cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc0ltYWdlOiBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSBtb2RlbC5nZXQoRmxvdy5GTE9XX1RZUEUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudFR5cGUgPT0gRmxvdy5JTUFHRTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWIpOaWreiKgueCueaYr+WQpuaYr+aWh+Wtl+iKgueCuVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCDoioLngrnnmoRtb2RlbFxyXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAg5pivIOWQplxyXG4gICAgICAgICAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgQGV4YW1wbGVcclxuICAgICAgICAgKiAgICAgIC8v5Yik5pat5piv5ZCm5piv5paH5a2X6IqC54K5XHJcbiAgICAgICAgICogICAgICB2YXIgbm9kZU1vZGVsID0gZS50YXJnZXQubW9kZWw7XHJcbiAgICAgICAgICogICAgICBpZiAodGhpcy5maXNoVG9wby5GbG93LmlzVGV4dChub2RlTW9kZWwpKSB7IHJldHVybiB0cnVlO31cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc1RleHQ6IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IG1vZGVsLmdldChGbG93LkZMT1dfVFlQRSk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50VHlwZSA9PSBGbG93LlRFWFQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDliKTmlq3oioLngrnmmK/lkKbmmK/lnIblvaLoioLngrlcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWwg6IqC54K555qEbW9kZWxcclxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIOaYryDlkKZcclxuICAgICAgICAgKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgIEBleGFtcGxlXHJcbiAgICAgICAgICogICAgICAvL+WIpOaWreaYr+WQpuaYr+WchuW9ouiKgueCuVxyXG4gICAgICAgICAqICAgICAgdmFyIG5vZGVNb2RlbCA9IGUudGFyZ2V0Lm1vZGVsO1xyXG4gICAgICAgICAqICAgICAgaWYgKHRoaXMuZmlzaFRvcG8uRmxvdy5pc0NpcmNsZShub2RlTW9kZWwpKSB7IHJldHVybiB0cnVlO31cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc0NpcmNsZTogZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gbW9kZWwuZ2V0KEZsb3cuRkxPV19UWVBFKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRUeXBlID09IEZsb3cuQ0lSQ0xFO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W6IqC54K555qE57G75Z6LXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIOiKgueCueeahG1vZGVsXHJcbiAgICAgICAgICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgICAqICAgICAgLy/ojrflj5boioLngrnnsbvlnotcclxuICAgICAgICAgKiAgICAgIHZhciBub2RlTW9kZWwgPSBlLnRhcmdldC5tb2RlbDtcclxuICAgICAgICAgKiAgICAgIHJldHVybiB0aGlzLmZpc2hUb3BvLkZsb3cuZ2V0VHlwZShub2RlTW9kZWwpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IG1vZGVsLmdldChGbG93LkZMT1dfVFlQRSk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50VHlwZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRyYW5zbGF0ZUxpbmtPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucG9zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJyUG9zID0gb3B0aW9ucy5wb3Muc3BsaXQoXCIsXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyclBvcy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24uc3RhcnRQb3MgPSBhcnJQb3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbi5lbmRQb3MgPSBhcnJQb3NbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEZsb3c7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvRmxvdy5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDmipjnur88YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubGluay5Gb2xkXHJcbiAqIEBleHRlbmRzIGZpc2hUb3BvRmxvdy5saW5rXHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgbGluayA9IGZpc2hUb3BvRmxvdy5saW5rO1xyXG4gKiAgICAgICB2YXIgZmlzaFRvcG8gPSBmaXNoVG9wb0Zsb3cuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsb3dJbnNcIiksIHtyb2FtOmZhbHNlfSk7XHJcbiAqICAgICAgIC8v6IqC54K5XHJcbiAqICAgICAgIGZ1bmN0aW9uIG5ld05vZGUoeCwgeSwgdywgaCkge1xyXG4gKiAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgbm9kZS5SZWN0KHtcclxuICogICAgICAgICAgICAgICBzaGFwZToge3dpZHRoOiB3LGhlaWdodDogaH0sXHJcbiAqICAgICAgICAgICAgICAgcG9zaXRpb246IFt4LCB5XSxcclxuICogICAgICAgICAgICAgICBzdHlsZToge2ZpbGw6IFwiIzE2N0NGRlwifVxyXG4gKiAgICAgICAgICAgfSk7XHJcbiAqICAgICAgICAgICBmaXNoVG9wby5hZGQocmVjdCk7XHJcbiAqICAgICAgICAgICByZXR1cm4gcmVjdDtcclxuICogICAgICAgfVxyXG4gKiAgICAgICAvL+aKmOe6v1xyXG4gKiAgICAgICBmdW5jdGlvbiBuZXdGb2xkTGluayhzdGFydE5vZGUsIGVuZE5vZGUsIHRleHQsIGRpcmVjdGlvbiwgZGFzaGVkUGF0dGVybikge1xyXG4gKiAgICAgICAgICAgdmFyIGZsaW5rID0gbmV3IGxpbmsuRm9sZChzdGFydE5vZGUsIGVuZE5vZGUsIHtcclxuICogICAgICAgICAgICAgICBzdHlsZToge2xpbmVEYXNoOiBbZGFzaGVkUGF0dGVybl19LFxyXG4gKiAgICAgICAgICAgICAgIHRleHQ6IHt0ZXh0OiB0ZXh0fSxcclxuICogICAgICAgICAgICAgICBwb3M6IGRpcmVjdGlvblxyXG4gKiAgICAgICAgICAgfSlcclxuICogICAgICAgICAgIGZpc2hUb3BvLmFkZChmbGluayk7XHJcbiAqICAgICAgICAgICByZXR1cm4gZmxpbms7XHJcbiAqICAgICAgIH1cclxuICogICAgICAgdmFyIGZyb20gPSBuZXdOb2RlKDEwMCwgNDAsIDMwLCAzMCk7XHJcbiAqICAgICAgIHZhciB0byA9IG5ld05vZGUoMzAwLCA4MCwgMzAsIDMwKTtcclxuICogICAgICAgbmV3Rm9sZExpbmsoZnJvbSwgdG8sICfmipjnur8nKTtcclxuICovXHJcblxyXG4gICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBGbG93ID0gcmVxdWlyZShcIi4uL0Zsb3dcIik7XHJcblxyXG4gICAgZnVuY3Rpb24gRm9sZChzdGFydE5vZGUsZW5kTm9kZSxvcHRpb25zKSB7XHJcbiAgICAgICAgLy/mipjnur9cclxuICAgICAgICB2YXIgb3B0ID0genJVdGlsLm1lcmdlKHtzdHlsZTp7bGluZVR5cGU6IENvbm5lY3Rvci5UWVBFX0pBR0dFRH19LCBvcHRpb25zLCB0cnVlKTtcclxuICAgICAgICBvcHQgPSBGbG93LnRyYW5zbGF0ZUxpbmtPcHRpb25zKG9wdCk7XHJcbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IG5ldyBDb25uZWN0b3Iob3B0KTtcclxuICAgICAgICBjb25uZWN0b3Iuc3RhcnROb2RlID0gc3RhcnROb2RlO1xyXG4gICAgICAgIGNvbm5lY3Rvci5lbmROb2RlID0gZW5kTm9kZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZXRob2QgY3JlYXRlQnlQb2ludFxyXG4gICAgICog55So5oi35oyH5a6a6L+e57q/55qE54K577yM5p2l6L+b6KGM55S757q/XHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMg57q/5q616YCJ6aG5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc3R5bGVdIOiKgueCueeahOagt+W8j1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN0eWxlLmxpbmVXaWR0aD0xXSDnur/mrrXnmoTlrr3luqZcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZS5saW5lVHlwZT0nc3RyYWlnaHQnXSDnur/mrrXnmoTnsbvlnosgZWcuICdzdHJhaWdodCcsICdqYWdnZWQnLCdjdXJ2ZSdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZS5zdHJva2U9XCIjMDAwMDAwXCJdIOe6v+auteeahOminOiJsuWAvCBlZy4gJyMxNTdjZmYnICAncmdiKDEyMiwxMjIsMTIyKSdcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5zdHlsZS5saW5lRGFzaF0g6Jma57q/55qE6Ze06ZqUIGVnLiBbMywzXVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN5bWJvbF0g57q/5q6155qE566t5aS0XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLnR5cGU9J2Fycm93J10g57q/5q6155qE566t5aS055qE57G75Z6LIOWPr+mAieWAvOS4uu+8miAnY2lyY2xlJywgJ3JlY3QnLCAncm91bmRSZWN0JywgJ3RyaWFuZ2xlJywgJ2RpYW1vbmQnLCAncGluJywgJ2Fycm93J1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN5bWJvbC5zaXplPTEwXSDnur/mrrXnmoTnrq3lpLTnmoTlsLrlr7hcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wuY29sb3I9JyMwMDAwMDAnXSDnur/mrrXnmoTnrq3lpLTnmoTpopzoibJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zeW1ib2wuel0gW+eureWktOeahOWxgue6p++8jOi2iuWkp+i2iuWcqOWJjemdouaYvuekul1cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3ltYm9sLmJvdGhdIFvmjIflrprmmK/lkKblnKjov57nur/nmoTpppbkuI7lsL7pg73nlLvnrq3lpLQg6buY6K6k5pivZmFsc2VdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudGV4dF0g57q/5q615LiK55qE5paH5a2XXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC50ZXh0XSDnur/mrrXkuIrnmoTmloflrZflhoXlrrlcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LmNvbG9yXSDnur/mrrXkuIrnmoTmloflrZfpopzoibJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0LnRleHRQb3NdIOaWh+Wtl+S9jee9ruWPr+mAieWAvCAnc3RhcnQnLCdjZW50ZXInLCdlbmQnLOm7mOiupOWAvOS4umNlbnRlclxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8QXJyYXl9IFtvcHRpb25zLnRleHQub2Zmc2V0XSDmloflrZfkvY3nva7lgY/np7vph48s5Li6bnVtYmVy5YiZ5piveOWBj+enuyBhcnJheeWImeS4ult4LHldXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zXSDkv53nlZkg6K+35L2/55Sob3B0aW9ucy5wb3NpdGlvbi5kaXJlY3Rpb24g5oyH5a6a57q/5q616LW35aeL5LiO57uI5q2iIOWcqOiKgueCueeahOS7gOS5iOS9jee9riDpu5jorqTlgLzkuLonbGVmdCxyaWdodCcgIOWPr+WPluWAvOWbm+S4quaWueWQkXRvcCxib3R0b20sbGVmdCxyaWdodCDmlrnlkJHlj6/liqDlgY/np7vph4/lpoLlpoIgXCJsZWZ0KzEwLHRvcFwiXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb25dIOaMh+Wumue6v+auteS9jee9rlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLmRpcmVjdGlvbl0g5oyH5a6a57q/5q616LW35aeL5LiO57uI5q2iIOWcqOiKgueCueeahOS7gOS5iOS9jee9riDpu5jorqTlgLzkuLonbGVmdCxyaWdodCcgIOWPr+WPluWAvOWbm+S4quaWueWQkXRvcCxib3R0b20sbGVmdCxyaWdodCDmlrnlkJHlj6/liqDlgY/np7vph4/lpoLlpoIgXCJsZWZ0KzEwLHRvcFwiXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucG9zaXRpb24uc3RhcnRPZmZzZXRdIOe6v+auteW8gOWni+S9jee9rueahOWBj+enu1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLmVuZE9mZnNldF0g57q/5q6157uT5p2f5L2N572u55qE5YGP56e7XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb24uZXNjYXBlRGlzdGFuY2VdIOaMh+Wumue6v+auteesrOS4gOadoeaKmOe6v+eahOmVv+W6pu+8jOacgOWQjuS4gOadoeaKmOe6v+eahOmVv+W6pu+8jOm7mOiupOWAvOS4ulszMCwgMzBdXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb24ucG9pbnRzXSDkuI3kvb/nlKjoh6rliqjorqHnrpcg5oyH5a6a6L+e57q/55qE5oqY54K55L2N572u5pWw57uE77yM6aaW5bC+5Y+v5Lul5L2/55SobGVmdCxyaWdodCx0b3AsYm90dG9tXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZWZmZWN0XSDnur/kuIrliqjmgIHmlYjmnpxcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5lZmZlY3Quc2hvd10g5piv5ZCm5pi+56S6566t5aS05Yqo5pWIXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZWZmZWN0LnBlcmlvZF0g5Yqo5pWI56e75Yqo6YCf5bqmXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9DaGFuZ2VQb3NpdGlvbl0g6L+e57q/55qE6L+e5o6l54K56ZqPbm9kZeenu+WKqOiHquWKqOWIh+aNouS9jee9ru+8jOm7mOiupOS4umZsYXNlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuel0g6L+e57q/55qE5bGC57qn77yM6LaK5aSn6LaK5Zyo5YmN6Z2i5pi+56S6XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnVuZGxlT2Zmc2V0PTMwXSDmi4bnur/mi5Dop5LlpITnmoTplb/luqYo55So5LqO6L+e57q/57uEKVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ1bmRsZUdhcD0yMF0g5aSa57q/5q6155qE6Ze06ZqUKOeUqOS6jui/nue6v+e7hClcclxuICAgICAqL1xyXG4gICAgRm9sZC5jcmVhdGVCeVBvaW50ID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBvcHQgPSB6clV0aWwubWVyZ2Uoe3N0eWxlOntsaW5lVHlwZTogQ29ubmVjdG9yLlRZUEVfSkFHR0VEfX0sIG9wdGlvbnMsIHRydWUpO1xyXG4gICAgICAgIG9wdCA9IEZsb3cudHJhbnNsYXRlTGlua09wdGlvbnMob3B0KTtcclxuICAgICAgICB2YXIgY29ubmVjdG9yID0gbmV3IENvbm5lY3RvcihvcHQpO1xyXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XHJcbiAgICB9XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEZvbGQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9saW5rL0ZvbGQuanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5puy57q/PGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93LmxpbmsuQ3VydmVcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93LmxpbmtcclxuICpcclxuICogKirkvb/nlKjojIPkvosqKu+8mlxyXG4gKlxyXG4gKiAgICAgIEBleGFtcGxlXHJcbiAqICAgICAgIHZhciBub2RlID0gZmlzaFRvcG9GbG93Lm5vZGU7XHJcbiAqICAgICAgIHZhciBsaW5rID0gZmlzaFRvcG9GbG93Lmxpbms7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgLy/oioLngrlcclxuICogICAgICAgZnVuY3Rpb24gbmV3Tm9kZSh4LCB5LCB3LCBoKSB7XHJcbiAqICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBub2RlLlJlY3Qoe1xyXG4gKiAgICAgICAgICAgICAgIHNoYXBlOiB7d2lkdGg6IHcsaGVpZ2h0OiBofSxcclxuICogICAgICAgICAgICAgICBwb3NpdGlvbjogW3gsIHldLFxyXG4gKiAgICAgICAgICAgICAgIHN0eWxlOiB7ZmlsbDogXCIjMTY3Q0ZGXCJ9XHJcbiAqICAgICAgICAgICB9KTtcclxuICogICAgICAgICAgIGZpc2hUb3BvLmFkZChyZWN0KTtcclxuICogICAgICAgICAgIHJldHVybiByZWN0O1xyXG4gKiAgICAgICB9XHJcbiAqICAgICAgIC8v5puy57q/XHJcbiAqICAgICAgIGZ1bmN0aW9uIG5ld0N1cnZlTGluayhzdGFydE5vZGUsIGVuZE5vZGUsIHRleHQsIGRpcmVjdGlvbiwgZGFzaGVkUGF0dGVybikge1xyXG4gKiAgICAgICAgICAgdmFyIGNsaW5rID0gbmV3IGxpbmsuQ3VydmUoc3RhcnROb2RlLCBlbmROb2RlLCB7XHJcbiAqICAgICAgICAgICAgICAgc3R5bGU6IHtsaW5lRGFzaDogW2Rhc2hlZFBhdHRlcm5dfSxcclxuICogICAgICAgICAgICAgICB0ZXh0OiB7dGV4dDogdGV4dH0sXHJcbiAqICAgICAgICAgICAgICAgcG9zOiBkaXJlY3Rpb25cclxuICogICAgICAgICAgIH0pXHJcbiAqICAgICAgICAgICBmaXNoVG9wby5hZGQoY2xpbmspO1xyXG4gKiAgICAgICAgICAgcmV0dXJuIGNsaW5rO1xyXG4gKiAgICAgICB9XHJcbiAqICAgICAgIHZhciBmcm9tID0gbmV3Tm9kZSgxMDAsIDQwLCAzMCwgMzApO1xyXG4gKiAgICAgICB2YXIgdG8gPSBuZXdOb2RlKDMwMCwgODAsIDMwLCAzMCk7XHJcbiAqICAgICAgIG5ld0N1cnZlTGluayhmcm9tLCB0bywgJ+absue6vycpO1xyXG4gKi9cclxuXHJcbiAgICB2YXIgQ29ubmVjdG9yID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9zaGFwZXMvQ29ubmVjdG9yLmpzXCIpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIEZsb3cgPSByZXF1aXJlKFwiLi4vRmxvd1wiKTtcclxuICAgIGZ1bmN0aW9uIEN1cnZlKHN0YXJ0Tm9kZSxlbmROb2RlLG9wdGlvbnMpIHtcclxuICAgICAgICAvL+absue6v1xyXG4gICAgICAgIHZhciBvcHQgPSB6clV0aWwubWVyZ2Uoe3N0eWxlOntsaW5lVHlwZTogQ29ubmVjdG9yLlRZUEVfQ1VSVkV9fSwgb3B0aW9ucywgdHJ1ZSk7XHJcbiAgICAgICAgb3B0ID0gRmxvdy50cmFuc2xhdGVMaW5rT3B0aW9ucyhvcHQpO1xyXG5cclxuICAgICAgICB2YXIgY29ubmVjdG9yID0gbmV3IENvbm5lY3RvcihvcHQpO1xyXG4gICAgICAgIGNvbm5lY3Rvci5zdGFydE5vZGUgPSBzdGFydE5vZGU7XHJcbiAgICAgICAgY29ubmVjdG9yLmVuZE5vZGUgPSBlbmROb2RlO1xyXG5cclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZUJ5UG9pbnRcclxuICAgICAqIOeUqOaIt+aMh+Wumui/nue6v+eahOeCue+8jOadpei/m+ihjOeUu+e6v1xyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIOe6v+autemAiemhuVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN0eWxlXSDoioLngrnnmoTmoLflvI9cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdHlsZS5saW5lV2lkdGg9MV0g57q/5q6155qE5a695bqmXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3R5bGUubGluZVR5cGU9J3N0cmFpZ2h0J10g57q/5q6155qE57G75Z6LIGVnLiAnc3RyYWlnaHQnLCAnamFnZ2VkJywnY3VydmUnXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3R5bGUuc3Ryb2tlPVwiIzAwMDAwMFwiXSDnur/mrrXnmoTpopzoibLlgLwgZWcuICcjMTU3Y2ZmJyAgJ3JnYigxMjIsMTIyLDEyMiknXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMuc3R5bGUubGluZURhc2hdIOiZmue6v+eahOmXtOmalCBlZy4gWzMsM11cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zeW1ib2xdIOe6v+auteeahOeureWktFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN5bWJvbC50eXBlPSdhcnJvdyddIOe6v+auteeahOeureWktOeahOexu+WeiyDlj6/pgInlgLzkuLrvvJogJ2NpcmNsZScsICdyZWN0JywgJ3JvdW5kUmVjdCcsICd0cmlhbmdsZScsICdkaWFtb25kJywgJ3BpbicsICdhcnJvdydcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zeW1ib2wuc2l6ZT0xMF0g57q/5q6155qE566t5aS055qE5bC65a+4XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLmNvbG9yPScjMDAwMDAwJ10g57q/5q6155qE566t5aS055qE6aKc6ImyXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3ltYm9sLnpdIFvnrq3lpLTnmoTlsYLnuqfvvIzotorlpKfotorlnKjliY3pnaLmmL7npLpdXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN5bWJvbC5ib3RoXSBb5oyH5a6a5piv5ZCm5Zyo6L+e57q/55qE6aaW5LiO5bC+6YO955S7566t5aS0IOm7mOiupOaYr2ZhbHNlXVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRleHRdIOe6v+auteS4iueahOaWh+Wtl1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRleHQudGV4dF0g57q/5q615LiK55qE5paH5a2X5YaF5a65XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC5jb2xvcl0g57q/5q615LiK55qE5paH5a2X6aKc6ImyXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGV4dC50ZXh0UG9zXSDmloflrZfkvY3nva7lj6/pgInlgLwgJ3N0YXJ0JywnY2VudGVyJywnZW5kJyzpu5jorqTlgLzkuLpjZW50ZXJcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfEFycmF5fSBbb3B0aW9ucy50ZXh0Lm9mZnNldF0g5paH5a2X5L2N572u5YGP56e76YePLOS4um51bWJlcuWImeaYr3jlgY/np7sgYXJyYXnliJnkuLpbeCx5XVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc10g5L+d55WZIOivt+S9v+eUqG9wdGlvbnMucG9zaXRpb24uZGlyZWN0aW9uIOaMh+Wumue6v+autei1t+Wni+S4jue7iOatoiDlnKjoioLngrnnmoTku4DkuYjkvY3nva4g6buY6K6k5YC85Li6J2xlZnQscmlnaHQnICDlj6/lj5blgLzlm5vkuKrmlrnlkJF0b3AsYm90dG9tLGxlZnQscmlnaHQg5pa55ZCR5Y+v5Yqg5YGP56e76YeP5aaC5aaCIFwibGVmdCsxMCx0b3BcIlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uXSDmjIflrprnur/mrrXkvY3nva5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb3NpdGlvbi5kaXJlY3Rpb25dIOaMh+Wumue6v+autei1t+Wni+S4jue7iOatoiDlnKjoioLngrnnmoTku4DkuYjkvY3nva4g6buY6K6k5YC85Li6J2xlZnQscmlnaHQnICDlj6/lj5blgLzlm5vkuKrmlrnlkJF0b3AsYm90dG9tLGxlZnQscmlnaHQg5pa55ZCR5Y+v5Yqg5YGP56e76YeP5aaC5aaCIFwibGVmdCsxMCx0b3BcIlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBvc2l0aW9uLnN0YXJ0T2Zmc2V0XSDnur/mrrXlvIDlp4vkvY3nva7nmoTlgY/np7tcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wb3NpdGlvbi5lbmRPZmZzZXRdIOe6v+autee7k+adn+S9jee9rueahOWBj+enu1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uLmVzY2FwZURpc3RhbmNlXSDmjIflrprnur/mrrXnrKzkuIDmnaHmipjnur/nmoTplb/luqbvvIzmnIDlkI7kuIDmnaHmipjnur/nmoTplb/luqbvvIzpu5jorqTlgLzkuLpbMzAsIDMwXVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uLnBvaW50c10g5LiN5L2/55So6Ieq5Yqo6K6h566XIOaMh+Wumui/nue6v+eahOaKmOeCueS9jee9ruaVsOe7hO+8jOmmluWwvuWPr+S7peS9v+eUqGxlZnQscmlnaHQsdG9wLGJvdHRvbVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmVmZmVjdF0g57q/5LiK5Yqo5oCB5pWI5p6cXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZWZmZWN0LnNob3ddIOaYr+WQpuaYvuekuueureWktOWKqOaViFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVmZmVjdC5wZXJpb2RdIOWKqOaViOenu+WKqOmAn+W6plxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvQ2hhbmdlUG9zaXRpb25dIOi/nue6v+eahOi/nuaOpeeCuemaj25vZGXnp7vliqjoh6rliqjliIfmjaLkvY3nva7vvIzpu5jorqTkuLpmbGFzZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnpdIOi/nue6v+eahOWxgue6p++8jOi2iuWkp+i2iuWcqOWJjemdouaYvuekulxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ1bmRsZU9mZnNldD0zMF0g5ouG57q/5ouQ6KeS5aSE55qE6ZW/5bqmKOeUqOS6jui/nue6v+e7hClcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5idW5kbGVHYXA9MjBdIOWkmue6v+auteeahOmXtOmalCjnlKjkuo7ov57nur/nu4QpXHJcbiAgICAgKi9cclxuICAgIEN1cnZlLmNyZWF0ZUJ5UG9pbnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9wdCA9IHpyVXRpbC5tZXJnZSh7c3R5bGU6e2xpbmVUeXBlOiBDb25uZWN0b3IuVFlQRV9DVVJWRX19LCBvcHRpb25zLCB0cnVlKTtcclxuICAgICAgICBvcHQgPSBGbG93LnRyYW5zbGF0ZUxpbmtPcHRpb25zKG9wdCk7XHJcbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IG5ldyBDb25uZWN0b3Iob3B0KTtcclxuICAgICAgICByZXR1cm4gY29ubmVjdG9yO1xyXG4gICAgfVxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDdXJ2ZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2xpbmsvQ3VydmUuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog6L+e57q/5pON5L2c57G7XHJcbiAqIEBhdXRob3IgbWlhby5jdW56aGlcclxuICovXHJcblxyXG4gICAgdmFyIHN5bWJvbFV0aWwgPSByZXF1aXJlKCcuLi9zaGFwZXMvU3ltYm9sJyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgaWNvbiA9IHJlcXVpcmUoJy4vSWNvbk9wZXJhdGlvbicpO1xyXG4gICAgZnVuY3Rpb24gTGluZU9wZXJhdGlvbk1hbmFnZXIoY29ubmVjdGlvbk1hbmFnZXIsIGFwaSkge1xyXG4gICAgICAgIHRoaXMubGluZU9wZXJhdGlvbnMgPSBbXSxcclxuICAgICAgICB0aGlzLmlzRWRpdCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IGNvbm5lY3Rpb25NYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuX2FwaSA9IGFwaTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqICB0aGlzLmxpbmVPcGVyYXRpb25NYW5hZ2VyLmFkZEljb24oa2V5LCBvcHRpb25zKTtcclxuICAgICAqL1xyXG4gICAgTGluZU9wZXJhdGlvbk1hbmFnZXIucHJvdG90eXBlLmFkZEljb24gPSBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcclxuICAgICAgICAvL+WIpOaWreaYr+Wwj+Wbvuagh+WQpuWtmOWcqCDvvIzlrZjlnKjliJnnm7TmjqXov5Tlm55cclxuICAgICAgICB2YXIgbGluZU9wZXJhdGlvbkljb24gPSB6clV0aWwuZmluZChvcHRpb25zLmxpbmVOb2RlLmljb25zLCBmdW5jdGlvbihpY29uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpY29uLmtleSA9PT0ga2V5O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAobGluZU9wZXJhdGlvbkljb24pIHtcclxuICAgICAgICAgICAgdGhpcy5iaW5kT3BlcmF0aW9uKG9wdGlvbnMubGluZU5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbGluZU9wZXJhdGlvbiA9IHRoaXMuY3JlYXRPcGVyYXRpb24oa2V5LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgdGhpcy5fYXBpLl9nZXRQYXJlbnRacigpLmFkZChsaW5lT3BlcmF0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5iaW5kT3BlcmF0aW9uKG9wdGlvbnMubGluZU5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbGluZU9wZXJhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLnByb3RvdHlwZS5jcmVhdE9wZXJhdGlvbiA9IGZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBsaW5lT3BlcmF0aW9uID0gc3ltYm9sVXRpbC5jcmVhdGVTeW1ib2wob3B0aW9ucy5pY29uUGF0aCwgMCwgMCwgb3B0aW9ucy53aWR0aCB8fCAxNSwgb3B0aW9ucy5oZWlnaHQgfHwgMTUsIDAsIG9wdGlvbnMuY29sb3J8fCcjMDAwJyk7XHJcbiAgICAgICAgbGluZU9wZXJhdGlvbi5rZXkgPSBrZXk7XHJcbiAgICAgICAgbGluZU9wZXJhdGlvbi5fd2lkdGggPSAgb3B0aW9ucy53aWR0aCB8fCAxNTsgIC8vIHBhdGjmg4XlhrXkuIvml6Dms5XorqHnrpdcclxuICAgICAgICBsaW5lT3BlcmF0aW9uLl9pc0xpbmVPcGVyYXRpb25JY29uID0gdHJ1ZTtcclxuICAgICAgICBsaW5lT3BlcmF0aW9uLmhpZGUoKTtcclxuICAgICAgICBvcHRpb25zLmxpbmVOb2RlLmljb25zLnB1c2gobGluZU9wZXJhdGlvbik7XHJcbiAgICAgICAgdGhpcy5saW5lT3BlcmF0aW9ucy5wdXNoKGxpbmVPcGVyYXRpb24pO1xyXG5cclxuICAgICAgICAvL+Wwj+WbvuaghyDngrnlh7vkuovku7YgIOWmguaenOacieWbnuiwg+WImeiwg+eUqOWbnuiwg++8jOWQpuWImea0vuWPkeS6i+S7tlxyXG4gICAgICAgIGxpbmVPcGVyYXRpb24ub24oXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YSA9IG9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICBldmVudC5saW5lTm9kZSA9IG9wdGlvbnMubGluZU5vZGU7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKGV2ZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnR5cGUgPSBcImNsaWNrXCI7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuZWxlbWVudFR5cGUgPSBcIkxpbmVPcGVyYXRpb25JY29uXCI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcGkudHJpZ2dlcihwYXJhbXMudHlwZSwgcGFyYW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmVPcGVyYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorqHnrpflsI/lm77moIfnmoTkvY3nva7vvIzlubbmmL7npLpcclxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gY29ubmVjdG9yIFtkZXNjcmlwdGlvbl1cclxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICAgICAqL1xyXG4gICAgTGluZU9wZXJhdGlvbk1hbmFnZXIucHJvdG90eXBlLmJpbmRPcGVyYXRpb24gPSBmdW5jdGlvbihjb25uZWN0b3IpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0VkaXQgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcG9pbnRQb3NpdGlvbiA9IGNvbm5lY3Rvci5taWRkbGUoKTtcclxuXHJcbiAgICAgICAgdmFyIGFyckxlbmd0aCA9IHpyVXRpbC5tYXAoY29ubmVjdG9yLmljb25zLCBmdW5jdGlvbihpY29uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpY29uLl93aWR0aDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIHRvdGFsTGVuZ3RoID0genJVdGlsLnJlZHVjZShhcnJMZW5ndGgsIGZ1bmN0aW9uKHByZXZpb3VzVmFsdWUsY3VycmVudFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlICsgY3VycmVudFZhbHVlICsgMTA7XHJcbiAgICAgICAgfSwgMCApO1xyXG5cclxuICAgICAgICB6clV0aWwuZWFjaChjb25uZWN0b3IuaWNvbnMsIGZ1bmN0aW9uKGljb24sIGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3JQb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaW5kZXg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yUG9zaXRpb24gKz0gYXJyTGVuZ3RoW2tdICsgMTA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWNvbi5hdHRyKFwicG9zaXRpb25cIiwgW3BvaW50UG9zaXRpb25bMF0gKyBjb25uZWN0b3JQb3NpdGlvbiAtIHRvdGFsTGVuZ3RoIC8gMiwgcG9pbnRQb3NpdGlvblsxXSArIDVdKTtcclxuICAgICAgICAgICAgaWNvbi5zaG93KCk7XHJcbiAgICAgICAgICAgIGljb24uYXR0YWNoTGluZSA9IGNvbm5lY3RvcjtcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIExpbmVPcGVyYXRpb25NYW5hZ2VyLnByb3RvdHlwZS5oaWRlQWxsTGluZU9wZXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHpyVXRpbC5lYWNoKHRoaXMubGluZU9wZXJhdGlvbnMsIGZ1bmN0aW9uKGxpbmVPcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgbGluZU9wZXJhdGlvbi5oaWRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgTGluZU9wZXJhdGlvbk1hbmFnZXIucHJvdG90eXBlLmFkZERlbGV0ZUljb24gPSBmdW5jdGlvbihsaW5lTm9kZSxvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB6clV0aWwuZGVmYXVsdHMoe1xyXG4gICAgICAgICAgICBpY29uUGF0aDogJ2ltYWdlOi8vJyArIGljb24uREVMX0lNRyxcclxuICAgICAgICAgICAgd2lkdGg6IDEyLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDE0LFxyXG4gICAgICAgICAgICBsaW5lTm9kZTogbGluZU5vZGUsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcGkucmVtb3ZlKGUudGFyZ2V0LmF0dGFjaExpbmUpOy8vdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zZWxDb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcylcclxuICAgICAgICB9LCBvcHRpb25zLHRydWUpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZEljb24oXCJkZWxldGVcIiwgb3B0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgTGluZU9wZXJhdGlvbk1hbmFnZXIucHJvdG90eXBlLmFkZENoYW5nZUxpbmVUeXBlSWNvbiA9IGZ1bmN0aW9uKGxpbmVOb2RlLG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHpyVXRpbC5kZWZhdWx0cyh7XHJcbiAgICAgICAgICAgIGljb25QYXRoOiAnaW1hZ2U6Ly8nICsgaWNvbi5DSEFOR0VfTElORV9UWVBFX0lNRyxcclxuICAgICAgICAgICAgd2lkdGg6IDE1LFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDE1LFxyXG4gICAgICAgICAgICBsaW5lTm9kZTogbGluZU5vZGUsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcGkuY2hhbmdlU2VsZWN0Q29ubmVjdG9yVHlwZSgpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcylcclxuICAgICAgICB9LCBvcHRpb25zLHRydWUpO1xyXG5cclxuICAgICAgICB0aGlzLmFkZEljb24oXCJjaGFuZ2VcIiwgb3B0cylcclxuICAgIH1cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExpbmVPcGVyYXRpb25NYW5hZ2VyO1xyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWNvcmUvbGliL21hbmFnZXIvTGluZU9wZXJhdGlvbk1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vKipcclxuICogZmlzaFRvcG9GbG9355qEbGF5b3V05a+56LGh77yM5qGG5p625o+Q5L6b55qE5biD5bGA6YO95pS+5Zyo6L+Z5Liq5a+56LGh5LiL44CC6YCa6L+HYWRkQ3VzdG9tTGF5b3V05pa55rOV5re75Yqg6Ieq5a6a5LmJ5biD5bGAXHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubGF5b3V0XHJcbiAqIEBhYnN0cmFjdFxyXG4gKi9cclxuXHJcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBmbG93VXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL0Zsb3dVdGlsXCIpO1xyXG4gICAgdmFyIEhMYXlvdXQgPSByZXF1aXJlKCcuL0hMYXlvdXQnKTtcclxuICAgIHZhciBWTGF5b3V0ID0gcmVxdWlyZSgnLi9WTGF5b3V0Jyk7XHJcbiAgICB2YXIgVHJlZUxheW91dCA9IHJlcXVpcmUoJy4vVHJlZUxheW91dCcpO1xyXG4gICAgdmFyIEZvcmNlTGF5b3V0ID0gcmVxdWlyZSgnLi9Gb3JjZUxheW91dCcpO1xyXG4gICAgdmFyIHBhcnNlUGVyY2VudCA9IGZsb3dVdGlsLnBhcnNlUGVyY2VudDtcclxuICAgIHZhciBUcmVlID0gcmVxdWlyZSgnLi4vZGF0YS9UcmVlJyk7XHJcbiAgICB2YXIgbGF5b3V0ID0ge307XHJcbiAgICBsYXlvdXQuSExheW91dCA9IEhMYXlvdXQ7XHJcbiAgICBsYXlvdXQuVkxheW91dCA9IFZMYXlvdXQ7XHJcbiAgICBsYXlvdXQuVHJlZUxheW91dCA9IFRyZWVMYXlvdXQ7XHJcbiAgICBsYXlvdXQuRm9yY2VMYXlvdXQgPSBGb3JjZUxheW91dDtcclxuICAgIGxheW91dC5UcmVlID0gVHJlZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBhZGRDdXN0b21MYXlvdXRcclxuICAgICAqIOa3u+WKoOiHquWumuS5ieW4g+WxgOexu1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbUxheW91dCDoh6rlrprkuYnluIPlsYDnmoTnsbtcclxuICAgICAqL1xyXG4gICAgbGF5b3V0LmFkZEN1c3RvbUxheW91dCA9IGZ1bmN0aW9uKGN1c3RvbUxheW91dCkge1xyXG4gICAgICAgIGxheW91dC5jdXN0b21MYXlvdXQgPSBjdXN0b21MYXlvdXQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGxheW91dC5nZXRMYXlvdXRSZWN0ID0gZnVuY3Rpb24gKHBvc2l0aW9uSW5mbywgY29udGFpbmVyUmVjdCwgbWFyZ2luKSB7XHJcbiAgICAgICAgbWFyZ2luID0gZmxvd1V0aWwubm9ybWFsaXplQ3NzQXJyYXkobWFyZ2luIHx8IDApO1xyXG5cclxuICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSBjb250YWluZXJSZWN0LndpZHRoO1xyXG4gICAgICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBjb250YWluZXJSZWN0LmhlaWdodDtcclxuXHJcbiAgICAgICAgdmFyIGxlZnQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmxlZnQsIGNvbnRhaW5lcldpZHRoKTtcclxuICAgICAgICB2YXIgdG9wID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby50b3AsIGNvbnRhaW5lckhlaWdodCk7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby5yaWdodCwgY29udGFpbmVyV2lkdGgpO1xyXG4gICAgICAgIHZhciBib3R0b20gPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmJvdHRvbSwgY29udGFpbmVySGVpZ2h0KTtcclxuICAgICAgICB2YXIgd2lkdGggPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLndpZHRoLCBjb250YWluZXJXaWR0aCk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8uaGVpZ2h0LCBjb250YWluZXJIZWlnaHQpO1xyXG5cclxuICAgICAgICB2YXIgdmVydGljYWxNYXJnaW4gPSBtYXJnaW5bMl0gKyBtYXJnaW5bMF07XHJcbiAgICAgICAgdmFyIGhvcml6b250YWxNYXJnaW4gPSBtYXJnaW5bMV0gKyBtYXJnaW5bM107XHJcbiAgICAgICAgdmFyIGFzcGVjdCA9IHBvc2l0aW9uSW5mby5hc3BlY3Q7XHJcblxyXG4gICAgICAgIC8vIElmIHdpZHRoIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSB3aWR0aCBmcm9tIGxlZnQgYW5kIHJpZ2h0XHJcbiAgICAgICAgaWYgKGlzTmFOKHdpZHRoKSkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gcmlnaHQgLSBob3Jpem9udGFsTWFyZ2luIC0gbGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTmFOKGhlaWdodCkpIHtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0IC0gYm90dG9tIC0gdmVydGljYWxNYXJnaW4gLSB0b3A7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBub3QgZ2l2ZW5cclxuICAgICAgICAvLyAxLiBHcmFwaCBzaG91bGQgbm90IGV4Y2VlZHMgdGhlIGNvbnRhaW5lclxyXG4gICAgICAgIC8vIDIuIEFzcGVjdCBtdXN0IGJlIGtlZXBlZFxyXG4gICAgICAgIC8vIDMuIEdyYXBoIHNob3VsZCB0YWtlIHRoZSBzcGFjZSBhcyBtb3JlIGFzIHBvc3NpYmxlXHJcbiAgICAgICAgaWYgKGlzTmFOKHdpZHRoKSAmJiBpc05hTihoZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIGlmIChhc3BlY3QgPiBjb250YWluZXJXaWR0aCAvIGNvbnRhaW5lckhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgd2lkdGggPSBjb250YWluZXJXaWR0aCAqIDAuODtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGNvbnRhaW5lckhlaWdodCAqIDAuODtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFzcGVjdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB3aWR0aCBvciBoZWlnaHQgd2l0aCBnaXZlbiBhc3BlY3RcclxuICAgICAgICAgICAgaWYgKGlzTmFOKHdpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgd2lkdGggPSBhc3BlY3QgKiBoZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzTmFOKGhlaWdodCkpIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBsZWZ0IGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSBsZWZ0IGZyb20gcmlnaHQgYW5kIHdpZHRoXHJcbiAgICAgICAgaWYgKGlzTmFOKGxlZnQpKSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAtIHJpZ2h0IC0gd2lkdGggLSBob3Jpem9udGFsTWFyZ2luO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOYU4odG9wKSkge1xyXG4gICAgICAgICAgICB0b3AgPSBjb250YWluZXJIZWlnaHQgLSBib3R0b20gLSBoZWlnaHQgLSB2ZXJ0aWNhbE1hcmdpbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFsaWduIGxlZnQgYW5kIHRvcFxyXG4gICAgICAgIHN3aXRjaCAocG9zaXRpb25JbmZvLmxlZnQgfHwgcG9zaXRpb25JbmZvLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gY29udGFpbmVyV2lkdGggLyAyIC0gd2lkdGggLyAyIC0gbWFyZ2luWzNdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAtIHdpZHRoIC0gaG9yaXpvbnRhbE1hcmdpbjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uSW5mby50b3AgfHwgcG9zaXRpb25JbmZvLmJvdHRvbSkge1xyXG4gICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxyXG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgICAgICAgICAgdG9wID0gY29udGFpbmVySGVpZ2h0IC8gMiAtIGhlaWdodCAvIDIgLSBtYXJnaW5bMF07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgICAgICAgIHRvcCA9IGNvbnRhaW5lckhlaWdodCAtIGhlaWdodCAtIHZlcnRpY2FsTWFyZ2luO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHNvbWV0aGluZyBpcyB3cm9uZyBhbmQgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IGFyZSBjYWxjdWxhdGVkIGFzIE5hTlxyXG4gICAgICAgIGxlZnQgPSBsZWZ0IHx8IDA7XHJcbiAgICAgICAgdG9wID0gdG9wIHx8IDA7XHJcbiAgICAgICAgaWYgKGlzTmFOKHdpZHRoKSkge1xyXG4gICAgICAgICAgICAvLyBXaWR0aCBtYXkgYmUgTmFOIGlmIG9ubHkgb25lIHZhbHVlIGlzIGdpdmVuIGV4Y2VwdCB3aWR0aFxyXG4gICAgICAgICAgICB3aWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gbGVmdCAtIChyaWdodCB8fCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTmFOKGhlaWdodCkpIHtcclxuICAgICAgICAgICAgLy8gSGVpZ2h0IG1heSBiZSBOYU4gaWYgb25seSBvbmUgdmFsdWUgaXMgZ2l2ZW4gZXhjZXB0IGhlaWdodFxyXG4gICAgICAgICAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQgLSB0b3AgLSAoYm90dG9tIHx8IDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KGxlZnQgKyBtYXJnaW5bM10sIHRvcCArIG1hcmdpblswXSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgcmVjdC5tYXJnaW4gPSBtYXJnaW47XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBsYXlvdXQucG9zaXRpb25FbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpbiwgb3B0KSB7XHJcbiAgICAgICAgdmFyIGggPSAhb3B0IHx8ICFvcHQuaHYgfHwgb3B0Lmh2WzBdO1xyXG4gICAgICAgIHZhciB2ID0gIW9wdCB8fCAhb3B0Lmh2IHx8IG9wdC5odlsxXTtcclxuICAgICAgICB2YXIgYm91bmRpbmdNb2RlID0gb3B0ICYmIG9wdC5ib3VuZGluZ01vZGUgfHwgJ2FsbCc7XHJcblxyXG4gICAgICAgIGlmICghaCAmJiAhdikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVjdDtcclxuICAgICAgICBpZiAoYm91bmRpbmdNb2RlID09PSAncmF3Jykge1xyXG4gICAgICAgICAgICByZWN0ID0gKGVsLnR5cGUgPT09ICdncm91cCcgfHwgZWwudHlwZSA9PT0gJ0dyb3VwTm9kZScpXHJcbiAgICAgICAgICAgICAgICA/IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgK3Bvc2l0aW9uSW5mby53aWR0aCB8fCAwLCArcG9zaXRpb25JbmZvLmhlaWdodCB8fCAwKVxyXG4gICAgICAgICAgICAgICAgOiBlbC5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlY3QgPSBlbC5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAgICAgaWYgKGVsLm5lZWRMb2NhbFRyYW5zZm9ybSgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gZWwuZ2V0TG9jYWxUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgIC8vIE5vdGljZTogcmF3IHJlY3QgbWF5IGJlIGlubmVyIG9iamVjdCBvZiBlbCxcclxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHNob3VsZCBub3QgYmUgbW9kaWZpZWQuXHJcbiAgICAgICAgICAgICAgICByZWN0ID0gcmVjdC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgcmVjdC5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwb3NpdGlvbkluZm8gPSBsYXlvdXQuZ2V0TGF5b3V0UmVjdChcclxuICAgICAgICAgICAgenJVdGlsLmRlZmF1bHRzKFxyXG4gICAgICAgICAgICAgICAge3dpZHRoOiByZWN0LndpZHRoLCBoZWlnaHQ6IHJlY3QuaGVpZ2h0fSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uSW5mb1xyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICAgICBjb250YWluZXJSZWN0LFxyXG4gICAgICAgICAgICBtYXJnaW5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBCZWNhdXNlICd0cmFubGF0ZScgaXMgdGhlIGxhc3Qgc3RlcCBpbiB0cmFuc2Zvcm1cclxuICAgICAgICAvLyAoc2VlIHpyZW5kZXIvY29yZS9UcmFuc2Zvcm1hYmxlI2dldExvY2FsVHJhbnNmcm9tKSxcclxuICAgICAgICAvLyB3ZSBjYW4ganVzdCBvbmx5IG1vZGlmeSBlbC5wb3NpdGlvbiB0byBnZXQgZmluYWwgcmVzdWx0LlxyXG4gICAgICAgIHZhciBlbFBvcyA9IGVsLnBvc2l0aW9uO1xyXG4gICAgICAgIHZhciBkeCA9IGggPyBwb3NpdGlvbkluZm8ueCAtIHJlY3QueCA6IDA7XHJcbiAgICAgICAgdmFyIGR5ID0gdiA/IHBvc2l0aW9uSW5mby55IC0gcmVjdC55IDogMDtcclxuXHJcbiAgICAgICAgZWwuYXR0cigncG9zaXRpb24nLCBib3VuZGluZ01vZGUgPT09ICdyYXcnID8gW2R4LCBkeV0gOiBbZWxQb3NbMF0gKyBkeCwgZWxQb3NbMV0gKyBkeV0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBsYXlvdXQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvbGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOawtOW5s+W4g+WxgDxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5sYXlvdXQuSExheW91dFxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubGF5b3V0XHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgbGF5b3V0ID0gZmlzaFRvcG9GbG93LmxheW91dDtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICBmdW5jdGlvbiBuZXdOb2RlKGdyb3VwLHRleHQpIHtcclxuICogICAgICAgICAgIHZhciByZWN0ID0gbmV3IG5vZGUuUmVjdCh7XHJcbiAqICAgICAgICAgICAgICAgICAgIHNoYXBlOnt3aWR0aDoyNSxoZWlnaHQ6MjV9LFxyXG4gKiAgICAgICAgICAgICAgICAgICBzdHlsZToge3RleHQ6dGV4dCxmaWxsOiBcIiMxNjdDRkZcIn1cclxuICogICAgICAgICAgICAgICB9KTtcclxuICogICAgICAgICAgIGdyb3VwLmFkZChyZWN0KTtcclxuICogICAgICAgICAgIHJldHVybiByZWN0O1xyXG4gKiAgICAgICB9XHJcbiAqICAgICAgIHZhciBoR3JvdXAgPSAgbmV3IG5vZGUuR3JvdXAoe1xyXG4gKiAgICAgICAgICAgc3R5bGU6IHtcclxuICogICAgICAgICAgICAgICB0ZXh0OiBcIuawtOW5s+W4g+WxgFwiLFxyXG4gKiAgICAgICAgICAgICAgIHRleHRQb3NpdGlvbjpcImJvdHRvbVwiXHJcbiAqICAgICAgICAgICB9LFxyXG4gKiAgICAgICAgICAgcG9zaXRpb246WzUwLDUwXSxcclxuICogICAgICAgICAgIGxheW91dCA6IG5ldyBsYXlvdXQuSExheW91dCh7Z2FwOjEwfSlcclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIG5ld05vZGUoaEdyb3VwLCBcIkFfMVwiKVxyXG4gKiAgICAgICBuZXdOb2RlKGhHcm91cCwgXCJBXzJcIik7XHJcbiAqICAgICAgIG5ld05vZGUoaEdyb3VwLCBcIkFfM1wiKTtcclxuICogICAgICAgbmV3Tm9kZShoR3JvdXAsIFwiQV80XCIpO1xyXG4gKiAgICAgICBuZXdOb2RlKGhHcm91cCwgXCJBXzVcIik7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZChoR3JvdXApO1xyXG4gKi9cclxuXHJcbiAgICAgICAgICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgICAgICAgICAgIHZhciBDb25uZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL3NoYXBlcy9Db25uZWN0b3IuanNcIik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEhMYXlvdXQob3B0cykge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IGdhcCDoioLngrnkuYvpl7TnmoTpl7TpmpRcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IG1heEhlaWdodD1JbmZpbml0eSDnu4TmnIDlpKfnmoTlrr3luqbvvIzlpoLmnpzotoXov4fkvJrmjaLooYxcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGdhcDogNSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aDogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdHMsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHJ1blxyXG4gICAgICAgICAgICAgKiDov5vooYzlnoLnm7TluIPlsYDvvIzkuIDoiKzkuI3pnIDopoHosIPnlKjvvIznm7TmjqXlsIbluIPlsYDnsbsg6LWL5YC857uZ57uEbGF5b3V0IOWxnuaAp+WNs+WPr1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JvdXAg6ZyA6KaB6L+b6KGM5Z6C55u05biD5bGA55qE57uEXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBITGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbihncm91cCkgIHtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50TGluZU1heFNpemUgPSAwO1xyXG4gICAgICAgICAgICAgICAgZ3JvdXAuZWFjaChmdW5jdGlvbiAoY2hpbGQsIGlkeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIENvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBjaGlsZC5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGNoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Q2hpbGQgPSBncm91cC5jaGlsZEF0KGlkeCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Q2hpbGRSZWN0ID0gbmV4dENoaWxkICYmIG5leHRDaGlsZC5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3ZlWCA9IHJlY3Qud2lkdGggKyAobmV4dENoaWxkUmVjdCA/ICgtbmV4dENoaWxkUmVjdC54ICsgcmVjdC54KSA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRYID0geCArIG1vdmVYO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdyYXAgd2hlbiB3aWR0aCBleGNlZWRzIG1heFdpZHRoIG9yIG1lZXQgYSBgbmV3bGluZWAgZ3JvdXBcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFggPiB0aGlzLm9wdGlvbnMubWF4V2lkdGggfHwgY2hpbGQubmV3bGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFggPSBtb3ZlWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBjdXJyZW50TGluZU1heFNpemUgKyBwYXJzZUludCh0aGlzLm9wdGlvbnMuZ2FwLDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gTWF0aC5tYXgoY3VycmVudExpbmVNYXhTaXplLCByZWN0LmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQubmV3bGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblswXSA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25bMV0gPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBuZXh0WCArIHRoaXMub3B0aW9ucy5nYXA7XHJcbiAgICAgICAgICAgICAgICB9LHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBITGF5b3V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBITGF5b3V0O1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgYWRkQ3VzdG9tTGF5b3V0XHJcbiAqIEBoaWRlXHJcbiAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvSExheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDlnoLnm7TluIPlsYA8YnI+XHJcbiAqIEBjbGFzcyBmaXNoVG9wb0Zsb3cubGF5b3V0LlZMYXlvdXRcclxuICogQGV4dGVuZHMgZmlzaFRvcG9GbG93LmxheW91dFxyXG4gKlxyXG4gKiAqKuS9v+eUqOiMg+S+iyoq77yaXHJcbiAqXHJcbiAqICAgICAgQGV4YW1wbGVcclxuICogICAgICAgdmFyIG5vZGUgPSBmaXNoVG9wb0Zsb3cubm9kZTtcclxuICogICAgICAgdmFyIGxheW91dCA9IGZpc2hUb3BvRmxvdy5sYXlvdXQ7XHJcbiAqICAgICAgIHZhciBmaXNoVG9wbyA9IGZpc2hUb3BvRmxvdy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxvd0luc1wiKSwge3JvYW06ZmFsc2V9KTtcclxuICogICAgICAgZnVuY3Rpb24gbmV3Tm9kZShncm91cCx0ZXh0KSB7XHJcbiAqICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBub2RlLlJlY3Qoe1xyXG4gKiAgICAgICAgICAgICAgICAgICBzaGFwZTp7d2lkdGg6MjUsaGVpZ2h0OjI1fSxcclxuICogICAgICAgICAgICAgICAgICAgc3R5bGU6IHt0ZXh0OnRleHQsZmlsbDogXCIjMTY3Q0ZGXCJ9XHJcbiAqICAgICAgICAgICAgICAgfSk7XHJcbiAqICAgICAgICAgICBncm91cC5hZGQocmVjdCk7XHJcbiAqICAgICAgICAgICByZXR1cm4gcmVjdDtcclxuICogICAgICAgfVxyXG4gKiAgICAgICB2YXIgdkdyb3VwID0gIG5ldyBub2RlLkdyb3VwKHtcclxuICogICAgICAgICAgIHN0eWxlOiB7XHJcbiAqICAgICAgICAgICAgICAgdGV4dDogXCLlnoLnm7TluIPlsYBcIixcclxuICogICAgICAgICAgICAgICB0ZXh0UG9zaXRpb246XCJib3R0b21cIlxyXG4gKiAgICAgICAgICAgfSxcclxuICogICAgICAgICAgIHBvc2l0aW9uOls2MCw2MF0sXHJcbiAqICAgICAgICAgICBsYXlvdXQgOiBuZXcgbGF5b3V0LlZMYXlvdXQoe2dhcDoxMH0pXHJcbiAqICAgICAgIH0pO1xyXG4qXHJcbiAqICAgICAgIG5ld05vZGUodkdyb3VwLCBcIkFfMVwiKVxyXG4gKiAgICAgICBuZXdOb2RlKHZHcm91cCwgXCJBXzJcIik7XHJcbiAqICAgICAgIG5ld05vZGUodkdyb3VwLCBcIkFfM1wiKTtcclxuICogICAgICAgbmV3Tm9kZSh2R3JvdXAsIFwiQV80XCIpO1xyXG4gKiAgICAgICBuZXdOb2RlKHZHcm91cCwgXCJBXzVcIik7XHJcbiAqICAgICAgIGZpc2hUb3BvLmFkZCh2R3JvdXApO1xyXG4gKi9cclxuXHJcbiAgICAgICAgICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgICAgICAgICAgdmFyIENvbm5lY3RvciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvc2hhcGVzL0Nvbm5lY3Rvci5qc1wiKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVkxheW91dChvcHRzKSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEBjZmcge051bWJlcn0gZ2FwIOiKgueCueS5i+mXtOeahOmXtOmalFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEBjZmcge051bWJlcn0gbWF4SGVpZ2h0PUluZmluaXR5IOe7hOacgOWkp+eahOmrmOW6pu+8jOWmguaenOi2hei/h+S8muaNouihjFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2FwOiA1LFxyXG4gICAgICAgICAgICAgICAgICAgIG1heEhlaWdodDogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdHMsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG1ldGhvZCBydW5cclxuICAgICAgICAgICAgICog6L+b6KGM5Z6C55u05biD5bGA77yM5LiA6Iis5LiN6ZyA6KaB6LCD55So77yM55u05o6l5bCG5biD5bGA57G7IOi1i+WAvOe7mee7hGxheW91dCDlsZ7mgKfljbPlj69cclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGdyb3VwIOmcgOimgei/m+ihjOWeguebtOW4g+WxgOeahOe7hFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVkxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oZ3JvdXApICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudExpbmVNYXhTaXplID0gMDtcclxuICAgICAgICAgICAgICAgIGdyb3VwLmVhY2goZnVuY3Rpb24gKGNoaWxkLCBpZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBDb25uZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gY2hpbGQucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBjaGlsZC5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENoaWxkID0gZ3JvdXAuY2hpbGRBdChpZHggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENoaWxkUmVjdCA9IG5leHRDaGlsZCAmJiBuZXh0Q2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW92ZVkgPSByZWN0LmhlaWdodCArIChuZXh0Q2hpbGRSZWN0ID8gKC1uZXh0Q2hpbGRSZWN0LnkgKyByZWN0LnkpIDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFkgPSB5ICsgbW92ZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JhcCB3aGVuIHdpZHRoIGV4Y2VlZHMgbWF4SGVpZ2h0IG9yIG1lZXQgYSBgbmV3bGluZWAgZ3JvdXBcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFkgPiB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0IHx8IGNoaWxkLm5ld2xpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBjdXJyZW50TGluZU1heFNpemUgKyBwYXJzZUludCh0aGlzLm9wdGlvbnMuZ2FwLDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRZID0gbW92ZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZU1heFNpemUgPSBNYXRoLm1heChjdXJyZW50TGluZU1heFNpemUsIHJlY3Qud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5ld2xpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25bMF0gPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uWzFdID0geTtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gbmV4dFkgKyB0aGlzLm9wdGlvbnMuZ2FwO1xyXG4gICAgICAgICAgICAgICAgfSx0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVkxheW91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gVkxheW91dDtcclxuXHJcblxyXG4vKipcclxuICogQG1ldGhvZCBhZGRDdXN0b21MYXlvdXRcclxuICogQGhpZGVcclxuICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2xheW91dC9WTGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIOagkeW4g+WxgDxicj5cclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy5sYXlvdXQuVHJlZUxheW91dFxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubGF5b3V0XHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgbGF5b3V0ID0gZmlzaFRvcG9GbG93LmxheW91dDtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpKTtcclxuICogICAgICAgZnVuY3Rpb24gbmV3Tm9kZShkYXRhKSB7XHJcbiAqICAgICAgICAgICB2YXIgY2lyY2xlID0gbmV3IG5vZGUuQ2lyY2xlKHtcclxuICogICAgICAgICAgICAgICBzaGFwZTogeyByOiAxNSB9LFxyXG4gKiAgICAgICAgICAgICAgIHN0eWxlOiB7IGZpbGw6IFwiIzQ4ODNiNFwiIH0sXHJcbiAqICAgICAgICAgICAgICAgbmFtZTogZGF0YS5uYW1lXHJcbiAqICAgICAgICAgICB9KTtcclxuICogICAgICAgICAgIHJldHVybiBjaXJjbGU7XHJcbiAqICAgICAgIH1cclxuICogICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAqICAgICAgICAgICBjcmVhdGVOb2RlRnVuY3Rpb246IG5ld05vZGUsXHJcbiAqICAgICAgICAgICBkYXRhOlt7XHJcbiAqICAgICAgICAgICAgICAgbmFtZTogJ+agueiKgueCuScsXHJcbiAqICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcclxuICogICAgICAgICAgICAgICAgICAgeyAgIG5hbWU6ICfoioLngrkxJyxcclxuICogICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrkxJ30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrkyJ30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrkzJ30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrk0J30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrk1J30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrk2J31cclxuICogICAgICAgICAgICAgICAgICAgICAgIF1cclxuICogICAgICAgICAgICAgICAgICAgfSxcclxuICogICAgICAgICAgICAgICAgICAgeyAgIG5hbWU6ICfoioLngrkyJyxcclxuICogICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrk3J30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrk4J31dXHJcbiAqICAgICAgICAgICAgICAgICAgIH0sXHJcbiAqICAgICAgICAgICAgICAgICAgIHsgICBuYW1lOiAn6IqC54K5MycsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn5Y+25a2Q6IqC54K5OSd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAn5Y+25a2Q6IqC54K5MTAnfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ+WPtuWtkOiKgueCuTExJ30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICflj7blrZDoioLngrkxMid9XHJcbiAqICAgICAgICAgICAgICAgICAgICAgICBdXHJcbiAqICAgICAgICAgICAgICAgICAgIH1cclxuICogICAgICAgICAgICAgICBdXHJcbiAqICAgICAgICAgICB9XVxyXG4gKiAgICAgICB9XHJcbipcclxuICogICAgICAgdmFyIHRyZWVMYXlvdXQgPSBuZXcgbGF5b3V0LlRyZWVMYXlvdXQoe1xyXG4gKiAgICAgICAgICAgZmlzaFRvcG86ZmlzaFRvcG8sXHJcbiAqICAgICAgICAgICByb290TG9jYXRpb246e3g6J2NlbnRlcicsIHk6NTB9LFxyXG4gKiAgICAgICAgICAgbm9kZVBhZGRpbmc6MVxyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgdHJlZUxheW91dC5kb0xheW91dChvcHRpb25zKTtcclxuICovXHJcblxyXG4gICAgICAgICAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICAgICAgICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xyXG4gICAgICAgICAgICB2YXIgZmxvd1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL0Zsb3dVdGlsJyk7XHJcbiAgICAgICAgICAgIHZhciBwYXJzZVBlcmNlbnQgPSBmbG93VXRpbC5wYXJzZVBlcmNlbnQ7XHJcbiAgICAgICAgICAgIHZhciBUcmVlRGF0YSA9IHJlcXVpcmUoJy4uL2RhdGEvVHJlZScpOyAgLy8g5pWw5o2u5L6d6LWWXHJcbiAgICAgICAgICAgIHZhciBUcmVlSGVscGVyID0gcmVxdWlyZShcIi4vdHJlZUhlbHBlclwiKTsgLy8g5biD5bGA5L6d6LWWXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRyZWVMYXlvdXQob3B0cykge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IGZpc2hUb3BvIGZpc2hUb3Bv5a6e5L6LXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQGNmZyB7T2JqZWN0fSByb290TG9jYXRpb24g5qC56IqC54K55Z2Q5qCH77yM5pSv5oyB57ud5a+55YC877yIcHjvvInjgIHlrZfnrKblkoznmb7liIbmr5QgJ2NlbnRlcicgfCAnbGVmdCcgfCAncmlnaHQnIHwgJ3glJyB8IG51bWJlclxyXG4gICAgICAgICAgICAgICAgICogQGNmZyB7TnVtYmVyfFN0cmluZ30gcm9vdExvY2F0aW9uLnggIOagueiKgueCueaoquWdkOagh++8jOaUr+aMgee7neWvueWAvO+8iHB477yJ44CB5a2X56ym5ZKM55m+5YiG5q+UICdjZW50ZXInIHwgJ2xlZnQnIHwgJ3JpZ2h0JyB8ICd4JScgfCBudW1iZXJcclxuICAgICAgICAgICAgICAgICAqIEBjZmcge051bWJlcnxTdHJpbmd9IHJvb3RMb2NhdGlvbi55ICDmoLnoioLngrnnurXlnZDmoIfvvIzmlK/mjIHnu53lr7nlgLzvvIhweO+8ieOAgeWtl+espuWSjOeZvuWIhuavlCAnY2VudGVyJyB8ICdsZWZ0JyB8ICdyaWdodCcgfCAneCUnIHwgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQGNmZyB7TnVtYmVyfSBsYXllclBhZGRpbmc9MTAwIOWxgumXtOi3nSzpu5jorqQ6MTAwXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQGNmZyB7TnVtYmVyfSBub2RlUGFkZGluZz0zMCDoioLngrnpl7Tot50s6buY6K6kOjMwXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICpAY2ZnIHtTdHJpbmd9IGRpcmVjdGlvbiDmoJHnmoTmlrnlkJHlj6/pgInvvJondmVydGljYWwnIHwgJ2hvcml6b250YWwnICzpu5jorqQ6dmVydGljYWxcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IGxpbmVTdHlsZSDov57nur/nmoTmoLflvI8gIOWPguingXtAbGluayBmaXNoVG9wb0Zsb3cubGluayNjb25zdHJ1Y3RvciDmnoTpgKDlh73mlbBvcHRpb25z5Y+C5pWwfVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZW50Oid2ZXJ0aWNhbCcsICAvLyB2ZXJ0aWNhbCxob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZVBhZGRpbmc6MzAsIC8v6IqC54K56Ze06LedXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJQYWRkaW5nOjEwMCwgIC8v5bGC6Ze06LedXHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdExvY2F0aW9uOiB7eDoxMDAsIHk6MjMwfSwgLy8g5qC56IqC54K55Z2Q5qCH77yM5pSv5oyB57ud5a+55YC877yIcHjvvInjgIHlrZfnrKblkoznmb7liIbmr5RcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlVGltZSA6IDUwMCxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lU3R5bGU6IHtwb3M6J2JvdHRvbSx0b3AnLCBzeW1ib2w6e3R5cGU6J25vbmUnfX1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5vcmllbnQgPT09ICdob3Jpem9udGFsJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zLmxpbmVTdHlsZS5wb3MgPSAncmlnaHQsbGVmdCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0genJVdGlsLmRlZmF1bHRzKGRlZmF1bHRPcHRpb25zLCBvcHRzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVBhZGRpbmcgPSB0aGlzLm9wdGlvbnMubm9kZVBhZGRpbmc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxheWVyUGFkZGluZyA9IHRoaXMub3B0aW9ucy5sYXllclBhZGRpbmc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpc2hUb3BvID0gdGhpcy5vcHRpb25zLmZpc2hUb3BvO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJPZmZzZXRzID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVOb2RlcyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG1ldGhvZCBsYXlvdXRCeVJvb3ROb2RlXHJcbiAgICAgICAgICAgICAqIOagueaNruagueiKgueCueWPiui/nue6v+eahOWFs+ezuyDvvIznlJ/miJDmoJFcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJvb3ROb2RlIOagkeeahOagueiKgueCuVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGJvdW5kaW5nYm94IOWMheWbtOWSjFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUubGF5b3V0QnlSb290Tm9kZSA9IGZ1bmN0aW9uKHJvb3ROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdG9ycyA9IHRoaXMuZmlzaFRvcG8uY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdG9yczsgIC8v5omA5pyJ57q/5q6155qE5pWw57uEXHJcbiAgICAgICAgICAgICAgICAvL+mAkuW9kueUn+aIkOagkeWei+aVsOaNrue7k+aehFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdHJhdmVyc2VOb2RlKHBhcmVudE5vZGUsIHRyZWVEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuRGF0YSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbk5vZGUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAvLzEu5qC55o2u6L+e57q/77yM5om+5Ye66LW35aeL6IqC54K555qE5omA5pyJ5a2Q6IqC54K5XHJcbiAgICAgICAgICAgICAgICAgICAgenJVdGlsLmVhY2goY29ubmVjdG9ycywgZnVuY3Rpb24oY29ubmVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvbm5lY3Rvci5zdGFydE5vZGUgPT09IHBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFjb25uZWN0b3IuZW5kTm9kZS5leGNsdWRlKSB7ICAgLy/lpoLmnpzmmK/mjpLmlqXnmoToioLngrnliJnkuI3liqDlhaVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbk5vZGUucHVzaChjb25uZWN0b3IuZW5kTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW5Ob2RlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8yLumBjeWOhuWtkOiKgueCuVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChjaGlsZHJlbk5vZGUsIGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZURhdGEgPSB7bmFtZTogbm9kZS5pZCwgbm9kZTpub2RlfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkRhdGEucHVzaChub2RlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VOb2RlKG5vZGUsIG5vZGVEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8zLuWwhuWtkOiKgueCueaUvuWFpWNoaWxkcmVu5LitXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuRGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVEYXRhLmNoaWxkcmVuID0gY2hpbGRyZW5EYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByb290VHJlZURhdGEgPSB7bmFtZTogcm9vdE5vZGUuaWQsIG5vZGU6cm9vdE5vZGV9O1xyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VOb2RlKHJvb3ROb2RlLHJvb3RUcmVlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb0xheW91dCh7ZGF0YTpbcm9vdFRyZWVEYXRhXX0sIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG1ldGhvZCBkb0xheW91dFxyXG4gICAgICAgICAgICAgKiDmoLnmja7kvKDov4fmnaXmoJHlnovnu5PmnoTmlbDmja7ov5vooYzmoJHluIPlsYBcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRyZWVEYXRhIOagkeW9ouaVsOaNrlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmVlRGF0YS5jcmVhdGVOb2RlRnVuY3Rpb249bnVsbCDliJvlu7roioLngrnnmoTlh73mlbAg5Lya5oqKZGF0YeS4reeahOaVsOaNriDkvKDpgJLov4fljrsgIOWmguaenOayoeaciem7mOiupOWwseaYr+WIm+W7uuWchuW9olxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJlZURhdGEuZGF0YSDliJvlu7rmoJHluIPlsYDmlbDmja7vvIjlv4XpobvljIXmi6xuYW1l5bGe5oCn77yJXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNOb3RCdWlsZExpbms9dHJ1ZSDpu5jorqTmmK/oh6rliqjliJvlu7rov57nur/vvIzkvKB0cnVl5YiZ5LiN5Lya6Ieq5Yqo5Yib5bu66L+e57q/XHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gYm91bmRpbmdib3gg5YyF5Zu05ZKMXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS5kb0xheW91dCA9IGZ1bmN0aW9uKHRyZWVEYXRhLCBpc05vdEJ1aWxkTGluaykgIHtcclxuICAgICAgICAgICAgICAgIHZhciByb290RGF0YSA9IHRyZWVEYXRhLmRhdGFbMF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVEYXRhID0gdHJlZURhdGE7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlID0gVHJlZURhdGEuZnJvbU9wdGlvbkRhdGEocm9vdERhdGEubmFtZSwgcm9vdERhdGEuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLnJvb3QuZGF0YSA9IHJvb3REYXRhO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9idWlsZE5vZGUodHJlZURhdGEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8v5qC55o2ucm9vdOWdkOaghyDmlrnlkJEg5a+55q+P5Liq6IqC54K555qE5Z2Q5qCH6L+b6KGM5pig5bCEXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRUcmVlU2hhcGUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVpbGRBbGxMaW5rKGlzTm90QnVpbGRMaW5rKTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9idWlsZEFsbExpbmtcclxuICAgICAgICAgICAgICog6YCS5b2S55S75Ye66L+e5o6l57q/IOS4juiuvue9ruiKgueCueWdkOagh1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgIFRyZWVMYXlvdXQucHJvdG90eXBlLl9idWlsZEFsbExpbmsgPSBmdW5jdGlvbiAoaXNOb3RCdWlsZExpbmspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZS50cmF2ZXJzZShmdW5jdGlvbih0cmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8v55S76L+e5o6l57q/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVOb2RlLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgIWlzTm90QnVpbGRMaW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1aWxkTGlua0J5UGFyZW50KHRyZWVOb2RlLCB0aGlzLnRyZWVEYXRhLmNyZWF0ZUxpbmtGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpc2hUb3BvLmNvbm5lY3Rpb25NYW5hZ2VyLnJlZnJlc2hMaW5lQnlOb2RlKHRyZWVOb2RlLmRhdGEubm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSx0aGlzKVxyXG4gICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGdldEJvdW5kaW5nUmVjdFxyXG4gICAgICAgICAgICAgKiDorqHnrpflh7rmoJHnmoTljIXlm7TlkoxcclxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBib3VuZGluZ2JveCDljIXlm7TlkoxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRyZWVMYXlvdXQucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLnRyYXZlcnNlKGZ1bmN0aW9uKHRyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkUmVjdCA9IEJvdW5kaW5nUmVjdC5jcmVhdGUoe3g6dHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzBdLCB5OnRyZWVOb2RlLmxheW91dC5wb3NpdGlvblsxXSwgd2lkdGg6dHJlZU5vZGUubGF5b3V0LndpZHRoLCBoZWlnaHQ6IHRyZWVOb2RlLmxheW91dC5oZWlnaHR9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY3QpIHJlY3QgPSBjaGlsZFJlY3QuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZWN0LnVuaW9uKGNoaWxkUmVjdCk7XHJcbiAgICAgICAgICAgICAgICB9LHRoaXMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS5fc2V0VHJlZVNoYXBlID0gZnVuY3Rpb24oZG9uZUNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0ZUNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciB0cmVlSGVscGVyID0gbmV3IFRyZWVIZWxwZXIoXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlUGFkZGluZzogdGhpcy5ub2RlUGFkZGluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJQYWRkaW5nOiB0aGlzLmxheWVyUGFkZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZS50cmF2ZXJzZShmdW5jdGlvbih0cmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHpyVXRpbC5pbmRleE9mKHRoaXMuX2hpZGVOb2RlcywgdHJlZU5vZGUpID09IC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRyZWVOb2RlLmRhdGEubm9kZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUubGF5b3V0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRyZWVOb2RlLmRhdGEubm9kZS5fd2lkdGggfHwgYm91bmRpbmdSZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0cmVlTm9kZS5kYXRhLm5vZGUuX2hlaWdodCB8fCBib3VuZGluZ1JlY3QuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSx0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRyZWVIZWxwZXIuX2hpZGVOb2RlcyA9IHRoaXMuX2hpZGVOb2RlcztcclxuICAgICAgICAgICAgICAgIHRyZWVIZWxwZXIucnVuKHRoaXMudHJlZSk7XHJcbiAgICAgICAgICAgICAgICAvLyDmoJHnmoTmlrnlkJFcclxuICAgICAgICAgICAgICAgIHZhciBvcmllbnQgPSB0aGlzLm9wdGlvbnMub3JpZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvb3RYID0gdGhpcy5vcHRpb25zLnJvb3RMb2NhdGlvbi54O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvb3RZID0gdGhpcy5vcHRpb25zLnJvb3RMb2NhdGlvbi55O1xyXG4gICAgICAgICAgICAgICAgdmFyIHpyV2lkdGggPSB0aGlzLmZpc2hUb3BvLmdldFdpZHRoKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgenJIZWlnaHQgPSB0aGlzLmZpc2hUb3BvLmdldEhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvb3RYID09PSAnY2VudGVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RYID0genJXaWR0aCAqIDAuNTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RYID0gcGFyc2VQZXJjZW50KHJvb3RYLCB6cldpZHRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyb290WSA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICByb290WSA9IHpySGVpZ2h0ICogMC41O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdFkgPSBwYXJzZVBlcmNlbnQocm9vdFksIHpySGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJvb3RZID0gcGFyc2VQZXJjZW50KHJvb3RZLCB6ckhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAvLyDmsLTlubPmoJFcclxuICAgICAgICAgICAgICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RYID0gaXNOYU4ocm9vdFgpID8gMTAgOiByb290WDtcclxuICAgICAgICAgICAgICAgICAgICByb290WSA9IGlzTmFOKHJvb3RZKSA/IHpySGVpZ2h0ICogMC41IDogcm9vdFk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyDnurXlkJHmoJFcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RYID0gaXNOYU4ocm9vdFgpID8genJXaWR0aCAqIDAuNSA6IHJvb3RYO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RZID0gaXNOYU4ocm9vdFkpID8gMTAgOiByb290WTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHRyZWUgbGF5b3V06Ieq5Yqo566X5Ye65p2l55qEcm9vdOeahOWdkOagh1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpblJvb3RYID0gdGhpcy50cmVlLnJvb3QubGF5b3V0LnBvc2l0aW9uWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0cmVlTm9kZUNvdW50ID0gdHJlZUhlbHBlci5jb3VudCh0aGlzLnRyZWUpIC0gdGhpcy5faGlkZU5vZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLnRyYXZlcnNlKFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh0cmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHpyVXRpbC5pbmRleE9mKHRoaXMuX2hpZGVOb2RlcywgdHJlZU5vZGUpID09IC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmllbnQgPT09ICd2ZXJ0aWNhbCcgJiYgdGhpcy5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ2ludmVyc2UnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHRyZWVOb2RlLmxheW91dC5wb3NpdGlvblswXSAtIG9yaWdpblJvb3RYICsgcm9vdFg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHJvb3RZIC0gdHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JpZW50ID09PSAndmVydGljYWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHRyZWVOb2RlLmxheW91dC5wb3NpdGlvblswXSAtIG9yaWdpblJvb3RYICsgcm9vdFg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHRyZWVOb2RlLmxheW91dC5wb3NpdGlvblsxXSArIHJvb3RZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcgJiYgdGhpcy5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ2ludmVyc2UnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHRyZWVOb2RlLmxheW91dC5wb3NpdGlvblswXSAtIG9yaWdpblJvb3RYICsgcm9vdFk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHJvb3RYIC0gdHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gdHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzBdIC0gb3JpZ2luUm9vdFggKyByb290WTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gdHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzFdICsgcm9vdFg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZS5sYXlvdXQuX194ID0geDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmxheW91dC5fX3kgPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluWSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLnRyYXZlcnNlKGZ1bmN0aW9uICh0cmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHpyVXRpbC5pbmRleE9mKHRoaXMuX2hpZGVOb2RlcywgdHJlZU5vZGUpID09IC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pblkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZS5sYXlvdXQucG9zaXRpb25bMF0gPSB0cmVlTm9kZS5sYXlvdXQuX194O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzFdID0gdHJlZU5vZGUubGF5b3V0Ll9feTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZS5sYXlvdXQucG9zaXRpb25bMF0gPSB0cmVlTm9kZS5sYXlvdXQuX194O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUubGF5b3V0LnBvc2l0aW9uWzFdID0gdHJlZU5vZGUubGF5b3V0Ll9feSAtIG1pblk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmRhdGEubm9kZS5hbmltYXRlVG8oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFt0cmVlTm9kZS5sYXlvdXQucG9zaXRpb25bMF0sIHRyZWVOb2RlLmxheW91dC5wb3NpdGlvblsxXV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLmFuaW1hdGVUaW1lLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2FuaW1hdGVDb3VudCA9PT0gdHJlZU5vZGVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVDYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+iKgueCueacieWtqeWtkOaJjeaYvuekuiDmlLbnvKnmjInpkq5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5faGlkZU5vZGVzLmxlbmd0aCA9PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmVlTm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwICYmIHRyZWVOb2RlLmRhdGEubm9kZS5fdG9nZ2xlU2hyaW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUuZGF0YS5ub2RlLl90b2dnbGVTaHJpbmsodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSx0aGlzKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS5fYnVpbGROb2RlID0gZnVuY3Rpb24odHJlZURhdGEpIHtcclxuICAgICAgICAgICAgICAgIGlmKCF0cmVlRGF0YS5jcmVhdGVOb2RlRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmVlRGF0YS5jcmVhdGVOb2RlRnVuY3Rpb24gPSB0aGlzLl9kZWZhdWx0Q3JlYXRlTm9kZUZ1bmN0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy/liKTmlq3kuIDkuIvmmK/lkKbmnIlub2RlIOWmguaenOayoeacieWImeiHquW3seWIm+W7ulxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLnRyYXZlcnNlKGZ1bmN0aW9uKHRyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXRyZWVOb2RlLmRhdGEubm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3JlYXRlTm9kZUZ1bmN0aW9uID0gdHJlZU5vZGUuZGF0YS5jcmVhdGVOb2RlRnVuY3Rpb24gfHwgdHJlZURhdGEuY3JlYXRlTm9kZUZ1bmN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGVGdW5jdGlvbih0cmVlTm9kZS5kYXRhLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5fY2hpbGRTaG93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXNoVG9wby5hZGQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmRhdGEubm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSx0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUuX2RlZmF1bHRDcmVhdGVOb2RlRnVuY3Rpb24gPSBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2lyY2xlID0gdGhpcy5maXNoVG9wby5jcmVhdGVOb2RlKFwiQ2lyY2xlXCIse1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7IHI6IDE1IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHsgZmlsbDogXCIjNDg4M2I0XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLmxhYmxlIHx8IGl0ZW0ubmFtZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2lyY2xlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS5fYnVpbGRMaW5rQnlQYXJlbnQgPSBmdW5jdGlvbiAocGFyZW50VHJlZU5vZGUsIGNyZWF0ZUxpbmtGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNoaWxkTGVuZ3RoID0gcGFyZW50VHJlZU5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgY2hpbGRMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1aWxkTGluayhwYXJlbnRUcmVlTm9kZSwgcGFyZW50VHJlZU5vZGUuY2hpbGRyZW5baV0sIGNyZWF0ZUxpbmtGdW5jdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUuX2J1aWxkTGluayA9IGZ1bmN0aW9uIChzdGFydFRyZWVOb2RlLCBlbmRUcmVlTm9kZSwgY3JlYXRlTGlua0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IHN0YXJ0VHJlZU5vZGUuZGF0YS5ub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmROb2RlID0gZW5kVHJlZU5vZGUuZGF0YS5ub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNyZWF0ZUxpbmtGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1PYmogPSAgZW5kVHJlZU5vZGUuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1PYmouc3RhcnROb2RlID0gc3RhcnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbU9iai5lbmROb2RlID0gZW5kTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yID0gY3JlYXRlTGlua0Z1bmN0aW9uKHBhcmFtT2JqKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlua1N0eWxlID0gdGhpcy5vcHRpb25zLmxpbmVTdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZFRyZWVOb2RlLmRhdGEubGluZVN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rU3R5bGUgPSB6clV0aWwubWVyZ2UoenJVdGlsLmNsb25lKGxpbmtTdHlsZSksIGVuZFRyZWVOb2RlLmRhdGEubGluZVN0eWxlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3IgPSB0aGlzLmZpc2hUb3BvLmNyZWF0ZUxpbmsoc3RhcnROb2RlLGVuZE5vZGUsbGlua1N0eWxlKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpc2hUb3BvLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgICAgIFRyZWVMYXlvdXQucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKHRyZWVOb2RlLCBkYXRhLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1RyZWVOb2RlID0gKG5ldyBUcmVlRGF0YShkYXRhLm5hbWUpKS5yb290O1xyXG4gICAgICAgICAgICAgICAgbmV3VHJlZU5vZGUuZGF0YSA9IGRhdGE7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnRyZWVEYXRhLmNyZWF0ZU5vZGVGdW5jdGlvbihuZXdUcmVlTm9kZS5kYXRhLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIG5vZGUuX2NoaWxkU2hvdyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJlZU5vZGUuY2hpbGRyZW4ubGVuZ3RoID49IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmF0dHIoJ3Bvc2l0aW9uJywgenJVdGlsLmNsb25lKHRyZWVOb2RlLmNoaWxkcmVuW3RyZWVOb2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxheW91dC5wb3NpdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmF0dHIoJ3Bvc2l0aW9uJywgenJVdGlsLmNsb25lKHRyZWVOb2RlLmxheW91dC5wb3NpdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZmlzaFRvcG8uYWRkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbmV3VHJlZU5vZGUuZGF0YS5ub2RlID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1aWxkTGluayh0cmVlTm9kZSwgbmV3VHJlZU5vZGUsIHRoaXMudHJlZURhdGEuY3JlYXRlTGlua0Z1bmN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5vcHRpb25zLmFuaW1hdGVUaW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0cmVlTm9kZS5hZGQobmV3VHJlZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoUG9zaXRpb25BbmRMaW5lKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUudG9nZ2xlQ2hpbGQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvZ2dsZVRyZWVOb2RlID0gdGhpcy5maW5kVHJlZU5vZGVCeU5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5fY2hpbGRTaG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlVHJlZU5vZGUudHJhdmVyc2UoZnVuY3Rpb24gKHRyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmVlTm9kZS5kYXRhLm5vZGUgIT09IG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmRhdGEubm9kZS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih6clV0aWwuaW5kZXhPZih0aGlzLl9oaWRlTm9kZXMsIHRyZWVOb2RlKSA9PSAtMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZU5vZGVzLnB1c2godHJlZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXNoVG9wby5jb25uZWN0aW9uTWFuYWdlci50b2dnbGVMaW5lQnlOb2RlKHRyZWVOb2RlLmRhdGEubm9kZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVOb2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZS5kYXRhLm5vZGUuX2NoaWxkU2hvdyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVOb2RlLmRhdGEubm9kZS5fdG9nZ2xlU2hyaW5rICYmIHRyZWVOb2RlLmRhdGEubm9kZS5fdG9nZ2xlU2hyaW5rKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fY2hpbGRTaG93ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fdG9nZ2xlU2hyaW5rICYmIG5vZGUuX3RvZ2dsZVNocmluayhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoUG9zaXRpb25BbmRMaW5lKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZVRyZWVOb2RlLnRyYXZlcnNlKGZ1bmN0aW9uICh0cmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJlZU5vZGUuZGF0YS5ub2RlICE9PSBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZS5kYXRhLm5vZGUuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZU5vZGVzLnNwbGljZSh6clV0aWwuaW5kZXhPZih0aGlzLl9oaWRlTm9kZXMsIHRyZWVOb2RlKSwxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlzaFRvcG8uY29ubmVjdGlvbk1hbmFnZXIudG9nZ2xlTGluZUJ5Tm9kZSh0cmVlTm9kZS5kYXRhLm5vZGUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVOb2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlTm9kZS5kYXRhLm5vZGUuX2NoaWxkU2hvdyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZU5vZGUuZGF0YS5ub2RlLl90b2dnbGVTaHJpbmsgJiYgdHJlZU5vZGUuZGF0YS5ub2RlLl90b2dnbGVTaHJpbmsodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2NoaWxkU2hvdyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fdG9nZ2xlU2hyaW5rICYmIG5vZGUuX3RvZ2dsZVNocmluayh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbkFuZExpbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS5maW5kVHJlZU5vZGVCeU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldHVyblRyZWVOb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZS50cmF2ZXJzZShmdW5jdGlvbiAodHJlZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJlZU5vZGUuZGF0YS5ub2RlID09PSBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblRyZWVOb2RlID0gdHJlZU5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVHJlZU5vZGU7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS5yZW1vdmVOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmVlTm9kZSA9IHRoaXMuZmluZFRyZWVOb2RlQnlOb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFRyZWVOb2RlID0gdHJlZU5vZGUucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRUcmVlTm9kZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy/pgY3ljoYgdG9wb+S4reWIoOmZpOiHquW3seWPiuWtqeWtkOiKgueCuVxyXG4gICAgICAgICAgICAgICAgdHJlZU5vZGUudHJhdmVyc2UoZnVuY3Rpb24gKGVhY2hUcmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlzaFRvcG8ucmVtb3ZlKGVhY2hUcmVlTm9kZS5kYXRhLm5vZGUpOyAvL+WIoOmZpOiKgueCuVxyXG4gICAgICAgICAgICAgICAgfSx0aGlzKVxyXG5cclxuICAgICAgICAgICAgICAgIHBhcmVudFRyZWVOb2RlLnJlbW92ZSh0cmVlTm9kZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy/liKTmlq3kuIDkuIvniLboioLngrnmmK/kuI3mmK/msqHmnInkuoYs5aaC5p6c5rKh5pyJ55qE6K+dLOimgeaKiue6v+S4jist5Y+357uZ6ZqQ6JeP5o6JXHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJlZU5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJlZU5vZGUuZGF0YS5ub2RlLl9oaWRlVG9nZ2xlICYmIHBhcmVudFRyZWVOb2RlLmRhdGEubm9kZS5faGlkZVRvZ2dsZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8v6YeN5paw55Sf5oiQ5pWw5o2uXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbkFuZExpbmUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgICAgIFRyZWVMYXlvdXQucHJvdG90eXBlLnJlbW92ZUNoaWxkcmVuID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0cmVlTm9kZSA9IHRoaXMuZmluZFRyZWVOb2RlQnlOb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgLy/pgY3ljoYgdG9wb+S4reWIoOmZpOWtqeWtkOiKgueCuVxyXG4gICAgICAgICAgICAgICAgdHJlZU5vZGUudHJhdmVyc2UoZnVuY3Rpb24gKGVhY2hUcmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlYWNoVHJlZU5vZGUgIT09IHRyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlzaFRvcG8ucmVtb3ZlKGVhY2hUcmVlTm9kZS5kYXRhLm5vZGUpOyAvL+WIoOmZpOiKgueCuVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sdGhpcylcclxuXHJcbiAgICAgICAgICAgICAgICB0cmVlTm9kZS5yZW1vdmVBbGxDaGlsZHJlbigpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5faGlkZVRvZ2dsZSAmJiBub2RlLl9oaWRlVG9nZ2xlKCk7IC8vdGhpcy5faGlkZVBhdGgobm9kZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy/ph43mlrDnlJ/miJDmlbDmja5cclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaFBvc2l0aW9uQW5kTGluZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBUcmVlTGF5b3V0LnByb3RvdHlwZS5yZWZyZXNoUG9zaXRpb25BbmRMaW5lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWUucm9vdC51cGRhdGVEZXB0aEFuZEhlaWdodCgwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFRyZWVTaGFwZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlLnRyYXZlcnNlKGZ1bmN0aW9uIChlYWNoVHJlZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXNoVG9wby5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoTGluZUJ5Tm9kZShlYWNoVHJlZU5vZGUuZGF0YS5ub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVHJlZUxheW91dC5wcm90b3R5cGUuY2hhbmdlUG9zaXRpb24gPSBmdW5jdGlvbiAobm9kZSwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vd0luZGV4ID0genJVdGlsLmluZGV4T2YocGFyZW50Tm9kZS5jaGlsZHJlbiwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpZihkaXJlY3Rpb24gPT0gXCJuZXh0XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEluZGV4ID0gbm93SW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgfWVsc2UgaWYoZGlyZWN0aW9uID09IFwicHJldlwiKXtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRJbmRleCA9IG5vd0luZGV4IC0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gcGFyZW50Tm9kZS5jaGlsZHJlblt0YXJnZXRJbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZih0YXJnZXROb2RlKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmFnZSA9IHRhcmdldE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlblt0YXJnZXRJbmRleF0gPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW5bbm93SW5kZXhdID0gc3RvcmFnZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaFBvc2l0aW9uQW5kTGluZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maXNoVG9wby50cmlnZ2VyKCd0cmVlTGF5b3V0OmNoYW5nZVBvc2l0aW9uJyx7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZTpub2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGU6cGFyZW50Tm9kZSxcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlOnRhcmdldE5vZGVcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBUcmVlTGF5b3V0O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGFkZEN1c3RvbUxheW91dFxyXG4gKiBAaGlkZVxyXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L1RyZWVMYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBjb25zdHJ1Y3RvciBUcmVlTm9kZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIE5vZGUgSURcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gVHJlZU5vZGUoaWQsIGRhdGEpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDoioLngrnnmoTmt7HluqZcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOS7peW9k+WJjeiKgueCueS4uuagueiKgueCueeahOWtkOagkeeahOmrmOW6plxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWtkOiKgueCueWIl+ihqFxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48VHJlZU5vZGU+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge1RyZWVOb2RlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5a2Y5YKo55qE55So5oi35pWw5o2uXHJcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmt7vliqDlrZDoioLngrlcclxuICAgICAqIEBwYXJhbSB7VHJlZU5vZGV9IGNoaWxkXHJcbiAgICAgKi9cclxuICAgIFRyZWVOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnp7vpmaTlrZDoioLngrlcclxuICAgICAqIEBwYXJhbSB7VHJlZU5vZGV9IGNoaWxkXHJcbiAgICAgKi9cclxuICAgIFRyZWVOb2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG4gICAgICAgIHZhciBpZHggPSB6clV0aWwuaW5kZXhPZihjaGlsZHJlbiwgY2hpbGQpO1xyXG4gICAgICAgIGlmIChpZHggPj0gMCkge1xyXG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgICBUcmVlTm9kZS5wcm90b3R5cGUucmVtb3ZlQWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcbiAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOmBjeWOhuW9k+WJjeiKgueCueWPiuWFtuaJgOacieWtkOiKgueCuVxyXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXHJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgW2NvbnRleHRdXHJcbiAgICAgKi9cclxuICAgIFRyZWVOb2RlLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xyXG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcyk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6YGN5Y6G6IqC5YmN6IqC54K55Y+K5omA5pyJ5a2Q6IqC54K555qE5pWw6YePXHJcbiAgICAgKi9cclxuICAgIFRyZWVOb2RlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMudHJhdmVyc2UoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb3VudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOabtOaWsOW9k+WJjeagkeWPiuaJgOacieWtkOagkeeahOmrmOW6puWSjOa3seW6plxyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBkZXB0aFxyXG4gICAgICovXHJcbiAgICBUcmVlTm9kZS5wcm90b3R5cGUudXBkYXRlRGVwdGhBbmRIZWlnaHQgPSBmdW5jdGlvbiAoZGVwdGgpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGNoaWxkLnVwZGF0ZURlcHRoQW5kSGVpZ2h0KGRlcHRoICsgMSk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5oZWlnaHQgPiBoZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGNoaWxkLmhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCArIDE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBpZFxyXG4gICAgICogQHJldHVybiBUcmVlTm9kZVxyXG4gICAgICovXHJcbiAgICBUcmVlTm9kZS5wcm90b3R5cGUuZ2V0Tm9kZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICBpZiAodGhpcy5pZCA9PT0gaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5jaGlsZHJlbltpXS5nZXROb2RlQnlJZChpZCk7XHJcbiAgICAgICAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvZGF0YS9UcmVlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gVHJlZShpZCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtUcmVlTm9kZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJvb3QgPSBuZXcgVHJlZU5vZGUoaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog6YGN5Y6G5qCR55qE5omA5pyJ5a2Q6IqC54K5KOa3seW6puS8mOWFiOmBjeWOhilcclxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgIFtjb250ZXh0XVxyXG4gICAgICovXHJcbiAgICBUcmVlLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uKGNiLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5yb290LnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlJ/miJDlrZDmoJFcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gaWQg5a2Q5qCR5qC56IqC54K5IGlkXHJcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL1RyZWV9XHJcbiAgICAgKi9cclxuICAgIFRyZWUucHJvdG90eXBlLmdldFN1YlRyZWUgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgICAgIHZhciByb290ID0gdGhpcy5nZXROb2RlQnlJZChpZCk7XHJcbiAgICAgICAgaWYgKHJvb3QpIHtcclxuICAgICAgICAgICAgdmFyIHRyZWUgPSBuZXcgVHJlZShyb290LmlkKTtcclxuICAgICAgICAgICAgdHJlZS5yb290ID0gcm9vdDtcclxuICAgICAgICAgICAgcmV0dXJuIHRyZWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gaWRcclxuICAgICAqIEByZXR1cm4gVHJlZU5vZGVcclxuICAgICAqL1xyXG4gICAgVHJlZS5wcm90b3R5cGUuZ2V0Tm9kZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290LmdldE5vZGVCeUlkKGlkKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5LuOIG9wdGlvbiDph4znmoQgZGF0YSDmlbDmja7mnoTlu7rmoJFcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxyXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gZGF0YVxyXG4gICAgICogQHJldHVybiBUcmVlXHJcbiAgICAgKi9cclxuICAgIFRyZWUuZnJvbU9wdGlvbkRhdGEgPSBmdW5jdGlvbiAoaWQsIGRhdGEpIHtcclxuICAgICAgICB2YXIgdHJlZSA9IG5ldyBUcmVlKGlkKTtcclxuICAgICAgICB2YXIgcm9vdE5vZGUgPSB0cmVlLnJvb3Q7XHJcbiAgICAgICAgLy8gUm9vdCBub2RlXHJcbiAgICAgICAgcm9vdE5vZGUuZGF0YSA9IHtcclxuICAgICAgICAgICAgbmFtZTogaWQsXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiBkYXRhXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYnVpbGRIaWVyYXJjaHkoZGF0YU5vZGUsIHBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBuZXcgVHJlZU5vZGUoZGF0YU5vZGUubmFtZSwgZGF0YU5vZGUpO1xyXG4gICAgICAgICAgICBwYXJlbnROb2RlLmFkZChub2RlKTtcclxuICAgICAgICAgICAgLy8g6YGN5Y6G5re75Yqg5a2Q6IqC54K5XHJcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGRhdGFOb2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBidWlsZEhpZXJhcmNoeShjaGlsZHJlbltpXSwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBidWlsZEhpZXJhcmNoeShkYXRhW2ldLCByb290Tm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cmVlLnJvb3QudXBkYXRlRGVwdGhBbmRIZWlnaHQoMCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0cmVlO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgVHJlZS5mcm9tRGF0YVNvdXJjZSA9IGZ1bmN0aW9uIChkYXRhU291cmNlLCByb290SXRlbSkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBfZmluZENoaWxkSXRlbShub2RlTmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4genJVdGlsLmZpbHRlcihkYXRhU291cmNlLmxpbmssZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgICAgICAgICBpZihpdGVtLmZyb20gPT09IG5vZGVOYW1lICYmICFpdGVtLnBvcykgeyAgLy8g5pWw5o2u5Lit5pyJcG9z5bGe5oCn55qE5LiN5piv5a2Q6IqC54K5XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkSGllcmFyY2h5KHJvb3QpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkSXRlbSA9IF9maW5kQ2hpbGRJdGVtKHJvb3QuaWQpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkSXRlbS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBjaGlsZEl0ZW1baV07XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRUcmVlTm9kZSA9IHRyZWVOb2Rlc01hcFtpdGVtLnRvXTtcclxuICAgICAgICAgICAgICAgIHJvb3QuY2hpbGRyZW4ucHVzaChjaGlsZFRyZWVOb2RlKTtcclxuICAgICAgICAgICAgICAgIGJ1aWxkSGllcmFyY2h5KGNoaWxkVHJlZU5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdHJlZU5vZGVzTWFwID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhU291cmNlLm5vZGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBkYXRhU291cmNlLm5vZGVbaV07XHJcbiAgICAgICAgICAgIHZhciB0cmVlTm9kZSA9IG5ldyBUcmVlTm9kZShub2RlLm5hbWUsbm9kZSk7XHJcbiAgICAgICAgICAgIHRyZWVOb2Rlc01hcFtub2RlLm5hbWVdID0gdHJlZU5vZGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdHJlZSA9IG5ldyBUcmVlKHJvb3RJdGVtLm5hbWUpO1xyXG4gICAgICAgIHZhciByb290Tm9kZSA9IHRyZWUucm9vdDtcclxuICAgICAgICAvLyBSb290IG5vZGVcclxuICAgICAgICByb290Tm9kZS5kYXRhID0gcm9vdEl0ZW07XHJcblxyXG5cclxuICAgICAgICBidWlsZEhpZXJhcmNoeSh0cmVlLnJvb3QpO1xyXG4gICAgICAgIHRyZWUucm9vdC51cGRhdGVEZXB0aEFuZEhlaWdodCgwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRyZWU7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gVHJlZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2RhdGEvVHJlZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3ZlY3RvcicpO1xyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIGZ1bmN0aW9uIFRyZWVIZWxwZXIob3B0cykge1xyXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG5cclxuICAgICAgICB0aGlzLm5vZGVQYWRkaW5nID0gb3B0cy5ub2RlUGFkZGluZyB8fCAzMDtcclxuXHJcbiAgICAgICAgdGhpcy5sYXllclBhZGRpbmcgPSBvcHRzLmxheWVyUGFkZGluZyB8fCAxMDA7XHJcblxyXG4gICAgICAgIHRoaXMuX2xheWVyT2Zmc2V0cyA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLl9sYXllcnMgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5faGlkZU5vZGVzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgVHJlZUhlbHBlci5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAodHJlZSkge1xyXG4gICAgICAgIHZhciBjb3VudCA9IDA7XHJcbiAgICAgICAgdHJlZS50cmF2ZXJzZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfVxyXG5cclxuICAgIFRyZWVIZWxwZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICh0cmVlKSB7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJPZmZzZXRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLnJvb3QuaGVpZ2h0ICsgMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyT2Zmc2V0c1tpXSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyc1tpXSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl91cGRhdGVOb2RlWFBvc2l0aW9uKHRyZWUucm9vdCk7XHJcbiAgICAgICAgdmFyIHJvb3QgPSB0cmVlLnJvb3Q7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTm9kZVlQb3NpdGlvbihyb290LCAwLCByb290LmxheW91dC5oZWlnaHQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBUcmVlSGVscGVyLnByb3RvdHlwZS5fdXBkYXRlTm9kZVhQb3NpdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdmFyIG1pblggPSBJbmZpbml0eTtcclxuICAgICAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcclxuICAgICAgICBub2RlLmxheW91dC5wb3NpdGlvbiA9IG5vZGUubGF5b3V0LnBvc2l0aW9uIHx8IHZlYzIuY3JlYXRlKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGlmKHpyVXRpbC5pbmRleE9mKHRoaXMuX2hpZGVOb2RlcywgY2hpbGQpID09IC0xKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU5vZGVYUG9zaXRpb24oY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBjaGlsZC5sYXlvdXQucG9zaXRpb25bMF07XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA8IG1pblgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5YID0geDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh4ID4gbWF4WCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFggPSB4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgKHpyVXRpbC5pbmRleE9mKHRoaXMuX2hpZGVOb2Rlcywgbm9kZS5jaGlsZHJlblswXSkgPT0gLTEpKSB7XHJcbiAgICAgICAgICAgIG5vZGUubGF5b3V0LnBvc2l0aW9uWzBdID0gKG1pblggKyBtYXhYKSAvIDI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZS5sYXlvdXQucG9zaXRpb25bMF0gPSAwO1xyXG4gICAgICAgICAgICBub2RlLmhlaWdodCA9IDA7ICAgLy8g6ZqQ6JeP6IqC54K555qEIOa3seW6puiuvuS4ujBcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9mZiA9IHRoaXMuX2xheWVyT2Zmc2V0c1tub2RlLmRlcHRoXSB8fCAwO1xyXG4gICAgICAgIGlmIChvZmYgPiBub2RlLmxheW91dC5wb3NpdGlvblswXSkge1xyXG4gICAgICAgICAgICB2YXIgc2hpZnQgPSBvZmYgLSBub2RlLmxheW91dC5wb3NpdGlvblswXTtcclxuICAgICAgICAgICAgdGhpcy5fc2hpZnRTdWJ0cmVlKG5vZGUsIHNoaWZ0KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IG5vZGUuZGVwdGggKyAxOyBqIDwgbm9kZS5oZWlnaHQgKyBub2RlLmRlcHRoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyT2Zmc2V0c1tqXSArPSBzaGlmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sYXllck9mZnNldHNbbm9kZS5kZXB0aF0gPSBub2RlLmxheW91dC5wb3NpdGlvblswXSArIG5vZGUubGF5b3V0LndpZHRoICsgdGhpcy5ub2RlUGFkZGluZztcclxuXHJcbiAgICAgICAgaWYoenJVdGlsLmluZGV4T2YodGhpcy5fbGF5ZXJzW25vZGUuZGVwdGhdLCBub2RlKSA9PSAtMSl7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyc1tub2RlLmRlcHRoXS5wdXNoKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgVHJlZUhlbHBlci5wcm90b3R5cGUuX3NoaWZ0U3VidHJlZSA9IGZ1bmN0aW9uIChyb290LCBvZmZzZXQpIHtcclxuICAgICAgICByb290LmxheW91dC5wb3NpdGlvblswXSArPSBvZmZzZXQ7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb290LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmKHpyVXRpbC5pbmRleE9mKHRoaXMuX2hpZGVOb2Rlcyxyb290LmNoaWxkcmVuW2ldKSA9PSAtMSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGlmdFN1YnRyZWUocm9vdC5jaGlsZHJlbltpXSwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgVHJlZUhlbHBlci5wcm90b3R5cGUuX3VwZGF0ZU5vZGVZUG9zaXRpb24gPSBmdW5jdGlvbiAobm9kZSwgeSwgcHJldkxheWVySGVpZ2h0KSB7XHJcbiAgICAgICAgaWYoenJVdGlsLmluZGV4T2YodGhpcy5faGlkZU5vZGVzLG5vZGUpID09IC0xKXtcclxuICAgICAgICAgICAgbm9kZS5sYXlvdXQucG9zaXRpb25bMV0gPSB5O1xyXG4gICAgICAgICAgICB2YXIgbGF5ZXJIZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxheWVySGVpZ2h0ID0gTWF0aC5tYXgobm9kZS5jaGlsZHJlbltpXS5sYXlvdXQuaGVpZ2h0LCBsYXllckhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxheWVyUGFkZGluZyA9IHRoaXMubGF5ZXJQYWRkaW5nO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIChsYXllclBhZGRpbmcpID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBsYXllclBhZGRpbmcgPSBsYXllclBhZGRpbmcobm9kZS5kZXB0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVOb2RlWVBvc2l0aW9uKG5vZGUuY2hpbGRyZW5bal0sIHkgKyBsYXllclBhZGRpbmcgKyBwcmV2TGF5ZXJIZWlnaHQsIGxheWVySGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUcmVlSGVscGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvbGF5b3V0L3RyZWVIZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICog5Yqb5a+85ZCR5biD5bGAPGJyPlxyXG4gKiBAY2xhc3MgZmlzaFRvcG9GbG93LmxheW91dC5Gb3JjZUxheW91dFxyXG4gKiBAZXh0ZW5kcyBmaXNoVG9wb0Zsb3cubGF5b3V0XHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gKiAgICAgICB2YXIgbm9kZSA9IGZpc2hUb3BvRmxvdy5ub2RlO1xyXG4gKiAgICAgICB2YXIgbGF5b3V0ID0gZmlzaFRvcG9GbG93LmxheW91dDtcclxuICogICAgICAgdmFyIGZpc2hUb3BvID0gZmlzaFRvcG9GbG93LmluaXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbG93SW5zXCIpLCB7cm9hbTpmYWxzZX0pO1xyXG4gKiAgICAgICBmdW5jdGlvbiBuZXdOb2RlKGRhdGEpIHtcclxuICogICAgICAgICAgIHZhciBjaXJjbGUgPSBuZXcgbm9kZS5DaXJjbGUoe1xyXG4gKiAgICAgICAgICAgICAgIHNoYXBlOiB7IHI6IDE1IH0sXHJcbiAqICAgICAgICAgICAgICAgc3R5bGU6IHsgZmlsbDogXCIjNDg4M2I0XCIgfSxcclxuICogICAgICAgICAgICAgICBuYW1lOiBkYXRhLm5hbWVcclxuICogICAgICAgICAgIH0pO1xyXG4gKiAgICAgICAgICAgcmV0dXJuIGNpcmNsZTtcclxuICogICAgICAgfVxyXG4gKiAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICogICAgICAgICAgIGNyZWF0ZU5vZGVGdW5jdGlvbjogbmV3Tm9kZSxcclxuICogICAgICAgICAgIGRhdGE6W3tub2RlczpbXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICfoioLngrkxJ30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICfoioLngrkyJ30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICfoioLngrkzJ30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICfoioLngrk0J30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICfoioLngrk1J30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICfoioLngrk2J30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICfoioLngrk3J30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICfoioLngrk4J31cclxuICogICAgICAgICAgICAgICAgICAgICAgIF0sXHJcbiAqICAgICAgICAgICAgICAgICAgIGxpbmtzOltcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7c291cmNlOifoioLngrkxJywgdGFyZ2V0OifoioLngrkyJ30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge3NvdXJjZTon6IqC54K5MicsIHRhcmdldDon6IqC54K5Myd9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzb3VyY2U6J+iKgueCuTMnLCB0YXJnZXQ6J+iKgueCuTQnfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7c291cmNlOifoioLngrk0JywgdGFyZ2V0OifoioLngrk1J30sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge3NvdXJjZTon6IqC54K5NScsIHRhcmdldDon6IqC54K5Nid9LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzb3VyY2U6J+iKgueCuTYnLCB0YXJnZXQ6J+iKgueCuTcnfSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7c291cmNlOifoioLngrk3JywgdGFyZ2V0OifoioLngrk4J31cclxuICogICAgICAgICAgICAgICAgICAgICAgIF1cclxuICogICAgICAgICAgIH1dXHJcbiAqICAgICAgIH1cclxuICogICAgICAgdmFyIGZvcmNlTGF5b3V0ID0gbmV3IGxheW91dC5Gb3JjZUxheW91dCh7XHJcbiAqICAgICAgICAgIGZpc2hUb3BvOmZpc2hUb3BvLFxyXG4gKiAgICAgICAgICAgcmVwdWxzaW9uOiAyMDBcclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGZvcmNlTGF5b3V0LmRvTGF5b3V0KG9wdGlvbnMpO1xyXG4gKi9cclxuXHJcblxyXG5cclxuICAgIHZhciBmb3JjZUhlbHBlciA9IHJlcXVpcmUoJy4vZm9yY2VIZWxwZXInKTtcclxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIGZ1bmN0aW9uIEZvcmNlTGF5b3V0KG9wdHMpIHtcclxuICAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7T2JqZWN0fSBmaXNoVG9wbyBmaXNoVG9wb+WunuS+i1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtOdW1iZXJ9IFtyZXB1bHNpb249MTAwXSDoioLngrnkuYvpl7TnmoTmlqXlipvlm6DlrZDjgILor6XlgLzotorlpKfoioLngrnkuYvpl7TnmoTmlqXlipvotorlpKfvvIzkuKTkuKroioLngrnpl7TnmoTot53nprvkuZ/kvJrotorov5zvvIzpu5jorqTkuLoxMDBcclxuICAgICAgICAgKi9cclxuICAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGNmZyB7TnVtYmVyfSBbZ3Jhdml0eT0wLjFdIOiKgueCueWPl+WIsOeahOWQkeS4reW/g+eahOW8leWKm+WboOWtkOOAguivpeWAvOi2iuWkp+iKgueCuei2iuW+gOS4reW/g+eCuemdoOaLouOAgum7mOiupOS4ujAuMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge051bWJlcn0gW2VkZ2VMZW5ndGg9MzBdIOi+ueeahOS4pOS4quiKgueCueS5i+mXtOeahOi3neemu++8jOi/meS4qui3neemu+S5n+S8muWPlyByZXB1bHNpb27lvbHlk43jgIIg6buY6K6k5Li6MzBcclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtCb29sZWFufSBbb25jZT10cnVlXSDmmK/lkKblj6rov5vooYzluIPlsYDkuIDmrKFcclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtPYmplY3R9IFtyZWN0XSDluIPlsYDmmL7npLrojIPlm7RcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gW3JlY3QueF0g5biD5bGA5pi+56S66IyD5Zu0eOWdkOagh1xyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gW3JlY3QueV0g5biD5bGA5pi+56S66IyD5Zu0eeWdkOagh1xyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gW3JlY3Qud2lkdGhdIOW4g+WxgOaYvuekuuWuveW6plxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gW3JlY3QuaGVpZ2h0XSDluIPlsYDmmL7npLrpq5jluqZcclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAY2ZnIHtCb29sZWFufSBbbGF5b3V0QW5pbWF0aW9uPXRydWVdIOaYr+WQpuaYvuekuuW4g+WxgOWKqOeUu1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBjZmcge09iamVjdH0gW2xpbmVTdHlsZV0g6L+e57q/55qE5qC35byPICDlj4Lop4F7QGxpbmsgZmlzaFRvcG9GbG93LmxpbmsjY29uc3RydWN0b3Ig5p6E6YCg5Ye95pWwb3B0aW9uc+WPguaVsH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZpc2hUb3BvID0gb3B0cy5maXNoVG9wbztcclxuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHJlcHVsc2lvbjogMTAwLCAgLy/oioLngrnkuYvpl7TnmoTmlqXlipvlm6DlrZDjgILor6XlgLzotorlpKfoioLngrnkuYvpl7TnmoTmlqXlipvotorlpKfvvIzkuKTkuKroioLngrnpl7TnmoTot53nprvkuZ/kvJrotorov5zvvIzpu5jorqTkuLoxMDBcclxuICAgICAgICAgICAgZ3Jhdml0eTogMC4xLCAvL+iKgueCueWPl+WIsOeahOWQkeS4reW/g+eahOW8leWKm+WboOWtkOOAguivpeWAvOi2iuWkp+iKgueCuei2iuW+gOS4reW/g+eCuemdoOaLouOAgum7mOiupOS4ujAuMVxyXG4gICAgICAgICAgICBlZGdlTGVuZ3RoOiAzMCwgLy8g6L6555qE5Lik5Liq6IqC54K55LmL6Ze055qE6Led56a777yM6L+Z5Liq6Led56a75Lmf5Lya5Y+XIHJlcHVsc2lvbuOAgiDpu5jorqTkuLozMFxyXG4gICAgICAgICAgICBvbmNlOnRydWUsXHJcbiAgICAgICAgICAgIGxheW91dEFuaW1hdGlvbjp0cnVlLFxyXG4gICAgICAgICAgICByZWN0OiB7eDowLCB5OjAsIHdpZHRoOnRoaXMuZmlzaFRvcG8uZ2V0V2lkdGgoKSAsaGVpZ2h0OnRoaXMuZmlzaFRvcG8uZ2V0SGVpZ2h0KCl9LFxyXG4gICAgICAgICAgICBsaW5lU3R5bGU6IHtzeW1ib2w6e3R5cGU6J25vbmUnfX0sXHJcbiAgICAgICAgICAgIHByZXNlcnZlZFBvaW50czoge31cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB6clV0aWwuZGVmYXVsdHMoZGVmYXVsdE9wdGlvbnMsIG9wdHMsIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1ldGhvZCBkb0xheW91dFxyXG4gICAgICog5qC55o2uZm9yY2VEYXRh6L+b6KGM5Yqb5a+85ZCR5biD5bGAXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZm9yY2VEYXRhIOWKm+WvvOWQkeaVsOaNrlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm9yY2VEYXRhLmNyZWF0ZU5vZGVGdW5jdGlvbj1udWxsIOWIm+W7uuiKgueCueeahOWHveaVsCDkvJrmiopkYXRh5Litbm9kZXPnmoTmlbDmja4g5Lyg6YCS6L+H5Y67ICDlpoLmnpzmsqHmnInpu5jorqTlsLHmmK/liJvlu7rlnIblvaJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmb3JjZURhdGEuZGF0YSDliJvlu7rlipvlr7zlkJHluIPlsYDmlbDmja5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmb3JjZURhdGEuZGF0YS5ub2RlcyDliJvlu7rlipvlr7zlkJHluIPlsYDoioLngrnnmoTlr7nosaHmlbDmja7vvIjlv4XpobvljIXmi6xuYW1l5bGe5oCn77yJXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZm9yY2VEYXRhLmRhdGEubGlua3Mg5Yib5bu65Yqb5a+85ZCR5biD5bGA6L+e57q/55qE5a+56LGh5pWw5o2u77yI5b+F6aG75YyF5ousbmFtZeWxnuaAp++8iVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgRm9yY2VMYXlvdXQucHJvdG90eXBlLmRvTGF5b3V0ID0gZnVuY3Rpb24oZm9yY2VEYXRhKSB7XHJcbiAgICAgICAgIHZhciByb290RGF0YSA9IGZvcmNlRGF0YS5kYXRhWzBdO1xyXG4gICAgICAgIHRoaXMuYWxsTm9kZXMgPSB0aGlzLl9idWlsZE5vZGUocm9vdERhdGEubm9kZXMpO1xyXG4gICAgICAgIHRoaXMuYWxsTGlua3MgPSB0aGlzLl9idWlsZExpbmtzKHJvb3REYXRhLmxpbmtzKTtcclxuICAgICAgICB0aGlzLl9mb3JjZUlucygpO1xyXG5cclxuICAgICAgICB0aGlzLl9zdGFydEZvcmNlTGF5b3V0SXRlcmF0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgRm9yY2VMYXlvdXQucHJvdG90eXBlLl9idWlsZE5vZGUgPSBmdW5jdGlvbihkYXRhcykge1xyXG4gICAgICAgIGlmKCFkYXRhcy5jcmVhdGVOb2RlRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgZGF0YXMuY3JlYXRlTm9kZUZ1bmN0aW9uID0gdGhpcy5fZGVmYXVsdENyZWF0ZU5vZGVGdW5jdGlvbi5iaW5kKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWxsTm9kZXMgPSBbXTtcclxuICAgICAgICAvL+WIpOaWreS4gOS4i+aYr+WQpuaciW5vZGUg5aaC5p6c5rKh5pyJ5YiZ6Ieq5bex5Yib5bu6XHJcbiAgICAgICAgenJVdGlsLmVhY2goZGF0YXMsICBmdW5jdGlvbihpdGVtLGlkeCkge1xyXG4gICAgICAgICAgICBpZighaXRlbS5ub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3JlYXRlTm9kZUZ1bmN0aW9uID0gaXRlbS5jcmVhdGVOb2RlRnVuY3Rpb24gfHwgZGF0YXMuY3JlYXRlTm9kZUZ1bmN0aW9uO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVOb2RlRnVuY3Rpb24oaXRlbSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpc2hUb3BvLmFkZChub2RlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZE5vZGVFdmVudChub2RlLGlkeCk7XHJcbiAgICAgICAgICAgICAgICBhbGxOb2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSx0aGlzKTtcclxuICAgICAgICByZXR1cm4gYWxsTm9kZXM7XHJcbiAgICB9XHJcblxyXG4gICAgRm9yY2VMYXlvdXQucHJvdG90eXBlLl9hZGROb2RlRXZlbnQgPSBmdW5jdGlvbihub2RlLGlkeCkge1xyXG4gICAgICAgIGlmKCF0aGlzLm9wdGlvbnMub25jZSkge1xyXG4gICAgICAgICAgICBub2RlLm9uKCdkcmFnJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZm9yY2VMYXlvdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZm9yY2VMYXlvdXQud2FybVVwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2xheW91dGluZyAmJiB0aGlzLl9zdGFydEZvcmNlTGF5b3V0SXRlcmF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZvcmNlTGF5b3V0LnNldEZpeGVkKGlkeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sdGhpcykub24oJ2RyYWdlbmQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5mb3JjZUxheW91dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5mb3JjZUxheW91dC5zZXRVbmZpeGVkKGlkeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sdGhpcylcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgRm9yY2VMYXlvdXQucHJvdG90eXBlLl9kZWZhdWx0Q3JlYXRlTm9kZUZ1bmN0aW9uID0gZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICAgIHZhciBjaXJjbGUgPSB0aGlzLmZpc2hUb3BvLmNyZWF0ZU5vZGUoXCJDaXJjbGVcIix7XHJcbiAgICAgICAgICAgIHNoYXBlOiB7IHI6IDE1IH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7IGZpbGw6IFwiIzQ4ODNiNFwiIH0sXHJcbiAgICAgICAgICAgIG5hbWU6IGl0ZW0ubGFibGUgfHwgaXRlbS5uYW1lXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNpcmNsZTtcclxuICAgIH1cclxuXHJcbiAgICBGb3JjZUxheW91dC5wcm90b3R5cGUuX2J1aWxkTGlua3MgPSBmdW5jdGlvbihsaW5rcyxjcmVhdGVMaW5rRnVuY3Rpb24pIHtcclxuICAgICAgICB2YXIgYWxsTGlua3MgPSBbXTtcclxuXHJcbiAgICAgICAgenJVdGlsLmVhY2gobGlua3MsIGZ1bmN0aW9uKGxpbmspIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IHRoaXMuZmlzaFRvcG8uY2hpbGRPZk5hbWUobGluay5zb3VyY2UpO1xyXG4gICAgICAgICAgICB2YXIgZW5kTm9kZSA9IHRoaXMuZmlzaFRvcG8uY2hpbGRPZk5hbWUobGluay50YXJnZXQpO1xyXG4gICAgICAgICAgICBpZihzdGFydE5vZGUgJiYgZW5kTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgIHZhciBjb25uZWN0b3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYoY3JlYXRlTGlua0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtT2JqID0gbGluaztcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbU9iai5zdGFydE5vZGUgPSBzdGFydE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1PYmouZW5kTm9kZSA9IGVuZE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yID0gY3JlYXRlTGlua0Z1bmN0aW9uKHBhcmFtT2JqKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmtTdHlsZSA9IHRoaXMub3B0aW9ucy5saW5lU3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmsuc3R5bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua1N0eWxlID0genJVdGlsLm1lcmdlKHpyVXRpbC5jbG9uZShsaW5rU3R5bGUpLCBsaW5rLnN0eWxlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdG9yID0gdGhpcy5maXNoVG9wby5jcmVhdGVMaW5rKHN0YXJ0Tm9kZSxlbmROb2RlLGxpbmtTdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpc2hUb3BvLmFkZChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgYWxsTGlua3MucHVzaChjb25uZWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSx0aGlzKTtcclxuICAgICAgICByZXR1cm4gYWxsTGlua3M7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIEZvcmNlTGF5b3V0LnByb3RvdHlwZS5fZm9yY2VJbnMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMub3B0aW9ucy5yZWN0O1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgcHJlc2VydmVkUG9pbnRzID0gdGhpcy5vcHRpb25zLnByZXNlcnZlZFBvaW50cztcclxuICAgICAgICB2YXIgbm9kZXMgPSB6clV0aWwubWFwKHRoaXMuYWxsTm9kZXMsIGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIHJlcCA9IHRoaXMub3B0aW9ucy5yZXB1bHNpb247IG5vZGUudyA9IHJlcDsgbm9kZS5yZXAgPSByZXA7IG5vZGUucCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3OiByZXAsXHJcbiAgICAgICAgICAgICAgICByZXA6IHJlcCxcclxuICAgICAgICAgICAgICAgIHA6IG51bGxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LHRoaXMpO1xyXG4gICAgICAgIGlmIChwcmVzZXJ2ZWRQb2ludHMpIHtcclxuICAgICAgICAgICAgenJVdGlsLmVhY2godGhpcy5hbGxOb2RlcywgZnVuY3Rpb24obm9kZSxpZHgpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuYXR0cihcInBvc2l0aW9uXCIsIHByZXNlcnZlZFBvaW50c1tpZHhdKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgenJVdGlsLmVhY2godGhpcy5hbGxMaW5rcywgZnVuY3Rpb24obGluaykge1xyXG4gICAgICAgICAgICBsaW5rLm4xID0gbGluay5zdGFydE5vZGUsXHJcbiAgICAgICAgICAgIGxpbmsubjIgPSBsaW5rLmVuZE5vZGUsXHJcbiAgICAgICAgICAgIGxpbmsuZCA9IHRoaXMub3B0aW9ucy5lZGdlTGVuZ3RoO1xyXG4gICAgICAgICAgICBsaW5rLmN1cnZlbmVzcyA9IDA7XHJcbiAgICAgICAgfSx0aGlzKVxyXG5cclxuICAgICAgICB2YXIgZm9yY2VJbnN0YW5jZSA9IGZvcmNlSGVscGVyKHRoaXMuYWxsTm9kZXMsIHRoaXMuYWxsTGlua3MsIHtcclxuICAgICAgICAgICAgcmVjdDogcmVjdCxcclxuICAgICAgICAgICAgZ3Jhdml0eTogdGhpcy5vcHRpb25zLmdyYXZpdHlcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgb2xkU3RlcCA9IGZvcmNlSW5zdGFuY2Uuc3RlcDtcclxuICAgICAgICBmb3JjZUluc3RhbmNlLnN0ZXAgPSBmdW5jdGlvbihjYikge1xyXG4gICAgICAgICAgICB6clV0aWwuZWFjaCh0aGlzLmFsbE5vZGVzLCBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMuZml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2ZWMyLmNvcHkobm9kZXMucCwgbm9kZXMucG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgb2xkU3RlcChmdW5jdGlvbihhbGxOb2RlcywgYWxsTGlua3MsIHN0b3BwZWQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYWxsTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxOb2Rlc1tpXS5maXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxOb2Rlc1tpXS5hdHRyKFwicG9zaXRpb25cIiwgYWxsTm9kZXNbaV0ucCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlZFBvaW50c1tpXSA9IGFsbE5vZGVzW2ldLnA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgenJVdGlsLmVhY2goYWxsTGlua3MsIGZ1bmN0aW9uKGNvbm5lY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmlzaFRvcG8uY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaENvbm5lY3Rvcihjb25uZWN0b3IsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgICAgICBjYiAmJiBjYihzdG9wcGVkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMuZm9yY2VMYXlvdXQgPSBmb3JjZUluc3RhbmNlO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucy5wcmVzZXJ2ZWRQb2ludHMgPSBwcmVzZXJ2ZWRQb2ludHM7XHJcbiAgICAgICAgLy8gU3RlcCB0byBnZXQgdGhlIGxheW91dFxyXG4gICAgICAgIGZvcmNlSW5zdGFuY2Uuc3RlcCgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBGb3JjZUxheW91dC5wcm90b3R5cGUuX3N0YXJ0Rm9yY2VMYXlvdXRJdGVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBsYXlvdXRBbmltYXRpb24gPSB0aGlzLm9wdGlvbnMubGF5b3V0QW5pbWF0aW9uO1xyXG4gICAgICAgIChmdW5jdGlvbiBzdGVwKCkge1xyXG4gICAgICAgICAgICBzZWxmLm9wdGlvbnMuZm9yY2VMYXlvdXQuc3RlcChmdW5jdGlvbiAoc3RvcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fbGF5b3V0aW5nID0gIXN0b3BwZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fbGF5b3V0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheW91dEFuaW1hdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9sYXlvdXRUaW1lb3V0ID0gc2V0VGltZW91dChzdGVwLCAxNilcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgc2VsZi5maXNoVG9wby50cmlnZ2VyKFwiZm9yY2VMYXlvdXRFbmRcIik7ICAvL+a0vuWPkeW4g+WxgOe7k+adn+S6i+S7tlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pKCk7XHJcbiAgICB9O1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBGb3JjZUxheW91dDtcclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGFkZEN1c3RvbUxheW91dFxyXG4gKiBAaGlkZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZXZlbnQgZm9yY2VMYXlvdXRFbmRcclxuICog5biD5bGA57uT5p2f5LqL5Lu2XHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqIGZpc2h0b3BvLm9uKCdmb3JjZUxheW91dEVuZCcsIGZ1bmN0aW9uKGUpIHtcclxuICogICAvL2RvIHNvbWV0aGluZ1xyXG4gKiB9KVxyXG4gKiA8L3ByZT5cclxuICovXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi9sYXlvdXQvRm9yY2VMYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHJcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yJyk7XHJcbiAgICB2YXIgc2NhbGVBbmRBZGQgPSB2ZWMyLnNjYWxlQW5kQWRkO1xyXG5cclxuICAgIC8vIGZ1bmN0aW9uIGFkamFjZW50Tm9kZShuLCBlKSB7XHJcbiAgICAvLyAgICAgcmV0dXJuIGUubjEgPT09IG4gPyBlLm4yIDogZS5uMTtcclxuICAgIC8vIH1cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChub2RlcywgZWRnZXMsIG9wdHMpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IG9wdHMucmVjdDtcclxuICAgICAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICB2YXIgY2VudGVyID0gW3JlY3QueCArIHdpZHRoIC8gMiwgcmVjdC55ICsgaGVpZ2h0IC8gMl07XHJcbiAgICAgICAgLy8gdmFyIHNjYWxlID0gb3B0cy5zY2FsZSB8fCAxO1xyXG4gICAgICAgIHZhciBncmF2aXR5ID0gb3B0cy5ncmF2aXR5ID09IG51bGwgPyAwLjEgOiBvcHRzLmdyYXZpdHk7XHJcblxyXG4gICAgICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyAgICAgdmFyIGUgPSBlZGdlc1tpXTtcclxuICAgICAgICAvLyAgICAgdmFyIG4xID0gZS5uMTtcclxuICAgICAgICAvLyAgICAgdmFyIG4yID0gZS5uMjtcclxuICAgICAgICAvLyAgICAgbjEuZWRnZXMgPSBuMS5lZGdlcyB8fCBbXTtcclxuICAgICAgICAvLyAgICAgbjIuZWRnZXMgPSBuMi5lZGdlcyB8fCBbXTtcclxuICAgICAgICAvLyAgICAgbjEuZWRnZXMucHVzaChlKTtcclxuICAgICAgICAvLyAgICAgbjIuZWRnZXMucHVzaChlKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gSW5pdCBwb3NpdGlvblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcclxuICAgICAgICAgICAgaWYgKCFuLnApIHtcclxuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgcG9zaXRpb24gZnJvbSBmaXJzdCBhZGplY2VudCBub2RlIHdpdGggZGVmaW5lZCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gT3IgdXNlIGEgcmFuZG9tIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyBGcm9tIGQzXHJcbiAgICAgICAgICAgICAgICAvLyBpZiAobi5lZGdlcykge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIHZhciBqID0gLTE7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgd2hpbGUgKCsraiA8IG4uZWRnZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHZhciBlID0gbi5lZGdlc1tqXTtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgdmFyIG90aGVyID0gYWRqYWNlbnROb2RlKG4sIGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBpZiAob3RoZXIucCkge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgbi5wID0gdmVjMi5jbG9uZShvdGhlci5wKTtcclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgKCFuLnApIHtcclxuICAgICAgICAgICAgICAgICAgICBuLnAgPSB2ZWMyLmNyZWF0ZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKyBjZW50ZXJbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSArIGNlbnRlclsxXVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbi5wcCA9IHZlYzIuY2xvbmUobi5wKTtcclxuICAgICAgICAgICAgbi5lZGdlcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGb3JtdWxhIGluICdHcmFwaCBEcmF3aW5nIGJ5IEZvcmNlLWRpcmVjdGVkIFBsYWNlbWVudCdcclxuICAgICAgICAvLyB2YXIgayA9IHNjYWxlICogTWF0aC5zcXJ0KHdpZHRoICogaGVpZ2h0IC8gbm9kZXMubGVuZ3RoKTtcclxuICAgICAgICAvLyB2YXIgazIgPSBrICogaztcclxuXHJcbiAgICAgICAgdmFyIGZyaWN0aW9uID0gMC42O1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB3YXJtVXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGZyaWN0aW9uID0gMC41O1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc2V0Rml4ZWQ6IGZ1bmN0aW9uIChpZHgpIHtcclxuICAgICAgICAgICAgICAgIG5vZGVzW2lkeF0uZml4ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc2V0VW5maXhlZDogZnVuY3Rpb24gKGlkeCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZXNbaWR4XS5maXhlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgc3RlcDogZnVuY3Rpb24gKGNiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdjEyID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgbkxlbiA9IG5vZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGVkZ2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuMSA9IGUubjE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4yID0gZS5uMjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5zdWIodjEyLCBuMi5wLCBuMS5wKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHZlYzIubGVuKHYxMikgLSBlLmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSBuMi53IC8gKG4xLncgKyBuMi53KTtcclxuICAgICAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZSh2MTIsIHYxMik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICFuMS5maXhlZCAmJiBzY2FsZUFuZEFkZChuMS5wLCBuMS5wLCB2MTIsIHcgKiBkICogZnJpY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICFuMi5maXhlZCAmJiBzY2FsZUFuZEFkZChuMi5wLCBuMi5wLCB2MTIsIC0oMSAtIHcpICogZCAqIGZyaWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEdyYXZpdHlcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW4uZml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5zdWIodjEyLCBjZW50ZXIsIG4ucCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhciBkID0gdmVjMi5sZW4odjEyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmVjMi5zY2FsZSh2MTIsIHYxMiwgMSAvIGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2YXIgZ3Jhdml0eUZhY3RvciA9IGdyYXZpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuc2NhbGVBbmRBZGQobi5wLCBuLnAsIHYxMiwgZ3Jhdml0eSAqIGZyaWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVwdWxzaXZlXHJcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5MZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuMSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG5MZW47IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbjIgPSBub2Rlc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5zdWIodjEyLCBuMi5wLCBuMS5wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSB2ZWMyLmxlbih2MTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmFuZG9tIHJlcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuc2V0KHYxMiwgTWF0aC5yYW5kb20oKSAtIDAuNSwgTWF0aC5yYW5kb20oKSAtIDAuNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVwRmFjdCA9IChuMS5yZXAgKyBuMi5yZXApIC8gZCAvIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFuMS5maXhlZCAmJiBzY2FsZUFuZEFkZChuMS5wcCwgbjEucHAsIHYxMiwgcmVwRmFjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFuMi5maXhlZCAmJiBzY2FsZUFuZEFkZChuMi5wcCwgbjIucHAsIHYxMiwgLXJlcEZhY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB2ID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5MZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuLmZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuc3ViKHYsIG4ucCwgbi5wcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuc2NhbGVBbmRBZGQobi5wLCBuLnAsIHYsIGZyaWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jb3B5KG4ucHAsIG4ucCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZyaWN0aW9uID0gZnJpY3Rpb24gKiAwLjk5MjtcclxuXHJcbiAgICAgICAgICAgICAgICBjYiAmJiBjYihub2RlcywgZWRnZXMsIGZyaWN0aW9uIDwgMC4wMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZmlzaC10b3BvLWZsb3cvbGliL2xheW91dC9mb3JjZUhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiDlt6XlhbfnsbtcclxuICogQGNsYXNzIGZpc2hUb3BvRmxvdy51dGlsXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZXRob2QgaW5pdEltYWdlUG9vbFxyXG4gKiDliJ3lp4vljJblm77niYfmsaAgIOeUqOS6juWvueWbvueJh+WKoOi9vei/m+ihjOeuoeeQhlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IOacgOWkp+i/nuaOpeaVsOOAguaVsOWAvOOAglxyXG4gKiBAcmV0dXJucyB7e2xvYWQ6IEZ1bmN0aW9uLCBpbmZvOiBGdW5jdGlvbn19XHJcbiAqXHJcbiAqICoq5L2/55So6IyD5L6LKirvvJpcclxuICpcclxuICogICAgICBAZXhhbXBsZVxyXG4gICAgICAgIHZhciBpbWFnZXBvb2wgPSBmaXNoVG9wb0Zsb3cudXRpbC5pbml0SW1hZ2VQb29sKDEwMCk7XHJcbiAgICAgICAgaW1hZ2Vwb29sLmxvYWQoZ3JheUFycmF5LCB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGltZ3MpIHtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25jZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbWV0aG9kIGluaGVyaXRzXHJcbiAqIOaehOmAoOexu+e7p+aJv+WFs+ezu1xyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGF6eiDmupDnsbtcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZUNsYXp6IOWfuuexu1xyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIGVtcHR5Rm4gPSBmdW5jdGlvbigpIHt9O1xyXG4gICAgLy/liJ3lp4vpu5jorqTphY3nva5cclxuICAgIHZhciBjb25maWdfZGVmYXVsdCA9IHtcclxuICAgICAgICAvL+e6v+eoi+axoFwi57q/56iLXCLmlbDph49cclxuICAgICAgICB0aHJlYWQ6IDUsXHJcbiAgICAgICAgLy/lm77niYfliqDovb3lpLHotKXph43or5XmrKHmlbBcclxuICAgICAgICAvL+mHjeivlTLmrKHvvIzliqDkuIrljp/mnInnmoTkuIDmrKHvvIzmgLvlhbHmmK8z5qyhXHJcbiAgICAgICAgXCJ0cmllc1wiOiAyXHJcbiAgICB9O1xyXG4gICAgLy/lt6XlhbdcclxuICAgIHZhciBfaGVscGVycyA9IHtcclxuICAgICAgICAvL+iuvue9rmRvbeWxnuaAp1xyXG4gICAgICAgIHNldEF0dHI6IChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICAvL+WIpOaWrea1j+iniOWZqOaYr+WQpuaUr+aMgUhUTUw1IGRhdGFzZXRcclxuICAgICAgICAgICAgaWYgKGltZy5kYXRhc2V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZG9tLCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbS5kYXRhc2V0W25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkb20sIG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcImRhdGEtXCIgKyBuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSksXHJcbiAgICAgICAgLy/ojrflj5Zkb23lsZ7mgKdcclxuICAgICAgICBnZXRBdHRyOiAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgLy/liKTmlq3mtY/op4jlmajmmK/lkKbmlK/mjIFIVE1MNSBkYXRhc2V0XHJcbiAgICAgICAgICAgIGlmIChpbWcuZGF0YXNldCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvbSwgbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFkb20uZGF0YXNldFtuYW1lXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb20uZ2V0QXR0cmlidXRlKFwiZGF0YS1cIiArIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9tLmRhdGFzZXRbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkb20sIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9tLmdldEF0dHJpYnV0ZShcImRhdGEtXCIgKyBuYW1lKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCkpXHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDmnoTpgKDmlrnms5VcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gbWF4IOacgOWkp+i/nuaOpeaVsOOAguaVsOWAvOOAglxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBJbWFnZVBvb2wobWF4KSB7XHJcbiAgICAgICAgLy/mnIDlpKflubblj5HmlbDph49cclxuICAgICAgICB0aGlzLm1heCA9IG1heCB8fCBjb25maWdfZGVmYXVsdC50aHJlYWQ7XHJcbiAgICAgICAgdGhpcy5saW5rSGVhZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5saW5rTm9kZSA9IG51bGw7XHJcbiAgICAgICAgLy/liqDovb3msaBcclxuICAgICAgICAvL1t7aW1nOiBkb20sZnJlZTogdHJ1ZSwgbm9kZTogbm9kZX1dXHJcbiAgICAgICAgLy9ub2RlXHJcbiAgICAgICAgLy97c3JjOiBcIlwiLCBvcHRpb25zOiB7c3VjY2VzczogXCJmblwiLGVycm9yOiBcImZuXCIsIG9uY2U6IHRydWV9LCB0cmllczogMH1cclxuICAgICAgICB0aGlzLnBvb2wgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5Yid5aeL5YyWXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBJbWFnZVBvb2wucHJvdG90eXBlLmluaXRQb29sID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGksIGltZywgb2JqLCBfcztcclxuICAgICAgICBfcyA9IHRoaXM7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubWF4OyBpKyspIHtcclxuICAgICAgICAgICAgb2JqID0ge307XHJcbiAgICAgICAgICAgIGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICBfaGVscGVycy5zZXRBdHRyKGltZywgXCJpZFwiLCBpKTtcclxuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLy/lm57osINcclxuICAgICAgICAgICAgICAgIF9zLm5vdGljZShfcy5nZXROb2RlKHRoaXMpLCBcInN1Y2Nlc3NcIiwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAvL+WkhOeQhuS7u+WKoVxyXG4gICAgICAgICAgICAgICAgX3MuZXhlY3V0ZUxpbmsodGhpcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IF9zLmdldE5vZGUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAvL+WIpOaWreWwneivleasoeaVsFxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHJpZXMgPCBjb25maWdfZGVmYXVsdC50cmllcykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUudHJpZXMgPSBub2RlLnRyaWVzKzE7XHJcbiAgICAgICAgICAgICAgICAgICAgLy/lho3mrKHov73liqDliLDku7vliqHpk77ooajmnKvlsL5cclxuICAgICAgICAgICAgICAgICAgICBfcy5hcHBlbmROb2RlKF9zLmNyZWF0ZU5vZGUobm9kZS5zcmMsIG5vZGUub3B0aW9ucywgbm9kZS5ub3RpY2UsIG5vZGUuZ3JvdXAsIG5vZGUudHJpZXMpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9lcnJvcuWbnuiwg1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbm9kZS5vcHRpb25zLmVycm9yLmNhbGwobnVsbCwgdGhpcy5zcmMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zLm5vdGljZShub2RlLCBcImVycm9yXCIsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy/lpITnkIbku7vliqFcclxuICAgICAgICAgICAgICAgIF9zLmV4ZWN1dGVMaW5rKHRoaXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBvYmouaW1nID0gaW1nO1xyXG4gICAgICAgICAgICBvYmouZnJlZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMucG9vbC5wdXNoKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Zue6LCD5bCB6KOFXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIG5vZGUg6IqC54K544CC5a+56LGh44CCXHJcbiAgICAgKiBAcGFyYW0gc3RhdHVzIOeKtuaAgeOAguWtl+espuS4suOAguWPr+mAieWAvO+8mnN1Y2Nlc3Mo5oiQ5YqfKXxlcnJvcijlpLHotKUpXHJcbiAgICAgKiBAcGFyYW0gaW1nIOWbvueJh+OAglxyXG4gICAgICovXHJcbiAgICBJbWFnZVBvb2wucHJvdG90eXBlLm5vdGljZSA9IGZ1bmN0aW9uKG5vZGUsIHN0YXR1cywgaW1nKSB7XHJcbiAgICAgICAgbm9kZS5ub3RpY2Uoc3RhdHVzLCBpbWcpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5aSE55CG6ZO+6KGo5Lu75YqhXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIGRvbSDlm77lg49kb23lr7nosaHjgILlr7nosaHjgIJcclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5leGVjdXRlTGluayA9IGZ1bmN0aW9uKGRvbSkge1xyXG4gICAgICAgIC8v5Yik5pat6ZO+6KGo5piv5ZCm5a2Y5Zyo6IqC54K5XHJcbiAgICAgICAgaWYgKHRoaXMubGlua0hlYWQpIHtcclxuICAgICAgICAgICAgLy/liqDovb3kuIvkuIDkuKrlm77niYdcclxuICAgICAgICAgICAgdGhpcy5zZXRTcmMoZG9tLCB0aGlzLmxpbmtIZWFkKTtcclxuICAgICAgICAgICAgLy/ljrvpmaTpk77ooajlpLRcclxuICAgICAgICAgICAgdGhpcy5zaGlmdE5vZGUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL+iuvue9ruiHqui6q+eKtuaAgeS4uuepuumXslxyXG4gICAgICAgICAgICB0aGlzLnN0YXR1cyhkb20sIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluepuumXslwi57q/56iLXCJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuZ2V0RnJlZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBsZW5ndGgsIGk7XHJcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gdGhpcy5wb29sLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvb2xbaV0uZnJlZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9vbFtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWwgeijhXNyY+WxnuaAp+iuvue9rlxyXG4gICAgICog5Zug5Li65pS55Y+Yc3Jj5bGe5oCn55u45b2T5LqO5Yqg6L295Zu+54mH77yM5omA5Lul5oqK5pON5L2c5bCB6KOF6LW35p2lXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIGRvbSDlm77lg49kb23lr7nosaHjgILlr7nosaHjgIJcclxuICAgICAqIEBwYXJhbSBub2RlIOiKgueCueOAguWvueixoeOAglxyXG4gICAgICovXHJcbiAgICBJbWFnZVBvb2wucHJvdG90eXBlLnNldFNyYyA9IGZ1bmN0aW9uKGRvbSwgbm9kZSkge1xyXG4gICAgICAgIC8v6K6+572u5rGg5Lit55qEXCLnur/nqItcIuS4uumdnuepuumXsueKtuaAgVxyXG4gICAgICAgIHRoaXMuc3RhdHVzKGRvbSwgZmFsc2UpO1xyXG4gICAgICAgIC8v5YWz6IGU6IqC54K5XHJcbiAgICAgICAgdGhpcy5zZXROb2RlKGRvbSwgbm9kZSk7XHJcbiAgICAgICAgLy/liqDovb3lm77niYdcclxuICAgICAgICBkb20uc3JjID0gbm9kZS5zcmM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDmm7TmlrDmsaDkuK3nmoRcIue6v+eoi1wi54q25oCBXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIGRvbSDlm77lg49kb23lr7nosaHjgILlr7nosaHjgIJcclxuICAgICAqIEBwYXJhbSBzdGF0dXMg54q25oCB44CC5biD5bCU44CC5Y+v6YCJ5YC877yadHJ1ZSjnqbrpl7IpfGZhbHNlKOmdnuepuumXsilcclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5zdGF0dXMgPSBmdW5jdGlvbihkb20sIHN0YXR1cykge1xyXG4gICAgICAgIHZhciBpZCA9IF9oZWxwZXJzLmdldEF0dHIoZG9tLCBcImlkXCIpO1xyXG4gICAgICAgIGlmKGlkKXtcclxuICAgICAgICAgICAgdGhpcy5wb29sW2lkXS5mcmVlID0gc3RhdHVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy/nqbrpl7LnirbmgIHvvIzmuIXpmaTlhbPogZTnmoToioLngrlcclxuICAgICAgICBpZiAoc3RhdHVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9vbFtpZF0ubm9kZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5pu05paw5rGg5Lit55qEXCLnur/nqItcIueahOWFs+iBlOiKgueCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSBkb20g5Zu+5YOPZG9t5a+56LGh44CC5a+56LGh44CCXHJcbiAgICAgKiBAcGFyYW0gbm9kZSDoioLngrnjgILlr7nosaHjgIJcclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5zZXROb2RlID0gZnVuY3Rpb24oZG9tLCBub2RlKSB7XHJcbiAgICAgICAgdmFyIGlkID0gX2hlbHBlcnMuZ2V0QXR0cihkb20sIFwiaWRcIik7XHJcbiAgICAgICAgaWYoaWQpe1xyXG4gICAgICAgICAgICB0aGlzLnBvb2xbaWRdLm5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb29sW2lkXS5ub2RlID09PSBub2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bmsaDkuK3nmoRcIue6v+eoi1wi55qE5YWz6IGU6IqC54K5XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIGRvbSDlm77lg49kb23lr7nosaHjgILlr7nosaHjgIJcclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5nZXROb2RlID0gZnVuY3Rpb24oZG9tKSB7XHJcbiAgICAgICAgdmFyIGlkID0gX2hlbHBlcnMuZ2V0QXR0cihkb20sIFwiaWRcIik7XHJcbiAgICAgICAgaWYoaWQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb29sW2lkXS5ub2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlr7nlpJbmjqXlj6PvvIzliqDovb3lm77niYdcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gc3JjIOWPr+S7peaYr3NyY+Wtl+espuS4su+8jOS5n+WPr+S7peaYr3NyY+Wtl+espuS4suaVsOe7hOOAglxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMg55So5oi36Ieq5a6a5LmJ5Y+C5pWw44CC5YyF5ZCr77yac3VjY2Vzc+Wbnuiwg+OAgWVycm9y5Zue6LCD44CBb25jZeagh+ivhuOAglxyXG4gICAgICovXHJcbiAgICBJbWFnZVBvb2wucHJvdG90eXBlLl9sb2FkID0gZnVuY3Rpb24oc3JjLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHNyY3MgPSBbXSxcclxuICAgICAgICAgICAgZnJlZSA9IG51bGwsXHJcbiAgICAgICAgICAgIGxlbmd0aCA9IDAsXHJcbiAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAvL+WPquWIneWni+WMluS4gOasoeWbnuiwg+etlueVpVxyXG4gICAgICAgICAgICBub3RpY2UgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXR1cywgaW1nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnID0gdGhpcy5ncm91cCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v6K6w5b2VXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdbc3RhdHVzXS5wdXNoKGltZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v5Yik5pat5pS557uE5piv5ZCm5YWo6YOo5aSE55CG5a6M5oiQXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnLnN1Y2Nlc3MubGVuZ3RoICsgZy5lcnJvci5sZW5ndGggPT09IGcuY291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8v5byC5q2lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL+WunumZheS4iuaYr+S9nOS4uuWPpuS4gOS4quS7u+WKoeWNleeLrOaJp+ihjO+8jOmYsuatouWbnuiwg+WHveaVsOaJp+ihjOaXtumXtOi/h+mVv+W9seWTjeWbvueJh+WKoOi9vemAn+W6plxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLnN1Y2Nlc3MuY2FsbChudWxsLCBnLnN1Y2Nlc3MsIGcuZXJyb3IsIGcuY291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RhdHVzLCBpbWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8v55u05o6l5Zue6LCDXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvW3N0YXR1c10uY2FsbChudWxsLCBpbWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KCkpLFxyXG4gICAgICAgICAgICBncm91cCA9IHtcclxuICAgICAgICAgICAgICAgIGNvdW50OiAwLFxyXG4gICAgICAgICAgICAgICAgc3VjY2VzczogW10sXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogW11cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgb3B0aW9ucy5zdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzIHx8IGVtcHR5Rm47XHJcbiAgICAgICAgb3B0aW9ucy5lcnJvciA9IG9wdGlvbnMuZXJyb3IgfHwgZW1wdHlGbjtcclxuICAgICAgICBzcmNzID0gc3Jjcy5jb25jYXQoc3JjKTtcclxuICAgICAgICAvL+iuvue9rue7hOWFg+e0oOS4quaVsFxyXG4gICAgICAgIGdyb3VwLmNvdW50ID0gc3Jjcy5sZW5ndGg7XHJcbiAgICAgICAgLy/pgY3ljobpnIDopoHliqDovb3nmoTlm77niYdcclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzcmNzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8v5Yib5bu66IqC54K5XHJcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoc3Jjc1tpXSwgb3B0aW9ucywgbm90aWNlLCBncm91cCk7XHJcbiAgICAgICAgICAgIC8v5Yik5pat57q/56iL5rGg5piv5ZCm5pyJ56m66ZeyXHJcbiAgICAgICAgICAgIGZyZWUgPSB0aGlzLmdldEZyZWUoKTtcclxuICAgICAgICAgICAgaWYgKGZyZWUpIHtcclxuICAgICAgICAgICAgICAgIC8v5pyJ56m66Zey77yM5YiZ56uL5Y2z5Yqg6L295Zu+54mHXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNyYyhmcmVlLmltZywgbm9kZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL+ayoeacieepuumXsu+8jOWwhuS7u+WKoea3u+WKoOWIsOmTvuihqFxyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmROb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W5YaF6YOo54q25oCB5L+h5oGvXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5faW5mbyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpbmZvID0ge30sXHJcbiAgICAgICAgICAgIGxlbmd0aCA9IDAsXHJcbiAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICBub2RlID0gbnVsbDtcclxuICAgICAgICAvL+e6v+eoi1xyXG4gICAgICAgIGluZm8udGhyZWFkID0ge307XHJcbiAgICAgICAgLy/nur/nqIvmgLvmlbDph49cclxuICAgICAgICBpbmZvLnRocmVhZC5jb3VudCA9IHRoaXMucG9vbC5sZW5ndGg7XHJcbiAgICAgICAgLy/nqbrpl7Lnur/nqIvmlbDph49cclxuICAgICAgICBpbmZvLnRocmVhZC5mcmVlID0gMDtcclxuICAgICAgICAvL+S7u+WKoVxyXG4gICAgICAgIGluZm8udGFzayA9IHt9O1xyXG4gICAgICAgIC8v5b6F5aSE55CG5Lu75Yqh5pWw6YePXHJcbiAgICAgICAgaW5mby50YXNrLmNvdW50ID0gMDtcclxuICAgICAgICAvL+iOt+WPluepuumXslwi57q/56iLXCLmlbDph49cclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB0aGlzLnBvb2wubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucG9vbFtpXS5mcmVlKSB7XHJcbiAgICAgICAgICAgICAgICBpbmZvLnRocmVhZC5mcmVlID0gaW5mby50aHJlYWQuZnJlZSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy/ojrflj5bku7vliqHmlbDph48o5Lu75Yqh6ZO+6ZW/5bqmKVxyXG4gICAgICAgIG5vZGUgPSB0aGlzLmxpbmtIZWFkO1xyXG4gICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgIGluZm8udGFzay5jb3VudCA9IGluZm8udGFzay5jb3VudCArIDE7XHJcbiAgICAgICAgICAgIHdoaWxlIChub2RlLm5leHQpIHtcclxuICAgICAgICAgICAgICAgIGluZm8udGFzay5jb3VudCA9IGluZm8udGFzay5jb3VudCArIDE7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbmZvO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uuiKgueCuVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSBzcmMg5Zu+54mH6Lev5b6E44CC5a2X56ym5Liy44CCXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyDnlKjmiLfoh6rlrprkuYnlj4LmlbDjgILljIXlkKvvvJpzdWNjZXNz5Zue6LCD44CBZXJyb3Llm57osIPjgIFvbmNl5qCH6K+G44CCXHJcbiAgICAgKiBAcGFyYW0gbm90aWNlIOWbnuiwg+etlueVpeOAgiDlh73mlbDjgIJcclxuICAgICAqIEBwYXJhbSBncm91cCDnu4Tkv6Hmga/jgILlr7nosaHjgIJ7Y291bnQ6IDAsIHN1Y2Nlc3M6IFtdLCBlcnJvcjogW119XHJcbiAgICAgKiBAcGFyYW0gdHIg5Ye66ZSZ6YeN6K+V5qyh5pWw44CC5pWw5YC844CC6buY6K6k5Li6MOOAglxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24oc3JjLCBvcHRpb25zLCBub3RpY2UsIGdyb3VwLCB0cikge1xyXG4gICAgICAgIHZhciBub2RlID0ge307XHJcbiAgICAgICAgbm9kZS5zcmMgPSBzcmM7XHJcbiAgICAgICAgbm9kZS5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICBub2RlLm5vdGljZSA9IG5vdGljZTtcclxuICAgICAgICBub2RlLmdyb3VwID0gZ3JvdXA7XHJcbiAgICAgICAgbm9kZS50cmllcyA9IHRyIHx8IDA7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlkJHku7vliqHpk77ooajmnKvlsL7ov73liqDoioLngrlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gbm9kZSDoioLngrnjgILlr7nosaHjgIJcclxuICAgICAqL1xyXG4gICAgSW1hZ2VQb29sLnByb3RvdHlwZS5hcHBlbmROb2RlID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgIC8v5Yik5pat6ZO+6KGo5piv5ZCm5Li656m6XHJcbiAgICAgICAgaWYgKCF0aGlzLmxpbmtIZWFkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlua0hlYWQgPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLmxpbmtOb2RlID0gbm9kZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmtOb2RlLm5leHQgPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLmxpbmtOb2RlID0gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDliKDpmaTpk77ooajlpLRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIEltYWdlUG9vbC5wcm90b3R5cGUuc2hpZnROb2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy/liKTmlq3pk77ooajmmK/lkKblrZjlnKjoioLngrlcclxuICAgICAgICBpZiAodGhpcy5saW5rSGVhZCkge1xyXG4gICAgICAgICAgICAvL+S/ruaUuemTvuihqOWktFxyXG4gICAgICAgICAgICB0aGlzLmxpbmtIZWFkID0gdGhpcy5saW5rSGVhZC5uZXh0IHx8IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yid5aeL5YyW5Zu+54mH5rGgXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IOacgOWkp+i/nuaOpeaVsOOAguaVsOWAvOOAglxyXG4gICAgICogQHJldHVybnMge3tsb2FkOiBGdW5jdGlvbiwgaW5mbzogRnVuY3Rpb259fVxyXG4gICAgICovXHJcbiAgICB2YXIgaW5pdEltYWdlUG9vbCA9IGZ1bmN0aW9uKG1heCkge1xyXG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBJbWFnZVBvb2wobWF4KTtcclxuICAgICAgICBpbnN0YW5jZS5pbml0UG9vbCgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiDliqDovb3lm77niYdcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHNyYyDlj6/ku6XmmK9zcmPlrZfnrKbkuLLvvIzkuZ/lj6/ku6XmmK9zcmPlrZfnrKbkuLLmlbDnu4TjgIJcclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMg55So5oi36Ieq5a6a5LmJ5Y+C5pWw44CC5YyF5ZCr77yac3VjY2Vzc+Wbnuiwg+OAgWVycm9y5Zue6LCD44CBb25jZeagh+ivhuOAglxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5zdWNjZXNzXSBzdWNjZXNz5Zue6LCDXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmVycm9yXSBlcnJvcuWbnuiwg1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm9uY2VdIOaYr+WQpuWFqOmDqOWKoOi9veWujOavleWQju+8jOS4gOasoeWbnuiwg1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgbG9hZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5fbG9hZC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIOiOt+WPluWGhemDqOeKtuaAgeS/oeaBr1xyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaW5mbzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UuX2luZm8uY2FsbChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHsgaW5pdEltYWdlUG9vbDogaW5pdEltYWdlUG9vbCB9XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvSW1hZ2VQb29sLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbiAgICB2YXIgVG9vbHRpcENvbnRlbnQgPSByZXF1aXJlKCcuL1Rvb2x0aXBDb250ZW50Jyk7XHJcbiAgICB2YXIgZ2xvYmFsTGlzdGVuZXIgPSByZXF1aXJlKCcuL2dsb2JhbExpc3RlbmVyJyk7XHJcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvbW9kZWwnKTtcclxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2VudicpO1xyXG4gICAgdmFyIGZsb3dVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9GbG93VXRpbCcpO1xyXG4gICAgdmFyIGxheW91dCA9IHJlcXVpcmUoXCIuLi9sYXlvdXQvbGF5b3V0XCIpO1xyXG4gICAgZnVuY3Rpb24gVG9vbHRpcFZpZXcodG9vbHRpcE1vZGVsLCBhcGkpIHtcclxuICAgICAgICB0aGlzLl90b29sdGlwQ29udGVudCA9IG5ldyBUb29sdGlwQ29udGVudChhcGkuZ2V0RG9tKCksYXBpKTtcclxuICAgICAgICB0aGlzLl9hcGkgPSBhcGk7XHJcbiAgICAgICAgdGhpcy5fdG9vbHRpcE1vZGVsID0gdG9vbHRpcE1vZGVsO1xyXG4gICAgICAgIHRoaXMuX2Fsd2F5c1Nob3dDb250ZW50ID0gdG9vbHRpcE1vZGVsLmdldCgnYWx3YXlzU2hvd0NvbnRlbnQnKTtcclxuICAgICAgICB0aGlzLl9pbml0R2xvYWJsTGlzdGVuZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBUb29sdGlwVmlldy5wcm90b3R5cGUuX2luaXRHbG9hYmxMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0cmlnZ2VyT24gPSB0aGlzLl90b29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyT24nKTtcclxuICAgICAgICAvLyDlvZPmnIkgJ2NsaWNrJyB8ICdtb3VzZW1vdmUnIHwgJ25vbmUnIOS6i+S7tuaXtuinpuWPkeWbnuiwg1xyXG4gICAgICAgIGdsb2JhbExpc3RlbmVyLnJlZ2lzdGVyKFxyXG4gICAgICAgICAgICAnaXRlbVRvb2x0aXAnLFxyXG4gICAgICAgICAgICB0aGlzLl9hcGksXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uKGN1cnJUcmlnZ2VyLCBlLCBkaXNwYXRjaEFjdGlvbil7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlck9uICE9PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJpZ2dlck9uLmluZGV4T2YoY3VyclRyaWdnZXIpID49IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyeVNob3coZSwgZGlzcGF0Y2hBY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyVHJpZ2dlciA9PT0gJ2xlYXZlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWRlKGRpc3BhdGNoQWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICAgICAgKVxyXG4gICAgfTtcclxuXHJcbiAgICBUb29sdGlwVmlldy5wcm90b3R5cGUuX3RyeVNob3cgPSBmdW5jdGlvbihlLCBkaXNwYXRjaEFjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgZWwgPSBlLnRhcmdldDtcclxuICAgICAgICAgICAgdmFyIHRvb2x0aXBNb2RlbCA9IHRoaXMuX3Rvb2x0aXBNb2RlbDtcclxuXHJcbiAgICAgICAgICAgIGlmICghdG9vbHRpcE1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNhdmUgbW91c2UgeCwgbW91c2UgeS4gU28gd2UgY2FuIHRyeSB0byBrZWVwIHNob3dpbmcgdGhlIHRpcCBpZiBjaGFydCBpcyByZWZyZXNoZWRcclxuICAgICAgICAgICAgdGhpcy5fbGFzdFggPSBlLm9mZnNldFg7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RZID0gZS5vZmZzZXRZO1xyXG5cclxuICAgICAgICAgICAgaWYgKGVsICYmIGVsLnRvb2x0aXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dDb21wb25lbnRJdGVtVG9vbHRpcChlLCBlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWRlKGRpc3BhdGNoQWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAgVG9vbHRpcFZpZXcucHJvdG90eXBlLl9oaWRlID0gZnVuY3Rpb24oZGlzcGF0Y2hBY3Rpb24pIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90IGRpcmVjdGx5IGhpZGVMYXRlciBoZXJlLCBiZWNhdXNlIHRoaXMgYmVoYXZpb3IgbWF5IGJlIHByZXZlbnRlZFxyXG4gICAgICAgICAgICAvLyBpbiBkaXNwYXRjaEFjdGlvbiB3aGVuIHNob3dUaXAgaXMgZGlzcGF0Y2hlZC5cclxuXHJcbiAgICAgICAgICAgIC8vIEZJWE1FXHJcbiAgICAgICAgICAgIC8vIGR1cGxpY2F0ZWQgaGlkZVRpcCBpZiBtYW51YWxseUhpZGVUaXAgaXMgY2FsbGVkIGZyb20gZGlzcGF0Y2hBY3Rpb24uXHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IG51bGw7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoQWN0aW9uKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdoaWRlVGlwJyxcclxuICAgICAgICAgICAgICAgIGZyb206IHRoaXMudWlkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLm1hbnVhbGx5SGlkZVRpcCgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgVG9vbHRpcFZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChlbnYubm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBDb250ZW50LmhpZGUoKTtcclxuICAgICAgICAgICAgZ2xvYmFsTGlzdGVuZXIudW5yZWdpc3RlcignaXRlbVRvb2x0aXAnLCB0aGlzLl9hcGkpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5tYW51YWxseUhpZGVUaXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0b29sdGlwQ29udGVudCA9IHRoaXMuX3Rvb2x0aXBDb250ZW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hbHdheXNTaG93Q29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgdG9vbHRpcENvbnRlbnQuaGlkZUxhdGVyKHRoaXMuX3Rvb2x0aXBNb2RlbC5nZXQoJ2hpZGVEZWxheScpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fbGFzdFggPSB0aGlzLl9sYXN0WSA9IG51bGw7XHJcblxyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5fc2hvd0NvbXBvbmVudEl0ZW1Ub29sdGlwID0gZnVuY3Rpb24gKGUsIGVsKSB7XHJcbiAgICAgICAgICAgIHZhciB0b29sdGlwT3B0ID0gZWwudG9vbHRpcDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b29sdGlwT3B0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB0b29sdGlwT3B0O1xyXG4gICAgICAgICAgICAgICAgdG9vbHRpcE9wdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeGVkIGZvcm1hdHRlclxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogY29udGVudFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3ViVG9vbHRpcE1vZGVsID0gbmV3IE1vZGVsKHRvb2x0aXBPcHQsIHRoaXMuX3Rvb2x0aXBNb2RlbCk7XHJcbiAgICAgICAgICAgIHZhciBkZWZhdWx0SHRtbCA9IHN1YlRvb2x0aXBNb2RlbC5nZXQoJ2NvbnRlbnQnKTtcclxuICAgICAgICAgICAgdmFyIGFzeW5jVGlja2V0ID0gTWF0aC5yYW5kb20oKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERvIG5vdCBjaGVjayB3aGV0aGVyIGB0cmlnZ2VyYCBpcyAnbm9uZScgaGVyZSwgYmVjYXVzZSBgdHJpZ2dlcmBcclxuICAgICAgICAgICAgLy8gb25seSB3b3JrcyBvbiBjb29yaWRpbmF0ZSBzeXN0ZW0uIEluIGZhY3QsIHdlIGhhdmUgbm90IGZvdW5kIGNhc2VcclxuICAgICAgICAgICAgLy8gdGhhdCByZXF1aXJlcyBzZXR0aW5nIGB0cmlnZ2VyYCBub3RoaW5nIG9uIGNvbXBvbmVudCB5ZXQuXHJcblxyXG4gICAgICAgICAgICB0aGlzLl9zaG93T3JNb3ZlKHN1YlRvb2x0aXBNb2RlbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXBDb250ZW50KFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YlRvb2x0aXBNb2RlbCwgZGVmYXVsdEh0bWwsIHN1YlRvb2x0aXBNb2RlbC5nZXQoJ2Zvcm1hdHRlclBhcmFtcycpIHx8IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jVGlja2V0LCBlLm9mZnNldFgsIGUub2Zmc2V0WSwgZS5wb3NpdGlvbiwgZWxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5fc2hvd09yTW92ZSA9IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGNiKSB7XHJcbiAgICAgICAgICAgIC8vIHNob3dEZWxheSBpcyB1c2VkIGluIHRoaXMgY2FzZTogdG9vbHRpcC5lbnRlcmFibGUgaXMgc2V0XHJcbiAgICAgICAgICAgIC8vIGFzIHRydWUuIFVzZXIgaW50ZW50IHRvIG1vdmUgbW91c2UgaW50byB0b29sdGlwIGFuZCBjbGlja1xyXG4gICAgICAgICAgICAvLyBzb21ldGhpbmcuIGBzaG93RGVsYXlgIG1ha2VzIGl0IGVhc3llciB0byBlbnRlciB0aGUgY29udGVudFxyXG4gICAgICAgICAgICAvLyBidXQgdG9vbHRpcCBkbyBub3QgbW92ZSBpbW1lZGlhdGVseS5cclxuICAgICAgICAgICAgdmFyIGRlbGF5ID0gdG9vbHRpcE1vZGVsLmdldCgnc2hvd0RlbGF5Jyk7XHJcbiAgICAgICAgICAgIGNiID0genJVdGlsLmJpbmQoY2IsIHRoaXMpO1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc2hvd1RpbW91dCk7XHJcbiAgICAgICAgICAgIGRlbGF5ID4gMFxyXG4gICAgICAgICAgICAgICAgPyAodGhpcy5fc2hvd1RpbW91dCA9IHNldFRpbWVvdXQoY2IsIGRlbGF5KSlcclxuICAgICAgICAgICAgICAgIDogY2IoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBUb29sdGlwVmlldy5wcm90b3R5cGUuX3Nob3dUb29sdGlwQ29udGVudCA9IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGRlZmF1bHRIdG1sLCBwYXJhbXMsIGFzeW5jVGlja2V0LCB4LCB5LCBwb3NpdGlvbkV4cHIsIGVsKSB7XHJcbiAgICAgICAgICAgIC8vIFJlc2V0IHRpY2tldFxyXG4gICAgICAgICAgICB0aGlzLl90aWNrZXQgPSAnJztcclxuXHJcbiAgICAgICAgICAgIGlmICghdG9vbHRpcE1vZGVsLmdldCgnc2hvd0NvbnRlbnQnKSB8fCAhdG9vbHRpcE1vZGVsLmdldCgnc2hvdycpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB0b29sdGlwQ29udGVudCA9IHRoaXMuX3Rvb2x0aXBDb250ZW50O1xyXG5cclxuICAgICAgICAgICAgdmFyIGZvcm1hdHRlciA9IHRvb2x0aXBNb2RlbC5nZXQoJ2Zvcm1hdHRlcicpO1xyXG4gICAgICAgICAgICBwb3NpdGlvbkV4cHIgPSBwb3NpdGlvbkV4cHIgfHwgdG9vbHRpcE1vZGVsLmdldCgncG9zaXRpb24nKTtcclxuICAgICAgICAgICAgdmFyIGh0bWwgPSBkZWZhdWx0SHRtbDtcclxuXHJcbiAgICAgICAgICAgIGlmIChmb3JtYXR0ZXIgJiYgdHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGh0bWwgPSBmbG93VXRpbC5mb3JtYXRUcGwoZm9ybWF0dGVyLCBwYXJhbXMsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChjYlRpY2tldCwgaHRtbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYlRpY2tldCA9PT0gdGhpcy5fdGlja2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LnNldENvbnRlbnQoaHRtbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcE1vZGVsLCBwb3NpdGlvbkV4cHIsIHgsIHksIHRvb2x0aXBDb250ZW50LCBwYXJhbXMsIGVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGlja2V0ID0gYXN5bmNUaWNrZXQ7XHJcbiAgICAgICAgICAgICAgICBodG1sID0gZm9ybWF0dGVyKHBhcmFtcywgYXN5bmNUaWNrZXQsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdG9vbHRpcENvbnRlbnQuc2V0Q29udGVudChodG1sKTtcclxuICAgICAgICAgICAgdG9vbHRpcENvbnRlbnQuc2hvdyh0b29sdGlwTW9kZWwpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oXHJcbiAgICAgICAgICAgICAgICB0b29sdGlwTW9kZWwsIHBvc2l0aW9uRXhwciwgeCwgeSwgdG9vbHRpcENvbnRlbnQsIHBhcmFtcywgZWxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd8RnVuY3Rpb258QXJyYXkuPG51bWJlcj59IHBvc2l0aW9uRXhwclxyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geCBNb3VzZSB4XHJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5IE1vdXNlIHlcclxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjb25maW5lIFdoZXRoZXIgY29uZmluZSB0b29sdGlwIGNvbnRlbnQgaW4gdmlldyByZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdHw8QXJyYXkuPE9iamVjdD59IHBhcmFtc1xyXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XHJcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcclxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBUb29sdGlwVmlldy5wcm90b3R5cGUuX3VwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgcG9zaXRpb25FeHByLCB4LCB5LCBjb250ZW50LCBwYXJhbXMsIGVsKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3V2lkdGggPSB0aGlzLl9hcGkuZ2V0V2lkdGgoKTtcclxuICAgICAgICAgICAgdmFyIHZpZXdIZWlnaHQgPSB0aGlzLl9hcGkuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRXhwciA9IHBvc2l0aW9uRXhwciB8fCB0b29sdGlwTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRTaXplID0gY29udGVudC5nZXRTaXplKCk7XHJcbiAgICAgICAgICAgIHZhciBhbGlnbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ2FsaWduJyk7XHJcbiAgICAgICAgICAgIHZhciB2QWxpZ24gPSB0b29sdGlwTW9kZWwuZ2V0KCd2ZXJ0aWNhbEFsaWduJyk7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gZWwgJiYgZWwuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcclxuICAgICAgICAgICAgZWwgJiYgcmVjdC5hcHBseVRyYW5zZm9ybShlbC50cmFuc2Zvcm0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbkV4cHIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIC8vIENhbGxiYWNrIG9mIHBvc2l0aW9uIGNhbiBiZSBhbiBhcnJheSBvciBhIHN0cmluZyBzcGVjaWZ5IHRoZSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25FeHByID0gcG9zaXRpb25FeHByKFt4LCB5XSwgcGFyYW1zLCBjb250ZW50LmVsLCByZWN0LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld1NpemU6IFt2aWV3V2lkdGgsIHZpZXdIZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRTaXplOiBjb250ZW50U2l6ZS5zbGljZSgpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHpyVXRpbC5pc0FycmF5KHBvc2l0aW9uRXhwcikpIHtcclxuICAgICAgICAgICAgICAgIHggPSBmbG93VXRpbC5wYXJzZVBlcmNlbnQocG9zaXRpb25FeHByWzBdLCB2aWV3V2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgeSA9IGZsb3dVdGlsLnBhcnNlUGVyY2VudChwb3NpdGlvbkV4cHJbMV0sIHZpZXdIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHpyVXRpbC5pc09iamVjdChwb3NpdGlvbkV4cHIpKSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIud2lkdGggPSBjb250ZW50U2l6ZVswXTtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uRXhwci5oZWlnaHQgPSBjb250ZW50U2l6ZVsxXTtcclxuICAgICAgICAgICAgICAgIHZhciBsYXlvdXRSZWN0ID0gbGF5b3V0LmdldExheW91dFJlY3QoXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25FeHByLCB7d2lkdGg6IHZpZXdXaWR0aCwgaGVpZ2h0OiB2aWV3SGVpZ2h0fVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHggPSBsYXlvdXRSZWN0Lng7XHJcbiAgICAgICAgICAgICAgICB5ID0gbGF5b3V0UmVjdC55O1xyXG4gICAgICAgICAgICAgICAgYWxpZ24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgLy8gV2hlbiBwb3NpdGlvbkV4cHIgaXMgbGVmdC90b3AvcmlnaHQvYm90dG9tLFxyXG4gICAgICAgICAgICAgICAgLy8gYWxpZ24gYW5kIHZlcnRpY2FsQWxpZ24gd2lsbCBub3Qgd29yay5cclxuICAgICAgICAgICAgICAgIHZBbGlnbiA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU3BlY2lmeSB0b29sdGlwIHBvc2l0aW9uIGJ5IHN0cmluZyAndG9wJyAnYm90dG9tJyAnbGVmdCcgJ3JpZ2h0JyBhcm91bmQgZ3JhcGhpYyBlbGVtZW50XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwb3NpdGlvbkV4cHIgPT09ICdzdHJpbmcnICYmIGVsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gY2FsY1Rvb2x0aXBQb3NpdGlvbihcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIsIHJlY3QsIGNvbnRlbnRTaXplXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgeCA9IHBvc1swXTtcclxuICAgICAgICAgICAgICAgIHkgPSBwb3NbMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zMSA9IHJlZml4VG9vbHRpcFBvc2l0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgIHgsIHksIGNvbnRlbnQuZWwsIHZpZXdXaWR0aCwgdmlld0hlaWdodCwgYWxpZ24gPyAwIDogMjAsIHZBbGlnbiA/IDAgOiAyMFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIHggPSBwb3MxWzBdO1xyXG4gICAgICAgICAgICAgICAgeSA9IHBvczFbMV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFsaWduICYmICh4IC09IGlzQ2VudGVyQWxpZ24oYWxpZ24pID8gY29udGVudFNpemVbMF0gLyAyIDogYWxpZ24gPT09ICdyaWdodCcgPyBjb250ZW50U2l6ZVswXSA6IDApO1xyXG4gICAgICAgICAgICB2QWxpZ24gJiYgKHkgLT0gaXNDZW50ZXJBbGlnbih2QWxpZ24pID8gY29udGVudFNpemVbMV0gLyAyIDogdkFsaWduID09PSAnYm90dG9tJyA/IGNvbnRlbnRTaXplWzFdIDogMCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodG9vbHRpcE1vZGVsLmdldCgnY29uZmluZScpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zMiA9IGNvbmZpbmVUb29sdGlwUG9zaXRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgeCwgeSwgY29udGVudC5lbCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgeCA9IHBvczJbMF07XHJcbiAgICAgICAgICAgICAgICB5ID0gcG9zMlsxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29udGVudC5tb3ZlVG8oeCwgeSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNhbGNUb29sdGlwUG9zaXRpb24ocG9zaXRpb24sIHJlY3QsIGNvbnRlbnRTaXplKSB7XHJcbiAgICAgICAgdmFyIGRvbVdpZHRoID0gY29udGVudFNpemVbMF07XHJcbiAgICAgICAgdmFyIGRvbUhlaWdodCA9IGNvbnRlbnRTaXplWzFdO1xyXG4gICAgICAgIHZhciBnYXAgPSA1O1xyXG4gICAgICAgIHZhciB4ID0gMDtcclxuICAgICAgICB2YXIgeSA9IDA7XHJcbiAgICAgICAgdmFyIHJlY3RXaWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgdmFyIHJlY3RIZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZSc6XHJcbiAgICAgICAgICAgICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoIC8gMiAtIGRvbVdpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0IC8gMiAtIGRvbUhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggKyByZWN0V2lkdGggLyAyIC0gZG9tV2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgeSA9IHJlY3QueSAtIGRvbUhlaWdodCAtIGdhcDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCArIHJlY3RXaWR0aCAvIDIgLSBkb21XaWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcmVjdEhlaWdodCArIGdhcDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggLSBkb21XaWR0aCAtIGdhcDtcclxuICAgICAgICAgICAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0IC8gMiAtIGRvbUhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCArIHJlY3RXaWR0aCArIGdhcDtcclxuICAgICAgICAgICAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0IC8gMiAtIGRvbUhlaWdodCAvIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWZpeFRvb2x0aXBQb3NpdGlvbih4LCB5LCBlbCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0LCBnYXBILCBnYXBWKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gZWwuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKHggKyB3aWR0aCArIGdhcEggPiB2aWV3V2lkdGgpIHtcclxuICAgICAgICAgICAgeCAtPSB3aWR0aCArIGdhcEg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB4ICs9IGdhcEg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5ICsgaGVpZ2h0ICsgZ2FwViA+IHZpZXdIZWlnaHQpIHtcclxuICAgICAgICAgICAgeSAtPSBoZWlnaHQgKyBnYXBWO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgeSArPSBnYXBWO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzQ2VudGVyQWxpZ24oYWxpZ24pIHtcclxuICAgICAgICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInIHx8IGFsaWduID09PSAnbWlkZGxlJztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb25maW5lVG9vbHRpcFBvc2l0aW9uKHgsIHksIGVsLCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSBlbC5jbGllbnRXaWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xyXG5cclxuICAgICAgICB4ID0gTWF0aC5taW4oeCArIHdpZHRoLCB2aWV3V2lkdGgpIC0gd2lkdGg7XHJcbiAgICAgICAgeSA9IE1hdGgubWluKHkgKyBoZWlnaHQsIHZpZXdIZWlnaHQpIC0gaGVpZ2h0O1xyXG4gICAgICAgIHggPSBNYXRoLm1heCh4LCAwKTtcclxuICAgICAgICB5ID0gTWF0aC5tYXgoeSwgMCk7XHJcblxyXG4gICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICB9XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRvb2x0aXBWaWV3O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9maXNoLXRvcG8tZmxvdy9saWIvdG9vbHRpcC9Ub29sdGlwVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG4gICAgdmFyIHpyQ29sb3IgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi90b29sL2NvbG9yJyk7XHJcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS9lbnYnKTtcclxuICAgIHZhciBldmVudFV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2V2ZW50Jyk7XHJcbiAgICB2YXIgZmxvd1V0aWwgPSByZXF1aXJlKCcuLi91dGlsL0Zsb3dVdGlsJyk7XHJcbiAgICB2YXIgdG9DYW1lbENhc2UgPSBmbG93VXRpbC50b0NhbWVsQ2FzZTtcclxuICAgIHZhciBub3JtYWxpemVDc3NBcnJheSA9IGZsb3dVdGlsLm5vcm1hbGl6ZUNzc0FycmF5O1xyXG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcclxuXHJcblxyXG4gICAgdmFyIHZlbmRvcnMgPSBbJycsICctd2Via2l0LScsICctbW96LScsICctby0nXTtcclxuXHJcbiAgICB2YXIgZ0Nzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jaztib3JkZXItc3R5bGU6c29saWQ7d2hpdGUtc3BhY2U6bm93cmFwO3otaW5kZXg6OTk5Oyc7Ly9maXNoIHBvcHVwIHppbmRleDoxMDUwXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFzc2VtYmxlVHJhbnNpdGlvbihkdXJhdGlvbikge1xyXG4gICAgICAgIHZhciB0cmFuc2l0aW9uQ3VydmUgPSAnY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpJztcclxuICAgICAgICB2YXIgdHJhbnNpdGlvblRleHQgPSAnbGVmdCAnICsgZHVyYXRpb24gKyAncyAnICsgdHJhbnNpdGlvbkN1cnZlICsgJywnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArICd0b3AgJyArIGR1cmF0aW9uICsgJ3MgJyArIHRyYW5zaXRpb25DdXJ2ZTtcclxuICAgICAgICByZXR1cm4genJVdGlsLm1hcCh2ZW5kb3JzLCBmdW5jdGlvbiAodmVuZG9yUHJlZml4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2ZW5kb3JQcmVmaXggKyAndHJhbnNpdGlvbjonICsgdHJhbnNpdGlvblRleHQ7XHJcbiAgICAgICAgfSkuam9pbignOycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRleHRTdHlsZVxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFzc2VtYmxlRm9udCh0ZXh0U3R5bGVNb2RlbCkge1xyXG4gICAgICAgIHZhciBjc3NUZXh0ID0gW107XHJcblxyXG4gICAgICAgIHZhciBmb250U2l6ZSA9IHRleHRTdHlsZU1vZGVsLmdldCgnZm9udFNpemUnKTtcclxuICAgICAgICB2YXIgY29sb3IgPSB0ZXh0U3R5bGVNb2RlbC5nZXQoXCJjb2xvclwiKTtcclxuXHJcbiAgICAgICAgY29sb3IgJiYgY3NzVGV4dC5wdXNoKCdjb2xvcjonICsgY29sb3IpO1xyXG5cclxuICAgICAgICB2YXIgZm9udCA9IHRleHRTdHlsZU1vZGVsLmdldChcImZvbnRcIik7XHJcbiAgICAgICAgZm9udCAmJiBjc3NUZXh0LnB1c2goJ2ZvbnQ6JyArIGZvbnQpO1xyXG5cclxuICAgICAgICBmb250U2l6ZSAmJlxyXG4gICAgICAgICAgICBjc3NUZXh0LnB1c2goJ2xpbmUtaGVpZ2h0OicgKyBNYXRoLnJvdW5kKGZvbnRTaXplICogMyAvIDIpICsgJ3B4Jyk7XHJcblxyXG4gICAgICAgIGVhY2goWydkZWNvcmF0aW9uJywgJ2FsaWduJ10sIGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSB0ZXh0U3R5bGVNb2RlbC5nZXQobmFtZSk7XHJcbiAgICAgICAgICAgIHZhbCAmJiBjc3NUZXh0LnB1c2goJ3RleHQtJyArIG5hbWUgKyAnOicgKyB2YWwpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gY3NzVGV4dC5qb2luKCc7Jyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0b29sdGlwTW9kZWxcclxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhc3NlbWJsZUNzc1RleHQodG9vbHRpcE1vZGVsKSB7XHJcblxyXG4gICAgICAgIHZhciBjc3NUZXh0ID0gW107XHJcblxyXG4gICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSB0b29sdGlwTW9kZWwuZ2V0KCd0cmFuc2l0aW9uRHVyYXRpb24nKTtcclxuICAgICAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gdG9vbHRpcE1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyk7XHJcbiAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gdG9vbHRpcE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcclxuICAgICAgICB2YXIgcGFkZGluZyA9IHRvb2x0aXBNb2RlbC5nZXQoJ3BhZGRpbmcnKTtcclxuXHJcbiAgICAgICAgLy8gQW5pbWF0aW9uIHRyYW5zaXRpb24uIERvIG5vdCBhbmltYXRlIHdoZW4gdHJhbnNpdGlvbkR1cmF0aW9uIGlzIDAuXHJcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uICYmXHJcbiAgICAgICAgICAgIGNzc1RleHQucHVzaChhc3NlbWJsZVRyYW5zaXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKSk7XHJcblxyXG4gICAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcclxuICAgICAgICAgICAgaWYgKGVudi5jYW52YXNTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgIGNzc1RleHQucHVzaCgnYmFja2dyb3VuZC1Db2xvcjonICsgYmFja2dyb3VuZENvbG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGZvciBpZVxyXG4gICAgICAgICAgICAgICAgY3NzVGV4dC5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLUNvbG9yOiMnICsgenJDb2xvci50b0hleChiYWNrZ3JvdW5kQ29sb3IpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgY3NzVGV4dC5wdXNoKCdmaWx0ZXI6YWxwaGEob3BhY2l0eT03MCknKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQm9yZGVyIHN0eWxlXHJcbiAgICAgICAgZWFjaChbJ3dpZHRoJywgJ2NvbG9yJywgJ3JhZGl1cyddLCBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgYm9yZGVyTmFtZSA9ICdib3JkZXItJyArIG5hbWU7XHJcbiAgICAgICAgICAgIHZhciBjYW1lbENhc2UgPSB0b0NhbWVsQ2FzZShib3JkZXJOYW1lKTtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IHRvb2x0aXBNb2RlbC5nZXQoY2FtZWxDYXNlKTtcclxuICAgICAgICAgICAgdmFsICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIGNzc1RleHQucHVzaChib3JkZXJOYW1lICsgJzonICsgdmFsICsgKG5hbWUgPT09ICdjb2xvcicgPyAnJyA6ICdweCcpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gVGV4dCBzdHlsZVxyXG4gICAgICAgIGNzc1RleHQucHVzaChhc3NlbWJsZUZvbnQodGV4dFN0eWxlTW9kZWwpKTtcclxuXHJcbiAgICAgICAgLy8gUGFkZGluZ1xyXG4gICAgICAgIGlmIChwYWRkaW5nICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY3NzVGV4dC5wdXNoKCdwYWRkaW5nOicgKyBub3JtYWxpemVDc3NBcnJheShwYWRkaW5nKS5qb2luKCdweCAnKSArICdweCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNzc1RleHQuam9pbignOycpICsgJzsnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7YW55fSBjb250YWluZXJcclxuICAgICAqIEBwYXJhbSB7YW55fSBhcGlcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gVG9vbHRpcENvbnRlbnQoY29udGFpbmVyLCBhcGkpIHtcclxuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICB2YXIgenIgPSB0aGlzLl96ciA9IGFwaS5nZXRacigpO1xyXG5cclxuICAgICAgICB0aGlzLmVsID0gZWw7XHJcblxyXG4gICAgICAgIHRoaXMuX3ggPSBhcGkuZ2V0V2lkdGgoKSAvIDI7XHJcbiAgICAgICAgdGhpcy5feSA9IGFwaS5nZXRIZWlnaHQoKSAvIDI7XHJcblxyXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcblxyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuXHJcbiAgICAgICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2hpZGVUaW1lb3V0O1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgZWwub25tb3VzZWVudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBjbGVhciB0aGUgdGltZW91dCBpbiBoaWRlTGF0ZXIgYW5kIGtlZXAgc2hvd2luZyB0b29sdGlwXHJcbiAgICAgICAgICAgIGlmIChzZWxmLl9lbnRlcmFibGUpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChzZWxmLl9oaWRlVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9zaG93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxmLl9pbkNvbnRlbnQgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZWwub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XHJcbiAgICAgICAgICAgIGlmICghc2VsZi5fZW50ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUcnkgdHJpZ2dlciB6cmVuZGVyIGV2ZW50IHRvIGF2b2lkIG1vdXNlXHJcbiAgICAgICAgICAgICAgICAvLyBpbiBhbmQgb3V0IHNoYXBlIHRvbyBmcmVxdWVudGx5XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IHpyLmhhbmRsZXI7XHJcbiAgICAgICAgICAgICAgICBldmVudFV0aWwubm9ybWFsaXplRXZlbnQoY29udGFpbmVyLCBlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIuZGlzcGF0Y2goJ21vdXNlbW92ZScsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBlbC5vbm1vdXNlbGVhdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLl9lbnRlcmFibGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9zaG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oaWRlTGF0ZXIoc2VsZi5faGlkZURlbGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxmLl9pbkNvbnRlbnQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgVG9vbHRpcENvbnRlbnQucHJvdG90eXBlID0ge1xyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvcjogVG9vbHRpcENvbnRlbnQsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX2VudGVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlIHdoZW4gdG9vbHRpcCBpcyByZW5kZXJlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBGSVhNRVxyXG4gICAgICAgICAgICAvLyBNb3ZlIHRoaXMgbG9naWMgdG8gZWMgbWFpbj9cclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuICAgICAgICAgICAgdmFyIHN0bCA9IGNvbnRhaW5lci5jdXJyZW50U3R5bGVcclxuICAgICAgICAgICAgICAgIHx8IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcclxuICAgICAgICAgICAgdmFyIGRvbVN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xyXG4gICAgICAgICAgICBpZiAoZG9tU3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgc3RsLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnKSB7XHJcbiAgICAgICAgICAgICAgICBkb21TdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSGlkZSB0aGUgdG9vbHRpcFxyXG4gICAgICAgICAgICAvLyBQRU5ESU5HXHJcbiAgICAgICAgICAgIC8vIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hpZGVUaW1lb3V0KTtcclxuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcclxuXHJcbiAgICAgICAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSBnQ3NzVGV4dCArIGFzc2VtYmxlQ3NzVGV4dCh0b29sdGlwTW9kZWwpXHJcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxMTI1NTg3L2NzczMtdHJhbnNpdGlvbi1ub3Qtd29ya2luZy1pbi1jaHJvbWUtYW55bW9yZVxyXG4gICAgICAgICAgICAgICAgKyAnO2xlZnQ6JyArIHRoaXMuX3ggKyAncHg7dG9wOicgKyB0aGlzLl95ICsgJ3B4OydcclxuICAgICAgICAgICAgICAgICsgKHRvb2x0aXBNb2RlbC5nZXQoJ2V4dHJhQ3NzVGV4dCcpIHx8ICcnKTtcclxuXHJcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5pbm5lckhUTUwgPyAgJ2Jsb2NrJyA6ICdub25lJztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3Nob3cgPSB0cnVlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gY29udGVudDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXRFbnRlcmFibGU6IGZ1bmN0aW9uIChlbnRlcmFibGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW50ZXJhYmxlID0gZW50ZXJhYmxlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcclxuICAgICAgICAgICAgcmV0dXJuIFtlbC5jbGllbnRXaWR0aCwgZWwuY2xpZW50SGVpZ2h0XTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgIC8vIHh5IHNob3VsZCBiZSBiYXNlZCBvbiBjYW52YXMgcm9vdC4gQnV0IHRvb2x0aXBDb250ZW50IGlzXHJcbiAgICAgICAgICAgIC8vIHRoZSBzaWJsaW5nIG9mIGNhbnZhcyByb290LiBTbyBwYWRkaW5nIG9mIGVjIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgY29uc2lkZXJlZCBoZXJlLlxyXG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl96cjtcclxuICAgICAgICAgICAgdmFyIHZpZXdwb3J0Um9vdDtcclxuICAgICAgICAgICAgaWYgKHpyICYmIHpyLnBhaW50ZXIgJiYgKHZpZXdwb3J0Um9vdCA9IHpyLnBhaW50ZXIuZ2V0Vmlld3BvcnRSb290KCkpKSB7XHJcbiAgICAgICAgICAgICAgICB4ICs9IHZpZXdwb3J0Um9vdC5vZmZzZXRMZWZ0IHx8IDA7XHJcbiAgICAgICAgICAgICAgICB5ICs9IHZpZXdwb3J0Um9vdC5vZmZzZXRUb3AgfHwgMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5lbC5zdHlsZTtcclxuICAgICAgICAgICAgc3R5bGUubGVmdCA9IHggKyAncHgnO1xyXG4gICAgICAgICAgICBzdHlsZS50b3AgPSB5ICsgJ3B4JztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xyXG4gICAgICAgICAgICB0aGlzLl95ID0geTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGhpZGVMYXRlcjogZnVuY3Rpb24gKHRpbWUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3cgJiYgISh0aGlzLl9pbkNvbnRlbnQgJiYgdGhpcy5fZW50ZXJhYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWRlRGVsYXkgPSB0aW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBzaG93IGZhbHNlIHRvIGF2b2lkIGludm9rZSBoaWRlTGF0ZXIgbXV0aXBsZSB0aW1lc1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3cgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWRlVGltZW91dCA9IHNldFRpbWVvdXQoenJVdGlsLmJpbmQodGhpcy5oaWRlLCB0aGlzKSwgdGltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzU2hvdzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hvdztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gVG9vbHRpcENvbnRlbnQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi90b29sdGlwL1Rvb2x0aXBDb250ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcblxyXG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvZW52Jyk7XHJcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICB2YXIgZ2V0ID0gcmVxdWlyZSgnLi4vdXRpbC9GbG93VXRpbCcpLm1ha2VHZXR0ZXIoKTtcclxuXHJcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xyXG5cclxuICAgIHZhciBnbG9iYWxMaXN0ZW5lciA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGtleSDms6jlhoznmoTlrZfnrKbkuLJcclxuICAgICAqIEBwYXJhbSBhcGkgRXh0ZW5zaW9uQVBJXHJcbiAgICAgKiBAcGFyYW0gaGFuZGxlciDlpITnkIblm57osINcclxuICAgICAqL1xyXG4gICAgZ2xvYmFsTGlzdGVuZXIucmVnaXN0ZXIgPSBmdW5jdGlvbiAoa2V5LCBhcGksIGhhbmRsZXIpIHtcclxuICAgICAgICBpZiAoZW52Lm5vZGUpIHsgICAvL25vZGXnjq/looPkuIvkuI3miafooYxcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+WIpOaWrXpyZW5kZXLnmoQgcmVjb3JkcyAg5bm25Yid5aeL5YyWXHJcbiAgICAgICAgdmFyIHpyID0gYXBpLmdldFpyKCk7XHJcbiAgICAgICAgZ2V0KHpyKS5yZWNvcmRzIHx8IChnZXQoenIpLnJlY29yZHMgPSB7fSk7XHJcblxyXG4gICAgICAgIGluaXRHbG9iYWxMaXN0ZW5lcnMoenIsIGFwaSk7XHJcblxyXG4gICAgICAgIC8v5bCG5Zue6LCD5Yqg5YWlcmVjb3JkXHJcbiAgICAgICAgdmFyIHJlY29yZCA9IGdldCh6cikucmVjb3Jkc1trZXldIHx8IChnZXQoenIpLnJlY29yZHNba2V5XSA9IHt9KTtcclxuICAgICAgICByZWNvcmQuaGFuZGxlciA9IGhhbmRsZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yid5aeL5YyW5YWo5bGA5L6m5ZCsXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHpyICAgenJlbmRlclxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFwaSAgRXh0ZW5zaW9uQVBJXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpbml0R2xvYmFsTGlzdGVuZXJzKHpyLCBhcGkpIHtcclxuICAgICAgICBpZiAoZ2V0KHpyKS5pbml0aWFsaXplZCkgeyAgIC8v6YG/5YWN6YeN5aSN5Yid5aeL5YyWXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdldCh6cikuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAvL+S+puWQrOS6i+S7tlxyXG4gICAgICAgIHVzZUhhbmRsZXIoJ2NsaWNrJywgenJVdGlsLmN1cnJ5KGRvRW50ZXIsICdjbGljaycpKTtcclxuICAgICAgICB1c2VIYW5kbGVyKCdtb3VzZW1vdmUnLCB6clV0aWwuY3VycnkoZG9FbnRlciwgJ21vdXNlbW92ZScpKTtcclxuICAgICAgICAvLyB1c2VIYW5kbGVyKCdtb3VzZW91dCcsIG9uTGVhdmUpO1xyXG4gICAgICAgIHVzZUhhbmRsZXIoJ2dsb2JhbG91dCcsIG9uTGVhdmUpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1c2VIYW5kbGVyKGV2ZW50VHlwZSwgY2IpIHtcclxuICAgICAgICAgICAgenIub24oZXZlbnRUeXBlLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpcyA9IG1ha2VEaXNwYXRjaEFjdGlvbihhcGkpO1xyXG4gICAgICAgICAgICAgICAgLy/pgY3ljobms6jlhoznmoQg5omA5pyJcmVjb3Jkc++8jCDlubbov5vooYzosIPnlKhcclxuICAgICAgICAgICAgICAgIGVhY2goZ2V0KHpyKS5yZWNvcmRzLCBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkICYmIGNiKHJlY29yZCwgZSwgZGlzLmRpc3BhdGNoQWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGRpc3BhdGNoVG9vbHRpcEZpbmFsbHkoZGlzLnBlbmRpbmdzLCBhcGkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hUb29sdGlwRmluYWxseShwZW5kaW5ncywgYXBpKSB7XHJcbiAgICAgICAgdmFyIHNob3dMZW4gPSBwZW5kaW5ncy5zaG93VGlwLmxlbmd0aDtcclxuICAgICAgICB2YXIgaGlkZUxlbiA9IHBlbmRpbmdzLmhpZGVUaXAubGVuZ3RoO1xyXG5cclxuICAgICAgICB2YXIgYWN0dWFsbHlQYXlsb2FkO1xyXG4gICAgICAgIGlmIChzaG93TGVuKSB7XHJcbiAgICAgICAgICAgIGFjdHVhbGx5UGF5bG9hZCA9IHBlbmRpbmdzLnNob3dUaXBbc2hvd0xlbiAtIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoaWRlTGVuKSB7XHJcbiAgICAgICAgICAgIGFjdHVhbGx5UGF5bG9hZCA9IHBlbmRpbmdzLmhpZGVUaXBbaGlkZUxlbiAtIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWN0dWFsbHlQYXlsb2FkKSB7XHJcbiAgICAgICAgICAgIGFjdHVhbGx5UGF5bG9hZC5kaXNwYXRjaEFjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbihhY3R1YWxseVBheWxvYWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbkxlYXZlKHJlY29yZCwgZSwgZGlzcGF0Y2hBY3Rpb24pIHtcclxuICAgICAgICByZWNvcmQuaGFuZGxlcignbGVhdmUnLCBudWxsLCBkaXNwYXRjaEFjdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZG9FbnRlcihjdXJyVHJpZ2dlciwgcmVjb3JkLCBlLCBkaXNwYXRjaEFjdGlvbikge1xyXG4gICAgICAgIHJlY29yZC5oYW5kbGVyKGN1cnJUcmlnZ2VyLCBlLCBkaXNwYXRjaEFjdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmtL7lj5FhY3Rpb24gICDooYzlsIblj5HnlJ/nmoRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gYXBpXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtYWtlRGlzcGF0Y2hBY3Rpb24oYXBpKSB7XHJcbiAgICAgICAgdmFyIHBlbmRpbmdzID0ge1xyXG4gICAgICAgICAgICBzaG93VGlwOiBbXSxcclxuICAgICAgICAgICAgaGlkZVRpcDogW11cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEZJWE1FXHJcbiAgICAgICAgLy8gYmV0dGVyIGFwcHJvYWNoP1xyXG4gICAgICAgIC8vICdzaG93VGlwJyBhbmQgJ2hpZGVUaXAnIGNhbiBiZSB0cmlnZ2VyZWQgYnkgYXhpc1BvaW50ZXIgYW5kIHRvb2x0aXAsXHJcbiAgICAgICAgLy8gd2hpY2ggbWF5IGJlIGNvbmZsaWN0LCAoYXhpc1BvaW50ZXIgY2FsbCBzaG93VGlwIGJ1dCB0b29sdGlwIGNhbGwgaGlkZVRpcCk7XHJcbiAgICAgICAgLy8gU28gd2UgaGF2ZSB0byBhZGQgXCJmaW5hbCBzdGFnZVwiIHRvIG1lcmdlIHRob3NlIGRpc3BhdGNoZWQgYWN0aW9ucy5cclxuICAgICAgICB2YXIgZGlzcGF0Y2hBY3Rpb24gPSBmdW5jdGlvbiAocGF5bG9hZCkge1xyXG4gICAgICAgICAgICB2YXIgcGVuZGluZ0xpc3QgPSBwZW5kaW5nc1twYXlsb2FkLnR5cGVdO1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZ0xpc3QpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmdMaXN0LnB1c2gocGF5bG9hZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmRpc3BhdGNoQWN0aW9uID0gZGlzcGF0Y2hBY3Rpb247XHJcbiAgICAgICAgICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24ocGF5bG9hZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkaXNwYXRjaEFjdGlvbjogZGlzcGF0Y2hBY3Rpb24sXHJcbiAgICAgICAgICAgIHBlbmRpbmdzOiBwZW5kaW5nc1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXHJcbiAgICAgKi9cclxuICAgIGdsb2JhbExpc3RlbmVyLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiAoa2V5LCBhcGkpIHtcclxuICAgICAgICBpZiAoZW52Lm5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgenIgPSBhcGkuZ2V0WnIoKTtcclxuICAgICAgICB2YXIgcmVjb3JkID0gKGdldCh6cikucmVjb3JkcyB8fCB7fSlba2V5XTtcclxuICAgICAgICBpZiAocmVjb3JkKSB7XHJcbiAgICAgICAgICAgIGdldCh6cikucmVjb3Jkc1trZXldID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsTGlzdGVuZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi90b29sdGlwL2dsb2JhbExpc3RlbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcblxyXG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vLi4vZmlzaC10b3BvLWNvcmUvbGliL21vZGVsJyk7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1vZGVsLmV4dGVuZCh7XHJcblxyXG4gICAgICAgIHR5cGU6ICd0b29sdGlwJyxcclxuXHJcbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xyXG4gICAgICAgICAgICB6bGV2ZWw6IDAsXHJcblxyXG4gICAgICAgICAgICB6OiA4LFxyXG5cclxuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcclxuXHJcbiAgICAgICAgICAgIC8vIHRvb2x0aXDkuLvkvZPlhoXlrrlcclxuICAgICAgICAgICAgc2hvd0NvbnRlbnQ6IHRydWUsXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vICdjbGljaycgfCAnbW91c2Vtb3ZlJyB8ICdub25lJ1xyXG4gICAgICAgICAgICB0cmlnZ2VyT246ICdtb3VzZW1vdmUnLFxyXG5cclxuICAgICAgICAgICAgYWx3YXlzU2hvd0NvbnRlbnQ6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgZGlzcGxheU1vZGU6ICdzaW5nbGUnLCAvLyAnc2luZ2xlJyB8ICdtdWx0aXBsZUJ5Q29vcmRTeXMnXHJcblxyXG4gICAgICAgICAgICAvLyDkvY3nva4ge0FycmF5fSB8IHtGdW5jdGlvbn1cclxuICAgICAgICAgICAgLy8gcG9zaXRpb246IG51bGxcclxuICAgICAgICAgICAgLy8gQ29uc2lkZXIgdHJpZ2dlcmVkIGZyb20gYXhpc1BvaW50ZXIgaGFuZGxlLCB2ZXJ0aWNhbEFsaWduIHNob3VsZCBiZSAnbWlkZGxlJ1xyXG4gICAgICAgICAgICAvLyBhbGlnbjogbnVsbCxcclxuICAgICAgICAgICAgLy8gdmVydGljYWxBbGlnbjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIC8vIOaYr+WQpue6puadnyBjb250ZW50IOWcqCB2aWV3UmVjdCDkuK3jgILpu5jorqQgZmFsc2Ug5piv5Li65LqG5YW85a655Lul5YmN54mI5pys44CCXHJcbiAgICAgICAgICAgIGNvbmZpbmU6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgLy8g5YaF5a655qC85byP5Zmo77yae3N0cmluZ33vvIhUZW1wbGF0Ze+8iSDCpiB7RnVuY3Rpb259XHJcbiAgICAgICAgICAgIC8vIGZvcm1hdHRlcjogbnVsbFxyXG5cclxuICAgICAgICAgICAgc2hvd0RlbGF5OiAwLFxyXG5cclxuICAgICAgICAgICAgLy8g6ZqQ6JeP5bu26L+f77yM5Y2V5L2NbXNcclxuICAgICAgICAgICAgaGlkZURlbGF5OiAxMDAsXHJcblxyXG4gICAgICAgICAgICAvLyDliqjnlLvlj5jmjaLml7bpl7TvvIzljZXkvY1zXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogMC40LFxyXG5cclxuICAgICAgICAgICAgZW50ZXJhYmxlOiBmYWxzZSxcclxuXHJcbiAgICAgICAgICAgIC8vIOaPkOekuuiDjOaZr+minOiJsu+8jOm7mOiupOS4uumAj+aYjuW6puS4ujAuN+eahOm7keiJslxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDUwLDUwLDUwLDAuNyknLFxyXG5cclxuICAgICAgICAgICAgLy8g5o+Q56S66L655qGG6aKc6ImyXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnIzMzMycsXHJcblxyXG4gICAgICAgICAgICAvLyDmj5DnpLrovrnmoYblnIbop5LvvIzljZXkvY1weO+8jOm7mOiupOS4ujRcclxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiA0LFxyXG5cclxuICAgICAgICAgICAgLy8g5o+Q56S66L655qGG57q/5a6977yM5Y2V5L2NcHjvvIzpu5jorqTkuLow77yI5peg6L655qGG77yJXHJcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAwLFxyXG5cclxuICAgICAgICAgICAgLy8g5o+Q56S65YaF6L656Led77yM5Y2V5L2NcHjvvIzpu5jorqTlkITmlrnlkJHlhoXovrnot53kuLo177yMXHJcbiAgICAgICAgICAgIC8vIOaOpeWPl+aVsOe7hOWIhuWIq+iuvuWumuS4iuWPs+S4i+W3pui+uei3ne+8jOWQjGNzc1xyXG4gICAgICAgICAgICBwYWRkaW5nOiA1LFxyXG5cclxuICAgICAgICAgICAgLy8gRXh0cmEgY3NzIHRleHRcclxuICAgICAgICAgICAgZXh0cmFDc3NUZXh0OiAnJyxcclxuXHJcbiAgICAgICAgICAgIHRleHRTdHlsZToge1xyXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxNFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Zpc2gtdG9wby1mbG93L2xpYi90b29sdGlwL1Rvb2x0aXBNb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuICAgIHJlcXVpcmUoJy4vZ3JhcGhpYycpO1xuICAgIHJlcXVpcmUoJy4uL3pyZW5kZXInKS5yZWdpc3RlclBhaW50ZXIoJ3ZtbCcsIHJlcXVpcmUoJy4vUGFpbnRlcicpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvdm1sL3ZtbC5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL05PVEUtVk1MXG4vLyBUT0RPIFVzZSBwcm94eSBsaWtlIHN2ZyBpbnN0ZWFkIG9mIG92ZXJ3cml0ZSBicnVzaCBtZXRob2RzXG5cblxuaWYgKCFyZXF1aXJlKCcuLi9jb3JlL2VudicpLmNhbnZhc1N1cHBvcnRlZCkge1xuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi4vY29yZS92ZWN0b3InKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcbiAgICB2YXIgQ01EID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKS5DTUQ7XG4gICAgdmFyIGNvbG9yVG9vbCA9IHJlcXVpcmUoJy4uL3Rvb2wvY29sb3InKTtcbiAgICB2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKCcuLi9jb250YWluL3RleHQnKTtcbiAgICB2YXIgdGV4dEhlbHBlciA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvaGVscGVyL3RleHQnKTtcbiAgICB2YXIgUmVjdFRleHQgPSByZXF1aXJlKCcuLi9ncmFwaGljL21peGluL1JlY3RUZXh0Jyk7XG4gICAgdmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9EaXNwbGF5YWJsZScpO1xuICAgIHZhciBaSW1hZ2UgPSByZXF1aXJlKCcuLi9ncmFwaGljL0ltYWdlJyk7XG4gICAgdmFyIFRleHQgPSByZXF1aXJlKCcuLi9ncmFwaGljL1RleHQnKTtcbiAgICB2YXIgUGF0aCA9IHJlcXVpcmUoJy4uL2dyYXBoaWMvUGF0aCcpO1xuICAgIHZhciBQYXRoUHJveHkgPSByZXF1aXJlKCcuLi9jb3JlL1BhdGhQcm94eScpO1xuXG4gICAgdmFyIEdyYWRpZW50ID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9HcmFkaWVudCcpO1xuXG4gICAgdmFyIHZtbENvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIGFicyA9IE1hdGguYWJzO1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgc2luID0gTWF0aC5zaW47XG4gICAgdmFyIG1hdGhNYXggPSBNYXRoLm1heDtcblxuICAgIHZhciBhcHBseVRyYW5zZm9ybSA9IHZlYzIuYXBwbHlUcmFuc2Zvcm07XG5cbiAgICB2YXIgY29tbWEgPSAnLCc7XG4gICAgdmFyIGltYWdlVHJhbnNmb3JtUHJlZml4ID0gJ3Byb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdCc7XG5cbiAgICB2YXIgWiA9IDIxNjAwO1xuICAgIHZhciBaMiA9IFogLyAyO1xuXG4gICAgdmFyIFpMRVZFTF9CQVNFID0gMTAwMDAwO1xuICAgIHZhciBaX0JBU0UgPSAxMDAwO1xuXG4gICAgdmFyIGluaXRSb290RWxTdHlsZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDt3aWR0aDoxcHg7aGVpZ2h0OjFweDsnO1xuICAgICAgICBlbC5jb29yZHNpemUgPSBaICsgJywnICArIFo7XG4gICAgICAgIGVsLmNvb3Jkb3JpZ2luID0gJzAsMCc7XG4gICAgfTtcblxuICAgIHZhciBlbmNvZGVIdG1sQXR0cmlidXRlID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhzKS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJTdHIgPSBmdW5jdGlvbiAociwgZywgYikge1xuICAgICAgICByZXR1cm4gJ3JnYignICsgW3IsIGcsIGJdLmpvaW4oJywnKSArICcpJztcbiAgICB9O1xuXG4gICAgdmFyIGFwcGVuZCA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCAmJiBwYXJlbnQgJiYgY2hpbGQucGFyZW50Tm9kZSAhPT0gcGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZW1vdmUgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgJiYgcGFyZW50ICYmIGNoaWxkLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZ2V0WkluZGV4ID0gZnVuY3Rpb24gKHpsZXZlbCwgeiwgejIpIHtcbiAgICAgICAgLy8geiDnmoTlj5blgLzojIPlm7TkuLogWzAsIDEwMDBdXG4gICAgICAgIHJldHVybiAocGFyc2VGbG9hdCh6bGV2ZWwpIHx8IDApICogWkxFVkVMX0JBU0UgKyAocGFyc2VGbG9hdCh6KSB8fCAwKSAqIFpfQkFTRSArIHoyO1xuICAgIH07XG5cbiAgICB2YXIgcGFyc2VQZXJjZW50ID0gZnVuY3Rpb24gKHZhbHVlLCBtYXhWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxhc3RJbmRleE9mKCclJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIG1heFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIFBBVEhcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICB2YXIgc2V0Q29sb3JBbmRPcGFjaXR5ID0gZnVuY3Rpb24gKGVsLCBjb2xvciwgb3BhY2l0eSkge1xuICAgICAgICB2YXIgY29sb3JBcnIgPSBjb2xvclRvb2wucGFyc2UoY29sb3IpO1xuICAgICAgICBvcGFjaXR5ID0gK29wYWNpdHk7XG4gICAgICAgIGlmIChpc05hTihvcGFjaXR5KSkge1xuICAgICAgICAgICAgb3BhY2l0eSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbG9yQXJyKSB7XG4gICAgICAgICAgICBlbC5jb2xvciA9IHJnYjJTdHIoY29sb3JBcnJbMF0sIGNvbG9yQXJyWzFdLCBjb2xvckFyclsyXSk7XG4gICAgICAgICAgICBlbC5vcGFjaXR5ID0gb3BhY2l0eSAqIGNvbG9yQXJyWzNdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBnZXRDb2xvckFuZEFscGhhID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHZhciBjb2xvckFyciA9IGNvbG9yVG9vbC5wYXJzZShjb2xvcik7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICByZ2IyU3RyKGNvbG9yQXJyWzBdLCBjb2xvckFyclsxXSwgY29sb3JBcnJbMl0pLFxuICAgICAgICAgICAgY29sb3JBcnJbM11cbiAgICAgICAgXTtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUZpbGxOb2RlID0gZnVuY3Rpb24gKGVsLCBzdHlsZSwgenJFbCkge1xuICAgICAgICAvLyBUT0RPIHBhdHRlcm5cbiAgICAgICAgdmFyIGZpbGwgPSBzdHlsZS5maWxsO1xuICAgICAgICBpZiAoZmlsbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBNb2RpZmllZCBmcm9tIGV4Y2FudmFzXG4gICAgICAgICAgICBpZiAoZmlsbCBpbnN0YW5jZW9mIEdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50VHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBmb2N1cyA9IFswLCAwXTtcbiAgICAgICAgICAgICAgICAvLyBhZGRpdGlvbmFsIG9mZnNldFxuICAgICAgICAgICAgICAgIHZhciBzaGlmdCA9IDA7XG4gICAgICAgICAgICAgICAgLy8gc2NhbGUgZmFjdG9yIGZvciBvZmZzZXRcbiAgICAgICAgICAgICAgICB2YXIgZXhwYW5zaW9uID0gMTtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHpyRWwuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3RXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3RIZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoZmlsbC50eXBlID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudFR5cGUgPSAnZ3JhZGllbnQnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0genJFbC50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwMCA9IFtmaWxsLnggKiByZWN0V2lkdGgsIGZpbGwueSAqIHJlY3RIZWlnaHRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcDEgPSBbZmlsbC54MiAqIHJlY3RXaWR0aCwgZmlsbC55MiAqIHJlY3RIZWlnaHRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMCwgcDAsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMSwgcDEsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gcDFbMF0gLSBwMFswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5ID0gcDFbMV0gLSBwMFsxXTtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKGR4LCBkeSkgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYW5nbGUgc2hvdWxkIGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGUgKz0gMzYwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVmVyeSBzbWFsbCBhbmdsZXMgcHJvZHVjZSBhbiB1bmV4cGVjdGVkIHJlc3VsdCBiZWNhdXNlIHRoZXkgYXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnRlZCB0byBhIHNjaWVudGlmaWMgbm90YXRpb24gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPCAxZS02KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50VHlwZSA9ICdncmFkaWVudHJhZGlhbCc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwMCA9IFtmaWxsLnggKiByZWN0V2lkdGgsIGZpbGwueSAqIHJlY3RIZWlnaHRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0genJFbC50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IHpyRWwuc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlY3RXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHJlY3RIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGVyY2VudCBpbiBib3VuZGluZyByZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAocDBbMF0gLSByZWN0LngpIC8gd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAocDBbMV0gLSByZWN0LnkpIC8gaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAwLCBwMCwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoIC89IHNjYWxlWzBdICogWjtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0IC89IHNjYWxlWzFdICogWjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpbWVuc2lvbiA9IG1hdGhNYXgod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMiAqIDAgLyBkaW1lbnNpb247XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuc2lvbiA9IDIgKiBmaWxsLnIgLyBkaW1lbnNpb24gLSBzaGlmdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHNvcnQgdGhlIGNvbG9yIHN0b3BzIGluIGFzY2VuZGluZyBvcmRlciBieSBvZmZzZXQsXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIElFIHdvbid0IGludGVycHJldCBpdCBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgdmFyIHN0b3BzID0gZmlsbC5jb2xvclN0b3BzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgc3RvcHMuc29ydChmdW5jdGlvbihjczEsIGNzMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3MxLm9mZnNldCAtIGNzMi5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gc3RvcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIENvbG9yIGFuZCBhbHBoYSBsaXN0IG9mIGZpcnN0IGFuZCBsYXN0IHN0b3BcbiAgICAgICAgICAgICAgICB2YXIgY29sb3JBbmRBbHBoYUxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3JzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcCA9IHN0b3BzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3JBbmRBbHBoYSA9IGdldENvbG9yQW5kQWxwaGEoc3RvcC5jb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9ycy5wdXNoKHN0b3Aub2Zmc2V0ICogZXhwYW5zaW9uICsgc2hpZnQgKyAnICcgKyBjb2xvckFuZEFscGhhWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JBbmRBbHBoYUxpc3QucHVzaChjb2xvckFuZEFscGhhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IxID0gY29sb3JBbmRBbHBoYUxpc3RbMF1bMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvcjIgPSBjb2xvckFuZEFscGhhTGlzdFsxXVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wYWNpdHkxID0gY29sb3JBbmRBbHBoYUxpc3RbMF1bMV0gKiBzdHlsZS5vcGFjaXR5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3BhY2l0eTIgPSBjb2xvckFuZEFscGhhTGlzdFsxXVsxXSAqIHN0eWxlLm9wYWNpdHk7XG5cbiAgICAgICAgICAgICAgICAgICAgZWwudHlwZSA9IGdyYWRpZW50VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgZWwubWV0aG9kID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICBlbC5mb2N1cyA9ICcxMDAlJztcbiAgICAgICAgICAgICAgICAgICAgZWwuYW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgZWwuY29sb3IgPSBjb2xvcjE7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNvbG9yMiA9IGNvbG9yMjtcbiAgICAgICAgICAgICAgICAgICAgZWwuY29sb3JzID0gY29sb3JzLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBjb2xvcnMgYXR0cmlidXRlIGlzIHVzZWQsIHRoZSBtZWFuaW5ncyBvZiBvcGFjaXR5IGFuZCBvOm9wYWNpdHkyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFyZSByZXZlcnNlZC5cbiAgICAgICAgICAgICAgICAgICAgZWwub3BhY2l0eSA9IG9wYWNpdHkyO1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBnX29fOm9wYWNpdHkgP1xuICAgICAgICAgICAgICAgICAgICBlbC5vcGFjaXR5MiA9IG9wYWNpdHkxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ3JhZGllbnRUeXBlID09PSAncmFkaWFsJykge1xuICAgICAgICAgICAgICAgICAgICBlbC5mb2N1c3Bvc2l0aW9uID0gZm9jdXMuam9pbignLCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIENoYW5nZSBmcm9tIEdyYWRpZW50IGZpbGwgdG8gY29sb3IgZmlsbFxuICAgICAgICAgICAgICAgIHNldENvbG9yQW5kT3BhY2l0eShlbCwgZmlsbCwgc3R5bGUub3BhY2l0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZVN0cm9rZU5vZGUgPSBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XG4gICAgICAgIC8vIGlmIChzdHlsZS5saW5lSm9pbiAhPSBudWxsKSB7XG4gICAgICAgIC8vICAgICBlbC5qb2luc3R5bGUgPSBzdHlsZS5saW5lSm9pbjtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZiAoc3R5bGUubWl0ZXJMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgIC8vICAgICBlbC5taXRlcmxpbWl0ID0gc3R5bGUubWl0ZXJMaW1pdCAqIFo7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYgKHN0eWxlLmxpbmVDYXAgIT0gbnVsbCkge1xuICAgICAgICAvLyAgICAgZWwuZW5kY2FwID0gc3R5bGUubGluZUNhcDtcbiAgICAgICAgLy8gfVxuICAgICAgICBpZiAoc3R5bGUubGluZURhc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgZWwuZGFzaHN0eWxlID0gc3R5bGUubGluZURhc2guam9pbignICcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZS5zdHJva2UgIT0gbnVsbCAmJiAhKHN0eWxlLnN0cm9rZSBpbnN0YW5jZW9mIEdyYWRpZW50KSkge1xuICAgICAgICAgICAgc2V0Q29sb3JBbmRPcGFjaXR5KGVsLCBzdHlsZS5zdHJva2UsIHN0eWxlLm9wYWNpdHkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVGaWxsQW5kU3Ryb2tlID0gZnVuY3Rpb24gKHZtbEVsLCB0eXBlLCBzdHlsZSwgenJFbCkge1xuICAgICAgICB2YXIgaXNGaWxsID0gdHlwZSA9PSAnZmlsbCc7XG4gICAgICAgIHZhciBlbCA9IHZtbEVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKHR5cGUpWzBdO1xuICAgICAgICAvLyBTdHJva2UgbXVzdCBoYXZlIGxpbmVXaWR0aFxuICAgICAgICBpZiAoc3R5bGVbdHlwZV0gIT0gbnVsbCAmJiBzdHlsZVt0eXBlXSAhPT0gJ25vbmUnICYmIChpc0ZpbGwgfHwgKCFpc0ZpbGwgJiYgc3R5bGUubGluZVdpZHRoKSkpIHtcbiAgICAgICAgICAgIHZtbEVsW2lzRmlsbCA/ICdmaWxsZWQnIDogJ3N0cm9rZWQnXSA9ICd0cnVlJztcbiAgICAgICAgICAgIC8vIEZJWE1FIFJlbW92ZSBiZWZvcmUgdXBkYXRpbmcsIG9yIHNldCBgY29sb3JzYCB3aWxsIHRocm93IGVycm9yXG4gICAgICAgICAgICBpZiAoc3R5bGVbdHlwZV0gaW5zdGFuY2VvZiBHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZSh2bWxFbCwgZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgICAgIGVsID0gdm1sQ29yZS5jcmVhdGVOb2RlKHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpc0ZpbGwgPyB1cGRhdGVGaWxsTm9kZShlbCwgc3R5bGUsIHpyRWwpIDogdXBkYXRlU3Ryb2tlTm9kZShlbCwgc3R5bGUpO1xuICAgICAgICAgICAgYXBwZW5kKHZtbEVsLCBlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2bWxFbFtpc0ZpbGwgPyAnZmlsbGVkJyA6ICdzdHJva2VkJ10gPSAnZmFsc2UnO1xuICAgICAgICAgICAgcmVtb3ZlKHZtbEVsLCBlbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHBvaW50cyA9IFtbXSwgW10sIFtdXTtcbiAgICB2YXIgcGF0aERhdGFUb1N0cmluZyA9IGZ1bmN0aW9uIChkYXRhLCBtKSB7XG4gICAgICAgIHZhciBNID0gQ01ELk07XG4gICAgICAgIHZhciBDID0gQ01ELkM7XG4gICAgICAgIHZhciBMID0gQ01ELkw7XG4gICAgICAgIHZhciBBID0gQ01ELkE7XG4gICAgICAgIHZhciBRID0gQ01ELlE7XG5cbiAgICAgICAgdmFyIHN0ciA9IFtdO1xuICAgICAgICB2YXIgblBvaW50O1xuICAgICAgICB2YXIgY21kU3RyO1xuICAgICAgICB2YXIgY21kO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHhpO1xuICAgICAgICB2YXIgeWk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGNtZCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgIGNtZFN0ciA9ICcnO1xuICAgICAgICAgICAgblBvaW50ID0gMDtcbiAgICAgICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBNOlxuICAgICAgICAgICAgICAgICAgICBjbWRTdHIgPSAnIG0gJztcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF1bMF0gPSB4aTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdWzFdID0geWk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTDpcbiAgICAgICAgICAgICAgICAgICAgY21kU3RyID0gJyBsICc7XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdWzBdID0geGk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1swXVsxXSA9IHlpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFE6XG4gICAgICAgICAgICAgICAgY2FzZSBDOlxuICAgICAgICAgICAgICAgICAgICBjbWRTdHIgPSAnIGMgJztcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTEgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MiA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkyID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtZCA9PT0gUSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBxdWFkcmF0aWMgdG8gY3ViaWMgdXNpbmcgZGVncmVlIGVsZXZhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgeDMgPSB4MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkzID0geTI7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9ICh4MiArIDIgKiB4MSkgLyAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSAoeTIgKyAyICogeTEpIC8gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gKHhpICsgMiAqIHgxKSAvIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9ICh5aSArIDIgKiB5MSkgLyAzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDMgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MyA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF1bMF0gPSB4MTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdWzFdID0geTE7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1sxXVswXSA9IHgyO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMV1bMV0gPSB5MjtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzJdWzBdID0geDM7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1syXVsxXSA9IHkzO1xuXG4gICAgICAgICAgICAgICAgICAgIHhpID0geDM7XG4gICAgICAgICAgICAgICAgICAgIHlpID0geTM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IFNSVCBmcm9tIG1hdHJpeFxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IG1bNF07XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gbVs1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN4ID0gc3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5ID0gc3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3kgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IGRhdGFbaSsrXSArIGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBkYXRhW2krK10gKyBzdGFydEFuZ2xlICsgYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBwc2kgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgeDAgPSBjeCArIGNvcyhzdGFydEFuZ2xlKSAqIHJ4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTAgPSBjeSArIHNpbihzdGFydEFuZ2xlKSAqIHJ5O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IGN4ICsgY29zKGVuZEFuZ2xlKSAqIHJ4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTEgPSBjeSArIHNpbihlbmRBbmdsZSkgKiByeTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGNsb2Nrd2lzZSA/ICcgd2EgJyA6ICcgYXQgJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHgwIC0geDEpIDwgMWUtNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUUgd29uJ3QgcmVuZGVyIGFyY2hlcyBkcmF3biBjb3VudGVyIGNsb2Nrd2lzZSBpZiB4MCA9PSB4MS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpID4gMWUtMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9mZnNldCB4MCBieSAxLzgwIG9mIGEgcGl4ZWwuIFVzZSBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCBpbiBiaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgwICs9IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgY2FzZSBkcmF3IGZ1bGwgY2lyY2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHkwIC0gY3kpIDwgMWUtNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNsb2Nrd2lzZSAmJiB4MCA8IGN4KSB8fCAoIWNsb2Nrd2lzZSAmJiB4MCA+IGN4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTEgLT0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxICs9IDI3MCAvIFo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKGNsb2Nrd2lzZSAmJiB5MCA8IGN5KSB8fCAoIWNsb2Nrd2lzZSAmJiB5MCA+IGN5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSArPSAyNzAgLyBaO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgLT0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RyLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91bmQoKChjeCAtIHJ4KSAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCgoY3kgLSByeSkgKiBzeSArIHkpICogWiAtIFoyKSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZCgoKGN4ICsgcngpICogc3ggKyB4KSAqIFogLSBaMiksIGNvbW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91bmQoKChjeSArIHJ5KSAqIHN5ICsgeSkgKiBaIC0gWjIpLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCh4MCAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCh5MCAqIHN5ICsgeSkgKiBaIC0gWjIpLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCh4MSAqIHN4ICsgeCkgKiBaIC0gWjIpLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCh5MSAqIHN5ICsgeSkgKiBaIC0gWjIpXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4MTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAwID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcDEgPSBwb2ludHNbMV07XG4gICAgICAgICAgICAgICAgICAgIC8vIHgwLCB5MFxuICAgICAgICAgICAgICAgICAgICBwMFswXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcDBbMV0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIC8vIHgxLCB5MVxuICAgICAgICAgICAgICAgICAgICBwMVswXSA9IHAwWzBdICsgZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBwMVsxXSA9IHAwWzFdICsgZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMCwgcDAsIG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDEsIHAxLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHAwWzBdID0gcm91bmQocDBbMF0gKiBaIC0gWjIpO1xuICAgICAgICAgICAgICAgICAgICBwMVswXSA9IHJvdW5kKHAxWzBdICogWiAtIFoyKTtcbiAgICAgICAgICAgICAgICAgICAgcDBbMV0gPSByb3VuZChwMFsxXSAqIFogLSBaMik7XG4gICAgICAgICAgICAgICAgICAgIHAxWzFdID0gcm91bmQocDFbMV0gKiBaIC0gWjIpO1xuICAgICAgICAgICAgICAgICAgICBzdHIucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHgwLCB5MFxuICAgICAgICAgICAgICAgICAgICAgICAgJyBtICcsIHAwWzBdLCBjb21tYSwgcDBbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB4MSwgeTBcbiAgICAgICAgICAgICAgICAgICAgICAgICcgbCAnLCBwMVswXSwgY29tbWEsIHAwWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8geDEsIHkxXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGwgJywgcDFbMF0sIGNvbW1hLCBwMVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHgwLCB5MVxuICAgICAgICAgICAgICAgICAgICAgICAgJyBsICcsIHAwWzBdLCBjb21tYSwgcDFbMV1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgVXBkYXRlIHhpLCB5aVxuICAgICAgICAgICAgICAgICAgICBzdHIucHVzaCgnIHggJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuUG9pbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RyLnB1c2goY21kU3RyKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG5Qb2ludDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gcG9pbnRzW2tdO1xuXG4gICAgICAgICAgICAgICAgICAgIG0gJiYgYXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIOS4jSByb3VuZCDkvJrpnZ7luLjmhaJcbiAgICAgICAgICAgICAgICAgICAgc3RyLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZChwWzBdICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKHBbMV0gKiBaIC0gWjIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgayA8IG5Qb2ludCAtIDEgPyBjb21tYSA6ICcnXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ci5qb2luKCcnKTtcbiAgICB9O1xuXG4gICAgLy8gUmV3cml0ZSB0aGUgb3JpZ2luYWwgcGF0aCBtZXRob2RcbiAgICBQYXRoLnByb3RvdHlwZS5icnVzaFZNTCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICAgICAgdmFyIHZtbEVsID0gdGhpcy5fdm1sRWw7XG4gICAgICAgIGlmICghdm1sRWwpIHtcbiAgICAgICAgICAgIHZtbEVsID0gdm1sQ29yZS5jcmVhdGVOb2RlKCdzaGFwZScpO1xuICAgICAgICAgICAgaW5pdFJvb3RFbFN0eWxlKHZtbEVsKTtcblxuICAgICAgICAgICAgdGhpcy5fdm1sRWwgPSB2bWxFbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZUZpbGxBbmRTdHJva2Uodm1sRWwsICdmaWxsJywgc3R5bGUsIHRoaXMpO1xuICAgICAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHZtbEVsLCAnc3Ryb2tlJywgc3R5bGUsIHRoaXMpO1xuXG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIHZhciBuZWVkVHJhbnNmb3JtID0gbSAhPSBudWxsO1xuICAgICAgICB2YXIgc3Ryb2tlRWwgPSB2bWxFbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3Ryb2tlJylbMF07XG4gICAgICAgIGlmIChzdHJva2VFbCkge1xuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbGluZSBzY2FsZS5cbiAgICAgICAgICAgIC8vIERldGVybWluYW50IG9mIHRoaXMubV8gbWVhbnMgaG93IG11Y2ggdGhlIGFyZWEgaXMgZW5sYXJnZWQgYnkgdGhlXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm1hdGlvbi4gU28gaXRzIHNxdWFyZSByb290IGNhbiBiZSB1c2VkIGFzIGEgc2NhbGUgZmFjdG9yXG4gICAgICAgICAgICAvLyBmb3Igd2lkdGguXG4gICAgICAgICAgICBpZiAobmVlZFRyYW5zZm9ybSAmJiAhc3R5bGUuc3Ryb2tlTm9TY2FsZSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgICAgICAgICAgICAgIGxpbmVXaWR0aCAqPSBzcXJ0KGFicyhkZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cm9rZUVsLndlaWdodCA9IGxpbmVXaWR0aCArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aCB8fCAodGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpKTtcbiAgICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgIHBhdGguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkUGF0aChwYXRoLCB0aGlzLnNoYXBlKTtcbiAgICAgICAgICAgIHBhdGgudG9TdGF0aWMoKTtcbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZtbEVsLnBhdGggPSBwYXRoRGF0YVRvU3RyaW5nKHBhdGguZGF0YSwgdGhpcy50cmFuc2Zvcm0pO1xuXG4gICAgICAgIHZtbEVsLnN0eWxlLnpJbmRleCA9IGdldFpJbmRleCh0aGlzLnpsZXZlbCwgdGhpcy56LCB0aGlzLnoyKTtcblxuICAgICAgICAvLyBBcHBlbmQgdG8gcm9vdFxuICAgICAgICBhcHBlbmQodm1sUm9vdCwgdm1sRWwpO1xuXG4gICAgICAgIC8vIFRleHRcbiAgICAgICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQodm1sUm9vdCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFBhdGgucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgcmVtb3ZlKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcbiAgICAgICAgdGhpcy5yZW1vdmVSZWN0VGV4dCh2bWxSb290KTtcbiAgICB9O1xuXG4gICAgUGF0aC5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICBhcHBlbmQodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgICAgICB0aGlzLmFwcGVuZFJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogSU1BR0VcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgdmFyIGlzSW1hZ2UgPSBmdW5jdGlvbiAoaW1nKSB7XG4gICAgICAgIC8vIEZJWE1FIGltZyBpbnN0YW5jZW9mIEltYWdlIOWmguaenCBpbWcg5piv5LiA5Liq5a2X56ym5Liy55qE5pe25YCZ77yMSUU4IOS4i+S8muaKpemUmVxuICAgICAgICByZXR1cm4gKHR5cGVvZiBpbWcgPT09ICdvYmplY3QnKSAmJiBpbWcudGFnTmFtZSAmJiBpbWcudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnSU1HJztcbiAgICAgICAgLy8gcmV0dXJuIGltZyBpbnN0YW5jZW9mIEltYWdlO1xuICAgIH07XG5cbiAgICAvLyBSZXdyaXRlIHRoZSBvcmlnaW5hbCBwYXRoIG1ldGhvZFxuICAgIFpJbWFnZS5wcm90b3R5cGUuYnJ1c2hWTUwgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICB2YXIgaW1hZ2UgPSBzdHlsZS5pbWFnZTtcblxuICAgICAgICAvLyBJbWFnZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0XG4gICAgICAgIHZhciBvdztcbiAgICAgICAgdmFyIG9oO1xuXG4gICAgICAgIGlmIChpc0ltYWdlKGltYWdlKSkge1xuICAgICAgICAgICAgdmFyIHNyYyA9IGltYWdlLnNyYztcbiAgICAgICAgICAgIGlmIChzcmMgPT09IHRoaXMuX2ltYWdlU3JjKSB7XG4gICAgICAgICAgICAgICAgb3cgPSB0aGlzLl9pbWFnZVdpZHRoO1xuICAgICAgICAgICAgICAgIG9oID0gdGhpcy5faW1hZ2VIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VSdW50aW1lU3R5bGUgPSBpbWFnZS5ydW50aW1lU3R5bGU7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFJ1bnRpbWVXaWR0aCA9IGltYWdlUnVudGltZVN0eWxlLndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBvbGRSdW50aW1lSGVpZ2h0ID0gaW1hZ2VSdW50aW1lU3R5bGUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGltYWdlUnVudGltZVN0eWxlLndpZHRoID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIGltYWdlUnVudGltZVN0eWxlLmhlaWdodCA9ICdhdXRvJztcblxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgb3JpZ2luYWwgc2l6ZVxuICAgICAgICAgICAgICAgIG93ID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgb2ggPSBpbWFnZS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBhbmQgcmVtb3ZlIG92ZXJpZGVzXG4gICAgICAgICAgICAgICAgaW1hZ2VSdW50aW1lU3R5bGUud2lkdGggPSBvbGRSdW50aW1lV2lkdGg7XG4gICAgICAgICAgICAgICAgaW1hZ2VSdW50aW1lU3R5bGUuaGVpZ2h0ID0gb2xkUnVudGltZUhlaWdodDtcblxuICAgICAgICAgICAgICAgIC8vIENhY2hpbmcgaW1hZ2Ugb3JpZ2luYWwgd2lkdGgsIGhlaWdodCBhbmQgc3JjXG4gICAgICAgICAgICAgICAgdGhpcy5faW1hZ2VTcmMgPSBzcmM7XG4gICAgICAgICAgICAgICAgdGhpcy5faW1hZ2VXaWR0aCA9IG93O1xuICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlSGVpZ2h0ID0gb2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbWFnZSA9IHNyYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbWFnZSA9PT0gdGhpcy5faW1hZ2VTcmMpIHtcbiAgICAgICAgICAgICAgICBvdyA9IHRoaXMuX2ltYWdlV2lkdGg7XG4gICAgICAgICAgICAgICAgb2ggPSB0aGlzLl9pbWFnZUhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWltYWdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IHN0eWxlLnggfHwgMDtcbiAgICAgICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG5cbiAgICAgICAgdmFyIGR3ID0gc3R5bGUud2lkdGg7XG4gICAgICAgIHZhciBkaCA9IHN0eWxlLmhlaWdodDtcblxuICAgICAgICB2YXIgc3cgPSBzdHlsZS5zV2lkdGg7XG4gICAgICAgIHZhciBzaCA9IHN0eWxlLnNIZWlnaHQ7XG4gICAgICAgIHZhciBzeCA9IHN0eWxlLnN4IHx8IDA7XG4gICAgICAgIHZhciBzeSA9IHN0eWxlLnN5IHx8IDA7XG5cbiAgICAgICAgdmFyIGhhc0Nyb3AgPSBzdyAmJiBzaDtcblxuICAgICAgICB2YXIgdm1sRWwgPSB0aGlzLl92bWxFbDtcbiAgICAgICAgaWYgKCF2bWxFbCkge1xuICAgICAgICAgICAgLy8gRklYTUUg5L2/55SoIGdyb3VwIOWcqCBsZWZ0LCB0b3Ag6YO95LiN5pivIDAg55qE5pe25YCZ5bCx5peg5rOV5pi+56S65LqG44CCXG4gICAgICAgICAgICAvLyB2bWxFbCA9IHZtbENvcmUuY3JlYXRlTm9kZSgnZ3JvdXAnKTtcbiAgICAgICAgICAgIHZtbEVsID0gdm1sQ29yZS5kb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBpbml0Um9vdEVsU3R5bGUodm1sRWwpO1xuXG4gICAgICAgICAgICB0aGlzLl92bWxFbCA9IHZtbEVsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZtbEVsU3R5bGUgPSB2bWxFbC5zdHlsZTtcbiAgICAgICAgdmFyIGhhc1JvdGF0aW9uID0gZmFsc2U7XG4gICAgICAgIHZhciBtO1xuICAgICAgICB2YXIgc2NhbGVYID0gMTtcbiAgICAgICAgdmFyIHNjYWxlWSA9IDE7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgc2NhbGVYID0gc3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgICAgICAgIHNjYWxlWSA9IHNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG5cbiAgICAgICAgICAgIGhhc1JvdGF0aW9uID0gbVsxXSB8fCBtWzJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNSb3RhdGlvbikge1xuICAgICAgICAgICAgLy8gSWYgZmlsdGVycyBhcmUgbmVjZXNzYXJ5IChyb3RhdGlvbiBleGlzdHMpLCBjcmVhdGUgdGhlbVxuICAgICAgICAgICAgLy8gZmlsdGVycyBhcmUgYm9nLXNsb3csIHNvIG9ubHkgY3JlYXRlIHRoZW0gaWYgYWJic29sdXRlbHkgbmVjZXNzYXJ5XG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNoZWNrIGRvZXNuJ3QgYWNjb3VudCBmb3Igc2tld3MgKHdoaWNoIGRvbid0IGV4aXN0XG4gICAgICAgICAgICAvLyBpbiB0aGUgY2FudmFzIHNwZWMgKHlldCkgYW55d2F5LlxuICAgICAgICAgICAgLy8gRnJvbSBleGNhbnZhc1xuICAgICAgICAgICAgdmFyIHAwID0gW3gsIHldO1xuICAgICAgICAgICAgdmFyIHAxID0gW3ggKyBkdywgeV07XG4gICAgICAgICAgICB2YXIgcDIgPSBbeCwgeSArIGRoXTtcbiAgICAgICAgICAgIHZhciBwMyA9IFt4ICsgZHcsIHkgKyBkaF07XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMCwgcDAsIG0pO1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDEsIHAxLCBtKTtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAyLCBwMiwgbSk7XG4gICAgICAgICAgICBhcHBseVRyYW5zZm9ybShwMywgcDMsIG0pO1xuXG4gICAgICAgICAgICB2YXIgbWF4WCA9IG1hdGhNYXgocDBbMF0sIHAxWzBdLCBwMlswXSwgcDNbMF0pO1xuICAgICAgICAgICAgdmFyIG1heFkgPSBtYXRoTWF4KHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdKTtcblxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybUZpbHRlciA9IFtdO1xuICAgICAgICAgICAgdHJhbnNmb3JtRmlsdGVyLnB1c2goJ00xMT0nLCBtWzBdIC8gc2NhbGVYLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNMTI9JywgbVsyXSAvIHNjYWxlWSwgY29tbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTTIxPScsIG1bMV0gLyBzY2FsZVgsIGNvbW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ00yMj0nLCBtWzNdIC8gc2NhbGVZLCBjb21tYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEeD0nLCByb3VuZCh4ICogc2NhbGVYICsgbVs0XSksIGNvbW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0R5PScsIHJvdW5kKHkgKiBzY2FsZVkgKyBtWzVdKSk7XG5cbiAgICAgICAgICAgIHZtbEVsU3R5bGUucGFkZGluZyA9ICcwICcgKyByb3VuZChtYXhYKSArICdweCAnICsgcm91bmQobWF4WSkgKyAncHggMCc7XG4gICAgICAgICAgICAvLyBGSVhNRSBEWEltYWdlVHJhbnNmb3JtIOWcqCBJRTExIOeahOWFvOWuueaooeW8j+S4i+S4jei1t+S9nOeUqFxuICAgICAgICAgICAgdm1sRWxTdHlsZS5maWx0ZXIgPSBpbWFnZVRyYW5zZm9ybVByZWZpeCArICcuTWF0cml4KCdcbiAgICAgICAgICAgICAgICArIHRyYW5zZm9ybUZpbHRlci5qb2luKCcnKSArICcsIFNpemluZ01ldGhvZD1jbGlwKSc7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgeCA9IHggKiBzY2FsZVggKyBtWzRdO1xuICAgICAgICAgICAgICAgIHkgPSB5ICogc2NhbGVZICsgbVs1XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZtbEVsU3R5bGUuZmlsdGVyID0gJyc7XG4gICAgICAgICAgICB2bWxFbFN0eWxlLmxlZnQgPSByb3VuZCh4KSArICdweCc7XG4gICAgICAgICAgICB2bWxFbFN0eWxlLnRvcCA9IHJvdW5kKHkpICsgJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbWFnZUVsID0gdGhpcy5faW1hZ2VFbDtcbiAgICAgICAgdmFyIGNyb3BFbCA9IHRoaXMuX2Nyb3BFbDtcblxuICAgICAgICBpZiAoIWltYWdlRWwpIHtcbiAgICAgICAgICAgIGltYWdlRWwgPSB2bWxDb3JlLmRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlRWwgPSBpbWFnZUVsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbWFnZUVMU3R5bGUgPSBpbWFnZUVsLnN0eWxlO1xuICAgICAgICBpZiAoaGFzQ3JvcCkge1xuICAgICAgICAgICAgLy8gTmVlZHMga25vdyBpbWFnZSBvcmlnaW5hbCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgICBpZiAoISAob3cgJiYgb2gpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcEltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRtcEltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wSW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgb3cgPSB0bXBJbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgb2ggPSB0bXBJbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkanVzdCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IHRvIGZpdCB0aGUgcmF0aW8gZGVzdGluYXRpb25TaXplIC8gc291cmNlU2l6ZVxuICAgICAgICAgICAgICAgICAgICBpbWFnZUVMU3R5bGUud2lkdGggPSByb3VuZChzY2FsZVggKiBvdyAqIGR3IC8gc3cpICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VFTFN0eWxlLmhlaWdodCA9IHJvdW5kKHNjYWxlWSAqIG9oICogZGggLyBzaCkgKyAncHgnO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hpbmcgaW1hZ2Ugb3JpZ2luYWwgd2lkdGgsIGhlaWdodCBhbmQgc3JjXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2ltYWdlV2lkdGggPSBvdztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW1hZ2VIZWlnaHQgPSBvaDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW1hZ2VTcmMgPSBpbWFnZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRtcEltYWdlLnNyYyA9IGltYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VFTFN0eWxlLndpZHRoID0gcm91bmQoc2NhbGVYICogb3cgKiBkdyAvIHN3KSArICdweCc7XG4gICAgICAgICAgICAgICAgaW1hZ2VFTFN0eWxlLmhlaWdodCA9IHJvdW5kKHNjYWxlWSAqIG9oICogZGggLyBzaCkgKyAncHgnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISBjcm9wRWwpIHtcbiAgICAgICAgICAgICAgICBjcm9wRWwgPSB2bWxDb3JlLmRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBjcm9wRWwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICAgICAgICB0aGlzLl9jcm9wRWwgPSBjcm9wRWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3JvcEVsU3R5bGUgPSBjcm9wRWwuc3R5bGU7XG4gICAgICAgICAgICBjcm9wRWxTdHlsZS53aWR0aCA9IHJvdW5kKChkdyArIHN4ICogZHcgLyBzdykgKiBzY2FsZVgpO1xuICAgICAgICAgICAgY3JvcEVsU3R5bGUuaGVpZ2h0ID0gcm91bmQoKGRoICsgc3kgKiBkaCAvIHNoKSAqIHNjYWxlWSk7XG4gICAgICAgICAgICBjcm9wRWxTdHlsZS5maWx0ZXIgPSBpbWFnZVRyYW5zZm9ybVByZWZpeCArICcuTWF0cml4KER4PSdcbiAgICAgICAgICAgICAgICAgICAgKyAoLXN4ICogZHcgLyBzdyAqIHNjYWxlWCkgKyAnLER5PScgKyAoLXN5ICogZGggLyBzaCAqIHNjYWxlWSkgKyAnKSc7XG5cbiAgICAgICAgICAgIGlmICghIGNyb3BFbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgdm1sRWwuYXBwZW5kQ2hpbGQoY3JvcEVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbWFnZUVsLnBhcmVudE5vZGUgIT0gY3JvcEVsKSB7XG4gICAgICAgICAgICAgICAgY3JvcEVsLmFwcGVuZENoaWxkKGltYWdlRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW1hZ2VFTFN0eWxlLndpZHRoID0gcm91bmQoc2NhbGVYICogZHcpICsgJ3B4JztcbiAgICAgICAgICAgIGltYWdlRUxTdHlsZS5oZWlnaHQgPSByb3VuZChzY2FsZVkgKiBkaCkgKyAncHgnO1xuXG4gICAgICAgICAgICB2bWxFbC5hcHBlbmRDaGlsZChpbWFnZUVsKTtcblxuICAgICAgICAgICAgaWYgKGNyb3BFbCAmJiBjcm9wRWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHZtbEVsLnJlbW92ZUNoaWxkKGNyb3BFbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JvcEVsID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWx0ZXJTdHIgPSAnJztcbiAgICAgICAgdmFyIGFscGhhID0gc3R5bGUub3BhY2l0eTtcbiAgICAgICAgaWYgKGFscGhhIDwgMSkge1xuICAgICAgICAgICAgZmlsdGVyU3RyICs9ICcuQWxwaGEob3BhY2l0eT0nICsgcm91bmQoYWxwaGEgKiAxMDApICsgJykgJztcbiAgICAgICAgfVxuICAgICAgICBmaWx0ZXJTdHIgKz0gaW1hZ2VUcmFuc2Zvcm1QcmVmaXggKyAnLkFscGhhSW1hZ2VMb2FkZXIoc3JjPScgKyBpbWFnZSArICcsIFNpemluZ01ldGhvZD1zY2FsZSknO1xuXG4gICAgICAgIGltYWdlRUxTdHlsZS5maWx0ZXIgPSBmaWx0ZXJTdHI7XG5cbiAgICAgICAgdm1sRWwuc3R5bGUuekluZGV4ID0gZ2V0WkluZGV4KHRoaXMuemxldmVsLCB0aGlzLnosIHRoaXMuejIpO1xuXG4gICAgICAgIC8vIEFwcGVuZCB0byByb290XG4gICAgICAgIGFwcGVuZCh2bWxSb290LCB2bWxFbCk7XG5cbiAgICAgICAgLy8gVGV4dFxuICAgICAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdSZWN0VGV4dCh2bWxSb290LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBaSW1hZ2UucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgcmVtb3ZlKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcblxuICAgICAgICB0aGlzLl92bWxFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Nyb3BFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ltYWdlRWwgPSBudWxsO1xuXG4gICAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfTtcblxuICAgIFpJbWFnZS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICBhcHBlbmQodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgICAgICB0aGlzLmFwcGVuZFJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH07XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBURVhUXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgdmFyIERFRkFVTFRfU1RZTEVfTk9STUFMID0gJ25vcm1hbCc7XG5cbiAgICB2YXIgZm9udFN0eWxlQ2FjaGUgPSB7fTtcbiAgICB2YXIgZm9udFN0eWxlQ2FjaGVDb3VudCA9IDA7XG4gICAgdmFyIE1BWF9GT05UX0NBQ0hFX1NJWkUgPSAxMDA7XG4gICAgdmFyIGZvbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgdmFyIGdldEZvbnRTdHlsZSA9IGZ1bmN0aW9uIChmb250U3RyaW5nKSB7XG4gICAgICAgIHZhciBmb250U3R5bGUgPSBmb250U3R5bGVDYWNoZVtmb250U3RyaW5nXTtcbiAgICAgICAgaWYgKCFmb250U3R5bGUpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIGNhY2hlXG4gICAgICAgICAgICBpZiAoZm9udFN0eWxlQ2FjaGVDb3VudCA+IE1BWF9GT05UX0NBQ0hFX1NJWkUpIHtcbiAgICAgICAgICAgICAgICBmb250U3R5bGVDYWNoZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb250U3R5bGVDYWNoZSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBmb250RWwuc3R5bGU7XG4gICAgICAgICAgICB2YXIgZm9udEZhbWlseTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuZm9udCA9IGZvbnRTdHJpbmc7XG4gICAgICAgICAgICAgICAgZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHkuc3BsaXQoJywnKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvbnRTdHlsZSA9IHtcbiAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUuZm9udFN0eWxlIHx8IERFRkFVTFRfU1RZTEVfTk9STUFMLFxuICAgICAgICAgICAgICAgIHZhcmlhbnQ6IHN0eWxlLmZvbnRWYXJpYW50IHx8IERFRkFVTFRfU1RZTEVfTk9STUFMLFxuICAgICAgICAgICAgICAgIHdlaWdodDogc3R5bGUuZm9udFdlaWdodCB8fCBERUZBVUxUX1NUWUxFX05PUk1BTCxcbiAgICAgICAgICAgICAgICBzaXplOiBwYXJzZUZsb2F0KHN0eWxlLmZvbnRTaXplIHx8IDEyKSB8IDAsXG4gICAgICAgICAgICAgICAgZmFtaWx5OiBmb250RmFtaWx5IHx8ICdNaWNyb3NvZnQgWWFIZWknXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb250U3R5bGVDYWNoZVtmb250U3RyaW5nXSA9IGZvbnRTdHlsZTtcbiAgICAgICAgICAgIGZvbnRTdHlsZUNhY2hlQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9udFN0eWxlO1xuICAgIH07XG5cbiAgICB2YXIgdGV4dE1lYXN1cmVFbDtcbiAgICAvLyBPdmVyd3JpdGUgbWVhc3VyZSB0ZXh0IG1ldGhvZFxuICAgIHRleHRDb250YWluLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24gKHRleHQsIHRleHRGb250KSB7XG4gICAgICAgIHZhciBkb2MgPSB2bWxDb3JlLmRvYztcbiAgICAgICAgaWYgKCF0ZXh0TWVhc3VyZUVsKSB7XG4gICAgICAgICAgICB0ZXh0TWVhc3VyZUVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGV4dE1lYXN1cmVFbC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO3RvcDotMjAwMDBweDtsZWZ0OjA7J1xuICAgICAgICAgICAgICAgICsgJ3BhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6bm9uZTt3aGl0ZS1zcGFjZTpwcmU7JztcbiAgICAgICAgICAgIHZtbENvcmUuZG9jLmJvZHkuYXBwZW5kQ2hpbGQodGV4dE1lYXN1cmVFbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGV4dE1lYXN1cmVFbC5zdHlsZS5mb250ID0gdGV4dEZvbnQ7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgZmFpbHVyZXMgdG8gc2V0IHRvIGludmFsaWQgZm9udC5cbiAgICAgICAgfVxuICAgICAgICB0ZXh0TWVhc3VyZUVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAvLyBEb24ndCB1c2UgaW5uZXJIVE1MIG9yIGlubmVyVGV4dCBiZWNhdXNlIHRoZXkgYWxsb3cgbWFya3VwL3doaXRlc3BhY2UuXG4gICAgICAgIHRleHRNZWFzdXJlRWwuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB0ZXh0TWVhc3VyZUVsLm9mZnNldFdpZHRoXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgpO1xuXG4gICAgdmFyIGRyYXdSZWN0VGV4dCA9IGZ1bmN0aW9uICh2bWxSb290LCByZWN0LCB0ZXh0UmVjdCwgZnJvbVRleHRFbCkge1xuXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICAgICAgLy8gT3B0aW1pemUsIGF2b2lkIG5vcm1hbGl6ZSBldmVyeSB0aW1lLlxuICAgICAgICB0aGlzLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpO1xuXG4gICAgICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDtcbiAgICAgICAgLy8gQ29udmVydCB0byBzdHJpbmdcbiAgICAgICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IHJpY2ggdGV4dCB0byBwbGFpbiB0ZXh0LiBSaWNoIHRleHQgaXMgbm90IHN1cHBvcnRlZCBpblxuICAgICAgICAvLyBJRTgtLCBidXQgdGFncyBpbiByaWNoIHRleHQgdGVtcGxhdGUgd2lsbCBiZSByZW1vdmVkLlxuICAgICAgICBpZiAoc3R5bGUucmljaCkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnRCbG9jayA9IHRleHRDb250YWluLnBhcnNlUmljaFRleHQodGV4dCwgc3R5bGUpO1xuICAgICAgICAgICAgdGV4dCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QmxvY2subGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gY29udGVudEJsb2NrLmxpbmVzW2ldLnRva2VucztcbiAgICAgICAgICAgICAgICB2YXIgdGV4dExpbmUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0TGluZS5wdXNoKHRva2Vuc1tqXS50ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dC5wdXNoKHRleHRMaW5lLmpvaW4oJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHg7XG4gICAgICAgIHZhciB5O1xuICAgICAgICB2YXIgYWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gICAgICAgIHZhciB2ZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ247XG5cbiAgICAgICAgdmFyIGZvbnRTdHlsZSA9IGdldEZvbnRTdHlsZShzdHlsZS5mb250KTtcbiAgICAgICAgLy8gRklYTUUgZW5jb2RlSHRtbEF0dHJpYnV0ZSA/XG4gICAgICAgIHZhciBmb250ID0gZm9udFN0eWxlLnN0eWxlICsgJyAnICsgZm9udFN0eWxlLnZhcmlhbnQgKyAnICcgKyBmb250U3R5bGUud2VpZ2h0ICsgJyAnXG4gICAgICAgICAgICArIGZvbnRTdHlsZS5zaXplICsgJ3B4IFwiJyArIGZvbnRTdHlsZS5mYW1pbHkgKyAnXCInO1xuXG4gICAgICAgIHRleHRSZWN0ID0gdGV4dFJlY3QgfHwgdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRleHQsIGZvbnQsIGFsaWduLCB2ZXJ0aWNhbEFsaWduKTtcblxuICAgICAgICAvLyBUcmFuc2Zvcm0gcmVjdCB0byB2aWV3IHNwYWNlXG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIC8vIElnbm9yZSB0cmFuc2Zvcm0gZm9yIHRleHQgaW4gb3RoZXIgZWxlbWVudFxuICAgICAgICBpZiAobSAmJiAhZnJvbVRleHRFbCkge1xuICAgICAgICAgICAgdG1wUmVjdC5jb3B5KHJlY3QpO1xuICAgICAgICAgICAgdG1wUmVjdC5hcHBseVRyYW5zZm9ybShtKTtcbiAgICAgICAgICAgIHJlY3QgPSB0bXBSZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmcm9tVGV4dEVsKSB7XG4gICAgICAgICAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gc3R5bGUudGV4dERpc3RhbmNlO1xuICAgICAgICAgICAgLy8gVGV4dCBwb3NpdGlvbiByZXByZXNlbnRlZCBieSBjb29yZFxuICAgICAgICAgICAgaWYgKHRleHRQb3NpdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMF0sIHJlY3Qud2lkdGgpO1xuICAgICAgICAgICAgICAgIHkgPSByZWN0LnkgKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzFdLCByZWN0LmhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICBhbGlnbiA9IGFsaWduIHx8ICdsZWZ0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0UG9zaXRpb25PblJlY3QoXG4gICAgICAgICAgICAgICAgICAgIHRleHRQb3NpdGlvbiwgcmVjdCwgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHggPSByZXMueDtcbiAgICAgICAgICAgICAgICB5ID0gcmVzLnk7XG5cbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGFsaWduIGFuZCBiYXNlbGluZSB3aGVuIGhhcyB0ZXh0UG9zaXRpb25cbiAgICAgICAgICAgICAgICBhbGlnbiA9IGFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgdmVydGljYWxBbGlnbiA9IHZlcnRpY2FsQWxpZ24gfHwgcmVzLnRleHRWZXJ0aWNhbEFsaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeCA9IHJlY3QueDtcbiAgICAgICAgICAgIHkgPSByZWN0Lnk7XG4gICAgICAgIH1cblxuICAgICAgICB4ID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFgoeCwgdGV4dFJlY3Qud2lkdGgsIGFsaWduKTtcbiAgICAgICAgeSA9IHRleHRDb250YWluLmFkanVzdFRleHRZKHksIHRleHRSZWN0LmhlaWdodCwgdmVydGljYWxBbGlnbik7XG5cbiAgICAgICAgLy8gRm9yY2UgYmFzZWxpbmUgJ21pZGRsZSdcbiAgICAgICAgeSArPSB0ZXh0UmVjdC5oZWlnaHQgLyAyO1xuXG4gICAgICAgIC8vIHZhciBmb250U2l6ZSA9IGZvbnRTdHlsZS5zaXplO1xuICAgICAgICAvLyAxLjc1IGlzIGFuIGFyYml0cmFyeSBudW1iZXIsIGFzIHRoZXJlIGlzIG5vIGluZm8gYWJvdXQgdGhlIHRleHQgYmFzZWxpbmVcbiAgICAgICAgLy8gc3dpdGNoIChiYXNlbGluZSkge1xuICAgICAgICAgICAgLy8gY2FzZSAnaGFuZ2luZyc6XG4gICAgICAgICAgICAvLyBjYXNlICd0b3AnOlxuICAgICAgICAgICAgLy8gICAgIHkgKz0gZm9udFNpemUgLyAxLjc1O1xuICAgICAgICAgICAgLy8gICAgIGJyZWFrO1xuICAgICAgICAvLyAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgLy8gICAgICAgICBicmVhaztcbiAgICAgICAgLy8gICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vICAgICAvLyBjYXNlIG51bGw6XG4gICAgICAgIC8vICAgICAvLyBjYXNlICdhbHBoYWJldGljJzpcbiAgICAgICAgLy8gICAgIC8vIGNhc2UgJ2lkZW9ncmFwaGljJzpcbiAgICAgICAgLy8gICAgIC8vIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIC8vICAgICAgICAgeSAtPSBmb250U2l6ZSAvIDIuMjU7XG4gICAgICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgIC8vICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgLy8gICAgICAgICBicmVhaztcbiAgICAgICAgLy8gICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIC8vICAgICAgICAgeCAtPSB0ZXh0UmVjdC53aWR0aCAvIDI7XG4gICAgICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIC8vICAgICAgICAgeCAtPSB0ZXh0UmVjdC53aWR0aDtcbiAgICAgICAgLy8gICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgLy8gYWxpZ24gPSBlbGVtZW50U3R5bGUuZGlyZWN0aW9uID09ICdsdHInID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAvLyBicmVhaztcbiAgICAgICAgICAgIC8vIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgICAgICAvLyBhbGlnbiA9IGVsZW1lbnRTdHlsZS5kaXJlY3Rpb24gPT0gJ3J0bCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgICAgIC8vIGJyZWFrO1xuICAgICAgICAgICAgLy8gZGVmYXVsdDpcbiAgICAgICAgICAgIC8vICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHZhciBjcmVhdGVOb2RlID0gdm1sQ29yZS5jcmVhdGVOb2RlO1xuXG4gICAgICAgIHZhciB0ZXh0Vm1sRWwgPSB0aGlzLl90ZXh0Vm1sRWw7XG4gICAgICAgIHZhciBwYXRoRWw7XG4gICAgICAgIHZhciB0ZXh0UGF0aEVsO1xuICAgICAgICB2YXIgc2tld0VsO1xuICAgICAgICBpZiAoIXRleHRWbWxFbCkge1xuICAgICAgICAgICAgdGV4dFZtbEVsID0gY3JlYXRlTm9kZSgnbGluZScpO1xuICAgICAgICAgICAgcGF0aEVsID0gY3JlYXRlTm9kZSgncGF0aCcpO1xuICAgICAgICAgICAgdGV4dFBhdGhFbCA9IGNyZWF0ZU5vZGUoJ3RleHRwYXRoJyk7XG4gICAgICAgICAgICBza2V3RWwgPSBjcmVhdGVOb2RlKCdza2V3Jyk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FIFdoeSBoZXJlIGlzIG5vdCBjYW1tZWwgY2FzZVxuICAgICAgICAgICAgLy8gQWxpZ24gJ2NlbnRlcicgc2VlbXMgd3JvbmdcbiAgICAgICAgICAgIHRleHRQYXRoRWwuc3R5bGVbJ3YtdGV4dC1hbGlnbiddID0gJ2xlZnQnO1xuXG4gICAgICAgICAgICBpbml0Um9vdEVsU3R5bGUodGV4dFZtbEVsKTtcblxuICAgICAgICAgICAgcGF0aEVsLnRleHRwYXRob2sgPSB0cnVlO1xuICAgICAgICAgICAgdGV4dFBhdGhFbC5vbiA9IHRydWU7XG5cbiAgICAgICAgICAgIHRleHRWbWxFbC5mcm9tID0gJzAgMCc7XG4gICAgICAgICAgICB0ZXh0Vm1sRWwudG8gPSAnMTAwMCAwLjA1JztcblxuICAgICAgICAgICAgYXBwZW5kKHRleHRWbWxFbCwgc2tld0VsKTtcbiAgICAgICAgICAgIGFwcGVuZCh0ZXh0Vm1sRWwsIHBhdGhFbCk7XG4gICAgICAgICAgICBhcHBlbmQodGV4dFZtbEVsLCB0ZXh0UGF0aEVsKTtcblxuICAgICAgICAgICAgdGhpcy5fdGV4dFZtbEVsID0gdGV4dFZtbEVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8g6L+Z6YeM5piv5Zyo5YmN6Z2iIGFwcGVuZENoaWxkIOS/neivgemhuuW6j+eahOWJjeaPkOS4i1xuICAgICAgICAgICAgc2tld0VsID0gdGV4dFZtbEVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBwYXRoRWwgPSBza2V3RWwubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB0ZXh0UGF0aEVsID0gcGF0aEVsLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvb3JkcyA9IFt4LCB5XTtcbiAgICAgICAgdmFyIHRleHRWbWxFbFN0eWxlID0gdGV4dFZtbEVsLnN0eWxlO1xuICAgICAgICAvLyBJZ25vcmUgdHJhbnNmb3JtIGZvciB0ZXh0IGluIG90aGVyIGVsZW1lbnRcbiAgICAgICAgaWYgKG0gJiYgZnJvbVRleHRFbCkge1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0oY29vcmRzLCBjb29yZHMsIG0pO1xuXG4gICAgICAgICAgICBza2V3RWwub24gPSB0cnVlO1xuXG4gICAgICAgICAgICBza2V3RWwubWF0cml4ID0gbVswXS50b0ZpeGVkKDMpICsgY29tbWEgKyBtWzJdLnRvRml4ZWQoMykgKyBjb21tYSArXG4gICAgICAgICAgICBtWzFdLnRvRml4ZWQoMykgKyBjb21tYSArIG1bM10udG9GaXhlZCgzKSArICcsMCwwJztcblxuICAgICAgICAgICAgLy8gVGV4dCBwb3NpdGlvblxuICAgICAgICAgICAgc2tld0VsLm9mZnNldCA9IChyb3VuZChjb29yZHNbMF0pIHx8IDApICsgJywnICsgKHJvdW5kKGNvb3Jkc1sxXSkgfHwgMCk7XG4gICAgICAgICAgICAvLyBMZWZ0IHRvcCBwb2ludCBhcyBvcmlnaW5cbiAgICAgICAgICAgIHNrZXdFbC5vcmlnaW4gPSAnMCAwJztcblxuICAgICAgICAgICAgdGV4dFZtbEVsU3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICAgICAgdGV4dFZtbEVsU3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBza2V3RWwub24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRleHRWbWxFbFN0eWxlLmxlZnQgPSByb3VuZCh4KSArICdweCc7XG4gICAgICAgICAgICB0ZXh0Vm1sRWxTdHlsZS50b3AgPSByb3VuZCh5KSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0UGF0aEVsLnN0cmluZyA9IGVuY29kZUh0bWxBdHRyaWJ1dGUodGV4dCk7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRleHRQYXRoRWwuc3R5bGUuZm9udCA9IGZvbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXJyb3IgZm9udCBmb3JtYXRcbiAgICAgICAgY2F0Y2ggKGUpIHt9XG5cbiAgICAgICAgdXBkYXRlRmlsbEFuZFN0cm9rZSh0ZXh0Vm1sRWwsICdmaWxsJywge1xuICAgICAgICAgICAgZmlsbDogc3R5bGUudGV4dEZpbGwsXG4gICAgICAgICAgICBvcGFjaXR5OiBzdHlsZS5vcGFjaXR5XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB1cGRhdGVGaWxsQW5kU3Ryb2tlKHRleHRWbWxFbCwgJ3N0cm9rZScsIHtcbiAgICAgICAgICAgIHN0cm9rZTogc3R5bGUudGV4dFN0cm9rZSxcbiAgICAgICAgICAgIG9wYWNpdHk6IHN0eWxlLm9wYWNpdHksXG4gICAgICAgICAgICBsaW5lRGFzaDogc3R5bGUubGluZURhc2hcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdGV4dFZtbEVsLnN0eWxlLnpJbmRleCA9IGdldFpJbmRleCh0aGlzLnpsZXZlbCwgdGhpcy56LCB0aGlzLnoyKTtcblxuICAgICAgICAvLyBBdHRhY2hlZCB0byByb290XG4gICAgICAgIGFwcGVuZCh2bWxSb290LCB0ZXh0Vm1sRWwpO1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlUmVjdFRleHQgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICByZW1vdmUodm1sUm9vdCwgdGhpcy5fdGV4dFZtbEVsKTtcbiAgICAgICAgdGhpcy5fdGV4dFZtbEVsID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIGFwcGVuZFJlY3RUZXh0ID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICAgICAgYXBwZW5kKHZtbFJvb3QsIHRoaXMuX3RleHRWbWxFbCk7XG4gICAgfTtcblxuICAgIHZhciBsaXN0ID0gW1JlY3RUZXh0LCBEaXNwbGF5YWJsZSwgWkltYWdlLCBQYXRoLCBUZXh0XTtcblxuICAgIC8vIEluIGNhc2UgRGlzcGxheWFibGUgaGFzIGJlZW4gbWl4ZWQgaW4gUmVjdFRleHRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3RvID0gbGlzdFtpXS5wcm90b3R5cGU7XG4gICAgICAgIHByb3RvLmRyYXdSZWN0VGV4dCA9IGRyYXdSZWN0VGV4dDtcbiAgICAgICAgcHJvdG8ucmVtb3ZlUmVjdFRleHQgPSByZW1vdmVSZWN0VGV4dDtcbiAgICAgICAgcHJvdG8uYXBwZW5kUmVjdFRleHQgPSBhcHBlbmRSZWN0VGV4dDtcbiAgICB9XG5cbiAgICBUZXh0LnByb3RvdHlwZS5icnVzaFZNTCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KHZtbFJvb3QsIHtcbiAgICAgICAgICAgICAgICB4OiBzdHlsZS54IHx8IDAsIHk6IHN0eWxlLnkgfHwgMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogMCwgaGVpZ2h0OiAwXG4gICAgICAgICAgICB9LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVGV4dC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgICAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH07XG5cbiAgICBUZXh0LnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvdm1sL2dyYXBoaWMuanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcblxuaWYgKCFyZXF1aXJlKCcuLi9jb3JlL2VudicpLmNhbnZhc1N1cHBvcnRlZCkge1xuICAgIHZhciB1cm4gPSAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnO1xuXG4gICAgdmFyIGNyZWF0ZU5vZGU7XG4gICAgdmFyIHdpbiA9IHdpbmRvdztcbiAgICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuXG4gICAgdmFyIHZtbEluaXRlZCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgIWRvYy5uYW1lc3BhY2VzLnpydm1sICYmIGRvYy5uYW1lc3BhY2VzLmFkZCgnenJ2bWwnLCB1cm4pO1xuICAgICAgICBjcmVhdGVOb2RlID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2MuY3JlYXRlRWxlbWVudCgnPHpydm1sOicgKyB0YWdOYW1lICsgJyBjbGFzcz1cInpydm1sXCI+Jyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KCc8JyArIHRhZ05hbWUgKyAnIHhtbG5zPVwiJyArIHVybiArICdcIiBjbGFzcz1cInpydm1sXCI+Jyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRnJvbSByYXBoYWVsXG4gICAgdmFyIGluaXRWTUwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bWxJbml0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2bWxJbml0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHZhciBzdHlsZVNoZWV0cyA9IGRvYy5zdHlsZVNoZWV0cztcbiAgICAgICAgaWYgKHN0eWxlU2hlZXRzLmxlbmd0aCA8IDMxKSB7XG4gICAgICAgICAgICBkb2MuY3JlYXRlU3R5bGVTaGVldCgpLmFkZFJ1bGUoJy56cnZtbCcsICdiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMxMTk0JTI4VlMuODUlMjkuYXNweFxuICAgICAgICAgICAgc3R5bGVTaGVldHNbMF0uYWRkUnVsZSgnLnpydm1sJywgJ2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gTm90IHVzZWluZyByZXR1cm4gdG8gYXZvaWQgZXJyb3Igd2hlbiBjb252ZXJ0aW5nIHRvIENvbW1vbkpTIG1vZHVsZVxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBkb2M6IGRvYyxcbiAgICAgICAgaW5pdFZNTDogaW5pdFZNTCxcbiAgICAgICAgY3JlYXRlTm9kZTogY3JlYXRlTm9kZVxuICAgIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjMuNi4zQHpyZW5kZXIvbGliL3ZtbC9jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBWTUwgUGFpbnRlci5cbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvdm1sL1BhaW50ZXJcbiAqL1xuXG5cblxuICAgIHZhciB6ckxvZyA9IHJlcXVpcmUoJy4uL2NvcmUvbG9nJyk7XG4gICAgdmFyIHZtbENvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSW50MTAodmFsKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvdm1sL1BhaW50ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWTUxQYWludGVyKHJvb3QsIHN0b3JhZ2UpIHtcblxuICAgICAgICB2bWxDb3JlLmluaXRWTUwoKTtcblxuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG5cbiAgICAgICAgdmFyIHZtbFZpZXdwb3J0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgdmFyIHZtbFJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICB2bWxWaWV3cG9ydC5zdHlsZS5jc3NUZXh0ID0gJ2Rpc3BsYXk6aW5saW5lLWJsb2NrO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDozMDBweDtoZWlnaHQ6MTUwcHg7JztcblxuICAgICAgICB2bWxSb290LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowOyc7XG5cbiAgICAgICAgcm9vdC5hcHBlbmRDaGlsZCh2bWxWaWV3cG9ydCk7XG5cbiAgICAgICAgdGhpcy5fdm1sUm9vdCA9IHZtbFJvb3Q7XG4gICAgICAgIHRoaXMuX3ZtbFZpZXdwb3J0ID0gdm1sVmlld3BvcnQ7XG5cbiAgICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgICAvLyBNb2RpZnkgc3RvcmFnZVxuICAgICAgICB2YXIgb2xkRGVsRnJvbVN0b3JhZ2UgPSBzdG9yYWdlLmRlbEZyb21TdG9yYWdlO1xuICAgICAgICB2YXIgb2xkQWRkVG9TdG9yYWdlID0gc3RvcmFnZS5hZGRUb1N0b3JhZ2U7XG4gICAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIG9sZERlbEZyb21TdG9yYWdlLmNhbGwoc3RvcmFnZSwgZWwpO1xuXG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5vblJlbW92ZSAmJiBlbC5vblJlbW92ZSh2bWxSb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzdG9yYWdlLmFkZFRvU3RvcmFnZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgLy8gRGlzcGxheWFibGUgYWxyZWFkeSBoYXMgYSB2bWwgbm9kZVxuICAgICAgICAgICAgZWwub25BZGQgJiYgZWwub25BZGQodm1sUm9vdCk7XG5cbiAgICAgICAgICAgIG9sZEFkZFRvU3RvcmFnZS5jYWxsKHN0b3JhZ2UsIGVsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9maXJzdFBhaW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBWTUxQYWludGVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogVk1MUGFpbnRlcixcblxuICAgICAgICBnZXRUeXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ZtbCc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0hUTUxEaXZFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdm1sVmlld3BvcnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Vmlld3BvcnRSb290T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmlld3BvcnRSb290ID0gdGhpcy5nZXRWaWV3cG9ydFJvb3QoKTtcbiAgICAgICAgICAgIGlmICh2aWV3cG9ydFJvb3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0OiB2aWV3cG9ydFJvb3Qub2Zmc2V0TGVmdCB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb3A6IHZpZXdwb3J0Um9vdC5vZmZzZXRUb3AgfHwgMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIt+aWsFxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlLCB0cnVlKTtcblxuICAgICAgICAgICAgdGhpcy5fcGFpbnRMaXN0KGxpc3QpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9wYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgICAgICB2YXIgdm1sUm9vdCA9IHRoaXMuX3ZtbFJvb3Q7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBsaXN0W2ldO1xuICAgICAgICAgICAgICAgIGlmIChlbC5pbnZpc2libGUgfHwgZWwuaWdub3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWwuX19hbHJlYWR5Tm90VmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwub25SZW1vdmUodm1sUm9vdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGFzIGFscmVhZHkgaW52aXNpYmxlXG4gICAgICAgICAgICAgICAgICAgIGVsLl9fYWxyZWFkeU5vdFZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLl9fYWxyZWFkeU5vdFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLm9uQWRkKHZtbFJvb3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsLl9fYWxyZWFkeU5vdFZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmJlZm9yZUJydXNoICYmIGVsLmJlZm9yZUJydXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoZWwuYnJ1c2hWTUwgfHwgZWwuYnJ1c2gpLmNhbGwoZWwsIHZtbFJvb3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuYWZ0ZXJCcnVzaCAmJiBlbC5hZnRlckJydXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWwuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fZmlyc3RQYWludCkge1xuICAgICAgICAgICAgICAgIC8vIERldGFjaGVkIGZyb20gZG9jdW1lbnQgYXQgZmlyc3QgdGltZVxuICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIHBhZ2UgcmVmcmVzaGluZyB0b28gbWFueSB0aW1lc1xuXG4gICAgICAgICAgICAgICAgLy8gRklYTUUg5aaC5p6c5q+P5qyh6YO95YWIIHJlbW92ZUNoaWxkIOWPr+iDveS8muWvvOiHtOS4gOS6m+Whq+WFheWSjOaPj+i+ueeahOaViOaenOaUueWPmFxuICAgICAgICAgICAgICAgIHRoaXMuX3ZtbFZpZXdwb3J0LmFwcGVuZENoaWxkKHZtbFJvb3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcnN0UGFpbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB3aWR0aCA9PSBudWxsID8gdGhpcy5fZ2V0V2lkdGgoKSA6IHdpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGhlaWdodCA9PSBudWxsID8gdGhpcy5fZ2V0SGVpZ2h0KCkgOiBoZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl93aWR0aCAhPSB3aWR0aCB8fCB0aGlzLl9oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgdm1sVmlld3BvcnRTdHlsZSA9IHRoaXMuX3ZtbFZpZXdwb3J0LnN0eWxlO1xuICAgICAgICAgICAgICAgIHZtbFZpZXdwb3J0U3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgdm1sVmlld3BvcnRTdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5pbm5lckhUTUwgPSAnJztcblxuICAgICAgICAgICAgdGhpcy5fdm1sUm9vdCA9XG4gICAgICAgICAgICB0aGlzLl92bWxWaWV3cG9ydCA9XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdm1sVmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QucmVtb3ZlQ2hpbGQodGhpcy5fdm1sVmlld3BvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICB2YXIgc3RsID0gcm9vdC5jdXJyZW50U3R5bGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKHJvb3QuY2xpZW50V2lkdGggfHwgcGFyc2VJbnQxMChzdGwud2lkdGgpKVxuICAgICAgICAgICAgICAgICAgICAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdMZWZ0KVxuICAgICAgICAgICAgICAgICAgICAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdSaWdodCkpIHwgMDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIHZhciBzdGwgPSByb290LmN1cnJlbnRTdHlsZTtcblxuICAgICAgICAgICAgcmV0dXJuICgocm9vdC5jbGllbnRIZWlnaHQgfHwgcGFyc2VJbnQxMChzdGwuaGVpZ2h0KSlcbiAgICAgICAgICAgICAgICAgICAgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nVG9wKVxuICAgICAgICAgICAgICAgICAgICAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdCb3R0b20pKSB8IDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gTm90IHN1cHBvcnRlZCBtZXRob2RzXG4gICAgZnVuY3Rpb24gY3JlYXRlTWV0aG9kTm90U3VwcG9ydChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHpyTG9nKCdJbiBJRTguMCBWTUwgbW9kZSBwYWludGVyIG5vdCBzdXBwb3J0IG1ldGhvZCBcIicgKyBtZXRob2QgKyAnXCInKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbm90U3VwcG9ydGVkTWV0aG9kcyA9IFtcbiAgICAgICAgJ2dldExheWVyJywgJ2luc2VydExheWVyJywgJ2VhY2hMYXllcicsICdlYWNoQnVpbHRpbkxheWVyJywgJ2VhY2hPdGhlckxheWVyJywgJ2dldExheWVycycsXG4gICAgICAgICdtb2RMYXllcicsICdkZWxMYXllcicsICdjbGVhckxheWVyJywgJ3RvRGF0YVVSTCcsICdwYXRoVG9JbWFnZSdcbiAgICBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3RTdXBwb3J0ZWRNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gbm90U3VwcG9ydGVkTWV0aG9kc1tpXTtcbiAgICAgICAgVk1MUGFpbnRlci5wcm90b3R5cGVbbmFtZV0gPSBjcmVhdGVNZXRob2ROb3RTdXBwb3J0KG5hbWUpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gVk1MUGFpbnRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMy42LjNAenJlbmRlci9saWIvdm1sL1BhaW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9