{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","fish-topo-bo.js","webpack:/webpack/bootstrap d999bf11626ecda66fa4","webpack:///index.bo.js","webpack:///lib/fish-topo-bo/lib/FishTopoBo.js","webpack:///~/zrender/lib/zrender.js","webpack:///~/zrender/lib/core/guid.js","webpack:///~/zrender/lib/core/env.js","webpack:///~/zrender/lib/core/util.js","webpack:///~/zrender/lib/Handler.js","webpack:///~/zrender/lib/mixin/Draggable.js","webpack:///~/zrender/lib/mixin/Eventful.js","webpack:///~/zrender/lib/Storage.js","webpack:///~/zrender/lib/container/Group.js","webpack:///~/zrender/lib/Element.js","webpack:///~/zrender/lib/mixin/Transformable.js","webpack:///~/zrender/lib/core/matrix.js","webpack:///~/zrender/lib/core/vector.js","webpack:///~/zrender/lib/mixin/Animatable.js","webpack:///~/zrender/lib/animation/Animator.js","webpack:///~/zrender/lib/animation/Clip.js","webpack:///~/zrender/lib/animation/easing.js","webpack:///~/zrender/lib/tool/color.js","webpack:///~/zrender/lib/core/LRU.js","webpack:///~/zrender/lib/core/log.js","webpack:///~/zrender/lib/config.js","webpack:///~/zrender/lib/core/BoundingRect.js","webpack:///~/zrender/lib/core/timsort.js","webpack:///~/zrender/lib/animation/Animation.js","webpack:///~/zrender/lib/core/event.js","webpack:///~/zrender/lib/animation/requestAnimationFrame.js","webpack:///~/zrender/lib/dom/HandlerProxy.js","webpack:///~/zrender/lib/core/GestureMgr.js","webpack:///~/zrender/lib/Painter.js","webpack:///~/zrender/lib/Layer.js","webpack:///~/zrender/lib/graphic/Style.js","webpack:///~/zrender/lib/graphic/Pattern.js","webpack:///~/zrender/lib/graphic/Image.js","webpack:///~/zrender/lib/graphic/Displayable.js","webpack:///~/zrender/lib/graphic/mixin/RectText.js","webpack:///~/zrender/lib/contain/text.js","webpack:///lib/fish-topo-bo/lib/node/BoNode.js","webpack:///lib/fish-topo-bo/lib/models/Const.js","webpack:///lib/fish-topo-bo/lib/node/BoName.js","webpack:///lib/fish-topo-core/lib/graphic.js","webpack:///~/zrender/lib/tool/path.js","webpack:///~/zrender/lib/graphic/Path.js","webpack:///~/zrender/lib/core/PathProxy.js","webpack:///~/zrender/lib/core/curve.js","webpack:///~/zrender/lib/core/bbox.js","webpack:///~/zrender/lib/contain/path.js","webpack:///~/zrender/lib/contain/line.js","webpack:///~/zrender/lib/contain/cubic.js","webpack:///~/zrender/lib/contain/quadratic.js","webpack:///~/zrender/lib/contain/arc.js","webpack:///~/zrender/lib/contain/util.js","webpack:///~/zrender/lib/contain/windingLine.js","webpack:///~/zrender/lib/tool/transformPath.js","webpack:///~/zrender/lib/graphic/Gradient.js","webpack:///~/zrender/lib/graphic/Text.js","webpack:///~/zrender/lib/graphic/shape/Circle.js","webpack:///~/zrender/lib/graphic/shape/Sector.js","webpack:///~/zrender/lib/graphic/shape/Ring.js","webpack:///~/zrender/lib/graphic/shape/Polygon.js","webpack:///~/zrender/lib/graphic/helper/poly.js","webpack:///~/zrender/lib/graphic/helper/smoothSpline.js","webpack:///~/zrender/lib/graphic/helper/smoothBezier.js","webpack:///~/zrender/lib/graphic/shape/Polyline.js","webpack:///~/zrender/lib/graphic/shape/Rect.js","webpack:///~/zrender/lib/graphic/helper/roundRect.js","webpack:///~/zrender/lib/graphic/shape/Line.js","webpack:///~/zrender/lib/graphic/shape/BezierCurve.js","webpack:///~/zrender/lib/graphic/shape/Arc.js","webpack:///~/zrender/lib/graphic/LinearGradient.js","webpack:///~/zrender/lib/graphic/RadialGradient.js","webpack:///lib/fish-topo-bo/lib/node/EventDecisionNode.js","webpack:///lib/fish-topo-bo/lib/node/LineNode.js","webpack:///lib/fish-topo-bo/lib/node/BoAttrNode.js","webpack:///lib/fish-topo-bo/lib/node/Relation.js","webpack:///~/zrender/lib/vml/vml.js","webpack:///~/zrender/lib/vml/graphic.js","webpack:///~/zrender/lib/vml/core.js","webpack:///~/zrender/lib/vml/Painter.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","FishTopoBo","dom","opts","nowZoom","canScale","_zr","zr","init","renderer","devicePixelRatio","util","BoNode","Relation","Const","graphic","eventTool","fishTopoProto","prototype","group","Group","groupDrag","add","zrScale","resize","addBo","boData","_setParent","layout","x","startPos","y","level","_bfs","_moveRightByParent","boNode","getShape","addChildBo","child","childCnt","length","childBoArr","i","parent","next","_levelMaxPos","_queue","push","tmp","shift","BO_NODE_WIDTH","_moveRightByChild","BO_NODE_OFFSET_X","width","moved","_moveRightByPrevious","parentBoNode","boNodeHeight","getBoundingRect","height","getLayout","BO_NODE_OFFSET_Y","getData","relationNode","relation","_relationLen","j","sourceId","targetId","sourceText","targetText","childOfName","setCurrentBo","boId","style","childCount","childAt","name","setCurrent","clear","type","zoom","zoomDelta","zoomX","zoomY","that","target","pos","position","scale","newZoom","_zoom","zoomScale","attr","getWidth","getHeight","on","e","stop","event","wheelDelta","offsetX","offsetY","groupDragFunction","moveDrag","gx","gy","min","max","sX","clientX","startX","sY","clientY","startY","nowGroupPosition","groupPositionX","groupPositionY","endDrag","off","moveFunction","upFunction","cancelBubble","drag","node","GroupNode","nodeMessage","shape","nodeXY","movePosition","moveX","moveY","groupNode","reDraw","alarm","newAlarmPosition","ConnectionManager","refreshLineByNode","layoutNode","forceLayoutOption","nodes","allNodes","_","indexOf","alarmPositionX","alarmPositionY","isdraggable","idBase","Date","instances","DOM_ATTRIBUTE_KEY","fishTopoBo","version","dependencies","zrender","Error","defaults","showGridLine","gridLineSpacing","setAttribute","getInstanceByDom","key","getAttribute","dispose","chart","topo","zrUtil","isDom","isDisposed","delInstance","guid","env","Handler","Storage","Animation","HandlerProxy","useVML","canvasSupported","painterCtors","canvas","ZRender","hasOwnProperty","getInstance","registerPainter","Ctor","self","storage","rendererType","vml","painter","handerProxy","getViewportRoot","handler","animation","stage","update","bind","flush","start","_needsRefresh","oldDelFromMap","delFromMap","oldAddToMap","addToMap","elId","el","get","removeSelfFromZr","addSelfToZr","constructor","getId","addRoot","remove","delRoot","configLayer","zLevel","config","refreshImmediately","refresh","_needsRefreshHover","refreshHoverImmediately","addHover","refreshHover","removeHover","clearHover","clearAnimation","pathToImage","dpr","setCursorStyle","cursorStyle","eventName","eventHandler","context","trigger","idStart","detect","ua","os","browser","firefox","match","ie","edge","weChat","test","document","createElement","getContext","touchEventsSupported","window","pointerEventsSupported","navigator","userAgent","clone","source","result","typeStr","objToString","len","TYPED_ARRAY","from","BUILTIN_OBJECT","isPrimitive","merge","overwrite","isObject","targetProp","sourceProp","isArray","isBuiltInObject","mergeAll","targetAndSources","extend","overlay","createCanvas","_ctx","array","value","inherits","clazz","baseClazz","F","clazzPrototype","prop","superClass","mixin","isArrayLike","data","each","obj","cb","forEach","nativeForEach","map","nativeMap","reduce","memo","nativeReduce","filter","nativeFilter","find","func","args","nativeSlice","arguments","apply","concat","curry","isFunction","isString","nodeType","ownerDocument","eqNaN","retrieve","values","slice","Function","assert","condition","message","setAsPrimitive","primitiveKey","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","Object","toString","arrayProto","Array","noop","makeEventPacket","eveType","zrX","zrY","gestureEvent","pinchX","pinchY","pinchScale","zrDelta","zrByTouch","EmptyProxy","isHover","displayable","rectHover","silent","clipPath","contain","Draggable","Eventful","handlerNames","proxy","painterRoot","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","hovered","findHover","lastHovered","setCursor","cursor","__zr","dispatchToElement","mouseout","innerDom","element","toElement","relatedTarget","parentNode","dispatch","eventArgs","targetEl","eventPacket","eachOtherLayer","layer","exclude","list","getDisplayList","ignore","_downel","_upel","_dragStart","_drag","_dragEnd","draggingTarget","draggable","_draggingTarget","dragging","_x","_y","dx","dy","drift","dropTarget","lastDropTarget","_dropTarget","arrySlice","_$handlers","one","_h","h","ctx","isSilent","newList","l","argLen","splice","triggerWithContext","shapeCompareFunc","a","b","zlevel","z","z2","timsort","_elements","_roots","_displayList","_displayListLen","traverse","includeIgnore","updateDisplayList","roots","displayList","_updateAndAddDisplayable","clipPaths","beforeUpdate","__dirty","afterUpdate","userSetClipPath","currentClipPath","parentClipPath","updateTransform","isGroup","children","_children","__clipPaths","addChildrenToStorage","delChildrenFromStorage","idx","__storage","dirty","elements","_renderList","displayableSortFunc","Element","BoundingRect","_doAdd","addBefore","nextSibling","removeAll","eachChild","includeChildren","rect","tmpRect","tmpMat","invisible","childRect","transform","getLocalTransform","copy","applyTransform","union","Transformable","Animatable","decomposeTransform","attrKV","hide","show","setClipPath","removeClipPath","__clipTarget","animators","addAnimator","removeAnimator","isNotAroundZero","val","EPSILON","matrix","vector","mIdentity","identity","rotation","origin","transformableProto","needLocalTransform","parentHasTransform","create","mul","invTransform","invert","rotate","setTransform","restoreTransform","tmpTransform","sx","sy","Math","sqrt","atan2","getGlobalScale","transformCoordToLocal","v2","transformCoordToGlobal","ArrayCtor","Float32Array","out","m1","m2","out0","out1","out2","out3","out4","out5","translate","v","rad","aa","ac","atx","ab","ad","aty","st","sin","ct","cos","vx","vy","det","set","v1","scaleAndAdd","sub","lenSquare","div","dot","s","normalize","d","distance","distanceSquare","negate","lerp","t","lengthSquare","dist","distSquare","Animator","log","animate","path","loop","animatingShape","pathSplitted","split","animator","during","done","stopAnimation","forwardToLast","animateTo","time","delay","easing","callback","count","_animateToShallow","objShallow","propertyCount","props","when","defaultGetter","defaultSetter","interpolateNumber","p0","p1","percent","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isNaN","isArraySame","catmullRomInterpolateArray","p2","p3","t2","t3","catmullRomInterpolate","v0","cloneValue","ret","rgba2String","rgba","floor","join","createTrackClip","oneTrackDone","keyframes","propName","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","sort","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","color","parse","lastValue","_target","w","lastFrame","lastFramePercent","onframe","frame","range","clip","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","pause","_paused","resume","isPaused","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","clipList","removeClip","getClips","options","_life","_initialized","gap","onrestart","_pausedTime","easingFuncs","step","globalTime","deltaTime","_startTime","easingFunc","schedule","fire","restart","_needsRemove","remainder","eventType","arg","linear","k","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","PI","sinusoidalOut","sinusoidalInOut","exponentialIn","pow","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","clampCssByte","round","clampCssAngle","clampCssFloat","f","parseCssInt","str","charAt","parseFloat","parseInt","parseCssFloat","cssHueToRgb","setRgba","r","g","copyRgba","putToCache","colorStr","rgbaArr","lastRemovedArr","colorCache","put","cached","replace","toLowerCase","kCSSColorTable","op","ep","fname","substr","params","alpha","pop","hsla2rgba","iv","hsla","rgba2hsla","H","S","R","G","B","vMin","vMax","delta","L","deltaR","deltaG","deltaB","lift","colorArr","stringify","toHex","fastMapToColor","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","LRU","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","LinkedList","head","tail","_len","linkedListProto","insert","entry","Entry","insertEntry","prev","maxSize","_list","_map","_maxSize","_lastRemovedEntry","LRUProto","removed","leastUsedEntry","debugMode","console","vec2","v2ApplyTransform","mathMin","mathMax","other","lt","rb","lb","rt","maxX","maxY","calculateTransform","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","minRunLength","n","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","mid","pivot","left","right","gallopLeft","hint","lastOffset","maxOffset","offset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","Dispatcher","requestAnimationFrame","_clips","_running","_time","_pauseStart","clips","_update","getTime","deferredEvents","deferredClips","_startLoop","getBoundingClientRect","top","clientToLocal","calculate","defaultGetZrXY","layerX","layerY","box","normalizeEvent","isTouch","touch","targetTouches","changedTouches","detail","addEventListener","isDomLevel2","attachEvent","removeEventListener","detachEvent","preventDefault","stopPropagation","returnValue","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","setTimeout","eventNameFix","processGesture","gestureMgr","_gestureMgr","gestureInfo","recognize","setTouchTimer","instance","_touching","clearTimeout","_touchTimer","isPointerFromTouch","pointerType","initDomHandler","makeMouseHandler","fn","touchHandlerNames","_handlers","domHandlers","pointerHandlerNames","mouseHandlerNames","HandlerDomProxy","mountHandlers","GestureMgr","TOUCH_CLICK_DELAY","pointerEventNames","pointerdown","pointerup","pointermove","pointerout","nm","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","pointPair","center","eventUtil","_track","_doTrack","_recognize","touches","trackItem","points","recognizers","pinch","track","pinchEnd","pinchPre","isFinite","pinchCenter","parseInt10","isLayerValid","__builtin__","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","beginPath","buildPath","createRoot","domRoot","cssText","Layer","MAX_PROGRESSIVE_LAYER_NUMBER","Painter","singleCanvas","nodeName","toUpperCase","_opts","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","initContext","_domRoot","_getSize","appendChild","_progressiveLayers","_hoverlayer","_hoverElements","isSingleCanvas","paintAll","_paintList","_startProgessive","hoverStyle","__hoverMir","elMirror","__from","setStyle","hoverElements","hoverLayer","getLayer","scope","save","originalEl","_doPaintEl","restore","token","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuiltinLayer","flushProgressiveLayer","globalAlpha","shadowBlur","currentLayer","drawImage","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","opacity","culling","prevClipLayer","prevElClipPaths","prevEl","beforeBrush","brush","afterBrush","insertLayer","layersMap","prevLayer","virtual","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","elCount","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","progressive","_clearLayer","layerConfig","delLayer","removeChild","display","clearLayer","getRenderedCanvas","imageLayer","pixelRatio","clearColor","backgroundColor","whIdx","wh","cwh","plt","prb","stl","defaultView","getComputedStyle","shadowBlurSize","shadowOffsetX","shadowOffsetY","lineWidth","hasStroke","leftMargin","rightMargin","topMargin","bottomMargin","clearRect","pathTransform","ImageShape","imgShape","image","returnFalse","createDom","newDom","newDomStyle","Style","Pattern","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","createBackBuffer","clearAll","haveMotionBLur","globalCompositeOperation","clearColorGradientOrPattern","colorStops","__canvasGradient","getGradient","getCanvasPattern","fillStyle","fillRect","createLinearGradient","x2","y2","global","canvasGradient","createRadialGradient","STYLE_COMMON_PROPS","extendFrom","fill","stroke","lineDash","lineDashOffset","strokeNoScale","text","textFill","textStroke","textPosition","textOffset","textBaseline","textAlign","textVerticalAlign","textDistance","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","textRotation","blend","prevStyle","firstDraw","styleName","strokeStyle","getLineScale","hasFill","otherStyle","newStyle","method","addColorStop","styleProto","repeat","_canvasPattern","createPattern","ZImage","Displayable","globalImageCache","src","_image","cachedImgObj","Image","onload","pending","aspect","sWidth","sHeight","drawRectText","_rect","RectText","rectContain","coord","animateStyle","useStyle","parsePercent","maxValue","lastIndexOf","textContain","textRect","align","font","textFont","baseline","verticalAlign","lineHeight","res","adjustTextPositionOnRect","shadowColor","textShadowColor","textLines","strokeText","fillText","getTextWidth","textWidthCache","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getTextRect","textLineLen","textHeight","halfHeight","truncateText","containerWidth","ellipsis","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","BO","_data","viewOption","fish","_oriStartPos","_nextStartPos","_displayAttrDataType","displayAttrDataType","_displayAttrEvent","displayAttrEvent","_boClickable","boClickable","_boPopupOpts","boPopupOpts","_boEventClickable","boEventClickable","_boEventPopupOpts","boEventPopupOpts","_attrEventClickable","attrEventClickable","_attrEventPopupOpts","attrEventPopupOpts","_isCurrent","isCurrent","_boShapeHeight","_group","_boShape","_render","BoName","EventDecision","Line","BoAttr","boProto","_createBoName","_createEventDecision","_createBoAttr","_createBoShape","_boNameShape","clickable","onclick","_click","_calNextShapeStartPos","boEventArr","_eventShape","_boEventArr","_boEventLen","_eventOpts","popupOpts","boAttrArr","_boAttrShape","_lineShape","_boAttrArr","_boAttrLen","_attrEventStartPos","BoLine","AttrLine","displayDataType","displayEventDecision","eventClickable","eventPopupOpts","AttrEventLine","curShape","BO_NODE_DEFAULT_HEIGHT","Rect","brushType","lineCape","DATA","popupView","BO_NAME_FONT","BO_NAME_PADDING_TOP","BO_NAME_PADDING_BOTTOM","BO_EVENT_HEIGHT","BO_EVENT_WIDTH","BO_EVENT_FONT","BO_ATTR_FONT","BO_ATTR_PADDING_TOP","BO_ATTR_PADDING_BOTTOM","BO_ATTR_PADDING_LEFT","BO_ATTR_DATA_TYPE_PADDING_RIGHT","BO_ATTR_EVENT_WIDTH","LINE_DASH","RELATION_OFFSET","RELATION_ARROW_WIDTH","RELATION_ARROW_HEIGHT","RELATION_TEXT_OFFSET_X","RELATION_TEXT_OFFSET_Y","Text","doSingleEnterHover","__isHover","__hoverStlDirty","__hoverStl","colorTool","Gradient","normalStyle","__normalStl","doSingleLeaveHover","normalStl","doEnterHover","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","animatableModel","postfix","duration","getShallow","animationEasing","pathTool","Path","Util","Circle","Sector","Ring","Polygon","Polyline","BezierCurve","Arc","LinearGradient","RadialGradient","extendShape","extendPath","pathData","extendFromString","makePath","createFromString","boundingRect","cx","cy","resizePath","mergePath","pathRect","subPixelOptimizeLine","param","subPixelOptimize","x1","y1","subPixelOptimizeRect","originX","originY","originWidth","originHeight","positiveOrNegative","doubledPosition","setHoverStyle","setNormalStyle","setText","textStyle","labelModel","labelPosition","labelColor","textStyleModel","getModel","getFont","getTextColor","updateProps","initProps","getTransform","ancestor","mat","vertex","transformDirection","direction","hBase","abs","vBase","processArc","fa","fs","rx","ry","psiDeg","cmd","psi","xp","mathCos","mathSin","yp","lambda","mathSqrt","cxp","cyp","theta","vAngle","u","dTheta","vRatio","addData","createPathProxyFromString","cs","cc","RegExp","prevCmd","arr","cpx","cpy","PathProxy","CMD","ctlPtx","ctlPty","M","C","Q","A","Z","toStatic","createPathOptions","pathProxy","setData","transformPath","rebuildPath","vMag","acos","pathEls","pathList","pathEl","pathBundle","appendPath","pathContain","__dirtyPath","strokeContainThreshold","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","_fillGradient","_strokeGradient","ctxLineDash","setLineDash","setScale","setLineDashOffset","shapeCfg","inBundle","needsUpdateRect","rectWithStroke","_rectWithStroke","lineScale","localPos","containStroke","dirtyPath","animateShape","setShape","Sub","defaultShape","thisShape","curve","bbox","min2","max2","mathAbs","hasTypedArray","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","moveTo","lineTo","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","x3","y3","_dashedBezierTo","quadraticCurveTo","_dashedQuadraticTo","arc","startAngle","endAngle","anticlockwise","arcTo","radius","closePath","x0","y0","lineDashSum","appendSize","appendPathData","_expandData","_prevCmd","newData","dash","dashSum","nDash","cubicAt","bezierLen","tmpLen","Number","MAX_VALUE","xi","yi","fromLine","fromCubic","fromQuadratic","fromArc","ux","uy","scaleX","scaleY","isEllipse","isAroundZero","onet","cubicDerivativeAt","cubicRootAt","t1","disc","K","discSqrt","Y1","Y2","mathPow","ONE_THIRD","T","ASqrt","THREE_SQRT","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","d1","d2","interval","Infinity","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","v2Create","end","extremity","PI2","fromPoints","bottom","xDim","yDim","tx","ty","vec2Min","vec2Max","diff","angle","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","x_","windingQuadratic","y_","windingArc","dir","normalizeRadian","containPath","isStroke","windingLine","cubic","quadratic","line","_l","_a","_b","_s","nPoint","mathAtan2","shadowTemp","r0","clockwise","modified","unitX","unitY","polyHelper","smooth","smoothConstraint","smoothSpline","smoothBezier","controlPoints","cp1","cp2","interpolate","isLoop","segs","w2","w3","v2Min","v2Max","v2Scale","v2Distance","v2Add","constraint","prevPoint","nextPoint","cps","point","d0","sum","cp0","roundRectHelper","r1","r2","r3","r4","total","pointAt","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","curveTool","tangentAt","globalCoord","EventDecisionNode","_startPos","_type","_clickable","_popupOpts","eventProto","_createEventShape","_createEVentName","eventNameShape","endPos","_line","attrHeight","_style","strokeColor","boAttrData","_keyValue","keyValue","_displayDataType","_displayEventDecision","_eventClickable","_eventPopupOpts","boAttrProto","_createText","_createDataType","attrNameShape","_dataTypeShape","dataType","_boAttrEventArr","boAttrEventArr","_boAttrEventLen","padding","sourceShape","targetShape","_sourceText","_targetText","_lStartPos","_lEndPos","_rStartPos","_rEndPos","_leftDirection","relationProto","_createLine","_createArrow","_linePoints","_arrowPoints","_arrowShape","_sourceTextPos","_targetTextPos","_textAlign","_srcTextShape","_targetTextShape","vmlCore","comma","imageTransformPrefix","Z2","ZLEVEL_BASE","Z_BASE","initRootElStyle","coordsize","coordorigin","encodeHtmlAttribute","String","rgb2Str","append","getZIndex","setColorAndOpacity","getColorAndAlpha","updateFillNode","zrEl","gradientType","focus","expansion","rectWidth","rectHeight","dimension","stops","cs1","cs2","colorAndAlphaList","colorAndAlpha","color1","color2","opacity1","opacity2","focusposition","updateStrokeNode","dashstyle","updateFillAndStroke","vmlEl","isFill","getElementsByTagName","createNode","pathDataToString","cmdStr","brushVML","vmlRoot","_vmlEl","needTransform","strokeEl","weight","zIndex","removeRectText","onRemove","onAdd","appendRectText","isImage","img","tagName","ow","oh","_imageSrc","_imageWidth","_imageHeight","imageRuntimeStyle","runtimeStyle","oldRuntimeWidth","oldRuntimeHeight","dw","dh","sw","sh","hasCrop","doc","vmlElStyle","hasRotation","transformFilter","imageEl","_imageEl","cropEl","_cropEl","imageELStyle","tmpImage","overflow","cropElStyle","filterStr","textMeasureEl","DEFAULT_STYLE_NORMAL","fontStyleCache","fontStyleCacheCount","MAX_FONT_CACHE_SIZE","fontEl","getFontStyle","fontString","fontStyle","fontFamily","variant","fontVariant","fontWeight","size","fontSize","family","body","ex","createTextNode","offsetWidth","fromTextEl","textPathEl","skewEl","textVmlEl","_textVmlEl","textpathok","to","coords","textVmlElStyle","toFixed","string","proto","urn","win","vmlInited","namespaces","zrvml","initVML","styleSheets","createStyleSheet","addRule","VMLPainter","vmlViewport","_vmlRoot","_vmlViewport","_firstPaint","createMethodNotSupport","zrLog","__alreadyNotVisible","_getWidth","_getHeight","vmlViewportStyle","currentStyle","clientWidth","paddingLeft","paddingRight","clientHeight","paddingTop","paddingBottom","notSupportedMethods"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,SAAAA,OAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,WAAAD,IAEAD,EAAA,WAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,EAAAA,EAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASL,EAAQD,EAASM,GAE/BL,EAAOD,QAAUM,EAAoB,IAKhC,SAASL,EAAQD,EAASM,GE1DhCL,EAAAD,QAAAM,EAAA,GAEAA,EAAA,KFqEM,SAASL,EAAQD,EAASM,GG7DhC,QAAAS,GAAAC,EAAAC,GAKAb,KAAAc,QAAA,EACAd,KAAAe,UAAA,EAKAf,KAAAgB,IAAAC,EAAAC,KAAAN,GACAO,SAAAN,EAAAM,UAAA,SACAC,iBAAAP,EAAAO,mBArBA,GAAAH,GAAAf,EAAA,GACAmB,EAAAnB,EAAA,GACAoB,EAAApB,EAAA,IACAqB,EAAArB,EAAA,IACAsB,EAAAtB,EAAA,IACAuB,EAAAvB,EAAA,IACAwB,EAAAxB,EAAA,IAmBAyB,EAAAhB,EAAAiB,SAKAD,GAAAT,KAAA,WACAlB,KAAA6B,MAAA,GAAAJ,GAAAK,MACA9B,KAAA+B,UAAA/B,KAAA6B,OACA7B,KAAAgB,IAAAgB,IAAAhC,KAAA6B,OACA7B,KAAAiC,WAMAN,EAAAO,OAAA,WACAlC,KAAAgB,IAAAkB,UAoBAP,EAAAQ,MAAA,SAAAC,EAAAvB,GAEAb,KAAAqC,WAAAD,GAGAA,EAAAE,QACAC,EAAA1B,EAAA2B,SAAAD,EACAE,EAAA5B,EAAA2B,SAAAC,EACAC,MAAA,GAIA1C,KAAA2C,KAAAP,GAGApC,KAAA4C,mBAAAR,EAAAvB,EAAA2B,SAAAD,EAAAH,EAAAE,OAAAC,EAGA,IAAAM,GAAA,GAAAvB,GAAAc,EAAAvB,EAMA,OALAb,MAAA6B,MAAAG,IAAAa,EAAAC,YAGA9C,KAAA+C,WAAAF,EAAAhC,GAEAgC,GAQAlB,EAAAU,WAAA,SAAAD,GACA,GAAAA,EAAAY,MAGA,IAAA,GAFAC,GAAAb,EAAAY,MAAAE,OACAC,EAAAf,EAAAY,MACAI,EAAA,EAA2BA,EAAAH,EAAcG,IACzCD,EAAAC,GAAAC,OAAAjB,EACAe,EAAAC,EAAA,GACAD,EAAAC,GAAAE,KAAAH,EAAAC,EAAA,GAGAhB,EAAAkB,MAAAlB,EAAAkB,KAAAN,QACAG,EAAAC,GAAAE,KAAAlB,EAAAkB,KAAAN,MAAA,IAEAhD,KAAAqC,WAAAc,EAAAC,KAaAzB,EAAAgB,KAAA,SAAAP,GAOA,IALApC,KAAAuD,gBAEAvD,KAAAwD,UACAxD,KAAAwD,OAAAC,KAAArB,GAEApC,KAAAwD,OAAAN,OAAA,GAAA,CACA,GAAAQ,GAAA1D,KAAAwD,OAAAG,OAqBA,IAhBA3D,KAAAuD,aAAAG,EAAApB,OAAAI,OAIA1C,KAAAuD,aAAAG,EAAApB,OAAAI,OAAAH,EAAAf,EAAAoC,eAAAF,EAAApB,OAAAC,EACAvC,KAAAuD,aAAAG,EAAApB,OAAAI,QAAuDH,EAAAmB,EAAApB,OAAAC,IAIvDvC,KAAA6D,kBAAAH,EAAA1D,KAAAuD,aAAAG,EAAApB,OAAAI,OAAAH,EAAAmB,EAAApB,OAAAC,EAAAf,EAAAoC,cAAApC,EAAAsC,kBACA9D,KAAAuD,aAAAG,EAAApB,OAAAI,QAAuDH,EAAAmB,EAAApB,OAAAC,IATvDvC,KAAAuD,aAAAG,EAAApB,OAAAI,QAAuDH,EAAAmB,EAAApB,OAAAC,GAevDmB,EAAAV,MAGA,IAAA,GAFAC,GAAAS,EAAAV,MAAAE,OAEAE,EAAA,EAA+BA,EAAAH,EAAcG,IAE7CM,EAAAV,MAAAI,GAAAd,QACAC,EAAAmB,EAAApB,OAAAC,GAAAf,EAAAoC,cAAApC,EAAAsC,oBAAAb,EAAA,GAAA,EAAAG,GACAV,MAAAgB,EAAApB,OAAAI,MAAA,GAGA1C,KAAAwD,OAAAC,KAAAC,EAAAV,MAAAI,MAYAzB,EAAAkC,kBAAA,SAAAzB,EAAA2B,GACA3B,IAEAA,EAAAE,OAAA0B,QAEA,GAAA5B,EAAAE,OAAAI,MACAN,EAAAE,OAAAC,GAAAwB,EAAA,EAEA3B,EAAAE,OAAAC,GAAAwB,EAGA3B,EAAAE,OAAA0B,OAAA,GAGAhE,KAAAiE,qBAAA7B,EAAAkB,KAAAS,GAEA/D,KAAA6D,kBAAAzB,EAAAiB,OAAAU,KAWApC,EAAAsC,qBAAA,SAAA7B,EAAA2B,GACA3B,IACAA,EAAAE,OAAAC,GAAAwB,EAEA/D,KAAAiE,qBAAA7B,EAAAkB,KAAAS,KAUApC,EAAAiB,mBAAA,SAAAR,EAAA2B,GACA,GAAA3B,IACAA,EAAAE,OAAAC,GAAAwB,EACA3B,EAAAY,OACA,IAAA,GAAAI,GAAA,EAA+BA,EAAAhB,EAAAY,MAAAE,OAAyBE,IACxDpD,KAAA4C,mBAAAR,EAAAY,MAAAI,GAAAW,IAYApC,EAAAoB,WAAA,SAAAmB,EAAArD,GAKA,IAHAb,KAAAwD,UACAxD,KAAAwD,OAAAC,KAAAS,GAEAlE,KAAAwD,OAAAN,OAAA,GAAA,CACA,GAAAQ,GAAA1D,KAAAwD,OAAAG,QACAQ,EAAAT,EAAAZ,WAAAsB,kBAAAC,MAYA,MAPArE,KAAAuD,aAAAG,EAAAY,YAAA5B,OAAAD,GACAzC,KAAAuD,aAAAG,EAAAY,YAAA5B,OAAAD,EAAAiB,EAAAY,YAAA7B,EAAA0B,EAAA3C,EAAA+C,oBACAvE,KAAAuD,aAAAG,EAAAY,YAAA5B,OAAAD,EAAAiB,EAAAY,YAAA7B,EAAA0B,EAAA3C,EAAA+C,kBAKAb,EAAAc,UAAAxB,MAAA,CAEA,GAEAH,GACA4B,EAHAtB,EAAAO,EAAAc,UAAAxB,MACAC,EAAAE,EAAAD,MAKArC,GAAA2B,SAAAC,EAAAzC,KAAAuD,aAAAG,EAAAY,YAAA5B,OAAAD,CACA,KAAA,GAAAW,GAAA,EAA+BA,EAAAH,EAAcG,IAU7C,GATAvC,EAAA2B,SAAAD,EAAAY,EAAAC,GAAAd,OAAAC,EACAY,EAAAC,GAAAd,OAAAG,EAAA5B,EAAA2B,SAAAC,EACAI,EAAA,GAAAvB,GAAA6B,EAAAC,GAAAvC,GAGAb,KAAA6B,MAAAG,IAAAa,EAAAC,YACA9C,KAAAwD,OAAAC,KAAAZ,GAGAM,EAAAC,GAAAsB,SAEA,IAAA,GADAC,GAAAxB,EAAAC,GAAAsB,SAAAxB,OACA0B,EAAA,EAAuCA,EAAAD,EAAkBC,IAAA,CACzD,GAAAC,GAAA1B,EAAAC,GAAAsB,SAAAE,GAAAC,SACAC,EAAA3B,EAAAC,GAAAsB,SAAAE,GAAAE,SACAC,EAAA5B,EAAAC,GAAAsB,SAAAE,GAAAG,WACAC,EAAA7B,EAAAC,GAAAsB,SAAAE,GAAAI,UAEAP,GAAA,GAAAlD,GACAsB,EAAAC,WAAAmC,YAAAJ,GACAnB,EAAAZ,WAAAmC,YAAAH,GACAC,EACAC,GAEAhF,KAAA6B,MAAAG,IAAAyC,EAAA3B,gBAcAnB,EAAAuD,aAAA,SAAAC,EAAAC,GAEA,IAAA,GADAlC,GAAAlD,KAAA6B,MAAAwD,aACAjC,EAAA,EAAuBA,EAAAF,EAAYE,IACnCpD,KAAA6B,MAAAyD,QAAAlC,GAAAmC,MAAAJ,GACAnF,KAAA6B,MAAAyD,QAAAlC,GAAAoC,WAAAJ,IAQAzD,EAAA8D,MAAA,WACAzF,KAAAgB,IAAAyE,QACAzF,KAAA6B,MAAA,GAAAJ,GAAAK,MACA9B,KAAAgB,IAAAgB,IAAAhC,KAAA6B,QAOAF,EAAAM,QAAA,SAAAyD,GAmBA,QAAAC,GAAAC,EAAAC,EAAAC,GACA,GAAA,GAAAC,EAAAhF,SAAA,CAGA,GAAAiF,GAAAD,EAAAlE,KACA,IAAAmE,EAAA,CACA,GAAAC,GAAAD,EAAAE,SACAC,EAAAH,EAAAG,MACAC,EAAAL,EAAAM,MAAAN,EAAAM,OAAA,CACAD,IAAAR,CACA,IAAAU,GAAAF,EAAAL,EAAAM,KAIAN,GAAAM,MAAAD,EAEAL,EAAAjF,QAAAsF,EAEAH,EAAA,KAAAJ,EAAAI,EAAA,KAAAK,EAAA,GACAL,EAAA,KAAAH,EAAAG,EAAA,KAAAK,EAAA,GACAH,EAAA,IAAAG,EACAH,EAAA,IAAAG,EACAN,EAAAO,KAAA,YAAAN,EAAA,GAAAA,EAAA,KACAD,EAAAO,KAAA,SAAAJ,EAAA,GAAAA,EAAA,OAzCA,GAAAJ,GAAA/F,IACA,IAAA0F,EAAA,CACA,GAAA,aAAAA,EAAA,CACA,GAAAE,GAAA,EAAA,GACAD,GAAAC,EAAA5F,KAAAgB,IAAAwF,WAAA,EAAAxG,KAAAgB,IAAAyF,YAAA,GAEA,GAAA,WAAAf,EAAA,CACA,GAAAE,GAAA,GACAD,GAAAC,EAAA5F,KAAAgB,IAAAwF,WAAA,EAAAxG,KAAAgB,IAAAyF,YAAA,QAGAV,GAAA/E,IAAA0F,GAAA,aAAA,SAAAC,GACAjF,EAAAkF,KAAAD,EAAAE,MACA,IAAAjB,GAAAe,EAAAG,WAAA,EAAA,IAAA,EAAA,GACAnB,GAAAC,EAAAe,EAAAI,QAAAJ,EAAAK,YAoCArF,EAAAI,UAAA,WAMA,QAAAkF,GAAAN,GAWA,QAAAO,GAAAP,GACA,GAAA5C,GAAAgC,EAAAlE,MAAAuC,kBAAAL,MAAAgC,EAAAjF,QACAuD,EAAA0B,EAAAlE,MAAAuC,kBAAAC,OAAA0B,EAAAjF,QACAqG,EAAApB,EAAAlE,MAAAuC,kBAAA7B,EAAAwD,EAAAjF,QACAsG,EAAArB,EAAAlE,MAAAuC,kBAAA3B,EAAAsD,EAAAjF,QACAuG,GAAA,IAAAtD,EAAAoD,GAAA,IAAA9C,EAAA+C,IACAE,GAAAvB,EAAA/E,IAAAwF,WAAAW,EAAA,GAAApB,EAAA/E,IAAAyF,YAAAW,EAAA,IACAG,GAAAZ,EAAAE,MAAAW,QAAAC,GAAA1B,EAAA,QACA2B,GAAAf,EAAAE,MAAAc,QAAAC,GAAA7B,EAAA,OACA8B,GAAA,GAAAC,EAAA,EACAD,EAAA,GAAAE,EAAA,EACAF,EAAA,GAAAP,EAAA,IAAAO,EAAA,GAAAP,EAAA,IAAAO,EAAA,GAAAR,EAAA,IAAAQ,EAAA,GAAAR,EAAA,IAGAtB,EAAAlE,MAAA0E,KAAA,WAAAsB,GASA,QAAAG,GAAArB,GACAZ,EAAA/E,IAAAiH,IAAA,YAAAC,GACAnC,EAAA/E,IAAAiH,IAAA,UAAAE,GACApC,EAAA/E,IAAAiH,IAAA,YAAAE,GApCA,GAAAV,GAAAd,EAAAE,MAAAW,QACAI,EAAAjB,EAAAE,MAAAc,QACAO,EAAA,SAAAvB,GACAO,EAAAP,IAEAkB,EAAA9B,EAAAlE,MAAAqE,SACA4B,EAAA/B,EAAAlE,MAAAqE,SAAA,GACA6B,EAAAhC,EAAAlE,MAAAqE,SAAA,EAqBAH,GAAA/E,IAAA0F,GAAA,YAAAwB,EACA,IAAAC,GAAA,SAAAxB,GACAqB,EAAArB,GASAZ,GAAA/E,IAAA0F,GAAA,UAAAyB,GACApC,EAAA/E,IAAA0F,GAAA,YAAAyB,GA9CA,GAAApC,GAAA/F,IACA+F,GAAA/E,IAAA0F,GAAA,YAAA,SAAAC,GACAM,EAAAN,GACAA,EAAAyB,cAAA,KAmDAzG,EAAA0G,KAAA,SAAAC,GASA,QAAArB,GAAAN,GAgBA,QAAAO,GAAAP,GACA,GAAAY,IAAAZ,EAAAE,MAAAW,QAAAC,GAAA1B,EAAA,QACA2B,GAAAf,EAAAE,MAAAc,QAAAC,GAAA7B,EAAA,OACA,IAAAuC,EAAAjF,QAAAiF,EAAAjF,iBAAAkF,WAAA,CAEA,GAAAC,IACAzE,MAAAuE,EAAAG,MAAA1E,MACAM,OAAAiE,EAAAG,MAAApE,OACA6B,SAAAoC,EAAApC,SACAwC,QAAAJ,EAAAG,MAAAlG,EAAA+F,EAAAG,MAAAhG,GACAkG,cAAAb,EAAAC,GACAa,MAAArB,EACAsB,MAAAnB,GAEAoB,EAAAR,EAAAjF,MACAyF,GAAAC,OAAAP,EAAAF,OAKA,IAHAT,EAAA,GAAAC,EAAA,EACAD,EAAA,GAAAE,EAAA,EACAO,EAAA/B,KAAA,WAAAsB,GACAS,EAAAU,MAAA,CACA,GAAAC,IAAApB,EAAA,GAAAS,EAAAlE,kBAAAL,OAAAuE,EAAAU,MAAA5E,kBAAAL,MAAA,GAAA8D,EAAA,GAAAS,EAAAU,MAAA5E,kBAAAC,OAAA,EACAiE,GAAAU,MAAAzC,KAAA,WAAA0C,GAIAC,kBAAAC,kBAAAb,GAQA,QAAAN,GAAArB,GAQA,GAPAZ,EAAA/E,IAAAiH,IAAA,YAAAC,GACAnC,EAAA/E,IAAAiH,IAAA,UAAAE,GACApC,EAAA/E,IAAAiH,IAAA,YAAAE,GAEAG,EAAAhG,QACAyD,EAAAqD,WAAA,QAA6Cd,KAAAA,IAE7CvC,EAAAsD,kBAAA,CACA,GAAAC,GAAAvD,EAAAsD,kBAAAE,QACAC,GAAAC,QAAAH,EAAAhB,QACAvC,EAAAqD,WAAA,QAAApJ,KAAAqJ,oBA5DA,GAQAK,GAAAC,EARAlC,EAAAd,EAAAE,MAAAW,QACAI,EAAAjB,EAAAE,MAAAc,QACAO,EAAA,SAAAvB,GACAO,EAAAP,IAEAkB,EAAAS,EAAApC,SACA4B,EAAAQ,EAAApC,SAAA,GACA6B,EAAAO,EAAApC,SAAA,EAEA,IAAAoC,EAAAU,MAAA,CACAV,EAAAU,MAAA9C,QACAwD,GAAApB,EAAAU,MAAA9C,SAAA,GACAyD,EAAArB,EAAAU,MAAA9C,SAAA,GAgCAH,EAAA/E,IAAA0F,GAAA,YAAAwB,EACA,IAAAC,GAAA,SAAAxB,GACAqB,EAAArB,GAoBAZ,GAAA/E,IAAA0F,GAAA,UAAAyB,GACApC,EAAA/E,IAAA0F,GAAA,YAAAyB,GA5EA,GAAApC,GAAA/F,IACAsI,GAAA5B,GAAA,YAAA,SAAAC,GACA,GAAA3G,KAAA4J,cAGA3C,EAAAN,GACAA,EAAAyB,cAAA,KA4EA,IAAAyB,GAAA,GAAAC,MAAA,EACAC,KACAC,EAAA,wBACAC,GAIAC,QAAA,QACAC,cACAC,QAAA,SAQAH,GAAA/I,KAAA,SAAAN,EAAAC,GACA,IAAAD,EACA,KAAA,IAAAyJ,OAAA,kCAGAxJ,GAAAA,MAEAQ,EAAAiJ,SAAAzJ,GAEA6E,KAAA,OACA6E,cAAA,EACAnJ,iBAAA,EACAoJ,gBAAA,IAIA,IAAAP,GAAA,GAAAtJ,GAAAC,EAAAC,EAQA,OAPAoJ,GAAA/I,OAEA+I,EAAA5J,GAAA,MAAAwJ,IACAE,EAAAE,EAAA5J,IAAA4J,EAEArJ,EAAA6J,cAAA7J,EAAA6J,aAAAT,EAAAC,EAAA5J,IAEA4J,GAQAA,EAAAS,iBAAA,SAAA9J,GACA,GAAA+J,GAAA/J,EAAAgK,aAAAZ,EACA,OAAAD,GAAAY,IAOAV,EAAAY,QAAA,SAAAC,GACA,GAAAC,EACAC,QAAAC,MAAAH,GACAC,EAAAd,EAAAS,iBAAAI,GAEA,gBAAAA,KACAC,EAAAhB,EAAAe,IAEAC,YAAAd,KAAAc,EAAAG,cACAH,EAAAF,WAIAhL,EAAAD,QAAAqK,GHkFM,SAASpK,EAAQD,EAASM,GInkBhC,QAAAiL,GAAA9K,SACA0J,GAAA1J,GA1EA,GAAA+K,GAAAlL,EAAA,GACAmL,EAAAnL,EAAA,GACA8K,EAAA9K,EAAA,GAEAoL,EAAApL,EAAA,GACAqL,EAAArL,EAAA,IACAsL,EAAAtL,EAAA,IACAuL,EAAAvL,EAAA,IAEAwL,GAAAL,EAAAM,gBAEAC,GACAC,OAAA3L,EAAA,KAGA6J,KAEAK,IAKAA,GAAAF,QAAA,QAYAE,EAAAlJ,KAAA,SAAAN,EAAAC,GACA,GAAAI,GAAA,GAAA6K,GAAAV,IAAAxK,EAAAC,EAEA,OADAkJ,GAAA9I,EAAAZ,IAAAY,EACAA,GAOAmJ,EAAAS,QAAA,SAAA5J,GACA,GAAAA,EACAA,EAAA4J,cAEA,CACA,IAAA,GAAAF,KAAAZ,GACAA,EAAAgC,eAAApB,IACAZ,EAAAY,GAAAE,SAGAd,MAGA,MAAAK,IAQAA,EAAA4B,YAAA,SAAA3L,GACA,MAAA0J,GAAA1J,IAGA+J,EAAA6B,gBAAA,SAAA1G,EAAA2G,GACAN,EAAArG,GAAA2G,EAqBA,IAAAJ,GAAA,SAAAzL,EAAAO,EAAAC,GAEAA,EAAAA,MAKAb,KAAAY,IAAAA,EAKAZ,KAAAK,GAAAA,CAEA,IAAA8L,GAAAnM,KACAoM,EAAA,GAAAb,GAEAc,EAAAxL,EAAAM,QAEA,IAAAuK,EAAA,CACA,IAAAE,EAAAU,IACA,KAAA,IAAAjC,OAAA,uDAEAgC,GAAA,UAEAA,IAAAT,EAAAS,KACAA,EAAA,SAEA,IAAAE,GAAA,GAAAX,GAAAS,GAAAzL,EAAAwL,EAAAvL,EAEAb,MAAAoM,QAAAA,EACApM,KAAAuM,QAAAA,CAEA,IAAAC,GAAAnB,EAAA/C,KAAA,KAAA,GAAAmD,GAAAc,EAAAE,kBACAzM,MAAA0M,QAAA,GAAApB,GAAAc,EAAAG,EAAAC,EAAAD,EAAA7M,MAKAM,KAAA2M,UAAA,GAAAnB,IACAoB,OACAC,OAAA7B,EAAA8B,KAAA9M,KAAA+M,MAAA/M,SAGAA,KAAA2M,UAAAK,QAMAhN,KAAAiN,aAIA,IAAAC,GAAAd,EAAAe,WACAC,EAAAhB,EAAAiB,QAEAjB,GAAAe,WAAA,SAAAG,GACA,GAAAC,GAAAnB,EAAAoB,IAAAF,EAEAJ,GAAA3M,KAAA6L,EAAAkB,GAEAC,GAAAA,EAAAE,iBAAAtB,IAGAC,EAAAiB,SAAA,SAAAE,GACAH,EAAA7M,KAAA6L,EAAAmB,GAEAA,EAAAG,YAAAvB,IAIAL,GAAAlK,WAEA+L,YAAA7B,EAKA8B,MAAA,WACA,MAAA5N,MAAAK,IAOA2B,IAAA,SAAAuL,GACAvN,KAAAoM,QAAAyB,QAAAN,GACAvN,KAAAiN,eAAA,GAOAa,OAAA,SAAAP,GACAvN,KAAAoM,QAAA2B,QAAAR,GACAvN,KAAAiN,eAAA,GAWAe,YAAA,SAAAC,EAAAC,GACAlO,KAAAuM,QAAAyB,YAAAC,EAAAC,GACAlO,KAAAiN,eAAA,GAMAkB,mBAAA,WAGAnO,KAAAiN,eAAA,EACAjN,KAAAuM,QAAA6B,UAIApO,KAAAiN,eAAA,GAMAmB,QAAA,WACApO,KAAAiN,eAAA,GAMAF,MAAA,WACA/M,KAAAiN,eACAjN,KAAAmO,qBAEAnO,KAAAqO,oBACArO,KAAAsO,2BASAC,SAAA,SAAAhB,EAAAnI,GACApF,KAAAuM,QAAAgC,WACAvO,KAAAuM,QAAAgC,SAAAhB,EAAAnI,GACApF,KAAAwO,iBAQAC,YAAA,SAAAlB,GACAvN,KAAAuM,QAAAkC,cACAzO,KAAAuM,QAAAkC,YAAAlB,GACAvN,KAAAwO,iBAQAE,WAAA,WACA1O,KAAAuM,QAAAmC,aACA1O,KAAAuM,QAAAmC,aACA1O,KAAAwO,iBAOAA,aAAA,WACAxO,KAAAqO,oBAAA,GAMAC,wBAAA,WACAtO,KAAAqO,oBAAA,EACArO,KAAAuM,QAAAiC,cAAAxO,KAAAuM,QAAAiC,gBAUAtM,OAAA,SAAArB,GACAA,EAAAA,MACAb,KAAAuM,QAAArK,OAAArB,EAAAkD,MAAAlD,EAAAwD,QACArE,KAAA0M,QAAAxK,UAMAyM,eAAA,WACA3O,KAAA2M,UAAAlH,SAMAe,SAAA,WACA,MAAAxG,MAAAuM,QAAA/F,YAMAC,UAAA,WACA,MAAAzG,MAAAuM,QAAA9F,aAsBAmI,YAAA,SAAAjI,EAAAkI,GACA,MAAA7O,MAAAuM,QAAAqC,YAAAjI,EAAAkI,IAOAC,eAAA,SAAAC,GACA/O,KAAA0M,QAAAoC,eAAAC,IAUArI,GAAA,SAAAsI,EAAAC,EAAAC,GACAlP,KAAA0M,QAAAhG,GAAAsI,EAAAC,EAAAC,IAQAjH,IAAA,SAAA+G,EAAAC,GACAjP,KAAA0M,QAAAzE,IAAA+G,EAAAC,IASAE,QAAA,SAAAH,EAAAnI,GACA7G,KAAA0M,QAAAyC,QAAAH,EAAAnI,IAOApB,MAAA,WACAzF,KAAAoM,QAAA2B,UACA/N,KAAAuM,QAAA9G,SAMAoF,QAAA,WACA7K,KAAA2M,UAAA/F,OAEA5G,KAAAyF,QACAzF,KAAAoM,QAAAvB,UACA7K,KAAAuM,QAAA1B,UACA7K,KAAA0M,QAAA7B,UAEA7K,KAAA2M,UACA3M,KAAAoM,QACApM,KAAAuM,QACAvM,KAAA0M,QAAA,KAEAvB,EAAAnL,KAAAK,MAIAR,EAAAD,QAAAwK,GJ+pBM,SAASvK,EAAQD,GK9jCvB,GAAAwP,GAAA,IAEAvP,GAAAD,QAAA,WACA,MAAAwP,OL8kCM,SAASvP,EAAQD,GM3jCvB,QAAAyP,GAAAC,GACA,GAAAC,MACAC,KAeAC,EAAAH,EAAAI,MAAA,qBAGAC,EAAAL,EAAAI,MAAA,mBAEAJ,EAAAI,MAAA,6BACAE,EAAAN,EAAAI,MAAA,kBAEAG,EAAA,kBAAAC,KAAAR,EAqDA,OA7BAG,KACAD,EAAAC,SAAA,EACAD,EAAAtF,QAAAuF,EAAA,IAKAE,IACAH,EAAAG,IAAA,EACAH,EAAAtF,QAAAyF,EAAA,IAGAC,IACAJ,EAAAI,MAAA,EACAJ,EAAAtF,QAAA0F,EAAA,IAKAC,IACAL,EAAAK,QAAA,IAUAL,QAAAA,EACAD,GAAAA,EACAjH,MAAA,EAGAqD,kBAAAoE,SAAAC,cAAA,UAAAC,WAKAC,qBAAA,gBAAAC,UAAAX,EAAAG,KAAAH,EAAAI,KAEAQ,uBAAA,iBAAAD,UAKAX,EAAAI,MAAAJ,EAAAG,IAAAH,EAAAtF,SAAA,KArHA,GAAAmB,KAGAA,GAFA,mBAAAgF,YAGAb,WACAD,MACAjH,MAAA,EAEAqD,iBAAA,GAIA0D,EAAAgB,UAAAC,WAGAzQ,EAAAD,QAAAyL,GNusCM,SAASxL,EAAQD,GOvqCvB,QAAA2Q,GAAAC,GACA,GAAA,MAAAA,GAAA,gBAAAA,GACA,MAAAA,EAGA,IAAAC,GAAAD,EACAE,EAAAC,EAAApQ,KAAAiQ,EAEA,IAAA,mBAAAE,EAAA,CACAD,IACA,KAAA,GAAArN,GAAA,EAAAwN,EAAAJ,EAAAtN,OAAgDE,EAAAwN,EAASxN,IACzDqN,EAAArN,GAAAmN,EAAAC,EAAApN,QAGA,IAAAyN,EAAAH,GACAD,EAAAD,EAAA7C,YAAAmD,KAAAN,OAEA,KAAAO,EAAAL,KAAAM,EAAAR,KAAAvF,EAAAuF,GAAA,CACAC,IACA,KAAA,GAAA9F,KAAA6F,GACAA,EAAAzE,eAAApB,KACA8F,EAAA9F,GAAA4F,EAAAC,EAAA7F,KAKA,MAAA8F,GASA,QAAAQ,GAAAjL,EAAAwK,EAAAU,GAGA,IAAAC,EAAAX,KAAAW,EAAAnL,GACA,MAAAkL,GAAAX,EAAAC,GAAAxK,CAGA,KAAA,GAAA2E,KAAA6F,GACA,GAAAA,EAAAzE,eAAApB,GAAA,CACA,GAAAyG,GAAApL,EAAA2E,GACA0G,EAAAb,EAAA7F,IAEAwG,EAAAE,KACAF,EAAAC,IACAE,EAAAD,IACAC,EAAAF,IACAnG,EAAAoG,IACApG,EAAAmG,IACAG,EAAAF,IACAE,EAAAH,IACAJ,EAAAK,IACAL,EAAAI,IAKAF,GAAAvG,IAAA3E,KAGAA,EAAA2E,GAAA4F,EAAAC,EAAA7F,IAAA,IALAsG,EAAAG,EAAAC,EAAAH,GAUA,MAAAlL,GAQA,QAAAwL,GAAAC,EAAAP,GAEA,IAAA,GADAT,GAAAgB,EAAA,GACArO,EAAA,EAAAwN,EAAAa,EAAAvO,OAAsDE,EAAAwN,EAASxN,IAC/DqN,EAAAQ,EAAAR,EAAAgB,EAAArO,GAAA8N,EAEA,OAAAT,GAQA,QAAAiB,GAAA1L,EAAAwK,GACA,IAAA,GAAA7F,KAAA6F,GACAA,EAAAzE,eAAApB,KACA3E,EAAA2E,GAAA6F,EAAA7F,GAGA,OAAA3E,GASA,QAAAsE,GAAAtE,EAAAwK,EAAAmB,GACA,IAAA,GAAAhH,KAAA6F,GACAA,EAAAzE,eAAApB,KACAgH,EAAA,MAAAnB,EAAA7F,GAAA,MAAA3E,EAAA2E,MAEA3E,EAAA2E,GAAA6F,EAAA7F,GAGA,OAAA3E,GAGA,QAAA4L,KACA,MAAA7B,UAAAC,cAAA,UAIA,QAAAC,KAMA,MALA4B,KAGAA,EAAAxQ,EAAAuQ,eAAA3B,WAAA,OAEA4B,EAOA,QAAApI,GAAAqI,EAAAC,GACA,GAAAD,EAAA,CACA,GAAAA,EAAArI,QACA,MAAAqI,GAAArI,QAAAsI,EAEA,KAAA,GAAA3O,GAAA,EAAAwN,EAAAkB,EAAA5O,OAA+CE,EAAAwN,EAASxN,IACxD,GAAA0O,EAAA1O,KAAA2O,EACA,MAAA3O,GAIA,SAUA,QAAA4O,GAAAC,EAAAC,GAEA,QAAAC,MADA,GAAAC,GAAAH,EAAArQ,SAEAuQ,GAAAvQ,UAAAsQ,EAAAtQ,UACAqQ,EAAArQ,UAAA,GAAAuQ,EAEA,KAAA,GAAAE,KAAAD,GACAH,EAAArQ,UAAAyQ,GAAAD,EAAAC,EAEAJ,GAAArQ,UAAA+L,YAAAsE,EACAA,EAAAK,WAAAJ,EASA,QAAAK,GAAAvM,EAAAwK,EAAAmB,GACA3L,EAAA,aAAAA,GAAAA,EAAApE,UAAAoE,EACAwK,EAAA,aAAAA,GAAAA,EAAA5O,UAAA4O,EAEAlG,EAAAtE,EAAAwK,EAAAmB,GAMA,QAAAa,GAAAC,GACA,GAAAA,EAGA,MAAA,gBAAAA,IAGA,gBAAAA,GAAAvP,OAUA,QAAAwP,GAAAC,EAAAC,EAAA1D,GACA,GAAAyD,GAAAC,EAGA,GAAAD,EAAAE,SAAAF,EAAAE,UAAAC,EACAH,EAAAE,QAAAD,EAAA1D,OAEA,IAAAyD,EAAAzP,UAAAyP,EAAAzP,OACA,IAAA,GAAAE,GAAA,EAAAwN,EAAA+B,EAAAzP,OAA6CE,EAAAwN,EAASxN,IACtDwP,EAAArS,KAAA2O,EAAAyD,EAAAvP,GAAAA,EAAAuP,OAIA,KAAA,GAAAhI,KAAAgI,GACAA,EAAA5G,eAAApB,IACAiI,EAAArS,KAAA2O,EAAAyD,EAAAhI,GAAAA,EAAAgI,GAcA,QAAAI,GAAAJ,EAAAC,EAAA1D,GACA,GAAAyD,GAAAC,EAAA,CAGA,GAAAD,EAAAI,KAAAJ,EAAAI,MAAAC,EACA,MAAAL,GAAAI,IAAAH,EAAA1D,EAIA,KAAA,GADAuB,MACArN,EAAA,EAAAwN,EAAA+B,EAAAzP,OAA6CE,EAAAwN,EAASxN,IACtDqN,EAAAhN,KAAAmP,EAAArS,KAAA2O,EAAAyD,EAAAvP,GAAAA,EAAAuP,GAEA,OAAAlC,IAYA,QAAAwC,GAAAN,EAAAC,EAAAM,EAAAhE,GACA,GAAAyD,GAAAC,EAAA,CAGA,GAAAD,EAAAM,QAAAN,EAAAM,SAAAE,EACA,MAAAR,GAAAM,OAAAL,EAAAM,EAAAhE,EAGA,KAAA,GAAA9L,GAAA,EAAAwN,EAAA+B,EAAAzP,OAA6CE,EAAAwN,EAASxN,IACtD8P,EAAAN,EAAArS,KAAA2O,EAAAgE,EAAAP,EAAAvP,GAAAA,EAAAuP,EAEA,OAAAO,IAYA,QAAAE,GAAAT,EAAAC,EAAA1D,GACA,GAAAyD,GAAAC,EAAA,CAGA,GAAAD,EAAAS,QAAAT,EAAAS,SAAAC,EACA,MAAAV,GAAAS,OAAAR,EAAA1D,EAIA,KAAA,GADAuB,MACArN,EAAA,EAAAwN,EAAA+B,EAAAzP,OAA6CE,EAAAwN,EAASxN,IACtDwP,EAAArS,KAAA2O,EAAAyD,EAAAvP,GAAAA,EAAAuP,IACAlC,EAAAhN,KAAAkP,EAAAvP,GAGA,OAAAqN,IAYA,QAAA6C,GAAAX,EAAAC,EAAA1D,GACA,GAAAyD,GAAAC,EAGA,IAAA,GAAAxP,GAAA,EAAAwN,EAAA+B,EAAAzP,OAAyCE,EAAAwN,EAASxN,IAClD,GAAAwP,EAAArS,KAAA2O,EAAAyD,EAAAvP,GAAAA,EAAAuP,GACA,MAAAA,GAAAvP,GAWA,QAAA0J,GAAAyG,EAAArE,GACA,GAAAsE,GAAAC,EAAAlT,KAAAmT,UAAA,EACA,OAAA,YACA,MAAAH,GAAAI,MAAAzE,EAAAsE,EAAAI,OAAAH,EAAAlT,KAAAmT,cASA,QAAAG,GAAAN,GACA,GAAAC,GAAAC,EAAAlT,KAAAmT,UAAA,EACA,OAAA,YACA,MAAAH,GAAAI,MAAA3T,KAAAwT,EAAAI,OAAAH,EAAAlT,KAAAmT,cASA,QAAApC,GAAAS,GACA,MAAA,mBAAApB,EAAApQ,KAAAwR,GAQA,QAAA+B,GAAA/B,GACA,MAAA,kBAAAA,GAQA,QAAAgC,GAAAhC,GACA,MAAA,oBAAApB,EAAApQ,KAAAwR,GAQA,QAAAZ,GAAAY,GAGA,GAAArM,SAAAqM,EACA,OAAA,aAAArM,KAAAqM,GAAA,UAAArM,EAQA,QAAA6L,GAAAQ,GACA,QAAAhB,EAAAJ,EAAApQ,KAAAwR,IAQA,QAAA9G,GAAA8G,GACA,MAAA,gBAAAA,IACA,gBAAAA,GAAAiC,UACA,gBAAAjC,GAAAkC,cAQA,QAAAC,GAAAnC,GACA,MAAAA,KAAAA,EAQA,QAAAoC,GAAAC,GACA,IAAA,GAAAhR,GAAA,EAAAwN,EAAA8C,UAAAxQ,OAA+CE,EAAAwN,EAASxN,IACxD,GAAA,MAAAsQ,UAAAtQ,GACA,MAAAsQ,WAAAtQ,GAYA,QAAAiR,KACA,MAAAC,UAAA/T,KAAAoT,MAAAF,EAAAC,WAQA,QAAAa,GAAAC,EAAAC,GACA,IAAAD,EACA,KAAA,IAAAnK,OAAAoK,GAQA,QAAAC,GAAA/B,GACAA,EAAAgC,IAAA,EAGA,QAAA3D,GAAA2B,GACA,MAAAA,GAAAgC,GApfA,GAyKA9C,GAzKAd,GACA6D,oBAAA,EACAC,kBAAA,EACAC,gBAAA,EACAC,iBAAA,EACAC,0BAAA,EACAC,yBAAA,EAEAC,iBAAA,EACAC,kBAAA,GAGAtE,GACAuE,qBAAA,EACAC,sBAAA,EACAC,6BAAA,EACAC,sBAAA,EACAC,uBAAA,EACAC,sBAAA,EACAC,uBAAA,EACAC,wBAAA,EACAC,wBAAA,GAGAjF,EAAAkF,OAAAjU,UAAAkU,SAEAC,EAAAC,MAAApU,UACAkR,EAAAiD,EAAAlD,QACAQ,EAAA0C,EAAA3C,OACAK,EAAAsC,EAAA1B,MACArB,EAAA+C,EAAAhD,IACAI,EAAA4C,EAAA9C,OA4cA0B,EAAA,mBAYAtT,GACA2Q,SAAAA,EACAO,MAAAA,EACAhC,MAAAA,EACAU,MAAAA,EACAO,SAAAA,EACAE,OAAAA,EACApH,SAAAA,EACA2F,WAAAA,EACA2B,aAAAA,EACAnI,QAAAA,EACA4K,MAAAA,EACAf,KAAAA,EACAd,YAAAA,EACAE,KAAAA,EACAK,IAAAA,EACAE,OAAAA,EACAG,OAAAA,EACAtG,KAAAA,EACA+G,MAAAA,EACAvC,QAAAA,EACAyC,SAAAA,EACA5C,SAAAA,EACA2C,WAAAA,EACAvC,gBAAAA,EACAtG,MAAAA,EACAiJ,MAAAA,EACAC,SAAAA,EACAI,OAAAA,EACAG,eAAAA,EACAuB,KAAA,aAEApW,GAAAD,QAAAyB,GPsuCM,SAASxB,EAAQD,EAASM,GQnwDhC,YAeA,SAAAgW,GAAAC,EAAAnQ,EAAAa,GACA,OACAnB,KAAAyQ,EACAtP,MAAAA,EACAb,OAAAA,EACAoC,cAAA,EACArB,QAAAF,EAAAuP,IACApP,QAAAH,EAAAwP,IACAC,aAAAzP,EAAAyP,aACAC,OAAA1P,EAAA0P,OACAC,OAAA3P,EAAA2P,OACAC,WAAA5P,EAAA4P,WACA3P,WAAAD,EAAA6P,QACAC,UAAA9P,EAAA8P,WAIA,QAAAC,MAmPA,QAAAC,GAAAC,EAAAvU,EAAAE,GACA,GAAAqU,EAAAA,EAAAC,UAAA,cAAA,WAAAxU,EAAAE,GAAA,CAEA,IADA,GAAA8K,GAAAuJ,EACAvJ,GAAA,CAEA,GAAAA,EAAAyJ,QAAAzJ,EAAA0J,WAAA1J,EAAA0J,SAAAC,QAAA3U,EAAAE,GACA,OAAA,CAEA8K,GAAAA,EAAAlK,OAEA,OAAA,EAGA,OAAA,EAtRA,GAAAhC,GAAAnB,EAAA,GACAiX,EAAAjX,EAAA,GAEAkX,EAAAlX,EAAA,EAoBA0W,GAAAhV,UAAAiJ,QAAA,YAEA,IAAAwM,IACA,QAAA,WAAA,aAAA,WACA,UAAA,YAAA,YAAA,eAWA/L,EAAA,SAAAc,EAAAG,EAAA+K,EAAAC,GACAH,EAAA7W,KAAAP,MAEAA,KAAAoM,QAAAA,EAEApM,KAAAuM,QAAAA,EAEAvM,KAAAuX,YAAAA,EAEAD,EAAAA,GAAA,GAAAV,GAKA5W,KAAAsX,MAAAA,EAGAA,EAAA5K,QAAA1M,KAMAA,KAAAwX,SAMAxX,KAAAyX,iBAMAzX,KAAA0X,OAMA1X,KAAA2X,OAGAR,EAAA5W,KAAAP,MAEAqB,EAAAqR,KAAA2E,EAAA,SAAA9R,GACA+R,EAAA5Q,IAAA4Q,EAAA5Q,GAAAnB,EAAAvF,KAAAuF,GAAAvF,OACSA,MAGTsL,GAAA1J,WAEA+L,YAAArC,EAEAsM,UAAA,SAAA/Q,GACA,GAAAtE,GAAAsE,EAAAuP,IACA3T,EAAAoE,EAAAwP,IAEAwB,EAAA7X,KAAA8X,UAAAvV,EAAAE,EAAA,MACAsV,EAAA/X,KAAAwX,SACAF,EAAAtX,KAAAsX,KAEAtX,MAAAwX,SAAAK,EAEAP,EAAAU,WAAAV,EAAAU,UAAAH,EAAAA,EAAAI,OAAA,WAGAF,GAAAF,IAAAE,GAAAA,EAAAG,MACAlY,KAAAmY,kBAAAJ,EAAA,WAAAlR,GAIA7G,KAAAmY,kBAAAN,EAAA,YAAAhR,GAGAgR,GAAAA,IAAAE,GACA/X,KAAAmY,kBAAAN,EAAA,YAAAhR,IAIAuR,SAAA,SAAAvR,GACA7G,KAAAmY,kBAAAnY,KAAAwX,SAAA,WAAA3Q,EAOA,IACAwR,GADAC,EAAAzR,EAAA0R,WAAA1R,EAAA2R,aAEA,GACAF,GAAAA,GAAAA,EAAAG,iBAEAH,GAAA,GAAAA,EAAAtE,YACAqE,EAAAC,IAAAtY,KAAAuX,eAGAc,GAAArY,KAAAmP,QAAA,aAAoDtI,MAAAA,KAMpD3E,OAAA,SAAA2E,GACA7G,KAAAwX,SAAA,MAQAkB,SAAA,SAAA1J,EAAA2J,GACA,GAAAjM,GAAA1M,KAAAgP,EACAtC,IAAAA,EAAAnM,KAAAP,KAAA2Y,IAMA9N,QAAA,WAEA7K,KAAAsX,MAAAzM,UAEA7K,KAAAoM,QACApM,KAAAsX,MACAtX,KAAAuM,QAAA,MAOAuC,eAAA,SAAAC,GACA,GAAAuI,GAAAtX,KAAAsX,KACAA,GAAAU,WAAAV,EAAAU,UAAAjJ,IAWAoJ,kBAAA,SAAAS,EAAA5J,EAAAnI,GAMA,IALA,GAAAoI,GAAA,KAAAD,EACA6J,EAAA3C,EAAAlH,EAAA4J,EAAA/R,GAEA0G,EAAAqL,EAEArL,IACAA,EAAA0B,KACA4J,EAAAzQ,aAAAmF,EAAA0B,GAAA1O,KAAAgN,EAAAsL,IAEAtL,EAAA4B,QAAAH,EAAA6J,GAEAtL,EAAAA,EAAAlK,QAEAwV,EAAAzQ,gBAKAyQ,EAAAzQ,eAEApI,KAAAmP,QAAAH,EAAA6J,GAGA7Y,KAAAuM,SAAAvM,KAAAuM,QAAAuM,eAAA,SAAAC,GACA,kBAAAA,GAAA9J,IACA8J,EAAA9J,GAAA1O,KAAAwY,EAAAF,GAEAE,EAAA5J,SACA4J,EAAA5J,QAAAH,EAAA6J,OAaAf,UAAA,SAAAvV,EAAAE,EAAAuW,GAEA,IAAA,GADAC,GAAAjZ,KAAAoM,QAAA8M,iBACA9V,EAAA6V,EAAA/V,OAAA,EAAyCE,GAAA,EAASA,IAClD,IAAA6V,EAAA7V,GAAA4T,QACAiC,EAAA7V,KAAA4V,IAEAC,EAAA7V,GAAA+V,QACAtC,EAAAoC,EAAA7V,GAAAb,EAAAE,GACA,MAAAwW,GAAA7V,KAOA/B,EAAAqR,MAAA,QAAA,YAAA,UAAA,aAAA,WAAA,eAAA,SAAAnN,GACA+F,EAAA1J,UAAA2D,GAAA,SAAAsB,GAEA,GAAAgR,GAAA7X,KAAA8X,UAAAjR,EAAAuP,IAAAvP,EAAAwP,IAAA,KAEA,IAAA,cAAA9Q,EACAvF,KAAAoZ,QAAAvB,EAEA7X,KAAAqZ,MAAAxB,MAEA,IAAA,YAAAtS,EACAvF,KAAAqZ,MAAAxB,MAEA,IAAA,UAAAtS,GACAvF,KAAAoZ,UAAApZ,KAAAqZ,MACA,MAIArZ,MAAAmY,kBAAAN,EAAAtS,EAAAsB,MAoBAxF,EAAAkR,MAAAjH,EAAA8L,GACA/V,EAAAkR,MAAAjH,EAAA6L,GAEAtX,EAAAD,QAAA0L,GR0wDM,SAASzL,EAAQD,GS7iEvB,QAAAuX,KAEAnX,KAAA0G,GAAA,YAAA1G,KAAAsZ,WAAAtZ,MACAA,KAAA0G,GAAA,YAAA1G,KAAAuZ,MAAAvZ,MACAA,KAAA0G,GAAA,UAAA1G,KAAAwZ,SAAAxZ,MACAA,KAAA0G,GAAA,YAAA1G,KAAAwZ,SAAAxZ,MAQAmX,EAAAvV,WAEA+L,YAAAwJ,EAEAmC,WAAA,SAAA3S,GACA,GAAA8S,GAAA9S,EAAAX,MACAyT,IAAAA,EAAAC,YACA1Z,KAAA2Z,gBAAAF,EACAA,EAAAG,UAAA,EACA5Z,KAAA6Z,GAAAlT,EAAAI,QACA/G,KAAA8Z,GAAAnT,EAAAK,QAEAhH,KAAAmY,kBAAAsB,EAAA,YAAA9S,EAAAE,SAIA0S,MAAA,SAAA5S,GACA,GAAA8S,GAAAzZ,KAAA2Z,eACA,IAAAF,EAAA,CAEA,GAAAlX,GAAAoE,EAAAI,QACAtE,EAAAkE,EAAAK,QAEA+S,EAAAxX,EAAAvC,KAAA6Z,GACAG,EAAAvX,EAAAzC,KAAA8Z,EACA9Z,MAAA6Z,GAAAtX,EACAvC,KAAA8Z,GAAArX,EAEAgX,EAAAQ,MAAAF,EAAAC,EAAArT,GACA3G,KAAAmY,kBAAAsB,EAAA,OAAA9S,EAAAE,MAEA,IAAAqT,GAAAla,KAAA8X,UAAAvV,EAAAE,EAAAgX,GACAU,EAAAna,KAAAoa,WACApa,MAAAoa,YAAAF,EAEAT,IAAAS,IACAC,GAAAD,IAAAC,GACAna,KAAAmY,kBAAAgC,EAAA,YAAAxT,EAAAE,OAEAqT,GAAAA,IAAAC,GACAna,KAAAmY,kBAAA+B,EAAA,YAAAvT,EAAAE,UAMA2S,SAAA,SAAA7S,GACA,GAAA8S,GAAAzZ,KAAA2Z,eAEAF,KACAA,EAAAG,UAAA,GAGA5Z,KAAAmY,kBAAAsB,EAAA,UAAA9S,EAAAE,OAEA7G,KAAAoa,aACApa,KAAAmY,kBAAAnY,KAAAoa,YAAA,OAAAzT,EAAAE,OAGA7G,KAAA2Z,gBAAA,KACA3Z,KAAAoa,YAAA,OAKAva,EAAAD,QAAAuX,GTujEM,SAAStX,EAAQD,GUhoEvB,GAAAya,GAAArE,MAAApU,UAAAyS,MAOA+C,EAAA,WACApX,KAAAsa,cAGAlD,GAAAxV,WAEA+L,YAAAyJ,EASAmD,IAAA,SAAA1T,EAAA6F,EAAAwC,GACA,GAAAsL,GAAAxa,KAAAsa,UAEA,KAAA5N,IAAA7F,EACA,MAAA7G,KAGAwa,GAAA3T,KACA2T,EAAA3T,MAGA,KAAA,GAAAzD,GAAA,EAA2BA,EAAAoX,EAAA3T,GAAA3D,OAAsBE,IACjD,GAAAoX,EAAA3T,GAAAzD,GAAAqX,IAAA/N,EACA,MAAA1M,KAUA,OANAwa,GAAA3T,GAAApD,MACAgX,EAAA/N,EACA6N,KAAA,EACAG,IAAAxL,GAAAlP,OAGAA,MASA0G,GAAA,SAAAG,EAAA6F,EAAAwC,GACA,GAAAsL,GAAAxa,KAAAsa,UAEA,KAAA5N,IAAA7F,EACA,MAAA7G,KAGAwa,GAAA3T,KACA2T,EAAA3T,MAGA,KAAA,GAAAzD,GAAA,EAA2BA,EAAAoX,EAAA3T,GAAA3D,OAAsBE,IACjD,GAAAoX,EAAA3T,GAAAzD,GAAAqX,IAAA/N,EACA,MAAA1M,KAUA,OANAwa,GAAA3T,GAAApD,MACAgX,EAAA/N,EACA6N,KAAA,EACAG,IAAAxL,GAAAlP,OAGAA,MAQA2a,SAAA,SAAA9T,GACA,GAAA2T,GAAAxa,KAAAsa,UACA,OAAAE,GAAA3T,IAAA2T,EAAA3T,GAAA3D,QAQA+E,IAAA,SAAApB,EAAA6F,GACA,GAAA8N,GAAAxa,KAAAsa,UAEA,KAAAzT,EAEA,MADA7G,MAAAsa,cACAta,IAGA,IAAA0M,EAAA,CACA,GAAA8N,EAAA3T,GAAA,CAEA,IAAA,GADA+T,MACAxX,EAAA,EAAAyX,EAAAL,EAAA3T,GAAA3D,OAAyDE,EAAAyX,EAAOzX,IAChEoX,EAAA3T,GAAAzD,GAAA,GAAAsJ,GACAkO,EAAAnX,KAAA+W,EAAA3T,GAAAzD,GAGAoX,GAAA3T,GAAA+T,EAGAJ,EAAA3T,IAAA,IAAA2T,EAAA3T,GAAA3D,cACAsX,GAAA3T,cAIA2T,GAAA3T,EAGA,OAAA7G,OAQAmP,QAAA,SAAAzJ,GACA,GAAA1F,KAAAsa,WAAA5U,GAAA,CACA,GAAA8N,GAAAE,UACAoH,EAAAtH,EAAAtQ,MAEA4X,GAAA,IACAtH,EAAA6G,EAAA9Z,KAAAiT,EAAA,GAKA,KAAA,GAFAgH,GAAAxa,KAAAsa,WAAA5U,GACAkL,EAAA4J,EAAAtX,OACAE,EAAA,EAA+BA,EAAAwN,GAAS,CAExC,OAAAkK,GACA,IAAA,GACAN,EAAApX,GAAA,EAAA7C,KAAAia,EAAApX,GAAA,IACA,MACA,KAAA,GACAoX,EAAApX,GAAA,EAAA7C,KAAAia,EAAApX,GAAA,IAAAoQ,EAAA,GACA,MACA,KAAA,GACAgH,EAAApX,GAAA,EAAA7C,KAAAia,EAAApX,GAAA,IAAAoQ,EAAA,GAAAA,EAAA,GACA,MACA,SAEAgH,EAAApX,GAAA,EAAAuQ,MAAA6G,EAAApX,GAAA,IAAAoQ,GAIAgH,EAAApX,GAAA,KACAoX,EAAAO,OAAA3X,EAAA,GACAwN,KAGAxN,KAKA,MAAApD,OAOAgb,mBAAA,SAAAtV,GACA,GAAA1F,KAAAsa,WAAA5U,GAAA,CACA,GAAA8N,GAAAE,UACAoH,EAAAtH,EAAAtQ,MAEA4X,GAAA,IACAtH,EAAA6G,EAAA9Z,KAAAiT,EAAA,EAAAA,EAAAtQ,OAAA,GAMA,KAAA,GAJAwX,GAAAlH,EAAAA,EAAAtQ,OAAA,GAEAsX,EAAAxa,KAAAsa,WAAA5U,GACAkL,EAAA4J,EAAAtX,OACAE,EAAA,EAA+BA,EAAAwN,GAAS,CAExC,OAAAkK,GACA,IAAA,GACAN,EAAApX,GAAA,EAAA7C,KAAAma,EACA,MACA,KAAA,GACAF,EAAApX,GAAA,EAAA7C,KAAAma,EAAAlH,EAAA,GACA,MACA,KAAA,GACAgH,EAAApX,GAAA,EAAA7C,KAAAma,EAAAlH,EAAA,GAAAA,EAAA,GACA,MACA,SAEAgH,EAAApX,GAAA,EAAAuQ,MAAA+G,EAAAlH,GAIAgH,EAAApX,GAAA,KACAoX,EAAAO,OAAA3X,EAAA,GACAwN,KAGAxN,KAKA,MAAApD,QA4EAH,EAAAD,QAAAwX,GVgpEM,SAASvX,EAAQD,EAASM,GW57EhC,YAmBA,SAAA+a,GAAAC,EAAAC,GACA,MAAAD,GAAAE,SAAAD,EAAAC,OACAF,EAAAG,IAAAF,EAAAE,EAOAH,EAAAI,GAAAH,EAAAG,GAEAJ,EAAAG,EAAAF,EAAAE,EAEAH,EAAAE,OAAAD,EAAAC,OAtBA,GAAA/Z,GAAAnB,EAAA,GACAmL,EAAAnL,EAAA,GAEA4B,EAAA5B,EAAA,IAIAqb,EAAArb,EAAA,IAsBAqL,EAAA,WAEAvL,KAAAwb,aAEAxb,KAAAyb,UAEAzb,KAAA0b,gBAEA1b,KAAA2b,gBAAA,EAGApQ,GAAA3J,WAEA+L,YAAApC,EAMAqQ,SAAA,SAAAhJ,EAAA1D,GACA,IAAA,GAAA9L,GAAA,EAA2BA,EAAApD,KAAAyb,OAAAvY,OAAwBE,IACnDpD,KAAAyb,OAAArY,GAAAwY,SAAAhJ,EAAA1D,IAYAgK,eAAA,SAAArM,EAAAgP,GAKA,MAJAA,GAAAA,IAAA,EACAhP,GACA7M,KAAA8b,kBAAAD,GAEA7b,KAAA0b,cASAI,kBAAA,SAAAD,GACA7b,KAAA2b,gBAAA,CAGA,KAAA,GAFAI,GAAA/b,KAAAyb,OACAO,EAAAhc,KAAA0b,aACAtY,EAAA,EAAAwN,EAAAmL,EAAA7Y,OAA+CE,EAAAwN,EAASxN,IACxDpD,KAAAic,yBAAAF,EAAA3Y,GAAA,KAAAyY,EAEAG,GAAA9Y,OAAAlD,KAAA2b,gBAOAtQ,EAAAM,iBAAA4P,EAAAS,EAAAf,IAGAgB,yBAAA,SAAA1O,EAAA2O,EAAAL,GAEA,IAAAtO,EAAA4L,QAAA0C,EAAA,CAIAtO,EAAA4O,eAEA5O,EAAA6O,SAEA7O,EAAAV,SAIAU,EAAA8O,aAEA,IAAAC,GAAA/O,EAAA0J,QACA,IAAAqF,EAAA,CAIAJ,EADAA,EACAA,EAAA7H,UASA,KAHA,GAAAkI,GAAAD,EACAE,EAAAjP,EAEAgP,GAEAA,EAAAlZ,OAAAmZ,EACAD,EAAAE,kBAEAP,EAAAzY,KAAA8Y,GAEAC,EAAAD,EACAA,EAAAA,EAAAtF,SAIA,GAAA1J,EAAAmP,QAAA,CAGA,IAAA,GAFAC,GAAApP,EAAAqP,UAEAxZ,EAAA,EAA+BA,EAAAuZ,EAAAzZ,OAAqBE,IAAA,CACpD,GAAAJ,GAAA2Z,EAAAvZ,EAIAmK,GAAA6O,UACApZ,EAAAoZ,SAAA,GAGApc,KAAAic,yBAAAjZ,EAAAkZ,EAAAL,GAIAtO,EAAA6O,SAAA,MAIA7O,GAAAsP,YAAAX,EAEAlc,KAAA0b,aAAA1b,KAAA2b,mBAAApO,IAQAM,QAAA,SAAAN,GAEAvN,KAAAwb,UAAAjO,EAAAlN,MAIAkN,YAAAzL,IACAyL,EAAAuP,qBAAA9c,MAGAA,KAAAqN,SAAAE,GACAvN,KAAAyb,OAAAhY,KAAA8J,KAOAQ,QAAA,SAAAT,GACA,GAAA,MAAAA,EAAA,CAEA,IAAA,GAAAlK,GAAA,EAA+BA,EAAApD,KAAAyb,OAAAvY,OAAwBE,IAAA,CACvD,GAAA1D,GAAAM,KAAAyb,OAAArY,EACA1D,aAAAoC,IACApC,EAAAqd,uBAAA/c,MASA,MALAA,MAAAwb,aACAxb,KAAAyb,UACAzb,KAAA0b,qBACA1b,KAAA2b,gBAAA,GAKA,GAAArO,YAAA0I,OACA,IAAA,GAAA5S,GAAA,EAAAyX,EAAAvN,EAAApK,OAAgDE,EAAAyX,EAAOzX,IACvDpD,KAAA+N,QAAAT,EAAAlK,QAFA,CAOA,GAAAmK,EAEAA,GADA,gBAAA,GACAvN,KAAAwb,UAAAlO,GAGAA,CAGA,IAAA0P,GAAA3b,EAAAoI,QAAAzJ,KAAAyb,OAAAlO,EACAyP,IAAA,IACAhd,KAAAmN,WAAAI,EAAAlN,IACAL,KAAAyb,OAAAV,OAAAiC,EAAA,GACAzP,YAAAzL,IACAyL,EAAAwP,uBAAA/c,SAKAqN,SAAA,SAAAE,GAQA,MAPAA,aAAAzL,KACAyL,EAAA0P,UAAAjd,MAEAuN,EAAA2P,OAAA,GAEAld,KAAAwb,UAAAjO,EAAAlN,IAAAkN,EAEAvN,MAGAwN,IAAA,SAAAF,GACA,MAAAtN,MAAAwb,UAAAlO,IAGAH,WAAA,SAAAG,GACA,GAAA6P,GAAAnd,KAAAwb,UACAjO,EAAA4P,EAAA7P,EAQA,OAPAC,WACA4P,GAAA7P,GACAC,YAAAzL,KACAyL,EAAA0P,UAAA,OAIAjd,MAMA6K,QAAA,WACA7K,KAAAwb,UACAxb,KAAAod,YACApd,KAAAyb,OAAA,MAGA4B,oBAAApC,GAGApb,EAAAD,QAAA2L,GXo8EM,SAAS1L,EAAQD,EAASM,GYpsFhC,GAAA8K,GAAA9K,EAAA,GACAod,EAAApd,EAAA,IACAqd,EAAArd,EAAA,IAQA4B,EAAA,SAAAjB,GAEAA,EAAAA,MAEAyc,EAAA/c,KAAAP,KAAAa,EAEA,KAAA,GAAA8J,KAAA9J,GACAA,EAAAkL,eAAApB,KACA3K,KAAA2K,GAAA9J,EAAA8J,GAIA3K,MAAA4c,aAEA5c,KAAAid,UAAA,KAEAjd,KAAAoc,SAAA,EAGAta,GAAAF,WAEA+L,YAAA7L,EAEA4a,SAAA,EAKAhX,KAAA,QAQAsR,QAAA,EAKA2F,SAAA,WACA,MAAA3c,MAAA4c,UAAAvI,SAQA/O,QAAA,SAAA0X,GACA,MAAAhd,MAAA4c,UAAAI,IAQA/X,YAAA,SAAAM,GAEA,IAAA,GADAoX,GAAA3c,KAAA4c,UACAxZ,EAAA,EAA2BA,EAAAuZ,EAAAzZ,OAAqBE,IAChD,GAAAuZ,EAAAvZ,GAAAmC,OAAAA,EACA,MAAAoX,GAAAvZ,IAQAiC,WAAA,WACA,MAAArF,MAAA4c,UAAA1Z,QAOAlB,IAAA,SAAAgB,GAQA,MAPAA,IAAAA,IAAAhD,MAAAgD,EAAAK,SAAArD,OAEAA,KAAA4c,UAAAnZ,KAAAT,GAEAhD,KAAAwd,OAAAxa,IAGAhD,MAQAyd,UAAA,SAAAza,EAAA0a,GACA,GAAA1a,GAAAA,IAAAhD,MAAAgD,EAAAK,SAAArD,MACA0d,GAAAA,EAAAra,SAAArD,KAAA,CAEA,GAAA2c,GAAA3c,KAAA4c,UACAI,EAAAL,EAAAlT,QAAAiU,EAEAV,IAAA,IACAL,EAAA5B,OAAAiC,EAAA,EAAAha,GACAhD,KAAAwd,OAAAxa,IAIA,MAAAhD,OAGAwd,OAAA,SAAAxa,GACAA,EAAAK,QACAL,EAAAK,OAAAyK,OAAA9K,GAGAA,EAAAK,OAAArD,IAEA,IAAAoM,GAAApM,KAAAid,UACAhc,EAAAjB,KAAAkY,IACA9L,IAAAA,IAAApJ,EAAAia,YAEA7Q,EAAAiB,SAAArK,GAEAA,YAAAlB,IACAkB,EAAA8Z,qBAAA1Q,IAIAnL,GAAAA,EAAAmN,WAOAN,OAAA,SAAA9K,GACA,GAAA/B,GAAAjB,KAAAkY,KACA9L,EAAApM,KAAAid,UACAN,EAAA3c,KAAA4c,UAEAI,EAAAhS,EAAAvB,QAAAkT,EAAA3Z,EACA,OAAAga,GAAA,EACAhd,MAEA2c,EAAA5B,OAAAiC,EAAA,GAEAha,EAAAK,OAAA,KAEA+I,IAEAA,EAAAe,WAAAnK,EAAA3C,IAEA2C,YAAAlB,IACAkB,EAAA+Z,uBAAA3Q,IAIAnL,GAAAA,EAAAmN,UAEApO,OAMA2d,UAAA,WACA,GAEA3a,GACAI,EAHAuZ,EAAA3c,KAAA4c,UACAxQ,EAAApM,KAAAid,SAGA,KAAA7Z,EAAA,EAAuBA,EAAAuZ,EAAAzZ,OAAqBE,IAC5CJ,EAAA2Z,EAAAvZ,GACAgJ,IACAA,EAAAe,WAAAnK,EAAA3C,IACA2C,YAAAlB,IACAkB,EAAA+Z,uBAAA3Q,IAGApJ,EAAAK,OAAA,IAIA,OAFAsZ,GAAAzZ,OAAA,EAEAlD,MAQA4d,UAAA,SAAAhL,EAAA1D,GAEA,IAAA,GADAyN,GAAA3c,KAAA4c,UACAxZ,EAAA,EAA2BA,EAAAuZ,EAAAzZ,OAAqBE,IAAA,CAChD,GAAAJ,GAAA2Z,EAAAvZ,EACAwP,GAAArS,KAAA2O,EAAAlM,EAAAI,GAEA,MAAApD,OAQA4b,SAAA,SAAAhJ,EAAA1D,GACA,IAAA,GAAA9L,GAAA,EAA2BA,EAAApD,KAAA4c,UAAA1Z,OAA2BE,IAAA,CACtD,GAAAJ,GAAAhD,KAAA4c,UAAAxZ,EACAwP,GAAArS,KAAA2O,EAAAlM,GAEA,UAAAA,EAAA0C,MACA1C,EAAA4Y,SAAAhJ,EAAA1D,GAGA,MAAAlP,OAGA8c,qBAAA,SAAA1Q,GACA,IAAA,GAAAhJ,GAAA,EAA2BA,EAAApD,KAAA4c,UAAA1Z,OAA2BE,IAAA,CACtD,GAAAJ,GAAAhD,KAAA4c,UAAAxZ,EACAgJ,GAAAiB,SAAArK,GACAA,YAAAlB,IACAkB,EAAA8Z,qBAAA1Q,KAKA2Q,uBAAA,SAAA3Q,GACA,IAAA,GAAAhJ,GAAA,EAA2BA,EAAApD,KAAA4c,UAAA1Z,OAA2BE,IAAA,CACtD,GAAAJ,GAAAhD,KAAA4c,UAAAxZ,EACAgJ,GAAAe,WAAAnK,EAAA3C,IACA2C,YAAAlB,IACAkB,EAAA+Z,uBAAA3Q,KAKA8Q,MAAA,WAGA,MAFAld,MAAAoc,SAAA,EACApc,KAAAkY,MAAAlY,KAAAkY,KAAA9J,UACApO,MAMAoE,gBAAA,SAAAyZ,GAOA,IAAA,GALAC,GAAA,KACAC,EAAA,GAAAR,GAAA,EAAA,EAAA,EAAA,GACAZ,EAAAkB,GAAA7d,KAAA4c,UACAoB,KAEA5a,EAAA,EAA2BA,EAAAuZ,EAAAzZ,OAAqBE,IAAA,CAChD,GAAAJ,GAAA2Z,EAAAvZ,EACA,KAAAJ,EAAAmW,SAAAnW,EAAAib,UAAA,CAIA,GAAAC,GAAAlb,EAAAoB,kBACA+Z,EAAAnb,EAAAob,kBAAAJ,EAQAG,IACAJ,EAAAM,KAAAH,GACAH,EAAAO,eAAAH,GACAL,EAAAA,GAAAC,EAAAxN,QACAuN,EAAAS,MAAAR,KAGAD,EAAAA,GAAAI,EAAA3N,QACAuN,EAAAS,MAAAL,KAGA,MAAAJ,IAAAC,IAIA/S,EAAAgH,SAAAlQ,EAAAwb,GAEAzd,EAAAD,QAAAkC,GZ+tFM,SAASjC,EAAQD,EAASM,Ga1hGhC,YAMA,IAAAkL,GAAAlL,EAAA,GACAkX,EAAAlX,EAAA,GACAse,EAAAte,EAAA,IACAue,EAAAve,EAAA,IACA8K,EAAA9K,EAAA,GASAod,EAAA,SAAAzc,GAEA2d,EAAAje,KAAAP,KAAAa,GACAuW,EAAA7W,KAAAP,KAAAa,GACA4d,EAAAle,KAAAP,KAAAa,GAMAb,KAAAK,GAAAQ,EAAAR,IAAA+K,IAGAkS,GAAA1b,WAOA8D,KAAA,UAOAH,KAAA,GAQA2S,KAAA,KASAiB,QAAA,EASAlC,SAAA,KAOAgD,MAAA,SAAAF,EAAAC,GACA,OAAAha,KAAA0Z,WACA,IAAA,aACAM,EAAA,CACA,MACA,KAAA,WACAD,EAAA,EAIA,GAAAvZ,GAAAR,KAAAme,SACA3d,KACAA,EAAAR,KAAAme,WAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAEA3d,EAAA,IAAAuZ,EACAvZ,EAAA,IAAAwZ,EAEAha,KAAA0e,qBACA1e,KAAAkd,OAAA,IAMAf,aAAA,aAIAE,YAAA,aAIAxP,OAAA,WACA7M,KAAAyc,mBAOAb,SAAA,SAAAhJ,EAAA1D,KAKAyP,OAAA,SAAAhU,EAAAoH,GACA,GAAA,aAAApH,GAAA,UAAAA,GAAA,WAAAA,GAEA,GAAAoH,EAAA,CACA,GAAA/L,GAAAhG,KAAA2K,EACA3E,KACAA,EAAAhG,KAAA2K,OAEA3E,EAAA,GAAA+L,EAAA,GACA/L,EAAA,GAAA+L,EAAA,QAIA/R,MAAA2K,GAAAoH,GAOA6M,KAAA,WACA5e,KAAAmZ,QAAA,EACAnZ,KAAAkY,MAAAlY,KAAAkY,KAAA9J,WAMAyQ,KAAA,WACA7e,KAAAmZ,QAAA,EACAnZ,KAAAkY,MAAAlY,KAAAkY,KAAA9J,WAOA7H,KAAA,SAAAoE,EAAAoH,GACA,GAAA,gBAAApH,GACA3K,KAAA2e,OAAAhU,EAAAoH,OAEA,IAAA/G,EAAAmG,SAAAxG,GACA,IAAA,GAAApF,KAAAoF,GACAA,EAAAoB,eAAAxG,IACAvF,KAAA2e,OAAApZ,EAAAoF,EAAApF,GAOA,OAFAvF,MAAAkd,OAAA,GAEAld,MAMA8e,YAAA,SAAA7H,GACA,GAAAhW,GAAAjB,KAAAkY,IACAjX,IACAgW,EAAAvJ,YAAAzM,GAIAjB,KAAAiX,UAAAjX,KAAAiX,WAAAA,GACAjX,KAAA+e,iBAGA/e,KAAAiX,SAAAA,EACAA,EAAAiB,KAAAjX,EACAgW,EAAA+H,aAAAhf,KAEAA,KAAAkd,OAAA,IAKA6B,eAAA,WACA,GAAA9H,GAAAjX,KAAAiX,QACAA,KACAA,EAAAiB,MACAjB,EAAAxJ,iBAAAwJ,EAAAiB,MAGAjB,EAAAiB,KAAA,KACAjB,EAAA+H,aAAA,KACAhf,KAAAiX,SAAA,KAEAjX,KAAAkd,OAAA,KASAxP,YAAA,SAAAzM,GACAjB,KAAAkY,KAAAjX,CAEA,IAAAge,GAAAjf,KAAAif,SACA,IAAAA,EACA,IAAA,GAAA7b,GAAA,EAA+BA,EAAA6b,EAAA/b,OAAsBE,IACrDnC,EAAA0L,UAAAuS,YAAAD,EAAA7b,GAIApD,MAAAiX,UACAjX,KAAAiX,SAAAvJ,YAAAzM,IASAwM,iBAAA,SAAAxM,GACAjB,KAAAkY,KAAA,IAEA,IAAA+G,GAAAjf,KAAAif,SACA,IAAAA,EACA,IAAA,GAAA7b,GAAA,EAA+BA,EAAA6b,EAAA/b,OAAsBE,IACrDnC,EAAA0L,UAAAwS,eAAAF,EAAA7b,GAIApD,MAAAiX,UACAjX,KAAAiX,SAAAxJ,iBAAAxM,KAKA+J,EAAAuH,MAAA+K,EAAAmB,GACAzT,EAAAuH,MAAA+K,EAAAkB,GACAxT,EAAAuH,MAAA+K,EAAAlG,GAEAvX,EAAAD,QAAA0d,GbiiGM,SAASzd,EAAQD,EAASM,GctyGhC,YAcA,SAAAkf,GAAAC,GACA,MAAAA,GAAAC,GAAAD,GAAAC,EAPA,GAAAC,GAAArf,EAAA,IACAsf,EAAAtf,EAAA,IACAuf,EAAAF,EAAAG,SAEAJ,EAAA,KAUAd,EAAA,SAAA3d,GACAA,EAAAA,MAEAA,EAAAqF,WAMAlG,KAAAkG,UAAA,EAAA,IAEA,MAAArF,EAAA8e,WAMA3f,KAAA2f,SAAA,GAEA9e,EAAAsF,QAMAnG,KAAAmG,OAAA,EAAA,IAOAnG,KAAA4f,OAAA5f,KAAA4f,QAAA,MAGAC,EAAArB,EAAA5c,SACAie,GAAA1B,UAAA,KAMA0B,EAAAC,mBAAA,WACA,MAAAV,GAAApf,KAAA2f,WACAP,EAAApf,KAAAkG,SAAA,KACAkZ,EAAApf,KAAAkG,SAAA,KACAkZ,EAAApf,KAAAmG,MAAA,GAAA,IACAiZ,EAAApf,KAAAmG,MAAA,GAAA,IAGA0Z,EAAApD,gBAAA,WACA,GAAApZ,GAAArD,KAAAqD,OACA0c,EAAA1c,GAAAA,EAAA8a,UACA2B,EAAA9f,KAAA8f,qBAEAtf,EAAAR,KAAAme,SACA,OAAA2B,IAAAC,GAKAvf,EAAAA,GAAA+e,EAAAS,SAEAF,EACA9f,KAAAoe,kBAAA5d,GAGAif,EAAAjf,GAIAuf,IACAD,EACAP,EAAAU,IAAAzf,EAAA6C,EAAA8a,UAAA3d,GAGA+e,EAAAlB,KAAA7d,EAAA6C,EAAA8a,YAIAne,KAAAme,UAAA3d,EAEAR,KAAAkgB,aAAAlgB,KAAAkgB,cAAAX,EAAAS,aACAT,GAAAY,OAAAngB,KAAAkgB,aAAA1f,SA1BAA,GAAAif,EAAAjf,KA6BAqf,EAAAzB,kBAAA,SAAA5d,GACAA,EAAAA,MACAif,EAAAjf,EAEA,IAAAof,GAAA5f,KAAA4f,OAEAzZ,EAAAnG,KAAAmG,MACAwZ,EAAA3f,KAAA2f,SACAzZ,EAAAlG,KAAAkG,QAmBA,OAlBA0Z,KAEApf,EAAA,IAAAof,EAAA,GACApf,EAAA,IAAAof,EAAA,IAEAL,EAAApZ,MAAA3F,EAAAA,EAAA2F,GACAwZ,GACAJ,EAAAa,OAAA5f,EAAAA,EAAAmf,GAEAC,IAEApf,EAAA,IAAAof,EAAA,GACApf,EAAA,IAAAof,EAAA,IAGApf,EAAA,IAAA0F,EAAA,GACA1F,EAAA,IAAA0F,EAAA,GAEA1F,GAMAqf,EAAAQ,aAAA,SAAA3F,GACA,GAAAla,GAAAR,KAAAme,UACAtP,EAAA6L,EAAA7L,KAAA,CACArO,GACAka,EAAA2F,aAAAxR,EAAArO,EAAA,GAAAqO,EAAArO,EAAA,GAAAqO,EAAArO,EAAA,GAAAqO,EAAArO,EAAA,GAAAqO,EAAArO,EAAA,GAAAqO,EAAArO,EAAA,IAGAka,EAAA2F,aAAAxR,EAAA,EAAA,EAAAA,EAAA,EAAA,IAIAgR,EAAAS,iBAAA,SAAA5F,GACA,GACA7L,IADA7O,KAAAme,UACAzD,EAAA7L,KAAA,EACA6L,GAAA2F,aAAAxR,EAAA,EAAA,EAAAA,EAAA,EAAA,GAGA,IAAA0R,KAKAV,GAAAnB,mBAAA,WACA,GAAA1e,KAAAme,UAAA,CAGA,GAAA9a,GAAArD,KAAAqD,OACA7C,EAAAR,KAAAme,SACA9a,IAAAA,EAAA8a,YAEAoB,EAAAU,IAAAM,EAAAld,EAAA6c,aAAA1f,GACAA,EAAA+f,EAEA,IAAAC,GAAAhgB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACAigB,EAAAjgB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACA0F,EAAAlG,KAAAkG,SACAC,EAAAnG,KAAAmG,KACAiZ,GAAAoB,EAAA,KACAA,EAAAE,KAAAC,KAAAH,IAEApB,EAAAqB,EAAA,KACAA,EAAAC,KAAAC,KAAAF,IAEAjgB,EAAA,GAAA,IACAggB,GAAAA,GAEAhgB,EAAA,GAAA,IACAigB,GAAAA,GAEAva,EAAA,GAAA1F,EAAA,GACA0F,EAAA,GAAA1F,EAAA,GACA2F,EAAA,GAAAqa,EACAra,EAAA,GAAAsa,EACAzgB,KAAA2f,SAAAe,KAAAE,OAAApgB,EAAA,GAAAigB,EAAAjgB,EAAA,GAAAggB,KAOAX,EAAAgB,eAAA,WACA,GAAArgB,GAAAR,KAAAme,SACA,KAAA3d,EACA,OAAA,EAAA,EAEA,IAAAggB,GAAAE,KAAAC,KAAAngB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAigB,EAAAC,KAAAC,KAAAngB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAOA,OANAA,GAAA,GAAA,IACAggB,GAAAA,GAEAhgB,EAAA,GAAA,IACAigB,GAAAA,IAEAD,EAAAC,IASAZ,EAAAiB,sBAAA,SAAAve,EAAAE,GACA,GAAAse,IAAAxe,EAAAE,GACAyd,EAAAlgB,KAAAkgB,YAIA,OAHAA,IACAV,EAAAlB,eAAAyC,EAAAA,EAAAb,GAEAa,GAUAlB,EAAAmB,uBAAA,SAAAze,EAAAE,GACA,GAAAse,IAAAxe,EAAAE,GACA0b,EAAAne,KAAAme,SAIA,OAHAA,IACAqB,EAAAlB,eAAAyC,EAAAA,EAAA5C,GAEA4C,GAGAlhB,EAAAD,QAAA4e,Gd8yGM,SAAS3e,EAAQD,GeriHvB,GAAAqhB,GAAA,mBAAAC,cACAlL,MACAkL,aAKA3B,GAKAS,OAAA,WACA,GAAAmB,GAAA,GAAAF,GAAA,EAGA,OAFA1B,GAAAG,SAAAyB,GAEAA,GAMAzB,SAAA,SAAAyB,GAOA,MANAA,GAAA,GAAA,EACAA,EAAA,GAAA,EACAA,EAAA,GAAA,EACAA,EAAA,GAAA,EACAA,EAAA,GAAA,EACAA,EAAA,GAAA,EACAA,GAOA9C,KAAA,SAAA8C,EAAA3gB,GAOA,MANA2gB,GAAA,GAAA3gB,EAAA,GACA2gB,EAAA,GAAA3gB,EAAA,GACA2gB,EAAA,GAAA3gB,EAAA,GACA2gB,EAAA,GAAA3gB,EAAA,GACA2gB,EAAA,GAAA3gB,EAAA,GACA2gB,EAAA,GAAA3gB,EAAA,GACA2gB,GAQAlB,IAAA,SAAAkB,EAAAC,EAAAC,GAIA,GAAAC,GAAAF,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAE,EAAAH,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAG,EAAAJ,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAI,EAAAL,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GACAK,EAAAN,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,GACAO,EAAAP,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,EAOA,OANAD,GAAA,GAAAG,EACAH,EAAA,GAAAI,EACAJ,EAAA,GAAAK,EACAL,EAAA,GAAAM,EACAN,EAAA,GAAAO,EACAP,EAAA,GAAAQ,EACAR,GAQAS,UAAA,SAAAT,EAAAjG,EAAA2G,GAOA,MANAV,GAAA,GAAAjG,EAAA,GACAiG,EAAA,GAAAjG,EAAA,GACAiG,EAAA,GAAAjG,EAAA,GACAiG,EAAA,GAAAjG,EAAA,GACAiG,EAAA,GAAAjG,EAAA,GAAA2G,EAAA,GACAV,EAAA,GAAAjG,EAAA,GAAA2G,EAAA,GACAV,GAQAf,OAAA,SAAAe,EAAAjG,EAAA4G,GACA,GAAAC,GAAA7G,EAAA,GACA8G,EAAA9G,EAAA,GACA+G,EAAA/G,EAAA,GACAgH,EAAAhH,EAAA,GACAiH,EAAAjH,EAAA,GACAkH,EAAAlH,EAAA,GACAmH,EAAA3B,KAAA4B,IAAAR,GACAS,EAAA7B,KAAA8B,IAAAV,EAQA,OANAX,GAAA,GAAAY,EAAAQ,EAAAL,EAAAG,EACAlB,EAAA,IAAAY,EAAAM,EAAAH,EAAAK,EACApB,EAAA,GAAAa,EAAAO,EAAAJ,EAAAE,EACAlB,EAAA,IAAAa,EAAAK,EAAAE,EAAAJ,EACAhB,EAAA,GAAAoB,EAAAN,EAAAI,EAAAD,EACAjB,EAAA,GAAAoB,EAAAH,EAAAC,EAAAJ,EACAd,GAQAhb,MAAA,SAAAgb,EAAAjG,EAAA2G,GACA,GAAAY,GAAAZ,EAAA,GACAa,EAAAb,EAAA,EAOA,OANAV,GAAA,GAAAjG,EAAA,GAAAuH,EACAtB,EAAA,GAAAjG,EAAA,GAAAwH,EACAvB,EAAA,GAAAjG,EAAA,GAAAuH,EACAtB,EAAA,GAAAjG,EAAA,GAAAwH,EACAvB,EAAA,GAAAjG,EAAA,GAAAuH,EACAtB,EAAA,GAAAjG,EAAA,GAAAwH,EACAvB,GAOAhB,OAAA,SAAAgB,EAAAjG,GAEA,GAAA6G,GAAA7G,EAAA,GACA8G,EAAA9G,EAAA,GACA+G,EAAA/G,EAAA,GACAgH,EAAAhH,EAAA,GACAiH,EAAAjH,EAAA,GACAkH,EAAAlH,EAAA,GAEAyH,EAAAZ,EAAAI,EAAAD,EAAAF,CACA,OAAAW,IAGAA,EAAA,EAAAA,EAEAxB,EAAA,GAAAgB,EAAAQ,EACAxB,EAAA,IAAAe,EAAAS,EACAxB,EAAA,IAAAa,EAAAW,EACAxB,EAAA,GAAAY,EAAAY,EACAxB,EAAA,IAAAa,EAAAI,EAAAD,EAAAF,GAAAU,EACAxB,EAAA,IAAAe,EAAAD,EAAAF,EAAAK,GAAAO,EACAxB,GAVA,MAcAthB,GAAAD,QAAA2f,Gf8iHM,SAAS1f,EAAQD,GgBzsHvB,GAAAqhB,GAAA,mBAAAC,cACAlL,MACAkL,aASA1B,GAOAQ,OAAA,SAAAzd,EAAAE,GACA,GAAA0e,GAAA,GAAAF,GAAA,EASA,OARA,OAAA1e,IACAA,EAAA,GAEA,MAAAE,IACAA,EAAA,GAEA0e,EAAA,GAAA5e,EACA4e,EAAA,GAAA1e,EACA0e,GASA9C,KAAA,SAAA8C,EAAAU,GAGA,MAFAV,GAAA,GAAAU,EAAA,GACAV,EAAA,GAAAU,EAAA,GACAV,GAQA5Q,MAAA,SAAAsR,GACA,GAAAV,GAAA,GAAAF,GAAA,EAGA,OAFAE,GAAA,GAAAU,EAAA,GACAV,EAAA,GAAAU,EAAA,GACAV,GAUAyB,IAAA,SAAAzB,EAAAjG,EAAAC,GAGA,MAFAgG,GAAA,GAAAjG,EACAiG,EAAA,GAAAhG,EACAgG,GASAnf,IAAA,SAAAmf,EAAA0B,EAAA9B,GAGA,MAFAI,GAAA,GAAA0B,EAAA,GAAA9B,EAAA,GACAI,EAAA,GAAA0B,EAAA,GAAA9B,EAAA,GACAI,GAUA2B,YAAA,SAAA3B,EAAA0B,EAAA9B,EAAA7F,GAGA,MAFAiG,GAAA,GAAA0B,EAAA,GAAA9B,EAAA,GAAA7F,EACAiG,EAAA,GAAA0B,EAAA,GAAA9B,EAAA,GAAA7F,EACAiG,GASA4B,IAAA,SAAA5B,EAAA0B,EAAA9B,GAGA,MAFAI,GAAA,GAAA0B,EAAA,GAAA9B,EAAA,GACAI,EAAA,GAAA0B,EAAA,GAAA9B,EAAA,GACAI,GAQAvQ,IAAA,SAAAiR,GACA,MAAAnB,MAAAC,KAAA3gB,KAAAgjB,UAAAnB,KAQAmB,UAAA,SAAAnB,GACA,MAAAA,GAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IASA5B,IAAA,SAAAkB,EAAA0B,EAAA9B,GAGA,MAFAI,GAAA,GAAA0B,EAAA,GAAA9B,EAAA,GACAI,EAAA,GAAA0B,EAAA,GAAA9B,EAAA,GACAI,GASA8B,IAAA,SAAA9B,EAAA0B,EAAA9B,GAGA,MAFAI,GAAA,GAAA0B,EAAA,GAAA9B,EAAA,GACAI,EAAA,GAAA0B,EAAA,GAAA9B,EAAA,GACAI,GASA+B,IAAA,SAAAL,EAAA9B,GACA,MAAA8B,GAAA,GAAA9B,EAAA,GAAA8B,EAAA,GAAA9B,EAAA,IASA5a,MAAA,SAAAgb,EAAAU,EAAAsB,GAGA,MAFAhC,GAAA,GAAAU,EAAA,GAAAsB,EACAhC,EAAA,GAAAU,EAAA,GAAAsB,EACAhC,GAQAiC,UAAA,SAAAjC,EAAAU,GACA,GAAAwB,GAAA7D,EAAA5O,IAAAiR,EASA,OARA,KAAAwB,GACAlC,EAAA,GAAA,EACAA,EAAA,GAAA,IAGAA,EAAA,GAAAU,EAAA,GAAAwB,EACAlC,EAAA,GAAAU,EAAA,GAAAwB,GAEAlC,GASAmC,SAAA,SAAAT,EAAA9B,GACA,MAAAL,MAAAC,MACAkC,EAAA,GAAA9B,EAAA,KAAA8B,EAAA,GAAA9B,EAAA,KACA8B,EAAA,GAAA9B,EAAA,KAAA8B,EAAA,GAAA9B,EAAA,MAUAwC,eAAA,SAAAV,EAAA9B,GACA,OAAA8B,EAAA,GAAA9B,EAAA,KAAA8B,EAAA,GAAA9B,EAAA,KACA8B,EAAA,GAAA9B,EAAA,KAAA8B,EAAA,GAAA9B,EAAA,KAQAyC,OAAA,SAAArC,EAAAU,GAGA,MAFAV,GAAA,IAAAU,EAAA,GACAV,EAAA,IAAAU,EAAA,GACAV,GAUAsC,KAAA,SAAAtC,EAAA0B,EAAA9B,EAAA2C,GAGA,MAFAvC,GAAA,GAAA0B,EAAA,GAAAa,GAAA3C,EAAA,GAAA8B,EAAA,IACA1B,EAAA,GAAA0B,EAAA,GAAAa,GAAA3C,EAAA,GAAA8B,EAAA,IACA1B,GASA7C,eAAA,SAAA6C,EAAAU,EAAArhB,GACA,GAAA+B,GAAAsf,EAAA,GACApf,EAAAof,EAAA,EAGA,OAFAV,GAAA,GAAA3gB,EAAA,GAAA+B,EAAA/B,EAAA,GAAAiC,EAAAjC,EAAA,GACA2gB,EAAA,GAAA3gB,EAAA,GAAA+B,EAAA/B,EAAA,GAAAiC,EAAAjC,EAAA,GACA2gB,GAQA9Z,IAAA,SAAA8Z,EAAA0B,EAAA9B,GAGA,MAFAI,GAAA,GAAAT,KAAArZ,IAAAwb,EAAA,GAAA9B,EAAA,IACAI,EAAA,GAAAT,KAAArZ,IAAAwb,EAAA,GAAA9B,EAAA,IACAI,GAQA7Z,IAAA,SAAA6Z,EAAA0B,EAAA9B,GAGA,MAFAI,GAAA,GAAAT,KAAApZ,IAAAub,EAAA,GAAA9B,EAAA,IACAI,EAAA,GAAAT,KAAApZ,IAAAub,EAAA,GAAA9B,EAAA,IACAI,GAIA3B,GAAAtc,OAAAsc,EAAA5O,IACA4O,EAAAmE,aAAAnE,EAAAwD,UACAxD,EAAAoE,KAAApE,EAAA8D,SACA9D,EAAAqE,WAAArE,EAAA+D,eAEA1jB,EAAAD,QAAA4f,GhBktHM,SAAS3f,EAAQD,EAASM,GiBx+HhC,YAMA,IAAA4jB,GAAA5jB,EAAA,IACAmB,EAAAnB,EAAA,GACA6T,EAAA1S,EAAA0S,SACAD,EAAAzS,EAAAyS,WACA3C,EAAA9P,EAAA8P,SACA4S,EAAA7jB,EAAA,IAMAue,EAAA,WAMAze,KAAAif,aAGAR,GAAA7c,WAEA+L,YAAA8Q,EAcAuF,QAAA,SAAAC,EAAAC,GACA,GAAAle,GACAme,GAAA,EACA5W,EAAAvN,KACAiB,EAAAjB,KAAAkY,IACA,IAAA+L,EAAA,CACA,GAAAG,GAAAH,EAAAI,MAAA,KACAhS,EAAA9E,CAEA4W,GAAA,UAAAC,EAAA,EACA,KAAA,GAAAhhB,GAAA,EAAAyX,EAAAuJ,EAAAlhB,OAAwDE,EAAAyX,EAAOzX,IAC/DiP,IAGAA,EAAAA,EAAA+R,EAAAhhB,IAEAiP,KACArM,EAAAqM,OAIArM,GAAAuH,CAGA,KAAAvH,EAOA,WANA+d,GACA,aACAE,EACA,+BACA1W,EAAAlN,GAKA,IAAA4e,GAAA1R,EAAA0R,UAEAqF,EAAA,GAAAR,GAAA9d,EAAAke,EAiBA,OAfAI,GAAAC,OAAA,SAAAve,GACAuH,EAAA2P,MAAAiH,KAEAK,KAAA,WAEAvF,EAAAlE,OAAA1Z,EAAAoI,QAAAwV,EAAAqF,GAAA,KAGArF,EAAAxb,KAAA6gB,GAGArjB,GACAA,EAAA0L,UAAAuS,YAAAoF,GAGAA,GAOAG,cAAA,SAAAC,GAGA,IAAA,GAFAzF,GAAAjf,KAAAif,UACArO,EAAAqO,EAAA/b,OACAE,EAAA,EAA2BA,EAAAwN,EAASxN,IACpC6b,EAAA7b,GAAAwD,KAAA8d,EAIA,OAFAzF,GAAA/b,OAAA,EAEAlD,MA4BA2kB,UAAA,SAAA3e,EAAA4e,EAAAC,EAAAC,EAAAC,GAmCA,QAAAP,KACAQ,IACAA,GACAD,GAAAA,IApCAhR,EAAA8Q,IACAE,EAAAD,EACAA,EAAAD,EACAA,EAAA,GAGA/Q,EAAAgR,IACAC,EAAAD,EACAA,EAAA,SACAD,EAAA,GAGA/Q,EAAA+Q,IACAE,EAAAF,EACAA,EAAA,GAGA/Q,EAAA8Q,IACAG,EAAAH,EACAA,EAAA,KAGAA,IACAA,EAAA,KAGA5kB,KAAAykB,gBACAzkB,KAAAilB,kBAAA,GAAAjlB,KAAAgG,EAAA4e,EAAAC,EAAAC,EAAAC,EAIA,IAAA9F,GAAAjf,KAAAif,UAAA5K,QACA2Q,EAAA/F,EAAA/b,MAUA8hB,IACAD,GAAAA,GAIA,KAAA,GAAA3hB,GAAA,EAA2BA,EAAA6b,EAAA/b,OAAsBE,IACjD6b,EAAA7b,GACAohB,KAAAA,GACAxX,MAAA8X,IA6BAG,kBAAA,SAAAhB,EAAAzT,EAAAxK,EAAA4e,EAAAC,GACA,GAAAK,MACAC,EAAA,CACA,KAAA,GAAA5f,KAAAS,GACA,GAAAA,EAAA+F,eAAAxG,GAIA,GAAA,MAAAiL,EAAAjL,GACA4L,EAAAnL,EAAAT,MAAAlE,EAAAmR,YAAAxM,EAAAT,IACAvF,KAAAilB,kBACAhB,EAAAA,EAAA,IAAA1e,EAAAA,EACAiL,EAAAjL,GACAS,EAAAT,GACAqf,EACAC,IAIAK,EAAA3f,GAAAS,EAAAT,GACA4f,SAGA,IAAA,MAAAnf,EAAAT,GAGA,GAAA0e,EAGA,CACA,GAAAmB,KACAA,GAAAnB,MACAmB,EAAAnB,GAAA1e,GAAAS,EAAAT,GACAvF,KAAAuG,KAAA6e,OANAplB,MAAAuG,KAAAhB,EAAAS,EAAAT,GAiBA,OANA4f,GAAA,GACAnlB,KAAAgkB,QAAAC,GAAA,GACAoB,KAAA,MAAAT,EAAA,IAAAA,EAAAM,GACAL,MAAAA,GAAA,GAGA7kB,OAIAH,EAAAD,QAAA6e,GjB++HM,SAAS5e,EAAQD,EAASM,GkB9uIhC,QAAAolB,GAAAtf,EAAA2E,GACA,MAAA3E,GAAA2E,GAGA,QAAA4a,GAAAvf,EAAA2E,EAAAoH,GACA/L,EAAA2E,GAAAoH,EASA,QAAAyT,GAAAC,EAAAC,EAAAC,GACA,OAAAD,EAAAD,GAAAE,EAAAF,EASA,QAAAG,GAAAH,EAAAC,EAAAC,GACA,MAAAA,GAAA,GAAAD,EAAAD,EAUA,QAAAI,GAAAJ,EAAAC,EAAAC,EAAAxE,EAAA2E,GACA,GAAAlV,GAAA6U,EAAAviB,MACA,IAAA,GAAA4iB,EACA,IAAA,GAAA1iB,GAAA,EAA2BA,EAAAwN,EAASxN,IACpC+d,EAAA/d,GAAAoiB,EAAAC,EAAAriB,GAAAsiB,EAAAtiB,GAAAuiB,OAKA,KAAA,GADAI,GAAAN,EAAA,GAAAviB,OACAE,EAAA,EAA2BA,EAAAwN,EAASxN,IACpC,IAAA,GAAAwB,GAAA,EAA+BA,EAAAmhB,EAAUnhB,IACzCuc,EAAA/d,GAAAwB,GAAA4gB,EACAC,EAAAriB,GAAAwB,GAAA8gB,EAAAtiB,GAAAwB,GAAA+gB,GASA,QAAAK,GAAAC,EAAAC,EAAAJ,GACA,GAAAK,GAAAF,EAAA/iB,OACAkjB,EAAAF,EAAAhjB,MACA,IAAAijB,IAAAC,EAAA,CAEA,GAAAC,GAAAF,EAAAC,CACA,IAAAC,EAEAJ,EAAA/iB,OAAAkjB,MAIA,KAAA,GAAAhjB,GAAA+iB,EAAqC/iB,EAAAgjB,EAAahjB,IAClD6iB,EAAAxiB,KACA,IAAAqiB,EAAAI,EAAA9iB,GAAAkjB,EAAA/lB,KAAA2lB,EAAA9iB,KAOA,IAAA,GADA2iB,GAAAE,EAAA,IAAAA,EAAA,GAAA/iB,OACAE,EAAA,EAAuBA,EAAA6iB,EAAA/iB,OAAiBE,IACxC,GAAA,IAAA0iB,EACAS,MAAAN,EAAA7iB,MACA6iB,EAAA7iB,GAAA8iB,EAAA9iB,QAIA,KAAA,GAAAwB,GAAA,EAA+BA,EAAAmhB,EAAUnhB,IACzC2hB,MAAAN,EAAA7iB,GAAAwB,MACAqhB,EAAA7iB,GAAAwB,GAAAshB,EAAA9iB,GAAAwB,IAaA,QAAA4hB,GAAAP,EAAAC,EAAAJ,GACA,GAAAG,IAAAC,EACA,OAAA,CAEA,IAAAtV,GAAAqV,EAAA/iB,MACA,IAAA0N,IAAAsV,EAAAhjB,OACA,OAAA,CAEA,IAAA,IAAA4iB,GACA,IAAA,GAAA1iB,GAAA,EAA2BA,EAAAwN,EAASxN,IACpC,GAAA6iB,EAAA7iB,KAAA8iB,EAAA9iB,GACA,OAAA,MAMA,KAAA,GADA2iB,GAAAE,EAAA,GAAA/iB,OACAE,EAAA,EAA2BA,EAAAwN,EAASxN,IACpC,IAAA,GAAAwB,GAAA,EAA+BA,EAAAmhB,EAAUnhB,IACzC,GAAAqhB,EAAA7iB,GAAAwB,KAAAshB,EAAA9iB,GAAAwB,GACA,OAAA,CAKA,QAAA,EAeA,QAAA6hB,GACAhB,EAAAC,EAAAgB,EAAAC,EAAAjD,EAAAkD,EAAAC,EAAA1F,EAAA2E,GAEA,GAAAlV,GAAA6U,EAAAviB,MACA,IAAA,GAAA4iB,EACA,IAAA,GAAA1iB,GAAA,EAA2BA,EAAAwN,EAASxN,IACpC+d,EAAA/d,GAAA0jB,EACArB,EAAAriB,GAAAsiB,EAAAtiB,GAAAsjB,EAAAtjB,GAAAujB,EAAAvjB,GAAAsgB,EAAAkD,EAAAC,OAMA,KAAA,GADAd,GAAAN,EAAA,GAAAviB,OACAE,EAAA,EAA2BA,EAAAwN,EAASxN,IACpC,IAAA,GAAAwB,GAAA,EAA+BA,EAAAmhB,EAAUnhB,IACzCuc,EAAA/d,GAAAwB,GAAAkiB,EACArB,EAAAriB,GAAAwB,GAAA8gB,EAAAtiB,GAAAwB,GAAA8hB,EAAAtjB,GAAAwB,GAAA+hB,EAAAvjB,GAAAwB,GACA8e,EAAAkD,EAAAC;CAkBA,QAAAC,GAAArB,EAAAC,EAAAgB,EAAAC,EAAAjD,EAAAkD,EAAAC,GACA,GAAAE,GAAA,IAAAL,EAAAjB,GACA5C,EAAA,IAAA8D,EAAAjB,EACA,QAAA,GAAAA,EAAAgB,GAAAK,EAAAlE,GAAAgE,OACAnB,EAAAgB,GAAA,EAAAK,EAAAlE,GAAA+D,EACAG,EAAArD,EAAAgC,EAGA,QAAAsB,GAAAjV,GACA,GAAAS,EAAAT,GAAA,CACA,GAAAnB,GAAAmB,EAAA7O,MACA,IAAAsP,EAAAT,EAAA,IAAA,CAEA,IAAA,GADAkV,MACA7jB,EAAA,EAA+BA,EAAAwN,EAASxN,IACxC6jB,EAAAxjB,KAAA6iB,EAAA/lB,KAAAwR,EAAA3O,IAEA,OAAA6jB,GAGA,MAAAX,GAAA/lB,KAAAwR,GAGA,MAAAA,GAGA,QAAAmV,GAAAC,GAKA,MAJAA,GAAA,GAAAzG,KAAA0G,MAAAD,EAAA,IACAA,EAAA,GAAAzG,KAAA0G,MAAAD,EAAA,IACAA,EAAA,GAAAzG,KAAA0G,MAAAD,EAAA,IAEA,QAAAA,EAAAE,KAAA,KAAA,IAGA,QAAAC,GAAAhD,EAAAQ,EAAAyC,EAAAC,EAAAC,GACA,GAAAC,GAAApD,EAAAqD,QACAC,EAAAtD,EAAAuD,QACAC,EAAA,WAAAhD,EAEAiD,EAAAP,EAAAtkB,MACA,IAAA6kB,EAAA,CAIA,GAWAC,GAXAC,EAAAT,EAAA,GAAAzV,MACAmW,EAAA1V,EAAAyV,GACAE,GAAA,EACAC,GAAA,EAGAtC,EACAoC,GACA1V,EAAAyV,EAAA,IAEA,EAAA,CAGAT,GAAAa,KAAA,SAAAnN,EAAAC,GACA,MAAAD,GAAA0J,KAAAzJ,EAAAyJ,OAGAoD,EAAAR,EAAAO,EAAA,GAAAnD,IAOA,KAAA,GALA0D,MAEAC,KACAC,EAAAhB,EAAA,GAAAzV,MACA0W,GAAA,EACArlB,EAAA,EAAuBA,EAAA2kB,EAAc3kB,IAAA,CACrCklB,EAAA7kB,KAAA+jB,EAAApkB,GAAAwhB,KAAAoD,EAEA,IAAAjW,GAAAyV,EAAApkB,GAAA2O,KAUA,IAPAmW,GAAA1B,EAAAzU,EAAAyW,EAAA1C,KACAoC,GAAAnW,IAAAyW,IACAC,GAAA,GAEAD,EAAAzW,EAGA,gBAAAA,GAAA,CACA,GAAA2W,GAAAC,EAAAC,MAAA7W,EACA2W,IACA3W,EAAA2W,EACAP,GAAA,GAGAC,GAAA,EAGAG,EAAA9kB,KAAAsO,GAEA,IAAA0W,EAAA,CAMA,IAAA,GAFAI,GAAAN,EAAAR,EAAA,GAEA3kB,EAAA,EAAuBA,EAAA2kB,EAAA,EAAkB3kB,IACzC8kB,EACAlC,EAAAuC,EAAAnlB,GAAAylB,EAAA/C,IAGAS,MAAAgC,EAAAnlB,KAAAmjB,MAAAsC,IAAAT,GAAAD,IACAI,EAAAnlB,GAAAylB,EAIAX,IAAAlC,EAAA0B,EAAApD,EAAAwE,QAAArB,GAAAoB,EAAA/C,EAIA,IAEA9Y,GACA+b,EACAtD,EACAC,EACAgB,EACAC,EAPAqC,EAAA,EACAC,EAAA,CAQA,IAAAd,EACA,GAAAhB,IAAA,EAAA,EAAA,EAAA,EAGA,IAAA+B,GAAA,SAAAljB,EAAA2f,GAIA,GAAAwD,EAEA,IAAAxD,EAAA,EACAwD,EAAA,MAEA,IAAAxD,EAAAsD,EAAA,CAIA,IADAjc,EAAA0T,KAAArZ,IAAA2hB,EAAA,EAAAjB,EAAA,GACAoB,EAAAnc,EAAmCmc,GAAA,KACnCb,EAAAa,IAAAxD,GAD+CwD,KAM/CA,EAAAzI,KAAArZ,IAAA8hB,EAAApB,EAAA,OAEA,CACA,IAAAoB,EAAAH,EAAuCG,EAAApB,KACvCO,EAAAa,GAAAxD,GADyDwD,KAKzDA,EAAAzI,KAAArZ,IAAA8hB,EAAA,EAAApB,EAAA,GAEAiB,EAAAG,EACAF,EAAAtD,CAEA,IAAAyD,GAAAd,EAAAa,EAAA,GAAAb,EAAAa,EACA,IAAA,IAAAC,EAMA,GAFAL,GAAApD,EAAA2C,EAAAa,IAAAC,EAEAtB,EAKA,GAJApC,EAAA6C,EAAAY,GACA1D,EAAA8C,EAAA,IAAAY,EAAAA,EAAAA,EAAA,GACAzC,EAAA6B,EAAAY,EAAApB,EAAA,EAAAA,EAAA,EAAAoB,EAAA,GACAxC,EAAA4B,EAAAY,EAAApB,EAAA,EAAAA,EAAA,EAAAoB,EAAA,GACAjB,EACAzB,EACAhB,EAAAC,EAAAgB,EAAAC,EAAAoC,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EACArB,EAAA1hB,EAAAyhB,GACA3B,OAGA,CACA,GAAA/T,EACA,IAAAoW,EACApW,EAAA0U,EACAhB,EAAAC,EAAAgB,EAAAC,EAAAoC,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EACA5B,EAAA,GAEApV,EAAAmV,EAAAC,OAEA,CAAA,GAAAiB,EAEA,MAAAxC,GAAAF,EAAAgB,EAAAqC,EAGAhX,GAAA+U,EACArB,EAAAC,EAAAgB,EAAAC,EAAAoC,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,GAGAnB,EACA5hB,EACAyhB,EACA1V,OAKA,IAAAmW,EACArC,EACA0C,EAAAY,GAAAZ,EAAAY,EAAA,GAAAJ,EACArB,EAAA1hB,EAAAyhB,GACA3B,OAGA,CACA,GAAA/T,EACA,IAAAoW,EACAtC,EACA0C,EAAAY,GAAAZ,EAAAY,EAAA,GAAAJ,EACA5B,EAAA,GAEApV,EAAAmV,EAAAC,OAEA,CAAA,GAAAiB,EAEA,MAAAxC,GAAA2C,EAAAY,GAAAZ,EAAAY,EAAA,GAAAJ,EAGAhX,GAAAyT,EAAA+C,EAAAY,GAAAZ,EAAAY,EAAA,GAAAJ,GAEAnB,EACA5hB,EACAyhB,EACA1V,KAMAsX,EAAA,GAAAC,IACAtjB,OAAAse,EAAAwE,QACAS,KAAAvB,EACA9D,KAAAI,EAAAkF,MACA3E,MAAAP,EAAAmF,OACAP,QAAAA,EACAQ,UAAAnC,GAOA,OAJAzC,IAAA,WAAAA,IACAuE,EAAAvE,OAAAA,GAGAuE,IA5aA,GAAAC,GAAAppB,EAAA,IACAyoB,EAAAzoB,EAAA,IACAmB,EAAAnB,EAAA,GACAsS,EAAAnR,EAAAmR,YAEA8T,EAAAtQ,MAAApU,UAAAyS,MAkbAyP,EAAA,SAAA9d,EAAAke,EAAAwD,EAAAE,GACA5nB,KAAA2pB,WACA3pB,KAAA8oB,QAAA9iB,EAEAhG,KAAAwpB,MAAAtF,IAAA,EAEAlkB,KAAA2nB,QAAAD,GAAApC,EACAtlB,KAAA6nB,QAAAD,GAAArC,EAEAvlB,KAAA4pB,WAAA,EAEA5pB,KAAAypB,OAAA,EAEAzpB,KAAA6pB,aAEA7pB,KAAA8pB,gBAEA9pB,KAAA+pB,aAGAjG,GAAAliB,WAOAyjB,KAAA,SAAAT,EAAAQ,GACA,GAAA4E,GAAAhqB,KAAA2pB,OACA,KAAA,GAAAlC,KAAArC,GACA,GAAAA,EAAArZ,eAAA0b,GAAA,CAIA,IAAAuC,EAAAvC,GAAA,CACAuC,EAAAvC,KAEA,IAAA1V,GAAA/R,KAAA2nB,QAAA3nB,KAAA8oB,QAAArB,EACA,IAAA,MAAA1V,EAEA,QAMA,KAAA6S,GACAoF,EAAAvC,GAAAhkB,MACAmhB,KAAA,EACA7S,MAAAiV,EAAAjV,KAIAiY,EAAAvC,GAAAhkB,MACAmhB,KAAAA,EACA7S,MAAAqT,EAAAqC,KAGA,MAAAznB,OAOAukB,OAAA,SAAAQ,GAEA,MADA/kB,MAAA8pB,aAAArmB,KAAAshB,GACA/kB,MAGAiqB,MAAA,WACA,IAAA,GAAA7mB,GAAA,EAA2BA,EAAApD,KAAA+pB,UAAA7mB,OAA2BE,IACtDpD,KAAA+pB,UAAA3mB,GAAA6mB,OAEAjqB,MAAAkqB,SAAA,GAGAC,OAAA,WACA,IAAA,GAAA/mB,GAAA,EAA2BA,EAAApD,KAAA+pB,UAAA7mB,OAA2BE,IACtDpD,KAAA+pB,UAAA3mB,GAAA+mB,QAEAnqB,MAAAkqB,SAAA,GAGAE,SAAA,WACA,QAAApqB,KAAAkqB,SAGAG,cAAA,WAEArqB,KAAA2pB,WAEA3pB,KAAA+pB,UAAA7mB,OAAA,CAIA,KAAA,GAFAonB,GAAAtqB,KAAA6pB,UACAjZ,EAAA0Z,EAAApnB,OACAE,EAAA,EAA2BA,EAAAwN,EAASxN,IACpCknB,EAAAlnB,GAAA7C,KAAAP,OASAgN,MAAA,SAAA8X,GAEA,GAUAyF,GAVApe,EAAAnM,KACAwqB,EAAA,EAEAjD,EAAA,WACAiD,IACAA,GACAre,EAAAke,gBAKA,KAAA,GAAA5C,KAAAznB,MAAA2pB,QACA,GAAA3pB,KAAA2pB,QAAA5d,eAAA0b,GAAA,CAGA,GAAA4B,GAAA/B,EACAtnB,KAAA8kB,EAAAyC,EACAvnB,KAAA2pB,QAAAlC,GAAAA,EAEA4B,KACArpB,KAAA+pB,UAAAtmB,KAAA4lB,GACAmB,IAGAxqB,KAAA2M,WACA3M,KAAA2M,UAAA8d,QAAApB,GAGAkB,EAAAlB,GAKA,GAAAkB,EAAA,CACA,GAAAG,GAAAH,EAAArB,OACAqB,GAAArB,QAAA,SAAAljB,EAAA2f,GACA+E,EAAA1kB,EAAA2f,EAEA,KAAA,GAAAviB,GAAA,EAAmCA,EAAA+I,EAAA2d,aAAA5mB,OAA8BE,IACjE+I,EAAA2d,aAAA1mB,GAAA4C,EAAA2f,IAQA,MAHA6E,IACAxqB,KAAAqqB,gBAEArqB,MAMA4G,KAAA,SAAA8d,GAGA,IAAA,GAFAiG,GAAA3qB,KAAA+pB,UACApd,EAAA3M,KAAA2M,UACAvJ,EAAA,EAA2BA,EAAAunB,EAAAznB,OAAqBE,IAAA,CAChD,GAAAimB,GAAAsB,EAAAvnB,EACAshB,IAEA2E,EAAAH,QAAAlpB,KAAA8oB,QAAA,GAEAnc,GAAAA,EAAAie,WAAAvB,GAEAsB,EAAAznB,OAAA,GAOA2hB,MAAA,SAAAD,GAEA,MADA5kB,MAAAypB,OAAA7E,EACA5kB,MAOAwkB,KAAA,SAAA5R,GAIA,MAHAA,IACA5S,KAAA6pB,UAAApmB,KAAAmP,GAEA5S,MAMA6qB,SAAA,WACA,MAAA7qB,MAAA+pB,YAIAlqB,EAAAD,QAAAkkB,GlBiwIM,SAASjkB,EAAQD,EAASM,GmBt3JhC,QAAAopB,GAAAwB,GAEA9qB,KAAA8oB,QAAAgC,EAAA9kB,OAGAhG,KAAA+qB,MAAAD,EAAAvB,MAAA,IAEAvpB,KAAAypB,OAAAqB,EAAAjG,OAAA,EAGA7kB,KAAAgrB,cAAA,EAGAhrB,KAAAkkB,KAAA,MAAA4G,EAAA5G,MAAA4G,EAAA5G,KAEAlkB,KAAAirB,IAAAH,EAAAG,KAAA,EAEAjrB,KAAA8kB,OAAAgG,EAAAhG,QAAA,SAEA9kB,KAAAkpB,QAAA4B,EAAA5B,QACAlpB,KAAA0pB,UAAAoB,EAAApB,UACA1pB,KAAAkrB,UAAAJ,EAAAI,UAEAlrB,KAAAmrB,YAAA,EACAnrB,KAAAkqB,SAAA,EA1BA,GAAAkB,GAAAlrB,EAAA,GA6BAopB,GAAA1nB,WAEA+L,YAAA2b,EAEA+B,KAAA,SAAAC,EAAAC,GAQA,GALAvrB,KAAAgrB,eACAhrB,KAAAwrB,WAAAF,EAAAtrB,KAAAypB,OACAzpB,KAAAgrB,cAAA,GAGAhrB,KAAAkqB,QAEA,YADAlqB,KAAAmrB,aAAAI,EAIA,IAAA5F,IAAA2F,EAAAtrB,KAAAwrB,WAAAxrB,KAAAmrB,aAAAnrB,KAAA+qB,KAGA,MAAApF,EAAA,GAAA,CAIAA,EAAAjF,KAAArZ,IAAAse,EAAA,EAEA,IAAAb,GAAA9kB,KAAA8kB,OACA2G,EAAA,gBAAA3G,GAAAsG,EAAAtG,GAAAA,EACA4G,EAAA,kBAAAD,GACAA,EAAA9F,GACAA,CAKA,OAHA3lB,MAAA2rB,KAAA,QAAAD,GAGA,GAAA/F,EACA3lB,KAAAkkB,MACAlkB,KAAA4rB,QAAAN,GAGA,YAKAtrB,KAAA6rB,cAAA,EACA,WAGA,OAGAD,QAAA,SAAAN,GACA,GAAAQ,IAAAR,EAAAtrB,KAAAwrB,WAAAxrB,KAAAmrB,aAAAnrB,KAAA+qB,KACA/qB,MAAAwrB,WAAAF,EAAAQ,EAAA9rB,KAAAirB,IACAjrB,KAAAmrB,YAAA,EAEAnrB,KAAA6rB,cAAA,GAGAF,KAAA,SAAAI,EAAAC,GACAD,EAAA,KAAAA,EACA/rB,KAAA+rB,IACA/rB,KAAA+rB,GAAA/rB,KAAA8oB,QAAAkD,IAIA/B,MAAA,WACAjqB,KAAAkqB,SAAA,GAGAC,OAAA,WACAnqB,KAAAkqB,SAAA,IAIArqB,EAAAD,QAAA0pB,GnBg5JM,SAASzpB,EAAQD,GoBngKvB,GAAAklB,IAKAmH,OAAA,SAAAC,GACA,MAAAA,IAOAC,YAAA,SAAAD,GACA,MAAAA,GAAAA,GAMAE,aAAA,SAAAF,GACA,MAAAA,IAAA,EAAAA,IAMAG,eAAA,SAAAH,GACA,OAAAA,GAAA,GAAA,EACA,GAAAA,EAAAA,SAEAA,GAAAA,EAAA,GAAA,IAQAI,QAAA,SAAAJ,GACA,MAAAA,GAAAA,EAAAA,GAMAK,SAAA,SAAAL,GACA,QAAAA,EAAAA,EAAAA,EAAA,GAMAM,WAAA,SAAAN,GACA,OAAAA,GAAA,GAAA,EACA,GAAAA,EAAAA,EAAAA,EAEA,KAAAA,GAAA,GAAAA,EAAAA,EAAA,IAQAO,UAAA,SAAAP,GACA,MAAAA,GAAAA,EAAAA,EAAAA,GAMAQ,WAAA,SAAAR,GACA,MAAA,MAAAA,EAAAA,EAAAA,EAAAA,GAMAS,aAAA,SAAAT,GACA,OAAAA,GAAA,GAAA,EACA,GAAAA,EAAAA,EAAAA,EAAAA,QAEAA,GAAA,GAAAA,EAAAA,EAAAA,EAAA,IAQAU,UAAA,SAAAV,GACA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,GAMAW,WAAA,SAAAX,GACA,QAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAA,GAMAY,aAAA,SAAAZ,GACA,OAAAA,GAAA,GAAA,EACA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAEA,KAAAA,GAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAA,IAQAa,aAAA,SAAAb,GACA,MAAA,GAAAxL,KAAA8B,IAAA0J,EAAAxL,KAAAsM,GAAA,IAMAC,cAAA,SAAAf,GACA,MAAAxL,MAAA4B,IAAA4J,EAAAxL,KAAAsM,GAAA,IAMAE,gBAAA,SAAAhB,GACA,MAAA,IAAA,EAAAxL,KAAA8B,IAAA9B,KAAAsM,GAAAd,KAQAiB,cAAA,SAAAjB,GACA,MAAA,KAAAA,EAAA,EAAAxL,KAAA0M,IAAA,KAAAlB,EAAA,IAMAmB,eAAA,SAAAnB,GACA,MAAA,KAAAA,EAAA,EAAA,EAAAxL,KAAA0M,IAAA,MAAAlB,IAMAoB,iBAAA,SAAApB,GACA,MAAA,KAAAA,EACA,EAEA,IAAAA,EACA,GAEAA,GAAA,GAAA,EACA,GAAAxL,KAAA0M,IAAA,KAAAlB,EAAA,GAEA,KAAAxL,KAAA0M,IAAA,OAAAlB,EAAA,IAAA,IAQAqB,WAAA,SAAArB,GACA,MAAA,GAAAxL,KAAAC,KAAA,EAAAuL,EAAAA,IAMAsB,YAAA,SAAAtB,GACA,MAAAxL,MAAAC,KAAA,KAAAuL,EAAAA,IAMAuB,cAAA,SAAAvB,GACA,OAAAA,GAAA,GAAA,OACAxL,KAAAC,KAAA,EAAAuL,EAAAA,GAAA,GAEA,IAAAxL,KAAAC,KAAA,GAAAuL,GAAA,GAAAA,GAAA,IAQAwB,UAAA,SAAAxB,GACA,GAAA/I,GACAjI,EAAA,GACAxa,EAAA,EACA,OAAA,KAAAwrB,EACA,EAEA,IAAAA,EACA,IAEAhR,GAAAA,EAAA,GACAA,EAAA,EAAsBiI,EAAAziB,EAAA,GAGtByiB,EAAAziB,EAAAggB,KAAAiN,KAAA,EAAAzS,IAAA,EAAAwF,KAAAsM,MAEA9R,EAAAwF,KAAA0M,IAAA,EAAA,IAAAlB,GAAA,IACAxL,KAAA4B,KAAA4J,EAAA/I,IAAA,EAAAzC,KAAAsM,IAAAtsB,MAMAktB,WAAA,SAAA1B,GACA,GAAA/I,GACAjI,EAAA,GACAxa,EAAA,EACA,OAAA,KAAAwrB,EACA,EAEA,IAAAA,EACA,IAEAhR,GAAAA,EAAA,GACAA,EAAA,EAAsBiI,EAAAziB,EAAA,GAGtByiB,EAAAziB,EAAAggB,KAAAiN,KAAA,EAAAzS,IAAA,EAAAwF,KAAAsM,IAEA9R,EAAAwF,KAAA0M,IAAA,MAAAlB,GACAxL,KAAA4B,KAAA4J,EAAA/I,IAAA,EAAAzC,KAAAsM,IAAAtsB,GAAA,IAMAmtB,aAAA,SAAA3B,GACA,GAAA/I,GACAjI,EAAA,GACAxa,EAAA,EACA,OAAA,KAAAwrB,EACA,EAEA,IAAAA,EACA,IAEAhR,GAAAA,EAAA,GACAA,EAAA,EAAsBiI,EAAAziB,EAAA,GAGtByiB,EAAAziB,EAAAggB,KAAAiN,KAAA,EAAAzS,IAAA,EAAAwF,KAAAsM,KAEAd,GAAA,GAAA,OACAhR,EAAAwF,KAAA0M,IAAA,EAAA,IAAAlB,GAAA,IACAxL,KAAA4B,KAAA4J,EAAA/I,IAAA,EAAAzC,KAAAsM,IAAAtsB,IAEAwa,EAAAwF,KAAA0M,IAAA,OAAAlB,GAAA,IACAxL,KAAA4B,KAAA4J,EAAA/I,IAAA,EAAAzC,KAAAsM,IAAAtsB,GAAA,GAAA,IASAotB,OAAA,SAAA5B,GACA,GAAA/I,GAAA,OACA,OAAA+I,GAAAA,IAAA/I,EAAA,GAAA+I,EAAA/I,IAMA4K,QAAA,SAAA7B,GACA,GAAA/I,GAAA,OACA,SAAA+I,EAAAA,IAAA/I,EAAA,GAAA+I,EAAA/I,GAAA,GAMA6K,UAAA,SAAA9B,GACA,GAAA/I,GAAA,SACA,QAAA+I,GAAA,GAAA,EACA,IAAAA,EAAAA,IAAA/I,EAAA,GAAA+I,EAAA/I,IAEA,KAAA+I,GAAA,GAAAA,IAAA/I,EAAA,GAAA+I,EAAA/I,GAAA,IAQA8K,SAAA,SAAA/B,GACA,MAAA,GAAApH,EAAAoJ,UAAA,EAAAhC,IAMAgC,UAAA,SAAAhC,GACA,MAAAA,GAAA,EAAA,KACA,OAAAA,EAAAA,EAEAA,EAAA,EAAA,KACA,QAAAA,GAAA,IAAA,MAAAA,EAAA,IAEAA,EAAA,IAAA,KACA,QAAAA,GAAA,KAAA,MAAAA,EAAA,MAGA,QAAAA,GAAA,MAAA,MAAAA,EAAA,SAOAiC,YAAA,SAAAjC,GACA,MAAAA,GAAA,GACA,GAAApH,EAAAmJ,SAAA,EAAA/B,GAEA,GAAApH,EAAAoJ,UAAA,EAAAhC,EAAA,GAAA,IAIArsB,GAAAD,QAAAklB,GpBkhKM,SAASjlB,EAAQD,EAASM,GqBpxKhC,QAAAkuB,GAAAhrB,GAEA,MADAA,GAAAsd,KAAA2N,MAAAjrB,GACAA,EAAA,EAAA,EAAAA,EAAA,IAAA,IAAAA,EAGA,QAAAkrB,GAAAlrB,GAEA,MADAA,GAAAsd,KAAA2N,MAAAjrB,GACAA,EAAA,EAAA,EAAAA,EAAA,IAAA,IAAAA,EAGA,QAAAmrB,GAAAC,GACA,MAAAA,GAAA,EAAA,EAAAA,EAAA,EAAA,EAAAA,EAGA,QAAAC,GAAAC,GACA,MACAN,GADAM,EAAAxrB,QAAA,MAAAwrB,EAAAC,OAAAD,EAAAxrB,OAAA,GACA0rB,WAAAF,GAAA,IAAA,IAEAG,SAAAH,EAAA,KAGA,QAAAI,GAAAJ,GACA,MACAH,GADAG,EAAAxrB,QAAA,MAAAwrB,EAAAC,OAAAD,EAAAxrB,OAAA,GACA0rB,WAAAF,GAAA,IAEAE,WAAAF,IAGA,QAAAK,GAAA3N,EAAAC,EAAA5G,GAQA,MAPAA,GAAA,EACAA,GAAA,EAEAA,EAAA,IACAA,GAAA,GAGA,EAAAA,EAAA,EACA2G,GAAAC,EAAAD,GAAA3G,EAAA,EAEA,EAAAA,EAAA,EACA4G,EAEA,EAAA5G,EAAA,EACA2G,GAAAC,EAAAD,IAAA,EAAA,EAAA3G,GAAA,EAEA2G,EAGA,QAAAqC,GAAAvI,EAAAC,EAAAza,GACA,MAAAwa,IAAAC,EAAAD,GAAAxa,EAGA,QAAAsuB,GAAA7N,EAAA8N,EAAAC,EAAA/T,EAAAD,GAEA,MADAiG,GAAA,GAAA8N,EAAmB9N,EAAA,GAAA+N,EAAY/N,EAAA,GAAAhG,EAAYgG,EAAA,GAAAjG,EAC3CiG,EAEA,QAAAgO,GAAAhO,EAAAjG,GAEA,MADAiG,GAAA,GAAAjG,EAAA,GAAsBiG,EAAA,GAAAjG,EAAA,GAAeiG,EAAA,GAAAjG,EAAA,GAAeiG,EAAA,GAAAjG,EAAA,GACpDiG,EAIA,QAAAiO,GAAAC,EAAAC,GAEAC,GACAJ,EAAAI,EAAAD,GAEAC,EAAAC,EAAAC,IAAAJ,EAAAE,GAAAD,EAAAjb,SAQA,QAAAuU,GAAAyG,EAAAC,GACA,GAAAD,EAAA,CAGAC,EAAAA,KAEA,IAAAI,GAAAF,EAAAhiB,IAAA6hB,EACA,IAAAK,EACA,MAAAP,GAAAG,EAAAI,EAIAL,IAAA,EAEA,IAAAX,GAAAW,EAAAM,QAAA,KAAA,IAAAC,aAGA,IAAAlB,IAAAmB,GAGA,MAFAV,GAAAG,EAAAO,EAAAnB,IACAU,EAAAC,EAAAC,GACAA,CAIA,IAAA,MAAAZ,EAAAC,OAAA,GAAA,CAkCA,GAAAmB,GAAApB,EAAAjlB,QAAA,KAAAsmB,EAAArB,EAAAjlB,QAAA,IACA,IAAAqmB,QAAAC,EAAA,IAAArB,EAAAxrB,OAAA,CACA,GAAA8sB,GAAAtB,EAAAuB,OAAA,EAAAH,GACAI,EAAAxB,EAAAuB,OAAAH,EAAA,EAAAC,GAAAD,EAAA,IAAAzL,MAAA,KACA8L,EAAA,CACA,QAAAH,GACA,IAAA,OACA,GAAA,IAAAE,EAAAhtB,OAEA,WADA8rB,GAAAM,EAAA,EAAA,EAAA,EAAA,EAGAa,GAAArB,EAAAoB,EAAAE,MAEA,KAAA,MACA,MAAA,KAAAF,EAAAhtB,WACA8rB,GAAAM,EAAA,EAAA,EAAA,EAAA,IAGAN,EAAAM,EACAb,EAAAyB,EAAA,IACAzB,EAAAyB,EAAA,IACAzB,EAAAyB,EAAA,IACAC,GAEAf,EAAAC,EAAAC,GACAA,EACA,KAAA,OACA,MAAA,KAAAY,EAAAhtB,WACA8rB,GAAAM,EAAA,EAAA,EAAA,EAAA,IAGAY,EAAA,GAAApB,EAAAoB,EAAA,IACAG,EAAAH,EAAAZ,GACAF,EAAAC,EAAAC,GACAA,EACA,KAAA,MACA,MAAA,KAAAY,EAAAhtB,WACA8rB,GAAAM,EAAA,EAAA,EAAA,EAAA,IAGAe,EAAAH,EAAAZ,GACAF,EAAAC,EAAAC,GACAA,EACA,SACA,QAIAN,EAAAM,EAAA,EAAA,EAAA,EAAA,OAlFA,CACA,GAAA,IAAAZ,EAAAxrB,OAAA,CACA,GAAAotB,GAAAzB,SAAAH,EAAAuB,OAAA,GAAA,GACA,OAAAK,IAAA,GAAAA,GAAA,MAIAtB,EAAAM,GACA,KAAAgB,IAAA,GAAA,KAAAA,IAAA,EACA,IAAAA,GAAA,IAAAA,IAAA,EACA,GAAAA,GAAA,GAAAA,IAAA,EACA,GAEAlB,EAAAC,EAAAC,GACAA,OAVAN,GAAAM,EAAA,EAAA,EAAA,EAAA,GAYA,GAAA,IAAAZ,EAAAxrB,OAAA,CACA,GAAAotB,GAAAzB,SAAAH,EAAAuB,OAAA,GAAA,GACA,OAAAK,IAAA,GAAAA,GAAA,UAIAtB,EAAAM,GACA,SAAAgB,IAAA,IACA,MAAAA,IAAA,EACA,IAAAA,EACA,GAEAlB,EAAAC,EAAAC,GACAA,OAVAN,GAAAM,EAAA,EAAA,EAAA,EAAA,MAwEA,QAAAe,GAAAE,EAAApJ,GACA,GAAA1M,IAAAmU,WAAA2B,EAAA,IAAA,IAAA,KAAA,IAAA,IAGApN,EAAA2L,EAAAyB,EAAA,IACA1V,EAAAiU,EAAAyB,EAAA,IACAlP,EAAAxG,GAAA,GAAAA,GAAAsI,EAAA,GAAAtI,EAAAsI,EAAAtI,EAAAsI,EACA/B,EAAA,EAAAvG,EAAAwG,CAcA,OAZA8F,GAAAA,MACA6H,EAAA7H,EACAiH,EAAA,IAAAW,EAAA3N,EAAAC,EAAA5G,EAAA,EAAA,IACA2T,EAAA,IAAAW,EAAA3N,EAAAC,EAAA5G,IACA2T,EAAA,IAAAW,EAAA3N,EAAAC,EAAA5G,EAAA,EAAA,IACA,GAGA,IAAA8V,EAAArtB,SACAikB,EAAA,GAAAoJ,EAAA,IAGApJ,EAOA,QAAAqJ,GAAArJ,GACA,GAAAA,EAAA,CAKA,GASAsJ,GACAC,EAVAC,EAAAxJ,EAAA,GAAA,IACAyJ,EAAAzJ,EAAA,GAAA,IACA0J,EAAA1J,EAAA,GAAA,IAEA2J,EAAApQ,KAAArZ,IAAAspB,EAAAC,EAAAC,GACAE,EAAArQ,KAAApZ,IAAAqpB,EAAAC,EAAAC,GACAG,EAAAD,EAAAD,EAEAG,GAAAF,EAAAD,GAAA,CAIA,IAAA,IAAAE,EACAP,EAAA,EACAC,EAAA,MAEA,CAEAA,EADAO,EAAA,GACAD,GAAAD,EAAAD,GAGAE,GAAA,EAAAD,EAAAD,EAGA,IAAAI,KAAAH,EAAAJ,GAAA,EAAAK,EAAA,GAAAA,EACAG,IAAAJ,EAAAH,GAAA,EAAAI,EAAA,GAAAA,EACAI,IAAAL,EAAAF,GAAA,EAAAG,EAAA,GAAAA,CAEAL,KAAAI,EACAN,EAAAW,EAAAD,EAEAP,IAAAG,EACAN,EAAA,EAAA,EAAAS,EAAAE,EAEAP,IAAAE,IACAN,EAAA,EAAA,EAAAU,EAAAD,GAGAT,EAAA,IACAA,GAAA,GAGAA,EAAA,IACAA,GAAA,GAIA,GAAAF,IAAA,IAAAE,EAAAC,EAAAO,EAMA,OAJA,OAAA9J,EAAA,IACAoJ,EAAA9sB,KAAA0jB,EAAA,IAGAoJ,GASA,QAAAc,GAAA1I,EAAAjmB,GACA,GAAA4uB,GAAA1I,EAAAD,EACA,IAAA2I,EAAA,CACA,IAAA,GAAAluB,GAAA,EAA2BA,EAAA,EAAOA,IAClCV,EAAA,EACA4uB,EAAAluB,GAAAkuB,EAAAluB,IAAA,EAAAV,GAAA,EAGA4uB,EAAAluB,IAAA,IAAAkuB,EAAAluB,IAAAV,EAAA4uB,EAAAluB,GAAA,CAGA,OAAAmuB,GAAAD,EAAA,IAAAA,EAAApuB,OAAA,OAAA,QASA,QAAAsuB,GAAA7I,EAAAjmB,GACA,GAAA4uB,GAAA1I,EAAAD,EACA,IAAA2I,EACA,QAAA,GAAA,KAAAA,EAAA,IAAA,KAAAA,EAAA,IAAA,KAAAA,EAAA,IAAAxb,SAAA,IAAAzB,MAAA,GAWA,QAAAod,GAAAC,EAAAC,EAAAxQ,GAEA,GADAA,EAAAA,IAAA,EAAA,EAAA,EAAA,IACAwQ,IAAAA,EAAAzuB,UACAwuB,GAAA,GAAAA,GAAA,GAEA,MAAAvQ,EAEA,IAAApP,GAAA2f,GAAAC,EAAAzuB,OAAA,GACA0uB,EAAAlR,KAAA0G,MAAArV,GACA8f,EAAAnR,KAAAoR,KAAA/f,GACAggB,EAAAJ,EAAAC,GACAI,EAAAL,EAAAE,GACAI,EAAAlgB,EAAA6f,CAKA,OAJAzQ,GAAA,GAAAiN,EAAA3K,EAAAsO,EAAA,GAAAC,EAAA,GAAAC,IACA9Q,EAAA,GAAAiN,EAAA3K,EAAAsO,EAAA,GAAAC,EAAA,GAAAC,IACA9Q,EAAA,GAAAiN,EAAA3K,EAAAsO,EAAA,GAAAC,EAAA,GAAAC,IACA9Q,EAAA,GAAAoN,EAAA9K,EAAAsO,EAAA,GAAAC,EAAA,GAAAC,IACA9Q,EAUA,QAAA+Q,GAAAR,EAAAC,EAAAQ,GACA,GAAAR,GAAAA,EAAAzuB,QACAwuB,GAAA,GAAAA,GAAA,EADA,CAMA,GAAA3f,GAAA2f,GAAAC,EAAAzuB,OAAA,GACA0uB,EAAAlR,KAAA0G,MAAArV,GACA8f,EAAAnR,KAAAoR,KAAA/f,GACAggB,EAAAnJ,EAAA+I,EAAAC,IACAI,EAAApJ,EAAA+I,EAAAE,IACAI,EAAAlgB,EAAA6f,EAEAjJ,EAAA4I,GAEAnD,EAAA3K,EAAAsO,EAAA,GAAAC,EAAA,GAAAC,IACA7D,EAAA3K,EAAAsO,EAAA,GAAAC,EAAA,GAAAC,IACA7D,EAAA3K,EAAAsO,EAAA,GAAAC,EAAA,GAAAC,IACA1D,EAAA9K,EAAAsO,EAAA,GAAAC,EAAA,GAAAC,KAEA,OAGA,OAAAE,IAEAxJ,MAAAA,EACAiJ,UAAAA,EACAC,WAAAA,EACA9f,MAAAA,GAEA4W,GAWA,QAAAyJ,GAAAzJ,EAAAlO,EAAA0I,EAAAtI,GAGA,GAFA8N,EAAAC,EAAAD,GAQA,MALAA,GAAA6H,EAAA7H,GACA,MAAAlO,IAAAkO,EAAA,GAAA2F,EAAA7T,IACA,MAAA0I,IAAAwF,EAAA,GAAAmG,EAAA3L,IACA,MAAAtI,IAAA8N,EAAA,GAAAmG,EAAAjU,IAEA0W,EAAAlB,EAAA1H,GAAA,QAUA,QAAA0J,GAAA1J,EAAAwH,GAGA,GAFAxH,EAAAC,EAAAD,GAEAA,GAAA,MAAAwH,EAEA,MADAxH,GAAA,GAAA4F,EAAA4B,GACAoB,EAAA5I,EAAA,QASA,QAAA4I,GAAAe,EAAA5sB,GACA,GAAA4sB,EAAA,CAGA,GAAAjD,GAAAiD,EAAA,GAAA,IAAAA,EAAA,GAAA,IAAAA,EAAA,EAIA,OAHA,SAAA5sB,GAAA,SAAAA,GAAA,SAAAA,IACA2pB,GAAA,IAAAiD,EAAA,IAEA5sB,EAAA,IAAA2pB,EAAA,KA7fA,GAAAkD,GAAAryB,EAAA,IAEA2vB,GACA2C,aAAA,EAAA,EAAA,EAAA,GAAAC,WAAA,IAAA,IAAA,IAAA,GACAC,cAAA,IAAA,IAAA,IAAA,GAAAC,MAAA,EAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GAAAC,OAAA,IAAA,IAAA,IAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GAAAC,QAAA,IAAA,IAAA,IAAA,GACAC,OAAA,EAAA,EAAA,EAAA,GAAAC,gBAAA,IAAA,IAAA,IAAA,GACAC,MAAA,EAAA,EAAA,IAAA,GAAAC,YAAA,IAAA,GAAA,IAAA,GACAC,OAAA,IAAA,GAAA,GAAA,GAAAC,WAAA,IAAA,IAAA,IAAA,GACAC,WAAA,GAAA,IAAA,IAAA,GAAAC,YAAA,IAAA,IAAA,EAAA,GACAC,WAAA,IAAA,IAAA,GAAA,GAAAC,OAAA,IAAA,IAAA,GAAA,GACAC,gBAAA,IAAA,IAAA,IAAA,GAAAC,UAAA,IAAA,IAAA,IAAA,GACAC,SAAA,IAAA,GAAA,GAAA,GAAAC,MAAA,EAAA,IAAA,IAAA,GACAC,UAAA,EAAA,EAAA,IAAA,GAAAC,UAAA,EAAA,IAAA,IAAA,GACAC,eAAA,IAAA,IAAA,GAAA,GAAAC,UAAA,IAAA,IAAA,IAAA,GACAC,WAAA,EAAA,IAAA,EAAA,GAAAC,UAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GAAAC,aAAA,IAAA,EAAA,IAAA,GACAC,gBAAA,GAAA,IAAA,GAAA,GAAAC,YAAA,IAAA,IAAA,EAAA,GACAC,YAAA,IAAA,GAAA,IAAA,GAAAC,SAAA,IAAA,EAAA,EAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GAAAC,cAAA,IAAA,IAAA,IAAA,GACAC,eAAA,GAAA,GAAA,IAAA,GAAAC,eAAA,GAAA,GAAA,GAAA,GACAC,eAAA,GAAA,GAAA,GAAA,GAAAC,eAAA,EAAA,IAAA,IAAA,GACAC,YAAA,IAAA,EAAA,IAAA,GAAAC,UAAA,IAAA,GAAA,IAAA,GACAC,aAAA,EAAA,IAAA,IAAA,GAAAC,SAAA,IAAA,IAAA,IAAA,GACAC,SAAA,IAAA,IAAA,IAAA,GAAAC,YAAA,GAAA,IAAA,IAAA,GACAC,WAAA,IAAA,GAAA,GAAA,GAAAC,aAAA,IAAA,IAAA,IAAA,GACAC,aAAA,GAAA,IAAA,GAAA,GAAAC,SAAA,IAAA,EAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GAAAC,YAAA,IAAA,IAAA,IAAA,GACAC,MAAA,IAAA,IAAA,EAAA,GAAAC,WAAA,IAAA,IAAA,GAAA,GACAC,MAAA,IAAA,IAAA,IAAA,GAAAC,OAAA,EAAA,IAAA,EAAA,GACAC,aAAA,IAAA,IAAA,GAAA,GAAAC,MAAA,IAAA,IAAA,IAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GAAAC,SAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,GAAA,GAAA,GAAAC,QAAA,GAAA,EAAA,IAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GAAAC,OAAA,IAAA,IAAA,IAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GAAAC,eAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,EAAA,GAAAC,cAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GAAAC,YAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GAAAC,sBAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GAAAC,YAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GAAAC,WAAA,IAAA,IAAA,IAAA,GACAC,aAAA,IAAA,IAAA,IAAA,GAAAC,eAAA,GAAA,IAAA,IAAA,GACAC,cAAA,IAAA,IAAA,IAAA,GAAAC,gBAAA,IAAA,IAAA,IAAA,GACAC,gBAAA,IAAA,IAAA,IAAA,GAAAC,gBAAA,IAAA,IAAA,IAAA,GACAC,aAAA,IAAA,IAAA,IAAA,GAAAC,MAAA,EAAA,IAAA,EAAA,GACAC,WAAA,GAAA,IAAA,GAAA,GAAAC,OAAA,IAAA,IAAA,IAAA,GACAC,SAAA,IAAA,EAAA,IAAA,GAAAC,QAAA,IAAA,EAAA,EAAA,GACAC,kBAAA,IAAA,IAAA,IAAA,GAAAC,YAAA,EAAA,EAAA,IAAA,GACAC,cAAA,IAAA,GAAA,IAAA,GAAAC,cAAA,IAAA,IAAA,IAAA,GACAC,gBAAA,GAAA,IAAA,IAAA,GAAAC,iBAAA,IAAA,IAAA,IAAA,GACAC,mBAAA,EAAA,IAAA,IAAA,GAAAC,iBAAA,GAAA,IAAA,IAAA,GACAC,iBAAA,IAAA,GAAA,IAAA,GAAAC,cAAA,GAAA,GAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GAAAC,WAAA,IAAA,IAAA,IAAA,GACAC,UAAA,IAAA,IAAA,IAAA,GAAAC,aAAA,IAAA,IAAA,IAAA,GACAC,MAAA,EAAA,EAAA,IAAA,GAAAC,SAAA,IAAA,IAAA,IAAA,GACAC,OAAA,IAAA,IAAA,EAAA,GAAAC,WAAA,IAAA,IAAA,GAAA,GACAC,QAAA,IAAA,IAAA,EAAA,GAAAC,WAAA,IAAA,GAAA,EAAA,GACAC,QAAA,IAAA,IAAA,IAAA,GAAAC,eAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GAAAC,eAAA,IAAA,IAAA,IAAA,GACAC,eAAA,IAAA,IAAA,IAAA,GAAAC,YAAA,IAAA,IAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GAAAC,MAAA,IAAA,IAAA,GAAA,GACAC,MAAA,IAAA,IAAA,IAAA,GAAAC,MAAA,IAAA,IAAA,IAAA,GACAC,YAAA,IAAA,IAAA,IAAA,GAAAC,QAAA,IAAA,EAAA,IAAA,GACAC,KAAA,IAAA,EAAA,EAAA,GAAAC,WAAA,IAAA,IAAA,IAAA,GACAC,WAAA,GAAA,IAAA,IAAA,GAAAC,aAAA,IAAA,GAAA,GAAA,GACAC,QAAA,IAAA,IAAA,IAAA,GAAAC,YAAA,IAAA,IAAA,GAAA,GACAC,UAAA,GAAA,IAAA,GAAA,GAAAC,UAAA,IAAA,IAAA,IAAA,GACAC,QAAA,IAAA,GAAA,GAAA,GAAAC,QAAA,IAAA,IAAA,IAAA,GACAC,SAAA,IAAA,IAAA,IAAA,GAAAC,WAAA,IAAA,GAAA,IAAA,GACAC,WAAA,IAAA,IAAA,IAAA,GAAAC,WAAA,IAAA,IAAA,IAAA,GACAC,MAAA,IAAA,IAAA,IAAA,GAAAC,aAAA,EAAA,IAAA,IAAA,GACAC,WAAA,GAAA,IAAA,IAAA,GAAAC,KAAA,IAAA,IAAA,IAAA,GACAC,MAAA,EAAA,IAAA,IAAA,GAAAC,SAAA,IAAA,IAAA,IAAA,GACAC,QAAA,IAAA,GAAA,GAAA,GAAAC,WAAA,GAAA,IAAA,IAAA,GACAC,QAAA,IAAA,IAAA,IAAA,GAAAC,OAAA,IAAA,IAAA,IAAA,GACAC,OAAA,IAAA,IAAA,IAAA,GAAAC,YAAA,IAAA,IAAA,IAAA,GACAC,QAAA,IAAA,IAAA,EAAA,GAAAC,aAAA,IAAA,IAAA,GAAA,IA+DAnM,EAAA,GAAA+C,GAAA,IACAhD,EAAA,IAoXA1vB,GAAAD,SACAgpB,MAAAA,EACAyI,KAAAA,EACAG,MAAAA,EACAC,eAAAA,EACAS,WAAAA,EACAE,UAAAA,EACAC,YAAAA,EACAd,UAAAA,IrBk3KM,SAAS1xB,EAAQD,GsBv3LvB,GAAAg8B,GAAA,WAKA57B,KAAA67B,KAAA,KAKA77B,KAAA87B,KAAA,KAEA97B,KAAA+7B,KAAA,GAGAC,EAAAJ,EAAAh6B,SAMAo6B,GAAAC,OAAA,SAAA5c,GACA,GAAA6c,GAAA,GAAAC,GAAA9c,EAEA,OADArf,MAAAo8B,YAAAF,GACAA,GAOAF,EAAAI,YAAA,SAAAF,GACAl8B,KAAA67B,MAIA77B,KAAA87B,KAAAx4B,KAAA44B,EACAA,EAAAG,KAAAr8B,KAAA87B,KACAI,EAAA54B,KAAA,KACAtD,KAAA87B,KAAAI,GANAl8B,KAAA67B,KAAA77B,KAAA87B,KAAAI,EAQAl8B,KAAA+7B,QAOAC,EAAAluB,OAAA,SAAAouB,GACA,GAAAG,GAAAH,EAAAG,KACA/4B,EAAA44B,EAAA54B,IACA+4B,GACAA,EAAA/4B,KAAAA,EAIAtD,KAAA67B,KAAAv4B,EAEAA,EACAA,EAAA+4B,KAAAA,EAIAr8B,KAAA87B,KAAAO,EAEAH,EAAA54B,KAAA44B,EAAAG,KAAA,KACAr8B,KAAA+7B,QAMAC,EAAAprB,IAAA,WACA,MAAA5Q,MAAA+7B,MAMAC,EAAAv2B,MAAA,WACAzF,KAAA67B,KAAA77B,KAAA87B,KAAA,KACA97B,KAAA+7B,KAAA,EAOA,IAAAI,GAAA,SAAA9c,GAIArf,KAAA+R,MAAAsN,EAKArf,KAAAsD,KAKAtD,KAAAq8B,MAQA9J,EAAA,SAAA+J,GAEAt8B,KAAAu8B,MAAA,GAAAX,GAEA57B,KAAAw8B,QAEAx8B,KAAAy8B,SAAAH,GAAA,GAEAt8B,KAAA08B,kBAAA,MAGAC,EAAApK,EAAA3wB,SAOA+6B,GAAAlN,IAAA,SAAA9kB,EAAAoH,GACA,GAAAkH,GAAAjZ,KAAAu8B,MACAxpB,EAAA/S,KAAAw8B,KACAI,EAAA,IACA,IAAA,MAAA7pB,EAAApI,GAAA,CACA,GAAAiG,GAAAqI,EAAArI,MAEAsrB,EAAAl8B,KAAA08B,iBAEA,IAAA9rB,GAAA5Q,KAAAy8B,UAAA7rB,EAAA,EAAA,CAEA,GAAAisB,GAAA5jB,EAAA4iB,IACA5iB,GAAAnL,OAAA+uB,SACA9pB,GAAA8pB,EAAAlyB,KAEAiyB,EAAAC,EAAA9qB,MACA/R,KAAA08B,kBAAAG,EAGAX,EACAA,EAAAnqB,MAAAA,EAGAmqB,EAAA,GAAAC,GAAApqB,GAEAmqB,EAAAvxB,IAAAA,EACAsO,EAAAmjB,YAAAF,GACAnpB,EAAApI,GAAAuxB,EAGA,MAAAU,IAOAD,EAAAnvB,IAAA,SAAA7C,GACA,GAAAuxB,GAAAl8B,KAAAw8B,KAAA7xB,GACAsO,EAAAjZ,KAAAu8B,KACA,IAAA,MAAAL,EAOA,MALAA,KAAAjjB,EAAA6iB,OACA7iB,EAAAnL,OAAAouB,GACAjjB,EAAAmjB,YAAAF,IAGAA,EAAAnqB,OAOA4qB,EAAAl3B,MAAA,WACAzF,KAAAu8B,MAAA92B,QACAzF,KAAAw8B,SAGA38B,EAAAD,QAAA2yB,GtBs4LM,SAAS1yB,EAAQD,EAASM,GuBxkMhC,GAAAgO,GAAAhO,EAAA,GAMAL,GAAAD,QAAA,WACA,GAAA,IAAAsO,EAAA4uB,UAGA,GAAA,GAAA5uB,EAAA4uB,UACA,IAAA,GAAA5Q,KAAAxY,WACA,KAAA,IAAArJ,OAAAqJ,UAAAwY,QAGA,IAAAhe,EAAA4uB,UAAA,EACA,IAAA,GAAA5Q,KAAAxY,WACAqpB,QAAAhZ,IAAArQ,UAAAwY,MvB6lMM,SAASrsB,EAAQD,GwB9mMvB,GAAAiP,GAAA,CAEA,oBAAAsB,UACAtB,EAAA6R,KAAApZ,IAAA6I,OAAA/O,kBAAA,EAAA,GAOA,IAAA8M,IAOA4uB,UAAA,EAGA17B,iBAAAyN,EAEAhP,GAAAD,QAAAsO,GxBwnMM,SAASrO,EAAQD,EAASM,GyB/oMhC,YAeA,SAAAqd,GAAAhb,EAAAE,EAAAsB,EAAAM,GAEAN,EAAA,IACAxB,GAAAwB,EACAA,GAAAA,GAEAM,EAAA,IACA5B,GAAA4B,EACAA,GAAAA,GAMArE,KAAAuC,EAAAA,EAIAvC,KAAAyC,EAAAA,EAIAzC,KAAA+D,MAAAA,EAIA/D,KAAAqE,OAAAA,EAnCA,GAAA24B,GAAA98B,EAAA,IACAqf,EAAArf,EAAA,IAEA+8B,EAAAD,EAAA1e,eACA4e,EAAAxc,KAAArZ,IACA81B,EAAAzc,KAAApZ,GAiCAiW,GAAA3b,WAEA+L,YAAA4P,EAKAgB,MAAA,SAAA6e,GACA,GAAA76B,GAAA26B,EAAAE,EAAA76B,EAAAvC,KAAAuC,GACAE,EAAAy6B,EAAAE,EAAA36B,EAAAzC,KAAAyC,EAEAzC,MAAA+D,MAAAo5B,EACAC,EAAA76B,EAAA66B,EAAAr5B,MACA/D,KAAAuC,EAAAvC,KAAA+D,OACAxB,EACAvC,KAAAqE,OAAA84B,EACAC,EAAA36B,EAAA26B,EAAA/4B,OACArE,KAAAyC,EAAAzC,KAAAqE,QACA5B,EACAzC,KAAAuC,EAAAA,EACAvC,KAAAyC,EAAAA,GAOA6b,eAAA,WACA,GAAA+e,MACAC,KACAC,KACAC,IACA,OAAA,UAAAh9B,GAIA,GAAAA,EAAA,CAGA68B,EAAA,GAAAE,EAAA,GAAAv9B,KAAAuC,EACA86B,EAAA,GAAAG,EAAA,GAAAx9B,KAAAyC,EACA66B,EAAA,GAAAE,EAAA,GAAAx9B,KAAAuC,EAAAvC,KAAA+D,MACAu5B,EAAA,GAAAC,EAAA,GAAAv9B,KAAAyC,EAAAzC,KAAAqE,OAEA44B,EAAAI,EAAAA,EAAA78B,GACAy8B,EAAAK,EAAAA,EAAA98B,GACAy8B,EAAAM,EAAAA,EAAA/8B,GACAy8B,EAAAO,EAAAA,EAAAh9B,GAEAR,KAAAuC,EAAA26B,EAAAG,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,IACAx9B,KAAAyC,EAAAy6B,EAAAG,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,GACA,IAAAC,GAAAN,EAAAE,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,IACAE,EAAAP,EAAAE,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,GACAx9B,MAAA+D,MAAA05B,EAAAz9B,KAAAuC,EACAvC,KAAAqE,OAAAq5B,EAAA19B,KAAAyC,OASAk7B,mBAAA,SAAAxiB,GACA,GAAAD,GAAAlb,KACAwgB,EAAArF,EAAApX,MAAAmX,EAAAnX,MACA0c,EAAAtF,EAAA9W,OAAA6W,EAAA7W,OAEA7D,EAAA+e,EAAAS,QAOA,OAJAT,GAAAqC,UAAAphB,EAAAA,IAAA0a,EAAA3Y,GAAA2Y,EAAAzY,IACA8c,EAAApZ,MAAA3F,EAAAA,GAAAggB,EAAAC,IACAlB,EAAAqC,UAAAphB,EAAAA,GAAA2a,EAAA5Y,EAAA4Y,EAAA1Y,IAEAjC,GAOAo9B,UAAA,SAAAziB,GACA,IAAAA,EACA,OAAA,CAGAA,aAAAoC,KAEApC,EAAAoC,EAAAyC,OAAA7E,GAGA,IAAAD,GAAAlb,KACA69B,EAAA3iB,EAAA3Y,EACAu7B,EAAA5iB,EAAA3Y,EAAA2Y,EAAAnX,MACAg6B,EAAA7iB,EAAAzY,EACAu7B,EAAA9iB,EAAAzY,EAAAyY,EAAA7W,OAEA45B,EAAA9iB,EAAA5Y,EACA27B,EAAA/iB,EAAA5Y,EAAA4Y,EAAApX,MACAo6B,EAAAhjB,EAAA1Y,EACA27B,EAAAjjB,EAAA1Y,EAAA0Y,EAAA9W,MAEA,SAAAy5B,EAAAG,GAAAC,EAAAL,GAAAG,EAAAG,GAAAC,EAAAL,IAGA7mB,QAAA,SAAA3U,EAAAE,GACA,GAAAqb,GAAA9d,IACA,OAAAuC,IAAAub,EAAAvb,GACAA,GAAAub,EAAAvb,EAAAub,EAAA/Z,OACAtB,GAAAqb,EAAArb,GACAA,GAAAqb,EAAArb,EAAAqb,EAAAzZ,QAMAkM,MAAA,WACA,MAAA,IAAAgN,GAAAvd,KAAAuC,EAAAvC,KAAAyC,EAAAzC,KAAA+D,MAAA/D,KAAAqE,SAMAga,KAAA,SAAA+e,GACAp9B,KAAAuC,EAAA66B,EAAA76B,EACAvC,KAAAyC,EAAA26B,EAAA36B,EACAzC,KAAA+D,MAAAq5B,EAAAr5B,MACA/D,KAAAqE,OAAA+4B,EAAA/4B,QAGAg6B,MAAA,WACA,OACA97B,EAAAvC,KAAAuC,EACAE,EAAAzC,KAAAyC,EACAsB,MAAA/D,KAAA+D,MACAM,OAAArE,KAAAqE,UAaAkZ,EAAAyC,OAAA,SAAAlC,GACA,MAAA,IAAAP,GAAAO,EAAAvb,EAAAub,EAAArb,EAAAqb,EAAA/Z,MAAA+Z,EAAAzZ,SAGAxE,EAAAD,QAAA2d,GzBspMM,SAAS1d,EAAQD,G0Bn1MvB,QAAA0+B,GAAAC,GAGA,IAFA,GAAAtP,GAAA,EAEAsP,GAAAC,GACAvP,GAAA,EAAAsP,EACAA,IAAA,CAGA,OAAAA,GAAAtP,EAGA,QAAAwP,GAAA3sB,EAAA4sB,EAAAC,EAAAC,GACA,GAAAC,GAAAH,EAAA,CAEA,IAAAG,IAAAF,EACA,MAAA,EAGA,IAAAC,EAAA9sB,EAAA+sB,KAAA/sB,EAAA4sB,IAAA,EAAA,CACA,KAAAG,EAAAF,GAAAC,EAAA9sB,EAAA+sB,GAAA/sB,EAAA+sB,EAAA,IAAA,GACAA,GAGAC,GAAAhtB,EAAA4sB,EAAAG,OAGA,MAAAA,EAAAF,GAAAC,EAAA9sB,EAAA+sB,GAAA/sB,EAAA+sB,EAAA,KAAA,GACAA,GAIA,OAAAA,GAAAH,EAGA,QAAAI,GAAAhtB,EAAA4sB,EAAAC,GAGA,IAFAA,IAEAD,EAAAC,GAAA,CACA,GAAAjb,GAAA5R,EAAA4sB,EACA5sB,GAAA4sB,KAAA5sB,EAAA6sB,GACA7sB,EAAA6sB,KAAAjb,GAIA,QAAAqb,GAAAjtB,EAAA4sB,EAAAC,EAAA3xB,EAAA4xB,GAKA,IAJA5xB,IAAA0xB,GACA1xB,IAGcA,EAAA2xB,EAAY3xB,IAAA,CAO1B,IANA,GAIAgyB,GAJAC,EAAAntB,EAAA9E,GAEAkyB,EAAAR,EACAS,EAAAnyB,EAGAkyB,EAAAC,GACAH,EAAAE,EAAAC,IAAA,EAEAP,EAAAK,EAAAntB,EAAAktB,IAAA,EACAG,EAAAH,EAGAE,EAAAF,EAAA,CAIA,IAAAT,GAAAvxB,EAAAkyB,CAEA,QAAAX,GACA,IAAA,GACAzsB,EAAAotB,EAAA,GAAAptB,EAAAotB,EAAA,EAEA,KAAA,GACAptB,EAAAotB,EAAA,GAAAptB,EAAAotB,EAAA,EAEA,KAAA,GACAptB,EAAAotB,EAAA,GAAAptB,EAAAotB,EACA,MACA,SACA,KAAAX,EAAA,GACAzsB,EAAAotB,EAAAX,GAAAzsB,EAAAotB,EAAAX,EAAA,GACAA,IAIAzsB,EAAAotB,GAAAD,GAIA,QAAAG,GAAArtB,EAAAD,EAAA9E,EAAA9J,EAAAm8B,EAAAT,GACA,GAAAU,GAAA,EACAC,EAAA,EACAC,EAAA,CAEA,IAAAZ,EAAA7sB,EAAAD,EAAA9E,EAAAqyB,IAAA,EAAA,CAGA,IAFAE,EAAAr8B,EAAAm8B,EAEAG,EAAAD,GAAAX,EAAA7sB,EAAAD,EAAA9E,EAAAqyB,EAAAG,IAAA,GACAF,EAAAE,EACAA,GAAAA,GAAA,GAAA,EAEAA,GAAA,IACAA,EAAAD,EAIAC,GAAAD,IACAC,EAAAD,GAGAD,GAAAD,EACAG,GAAAH,MAEA,CAEA,IADAE,EAAAF,EAAA,EACAG,EAAAD,GAAAX,EAAA7sB,EAAAD,EAAA9E,EAAAqyB,EAAAG,KAAA,GACAF,EAAAE,EACAA,GAAAA,GAAA,GAAA,EAEAA,GAAA,IACAA,EAAAD,EAGAC,GAAAD,IACAC,EAAAD,EAGA,IAAA77B,GAAA47B,CACAA,GAAAD,EAAAG,EACAA,EAAAH,EAAA37B,EAIA,IADA47B,IACAA,EAAAE,GAAA,CACA,GAAAh/B,GAAA8+B,GAAAE,EAAAF,IAAA,EAEAV,GAAA7sB,EAAAD,EAAA9E,EAAAxM,IAAA,EACA8+B,EAAA9+B,EAAA,EAGAg/B,EAAAh/B,EAGA,MAAAg/B,GAGA,QAAAC,GAAA1tB,EAAAD,EAAA9E,EAAA9J,EAAAm8B,EAAAT,GACA,GAAAU,GAAA,EACAC,EAAA,EACAC,EAAA,CAEA,IAAAZ,EAAA7sB,EAAAD,EAAA9E,EAAAqyB,IAAA,EAAA,CAGA,IAFAE,EAAAF,EAAA,EAEAG,EAAAD,GAAAX,EAAA7sB,EAAAD,EAAA9E,EAAAqyB,EAAAG,IAAA,GACAF,EAAAE,EACAA,GAAAA,GAAA,GAAA,EAEAA,GAAA,IACAA,EAAAD,EAIAC,GAAAD,IACAC,EAAAD,EAGA,IAAA77B,GAAA47B,CACAA,GAAAD,EAAAG,EACAA,EAAAH,EAAA37B,MAEA,CAGA,IAFA67B,EAAAr8B,EAAAm8B,EAEAG,EAAAD,GAAAX,EAAA7sB,EAAAD,EAAA9E,EAAAqyB,EAAAG,KAAA,GACAF,EAAAE,EACAA,GAAAA,GAAA,GAAA,EAEAA,GAAA,IACAA,EAAAD,EAIAC,GAAAD,IACAC,EAAAD,GAGAD,GAAAD,EACAG,GAAAH,EAKA,IAFAC,IAEAA,EAAAE,GAAA,CACA,GAAAh/B,GAAA8+B,GAAAE,EAAAF,IAAA,EAEAV,GAAA7sB,EAAAD,EAAA9E,EAAAxM,IAAA,EACAg/B,EAAAh/B,EAGA8+B,EAAA9+B,EAAA,EAIA,MAAAg/B,GAGA,QAAAE,GAAA5tB,EAAA8sB,GAsBA,QAAAe,GAAAC,EAAAC,GACAC,EAAAC,GAAAH,EACAI,EAAAD,GAAAF,EACAE,GAAA,EAGA,QAAAE,KACA,KAAAF,EAAA,GAAA,CACA,GAAAxB,GAAAwB,EAAA,CAEA,IAAAxB,GAAA,GAAAyB,EAAAzB,EAAA,IAAAyB,EAAAzB,GAAAyB,EAAAzB,EAAA,IAAAA,GAAA,GAAAyB,EAAAzB,EAAA,IAAAyB,EAAAzB,GAAAyB,EAAAzB,EAAA,GACAyB,EAAAzB,EAAA,GAAAyB,EAAAzB,EAAA,IACAA,QAGA,IAAAyB,EAAAzB,GAAAyB,EAAAzB,EAAA,GACA,KAEA2B,GAAA3B,IAIA,QAAA4B,KACA,KAAAJ,EAAA,GAAA,CACA,GAAAxB,GAAAwB,EAAA,CAEAxB,GAAA,GAAAyB,EAAAzB,EAAA,GAAAyB,EAAAzB,EAAA,IACAA,IAGA2B,EAAA3B,IAIA,QAAA2B,GAAA98B,GACA,GAAAg9B,GAAAN,EAAA18B,GACAi9B,EAAAL,EAAA58B,GACAk9B,EAAAR,EAAA18B,EAAA,GACAm9B,EAAAP,EAAA58B,EAAA,EAEA48B,GAAA58B,GAAAi9B,EAAAE,EAEAn9B,IAAA28B,EAAA,IACAD,EAAA18B,EAAA,GAAA08B,EAAA18B,EAAA,GACA48B,EAAA58B,EAAA,GAAA48B,EAAA58B,EAAA,IAGA28B,GAEA,IAAA7T,GAAAuT,EAAA3tB,EAAAwuB,GAAAxuB,EAAAsuB,EAAAC,EAAA,EAAAzB,EACAwB,IAAAlU,EACAmU,GAAAnU,EAEA,IAAAmU,IAIAE,EAAAnB,EAAAttB,EAAAsuB,EAAAC,EAAA,GAAAvuB,EAAAwuB,EAAAC,EAAAA,EAAA,EAAA3B,GAEA,IAAA2B,IAIAF,GAAAE,EACAC,EAAAJ,EAAAC,EAAAC,EAAAC,GAGAE,EAAAL,EAAAC,EAAAC,EAAAC,KAIA,QAAAC,GAAAJ,EAAAC,EAAAC,EAAAC,GACA,GAAAn9B,GAAA,CAEA,KAAAA,EAAA,EAAuBA,EAAAi9B,EAAaj9B,IACpCM,EAAAN,GAAA0O,EAAAsuB,EAAAh9B,EAGA,IAAAs9B,GAAA,EACAC,EAAAL,EACAM,EAAAR,CAIA,IAFAtuB,EAAA8uB,KAAA9uB,EAAA6uB,KAEA,MAAAJ,EAAA,CAOA,GAAA,IAAAF,EAAA,CACA,IAAAj9B,EAAA,EAA2BA,EAAAm9B,EAAan9B,IACxC0O,EAAA8uB,EAAAx9B,GAAA0O,EAAA6uB,EAAAv9B,EAGA,aADA0O,EAAA8uB,EAAAL,GAAA78B,EAAAg9B,IAOA,IAHA,GACAG,GAAAC,EAAAC,EADAC,EAAAC,IAGA,CACAJ,EAAA,EACAC,EAAA,EACAC,GAAA,CAEA,GACA,IAAAnC,EAAA9sB,EAAA6uB,GAAAj9B,EAAAg9B,IAAA,GAKA,GAJA5uB,EAAA8uB,KAAA9uB,EAAA6uB,KACAG,IACAD,EAAA,EAEA,MAAAN,EAAA,CACAQ,GAAA,CACA,YAOA,IAHAjvB,EAAA8uB,KAAAl9B,EAAAg9B,KACAG,IACAC,EAAA,EACA,MAAAT,EAAA,CACAU,GAAA,CACA,cAGiBF,EAAAC,GAAAE,EAEjB,IAAAD,EACA,KAGA,GAAA,CAGA,GAFAF,EAAApB,EAAA3tB,EAAA6uB,GAAAj9B,EAAAg9B,EAAAL,EAAA,EAAAzB,GAEA,IAAAiC,EAAA,CACA,IAAAz9B,EAAA,EAAmCA,EAAAy9B,EAAYz9B,IAC/C0O,EAAA8uB,EAAAx9B,GAAAM,EAAAg9B,EAAAt9B,EAMA,IAHAw9B,GAAAC,EACAH,GAAAG,EACAR,GAAAQ,EACAR,GAAA,EAAA,CACAU,GAAA,CACA,QAMA,GAFAjvB,EAAA8uB,KAAA9uB,EAAA6uB,KAEA,MAAAJ,EAAA,CACAQ,GAAA,CACA,OAKA,GAFAD,EAAA1B,EAAA17B,EAAAg9B,GAAA5uB,EAAA6uB,EAAAJ,EAAA,EAAA3B,GAEA,IAAAkC,EAAA,CACA,IAAA19B,EAAA,EAAmCA,EAAA09B,EAAY19B,IAC/C0O,EAAA8uB,EAAAx9B,GAAA0O,EAAA6uB,EAAAv9B,EAOA,IAJAw9B,GAAAE,EACAH,GAAAG,EACAP,GAAAO,EAEA,IAAAP,EAAA,CACAQ,GAAA,CACA,QAKA,GAFAjvB,EAAA8uB,KAAAl9B,EAAAg9B,KAEA,MAAAL,EAAA,CACAU,GAAA,CACA,OAGAC,UACiBH,GAAAK,GAAAJ,GAAAI,EAEjB,IAAAH,EACA,KAGAC,GAAA,IACAA,EAAA,GAGAA,GAAA,EAOA,GAJAC,EAAAD,EAEAC,EAAA,IAAAA,EAAA,GAEA,IAAAZ,EAAA,CACA,IAAAj9B,EAAA,EAA2BA,EAAAm9B,EAAan9B,IACxC0O,EAAA8uB,EAAAx9B,GAAA0O,EAAA6uB,EAAAv9B,EAEA0O,GAAA8uB,EAAAL,GAAA78B,EAAAg9B,OAEA,CAAA,GAAA,IAAAL,EACA,KAAA,IAAAh2B,MAIA,KAAAjH,EAAA,EAA2BA,EAAAi9B,EAAaj9B,IACxC0O,EAAA8uB,EAAAx9B,GAAAM,EAAAg9B,EAAAt9B,QA7HA,KAAAA,EAAA,EAA2BA,EAAAi9B,EAAaj9B,IACxC0O,EAAA8uB,EAAAx9B,GAAAM,EAAAg9B,EAAAt9B,GAiIA,QAAAq9B,GAAAL,EAAAC,EAAAC,EAAAC,GACA,GAAAn9B,GAAA,CAEA,KAAAA,EAAA,EAAuBA,EAAAm9B,EAAan9B,IACpCM,EAAAN,GAAA0O,EAAAwuB,EAAAl9B,EAGA,IAAAs9B,GAAAN,EAAAC,EAAA,EACAM,EAAAJ,EAAA,EACAK,EAAAN,EAAAC,EAAA,EACAY,EAAA,EACAC,EAAA,CAIA,IAFAtvB,EAAA8uB,KAAA9uB,EAAA4uB,KAEA,MAAAL,EAAA,CAUA,GAAA,IAAAE,EAAA,CAMA,IALAK,GAAAP,EACAK,GAAAL,EACAe,EAAAR,EAAA,EACAO,EAAAT,EAAA,EAEAt9B,EAAAi9B,EAAA,EAAqCj9B,GAAA,EAAQA,IAC7C0O,EAAAsvB,EAAAh+B,GAAA0O,EAAAqvB,EAAA/9B,EAIA,aADA0O,EAAA8uB,GAAAl9B,EAAAi9B,IAMA,IAFA,GAAAK,GAAAC,IAEA,CACA,GAAAJ,GAAA,EACAC,EAAA,EACAC,GAAA,CAEA,GACA,IAAAnC,EAAAl7B,EAAAi9B,GAAA7uB,EAAA4uB,IAAA,GAIA,GAHA5uB,EAAA8uB,KAAA9uB,EAAA4uB,KACAG,IACAC,EAAA,EACA,MAAAT,EAAA,CACAU,GAAA,CACA,YAOA,IAHAjvB,EAAA8uB,KAAAl9B,EAAAi9B,KACAG,IACAD,EAAA,EACA,MAAAN,EAAA,CACAQ,GAAA,CACA,cAGiBF,EAAAC,GAAAE,EAEjB,IAAAD,EACA,KAGA,GAAA,CAGA,GAFAF,EAAAR,EAAAZ,EAAA/7B,EAAAi9B,GAAA7uB,EAAAsuB,EAAAC,EAAAA,EAAA,EAAAzB,GAEA,IAAAiC,EAAA,CAOA,IANAD,GAAAC,EACAH,GAAAG,EACAR,GAAAQ,EACAO,EAAAR,EAAA,EACAO,EAAAT,EAAA,EAEAt9B,EAAAy9B,EAAA,EAA4Cz9B,GAAA,EAAQA,IACpD0O,EAAAsvB,EAAAh+B,GAAA0O,EAAAqvB,EAAA/9B,EAGA,IAAA,IAAAi9B,EAAA,CACAU,GAAA,CACA,QAMA,GAFAjvB,EAAA8uB,KAAAl9B,EAAAi9B,KAEA,MAAAJ,EAAA,CACAQ,GAAA,CACA,OAKA,GAFAD,EAAAP,EAAAnB,EAAAttB,EAAA4uB,GAAAh9B,EAAA,EAAA68B,EAAAA,EAAA,EAAA3B,GAEA,IAAAkC,EAAA,CAOA,IANAF,GAAAE,EACAH,GAAAG,EACAP,GAAAO,EACAM,EAAAR,EAAA,EACAO,EAAAR,EAAA,EAEAv9B,EAAA,EAAmCA,EAAA09B,EAAY19B,IAC/C0O,EAAAsvB,EAAAh+B,GAAAM,EAAAy9B,EAAA/9B,EAGA,IAAAm9B,GAAA,EAAA,CACAQ,GAAA,CACA,QAMA,GAFAjvB,EAAA8uB,KAAA9uB,EAAA4uB,KAEA,MAAAL,EAAA,CACAU,GAAA,CACA,OAGAC,UACiBH,GAAAK,GAAAJ,GAAAI,EAEjB,IAAAH,EACA,KAGAC,GAAA,IACAA,EAAA,GAGAA,GAAA,EASA,GANAC,EAAAD,EAEAC,EAAA,IACAA,EAAA,GAGA,IAAAV,EAAA,CAMA,IALAK,GAAAP,EACAK,GAAAL,EACAe,EAAAR,EAAA,EACAO,EAAAT,EAAA,EAEAt9B,EAAAi9B,EAAA,EAAqCj9B,GAAA,EAAQA,IAC7C0O,EAAAsvB,EAAAh+B,GAAA0O,EAAAqvB,EAAA/9B,EAGA0O,GAAA8uB,GAAAl9B,EAAAi9B,OAEA,CAAA,GAAA,IAAAJ,EACA,KAAA,IAAAl2B,MAKA,KADA82B,EAAAP,GAAAL,EAAA,GACAn9B,EAAA,EAA2BA,EAAAm9B,EAAan9B,IACxC0O,EAAAqvB,EAAA/9B,GAAAM,EAAAN,QAjJA,KAFA+9B,EAAAP,GAAAL,EAAA,GAEAn9B,EAAA,EAA2BA,EAAAm9B,EAAan9B,IACxC0O,EAAAqvB,EAAA/9B,GAAAM,EAAAN,GA/PA,GAIA08B,GACAE,EALAiB,EAAAC,EACAh+B,EAAA,EACAm+B,EAAAC,EACAC,EAAA,EAGAxB,EAAA,CAEA78B,GAAA4O,EAAA5O,OAEAA,EAAA,EAAAo+B,IACAD,EAAAn+B,IAAA,EAGA,IAAAQ,KAEA69B,GAAAr+B,EAAA,IAAA,EAAAA,EAAA,KAAA,GAAAA,EAAA,OAAA,GAAA,GAEA48B,KACAE,KAiYAhgC,KAAAigC,UAAAA,EACAjgC,KAAAmgC,eAAAA,EACAngC,KAAA2/B,QAAAA,EAGA,QAAAtX,GAAAvW,EAAA8sB,EAAAF,EAAAC,GACAD,IACAA,EAAA,GAEAC,IACAA,EAAA7sB,EAAA5O,OAGA,IAAAs+B,GAAA7C,EAAAD,CAEA,MAAA8C,EAAA,GAAA,CAIA,GAAAxB,GAAA,CAEA,IAAAwB,EAAAhD,EAGA,MAFAwB,GAAAvB,EAAA3sB,EAAA4sB,EAAAC,EAAAC,OACAG,GAAAjtB,EAAA4sB,EAAAC,EAAAD,EAAAsB,EAAApB,EAIA,IAAA6C,GAAA,GAAA/B,GAAA5tB,EAAA8sB,GAEA8C,EAAApD,EAAAkD,EAEA,GAAA,CAEA,GADAxB,EAAAvB,EAAA3sB,EAAA4sB,EAAAC,EAAAC,GACAoB,EAAA0B,EAAA,CACA,GAAAC,GAAAH,CACAG,GAAAD,IACAC,EAAAD,GAGA3C,EAAAjtB,EAAA4sB,EAAAA,EAAAiD,EAAAjD,EAAAsB,EAAApB,GACAoB,EAAA2B,EAGAF,EAAA9B,QAAAjB,EAAAsB,GACAyB,EAAAxB,YAEAuB,GAAAxB,EACAtB,GAAAsB,QACS,IAAAwB,EAETC,GAAAtB,kBA7pBA,GAAA3B,GAAA,GAEA0C,EAAA,EAEAI,EAAA,GA4pBAzhC,GAAAD,QAAAyoB,G1Bk2MM,SAASxoB,EAAQD,EAASM,G2BpgOhC,YAYA,IAAAmB,GAAAnB,EAAA,GACA0hC,EAAA1hC,EAAA,IAAA0hC,WAEAC,EAAA3hC,EAAA,IAEA4jB,EAAA5jB,EAAA,IA6BAsL,EAAA,SAAAsf,GAEAA,EAAAA,MAEA9qB,KAAA4M,MAAAke,EAAAle,UAEA5M,KAAAkpB,QAAA4B,EAAA5B,SAAA,aAGAlpB,KAAA8hC,UAEA9hC,KAAA+hC,UAAA,EAEA/hC,KAAAgiC,MAEAhiC,KAAAmrB,YAEAnrB,KAAAiiC,YAEAjiC,KAAAkqB,SAAA,EAEA0X,EAAArhC,KAAAP,MAGAwL,GAAA5J,WAEA+L,YAAAnC,EAKAif,QAAA,SAAApB,GACArpB,KAAA8hC,OAAAr+B,KAAA4lB,IAMAnK,YAAA,SAAAoF,GACAA,EAAA3X,UAAA3M,IAEA,KAAA,GADAkiC,GAAA5d,EAAAuG,WACAznB,EAAA,EAA2BA,EAAA8+B,EAAAh/B,OAAkBE,IAC7CpD,KAAAyqB,QAAAyX,EAAA9+B,KAOAwnB,WAAA,SAAAvB,GACA,GAAArM,GAAA3b,EAAAoI,QAAAzJ,KAAA8hC,OAAAzY,EACArM,IAAA,GACAhd,KAAA8hC,OAAA/mB,OAAAiC,EAAA,IAQAmC,eAAA,SAAAmF,GAEA,IAAA,GADA4d,GAAA5d,EAAAuG,WACAznB,EAAA,EAA2BA,EAAA8+B,EAAAh/B,OAAkBE,IAC7CpD,KAAA4qB,WAAAsX,EAAA9+B,GAEAkhB,GAAA3X,UAAA,MAGAw1B,QAAA,WASA,IAAA,GAPAvd,IAAA,GAAA9a,OAAAs4B,UAAApiC,KAAAmrB,YACA6F,EAAApM,EAAA5kB,KAAAgiC,MACAE,EAAAliC,KAAA8hC,OACAlxB,EAAAsxB,EAAAh/B,OAEAm/B,KACAC,KACAl/B,EAAA,EAA2BA,EAAAwN,EAASxN,IAAA,CACpC,GAAAimB,GAAA6Y,EAAA9+B,GACAuD,EAAA0iB,EAAAgC,KAAAzG,EAAAoM,EAGArqB,KACA07B,EAAA5+B,KAAAkD,GACA27B,EAAA7+B,KAAA4lB,IAKA,IAAA,GAAAjmB,GAAA,EAA2BA,EAAAwN,GAC3BsxB,EAAA9+B,GAAAyoB,cACAqW,EAAA9+B,GAAA8+B,EAAAtxB,EAAA,GACAsxB,EAAA9R,MACAxf,KAGAxN,GAIAwN,GAAAyxB,EAAAn/B,MACA,KAAA,GAAAE,GAAA,EAA2BA,EAAAwN,EAASxN,IACpCk/B,EAAAl/B,GAAAuoB,KAAA0W,EAAAj/B,GAGApD,MAAAgiC,MAAApd,EAEA5kB,KAAAkpB,QAAA8H,GAEAhxB,KAAAmP,QAAA,QAAA6hB,GAEAhxB,KAAA4M,MAAAC,QACA7M,KAAA4M,MAAAC,UAIA01B,WAAA,WAKA,QAAAlX,KACAlf,EAAA41B,WAEAF,EAAAxW,IAEAlf,EAAA+d,SAAA/d,EAAAg2B,WATA,GAAAh2B,GAAAnM,IAEAA,MAAA+hC,UAAA,EAWAF,EAAAxW,IAMAre,MAAA,WAEAhN,KAAAgiC,OAAA,GAAAl4B,OAAAs4B,UACApiC,KAAAmrB,YAAA,EAEAnrB,KAAAuiC,cAKA37B,KAAA,WACA5G,KAAA+hC,UAAA,GAMA9X,MAAA,WACAjqB,KAAAkqB,UACAlqB,KAAAiiC,aAAA,GAAAn4B,OAAAs4B,UACApiC,KAAAkqB,SAAA,IAOAC,OAAA,WACAnqB,KAAAkqB,UACAlqB,KAAAmrB,cAAA,GAAArhB,OAAAs4B,UAAApiC,KAAAiiC,YACAjiC,KAAAkqB,SAAA,IAOAzkB,MAAA,WACAzF,KAAA8hC,WAcA9d,QAAA,SAAAhe,EAAA8kB,GACAA,EAAAA,KAEA,IAAAxG,GAAA,GAAAR,GACA9d,EACA8kB,EAAA5G,KACA4G,EAAApD,OACAoD,EAAAlD,OAKA,OAFA5nB,MAAAkf,YAAAoF,GAEAA,IAIAjjB,EAAAkR,MAAA/G,EAAAo2B,GAEA/hC,EAAAD,QAAA4L,G3B4gOM,SAAS3L,EAAQD,EAASM,G4BxwOhC,YAaA,SAAAsiC,GAAAj1B,GAEA,MAAAA,GAAAi1B,sBAAAj1B,EAAAi1B,yBAAwEtD,KAAA,EAAAuD,IAAA,GAIxE,QAAAC,GAAAn1B,EAAA5G,EAAAwa,EAAAwhB,GAsCA,MArCAxhB,GAAAA,MAaAwhB,IAAAt3B,EAAAM,gBACAi3B,EAAAr1B,EAAA5G,EAAAwa,GASA9V,EAAAmE,QAAAC,SAAA,MAAA9I,EAAAk8B,QAAAl8B,EAAAk8B,SAAAl8B,EAAAI,SACAoa,EAAA/K,IAAAzP,EAAAk8B,OACA1hB,EAAA9K,IAAA1P,EAAAm8B,QAGA,MAAAn8B,EAAAI,SACAoa,EAAA/K,IAAAzP,EAAAI,QACAoa,EAAA9K,IAAA1P,EAAAK,SAIA47B,EAAAr1B,EAAA5G,EAAAwa,GAGAA,EAGA,QAAAyhB,GAAAr1B,EAAA5G,EAAAwa,GAEA,GAAA4hB,GAAAP,EAAAj1B,EACA4T,GAAA/K,IAAAzP,EAAAa,QAAAu7B,EAAA7D,KACA/d,EAAA9K,IAAA1P,EAAAgB,QAAAo7B,EAAAN,IAOA,QAAAO,GAAAz1B,EAAA5G,EAAAg8B,GAIA,GAFAh8B,EAAAA,GAAAwJ,OAAAtJ,MAEA,MAAAF,EAAAyP,IACA,MAAAzP,EAGA,IAAAolB,GAAAplB,EAAAjB,KACAu9B,EAAAlX,GAAAA,EAAAtiB,QAAA,UAAA,CAEA,IAAAw5B,EAIA,CACA,GAAAC,GAAA,YAAAnX,EACAplB,EAAAw8B,cAAA,GACAx8B,EAAAy8B,eAAA,EACAF,IAAAR,EAAAn1B,EAAA21B,EAAAv8B,EAAAg8B,OAPAD,GAAAn1B,EAAA5G,EAAAA,EAAAg8B,GACAh8B,EAAA+P,QAAA/P,EAAA,WAAAA,EAAAG,WAAA,MAAAH,EAAA08B,QAAA,GAAA,CASA,OAAA18B,GAGA,QAAA28B,GAAA/1B,EAAAhI,EAAAmH,GACA62B,EACAh2B,EAAA+1B,iBAAA/9B,EAAAmH,GAGAa,EAAAi2B,YAAA,KAAAj+B,EAAAmH,GAIA,QAAA+2B,GAAAl2B,EAAAhI,EAAAmH,GACA62B,EACAh2B,EAAAk2B,oBAAAl+B,EAAAmH,GAGAa,EAAAm2B,YAAA,KAAAn+B,EAAAmH,GAtGA,GAAA0K,GAAAlX,EAAA,GACAmL,EAAAnL,EAAA,GAEAqjC,EAAA,mBAAApzB,WAAAA,OAAAmzB,iBAgHA18B,EAAA28B,EACA,SAAA58B,GACAA,EAAAg9B,iBACAh9B,EAAAi9B,kBACAj9B,EAAAyB,cAAA,GAEA,SAAAzB,GACAA,EAAAk9B,aAAA,EACAl9B,EAAAyB,cAAA,EAGAvI,GAAAD,SACA8iC,cAAAA,EACAM,eAAAA,EACAM,iBAAAA,EACAG,oBAAAA,EAEA78B,KAAAA,EAEAg7B,WAAAxqB,I5BixOM,SAASvX,EAAQD,G6B75OvBC,EAAAD,QAAA,mBAAAuQ,UACAA,OAAA0xB,uBACA1xB,OAAA2zB,yBACA3zB,OAAA4zB,0BACA5zB,OAAA6zB,8BACA,SAAAzwB,GACA0wB,WAAA1wB,EAAA,M7Bw6OM,SAAS1T,EAAQD,EAASM,G8Bh5OhC,QAAAgkC,GAAA3+B,GACA,MAAA,eAAAA,GAAA8F,EAAAmE,QAAAC,QAAA,iBAAAlK,EAGA,QAAA4+B,GAAA7sB,EAAAzQ,EAAA+F,GACA,GAAAw3B,GAAA9sB,EAAA+sB,WAEA,WAAAz3B,GAAAw3B,EAAA3+B,OAEA,IAAA6+B,GAAAF,EAAAG,UACA19B,EACAyQ,EAAA5K,QAAAoL,UAAAjR,EAAAuP,IAAAvP,EAAAwP,IAAA,MACAiB,EAAA1W,IAMA,IAHA,QAAAgM,GAAAw3B,EAAA3+B,QAGA6+B,EAAA,CACA,GAAA5+B,GAAA4+B,EAAA5+B,IACAmB,GAAAyP,aAAA5Q,EAEA4R,EAAA5K,QAAAyL,kBAAAmsB,EAAAt+B,OAAAN,EAAA4+B,EAAAz9B,QAwBA,QAAA29B,GAAAC,GACAA,EAAAC,WAAA,EACAC,aAAAF,EAAAG,aACAH,EAAAG,YAAAX,WAAA,WACAQ,EAAAC,WAAA,GACS,KA8JT,QAAAG,GAAAh+B,GACA,GAAAi+B,GAAAj+B,EAAAi+B,WACA,OAAA,QAAAA,GAAA,UAAAA,EAqBA,QAAAC,GAAAN,GAaA,QAAAO,GAAAC,EAAAR,GACA,MAAA,YACA,IAAAA,EAAAC,UAGA,MAAAO,GAAAtxB,MAAA8wB,EAAA/wB,YAjBA1I,EAAA0H,KAAAwyB,EAAA,SAAA3/B,GACAk/B,EAAAU,UAAA5/B,GAAAyF,EAAA8B,KAAAs4B,EAAA7/B,GAAAk/B,KAGAz5B,EAAA0H,KAAA2yB,EAAA,SAAA9/B,GACAk/B,EAAAU,UAAA5/B,GAAAyF,EAAA8B,KAAAs4B,EAAA7/B,GAAAk/B,KAGAz5B,EAAA0H,KAAA4yB,EAAA,SAAA//B,GACAk/B,EAAAU,UAAA5/B,GAAAy/B,EAAAI,EAAA7/B,GAAAk/B,KAcA,QAAAc,GAAA3kC,GAkEA,QAAA4kC,GAAAnuB,EAAAotB,GACAz5B,EAAA0H,KAAA2E,EAAA,SAAA9R,GACA+9B,EAAA1iC,EAAAsjC,EAAA3+B,GAAAk/B,EAAAU,UAAA5/B,KACak/B,GApEbrtB,EAAA7W,KAAAP,MAEAA,KAAAY,IAAAA,EAMAZ,KAAA0kC,WAAA,EAMA1kC,KAAA4kC,YAMA5kC,KAAAqkC,YAAA,GAAAoB,GAEAzlC,KAAAmlC,aAEAJ,EAAA/kC,MAEAqL,EAAA+E,uBAOAo1B,EAAAH,EAAArlC,OAkBAqL,EAAA6E,sBACAs1B,EAAAN,EAAAllC,MAUAwlC,EAAAF,EAAAtlC,OA7VA,GAAA0B,GAAAxB,EAAA,IACA8K,EAAA9K,EAAA,GACAkX,EAAAlX,EAAA,GACAmL,EAAAnL,EAAA,GACAulC,EAAAvlC,EAAA,IAEAojC,EAAA5hC,EAAA4hC,iBACAG,EAAA/hC,EAAA+hC,oBACAT,EAAAthC,EAAAshC,eAEA0C,EAAA,IAEAJ,GACA,QAAA,WAAA,aAAA,WACA,UAAA,YAAA,YAAA,eAGAJ,GACA,aAAA,WAAA,aAGAS,GACAC,YAAA,EAAAC,UAAA,EAAAC,YAAA,EAAAC,WAAA,GAGAV,EAAAr6B,EAAA+H,IAAAuyB,EAAA,SAAA//B,GACA,GAAAygC,GAAAzgC,EAAAoqB,QAAA,QAAA,UACA,OAAAgW,GAAAK,GAAAA,EAAAzgC,IA0DA6/B,GAMAxtB,UAAA,SAAA/Q,GACAA,EAAAm8B,EAAAhjC,KAAAY,IAAAiG,GAEA7G,KAAAmP,QAAA,YAAAtI,IAQAuR,SAAA,SAAAvR,GACAA,EAAAm8B,EAAAhjC,KAAAY,IAAAiG,EAEA,IAAAyR,GAAAzR,EAAA0R,WAAA1R,EAAA2R,aACA,IAAAF,GAAAtY,KAAAY,IACA,KAAA0X,GAAA,GAAAA,EAAAtE,UAAA,CAEA,GAAAsE,IAAAtY,KAAAY,IACA,MAGA0X,GAAAA,EAAAG,WAIAzY,KAAAmP,QAAA,WAAAtI,IAQAo/B,WAAA,SAAAp/B,GAGAA,EAAAm8B,EAAAhjC,KAAAY,IAAAiG,GAIAA,EAAA8P,WAAA,EAEA3W,KAAAyX,iBAAA,GAAA3N,MAEAq6B,EAAAnkC,KAAA6G,EAAA,SAIAu+B,EAAAxtB,UAAArX,KAAAP,KAAA6G,GAEAu+B,EAAAc,UAAA3lC,KAAAP,KAAA6G,GAEA29B,EAAAxkC,OAQAmmC,UAAA,SAAAt/B,GAEAA,EAAAm8B,EAAAhjC,KAAAY,IAAAiG,GAIAA,EAAA8P,WAAA,EAEAwtB,EAAAnkC,KAAA6G,EAAA,UAKAu+B,EAAAxtB,UAAArX,KAAAP,KAAA6G,GAEA29B,EAAAxkC,OAQAomC,SAAA,SAAAv/B,GAEAA,EAAAm8B,EAAAhjC,KAAAY,IAAAiG,GAIAA,EAAA8P,WAAA,EAEAwtB,EAAAnkC,KAAA6G,EAAA,OAEAu+B,EAAAiB,QAAA9lC,KAAAP,KAAA6G,IAYA,GAAAiD,MAAA9J,KAAAyX,iBAAAiuB,GACAN,EAAAkB,MAAA/lC,KAAAP,KAAA6G,GAGA29B,EAAAxkC,OAGA4lC,YAAA,SAAA/+B,GACAu+B,EAAAc,UAAA3lC,KAAAP,KAAA6G,IAOAi/B,YAAA,SAAAj/B,GAMAg+B,EAAAh+B,IACAu+B,EAAAxtB,UAAArX,KAAAP,KAAA6G,IAIAg/B,UAAA,SAAAh/B,GACAu+B,EAAAiB,QAAA9lC,KAAAP,KAAA6G,IAGAk/B,WAAA,SAAAl/B,GAMAg+B,EAAAh+B,IACAu+B,EAAAhtB,SAAA7X,KAAAP,KAAA6G,IAeAmE,GAAA0H,MAAA,QAAA,YAAA,UAAA,aAAA,WAAA,eAAA,SAAAnN,GACA6/B,EAAA7/B,GAAA,SAAAsB,GACAA,EAAAm8B,EAAAhjC,KAAAY,IAAAiG,GACA7G,KAAAmP,QAAA5J,EAAAsB,KA2GA,IAAA0/B,GAAAhB,EAAA3jC,SACA2kC,GAAA17B,QAAA,WAGA,IAAA,GAFAwM,GAAAiuB,EAAA1xB,OAAAsxB,GAEA9hC,EAAA,EAAuBA,EAAAiU,EAAAnU,OAAyBE,IAAA,CAChD,GAAAmC,GAAA8R,EAAAjU,EACAqgC,GAAAzjC,KAAAY,IAAAsjC,EAAA3+B,GAAAvF,KAAAmlC,UAAA5/B,MAIAghC,EAAAvuB,UAAA,SAAAjJ,GACA/O,KAAAY,IAAAwE,MAAA6S,OAAAlJ,GAAA,WAGA/D,EAAAuH,MAAAgzB,EAAAnuB,GAEAvX,EAAAD,QAAA2lC,G9Bu7OM,SAAS1lC,EAAQD,EAASM,G+BhzPhC,YAmEA,SAAA0jB,GAAA4iB,GACA,GAAAzsB,GAAAysB,EAAA,GAAA,GAAAA,EAAA,GAAA,GACAxsB,EAAAwsB,EAAA,GAAA,GAAAA,EAAA,GAAA,EAEA,OAAA9lB,MAAAC,KAAA5G,EAAAA,EAAAC,EAAAA,GAGA,QAAAysB,GAAAD,GACA,QACAA,EAAA,GAAA,GAAAA,EAAA,GAAA,IAAA,GACAA,EAAA,GAAA,GAAAA,EAAA,GAAA,IAAA,GAvEA,GAAAE,GAAAxmC,EAAA,IAEAulC,EAAA,WAMAzlC,KAAA2mC,UAGAlB,GAAA7jC,WAEA+L,YAAA83B,EAEAlB,UAAA,SAAA19B,EAAAb,EAAAtG,GAEA,MADAM,MAAA4mC,SAAA//B,EAAAb,EAAAtG,GACAM,KAAA6mC,WAAAhgC,IAGApB,MAAA,WAEA,MADAzF,MAAA2mC,OAAAzjC,OAAA,EACAlD,MAGA4mC,SAAA,SAAA//B,EAAAb,EAAAtG,GACA,GAAAonC,GAAAjgC,EAAAigC,OAEA,IAAAA,EAAA,CAWA,IAAA,GAPAC,IACAC,UACAF,WACA9gC,OAAAA,EACAa,MAAAA,GAGAzD,EAAA,EAAAwN,EAAAk2B,EAAA5jC,OAAiDE,EAAAwN,EAASxN,IAAA,CAC1D,GAAA8/B,GAAA4D,EAAA1jC,GACA6C,EAAAygC,EAAAhE,cAAAhjC,EAAAwjC,KACA6D,GAAAC,OAAAvjC,MAAAwC,EAAAmQ,IAAAnQ,EAAAoQ,MACA0wB,EAAAD,QAAArjC,KAAAy/B,GAGAljC,KAAA2mC,OAAAljC,KAAAsjC,KAGAF,WAAA,SAAAhgC,GACA,IAAA,GAAAmI,KAAAi4B,GACA,GAAAA,EAAAl7B,eAAAiD,GAAA,CACA,GAAAs1B,GAAA2C,EAAAj4B,GAAAhP,KAAA2mC,OAAA9/B,EACA,IAAAy9B,EACA,MAAAA,KAqBA,IAAA2C,IAEAC,MAAA,SAAAC,EAAAtgC,GACA,GAAAkhB,GAAAof,EAAAjkC,MAEA,IAAA6kB,EAAA,CAIA,GAAAqf,IAAAD,EAAApf,EAAA,QAAqDif,OACrDK,GAAAF,EAAApf,EAAA,QAAqDif,QAAAI,CAErD,IAAAC,GACAA,EAAAnkC,OAAA,GACAkkC,GACAA,EAAAlkC,OAAA,EACA,CACA,GAAAuT,GAAAmN,EAAAwjB,GAAAxjB,EAAAyjB,IACAC,SAAA7wB,KAAAA,EAAA,GAEA5P,EAAA4P,WAAAA,CAEA,IAAA8wB,GAAAd,EAAAW,EAIA,OAHAvgC,GAAA0P,OAAAgxB,EAAA,GACA1gC,EAAA2P,OAAA+wB,EAAA,IAGA7hC,KAAA,QACAM,OAAAmhC,EAAA,GAAAnhC,OACAa,MAAAA,MAQAhH,GAAAD,QAAA6lC,G/BwzPM,SAAS5lC,EAAQD,EAASM,GgC96PhC,YA0BA,SAAAsnC,GAAAnoB,GACA,MAAAwP,UAAAxP,EAAA,IAGA,QAAAooB,GAAA1uB,GACA,QAAAA,MAIAA,EAAA2uB,aAIA,kBAAA3uB,GAAA,QACA,kBAAAA,GAAA,SAQA,QAAA4uB,GAAA5uB,GACAA,EAAA6uB,gBAGA,QAAAC,GAAA9uB,GACA,GAAAA,EAAA6uB,eACA7uB,EAAAtT,QAMA,QAAAqiC,GAAAv6B,EAAAxJ,EAAAM,GAOA,MANA0Z,GAAAM,KAAA9Q,EAAAnJ,mBACAmJ,EAAA4Q,WACAJ,EAAAO,eAAA/Q,EAAA4Q,WAEA4pB,EAAAhkC,MAAAA,EACAgkC,EAAA1jC,OAAAA,GACA0Z,EAAA6f,UAAAmK,GAGA,QAAAC,GAAA9rB,EAAA+rB,GACA,GAAA/rB,GAAA+rB,EACA,OAAA,CAGA,KAAA/rB,IAAA+rB,GAAA/rB,EAAAhZ,SAAA+kC,EAAA/kC,OACA,OAAA,CAEA,KAAA,GAAAE,GAAA,EAAuBA,EAAA8Y,EAAAhZ,OAAsBE,IAC7C,GAAA8Y,EAAA9Y,KAAA6kC,EAAA7kC,GACA,OAAA,EAKA,QAAA8kC,GAAAhsB,EAAAxB,GACA,IAAA,GAAAtX,GAAA,EAAuBA,EAAA8Y,EAAAhZ,OAAsBE,IAAA,CAC7C,GAAA6T,GAAAiF,EAAA9Y,GACA6gB,EAAAhN,EAAAgN,IAEAhN,GAAAoJ,aAAA3F,GACAuJ,EAAAkkB,UAAAztB,GACAzD,EAAAmxB,UAAAnkB,EAAAhN,EAAAxO,OACAiS,EAAA2O,OAEApS,EAAAqJ,iBAAA5F,IAIA,QAAA2tB,GAAAtkC,EAAAM,GACA,GAAAikC,GAAAv4B,SAAAC,cAAA,MAaA,OAVAs4B,GAAAljC,MAAAmjC,SACA,oBACA,kBACA,SAAAxkC,EAAA,KACA,UAAAM,EAAA,KACA,YACA,WACA,kBACAgjB,KAAA,KAAiB,IAEjBihB,EAvGA,GAAAp6B,GAAAhO,EAAA,IACAmB,EAAAnB,EAAA,GACA6jB,EAAA7jB,EAAA,IACAqd,EAAArd,EAAA,IACAqb,EAAArb,EAAA,IAEAsoC,EAAAtoC,EAAA,IAEA2hC,EAAA3hC,EAAA,IAMAuoC,EAAA,EAkCA1qB,EAAA,GAAAR,GAAA,EAAA,EAAA,EAAA,GACAwqB,EAAA,GAAAxqB,GAAA,EAAA,EAAA,EAAA,GAgEAmrB,EAAA,SAAAhpC,EAAA0M,EAAAvL,GAEA,GAAA8nC,IAAAjpC,EAAAkpC,UACA,WAAAlpC,EAAAkpC,SAAAC,aAEA7oC,MAAA8oC,MAAAjoC,EAAAQ,EAAAqQ,UAA0C7Q,OAK1Cb,KAAA6O,IAAAhO,EAAAO,kBAAA8M,EAAA9M,iBAKApB,KAAA+oC,cAAAJ,EAKA3oC,KAAAN,KAAAA,CAEA,IAAAspC,GAAAtpC,EAAA0F,KAEA4jC,KACAA,EAAA,+BAAA,cACAA,EAAA,uBACAA,EAAA,eACAA,EAAA,yBAAA,OAEAtpC,EAAAupC,UAAA,IAMAjpC,KAAAoM,QAAAA,CAMA,IAAA88B,GAAAlpC,KAAAmpC,eAMAC,EAAAppC,KAAAqpC,UAQA,IAFArpC,KAAAspC,gBAEAX,EASA,CACA,MAAA9nC,EAAAkD,QACArE,EAAAqE,MAAAlD,EAAAkD,OAEA,MAAAlD,EAAAwD,SACA3E,EAAA2E,OAAAxD,EAAAwD,OAGA,IAAAN,GAAArE,EAAAqE,MACAM,EAAA3E,EAAA2E,MACArE,MAAAupC,OAAAxlC,EACA/D,KAAAwpC,QAAAnlC,CAIA,IAAAolC,GAAA,GAAAjB,GAAA9oC,EAAAM,KAAA,EACAypC,GAAAC,cAGAN,EAAA,GAAAK,EACAP,EAAAzlC,KAAA,GAEAzD,KAAA2pC,SAAAjqC,MA/BA,CACAM,KAAAupC,OAAAvpC,KAAA4pC,SAAA,GACA5pC,KAAAwpC,QAAAxpC,KAAA4pC,SAAA,EAEA,IAAAtB,GAAAtoC,KAAA2pC,SAAAtB,EACAroC,KAAAupC,OAAAvpC,KAAAwpC,QAEA9pC,GAAAmqC,YAAAvB,GA4BAtoC,KAAA8pC,sBAMA9pC,KAAA+pC,YAEA/pC,KAAAgqC,kBAGAtB,GAAA9mC,WAEA+L,YAAA+6B,EAMAuB,eAAA,WACA,MAAAjqC,MAAA+oC,eAKAt8B,gBAAA,WACA,MAAAzM,MAAA2pC,UAOAv7B,QAAA,SAAA87B,GAEA,GAAAjxB,GAAAjZ,KAAAoM,QAAA8M,gBAAA,GAEAgwB,EAAAlpC,KAAAmpC,WAEAnpC,MAAAmqC,WAAAlxB,EAAAixB,EAGA,KAAA,GAAA9mC,GAAA,EAA2BA,EAAA8lC,EAAAhmC,OAAuBE,IAAA,CAClD,GAAAiY,GAAA6tB,EAAA9lC,GACA2V,EAAA/Y,KAAAqpC,QAAAhuB,IACAtC,EAAA2uB,aAAA3uB,EAAA3K,SACA2K,EAAA3K,UAUA,MANApO,MAAAwO,eAEAxO,KAAA8pC,mBAAA5mC,QACAlD,KAAAoqC,mBAGApqC,MAGAuO,SAAA,SAAAhB,EAAA88B,GACA,IAAA98B,EAAA+8B,WAAA,CAGA,GAAAC,GAAA,GAAAh9B,GAAAI,aACAvI,MAAAmI,EAAAnI,MACAqD,MAAA8E,EAAA9E,OAEA8hC,GAAAC,OAAAj9B,EACAA,EAAA+8B,WAAAC,EACAA,EAAAE,SAAAJ,GACArqC,KAAAgqC,eAAAvmC,KAAA8mC,KAGA97B,YAAA,SAAAlB,GACA,GAAAg9B,GAAAh9B,EAAA+8B,WACAI,EAAA1qC,KAAAgqC,eACAhtB,EAAA3b,EAAAoI,QAAAihC,EAAAH,EACAvtB,IAAA,GACA0tB,EAAA3vB,OAAAiC,EAAA,GAEAzP,EAAA+8B,WAAA,MAGA57B,WAAA,SAAAnB,GAEA,IAAA,GADAm9B,GAAA1qC,KAAAgqC,eACA5mC,EAAA,EAA2BA,EAAAsnC,EAAAxnC,OAA0BE,IAAA,CACrD,GAAA0N,GAAA45B,EAAAtnC,GAAAonC,MACA15B,KACAA,EAAAw5B,WAAA,MAGAI,EAAAxnC,OAAA,GAGAsL,aAAA,WACA,GAAAk8B,GAAA1qC,KAAAgqC,eACAp5B,EAAA85B,EAAAxnC,OACAynC,EAAA3qC,KAAA+pC,WAGA,IAFAY,GAAAA,EAAAllC,QAEAmL,EAAA,CAGA2K,EAAAmvB,EAAA1qC,KAAAoM,QAAAiR,qBAIAstB,IACAA,EAAA3qC,KAAA+pC,YAAA/pC,KAAA4qC,SAAA,KAGA,IAAAC,KACAF,GAAAjwB,IAAAowB,MACA,KAAA,GAAA1nC,GAAA,EAA2BA,EAAAwN,GAAS,CACpC,GAAArD,GAAAm9B,EAAAtnC,GACA2nC,EAAAx9B,EAAAi9B,MAGAO,IAAAA,EAAA7yB,MAMA9U,IAIA2nC,EAAA9sB,YACA1Q,EAAA4Q,UAAA4sB,EAAA5sB,UACA5Q,EAAA2S,aAAA6qB,EAAA7qB,aACA3S,EAAAsP,YAAAkuB,EAAAluB,YAEA7c,KAAAgrC,WAAAz9B,EAAAo9B,GAAA,EAAAE,MAdAH,EAAA3vB,OAAA3X,EAAA,GACA2nC,EAAAT,WAAA,KACA15B,KAeA+5B,EAAAjwB,IAAAuwB,YAGAb,iBAAA,WAcA,QAAA/e,KAEA6f,IAAA/+B,EAAAg/B,mBAAAh/B,EAAAC,UAEAD,EAAAi/B,aAAAj/B,EAAAC,QAAA8M,kBAEA/M,EAAAk/B,qBACAl/B,EAAAm/B,YACAzJ,EAAAxW,IAGAlf,EAAAg/B,sBAxBA,GAAAh/B,GAAAnM,IAEA,IAAAmM,EAAAk/B,oBAAA,CAMA,GAAAH,GAAA/+B,EAAAg/B,mBAAA,GAAArhC,KAEAqC,GAAAm/B,YACAzJ,EAAAxW,KAmBAkgB,kBAAA,WACAvrC,KAAAmrC,qBACAnrC,KAAAsrC,UAAA,EACAjqC,EAAAqR,KAAA1S,KAAA8pC,mBAAA,SAAA/wB,GACAA,EAAAqD,SAAArD,EAAAtT,WAIA0kC,WAAA,SAAAlxB,EAAAixB,GAEA,MAAAA,IACAA,GAAA,GAGAlqC,KAAAwrC,mBAAAvyB,GAEAjZ,KAAAurC,oBAEAvrC,KAAAyrC,iBAAA9D,GAEA3nC,KAAAorC,aAAAnyB,EAAAixB,GAEAlqC,KAAAyrC,iBAAA5D,IAGAuD,aAAA,SAAAnyB,EAAAixB,GAeA,QAAAwB,GAAA3yB,GACA,GAAAlK,GAAA6L,EAAA7L,KAAA,CACA6L,GAAAowB,OACApwB,EAAAixB,YAAA,EACAjxB,EAAAkxB,WAAA,EAEAC,EAAAzvB,SAAA,EACA1B,EAAA2F,aAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA3F,EAAAoxB,UAAA/yB,EAAAnY,IAAA,EAAA,EAAAmD,EAAA8K,EAAAxK,EAAAwK,GACA6L,EAAAuwB,UAGA,IAAA,GA1BAY,GACAE,EACArxB,EAGAmwB,EAGAmB,EAIAC,EALAC,EAAA,EAGAnoC,EAAA/D,KAAAupC,OACAllC,EAAArE,KAAAwpC,QAEArgB,EAAAnpB,KAAAsrC,UAaAloC,EAAA,EAAAyX,EAAA5B,EAAA/V,OAA4CE,EAAAyX,EAAOzX,IAAA,CACnD,GAAAmK,GAAA0L,EAAA7V,GACA+oC,EAAAnsC,KAAA+oC,cAAA,EAAAx7B,EAAA6N,OAEAgxB,EAAA7+B,EAAA8+B,OAwCA,IApCAD,EAAA,GAAAJ,IACAN,EAAAM,GACAA,EAAA,MAIAD,IAAAI,IACAzxB,GACAA,EAAAuwB,UAIAJ,KAGAkB,EAAAI,EACAN,EAAA7rC,KAAA4qC,SAAAmB,GAEAF,EAAAnE,aACA3jB,EACA,UAAAgoB,EACA,kCAAAF,EAAAxrC,IAIAqa,EAAAmxB,EAAAnxB,IACAA,EAAAowB,OAGAe,EAAAjE,cAAA,GAEAiE,EAAAzvB,SAAA8tB,IACA2B,EAAApmC,SAIAomC,EAAAzvB,SAAA8tB,EAAA,CAIA,GAAAkC,GAAA,EAAA,CAEA,IAAAJ,EAAA,CAQA,GAPAA,EAAAhsC,KAAA8pC,mBACAppB,KAAArZ,IAAA6kC,IAAAzD,EAAA,IAGAuD,EAAAtxB,IAAAowB,OACAkB,EAAAM,eAEAN,GACAA,EAAAO,WAAAP,EAAAQ,cACA,CAIAppC,EAAA4oC,EAAAS,iBAAA,CAEA,UAGAR,EAAAD,EAAAO,WAEAP,EAAA5vB,UAEA+M,EAAA8iB,GAGAD,EAAAO,WAAApjB,EAAA,EAGAijB,IAAAjjB,GACAnpB,KAAAgrC,WAAAz9B,EAAAy+B,GAAA,EAAAA,EAAAM,iBAIAtsC,MAAAgrC,WAAAz9B,EAAAs+B,EAAA3B,EAAAW,EAGAt9B,GAAA6O,SAAA,GAGA4vB,GACAN,EAAAM,GAIAtxB,GAAAA,EAAAuwB,UAMAjrC,KAAAqrC,qBAAA,EACAhqC,EAAAqR,KAAA1S,KAAA8pC,mBAAA,SAAA/wB,GACAA,EAAAyzB,eAAAzzB,EAAAwzB,aACAvsC,KAAAqrC,qBAAA,IAEarrC,OAGbgrC,WAAA,SAAAz9B,EAAAs+B,EAAAa,EAAA7B,GACA,GAAAnwB,GAAAmxB,EAAAnxB,IACAla,EAAA+M,EAAA4Q,SACA,KACA0tB,EAAAzvB,SAAAswB,KAEAn/B,EAAA0Q,WAEA,IAAA1Q,EAAAnI,MAAAunC,WAIAnsC,GAAAA,EAAA,IAAAA,EAAA,OAEA+M,EAAAq/B,UAAA9E,EAAAv6B,EAAAvN,KAAAupC,OAAAvpC,KAAAwpC,UACA,CAEA,GAAAttB,GAAA3O,EAAAsP,aAGAguB,EAAAgC,gBAAAhB,GACA7D,EAAA9rB,EAAA2uB,EAAAiC,oBAGAjC,EAAAiC,kBACAjC,EAAAgC,cAAAnyB,IAAAuwB,UACAJ,EAAAgC,cAAAhC,EAAAiC,gBAAA;AAGAjC,EAAAkC,OAAA,MAGA7wB,IACAxB,EAAAowB,OACA5C,EAAAhsB,EAAAxB,GACAmwB,EAAAgC,cAAAhB,EACAhB,EAAAiC,gBAAA5wB,IAGA3O,EAAAy/B,aAAAz/B,EAAAy/B,YAAAtyB,GAEAnN,EAAA0/B,MAAAvyB,EAAAmwB,EAAAkC,QAAA,MACAlC,EAAAkC,OAAAx/B,EAEAA,EAAA2/B,YAAA3/B,EAAA2/B,WAAAxyB,KASAkwB,SAAA,SAAAxvB,GACA,GAAApb,KAAA+oC,cACA,MAAA/oC,MAAAqpC,QAAA,EAGA,IAAAtwB,GAAA/Y,KAAAqpC,QAAAjuB,EAiBA,OAhBArC,KAEAA,EAAA,GAAAyvB,GAAA,MAAAptB,EAAApb,KAAAA,KAAA6O,KACAkK,EAAA2uB,aAAA,EAEA1nC,KAAAspC,aAAAluB,IACA/Z,EAAA4P,MAAA8H,EAAA/Y,KAAAspC,aAAAluB,IAAA,GAGApb,KAAAmtC,YAAA/xB,EAAArC,GAIAA,EAAA2wB,eAGA3wB,GAGAo0B,YAAA,SAAA/xB,EAAArC,GAEA,GAAAq0B,GAAAptC,KAAAqpC,QACAH,EAAAlpC,KAAAmpC,YACAv4B,EAAAs4B,EAAAhmC,OACAmqC,EAAA,KACAjqC,KACAklC,EAAAtoC,KAAA2pC,QAEA,IAAAyD,EAAAhyB,GAEA,WADA2I,GAAA,UAAA3I,EAAA,yBAIA,KAAAqsB,EAAA1uB,GAEA,WADAgL,GAAA,mBAAA3I,EAAA,gBAIA,IAAAxK,EAAA,GAAAwK,EAAA8tB,EAAA,GAAA,CACA,IAAA9lC,EAAA,EAA2BA,EAAAwN,EAAA,KAE3Bs4B,EAAA9lC,GAAAgY,GACA8tB,EAAA9lC,EAAA,GAAAgY,GAHwChY,KAQxCiqC,EAAAD,EAAAlE,EAAA9lC,IASA,GAPA8lC,EAAAnuB,OAAA3X,EAAA,EAAA,EAAAgY,GAEAgyB,EAAAhyB,GAAArC,GAKAA,EAAAu0B,QACA,GAAAD,EAAA,CACA,GAAAE,GAAAF,EAAAzsC,GACA2sC,GAAA7vB,YACA4qB,EAAAkF,aACAz0B,EAAAnY,IACA2sC,EAAA7vB,aAIA4qB,EAAAuB,YAAA9wB,EAAAnY,SAIA0nC,GAAAmF,WACAnF,EAAAkF,aAAAz0B,EAAAnY,IAAA0nC,EAAAmF,YAGAnF,EAAAuB,YAAA9wB,EAAAnY,MAOA8sC,UAAA,SAAA96B,EAAA1D,GACA,GACAmM,GACAjY,EAFA8lC,EAAAlpC,KAAAmpC,WAGA,KAAA/lC,EAAA,EAAuBA,EAAA8lC,EAAAhmC,OAAuBE,IAC9CiY,EAAA6tB,EAAA9lC,GACAwP,EAAArS,KAAA2O,EAAAlP,KAAAqpC,QAAAhuB,GAAAA,IAKAowB,iBAAA,SAAA74B,EAAA1D,GACA,GACA6J,GACAsC,EACAjY,EAHA8lC,EAAAlpC,KAAAmpC,WAIA,KAAA/lC,EAAA,EAAuBA,EAAA8lC,EAAAhmC,OAAuBE,IAC9CiY,EAAA6tB,EAAA9lC,GACA2V,EAAA/Y,KAAAqpC,QAAAhuB,GACAtC,EAAA2uB,aACA90B,EAAArS,KAAA2O,EAAA6J,EAAAsC,IAMAvC,eAAA,SAAAlG,EAAA1D,GACA,GACA6J,GACAsC,EACAjY,EAHA8lC,EAAAlpC,KAAAmpC,WAIA,KAAA/lC,EAAA,EAAuBA,EAAA8lC,EAAAhmC,OAAuBE,IAC9CiY,EAAA6tB,EAAA9lC,GACA2V,EAAA/Y,KAAAqpC,QAAAhuB,GACAtC,EAAA2uB,aACA90B,EAAArS,KAAA2O,EAAA6J,EAAAsC,IASAsyB,UAAA,WACA,MAAA3tC,MAAAqpC,SAGAmC,mBAAA,SAAAvyB,GAEA,GAAAmwB,GAAAppC,KAAAqpC,QACAuE,EAAA5tC,KAAA8pC,mBAEA+D,KACAC,IAEA9tC,MAAAyrC,iBAAA,SAAA1yB,EAAAsC,GACAwyB,EAAAxyB,GAAAtC,EAAAg1B,QACAh1B,EAAAg1B,QAAA,EACAh1B,EAAAqD,SAAA,IAGA/a,EAAAqR,KAAAk7B,EAAA,SAAA70B,EAAAiE,GACA8wB,EAAA9wB,GAAAjE,EAAAg1B,QACAh1B,EAAAg1B,QAAA,EACAh1B,EAAAqD,SAAA,GAOA,KAAA,GAHA4vB,GACAgC,EAFAC,EAAA,EAGAC,EAAA,EACA9qC,EAAA,EAAAyX,EAAA5B,EAAA/V,OAA4CE,EAAAyX,EAAOzX,IAAA,CACnD,GAAAmK,GAAA0L,EAAA7V,GACAgY,EAAApb,KAAA+oC,cAAA,EAAAx7B,EAAA6N,OACArC,EAAAqwB,EAAAhuB,GACA+yB,EAAA5gC,EAAA6gC,WAOA,IANAr1B,IACAA,EAAAg1B,UACAh1B,EAAAqD,QAAArD,EAAAqD,SAAA7O,EAAA6O,SAIA+xB,GAAA,EAAA,CAEAH,IAAAG,IACAH,EAAAG,EACAD,IAEA,IAAA9B,GAAA7+B,EAAA8+B,QAAA6B,EAAA,CACA,KAAAlC,EAAA,CACA,GAAAhvB,GAAA0D,KAAArZ,IAAA4mC,EAAAxF,EAAA,EACAuD,GAAA4B,EAAA5wB,GACAgvB,IACAA,EAAA4B,EAAA5wB,GAAA,GAAAwrB,GACA,cAAAxoC,KAAAA,KAAA6O,KAEAm9B,EAAAtC,eAEAsC,EAAAQ,cAAA,EAEAR,EAAA5vB,QAAA4vB,EAAA5vB,SAAA7O,EAAA6O,QACA4vB,EAAA+B,UAEA/B,EAAAQ,cAAA9rB,KAAApZ,IACA0kC,EAAAQ,cAAAJ,GAGAJ,EAAAQ,eAAAR,EAAAO,aAEAxzB,EAAAqD,SAAA,OAIA7O,GAAA8+B,WAEAL,IACAA,EAAAS,iBAAArpC,EACA6qC,IACAjC,EAAA,MAKAA,IACAiC,IACAjC,EAAAS,iBAAArpC,GAIApD,KAAAyrC,iBAAA,SAAA1yB,EAAAsC,GACAwyB,EAAAxyB,KAAAtC,EAAAg1B,UACAh1B,EAAAqD,SAAA,KAIAwxB,EAAA1qC,OAAAwd,KAAArZ,IAAA4mC,EAAAxF,GACApnC,EAAAqR,KAAAk7B,EAAA,SAAA70B,EAAAiE,GACA8wB,EAAA9wB,KAAAjE,EAAAg1B,UACAxgC,EAAA6O,SAAA,GAEArD,EAAAqD,UACArD,EAAAwzB,WAAA,MAQA9mC,MAAA,WAEA,MADAzF,MAAAyrC,iBAAAzrC,KAAAquC,aACAruC,MAGAquC,YAAA,SAAAt1B,GACAA,EAAAtT,SAaAuI,YAAA,SAAAoN,EAAAlN,GACA,GAAAA,EAAA,CACA,GAAAogC,GAAAtuC,KAAAspC,YACAgF,GAAAlzB,GAIA/Z,EAAA4P,MAAAq9B,EAAAlzB,GAAAlN,GAAA,GAHAogC,EAAAlzB,GAAAlN,CAMA,IAAA6K,GAAA/Y,KAAAqpC,QAAAjuB,EAEArC,IACA1X,EAAA4P,MAAA8H,EAAAu1B,EAAAlzB,IAAA,KASAmzB,SAAA,SAAAnzB,GACA,GAAAguB,GAAAppC,KAAAqpC,QACAH,EAAAlpC,KAAAmpC,YACApwB,EAAAqwB,EAAAhuB,EACArC,KAGAA,EAAAnY,IAAA6X,WAAA+1B,YAAAz1B,EAAAnY,WACAwoC,GAAAhuB,GAEA8tB,EAAAnuB,OAAA1Z,EAAAoI,QAAAy/B,EAAA9tB,GAAA,KAMAlZ,OAAA,SAAA6B,EAAAM,GACA,GAAAikC,GAAAtoC,KAAA2pC,QAEArB,GAAAljC,MAAAqpC,QAAA,MAGA,IAAA5tC,GAAAb,KAAA8oC,KAUA,IATA,MAAA/kC,IAAAlD,EAAAkD,MAAAA,GACA,MAAAM,IAAAxD,EAAAwD,OAAAA,GAEAN,EAAA/D,KAAA4pC,SAAA,GACAvlC,EAAArE,KAAA4pC,SAAA,GAEAtB,EAAAljC,MAAAqpC,QAAA,GAGAzuC,KAAAupC,QAAAxlC,GAAAM,GAAArE,KAAAwpC,QAAA,CACAlB,EAAAljC,MAAArB,MAAAA,EAAA,KACAukC,EAAAljC,MAAAf,OAAAA,EAAA,IAEA,KAAA,GAAAhE,KAAAL,MAAAqpC,QACArpC,KAAAqpC,QAAAt9B,eAAA1L,IACAL,KAAAqpC,QAAAhpC,GAAA6B,OAAA6B,EAAAM,EAGAhD,GAAAqR,KAAA1S,KAAA8pC,mBAAA,SAAA/wB,GACAA,EAAA7W,OAAA6B,EAAAM,KAGArE,KAAAoO,SAAA,GAMA,MAHApO,MAAAupC,OAAAxlC,EACA/D,KAAAwpC,QAAAnlC,EAEArE,MAOA0uC,WAAA,SAAAtzB,GACA,GAAArC,GAAA/Y,KAAAqpC,QAAAjuB,EACArC,IACAA,EAAAtT,SAOAoF,QAAA,WACA7K,KAAAN,KAAAupC,UAAA,GAEAjpC,KAAAN,KACAM,KAAAoM,QAEApM,KAAA2pC,SACA3pC,KAAAqpC,QAAA,MAQAsF,kBAAA,SAAA9tC,GAEA,GADAA,EAAAA,MACAb,KAAA+oC,cACA,MAAA/oC,MAAAqpC,QAAA,GAAAzoC,GAGA,IAAAguC,GAAA,GAAApG,GAAA,QAAAxoC,KAAAa,EAAAguC,YAAA7uC,KAAA6O,IACA+/B,GAAAlF,cAEAkF,EAAAE,WAAAjuC,EAAAkuC,gBACAH,EAAAnpC,OAKA,KAAA,GAHAuW,GAAAhc,KAAAoM,QAAA8M,gBAAA,GAEA2xB,KACAznC,EAAA,EAA2BA,EAAA4Y,EAAA9Y,OAAwBE,IAAA,CACnD,GAAAmK,GAAAyO,EAAA5Y,EACApD,MAAAgrC,WAAAz9B,EAAAqhC,GAAA,EAAA/D,GAGA,MAAA+D,GAAAhuC,KAKA4F,SAAA,WACA,MAAAxG,MAAAupC,QAMA9iC,UAAA,WACA,MAAAzG,MAAAwpC,SAGAI,SAAA,SAAAoF,GACA,GAAAnuC,GAAAb,KAAA8oC,MACAmG,GAAA,QAAA,UAAAD,GACAE,GAAA,cAAA,gBAAAF,GACAG,GAAA,cAAA,cAAAH,GACAI,GAAA,eAAA,iBAAAJ,EAEA,IAAA,MAAAnuC,EAAAouC,IAAA,SAAApuC,EAAAouC,GACA,MAAArgB,YAAA/tB,EAAAouC,GAGA,IAAAvvC,GAAAM,KAAAN,KACA2vC,EAAAt/B,SAAAu/B,YAAAC,iBAAA7vC,EAEA,QACAA,EAAAwvC,IAAA1H,EAAA6H,EAAAJ,KAAAzH,EAAA9nC,EAAA0F,MAAA6pC,MACAzH,EAAA6H,EAAAF,KAAA,IACA3H,EAAA6H,EAAAD,KAAA,GACA,GAGAxgC,YAAA,SAAAqV,EAAApV,GACAA,EAAAA,GAAA7O,KAAA6O,GAEA,IAAAhD,GAAAkE,SAAAC,cAAA,UACA0K,EAAA7O,EAAAoE,WAAA,MACA6N,EAAAmG,EAAA7f,kBACAgB,EAAA6e,EAAA7e,MACAoqC,EAAApqC,EAAAwmC,WACA6D,EAAArqC,EAAAqqC,cACAC,EAAAtqC,EAAAsqC,cACAC,EAAAvqC,EAAAwqC,YAAAxqC,EAAAuqC,UAAA,EAEAE,EAAAnvB,KAAApZ,IAAAqoC,EAAA,GAAAF,EAAAD,GACAM,EAAApvB,KAAApZ,IAAAqoC,EAAA,EAAAF,EAAAD,GACAO,EAAArvB,KAAApZ,IAAAqoC,EAAA,GAAAD,EAAAF,GACAQ,EAAAtvB,KAAApZ,IAAAqoC,EAAA,EAAAD,EAAAF,GACAzrC,EAAA+Z,EAAA/Z,MAAA8rC,EAAAC,EACAzrC,EAAAyZ,EAAAzZ,OAAA0rC,EAAAC,CAEAnkC,GAAA9H,MAAAA,EAAA8K,EACAhD,EAAAxH,OAAAA,EAAAwK,EAEA6L,EAAAvU,MAAA0I,EAAAA,GACA6L,EAAAu1B,UAAA,EAAA,EAAAlsC,EAAAM,GACAqW,EAAA7L,IAAAA,CAEA,IAAAqhC,IACAhqC,SAAA+d,EAAA/d,SACAyZ,SAAAsE,EAAAtE,SACAxZ,MAAA8d,EAAA9d,MAEA8d,GAAA/d,UAAA2pC,EAAA/xB,EAAAvb,EAAAwtC,EAAAjyB,EAAArb,GACAwhB,EAAAtE,SAAA,EACAsE,EAAA9d,OAAA,EAAA,GACA8d,EAAAxH,kBACAwH,GACAA,EAAAgpB,MAAAvyB,EAGA,IAAAy1B,GAAAjwC,EAAA,IACAkwC,EAAA,GAAAD,IACA/qC,OACA7C,EAAA,EACAE,EAAA,EACA4tC,MAAAxkC,IAgBA,OAZA,OAAAqkC,EAAAhqC,WACAkqC,EAAAlqC,SAAA+d,EAAA/d,SAAAgqC,EAAAhqC,UAGA,MAAAgqC,EAAAvwB,WACAywB,EAAAzwB,SAAAsE,EAAAtE,SAAAuwB,EAAAvwB,UAGA,MAAAuwB,EAAA/pC,QACAiqC,EAAAjqC,MAAA8d,EAAA9d,MAAA+pC,EAAA/pC,OAGAiqC,IAIAvwC,EAAAD,QAAA8oC,GhCs7PM,SAAS7oC,EAAQD,EAASM,GiCn+RhC,QAAAowC,KACA,OAAA,EAYA,QAAAC,GAAAlwC,EAAAqF,EAAA6G,EAAAsC,GACA,GAAA2hC,GAAAzgC,SAAAC,cAAAtK,GACA3B,EAAAwI,EAAA/F,WACAnC,EAAAkI,EAAA9F,YAEAgqC,EAAAD,EAAAprC,KAYA,OAVAqrC,GAAAvqC,SAAA,WACAuqC,EAAAvR,KAAA,EACAuR,EAAAhO,IAAA,EACAgO,EAAA1sC,MAAAA,EAAA,KACA0sC,EAAApsC,OAAAA,EAAA,KACAmsC,EAAAzsC,MAAAA,EAAA8K,EACA2hC,EAAAnsC,OAAAA,EAAAwK,EAGA2hC,EAAA/lC,aAAA,iBAAApK,GACAmwC,EAnCA,GAAAnvC,GAAAnB,EAAA,GACAgO,EAAAhO,EAAA,IACAwwC,EAAAxwC,EAAA,IACAywC,EAAAzwC,EAAA,IA2CAsoC,EAAA,SAAAnoC,EAAAkM,EAAAsC,GACA,GAAAjO,EACAiO,GAAAA,GAAAX,EAAA9M,iBACA,gBAAAf,GACAO,EAAA2vC,EAAAlwC,EAAA,SAAAkM,EAAAsC,GAGAxN,EAAA8P,SAAA9Q,KACAO,EAAAP,EACAA,EAAAO,EAAAP,IAEAL,KAAAK,GAAAA,EACAL,KAAAY,IAAAA,CAEA,IAAAgwC,GAAAhwC,EAAAwE,KACAwrC,KACAhwC,EAAAiwC,cAAAP,EACAM,EAAA,uBAAA,OACAA,EAAA,eAAA,OACAA,EAAA,yBAAA,OACAA,EAAA,+BAAA,gBACAA,EAAA,QAAA,EACAA,EAAA,OAAA,EACAA,EAAA,gBAAA,GAGA5wC,KAAA8wC,QAAA,KACA9wC,KAAA+wC,QAAA,KAEA/wC,KAAAuM,QAAAA,EAEAvM,KAAAkO,OAAA,KAQAlO,KAAA8uC,WAAA,EAMA9uC,KAAAgxC,YAAA,EAMAhxC,KAAAixC,eAAA,GAMAjxC,KAAA6O,IAAAA,EAGA25B,GAAA5mC,WAEA+L,YAAA66B,EAEAuF,QAAA,EAEA3xB,SAAA,EAEAstB,YAAA,WACA1pC,KAAA0a,IAAA1a,KAAAY,IAAAqP,WAAA,MAEAjQ,KAAA0a,IAAA7L,IAAA7O,KAAA6O,KAGAqiC,iBAAA,WACA,GAAAriC,GAAA7O,KAAA6O,GAEA7O,MAAA8wC,QAAAP,EAAA,QAAAvwC,KAAAK,GAAA,SAAAL,KAAAuM,QAAAsC,GACA7O,KAAA+wC,QAAA/wC,KAAA8wC,QAAA7gC,WAAA,MAEA,GAAApB,GACA7O,KAAA+wC,QAAA5qC,MAAA0I,EAAAA,IAQA3M,OAAA,SAAA6B,EAAAM,GACA,GAAAwK,GAAA7O,KAAA6O,IAEAjO,EAAAZ,KAAAY,IACAgwC,EAAAhwC,EAAAwE,MACA0rC,EAAA9wC,KAAA8wC,OAEAF,GAAA7sC,MAAAA,EAAA,KACA6sC,EAAAvsC,OAAAA,EAAA,KAEAzD,EAAAmD,MAAAA,EAAA8K,EACAjO,EAAAyD,OAAAA,EAAAwK,EAEAiiC,IACAA,EAAA/sC,MAAAA,EAAA8K,EACAiiC,EAAAzsC,OAAAA,EAAAwK,EAEA,GAAAA,GACA7O,KAAA+wC,QAAA5qC,MAAA0I,EAAAA,KASApJ,MAAA,SAAA0rC,GACA,GAAAvwC,GAAAZ,KAAAY,IACA8Z,EAAA1a,KAAA0a,IACA3W,EAAAnD,EAAAmD,MACAM,EAAAzD,EAAAyD,OAEAyqC,EAAA9uC,KAAA8uC,WACAsC,EAAApxC,KAAAgxC,aAAAG,EACAF,EAAAjxC,KAAAixC,eAEApiC,EAAA7O,KAAA6O,GAgBA,IAdAuiC,IACApxC,KAAA8wC,SACA9wC,KAAAkxC,mBAGAlxC,KAAA+wC,QAAAM,yBAAA,OACArxC,KAAA+wC,QAAAjF,UACAlrC,EAAA,EAAA,EACAmD,EAAA8K,EACAxK,EAAAwK,IAIA6L,EAAAu1B,UAAA,EAAA,EAAAlsC,EAAAM,GACAyqC,EAAA,CACA,GAAAwC,EAEAxC,GAAAyC,YAEAD,EAAAxC,EAAA0C,kBAAAd,EAAAe,YAAA/2B,EAAAo0B,GACAvsC,EAAA,EACAE,EAAA,EACAsB,MAAAA,EACAM,OAAAA,IAGAyqC,EAAA0C,iBAAAF,GAGAxC,EAAAuB,QACAiB,EAAAX,EAAA/uC,UAAA8vC,iBAAAnxC,KAAAuuC,EAAAp0B,IAEAA,EAAAowB,OACApwB,EAAAi3B,UAAAL,GAAAxC,EACAp0B,EAAAk3B,SAAA,EAAA,EAAA7tC,EAAAM,GACAqW,EAAAuwB,UAGA,GAAAmG,EAAA,CACA,GAAAN,GAAA9wC,KAAA8wC,OACAp2B,GAAAowB,OACApwB,EAAAixB,YAAAsF,EACAv2B,EAAAoxB,UAAAgF,EAAA,EAAA,EAAA/sC,EAAAM,GACAqW,EAAAuwB,aAKAprC,EAAAD,QAAA4oC,GjCq/RM,SAAS3oC,EAAQD,GkCxsSvB,QAAAiyC,GAAAn3B,EAAA/H,EAAAmL,GAEA,GAAAvb,GAAAoQ,EAAApQ,EACAuvC,EAAAn/B,EAAAm/B,GACArvC,EAAAkQ,EAAAlQ,EACAsvC,EAAAp/B,EAAAo/B,EAEAp/B,GAAAq/B,SACAzvC,EAAAA,EAAAub,EAAA/Z,MAAA+Z,EAAAvb,EACAuvC,EAAAA,EAAAh0B,EAAA/Z,MAAA+Z,EAAAvb,EACAE,EAAAA,EAAAqb,EAAAzZ,OAAAyZ,EAAArb,EACAsvC,EAAAA,EAAAj0B,EAAAzZ,OAAAyZ,EAAArb,EAGA,IAAAwvC,GAAAv3B,EAAAm3B,qBAAAtvC,EAAAE,EAAAqvC,EAAAC,EAEA,OAAAE,GAGA,QAAAC,GAAAx3B,EAAA/H,EAAAmL,GACA,GAAA/Z,GAAA+Z,EAAA/Z,MACAM,EAAAyZ,EAAAzZ,OACAgD,EAAAqZ,KAAArZ,IAAAtD,EAAAM,GAEA9B,EAAAoQ,EAAApQ,EACAE,EAAAkQ,EAAAlQ,EACAwsB,EAAAtc,EAAAsc,CACAtc,GAAAq/B,SACAzvC,EAAAA,EAAAwB,EAAA+Z,EAAAvb,EACAE,EAAAA,EAAA4B,EAAAyZ,EAAArb,EACAwsB,GAAA5nB,EAGA,IAAA4qC,GAAAv3B,EAAAw3B,qBAAA3vC,EAAAE,EAAA,EAAAF,EAAAE,EAAAwsB,EAEA,OAAAgjB,GA/CA,GAAAE,KACA,aAAA,IAAA,gBAAA,IAAA,gBAAA,IAAA,cAAA,SACA,UAAA,SAAA,WAAA,UAAA,aAAA,KAMAzB,EAAA,SAAA7vC,GACAb,KAAAoyC,WAAAvxC,GA0CA6vC,GAAA9uC,WAEA+L,YAAA+iC,EAKA2B,KAAA,UAKAC,OAAA,KAKA3F,QAAA,EAKA4F,SAAA,KAKAC,eAAA,EAKA5G,WAAA,EAKA6D,cAAA,EAKAC,cAAA,EAKAC,UAAA,EAMA8C,eAAA,EAOAC,KAAA,KAKAC,SAAA,OAKAC,WAAA,KAQAC,aAAA,SAMAC,WAAA,KAKAC,aAAA,KAKAC,UAAA,KAKAC,kBAAA,KAMAC,aAAA,EAMAC,eAAA,EAMAC,kBAAA,EAMAC,kBAAA,EAOAC,eAAA,EAMAC,aAAA,EAMAC,MAAA,KAKA1mC,KAAA,SAAA4N,EAAAnN,EAAAw/B,GAKA,IAAA,GAJA3nC,GAAApF,KACAyzC,EAAA1G,GAAAA,EAAA3nC,MACAsuC,GAAAD,EAEArwC,EAAA,EAA2BA,EAAA+uC,EAAAjvC,OAA+BE,IAAA,CAC1D,GAAAiP,GAAA8/B,EAAA/uC,GACAuwC,EAAAthC,EAAA,IAEAqhC,GAAAtuC,EAAAuuC,KAAAF,EAAAE,MAEAj5B,EAAAi5B,GAAAvuC,EAAAuuC,IAAAthC,EAAA,IAiBA,IAbAqhC,GAAAtuC,EAAAitC,OAAAoB,EAAApB,QACA33B,EAAAi3B,UAAAvsC,EAAAitC,OAEAqB,GAAAtuC,EAAAktC,SAAAmB,EAAAnB,UACA53B,EAAAk5B,YAAAxuC,EAAAktC,SAEAoB,GAAAtuC,EAAAunC,UAAA8G,EAAA9G,WACAjyB,EAAAixB,YAAA,MAAAvmC,EAAAunC,QAAA,EAAAvnC,EAAAunC,UAGA+G,GAAAtuC,EAAAouC,QAAAC,EAAAD,SACA94B,EAAA22B,yBAAAjsC,EAAAouC,OAAA,eAEAxzC,KAAA4vC,YAAA,CACA,GAAAD,GAAAvqC,EAAAuqC,SACAj1B,GAAAi1B,UAAAA,GACA3vC,KAAAyyC,eAAAllC,GAAAA,EAAAsmC,aAAAtmC,EAAAsmC,eAAA,KAKAC,QAAA,WACA,GAAAzB,GAAAryC,KAAAqyC,IACA,OAAA,OAAAA,GAAA,SAAAA,GAGAzC,UAAA,WACA,GAAA0C,GAAAtyC,KAAAsyC,MACA,OAAA,OAAAA,GAAA,SAAAA,GAAAtyC,KAAA2vC,UAAA,GAQAyC,WAAA,SAAA2B,EAAA7iC,GACA,GAAA6iC,EAAA,CACA,GAAA/tC,GAAAhG,IACA,KAAA,GAAAuF,KAAAwuC,IACAA,EAAAhoC,eAAAxG,KACA2L,GAAAlL,EAAA+F,eAAAxG,KAEAS,EAAAT,GAAAwuC,EAAAxuC,MAWAqd,IAAA,SAAAjQ,EAAAZ,GACA,gBAAAY,GACA3S,KAAA2S,GAAAZ,EAGA/R,KAAAoyC,WAAAz/B,GAAA,IAQApC,MAAA,WACA,GAAAyjC,GAAA,GAAAh0C,MAAA2N,WAEA,OADAqmC,GAAA5B,WAAApyC,MAAA,GACAg0C,GAGAvC,YAAA,SAAA/2B,EAAA/H,EAAAmL,GAIA,IAAA,GAHAm2B,GAAA,WAAAthC,EAAAjN,KAAAwsC,EAAAL,EACAI,EAAAgC,EAAAv5B,EAAA/H,EAAAmL,GACAyzB,EAAA5+B,EAAA4+B,WACAnuC,EAAA,EAA2BA,EAAAmuC,EAAAruC,OAAuBE,IAClD6uC,EAAAiC,aACA3C,EAAAnuC,GAAAo8B,OAAA+R,EAAAnuC,GAAAulB,MAGA,OAAAspB,IAKA,KAAA,GADAkC,GAAAzD,EAAA9uC,UACAwB,EAAA,EAAmBA,EAAA+uC,EAAAjvC,OAA+BE,IAAA,CAClD,GAAAiP,GAAA8/B,EAAA/uC,EACAiP,GAAA,IAAA8hC,KACAA,EAAA9hC,EAAA,IAAAA,EAAA,IAKAq+B,EAAAe,YAAA0C,EAAA1C,YAEA5xC,EAAAD,QAAA8wC,GlCguSM,SAAS7wC,EAAQD,GmCzhTvB,GAAA+wC,GAAA,SAAAN,EAAA+D,GACAp0C,KAAAqwC,MAAAA,EACArwC,KAAAo0C,OAAAA,EAGAp0C,KAAA0F,KAAA,UAGAirC,GAAA/uC,UAAA8vC,iBAAA,SAAAh3B,GAEA,MAAA1a,MAAAq0C,iBACAr0C,KAAAq0C,eAAA35B,EAAA45B,cAAAt0C,KAAAqwC,MAAArwC,KAAAo0C,UAGAv0C,EAAAD,QAAA+wC,GnCkiTM,SAAS9wC,EAAQD,EAASM,GoC/hThC,QAAAq0C,GAAA1zC,GACA2zC,EAAAj0C,KAAAP,KAAAa,GAbA,GAAA2zC,GAAAt0C,EAAA,IACAqd,EAAArd,EAAA,IACA8K,EAAA9K,EAAA,GAEAqyB,EAAAryB,EAAA,IACAu0C,EAAA,GAAAliB,GAAA,GAWAgiB,GAAA3yC,WAEA+L,YAAA4mC,EAEA7uC,KAAA,QAEAunC,MAAA,SAAAvyB,EAAAqyB,GACA,GAEAsD,GAFAjrC,EAAApF,KAAAoF,MACAsvC,EAAAtvC,EAAAirC,KAcA,IAVAjrC,EAAA0H,KAAA4N,EAAA1a,KAAA+sC,GAGAsD,EADA,gBAAAqE,GACA10C,KAAA20C,OAIAD,GAGArE,GAAAqE,EAAA,CAEA,GAAAE,GAAAH,EAAAjnC,IAAAknC,EACA,KAAAE,EAgBA,MAdAvE,GAAA,GAAAwE,OACAxE,EAAAyE,OAAA,WACAzE,EAAAyE,OAAA,IACA,KAAA,GAAA1xC,GAAA,EAAuCA,EAAAwxC,EAAAG,QAAA7xC,OAAiCE,IACxEwxC,EAAAG,QAAA3xC,GAAA8Z,SAGA03B,GACAvE,MAAAA,EACA0E,SAAA/0C,OAEAqwC,EAAAqE,IAAAA,EACAD,EAAAhlB,IAAAilB,EAAAE,QACA50C,KAAA20C,OAAAtE,EAOA,IAHAA,EAAAuE,EAAAvE,MACArwC,KAAA20C,OAAAtE,GAEAA,EAAAtsC,QAAAssC,EAAAhsC,OAEA,WADAuwC,GAAAG,QAAAtxC,KAAAzD,MAMA,GAAAqwC,EAAA,CASA,GAAA9tC,GAAA6C,EAAA7C,GAAA,EACAE,EAAA2C,EAAA3C,GAAA,CAEA,KAAA4tC,EAAAtsC,QAAAssC,EAAAhsC,OACA,MAEA,IAAAN,GAAAqB,EAAArB,MACAM,EAAAe,EAAAf,OACA2wC,EAAA3E,EAAAtsC,MAAAssC,EAAAhsC,MAgBA,IAfA,MAAAN,GAAA,MAAAM,EAEAN,EAAAM,EAAA2wC,EAEA,MAAA3wC,GAAA,MAAAN,EACAM,EAAAN,EAAAixC,EAEA,MAAAjxC,GAAA,MAAAM,IACAN,EAAAssC,EAAAtsC,MACAM,EAAAgsC,EAAAhsC,QAIArE,KAAAqgB,aAAA3F,GAEAtV,EAAA6vC,QAAA7vC,EAAA8vC,QAAA,CACA,GAAA10B,GAAApb,EAAAob,IAAA,EACAC,EAAArb,EAAAqb,IAAA,CACA/F,GAAAoxB,UACAuE,EACA7vB,EAAAC,EAAArb,EAAA6vC,OAAA7vC,EAAA8vC,QACA3yC,EAAAE,EAAAsB,EAAAM,OAGA,IAAAe,EAAAob,IAAApb,EAAAqb,GAAA,CACA,GAAAD,GAAApb,EAAAob,GACAC,EAAArb,EAAAqb,GACAw0B,EAAAlxC,EAAAyc,EACA00B,EAAA7wC,EAAAoc,CACA/F,GAAAoxB,UACAuE,EACA7vB,EAAAC,EAAAw0B,EAAAC,EACA3yC,EAAAE,EAAAsB,EAAAM,OAIAqW,GAAAoxB,UAAAuE,EAAA9tC,EAAAE,EAAAsB,EAAAM,EAGArE,MAAAsgB,iBAAA5F,GAGA,MAAAtV,EAAAstC,MACA1yC,KAAAm1C,aAAAz6B,EAAA1a,KAAAoE,qBAMAA,gBAAA,WACA,GAAAgB,GAAApF,KAAAoF,KAMA,OALApF,MAAAo1C,QACAp1C,KAAAo1C,MAAA,GAAA73B,GACAnY,EAAA7C,GAAA,EAAA6C,EAAA3C,GAAA,EAAA2C,EAAArB,OAAA,EAAAqB,EAAAf,QAAA,IAGArE,KAAAo1C,QAIApqC,EAAAgH,SAAAuiC,EAAAC,GAEA30C,EAAAD,QAAA20C,GpCyjTM,SAAS10C,EAAQD,EAASM,GqCjsThC,QAAAs0C,GAAA3zC,GAEAA,EAAAA,MAEAyc,EAAA/c,KAAAP,KAAAa,EAGA,KAAA,GAAA0E,KAAA1E,GAEAA,EAAAkL,eAAAxG,IACA,UAAAA,IAEAvF,KAAAuF,GAAA1E,EAAA0E,GAOAvF,MAAAoF,MAAA,GAAAsrC,GAAA7vC,EAAAuE,OAEApF,KAAAo1C,MAAA,KAEAp1C,KAAA6c,eApCA,GAAA7R,GAAA9K,EAAA,GAEAwwC,EAAAxwC,EAAA,IAEAod,EAAApd,EAAA,IACAm1C,EAAAn1C,EAAA,GAqCAs0C,GAAA5yC,WAEA+L,YAAA6mC,EAEA9uC,KAAA,cAQA0W,SAAA,EASA6B,WAAA,EAOA5C,EAAA,EAOAC,GAAA,EAQAF,OAAA,EAQA1B,WAAA,EAQAE,UAAA,EAQA5C,QAAA,EAOA41B,SAAA,EAOA30B,OAAA,UAOAlB,WAAA,EAOAq3B,eAEApB,YAAA,SAAAtyB,KAEAwyB,WAAA,SAAAxyB,KAOAuyB,MAAA,SAAAvyB,EAAAqyB,KAOA3oC,gBAAA,aASA8S,QAAA,SAAA3U,EAAAE,GACA,MAAAzC,MAAAs1C,YAAA/yC,EAAAE,IAOAmZ,SAAA,SAAAhJ,EAAA1D,GACA0D,EAAArS,KAAA2O,EAAAlP,OAUAs1C,YAAA,SAAA/yC,EAAAE,GACA,GAAA8yC,GAAAv1C,KAAA8gB,sBAAAve,EAAAE,GACAqb,EAAA9d,KAAAoE,iBACA,OAAA0Z,GAAA5G,QAAAq+B,EAAA,GAAAA,EAAA,KAOAr4B,MAAA,WACAld,KAAAoc,SAAA,EAEApc,KAAAo1C,MAAA,KAEAp1C,KAAAkY,MAAAlY,KAAAkY,KAAA9J,WAsBAonC,aAAA,SAAAtxB,GACA,MAAAlkB,MAAAgkB,QAAA,QAAAE,IAGAvF,OAAA,SAAAhU,EAAAoH,GACA,UAAApH,EACA2S,EAAA1b,UAAA+c,OAAApe,KAAAP,KAAA2K,EAAAoH,GAGA/R,KAAAoF,MAAAwd,IAAA7Q,IAQA04B,SAAA,SAAA9/B,EAAAoH,GAGA,MAFA/R,MAAAoF,MAAAwd,IAAAjY,EAAAoH,GACA/R,KAAAkd,OAAA,GACAld,MAOAy1C,SAAA,SAAA9iC,GAGA,MAFA3S,MAAAoF,MAAA,GAAAsrC,GAAA/9B,GACA3S,KAAAkd,OAAA,GACAld,OAIAgL,EAAAgH,SAAAwiC,EAAAl3B,GAEAtS,EAAAuH,MAAAiiC,EAAAa,GAGAx1C,EAAAD,QAAA40C,GrC6tTM,SAAS30C,EAAQD,EAASM,GsC19ThC,QAAAw1C,GAAA3jC,EAAA4jC,GACA,MAAA,gBAAA5jC,GACAA,EAAA6jC,YAAA,MAAA,EACAhnB,WAAA7c,GAAA,IAAA4jC,EAEA/mB,WAAA7c,GAEAA,EAdA,GAAA8jC,GAAA31C,EAAA,IACAqd,EAAArd,EAAA,IAEA6d,EAAA,GAAAR,GAEA83B,EAAA,YAYAA,GAAAzzC,WAEA+L,YAAA0nC,EAQAF,aAAA,SAAAz6B,EAAAoD,EAAAg4B,GACA,GAAA1wC,GAAApF,KAAAoF,MACAstC,EAAAttC,EAAAstC,IAGA,IADA,MAAAA,IAAAA,GAAA,IACAA,EAAA,CAKAh4B,EAAAowB,MAEA,IAAAvoC,GACAE,EACAowC,EAAAztC,EAAAytC,aACAC,EAAA1tC,EAAA0tC,WACAxvB,EAAAle,EAAA8tC,aACA6C,EAAA3wC,EAAA4tC,UACAgD,EAAA5wC,EAAA6wC,UAAA7wC,EAAA4wC,KACAE,EAAA9wC,EAAA2tC,aACAoD,EAAA/wC,EAAA6tC,iBAEA6C,GAAAA,GAAAD,EAAAzxC,gBAAAsuC,EAAAsD,EAAAD,EAAAG,EAGA,IAAA/3B,GAAAne,KAAAme,SAaA,IAZA/Y,EAAAkuC,cAQAtzC,KAAAqgB,aAAA3F,GAPAyD,IACAJ,EAAAM,KAAAP,GACAC,EAAAO,eAAAH,GACAL,EAAAC,GAQA80B,YAAA78B,QAOA,GALAzT,EAAAub,EAAAvb,EAAAmzC,EAAA7C,EAAA,GAAA/0B,EAAA/Z,OACAtB,EAAAqb,EAAArb,EAAAizC,EAAA7C,EAAA,GAAA/0B,EAAAzZ,QACA0xC,EAAAA,GAAA,OACAG,EAAAA,GAAA,MAEAC,EAAA,CACA,OAAAA,GACA,IAAA,SACA1zC,GAAAqzC,EAAAzxC,OAAA,EAAAyxC,EAAAM,WAAA,CACA,MACA,KAAA,SACA3zC,GAAAqzC,EAAAzxC,OAAAyxC,EAAAM,WAAA,CACA,MACA,SACA3zC,GAAAqzC,EAAAM,WAAA,EAGAF,EAAA,cAGA,CACA,GAAAG,GAAAR,EAAAS,yBACAzD,EAAA/0B,EAAAg4B,EAAAxyB,EAEA/gB,GAAA8zC,EAAA9zC,EACAE,EAAA4zC,EAAA5zC,EAEAszC,EAAAA,GAAAM,EAAArD,UACAkD,EAAAA,GAAAG,EAAAtD,aAGAD,IACAvwC,GAAAuwC,EAAA,GACArwC,GAAAqwC,EAAA,IAIAp4B,EAAAs4B,UAAA+C,GAAA,OAEAr7B,EAAAq4B,aAAAmD,GAAA,YAEA,IAAAvD,GAAAvtC,EAAAutC,SACAC,EAAAxtC,EAAAwtC,UACAD,KAAAj4B,EAAAi3B,UAAAgB,GACAC,IAAAl4B,EAAAk5B,YAAAhB,GAGAl4B,EAAAs7B,KAAAA,GAAA,kBAIAt7B,EAAAkxB,WAAAxmC,EAAA+tC,eACAz4B,EAAA67B,YAAAnxC,EAAAoxC,iBAAA,cACA97B,EAAA+0B,cAAArqC,EAAAguC,kBACA14B,EAAAg1B,cAAAtqC,EAAAiuC,iBAEA,IAAAoD,GAAA/D,EAAAruB,MAAA,KAEAjf,GAAAmuC,eACAp1B,GAAAzD,EAAAkH,UAAAzD,EAAA,GAAAA,EAAA,IACAzD,EAAA0F,OAAAhb,EAAAmuC,cACAp1B,GAAAzD,EAAAkH,WAAAzD,EAAA,IAAAA,EAAA,IAGA,KAAA,GAAA/a,GAAA,EAA2BA,EAAAqzC,EAAAvzC,OAAsBE,IAEjDwvC,GAAAl4B,EAAAg8B,WAAAD,EAAArzC,GAAAb,EAAAE,GACAkwC,GAAAj4B,EAAAi8B,SAAAF,EAAArzC,GAAAb,EAAAE,GACAA,GAAAqzC,EAAAM,UAGA17B,GAAAuwB,aAIAprC,EAAAD,QAAAy1C,GtC++TM,SAASx1C,EAAQD,EAASM,GuC1nUhC,QAAA02C,GAAAlE,EAAAuD,GACA,GAAAtrC,GAAA+nC,EAAA,IAAAuD,CACA,IAAAY,EAAAlsC,GACA,MAAAksC,GAAAlsC,EAMA,KAAA,GAHA8rC,IAAA/D,EAAA,IAAAruB,MAAA,MACAtgB,EAAA,EAEAX,EAAA,EAAAyX,EAAA47B,EAAAvzC,OAA6CE,EAAAyX,EAAOzX,IAEpDW,EAAA2c,KAAApZ,IAAAuuC,EAAAiB,YAAAL,EAAArzC,GAAA6yC,GAAAlyC,MAAAA,EAUA,OAPAgzC,GAAAC,IACAD,EAAA,EACAF,MAEAE,IACAF,EAAAlsC,GAAA5G,EAEAA,EAGA,QAAAkzC,GAAAvE,EAAAuD,EAAAjD,EAAAD,GACA,GAAAmE,KAAAxE,GAAA,IAAA,IAAAruB,MAAA,MAAAnhB,OAEAa,EAAA6yC,EAAAlE,EAAAuD,GAEAG,EAAAQ,EAAA,IAAAX,GACA5xC,EAAA6yC,EAAAd,EAEAt4B,EAAA,GAAAP,GAAA,EAAA,EAAAxZ,EAAAM,EAIA,QAFAyZ,EAAAs4B,WAAAA,EAEArD,GACA,IAAA,SACA,IAAA,aACAj1B,EAAArb,GAAA2zC,CACA,MACA,KAAA,SACAt4B,EAAArb,GAAA2zC,EAAA,EAOA,OAAApD,GACA,IAAA,MACA,IAAA,QACAl1B,EAAAvb,GAAAub,EAAA/Z,KACA,MACA,KAAA,SACA+Z,EAAAvb,GAAAub,EAAA/Z,MAAA,EAMA,MAAA+Z,GAGA,QAAAw4B,GAAAzD,EAAA/0B,EAAAg4B,EAAAxyB,GAEA,GAAA/gB,GAAAub,EAAAvb,EACAE,EAAAqb,EAAArb,EAEA4B,EAAAyZ,EAAAzZ,OACAN,EAAA+Z,EAAA/Z,MAEAozC,EAAArB,EAAAzxC,OAEA+yC,EAAA/yC,EAAA,EAAA8yC,EAAA,EAEAnE,EAAA,MAEA,QAAAH,GACA,IAAA,OACAtwC,GAAA+gB,EACA7gB,GAAA20C,EACApE,EAAA,OACA,MACA,KAAA,QACAzwC,GAAA+gB,EAAAvf,EACAtB,GAAA20C,EACApE,EAAA,MACA,MACA,KAAA,MACAzwC,GAAAwB,EAAA,EACAtB,GAAA6gB,EAAA6zB,EACAnE,EAAA,QACA,MACA,KAAA,SACAzwC,GAAAwB,EAAA,EACAtB,GAAA4B,EAAAif,EACA0vB,EAAA,QACA,MACA,KAAA,SACAzwC,GAAAwB,EAAA,EACAtB,GAAA20C,EACApE,EAAA,QACA,MACA,KAAA,aACAzwC,GAAA+gB,EACA7gB,GAAA20C,EACApE,EAAA,MACA,MACA,KAAA,cACAzwC,GAAAwB,EAAAuf,EACA7gB,GAAA20C,EACApE,EAAA,OACA,MACA,KAAA,YACAzwC,GAAAwB,EAAA,EACAtB,GAAA6gB,EACA0vB,EAAA,QACA,MACA,KAAA,eACAzwC,GAAAwB,EAAA,EACAtB,GAAA4B,EAAA8yC,EAAA7zB,EACA0vB,EAAA,QACA,MACA,KAAA,gBACAzwC,GAAA+gB,EACA7gB,GAAA6gB,EACA0vB,EAAA,MACA,MACA,KAAA,iBACAzwC,GAAAwB,EAAAuf,EACA7gB,GAAA6gB,EACA0vB,EAAA,OACA,MACA,KAAA,mBACAzwC,GAAA+gB,EACA7gB,GAAA4B,EAAA8yC,EAAA7zB,CACA,MACA,KAAA,oBACA/gB,GAAAwB,EAAAuf,EACA7gB,GAAA4B,EAAA8yC,EAAA7zB,EACA0vB,EAAA,QAIA,OACAzwC,EAAAA,EACAE,EAAAA,EACAuwC,UAAAA,EACAD,aAAA,OAmBA,QAAAsE,GAAA3E,EAAA4E,EAAArB,EAAAsB,EAAAzsB,GACA,IAAAwsB,EACA,MAAA,EAGAxsB,GAAAA,MAEAysB,EAAApjC,EAAAojC,EAAA,MAcA,KAAA,GAbAC,GAAArjC,EAAA2W,EAAA0sB,cAAA,GACAC,EAAAtjC,EAAA2W,EAAA2sB,QAAA,GAGAC,EAAAd,EAAA,IAAAX,GAGA0B,EAAAf,EAAA,IAAAX,GACA2B,EAAAzjC,EAAA2W,EAAA8sB,YAAA,IAIAC,EAAAP,EAAA52B,KAAApZ,IAAA,EAAAgwC,EAAA,GACAl0C,EAAA,EAAuBA,EAAAq0C,GAAAI,GAAAF,EAA6Cv0C,IACpEy0C,GAAAF,CAGA,IAAAG,GAAAlB,EAAAW,EACAO,GAAAD,IACAN,EAAA,GACAO,EAAA,GAGAD,EAAAP,EAAAQ,CAIA,KAAA,GAFArB,IAAA/D,EAAA,IAAAruB,MAAA,MAEAjhB,EAAA,EAAAwN,EAAA6lC,EAAAvzC,OAA+CE,EAAAwN,EAASxN,IAAA,CACxD,GAAA20C,GAAAtB,EAAArzC,GACAusC,EAAAiH,EAAAmB,EAAA9B,EAEA,MAAAtG,GAAA2H,GAAA,CAIA,IAAA,GAAA1yC,GAAA,GAA4BA,IAAA,CAC5B,GAAA+qC,GAAAkI,GAAAjzC,GAAA4yC,EAAA,CACAO,GAAAR,CACA,OAGA,GAAAS,GAAA,IAAApzC,EACAqzC,EAAAF,EAAAF,EAAAF,EAAAD,GACA/H,EAAA,EACAjvB,KAAA0G,MAAA2wB,EAAA70C,OAAA20C,EAAAlI,GACA,CAEAoI,GAAAA,EAAA9nB,OAAA,EAAA+nB,GACArI,EAAAiH,EAAAmB,EAAA9B,GAGA,KAAA8B,IACAA,EAAAH,GAGAnB,EAAArzC,GAAA20C,GAGA,MAAAtB,GAAApvB,KAAA,MAGA,QAAA4wB,GAAAvF,EAAAmF,EAAAF,EAAAD,GAGA,IAAA,GAFA3zC,GAAA,EACAX,EAAA,EACAwN,EAAA8hC,EAAAxvC,OAAmCE,EAAAwN,GAAA7M,EAAA8zC,EAAiCz0C,IAAA,CACpE,GAAA80C,GAAAxF,EAAAyF,WAAA/0C,EACAW,IAAA,GAAAm0C,GAAAA,GAAA,IAAAP,EAAAD,EAEA,MAAAt0C,GA5PA,GAAAyzC,MACAE,EAAA,EACAC,EAAA,IAEA31C,EAAAnB,EAAA,GACAqd,EAAArd,EAAA,IACAiU,EAAA9S,EAAA8S,SAyPA0hC,GAEArvC,SAAAowC,EAEAxyC,gBAAA6yC,EAEAX,yBAAAA,EAEAe,aAAAA,EAEAP,YAAA,SAAApE,EAAAuD,GACA,GAAAv7B,GAAArZ,EAAA4O,YAEA,OADAyK,GAAAs7B,KAAAC,GAAA,kBACAv7B,EAAAo8B,YAAApE,IAIA7yC,GAAAD,QAAAi2C,GvC2oUM,SAASh2C,EAAQD,EAASM,GwCj3UhC,QAAAk4C,GAAAh2C,EAAAvB,GAOAb,KAAAq4C,MAAAj2C,EACApC,KAAAq4C,MAAAC,cACAC,KAAA7mC,OAAA1R,KAAAq4C,MAAAC,WAAAz3C,EAAAy3C,gBAOAt4C,KAAAw4C,aAAA33C,EAAA2B,SAOAxC,KAAAy4C,eACAl2C,EAAA1B,EAAA2B,SAAAD,EACAE,EAAA5B,EAAA2B,SAAAC,GAQAzC,KAAA04C,qBAAA73C,EAAA83C,sBAAA,EAOA34C,KAAA44C,kBAAA/3C,EAAAg4C,mBAAA,EAGA74C,KAAA44C,kBACAp3C,EAAAoC,cAAA,EAAApC,EAAAoC,cACS5D,KAAA04C,uBACTl3C,EAAAoC,cAAA,IAAApC,EAAAoC,eAQA5D,KAAA84C,aAAAj4C,EAAAk4C,cAAA,EACA/4C,KAAAg5C,aAAAn4C,EAAAo4C,YACAj5C,KAAAk5C,kBAAAr4C,EAAAs4C,mBAAA,EACAn5C,KAAAo5C,kBAAAv4C,EAAAw4C,iBACAr5C,KAAAs5C,oBAAAz4C,EAAA04C,qBAAA,EACAv5C,KAAAw5C,oBAAA34C,EAAA44C,mBAOAz5C,KAAA05C,WAAA74C,EAAA84C,YAAA,EAQA35C,KAAA45C,eAAA,EAOA55C,KAAA65C,OAAA,GAAAp4C,GAAAK,MACA9B,KAAA65C,OAAAt0C,KAAAvF,KAAAq4C,MAAAh4C,GACAL,KAAA65C,OAAAr0C,WAAA,SAAAJ,GAEA,GAAA00C,GAAA95C,KAAAsF,QAAAtF,KAAAqF,aAAA,EAEAD,GACAmzC,KAAA7mC,OAAAooC,EAAA10C,MAAAA,GAGA00C,EAAA10C,MAAAitC,KAAA,WAKAryC,KAAA+5C,UA/HA,GAAAv4C,GAAAtB,EAAA,IACA85C,EAAA95C,EAAA,IACA+5C,EAAA/5C,EAAA,IACAg6C,EAAAh6C,EAAA,IACAi6C,EAAAj6C,EAAA,IACAuB,EAAAvB,EAAA,IA8HAk6C,EAAAhC,EAAAx2C,SAMAw4C,GAAAt3C,SAAA,WACA,MAAA9C,MAAA65C,QAOAO,EAAA51C,QAAA,WACA,MAAAxE,MAAAq4C,OAGA+B,EAAA91C,UAAA,WACA,MAAAtE,MAAAq4C,MAAA/1C,QAQA83C,EAAA50C,WAAA,WAEAxF,KAAAsF,QAAAtF,KAAAqF,WAAA,GAAAD,MAAAitC,KAAA,WAOA+H,EAAAL,QAAA,WAEA/5C,KAAAq6C,gBAGAr6C,KAAAs6C,uBAGAt6C,KAAAu6C,gBAGAv6C,KAAAw6C,iBAGAh5C,EAAAoC,cAAA,KAQAw2C,EAAAC,cAAA,WACA,GAAAI,GAAAT,EAAAh6C,KAAAq4C,MAAA9yC,KAAAvF,KAAAy4C,cAEAz4C,MAAA84C,eACA2B,EAAAC,UAAA16C,KAAA84C,aACA2B,EAAApC,MAAAr4C,KAAAq4C,MACAoC,EAAAzB,aAAAh5C,KAAAg5C,aACAyB,EAAAE,QAAA36C,KAAA46C,QAGA56C,KAAA65C,OAAA73C,IAAAy4C,GACAz6C,KAAA66C,sBAAAJ,IAOAL,EAAAE,qBAAA,WAGA,GAAAt6C,KAAAq4C,MAAAyC,WAaA,IAAA,GAPAC,GAFAC,EAAAh7C,KAAAq4C,MAAAyC,WACAG,EAAAD,EAAA93C,OAEAg4C,GACA14C,SAAAxC,KAAAy4C,cACAiC,UAAA16C,KAAAk5C,kBACAiC,UAAAn7C,KAAAo5C,mBAGAh2C,EAAA,EAAuBA,EAAA63C,EAAiB73C,IACxC23C,EAAA,GAAAd,GAAAe,EAAA53C,GAAA83C,GACAl7C,KAAA65C,OAAA73C,IAAA+4C,EAAAj4C,YACA9C,KAAA66C,sBAAAE,EAAAj4C,aASAs3C,EAAAG,cAAA,WAEA,GAAAv6C,KAAAq4C,MAAA+C,UAAA,CASA,IAAA,GAHAC,GAAAC,EAFAC,EAAAv7C,KAAAq4C,MAAA+C,UACAI,EAAAD,EAAAr4C,OAEAu4C,GAAkCl5C,EAAAvC,KAAAy4C,cAAAl2C,EAAAf,EAAAoC,cAAA,EAAAnB,EAAAzC,KAAAy4C,cAAAh2C,GAElCW,EAAA,EAAuBA,EAAAo4C,EAAgBp4C,IAEvCk4C,EADA,GAAAl4C,EACA82C,EAAAwB,OAAA17C,KAAAy4C,eAGAyB,EAAAyB,SAAA37C,KAAAy4C,eAGAz4C,KAAA65C,OAAA73C,IAAAs5C,GAEAt7C,KAAA66C,sBAAAS,GAEAD,EAAA,GAAAlB,GAAAoB,EAAAn4C,IAEAZ,SAAAxC,KAAAy4C,cACAmD,gBAAA57C,KAAA04C,qBACAmD,qBAAA77C,KAAA44C,kBACAkD,eAAA97C,KAAAs5C,oBACAyC,eAAA/7C,KAAAw5C,sBAGAx5C,KAAA65C,OAAA73C,IAAAq5C,EAAAv4C,YACA9C,KAAA66C,sBAAAQ,EAAAv4C,WAGA9C,MAAA44C,oBACA0C,EAAApB,EAAA8B,cAAAP,EACAz7C,KAAAy4C,cAAAh2C,EAAAg5C,EAAAh5C,GAEAzC,KAAA65C,OAAA73C,IAAAs5C,MAUAlB,EAAAS,sBAAA,SAAAoB,GAEAj8C,KAAAy4C,cAAAh2C,GAAAw5C,EAAA73C,kBAAAC,OAGArE,KAAA45C,gBAAAqC,EAAA73C,kBAAAC,QAQA+1C,EAAAI,eAAA,WACA,GAAAn2C,GAAArE,KAAA45C,eAAAp4C,EAAA06C,uBACAl8C,KAAA45C,eAAAp4C,EAAA06C,uBACAzzC,EAAA,GAAAhH,GAAA06C,MACAj2C,UAAAlG,KAAAw4C,aAAAj2C,EAAAvC,KAAAw4C,aAAA/1C,GAEAgG,OACAwmB,EAAA,EACAlrB,MAAAvC,EAAAoC,cACAS,OAAAA,GAGAe,OACAg3C,UAAA,OACA/J,KAAAryC,KAAA05C,WAAA,UAAA,QACApH,OAAA,UACA3C,UAAA,EACA0M,SAAA,SAGAjhC,WAGApb,MAAA84C,eACArwC,EAAA4vC,MAAAr4C,KAAAq4C,MACA5vC,EAAAuwC,aAAAh5C,KAAAg5C,aAEAvwC,EAAAiyC,UAAA16C,KAAA84C,aACArwC,EAAAkyC,QAAA36C,KAAA46C,QAGA56C,KAAA65C,OAAA73C,IAAAyG,IAOA2xC,EAAAQ,OAAA,WACA,GAAA9vB,GAAAytB,KAAA7mC,QAEA4mC,YACAgE,KAAAt8C,KAAAq4C,OAEAt0C,MAAA,IACAM,OAAA,KACarE,KAAAg5C,aAEbT,MAAAgE,UAAAzxB,IAGAjrB,EAAAD,QAAAw4C,GxCq6UM,SAASv4C,EAAQD,GyC3wVvBC,EAAAD,SACAgE,cAAA,IACAs4C,uBAAA,GACAp4C,iBAAA,GACAS,iBAAA,GAEAi4C,aAAA,kBACAC,oBAAA,GACAC,uBAAA,GAEAC,gBAAA,GACAC,eAAA,IACAC,cAAA,oBAEAC,aAAA,oBACAC,oBAAA,EACAC,uBAAA,EACAC,qBAAA,EACAC,gCAAA,EACAC,oBAAA,IAEAC,UAAA,GACAC,gBAAA,GACAC,qBAAA,GACAC,sBAAA,EACAC,uBAAA,GACAC,uBAAA,IzCwxVM,SAAS59C,EAAQD,EAASM,G0CtyVhC,QAAA85C,GAAAtH,EAAAlwC,GACA,GAAAD,GAAAC,EAAAD,EACAE,EAAAD,EAAAC,EAAAjB,EAAAi7C,oBAEAh0C,EAAA,GAAAhH,GAAAi8C,MACAt4C,OACAstC,KAAAA,EACAuD,SAAAz0C,EAAAg7C,aACAxJ,UAAA,OACAD,aAAA,OAGA7sC,UAAA3D,EAAAE,IASA,OALAgG,GAAAvC,SAAA,KAAA1E,EAAAoC,cAAA6E,EAAArE,kBAAAL,OAAA,EAGA0E,EAAArE,kBAAAC,QAAA7C,EAAAi7C,oBAAAj7C,EAAAk7C,uBAEAj0C,EA/BA,GAAAjH,GAAAtB,EAAA,IACAuB,EAAAvB,EAAA,GAiCAL,GAAAD,QAAAo6C,G1C8zVM,SAASn6C,EAAQD,EAASM,G2Ct2VhC,YA2MA,SAAAy9C,GAAApwC,GACA,IAAAA,EAAAqwC,UAAA,CAGA,GAAArwC,EAAAswC,gBAAA,CACA,GAAAvL,GAAA/kC,EAAAnI,MAAAktC,OACAD,EAAA9kC,EAAAnI,MAAAitC,KAGAhI,EAAA98B,EAAAuwC,WACAzsB,EAAA0sB,EAAA1sB,IACAgZ,GAAAgI,KAAAhI,EAAAgI,MACAA,IAAAA,YAAA2L,GAAA3L,EAAAhhB,EAAAghB,QACAhI,EAAAiI,OAAAjI,EAAAiI,QACAA,IAAAA,YAAA0L,GAAA1L,EAAAjhB,EAAAihB,OAEA,IAAA2L,KACA,KAAA,GAAA14C,KAAA8kC,GACAA,EAAAt+B,eAAAxG,KACA04C,EAAA14C,GAAAgI,EAAAnI,MAAAG,GAIAgI,GAAA2wC,YAAAD,EAEA1wC,EAAAswC,iBAAA,EAEAtwC,EAAAk9B,SAAAl9B,EAAAuwC,YACAvwC,EAAA+N,IAAA,EAEA/N,EAAAqwC,WAAA,GAMA,QAAAO,GAAA5wC,GACA,GAAAA,EAAAqwC,UAAA,CAIA,GAAAQ,GAAA7wC,EAAA2wC,WACAE,IAAA7wC,EAAAk9B,SAAA2T,GACA7wC,EAAA+N,IAAA,EAEA/N,EAAAqwC,WAAA,GAMA,QAAAS,GAAA9wC,GACA,UAAAA,EAAA7H,KACA6H,EAAAqO,SAAA,SAAA5Y,GACA,UAAAA,EAAA0C,MACAi4C,EAAA36C,KAGA26C,EAAApwC,GAGA,QAAA+wC,GAAA/wC,GACA,UAAAA,EAAA7H,KACA6H,EAAAqO,SAAA,SAAA5Y,GACA,UAAAA,EAAA0C,MACAy4C,EAAAn7C,KAGAm7C,EAAA5wC,GAMA,QAAAgxC,GAAAhxC,EAAAixC,GAGAjxC,EAAAuwC,WAAAvwC,EAAA88B,YAAAmU,MACAjxC,EAAAswC,iBAAA,EAMA,QAAAY,MAEAz+C,KAAA0+C,cAAAL,EAAAr+C,MAMA,QAAA2+C,MAEA3+C,KAAA0+C,cAAAJ,EAAAt+C,MAMA,QAAA4+C,KACA5+C,KAAA0+C,cAAA,EACAL,EAAAr+C,MAMA,QAAA6+C,KACA7+C,KAAA0+C,cAAA,EACAJ,EAAAt+C,MAqDA,QAAA8+C,GAAAC,EAAAxxC,EAAA6X,EAAA45B,EAAApsC,GACA,GAAAqsC,GAAAF,EAAA,SAAA,GACAG,EAAAF,GACAA,EAAAG,WAAA,oBAAAF,GACAG,EAAAJ,GACAA,EAAAG,WAAA,kBAAAF,EAEAD,IAAAA,EAAAG,WAAA,aACA5xC,EAAAoX,UAAAS,EAAA85B,EAAAE,EAAAxsC,IACArF,EAAAhH,KAAA6e,GAAAxS,GAAAA,KApXA,GAAA5H,GAAA9K,EAAA,GAEAm/C,EAAAn/C,EAAA,IACAmuB,EAAA3N,KAAA2N,MACAixB,EAAAp/C,EAAA,IACA69C,EAAA79C,EAAA,IACAqf,EAAArf,EAAA,IACAsf,EAAAtf,EAAA,IACA89C,EAAA99C,EAAA,IACAiX,EAAAjX,EAAA,GAEAuB,IACAA,GAAA89C,KAAAv0C,EACAvJ,EAAAK,MAAA5B,EAAA,IAEAuB,EAAAozC,MAAA30C,EAAA,IAEAuB,EAAAi8C,KAAAx9C,EAAA,IAEAuB,EAAAo0C,YAAA31C,EAAA,IAEAuB,EAAA+9C,OAAAt/C,EAAA,IAEAuB,EAAAg+C,OAAAv/C,EAAA,IAEAuB,EAAAi+C,KAAAx/C,EAAA,IAEAuB,EAAAk+C,QAAAz/C,EAAA,IAEAuB,EAAAm+C,SAAA1/C,EAAA,IAEAuB,EAAA06C,KAAAj8C,EAAA,IAEAuB,EAAAy4C,KAAAh6C,EAAA,IAEAuB,EAAAo+C,YAAA3/C,EAAA,IAEAuB,EAAAq+C,IAAA5/C,EAAA,IAEAuB,EAAAs+C,eAAA7/C,EAAA,IAEAuB,EAAAu+C,eAAA9/C,EAAA,IAEAuB,EAAA8b,aAAArd,EAAA,IAKAuB,EAAAw+C,YAAA,SAAAp/C,GACA,MAAAy+C,GAAA5tC,OAAA7Q,IAMAY,EAAAy+C,WAAA,SAAAC,EAAAt/C,GACA,MAAAw+C,GAAAe,iBAAAD,EAAAt/C,IAUAY,EAAA4+C,SAAA,SAAAF,EAAAt/C,EAAAid,EAAAxb,GACA,GAAA2hB,GAAAo7B,EAAAiB,iBAAAH,EAAAt/C,EACAsW,GAAA5W,KAAA0jB,EACA,IAAAs8B,GAAAt8B,EAAA7f,iBACA,IAAA0Z,EAAA,CACA,GAAAk3B,GAAAuL,EAAAx8C,MAAAw8C,EAAAl8C,MAEA,IAAA,WAAA/B,EAAA,CAEA,GACA+B,GADAN,EAAA+Z,EAAAzZ,OAAA2wC,CAEAjxC,IAAA+Z,EAAA/Z,MACAM,EAAAyZ,EAAAzZ,QAGAN,EAAA+Z,EAAA/Z,MACAM,EAAAN,EAAAixC,EAEA,IAAAwL,GAAA1iC,EAAAvb,EAAAub,EAAA/Z,MAAA,EACA08C,EAAA3iC,EAAArb,EAAAqb,EAAAzZ,OAAA,CAEAyZ,GAAAvb,EAAAi+C,EAAAz8C,EAAA,EACA+Z,EAAArb,EAAAg+C,EAAAp8C,EAAA,EACAyZ,EAAA/Z,MAAAA,EACA+Z,EAAAzZ,OAAAA,EAGArE,KAAA0gD,WAAAz8B,EAAAnG,GAIA,MADA9S,GAAAgH,SAAAiS,EAAA9M,GACA8M,GAGAxiB,EAAAk/C,UAAAtB,EAAAsB,UAOAl/C,EAAAi/C,WAAA,SAAAz8B,EAAAnG,GACA,GAAAmG,EAAA3F,eAAA,CAIA,GAAAsiC,GAAA38B,EAAA7f,kBAEA5D,EAAAogD,EAAAjjB,mBAAA7f,EAEAmG,GAAA3F,eAAA9d,KAgBAiB,EAAAo/C,qBAAA,SAAAC,GACA,GAAAC,GAAAt/C,EAAAs/C,iBACAt4C,EAAAq4C,EAAAr4C,MACAknC,EAAAmR,EAAA17C,MAAAuqC,SAQA,OANAthB,GAAA,EAAA5lB,EAAAu4C,MAAA3yB,EAAA,EAAA5lB,EAAAqpC,MACArpC,EAAAu4C,GAAAv4C,EAAAqpC,GAAAiP,EAAAt4C,EAAAu4C,GAAArR,GAAA,IAEAthB,EAAA,EAAA5lB,EAAAw4C,MAAA5yB,EAAA,EAAA5lB,EAAAspC,MACAtpC,EAAAw4C,GAAAx4C,EAAAspC,GAAAgP,EAAAt4C,EAAAw4C,GAAAtR,GAAA,IAEAmR,GAgBAr/C,EAAAy/C,qBAAA,SAAAJ,GACA,GAAAC,GAAAt/C,EAAAs/C,iBACAt4C,EAAAq4C,EAAAr4C,MACAknC,EAAAmR,EAAA17C,MAAAuqC,UACAwR,EAAA14C,EAAAlG,EACA6+C,EAAA34C,EAAAhG,EACA4+C,EAAA54C,EAAA1E,MACAu9C,EAAA74C,EAAApE,MAWA,OAVAoE,GAAAlG,EAAAw+C,EAAAt4C,EAAAlG,EAAAotC,GAAA,GACAlnC,EAAAhG,EAAAs+C,EAAAt4C,EAAAhG,EAAAktC,GAAA,GACAlnC,EAAA1E,MAAA2c,KAAApZ,IACAy5C,EAAAI,EAAAE,EAAA1R,GAAA,GAAAlnC,EAAAlG,EACA,IAAA8+C,EAAA,EAAA,GAEA54C,EAAApE,OAAAqc,KAAApZ,IACAy5C,EAAAK,EAAAE,EAAA3R,GAAA,GAAAlnC,EAAAhG,EACA,IAAA6+C,EAAA,EAAA,GAEAR,GAWAr/C,EAAAs/C,iBAAA,SAAA76C,EAAAypC,EAAA4R,GAGA,GAAAC,GAAAnzB,EAAA,EAAAnoB,EACA,QAAAs7C,EAAAnzB,EAAAshB,IAAA,IAAA,EACA6R,EAAA,GACAA,GAAAD,EAAA,OAAA,GAkEA9/C,EAAA48C,aAAAA,EAUA58C,EAAA68C,aAAAA,EAUA78C,EAAA88C,mBAAAA,EAsCA98C,EAAAggD,cAAA,SAAAl0C,EAAA88B,GACA,UAAA98B,EAAA7H,KACA6H,EAAAqO,SAAA,SAAA5Y,GACA,UAAAA,EAAA0C,MACA64C,EAAAv7C,EAAAqnC,KAGAkU,EAAAhxC,EAAA88B,GAEA98B,EAAA7G,GAAA,YAAA+3C,GACA/3C,GAAA,WAAAi4C,GAGApxC,EAAA7G,GAAA,WAAAk4C,GACAl4C,GAAA,SAAAm4C,IAGAp9C,EAAAigD,eAAA,SAAAn0C,EAAAud,GACA,GAAAvd,EAAA2wC,YACA,IAAA,GAAA34C,KAAAulB,GACAvd,EAAA2wC,YAAAnyC,eAAAxG,KACAgI,EAAA2wC,YAAA34C,GAAAulB,EAAAvlB,KAYA9D,EAAAkgD,QAAA,SAAAC,EAAAC,EAAAl5B,GACA,GAAAm5B,GAAAD,EAAA1C,WAAA,aAAA,SACA4C,EAAAD,EAAAr4C,QAAA,WAAA,EAAA,QAAAkf,EACAq5B,EAAAH,EAAAI,SAAA,YACAj3C,GAAA0G,OAAAkwC,GACA1O,aAAA2O,EAAA1C,WAAA,aAAA,EACAlJ,SAAA+L,EAAAE,UACArP,aAAAiP,EACAnP,SAAAqP,EAAAG,gBAAAJ,KAsBAtgD,EAAA2gD,YAAAp3C,EAAA6I,MAAAirC,GAAA,GASAr9C,EAAA4gD,UAAAr3C,EAAA6I,MAAAirC,GAAA,GASAr9C,EAAA6gD,aAAA,SAAAt8C,EAAAu8C,GAGA,IAFA,GAAAC,GAAAjjC,EAAAG,aAEA1Z,GAAAA,IAAAu8C,GACAhjC,EAAAU,IAAAuiC,EAAAx8C,EAAAoY,oBAAAokC,GACAx8C,EAAAA,EAAA3C,MAGA,OAAAm/C,IAUA/gD,EAAA6c,eAAA,SAAAmkC,EAAAtkC,EAAAgC,GAIA,MAHAA,KACAhC,EAAAoB,EAAAY,UAAAhC,IAEAqB,EAAAlB,kBAAAmkC,EAAAtkC,IASA1c,EAAAihD,mBAAA,SAAAC,EAAAxkC,EAAAgC,GAGA,GAAAyiC,GAAA,IAAAzkC,EAAA,IAAA,IAAAA,EAAA,IAAA,IAAAA,EAAA,GACA,EAAAuC,KAAAmiC,IAAA,EAAA1kC,EAAA,GAAAA,EAAA,IACA2kC,EAAA,IAAA3kC,EAAA,IAAA,IAAAA,EAAA,IAAA,IAAAA,EAAA,GACA,EAAAuC,KAAAmiC,IAAA,EAAA1kC,EAAA,GAAAA,EAAA,IAEAskC,GACA,SAAAE,GAAAC,EAAA,UAAAD,EAAAC,EAAA,EACA,QAAAD,GAAAG,EAAA,WAAAH,EAAAG,EAAA,EAKA,OAFAL,GAAAhhD,EAAA6c,eAAAmkC,EAAAtkC,EAAAgC,GAEAO,KAAAmiC,IAAAJ,EAAA,IAAA/hC,KAAAmiC,IAAAJ,EAAA,IACAA,EAAA,GAAA,EAAA,QAAA,OACAA,EAAA,GAAA,EAAA,SAAA,OAGA5iD,EAAAD,QAAA6B,G3C82VM,SAAS5B,EAAQD,EAASM,G4CtxWhC,QAAA6iD,GAAA/B,EAAAC,EAAAnP,EAAAC,EAAAiR,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAp/B,GACA,GAAAq/B,GAAAF,GAAAp2B,EAAA,KACAu2B,EAAAC,EAAAF,IAAAtC,EAAAlP,GAAA,EACA2R,EAAAH,IAAArC,EAAAlP,GAAA,EACA2R,KAAAD,EAAAH,IAAAtC,EAAAlP,GAAA,EACA0R,EAAAF,IAAArC,EAAAlP,GAAA,EAEA4R,EAAAJ,EAAAA,GAAAL,EAAAA,GAAAQ,EAAAA,GAAAP,EAAAA,EAEAQ,GAAA,IACAT,GAAAU,EAAAD,GACAR,GAAAS,EAAAD,GAGA,IAAAn1B,IAAAw0B,IAAAC,KAAA,GACAW,GAAAV,EAAAA,GAAAC,EAAAA,GACAD,EAAAA,GAAAQ,EAAAA,GACAP,EAAAA,GAAAI,EAAAA,KAAAL,EAAAA,GAAAQ,EAAAA,GACAP,EAAAA,GAAAI,EAAAA,MACA,EAEAM,EAAAr1B,EAAA00B,EAAAQ,EAAAP,EACAW,EAAAt1B,GAAA20B,EAAAI,EAAAL,EAEA1C,GAAAQ,EAAAlP,GAAA,EACA0R,EAAAF,GAAAO,EACAJ,EAAAH,GAAAQ,EACArD,GAAAQ,EAAAlP,GAAA,EACA0R,EAAAH,GAAAO,EACAL,EAAAF,GAAAQ,EAEAC,EAAAC,GAAA,EAAA,KAAAT,EAAAM,GAAAX,GAAAQ,EAAAI,GAAAX,IACAc,IAAAV,EAAAM,GAAAX,GAAAQ,EAAAI,GAAAX,GACAthC,OAAA0hC,EAAAM,GAAAX,MAAAQ,EAAAI,GAAAX,GACAe,EAAAF,EAAAC,EAAApiC,EAEAsiC,GAAAF,EAAApiC,SACAqiC,EAAAl3B,GAEAm3B,EAAAF,EAAApiC,IAAA,IACAqiC,EAAA,GAEA,IAAAjB,GAAAiB,EAAA,IACAA,GAAA,EAAAl3B,GAEA,IAAAi2B,GAAAiB,EAAA,IACAA,GAAA,EAAAl3B,GAGA/I,EAAAmgC,QAAAf,EAAA7C,EAAAC,EAAAyC,EAAAC,EAAAY,EAAAG,EAAAZ,EAAAL,GAGA,QAAAoB,GAAA5xC,GACA,IAAAA,EACA,QAIA,IAKA8rB,GALA+lB,EAAA7xC,EAAAkd,QAAA,KAAA,MACAA,QAAA,MAAA,KACAA,QAAA,KAAA,KACAA,QAAA,MAAA,IAIA,KAAA4O,EAAA,EAAmBA,EAAAgmB,EAAArhD,OAAeq7B,IAClC+lB,EAAAA,EAAA30B,QAAA,GAAA60B,QAAAD,EAAAhmB,GAAA,KAAA,IAAAgmB,EAAAhmB,GAIA,IAQAkmB,GARAC,EAAAJ,EAAAjgC,MAAA,KAEAsgC,EAAA,EACAC,EAAA,EAEA3gC,EAAA,GAAA4gC,GACAC,EAAAD,EAAAC,GAGA,KAAAvmB,EAAA,EAAmBA,EAAAmmB,EAAAxhD,OAAgBq7B,IAAA,CACnC,GAIA8kB,GAJA30B,EAAAg2B,EAAAnmB,GACA99B,EAAAiuB,EAAAC,OAAA,GACA1mB,EAAA,EACAvH,EAAAguB,EAAAra,MAAA,GAAAsb,QAAA,OAAA,MAAAtL,MAAA,IAGA3jB,GAAAwC,OAAA,GAAA,KAAAxC,EAAA,IACAA,EAAAiD,OAGA,KAAA,GAAAP,GAAA,EAA2BA,EAAA1C,EAAAwC,OAAcE,IACzC1C,EAAA0C,GAAAwrB,WAAAluB,EAAA0C,GAEA,MAAA6E,EAAAvH,EAAAwC,SAAAqjB,MAAA7lB,EAAAuH,MACAse,MAAA7lB,EAAA,KADA,CAIA,GAAAqkD,GACAC,EAEA9B,EACAC,EACAG,EACAN,EACAC,EAEAjC,EAAA2D,EACA1D,EAAA2D,CAGA,QAAAnkD,GACA,IAAA,IACAkkD,GAAAjkD,EAAAuH,KACA28C,GAAAlkD,EAAAuH,KACAo7C,EAAAyB,EAAA7zB,EACAhN,EAAAmgC,QAAAf,EAAAsB,EAAAC,EACA,MACA,KAAA,IACAD,EAAAjkD,EAAAuH,KACA28C,EAAAlkD,EAAAuH,KACAo7C,EAAAyB,EAAA7zB,EACAhN,EAAAmgC,QAAAf,EAAAsB,EAAAC,EACA,MACA,KAAA,IACAD,GAAAjkD,EAAAuH,KACA28C,GAAAlkD,EAAAuH,KACAo7C,EAAAyB,EAAAG,EACAhhC,EAAAmgC,QAAAf,EAAAsB,EAAAC,GACAnkD,EAAA,GACA,MACA,KAAA,IACAkkD,EAAAjkD,EAAAuH,KACA28C,EAAAlkD,EAAAuH,KACAo7C,EAAAyB,EAAAG,EACAhhC,EAAAmgC,QAAAf,EAAAsB,EAAAC,GACAnkD,EAAA,GACA,MACA,KAAA,IACAkkD,GAAAjkD,EAAAuH,KACAo7C,EAAAyB,EAAA7zB,EACAhN,EAAAmgC,QAAAf,EAAAsB,EAAAC,EACA,MACA,KAAA,IACAD,EAAAjkD,EAAAuH,KACAo7C,EAAAyB,EAAA7zB,EACAhN,EAAAmgC,QAAAf,EAAAsB,EAAAC,EACA,MACA,KAAA,IACAA,GAAAlkD,EAAAuH,KACAo7C,EAAAyB,EAAA7zB,EACAhN,EAAAmgC,QAAAf,EAAAsB,EAAAC,EACA,MACA,KAAA,IACAA,EAAAlkD,EAAAuH,KACAo7C,EAAAyB,EAAA7zB,EACAhN,EAAAmgC,QAAAf,EAAAsB,EAAAC,EACA,MACA,KAAA,IACAvB,EAAAyB,EAAAI,EACAjhC,EAAAmgC,QACAf,EAAA3iD,EAAAuH,KAAAvH,EAAAuH,KAAAvH,EAAAuH,KAAAvH,EAAAuH,KAAAvH,EAAAuH,KAAAvH,EAAAuH,MAEA08C,EAAAjkD,EAAAuH,EAAA,GACA28C,EAAAlkD,EAAAuH,EAAA,EACA,MACA,KAAA,IACAo7C,EAAAyB,EAAAI,EACAjhC,EAAAmgC,QACAf,EACA3iD,EAAAuH,KAAA08C,EAAAjkD,EAAAuH,KAAA28C,EACAlkD,EAAAuH,KAAA08C,EAAAjkD,EAAAuH,KAAA28C,EACAlkD,EAAAuH,KAAA08C,EAAAjkD,EAAAuH,KAAA28C,GAEAD,GAAAjkD,EAAAuH,EAAA,GACA28C,GAAAlkD,EAAAuH,EAAA,EACA,MACA,KAAA,IACA88C,EAAAJ,EACAK,EAAAJ,CACA,IAAAh0C,GAAAqT,EAAArT,MACAuvC,EAAAl8B,EAAAxR,IACAgyC,KAAAK,EAAAI,IACAH,GAAAJ,EAAAxE,EAAAvvC,EAAA,GACAo0C,GAAAJ,EAAAzE,EAAAvvC,EAAA,IAEAyyC,EAAAyB,EAAAI,EACAlE,EAAAtgD,EAAAuH,KACAg5C,EAAAvgD,EAAAuH,KACA08C,EAAAjkD,EAAAuH,KACA28C,EAAAlkD,EAAAuH,KACAgc,EAAAmgC,QAAAf,EAAA0B,EAAAC,EAAAhE,EAAAC,EAAA0D,EAAAC,EACA,MACA,KAAA,IACAG,EAAAJ,EACAK,EAAAJ,CACA,IAAAh0C,GAAAqT,EAAArT,MACAuvC,EAAAl8B,EAAAxR,IACAgyC,KAAAK,EAAAI,IACAH,GAAAJ,EAAAxE,EAAAvvC,EAAA,GACAo0C,GAAAJ,EAAAzE,EAAAvvC,EAAA,IAEAyyC,EAAAyB,EAAAI,EACAlE,EAAA2D,EAAAjkD,EAAAuH,KACAg5C,EAAA2D,EAAAlkD,EAAAuH,KACA08C,GAAAjkD,EAAAuH,KACA28C,GAAAlkD,EAAAuH,KACAgc,EAAAmgC,QAAAf,EAAA0B,EAAAC,EAAAhE,EAAAC,EAAA0D,EAAAC,EACA,MACA,KAAA,IACA5D,EAAAtgD,EAAAuH,KACAg5C,EAAAvgD,EAAAuH,KACA08C,EAAAjkD,EAAAuH,KACA28C,EAAAlkD,EAAAuH,KACAo7C,EAAAyB,EAAAK,EACAlhC,EAAAmgC,QAAAf,EAAArC,EAAAC,EAAA0D,EAAAC,EACA,MACA,KAAA,IACA5D,EAAAtgD,EAAAuH,KAAA08C,EACA1D,EAAAvgD,EAAAuH,KAAA28C,EACAD,GAAAjkD,EAAAuH,KACA28C,GAAAlkD,EAAAuH,KACAo7C,EAAAyB,EAAAK,EACAlhC,EAAAmgC,QAAAf,EAAArC,EAAAC,EAAA0D,EAAAC,EACA,MACA,KAAA,IACAG,EAAAJ,EACAK,EAAAJ,CACA,IAAAh0C,GAAAqT,EAAArT,MACAuvC,EAAAl8B,EAAAxR,IACAgyC,KAAAK,EAAAK,IACAJ,GAAAJ,EAAAxE,EAAAvvC,EAAA,GACAo0C,GAAAJ,EAAAzE,EAAAvvC,EAAA,IAEA+zC,EAAAjkD,EAAAuH,KACA28C,EAAAlkD,EAAAuH,KACAo7C,EAAAyB,EAAAK,EACAlhC,EAAAmgC,QAAAf,EAAA0B,EAAAC,EAAAL,EAAAC,EACA,MACA,KAAA,IACAG,EAAAJ,EACAK,EAAAJ,CACA,IAAAh0C,GAAAqT,EAAArT,MACAuvC,EAAAl8B,EAAAxR,IACAgyC,KAAAK,EAAAK,IACAJ,GAAAJ,EAAAxE,EAAAvvC,EAAA,GACAo0C,GAAAJ,EAAAzE,EAAAvvC,EAAA,IAEA+zC,GAAAjkD,EAAAuH,KACA28C,GAAAlkD,EAAAuH,KACAo7C,EAAAyB,EAAAK,EACAlhC,EAAAmgC,QAAAf,EAAA0B,EAAAC,EAAAL,EAAAC,EACA,MACA,KAAA,IACA1B,EAAAxiD,EAAAuH,KACAk7C,EAAAziD,EAAAuH,KACAq7C,EAAA5iD,EAAAuH,KACA+6C,EAAAtiD,EAAAuH,KACAg7C,EAAAviD,EAAAuH,KAEA+4C,EAAA2D,EAAA1D,EAAA2D,EACAD,EAAAjkD,EAAAuH,KACA28C,EAAAlkD,EAAAuH,KACAo7C,EAAAyB,EAAAM,EACArC,EACA/B,EAAAC,EAAA0D,EAAAC,EAAA5B,EAAAC,EAAAC,EAAAC,EAAAG,EAAAD,EAAAp/B,EAEA,MACA,KAAA,IACAi/B,EAAAxiD,EAAAuH,KACAk7C,EAAAziD,EAAAuH,KACAq7C,EAAA5iD,EAAAuH,KACA+6C,EAAAtiD,EAAAuH,KACAg7C,EAAAviD,EAAAuH,KAEA+4C,EAAA2D,EAAA1D,EAAA2D,EACAD,GAAAjkD,EAAAuH,KACA28C,GAAAlkD,EAAAuH,KACAo7C,EAAAyB,EAAAM,EACArC,EACA/B,EAAAC,EAAA0D,EAAAC,EAAA5B,EAAAC,EAAAC,EAAAC,EAAAG,EAAAD,EAAAp/B,IAMA,MAAAxjB,GAAA,MAAAA,IACA4iD,EAAAyB,EAAAO,EACAphC,EAAAmgC,QAAAf,IAGAoB,EAAApB,EAKA,MAFAp/B,GAAAqhC,WAEArhC,EAIA,QAAAshC,GAAA72B,EAAA7tB,GACA,GACAsd,GADAqnC,EAAAnB,EAAA31B,EAqBA,OAnBA7tB,GAAAA,MACAA,EAAAunC,UAAA,SAAAnkB,GACAA,EAAAwhC,QAAAD,EAAA/yC,MACA0L,GAAAunC,EAAAzhC,EAAA9F,EAEA,IAAAzD,GAAAuJ,EAAAhU,YACAyK,IACAuJ,EAAA0hC,YAAAjrC,IAIA7Z,EAAAyd,eAAA,SAAA9d,GACA2d,IACAA,EAAAoB,EAAAS,UAEAT,EAAAU,IAAA9B,EAAA3d,EAAA2d,GACAne,KAAAkd,OAAA,IAGArc,EA5VA,GAAAy+C,GAAAp/C,EAAA,IACA2kD,EAAA3kD,EAAA,IACAwlD,EAAAxlD,EAAA,IACAqf,EAAArf,EAAA,IAGAqkD,GACA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IACA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KAGAX,EAAAljC,KAAAC,KACA8iC,EAAA/iC,KAAA4B,IACAkhC,EAAA9iC,KAAA8B,IACAwK,EAAAtM,KAAAsM,GAEA44B,EAAA,SAAA/jC,GACA,MAAAnB,MAAAC,KAAAkB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,KAEAsiC,EAAA,SAAAF,EAAApiC,GACA,OAAAoiC,EAAA,GAAApiC,EAAA,GAAAoiC,EAAA,GAAApiC,EAAA,KAAA+jC,EAAA3B,GAAA2B,EAAA/jC,KAEAmiC,EAAA,SAAAC,EAAApiC,GACA,OAAAoiC,EAAA,GAAApiC,EAAA,GAAAoiC,EAAA,GAAApiC,EAAA,MAAA,GACAnB,KAAAmlC,KAAA1B,EAAAF,EAAApiC,IAuUAhiB,GAAAD,SAMA0gD,iBAAA,SAAA5xB,EAAA7tB,GACA,MAAA,IAAAy+C,GAAAiG,EAAA72B,EAAA7tB,KAQAu/C,iBAAA,SAAA1xB,EAAA7tB,GACA,MAAAy+C,GAAA5tC,OAAA6zC,EAAA72B,EAAA7tB,KASA8/C,UAAA,SAAAmF,EAAAjlD,GAGA,IAAA,GAFAklD,MACAn1C,EAAAk1C,EAAA5iD,OACAE,EAAA,EAA2BA,EAAAwN,EAASxN,IAAA,CACpC,GAAA4iD,GAAAF,EAAA1iD,EACA4iD,GAAA5pC,SACA4pC,EAAA5d,UAAA4d,EAAA/hC,KAAA+hC,EAAAv9C,OAAA,GAEAs9C,EAAAtiD,KAAAuiD,EAAA/hC,MAGA,GAAAgiC,GAAA,GAAA3G,GAAAz+C,EAUA,OATAolD,GAAA7d,UAAA,SAAAnkB,GACAA,EAAAiiC,WAAAH,EAEA,IAAArrC,GAAAuJ,EAAAhU,YACAyK,IACAuJ,EAAA0hC,YAAAjrC,IAIAurC,K5C4zWM,SAASpmD,EAAQD,EAASM,G6CprXhC,QAAAo/C,GAAAz+C,GACA2zC,EAAAj0C,KAAAP,KAAAa,GAMAb,KAAAikB,KAAA,GAAA4gC,GAvBA,GAAArQ,GAAAt0C,EAAA,IACA8K,EAAA9K,EAAA,GACA2kD,EAAA3kD,EAAA,IACAimD,EAAAjmD,EAAA,IAEAywC,EAAAzwC,EAAA,IACAwxC,EAAAf,EAAA/uC,UAAA8vC,iBAEAmR,EAAAniC,KAAAmiC,GAkBAvD,GAAA19C,WAEA+L,YAAA2xC,EAEA55C,KAAA,OAEA0gD,aAAA,EAEAC,uBAAA,EAEApZ,MAAA,SAAAvyB,EAAAqyB,GACA,GAAA3nC,GAAApF,KAAAoF,MACA6e,EAAAjkB,KAAAikB,KACA2rB,EAAAxqC,EAAAwqC,YACAkE,EAAA1uC,EAAA0uC,UACAzB,EAAAjtC,EAAAitC,KACAC,EAAAltC,EAAAktC,OACAgU,EAAAxS,KAAAzB,EAAA,WACAkU,EAAA3W,KAAA0C,EAAA,WACAkU,EAAA1S,KAAAzB,EAAA,MACAoU,EAAA7W,KAAA0C,EAAA,KAKA,IAHAltC,EAAA0H,KAAA4N,EAAA1a,KAAA+sC,GACA/sC,KAAAqgB,aAAA3F,GAEA1a,KAAAoc,QAAA,CACA,GAAA0B,GAAA9d,KAAAoE,iBAEAkiD,KACAtmD,KAAA0mD,cAAAthD,EAAAqsC,YAAA/2B,EAAA23B,EAAAv0B,IAEAyoC,IACAvmD,KAAA2mD,gBAAAvhD,EAAAqsC,YAAA/2B,EAAA43B,EAAAx0B,IAIAwoC,EAEA5rC,EAAAi3B,UAAA3xC,KAAA0mD,cAEAF,IACA9rC,EAAAi3B,UAAAD,EAAAnxC,KAAA8xC,EAAA33B,IAEA6rC,EACA7rC,EAAAk5B,YAAA5zC,KAAA2mD,gBAEAF,IACA/rC,EAAAk5B,YAAAlC,EAAAnxC,KAAA+xC,EAAA53B,GAGA,IAAA63B,GAAAntC,EAAAmtC,SACAC,EAAAptC,EAAAotC,eAEAoU,IAAAlsC,EAAAmsC,YAGA1gD,EAAAnG,KAAA6gB,gBACAoD,GAAA6iC,SAAA3gD,EAAA,GAAAA,EAAA,IAOAnG,KAAAomD,aACA7T,IAAAqU,GAAAhX,GAEA3rB,EAAAjkB,KAAAikB,KAAAkkB,UAAAztB,GAGA63B,IAAAqU,IACA3iC,EAAA4iC,YAAAtU,GACAtuB,EAAA8iC,kBAAAvU,IAGAxyC,KAAAooC,UAAAnkB,EAAAjkB,KAAAyI,OAAA,GAGAzI,KAAAomD,aAAA,IAIA1rC,EAAAytB,YACAnoC,KAAAikB,KAAA0hC,YAAAjrC,IAGAo5B,GAAA7vB,EAAAouB,KAAA33B,GAEA63B,GAAAqU,IACAlsC,EAAAmsC,YAAAtU,GACA73B,EAAA83B,eAAAA,GAGA5C,GAAA3rB,EAAAquB,OAAA53B,GAEA63B,GAAAqU,GAGAlsC,EAAAmsC,gBAIA7mD,KAAAsgB,iBAAA5F,GAGA,MAAAtV,EAAAstC,MAEA1yC,KAAAm1C,aAAAz6B,EAAA1a,KAAAoE,oBAMAgkC,UAAA,SAAA1tB,EAAAssC,EAAAC,KAEA7iD,gBAAA,WACA,GAAA0Z,GAAA9d,KAAAo1C,MACAhwC,EAAApF,KAAAoF,MACA8hD,GAAAppC,CACA,IAAAopC,EAAA,CACA,GAAAjjC,GAAAjkB,KAAAikB,IACAjkB,MAAAomD,cACAniC,EAAAkkB,YACAnoC,KAAAooC,UAAAnkB,EAAAjkB,KAAAyI,OAAA,IAEAqV,EAAAmG,EAAA7f,kBAIA,GAFApE,KAAAo1C,MAAAt3B,EAEA1Y,EAAAwqC,YAAA,CAIA,GAAAuX,GAAAnnD,KAAAonD,kBAAApnD,KAAAonD,gBAAAtpC,EAAAvN,QACA,IAAAvQ,KAAAoc,SAAA8qC,EAAA,CACAC,EAAA9oC,KAAAP,EAEA,IAAAiL,GAAA3jB,EAAAuqC,UAEA0X,EAAAjiD,EAAAqtC,cAAAzyC,KAAA6zC,eAAA,CAGAzuC,GAAA0uC,YACA/qB,EAAArI,KAAApZ,IAAAyhB,EAAA/oB,KAAAqmD,wBAAA,IAIAgB,EAAA,QACAF,EAAApjD,OAAAglB,EAAAs+B,EACAF,EAAA9iD,QAAA0kB,EAAAs+B,EACAF,EAAA5kD,GAAAwmB,EAAAs+B,EAAA,EACAF,EAAA1kD,GAAAsmB,EAAAs+B,EAAA,GAKA,MAAAF,GAGA,MAAArpC,IAGA5G,QAAA,SAAA3U,EAAAE,GACA,GAAA6kD,GAAAtnD,KAAA8gB,sBAAAve,EAAAE,GACAqb,EAAA9d,KAAAoE,kBACAgB,EAAApF,KAAAoF,KAIA,IAHA7C,EAAA+kD,EAAA,GACA7kD,EAAA6kD,EAAA,GAEAxpC,EAAA5G,QAAA3U,EAAAE,GAAA,CACA,GAAA09C,GAAAngD,KAAAikB,KAAAxR,IACA,IAAArN,EAAAwqC,YAAA,CACA,GAAAD,GAAAvqC,EAAAuqC,UACA0X,EAAAjiD,EAAAqtC,cAAAzyC,KAAA6zC,eAAA,CAEA,IAAAwT,EAAA,QAEAjiD,EAAA0uC,YACAnE,EAAAjvB,KAAApZ,IAAAqoC,EAAA3vC,KAAAqmD,yBAEAF,EAAAoB,cACApH,EAAAxQ,EAAA0X,EAAA9kD,EAAAE,IAEA,OAAA,EAIA,GAAA2C,EAAA0uC,UACA,MAAAqS,GAAAjvC,QAAAipC,EAAA59C,EAAAE,GAGA,OAAA,GAMAya,MAAA,SAAAsqC,GACA,MAAAA,IACAA,GAAA,GAGAA,IACAxnD,KAAAomD,YAAAoB,EACAxnD,KAAAo1C,MAAA,MAGAp1C,KAAAoc,SAAA,EAEApc,KAAAkY,MAAAlY,KAAAkY,KAAA9J,UAGApO,KAAAgf,cACAhf,KAAAgf,aAAA9B,SAQAuqC,aAAA,SAAAvjC,GACA,MAAAlkB,MAAAgkB,QAAA,QAAAE,IAIAvF,OAAA,SAAAhU,EAAAoH,GAEA,UAAApH,GACA3K,KAAA0nD,SAAA31C,GACA/R,KAAAomD,aAAA,EACApmD,KAAAo1C,MAAA,MAGAZ,EAAA5yC,UAAA+c,OAAApe,KAAAP,KAAA2K,EAAAoH,IAQA21C,SAAA,SAAA/8C,EAAAoH,GACA,GAAAtJ,GAAAzI,KAAAyI,KAEA,IAAAA,EAAA,CACA,GAAAuC,EAAAmG,SAAAxG,GACA,IAAA,GAAApF,KAAAoF,GACAA,EAAAoB,eAAAxG,KACAkD,EAAAlD,GAAAoF,EAAApF,QAKAkD,GAAAkC,GAAAoH,CAEA/R,MAAAkd,OAAA,GAEA,MAAAld,OAGA6zC,aAAA,WACA,GAAArzC,GAAAR,KAAAme,SAKA,OAAA3d,IAAAqiD,EAAAriD,EAAA,GAAA,GAAA,OAAAqiD,EAAAriD,EAAA,GAAA,GAAA,MACAkgB,KAAAC,KAAAkiC,EAAAriD,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,KACA,IAcA8+C,EAAA5tC,OAAA,SAAApH,GACA,GAAAq9C,GAAA,SAAA9mD,GACAy+C,EAAA/+C,KAAAP,KAAAa,GAEAyJ,EAAAlF,OAEApF,KAAAoF,MAAAgtC,WAAA9nC,EAAAlF,OAAA,EAIA,IAAAwiD,GAAAt9C,EAAA7B,KACA,IAAAm/C,EAAA,CACA5nD,KAAAyI,MAAAzI,KAAAyI,SACA,IAAAo/C,GAAA7nD,KAAAyI,KACA,KAAA,GAAAlD,KAAAqiD,IAEAC,EAAA97C,eAAAxG,IACAqiD,EAAA77C,eAAAxG,KAEAsiD,EAAAtiD,GAAAqiD,EAAAriD,IAKA+E,EAAApJ,MAAAoJ,EAAApJ,KAAAX,KAAAP,KAAAa,GAGAmK,GAAAgH,SAAA21C,EAAArI,EAGA,KAAA,GAAA/5C,KAAA+E,GAEA,UAAA/E,GAAA,UAAAA,IACAoiD,EAAA/lD,UAAA2D,GAAA+E,EAAA/E,GAIA,OAAAoiD,IAGA38C,EAAAgH,SAAAstC,EAAA9K,GAEA30C,EAAAD,QAAA0/C,G7CktXM,SAASz/C,EAAQD,EAASM,G8CxjYhC,YAYA,IAAA4nD,GAAA5nD,EAAA,IACA88B,EAAA98B,EAAA,IACA6nD,EAAA7nD,EAAA,IACAqd,EAAArd,EAAA,IACA2O,EAAA3O,EAAA,IAAAkB,iBAEA0jD,GACAG,EAAA,EACAh0B,EAAA,EACAi0B,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EAEA10B,EAAA,GAGAtpB,KACAC,KACA0gD,KACAC,KACA/qB,EAAAxc,KAAArZ,IACA81B,EAAAzc,KAAApZ,IACAk8C,EAAA9iC,KAAA8B,IACAihC,EAAA/iC,KAAA4B,IACAshC,EAAAljC,KAAAC,KACAunC,EAAAxnC,KAAAmiC,IAEAsF,EAAA,mBAAAjnC,cAMA2jC,EAAA,WAMA7kD,KAAAyS,QAEAzS,KAAA+7B,KAAA,EAEA/7B,KAAA6R,KAAA,KAEA7R,KAAAooD,IAAA,EACApoD,KAAAqoD,IAAA,EAEAroD,KAAAsoD,IAAA,EACAtoD,KAAAuoD,IAAA,EAGAvoD,KAAAwoD,IAAA,EACAxoD,KAAAyoD,IAAA,EAOA5D,GAAAjjD,WAEA+L,YAAAk3C,EAEA6D,UAAA,KAEAC,YAAA,EAEAC,SAAA,EAEAC,SAAA,EAKA/B,SAAA,SAAAtmC,EAAAC,GACAzgB,KAAAwoD,IAAAN,EAAA,EAAAr5C,EAAA2R,IAAA,EACAxgB,KAAAyoD,IAAAP,EAAA,EAAAr5C,EAAA4R,IAAA,GAGAxQ,WAAA,WACA,MAAAjQ,MAAA6R,MAOAs2B,UAAA,SAAAztB,GAiBA,MAfA1a,MAAA6R,KAAA6I,EAEAA,GAAAA,EAAAytB,YAEAztB,IAAA1a,KAAA6O,IAAA6L,EAAA7L,KAGA7O,KAAA+7B,KAAA,EAEA/7B,KAAA0oD,YACA1oD,KAAA0oD,UAAA,KAEA1oD,KAAA2oD,YAAA,GAGA3oD,MAQA8oD,OAAA,SAAAvmD,EAAAE,GAcA,MAbAzC,MAAAokD,QAAAU,EAAAG,EAAA1iD,EAAAE,GACAzC,KAAA6R,MAAA7R,KAAA6R,KAAAi3C,OAAAvmD,EAAAE,GAMAzC,KAAAsoD,IAAA/lD,EACAvC,KAAAuoD,IAAA9lD,EAEAzC,KAAAooD,IAAA7lD,EACAvC,KAAAqoD,IAAA5lD,EAEAzC,MAQA+oD,OAAA,SAAAxmD,EAAAE,GACA,GAAAumD,GAAAd,EAAA3lD,EAAAvC,KAAAooD,KAAApoD,KAAAwoD,KACAN,EAAAzlD,EAAAzC,KAAAqoD,KAAAroD,KAAAyoD,KAEAzoD,KAAA+7B,KAAA,CAaA,OAXA/7B,MAAAokD,QAAAU,EAAA7zB,EAAA1uB,EAAAE,GAEAzC,KAAA6R,MAAAm3C,IACAhpD,KAAAipD,aAAAjpD,KAAAkpD,cAAA3mD,EAAAE,GACAzC,KAAA6R,KAAAk3C,OAAAxmD,EAAAE,IAEAumD,IACAhpD,KAAAooD,IAAA7lD,EACAvC,KAAAqoD,IAAA5lD,GAGAzC,MAYAmpD,cAAA,SAAAnI,EAAAC,EAAAnP,EAAAC,EAAAqX,EAAAC,GAQA,MAPArpD,MAAAokD,QAAAU,EAAAI,EAAAlE,EAAAC,EAAAnP,EAAAC,EAAAqX,EAAAC,GACArpD,KAAA6R,OACA7R,KAAAipD,aAAAjpD,KAAAspD,gBAAAtI,EAAAC,EAAAnP,EAAAC,EAAAqX,EAAAC,GACArpD,KAAA6R,KAAAs3C,cAAAnI,EAAAC,EAAAnP,EAAAC,EAAAqX,EAAAC,IAEArpD,KAAAooD,IAAAgB,EACAppD,KAAAqoD,IAAAgB,EACArpD,MAUAupD,iBAAA,SAAAvI,EAAAC,EAAAnP,EAAAC,GAQA,MAPA/xC,MAAAokD,QAAAU,EAAAK,EAAAnE,EAAAC,EAAAnP,EAAAC,GACA/xC,KAAA6R,OACA7R,KAAAipD,aAAAjpD,KAAAwpD,mBAAAxI,EAAAC,EAAAnP,EAAAC,GACA/xC,KAAA6R,KAAA03C,iBAAAvI,EAAAC,EAAAnP,EAAAC,IAEA/xC,KAAAooD,IAAAtW,EACA9xC,KAAAqoD,IAAAtW,EACA/xC,MAYAypD,IAAA,SAAAjJ,EAAAC,EAAAxxB,EAAAy6B,EAAAC,EAAAC,GAQA,MAPA5pD,MAAAokD,QACAU,EAAAM,EAAA5E,EAAAC,EAAAxxB,EAAAA,EAAAy6B,EAAAC,EAAAD,EAAA,EAAAE,EAAA,EAAA,GAEA5pD,KAAA6R,MAAA7R,KAAA6R,KAAA43C,IAAAjJ,EAAAC,EAAAxxB,EAAAy6B,EAAAC,EAAAC,GAEA5pD,KAAAooD,IAAA5E,EAAAmG,GAAA16B,EAAAuxB,EACAxgD,KAAAqoD,IAAA5E,EAAAkG,GAAA16B,EAAAuxB,EACAxgD,MAIA6pD,MAAA,SAAA7I,EAAAC,EAAAnP,EAAAC,EAAA+X,GAIA,MAHA9pD,MAAA6R,MACA7R,KAAA6R,KAAAg4C,MAAA7I,EAAAC,EAAAnP,EAAAC,EAAA+X,GAEA9pD,MAIA8d,KAAA,SAAAvb,EAAAE,EAAAsmB,EAAAtO,GAGA,MAFAza,MAAA6R,MAAA7R,KAAA6R,KAAAiM,KAAAvb,EAAAE,EAAAsmB,EAAAtO,GACAza,KAAAokD,QAAAU,EAAAn0B,EAAApuB,EAAAE,EAAAsmB,EAAAtO,GACAza,MAMA+pD,UAAA,WACA/pD,KAAAokD,QAAAU,EAAAO,EAEA,IAAA3qC,GAAA1a,KAAA6R,KACAm4C,EAAAhqD,KAAAsoD,IACA2B,EAAAjqD,KAAAuoD,GAQA,OAPA7tC,KACA1a,KAAAipD,cAAAjpD,KAAAkpD,cAAAc,EAAAC,GACAvvC,EAAAqvC,aAGA/pD,KAAAooD,IAAA4B,EACAhqD,KAAAqoD,IAAA4B,EACAjqD,MASAqyC,KAAA,SAAA33B,GACAA,GAAAA,EAAA23B,OACAryC,KAAAslD,YAOAhT,OAAA,SAAA53B,GACAA,GAAAA,EAAA43B,SACAtyC,KAAAslD,YAQAuB,YAAA,SAAAtU,GACA,GAAAA,YAAAv8B,OAAA,CACAhW,KAAA0oD,UAAAnW,EAEAvyC,KAAA4oD,SAAA,CAGA,KAAA,GADAsB,GAAA,EACA9mD,EAAA,EAA+BA,EAAAmvC,EAAArvC,OAAqBE,IACpD8mD,GAAA3X,EAAAnvC,EAEApD,MAAA6oD,SAAAqB,EAEA,MAAAlqD,OAQA+mD,kBAAA,SAAAvnB,GAEA,MADAx/B,MAAA2oD,YAAAnpB,EACAx/B,MAOA4Q,IAAA,WACA,MAAA5Q,MAAA+7B,MAMA0pB,QAAA,SAAAhzC,GAEA,GAAA7B,GAAA6B,EAAAvP,MAEAlD,MAAAyS,MAAAzS,KAAAyS,KAAAvP,QAAA0N,IAAAu3C,IACAnoD,KAAAyS,KAAA,GAAAyO,cAAAtQ,GAGA,KAAA,GAAAxN,GAAA,EAA2BA,EAAAwN,EAASxN,IACpCpD,KAAAyS,KAAArP,GAAAqP,EAAArP,EAGApD,MAAA+7B,KAAAnrB,GAOAs1C,WAAA,SAAAjiC,GACAA,YAAAjO,SACAiO,GAAAA,GAKA,KAAA,GAHArT,GAAAqT,EAAA/gB,OACAinD,EAAA,EACA3qB,EAAAx/B,KAAA+7B,KACA34B,EAAA,EAA2BA,EAAAwN,EAASxN,IACpC+mD,GAAAlmC,EAAA7gB,GAAAwN,KAEAu3C,IAAAnoD,KAAAyS,eAAAyO,gBACAlhB,KAAAyS,KAAA,GAAAyO,cAAAse,EAAA2qB;AAEA,IAAA,GAAA/mD,GAAA,EAA2BA,EAAAwN,EAASxN,IAEpC,IAAA,GADAgnD,GAAAnmC,EAAA7gB,GAAAqP,KACAyZ,EAAA,EAA+BA,EAAAk+B,EAAAlnD,OAA2BgpB,IAC1DlsB,KAAAyS,KAAA+sB,KAAA4qB,EAAAl+B,EAGAlsB,MAAA+7B,KAAAyD,GAOA4kB,QAAA,SAAAf,GACA,GAAA5wC,GAAAzS,KAAAyS,IACAzS,MAAA+7B,KAAAroB,UAAAxQ,OAAAuP,EAAAvP,SAGAlD,KAAAqqD,cACA53C,EAAAzS,KAAAyS,KAEA,KAAA,GAAArP,GAAA,EAA2BA,EAAAsQ,UAAAxQ,OAAsBE,IACjDqP,EAAAzS,KAAA+7B,QAAAroB,UAAAtQ,EAGApD,MAAAsqD,SAAAjH,GAGAgH,YAAA,WAEA,KAAArqD,KAAAyS,eAAAuD,QAAA,CAEA,IAAA,GADAu0C,MACAnnD,EAAA,EAA+BA,EAAApD,KAAA+7B,KAAe34B,IAC9CmnD,EAAAnnD,GAAApD,KAAAyS,KAAArP,EAEApD,MAAAyS,KAAA83C,IASAtB,WAAA,WACA,MAAAjpD,MAAA0oD,WAGAQ,cAAA,SAAAlI,EAAAC,GACA,GAYAuJ,GAEAxtC,EAdAytC,EAAAzqD,KAAA6oD,SACArpB,EAAAx/B,KAAA2oD,YACApW,EAAAvyC,KAAA0oD,UACAhuC,EAAA1a,KAAA6R,KAEAm4C,EAAAhqD,KAAAooD,IACA6B,EAAAjqD,KAAAqoD,IACAtuC,EAAAinC,EAAAgJ,EACAhwC,EAAAinC,EAAAgJ,EACArmC,EAAAggC,EAAA7pC,EAAAA,EAAAC,EAAAA,GACAzX,EAAAynD,EACAvnD,EAAAwnD,EAEAS,EAAAnY,EAAArvC,MAaA,KAXA6W,GAAA6J,EACA5J,GAAA4J,EAEA4b,EAAA,IAEAA,EAAAirB,EAAAjrB,GAEAA,GAAAirB,EACAloD,GAAAi9B,EAAAzlB,EACAtX,GAAA+8B,EAAAxlB,EAEAD,EAAA,GAAAxX,GAAAy+C,GAAAjnC,EAAA,GAAAxX,GAAAy+C,GACA,GAAAjnC,IAAAC,EAAA,GAAAvX,GAAAw+C,GAAAjnC,EAAA,GAAAvX,GAAAw+C,IACAjkC,EAAAhd,KAAA4oD,SACA4B,EAAAjY,EAAAv1B,GACAza,GAAAwX,EAAAywC,EACA/nD,GAAAuX,EAAAwwC,EACAxqD,KAAA4oD,UAAA5rC,EAAA,GAAA0tC,EAEA3wC,EAAA,GAAAxX,EAAAynD,GAAAjwC,EAAA,GAAAxX,EAAAynD,GAAAhwC,EAAA,GAAAvX,EAAAwnD,GAAAjwC,EAAA,GAAAvX,EAAAwnD,GAGAvvC,EAAAsC,EAAA,EAAA,SAAA,UACAjD,GAAA,EAAAmjB,EAAA36B,EAAAy+C,GAAA7jB,EAAA56B,EAAAy+C,GACAhnC,GAAA,EAAAkjB,EAAAz6B,EAAAw+C,GAAA9jB,EAAA16B,EAAAw+C,GAIAlnC,GAAAxX,EAAAy+C,EACAhnC,EAAAvX,EAAAw+C,EACAjhD,KAAA2oD,aAAA/E,EAAA7pC,EAAAA,EAAAC,EAAAA,IAIAsvC,gBAAA,SAAAtI,EAAAC,EAAAnP,EAAAC,EAAAqX,EAAAC,GACA,GAOA3lC,GACA3J,EACAC,EAMAzX,EACAE,EAhBAgoD,EAAAzqD,KAAA6oD,SACArpB,EAAAx/B,KAAA2oD,YACApW,EAAAvyC,KAAA0oD,UACAhuC,EAAA1a,KAAA6R,KAEAm4C,EAAAhqD,KAAAooD,IACA6B,EAAAjqD,KAAAqoD,IAIAsC,EAAA7C,EAAA6C,QACAC,EAAA,EACA5tC,EAAAhd,KAAA4oD,SACA8B,EAAAnY,EAAArvC,OAKA2nD,EAAA,CAQA,KANArrB,EAAA,IAEAA,EAAAirB,EAAAjrB,GAEAA,GAAAirB,EAEA/mC,EAAA,EAAuBA,EAAA,EAAOA,GAAA,GAC9B3J,EAAA4wC,EAAAX,EAAAhJ,EAAAlP,EAAAsX,EAAA1lC,EAAA,IACAinC,EAAAX,EAAAhJ,EAAAlP,EAAAsX,EAAA1lC,GACA1J,EAAA2wC,EAAAV,EAAAhJ,EAAAlP,EAAAsX,EAAA3lC,EAAA,IACAinC,EAAAV,EAAAhJ,EAAAlP,EAAAsX,EAAA3lC,GACAknC,GAAAhH,EAAA7pC,EAAAA,EAAAC,EAAAA,EAIA,MAAkBgD,EAAA0tC,IAClBG,GAAAtY,EAAAv1B,KACA6tC,EAAArrB,IAF+BxiB,KAQ/B,IAFA0G,GAAAmnC,EAAArrB,GAAAorB,EAEAlnC,GAAA,GAEAnhB,EAAAooD,EAAAX,EAAAhJ,EAAAlP,EAAAsX,EAAA1lC,GACAjhB,EAAAkoD,EAAAV,EAAAhJ,EAAAlP,EAAAsX,EAAA3lC,GAIA1G,EAAA,EAAAtC,EAAAouC,OAAAvmD,EAAAE,GACAiY,EAAAquC,OAAAxmD,EAAAE,GAEAihB,GAAA6uB,EAAAv1B,GAAA4tC,EAEA5tC,GAAAA,EAAA,GAAA0tC,CAIA1tC,GAAA,IAAA,GAAAtC,EAAAquC,OAAAK,EAAAC,GACAtvC,EAAAqvC,EAAA7mD,EACAyX,EAAAqvC,EAAA5mD,EACAzC,KAAA2oD,aAAA/E,EAAA7pC,EAAAA,EAAAC,EAAAA,IAGAwvC,mBAAA,SAAAxI,EAAAC,EAAAnP,EAAAC,GAEA,GAAAqX,GAAAtX,EACAuX,EAAAtX,CACAD,IAAAA,EAAA,EAAAkP,GAAA,EACAjP,GAAAA,EAAA,EAAAkP,GAAA,EACAD,GAAAhhD,KAAAooD,IAAA,EAAApH,GAAA,EACAC,GAAAjhD,KAAAqoD,IAAA,EAAApH,GAAA,EAEAjhD,KAAAspD,gBAAAtI,EAAAC,EAAAnP,EAAAC,EAAAqX,EAAAC,IAOA/D,SAAA,WACA,GAAA7yC,GAAAzS,KAAAyS,IACAA,aAAAuD,SACAvD,EAAAvP,OAAAlD,KAAA+7B,KACAosB,IACAnoD,KAAAyS,KAAA,GAAAyO,cAAAzO,MAQArO,gBAAA,WACAiD,EAAA,GAAAA,EAAA,GAAA2gD,EAAA,GAAAA,EAAA,GAAA8C,OAAAC,UACAzjD,EAAA,GAAAA,EAAA,GAAA2gD,EAAA,GAAAA,EAAA,IAAA6C,OAAAC,SAQA,KAAA,GANAt4C,GAAAzS,KAAAyS,KACAu4C,EAAA,EACAC,EAAA,EACAjB,EAAA,EACAC,EAAA,EAEA7mD,EAAA,EAA2BA,EAAAqP,EAAAvP,QAAiB,CAC5C,GAAAmgD,GAAA5wC,EAAArP,IAcA,QAZA,GAAAA,IAKA4nD,EAAAv4C,EAAArP,GACA6nD,EAAAx4C,EAAArP,EAAA,GAEA4mD,EAAAgB,EACAf,EAAAgB,GAGA5H,GACA,IAAAyB,GAAAG,EAGA+E,EAAAv3C,EAAArP,KACA6mD,EAAAx3C,EAAArP,KACA4nD,EAAAhB,EACAiB,EAAAhB,EACAjC,EAAA,GAAAgC,EACAhC,EAAA,GAAAiC,EACAhC,EAAA,GAAA+B,EACA/B,EAAA,GAAAgC,CACA,MACA,KAAAnF,GAAA7zB,EACA82B,EAAAmD,SAAAF,EAAAC,EAAAx4C,EAAArP,GAAAqP,EAAArP,EAAA,GAAA4kD,EAAAC,GACA+C,EAAAv4C,EAAArP,KACA6nD,EAAAx4C,EAAArP,IACA,MACA,KAAA0hD,GAAAI,EACA6C,EAAAoD,UACAH,EAAAC,EAAAx4C,EAAArP,KAAAqP,EAAArP,KAAAqP,EAAArP,KAAAqP,EAAArP,KAAAqP,EAAArP,GAAAqP,EAAArP,EAAA,GACA4kD,EAAAC,GAEA+C,EAAAv4C,EAAArP,KACA6nD,EAAAx4C,EAAArP,IACA,MACA,KAAA0hD,GAAAK,EACA4C,EAAAqD,cACAJ,EAAAC,EAAAx4C,EAAArP,KAAAqP,EAAArP,KAAAqP,EAAArP,GAAAqP,EAAArP,EAAA,GACA4kD,EAAAC,GAEA+C,EAAAv4C,EAAArP,KACA6nD,EAAAx4C,EAAArP,IACA,MACA,KAAA0hD,GAAAM,EAEA,GAAA5E,GAAA/tC,EAAArP,KACAq9C,EAAAhuC,EAAArP,KACA8/C,EAAAzwC,EAAArP,KACA+/C,EAAA1wC,EAAArP,KACAsmD,EAAAj3C,EAAArP,KACAumD,EAAAl3C,EAAArP,KAAAsmD,EAGAE,GADAn3C,EAAArP,KACA,EAAAqP,EAAArP,KAEA,IAAAA,IAGA4mD,EAAAxG,EAAAkG,GAAAxG,EAAA1C,EACAyJ,EAAAxG,EAAAiG,GAAAvG,EAAA1C,GAGAsH,EAAAsD,QACA7K,EAAAC,EAAAyC,EAAAC,EAAAuG,EAAAC,EACAC,EAAA5B,EAAAC,GAGA+C,EAAAxH,EAAAmG,GAAAzG,EAAA1C,EACAyK,EAAAxH,EAAAkG,GAAAxG,EAAA1C,CACA,MACA,KAAAqE,GAAAn0B,EACAq5B,EAAAgB,EAAAv4C,EAAArP,KACA6mD,EAAAgB,EAAAx4C,EAAArP,IACA,IAAAW,GAAA0O,EAAArP,KACAiB,EAAAoO,EAAArP,IAEA2kD,GAAAmD,SAAAlB,EAAAC,EAAAD,EAAAjmD,EAAAkmD,EAAA5lD,EAAA2jD,EAAAC,EACA,MACA,KAAAnD,GAAAO,EACA2F,EAAAhB,EACAiB,EAAAhB,EAKAjtB,EAAA31B,IAAAA,EAAAA,EAAA2gD,GACAhrB,EAAA11B,IAAAA,EAAAA,EAAA2gD,GAQA,MAJA,KAAA7kD,IACAiE,EAAA,GAAAA,EAAA,GAAAC,EAAA,GAAAA,EAAA,GAAA,GAGA,GAAAiW,GACAlW,EAAA,GAAAA,EAAA,GAAAC,EAAA,GAAAD,EAAA,GAAAC,EAAA,GAAAD,EAAA,KASAs+C,YAAA,SAAAjrC,GAQA,IAAA,GANAsvC,GAAAC,EACAe,EAAAC,EACA1oD,EAAAE,EAHA4gB,EAAArjB,KAAAyS,KAIA64C,EAAAtrD,KAAAwoD,IACA+C,EAAAvrD,KAAAyoD,IACA73C,EAAA5Q,KAAA+7B,KACA34B,EAAA,EAA2BA,EAAAwN,GAAS,CACpC,GAAAyyC,GAAAhgC,EAAAjgB,IAaA,QAXA,GAAAA,IAKA4nD,EAAA3nC,EAAAjgB,GACA6nD,EAAA5nC,EAAAjgB,EAAA,GAEA4mD,EAAAgB,EACAf,EAAAgB,GAEA5H,GACA,IAAAyB,GAAAG,EACA+E,EAAAgB,EAAA3nC,EAAAjgB,KACA6mD,EAAAgB,EAAA5nC,EAAAjgB,KACAsX,EAAAouC,OAAAkC,EAAAC,EACA,MACA,KAAAnG,GAAA7zB,EACA1uB,EAAA8gB,EAAAjgB,KACAX,EAAA4gB,EAAAjgB,MAEA8kD,EAAA3lD,EAAAyoD,GAAAM,GAAApD,EAAAzlD,EAAAwoD,GAAAM,GAAAnoD,IAAAwN,EAAA,KACA8J,EAAAquC,OAAAxmD,EAAAE,GACAuoD,EAAAzoD,EACA0oD,EAAAxoD,EAEA,MACA,KAAAqiD,GAAAI,EACAxqC,EAAAyuC,cACA9lC,EAAAjgB,KAAAigB,EAAAjgB,KAAAigB,EAAAjgB,KAAAigB,EAAAjgB,KAAAigB,EAAAjgB,KAAAigB,EAAAjgB,MAEA4nD,EAAA3nC,EAAAjgB,EAAA,GACA6nD,EAAA5nC,EAAAjgB,EAAA,EACA,MACA,KAAA0hD,GAAAK,EACAzqC,EAAA6uC,iBAAAlmC,EAAAjgB,KAAAigB,EAAAjgB,KAAAigB,EAAAjgB,KAAAigB,EAAAjgB,MACA4nD,EAAA3nC,EAAAjgB,EAAA,GACA6nD,EAAA5nC,EAAAjgB,EAAA,EACA,MACA,KAAA0hD,GAAAM,EACA,GAAA5E,GAAAn9B,EAAAjgB,KACAq9C,EAAAp9B,EAAAjgB,KACA8/C,EAAA7/B,EAAAjgB,KACA+/C,EAAA9/B,EAAAjgB,KACA2gD,EAAA1gC,EAAAjgB,KACA8gD,EAAA7gC,EAAAjgB,KACAkgD,EAAAjgC,EAAAjgB,KACA6/C,EAAA5/B,EAAAjgB,KACA6rB,EAAAi0B,EAAAC,EAAAD,EAAAC,EACAqI,EAAAtI,EAAAC,EAAA,EAAAD,EAAAC,EACAsI,EAAAvI,EAAAC,EAAAA,EAAAD,EAAA,EACAwI,EAAAhrC,KAAAmiC,IAAAK,EAAAC,GAAA,KACAwG,EAAA5F,EAAAG,CACAwH,IACAhxC,EAAAkH,UAAA4+B,EAAAC,GACA/lC,EAAA0F,OAAAkjC,GACA5oC,EAAAvU,MAAAqlD,EAAAC,GACA/wC,EAAA+uC,IAAA,EAAA,EAAAx6B,EAAA80B,EAAA4F,EAAA,EAAA1G,GACAvoC,EAAAvU,MAAA,EAAAqlD,EAAA,EAAAC,GACA/wC,EAAA0F,QAAAkjC,GACA5oC,EAAAkH,WAAA4+B,GAAAC,IAGA/lC,EAAA+uC,IAAAjJ,EAAAC,EAAAxxB,EAAA80B,EAAA4F,EAAA,EAAA1G,GAGA,GAAA7/C,IAGA4mD,EAAAxG,EAAAO,GAAAb,EAAA1C,EACAyJ,EAAAxG,EAAAM,GAAAZ,EAAA1C,GAEAuK,EAAAxH,EAAAmG,GAAAzG,EAAA1C,EACAyK,EAAAxH,EAAAkG,GAAAxG,EAAA1C,CACA,MACA,KAAAqE,GAAAn0B,EACAq5B,EAAAgB,EAAA3nC,EAAAjgB,GACA6mD,EAAAgB,EAAA5nC,EAAAjgB,EAAA,GACAsX,EAAAoD,KAAAuF,EAAAjgB,KAAAigB,EAAAjgB,KAAAigB,EAAAjgB,KAAAigB,EAAAjgB,KACA,MACA,KAAA0hD,GAAAO,EACA3qC,EAAAqvC,YACAiB,EAAAhB,EACAiB,EAAAhB,MAMApF,EAAAC,IAAAA,EAEAjlD,EAAAD,QAAAilD,G9C+jYM,SAAShlD,EAAQD,EAASM,G+C/zZhC,YA0BA,SAAAyrD,GAAAtsC,GACA,MAAAA,IAAAC,GAAAD,EAAAC,EAEA,QAAAF,GAAAC,GACA,MAAAA,GAAAC,GAAAD,GAAAC,EAYA,QAAAqrC,GAAAllC,EAAAC,EAAAgB,EAAAC,EAAAjD,GACA,GAAAkoC,GAAA,EAAAloC,CACA,OAAAkoC,GAAAA,GAAAA,EAAAnmC,EAAA,EAAA/B,EAAAgC,GACAhC,EAAAA,GAAAA,EAAAiD,EAAA,EAAAilC,EAAAllC,GAaA,QAAAmlC,GAAApmC,EAAAC,EAAAgB,EAAAC,EAAAjD,GACA,GAAAkoC,GAAA,EAAAloC,CACA,OAAA,MACAgC,EAAAD,GAAAmmC,EAAA,GAAAllC,EAAAhB,GAAAhC,GAAAkoC,GACAjlC,EAAAD,GAAAhD,EAAAA,GAeA,QAAAooC,GAAArmC,EAAAC,EAAAgB,EAAAC,EAAAtH,EAAAtD,GAEA,GAAAb,GAAAyL,EAAA,GAAAjB,EAAAgB,GAAAjB,EACAtK,EAAA,GAAAuL,EAAA,EAAAhB,EAAAD,GACAhlB,EAAA,GAAAilB,EAAAD,GACApC,EAAAoC,EAAApG,EAEA+lC,EAAAjqC,EAAAA,EAAA,EAAAD,EAAAza,EACAowB,EAAA1V,EAAA1a,EAAA,EAAAya,EAAAmI,EACA6hC,EAAAzkD,EAAAA,EAAA,EAAA0a,EAAAkI,EAEAkb,EAAA,CAEA,IAAAotB,EAAAvG,IAAAuG,EAAA96B,GACA,GAAA86B,EAAAxwC,GACAY,EAAA,GAAA,MAEA,CACA,GAAAgwC,IAAAtrD,EAAA0a,CACA4wC,IAAA,GAAAA,GAAA,IACAhwC,EAAAwiB,KAAAwtB,OAIA,CACA,GAAAC,GAAAn7B,EAAAA,EAAA,EAAAu0B,EAAAF,CAEA,IAAAyG,EAAAK,GAAA,CACA,GAAAC,GAAAp7B,EAAAu0B,EACA2G,GAAA5wC,EAAAD,EAAA+wC,EACArlC,GAAAqlC,EAAA,CACAF,IAAA,GAAAA,GAAA,IACAhwC,EAAAwiB,KAAAwtB,GAEAnlC,GAAA,GAAAA,GAAA,IACA7K,EAAAwiB,KAAA3X,OAGA,IAAAolC,EAAA,EAAA,CACA,GAAAE,GAAAtI,EAAAoI,GACAG,EAAA/G,EAAAjqC,EAAA,IAAAD,IAAA2V,EAAAq7B,GACAE,EAAAhH,EAAAjqC,EAAA,IAAAD,IAAA2V,EAAAq7B,EAEAC,GADAA,EAAA,GACAE,GAAAF,EAAAG,GAGAD,EAAAF,EAAAG,GAGAF,EADAA,EAAA,GACAC,GAAAD,EAAAE,GAGAD,EAAAD,EAAAE,EAEA,IAAAP,KAAA5wC,GAAAgxC,EAAAC,KAAA,EAAAlxC,EACA6wC,IAAA,GAAAA,GAAA,IACAhwC,EAAAwiB,KAAAwtB,OAGA,CACA,GAAAQ,IAAA,EAAAnH,EAAAjqC,EAAA,EAAAD,EAAA2V,IAAA,EAAA+yB,EAAAwB,EAAAA,EAAAA,IACArB,EAAArjC,KAAAmlC,KAAA0G,GAAA,EACAC,EAAA5I,EAAAwB,GACA1hD,EAAAgd,KAAA8B,IAAAuhC,GAEAgI,IAAA5wC,EAAA,EAAAqxC,EAAA9oD,IAAA,EAAAwX,GACA0L,IAAAzL,EAAAqxC,GAAA9oD,EAAA+oD,EAAA/rC,KAAA4B,IAAAyhC,MAAA,EAAA7oC,GACA2L,IAAA1L,EAAAqxC,GAAA9oD,EAAA+oD,EAAA/rC,KAAA4B,IAAAyhC,MAAA,EAAA7oC,EACA6wC,IAAA,GAAAA,GAAA,IACAhwC,EAAAwiB,KAAAwtB,GAEAnlC,GAAA,GAAAA,GAAA,IACA7K,EAAAwiB,KAAA3X,GAEAC,GAAA,GAAAA,GAAA,IACA9K,EAAAwiB,KAAA1X,IAIA,MAAA0X,GAaA,QAAAmuB,GAAAjnC,EAAAC,EAAAgB,EAAAC,EAAAgmC,GACA,GAAAxxC,GAAA,EAAAuL,EAAA,GAAAhB,EAAA,EAAAD,EACAvK,EAAA,EAAAwK,EAAA,EAAAiB,EAAA,EAAAlB,EAAA,EAAAiB,EACAjmB,EAAA,EAAAilB,EAAA,EAAAD,EAEA8Y,EAAA,CACA,IAAAotB,EAAAzwC,IACA,GAAAkE,EAAAjE,GAAA,CACA,GAAA4wC,IAAAtrD,EAAA0a,CACA4wC,IAAA,GAAAA,GAAA,IACAY,EAAApuB,KAAAwtB,QAIA,CACA,GAAAC,GAAA7wC,EAAAA,EAAA,EAAAD,EAAAza,CACA,IAAAkrD,EAAAK,GACAW,EAAA,IAAAxxC,GAAA,EAAAD,OAEA,IAAA8wC,EAAA,EAAA,CACA,GAAAE,GAAAtI,EAAAoI,GACAD,IAAA5wC,EAAA+wC,IAAA,EAAAhxC,GACA0L,IAAAzL,EAAA+wC,IAAA,EAAAhxC,EACA6wC,IAAA,GAAAA,GAAA,IACAY,EAAApuB,KAAAwtB,GAEAnlC,GAAA,GAAAA,GAAA,IACA+lC,EAAApuB,KAAA3X,IAIA,MAAA2X,GAaA,QAAAquB,GAAAnnC,EAAAC,EAAAgB,EAAAC,EAAAjD,EAAAvC,GACA,GAAA0rC,IAAAnnC,EAAAD,GAAA/B,EAAA+B,EACAqnC,GAAApmC,EAAAhB,GAAAhC,EAAAgC,EACAqnC,GAAApmC,EAAAD,GAAAhD,EAAAgD,EAEAsmC,GAAAF,EAAAD,GAAAnpC,EAAAmpC,EACAI,GAAAF,EAAAD,GAAAppC,EAAAopC,EAEAI,GAAAD,EAAAD,GAAAtpC,EAAAspC,CAEA7rC,GAAA,GAAAsE,EACAtE,EAAA,GAAA0rC,EACA1rC,EAAA,GAAA6rC,EACA7rC,EAAA,GAAA+rC,EAEA/rC,EAAA,GAAA+rC,EACA/rC,EAAA,GAAA8rC,EACA9rC,EAAA,GAAA4rC,EACA5rC,EAAA,GAAAwF,EAmBA,QAAAwmC,GACAnD,EAAAC,EAAAjJ,EAAAC,EAAAnP,EAAAC,EAAAqX,EAAAC,EACA9mD,EAAAE,EAAA0e,GAGA,GAAAuC,GAGA2Y,EACA/4B,EACA8pD,EACAC,EALAC,EAAA,KACAjqC,EAAAkqC,EAAAA,CAMAC,GAAA,GAAAjrD,EACAirD,EAAA,GAAA/qD,CAIA,KAAA,GAAAgrD,GAAA,EAAwBA,EAAA,EAAQA,GAAA,IAChCC,EAAA,GAAA/C,EAAAX,EAAAhJ,EAAAlP,EAAAsX,EAAAqE,GACAC,EAAA,GAAA/C,EAAAV,EAAAhJ,EAAAlP,EAAAsX,EAAAoE,GACAL,EAAAO,EAAAH,EAAAE,GACAN,EAAA/pC,IACAK,EAAA+pC,EACApqC,EAAA+pC,EAGA/pC,GAAAkqC,EAAAA,CAGA,KAAA,GAAAnqD,GAAA,EAAuBA,EAAA,MACvBkqD,EAAAM,GAD+BxqD,IAI/Bi5B,EAAA3Y,EAAA4pC,EACAhqD,EAAAogB,EAAA4pC,EAEAI,EAAA,GAAA/C,EAAAX,EAAAhJ,EAAAlP,EAAAsX,EAAA/sB,GACAqxB,EAAA,GAAA/C,EAAAV,EAAAhJ,EAAAlP,EAAAsX,EAAAhtB,GAEA+wB,EAAAO,EAAAD,EAAAF,GAEAnxB,GAAA,GAAA+wB,EAAA/pC,GACAK,EAAA2Y,EACAhZ,EAAA+pC,IAIAS,EAAA,GAAAlD,EAAAX,EAAAhJ,EAAAlP,EAAAsX,EAAA9lD,GACAuqD,EAAA,GAAAlD,EAAAV,EAAAhJ,EAAAlP,EAAAsX,EAAA/lD,GACA+pD,EAAAM,EAAAE,EAAAL,GAEAlqD,GAAA,GAAA+pD,EAAAhqC,GACAK,EAAApgB,EACA+f,EAAAgqC,GAGAC,GAAA,GAUA,OALAnsC,KACAA,EAAA,GAAAwpC,EAAAX,EAAAhJ,EAAAlP,EAAAsX,EAAA1lC,GACAvC,EAAA,GAAAwpC,EAAAV,EAAAhJ,EAAAlP,EAAAsX,EAAA3lC,IAGAkgC,EAAAvgC,GAWA,QAAAyqC,GAAAroC,EAAAC,EAAAgB,EAAAhD,GACA,GAAAkoC,GAAA,EAAAloC,CACA,OAAAkoC,IAAAA,EAAAnmC,EAAA,EAAA/B,EAAAgC,GAAAhC,EAAAA,EAAAgD,EAWA,QAAAqnC,GAAAtoC,EAAAC,EAAAgB,EAAAhD,GACA,MAAA,KAAA,EAAAA,IAAAgC,EAAAD,GAAA/B,GAAAgD,EAAAhB,IAYA,QAAAsoC,GAAAvoC,EAAAC,EAAAgB,EAAArH,EAAAtD,GACA,GAAAb,GAAAuK,EAAA,EAAAC,EAAAgB,EACAvL,EAAA,GAAAuK,EAAAD,GACAhlB,EAAAglB,EAAApG,EAEAkf,EAAA,CACA,IAAAotB,EAAAzwC,IACA,GAAAkE,EAAAjE,GAAA,CACA,GAAA4wC,IAAAtrD,EAAA0a,CACA4wC,IAAA,GAAAA,GAAA,IACAhwC,EAAAwiB,KAAAwtB,QAIA,CACA,GAAAC,GAAA7wC,EAAAA,EAAA,EAAAD,EAAAza,CACA,IAAAkrD,EAAAK,GAAA,CACA,GAAAD,IAAA5wC,GAAA,EAAAD,EACA6wC,IAAA,GAAAA,GAAA,IACAhwC,EAAAwiB,KAAAwtB,OAGA,IAAAC,EAAA,EAAA,CACA,GAAAE,GAAAtI,EAAAoI,GACAD,IAAA5wC,EAAA+wC,IAAA,EAAAhxC,GACA0L,IAAAzL,EAAA+wC,IAAA,EAAAhxC,EACA6wC,IAAA,GAAAA,GAAA,IACAhwC,EAAAwiB,KAAAwtB,GAEAnlC,GAAA,GAAAA,GAAA,IACA7K,EAAAwiB,KAAA3X,IAIA,MAAA2X,GAWA,QAAA0vB,GAAAxoC,EAAAC,EAAAgB,GACA,GAAAwnC,GAAAzoC,EAAAiB,EAAA,EAAAhB,CACA,OAAA,KAAAwoC,EAEA,IAGAzoC,EAAAC,GAAAwoC,EAaA,QAAAC,GAAA1oC,EAAAC,EAAAgB,EAAAhD,EAAAvC,GACA,GAAA0rC,IAAAnnC,EAAAD,GAAA/B,EAAA+B,EACAqnC,GAAApmC,EAAAhB,GAAAhC,EAAAgC,EACAsnC,GAAAF,EAAAD,GAAAnpC,EAAAmpC,CAGA1rC,GAAA,GAAAsE,EACAtE,EAAA,GAAA0rC,EACA1rC,EAAA,GAAA6rC,EAGA7rC,EAAA,GAAA6rC,EACA7rC,EAAA,GAAA2rC,EACA3rC,EAAA,GAAAuF,EAiBA,QAAA0nC,GACApE,EAAAC,EAAAjJ,EAAAC,EAAAnP,EAAAC,EACAxvC,EAAAE,EAAA0e,GAGA,GAAAuC,GACA4pC,EAAA,KACAjqC,EAAAkqC,EAAAA,CAEAC,GAAA,GAAAjrD,EACAirD,EAAA,GAAA/qD,CAIA,KAAA,GAAAgrD,GAAA,EAAwBA,EAAA,EAAQA,GAAA,IAAA,CAChCC,EAAA,GAAAI,EAAA9D,EAAAhJ,EAAAlP,EAAA2b,GACAC,EAAA,GAAAI,EAAA7D,EAAAhJ,EAAAlP,EAAA0b,EACA,IAAAL,GAAAO,EAAAH,EAAAE,EACAN,GAAA/pC,IACAK,EAAA+pC,EACApqC,EAAA+pC,GAGA/pC,EAAAkqC,EAAAA,CAGA,KAAA,GAAAnqD,GAAA,EAAuBA,EAAA,MACvBkqD,EAAAM,GAD+BxqD,IAAA,CAI/B,GAAAi5B,GAAA3Y,EAAA4pC,EACAhqD,EAAAogB,EAAA4pC,CAEAI,GAAA,GAAAI,EAAA9D,EAAAhJ,EAAAlP,EAAAzV,GACAqxB,EAAA,GAAAI,EAAA7D,EAAAhJ,EAAAlP,EAAA1V,EAEA,IAAA+wB,GAAAO,EAAAD,EAAAF,EAEA,IAAAnxB,GAAA,GAAA+wB,EAAA/pC,EACAK,EAAA2Y,EACAhZ,EAAA+pC,MAEA,CAEAS,EAAA,GAAAC,EAAA9D,EAAAhJ,EAAAlP,EAAAxuC,GACAuqD,EAAA,GAAAC,EAAA7D,EAAAhJ,EAAAlP,EAAAzuC,EACA,IAAA+pD,GAAAM,EAAAE,EAAAL,EACAlqD,IAAA,GAAA+pD,EAAAhqC,GACAK,EAAApgB,EACA+f,EAAAgqC,GAGAC,GAAA,IAUA,MALAnsC,KACAA,EAAA,GAAA2sC,EAAA9D,EAAAhJ,EAAAlP,EAAApuB,GACAvC,EAAA,GAAA2sC,EAAA7D,EAAAhJ,EAAAlP,EAAAruB,IAGAkgC,EAAAvgC,GAvfA,GAAA2Z,GAAA98B,EAAA,IACAmuD,EAAArxB,EAAAhd,OACA2tC,EAAA3wB,EAAAnZ,WACAwoC,EAAA3rC,KAAA0M,IACAw2B,EAAAljC,KAAAC,KAEArB,EAAA,KACAsuC,EAAA,KAEAnB,EAAA7I,EAAA,GACA0I,EAAA,EAAA,EAGAkB,EAAAa,IACAX,EAAAW,IACAR,EAAAQ,GA2eAxuD,GAAAD,SAEA+qD,QAAAA,EAEAkB,kBAAAA,EAEAC,YAAAA,EAEAY,aAAAA,EAEAE,eAAAA,EAEAO,kBAAAA,EAEAW,YAAAA,EAEAC,sBAAAA,EAEAC,gBAAAA,EAEAC,kBAAAA,EAEAE,mBAAAA,EAEAC,sBAAAA,I/Cu0ZM,SAASvuD,EAAQD,EAASM,GgD51ahC,GAAA88B,GAAA98B,EAAA,IACA4nD,EAAA5nD,EAAA,IAEA6nD,KACA7qB,EAAAxc,KAAArZ,IACA81B,EAAAzc,KAAApZ,IACAm8C,EAAA/iC,KAAA4B,IACAkhC,EAAA9iC,KAAA8B,IAEAxV,EAAAgwB,EAAAhd,SACAsuC,EAAAtxB,EAAAhd,SACAuuC,EAAAvxB,EAAAhd,SAEAwuC,EAAA,EAAA9tC,KAAAsM,EAQA+6B,GAAA0G,WAAA,SAAAznB,EAAA3/B,EAAAC,GACA,GAAA,IAAA0/B,EAAA9jC,OAAA,CAGA,GAKAE,GALA1C,EAAAsmC,EAAA,GACA9H,EAAAx+B,EAAA,GACAy+B,EAAAz+B,EAAA,GACA+hC,EAAA/hC,EAAA,GACAguD,EAAAhuD,EAAA,EAGA,KAAA0C,EAAA,EAAmBA,EAAA4jC,EAAA9jC,OAAmBE,IACtC1C,EAAAsmC,EAAA5jC,GACA87B,EAAAhC,EAAAgC,EAAAx+B,EAAA,IACAy+B,EAAAhC,EAAAgC,EAAAz+B,EAAA,IACA+hC,EAAAvF,EAAAuF,EAAA/hC,EAAA,IACAguD,EAAAvxB,EAAAuxB,EAAAhuD,EAAA,GAGA2G,GAAA,GAAA63B,EACA73B,EAAA,GAAAo7B,EACAn7B,EAAA,GAAA63B,EACA73B,EAAA,GAAAonD,IAYA3G,EAAAmD,SAAA,SAAAlB,EAAAC,EAAAjJ,EAAAC,EAAA55C,EAAAC,GACAD,EAAA,GAAA61B,EAAA8sB,EAAAhJ,GACA35C,EAAA,GAAA61B,EAAA+sB,EAAAhJ,GACA35C,EAAA,GAAA61B,EAAA6sB,EAAAhJ,GACA15C,EAAA,GAAA61B,EAAA8sB,EAAAhJ,GAGA,IAAA0N,MACAC,IAeA7G,GAAAoD,UAAA,SACAnB,EAAAC,EAAAjJ,EAAAC,EAAAnP,EAAAC,EAAAqX,EAAAC,EAAAhiD,EAAAC,GAEA,GAEAlE,GAFAspD,EAAA5E,EAAA4E,aACA/B,EAAA7C,EAAA6C,QAEApsB,EAAAmuB,EAAA1C,EAAAhJ,EAAAlP,EAAAsX,EAAAuF,EAMA,KALAtnD,EAAA,GAAAkmD,EAAAA,EACAlmD,EAAA,GAAAkmD,EAAAA,EACAjmD,EAAA,KAAAimD,EAAAA,GACAjmD,EAAA,KAAAimD,EAAAA,GAEAnqD,EAAA,EAAmBA,EAAAm7B,EAAOn7B,IAAA,CAC1B,GAAAb,GAAAooD,EAAAX,EAAAhJ,EAAAlP,EAAAsX,EAAAuF,EAAAvrD,GACAiE,GAAA,GAAA61B,EAAA36B,EAAA8E,EAAA,IACAC,EAAA,GAAA61B,EAAA56B,EAAA+E,EAAA,IAGA,IADAi3B,EAAAmuB,EAAAzC,EAAAhJ,EAAAlP,EAAAsX,EAAAuF,GACAxrD,EAAA,EAAmBA,EAAAm7B,EAAOn7B,IAAA,CAC1B,GAAAX,GAAAkoD,EAAAV,EAAAhJ,EAAAlP,EAAAsX,EAAAuF,EAAAxrD,GACAiE,GAAA,GAAA61B,EAAAz6B,EAAA4E,EAAA,IACAC,EAAA,GAAA61B,EAAA16B,EAAA6E,EAAA,IAGAD,EAAA,GAAA61B,EAAA8sB,EAAA3iD,EAAA,IACAC,EAAA,GAAA61B,EAAA6sB,EAAA1iD,EAAA,IACAD,EAAA,GAAA61B,EAAAksB,EAAA/hD,EAAA,IACAC,EAAA,GAAA61B,EAAAisB,EAAA9hD,EAAA,IAEAD,EAAA,GAAA61B,EAAA+sB,EAAA5iD,EAAA,IACAC,EAAA,GAAA61B,EAAA8sB,EAAA3iD,EAAA,IACAD,EAAA,GAAA61B,EAAAmsB,EAAAhiD,EAAA,IACAC,EAAA,GAAA61B,EAAAksB,EAAA/hD,EAAA,KAeAygD,EAAAqD,cAAA,SAAApB,EAAAC,EAAAjJ,EAAAC,EAAAnP,EAAAC,EAAA1qC,EAAAC,GACA,GAAA2mD,GAAAnG,EAAAmG,kBACAH,EAAAhG,EAAAgG,YAEAe,EACA1xB,EACAD,EAAA+wB,EAAAjE,EAAAhJ,EAAAlP,GAAA,GAAA,GAEAgd,EACA3xB,EACAD,EAAA+wB,EAAAhE,EAAAhJ,EAAAlP,GAAA,GAAA,GAGAxvC,EAAAurD,EAAA9D,EAAAhJ,EAAAlP,EAAA+c,GACApsD,EAAAqrD,EAAA7D,EAAAhJ,EAAAlP,EAAA+c,EAEAznD,GAAA,GAAA61B,EAAA8sB,EAAAlY,EAAAvvC,GACA8E,EAAA,GAAA61B,EAAA+sB,EAAAlY,EAAAtvC,GACA6E,EAAA,GAAA61B,EAAA6sB,EAAAlY,EAAAvvC,GACA+E,EAAA,GAAA61B,EAAA8sB,EAAAlY,EAAAtvC,IAiBAslD,EAAAsD,QAAA,SACA9oD,EAAAE,EAAAygD,EAAAC,EAAAuG,EAAAC,EAAAC,EAAAviD,EAAAC,GAEA,GAAAynD,GAAA/xB,EAAA31B,IACA2nD,EAAAhyB,EAAA11B,IAEA2nD,EAAAvuC,KAAAmiC,IAAA6G,EAAAC,EAGA,IAAAsF,EAAAT,EAAA,MAAAS,EAAA,KAMA,MAJA5nD,GAAA,GAAA9E,EAAA2gD,EACA77C,EAAA,GAAA5E,EAAA0gD,EACA77C,EAAA,GAAA/E,EAAA2gD,OACA57C,EAAA,GAAA7E,EAAA0gD,EA6BA,IAzBAn2C,EAAA,GAAAw2C,EAAAkG,GAAAxG,EAAA3gD,EACAyK,EAAA,GAAAy2C,EAAAiG,GAAAvG,EAAA1gD,EAEA6rD,EAAA,GAAA9K,EAAAmG,GAAAzG,EAAA3gD,EACA+rD,EAAA,GAAA7K,EAAAkG,GAAAxG,EAAA1gD,EAEAssD,EAAA1nD,EAAA2F,EAAAshD,GACAU,EAAA1nD,EAAA0F,EAAAshD,GAGA5E,GAAA,EACAA,EAAA,IACAA,GAAA8E,GAEA7E,GAAA,EACAA,EAAA,IACAA,GAAA6E,GAGA9E,EAAAC,IAAAC,EACAD,GAAA6E,EAEA9E,EAAAC,GAAAC,IACAF,GAAA8E,GAEA5E,EAAA,CACA,GAAAlmD,GAAAimD,CACAA,GAAAD,EACAA,EAAAhmD,EAKA,IAAA,GAAAwrD,GAAA,EAA2BA,EAAAvF,EAAkBuF,GAAAxuC,KAAAsM,GAAA,EAC7CkiC,EAAAxF,IACA6E,EAAA,GAAA/K,EAAA0L,GAAAhM,EAAA3gD,EACAgsD,EAAA,GAAA9K,EAAAyL,GAAA/L,EAAA1gD,EAEAssD,EAAA1nD,EAAAknD,EAAAlnD,GACA2nD,EAAA1nD,EAAAinD,EAAAjnD,KAKAzH,EAAAD,QAAAmoD,GhDy2aM,SAASloD,EAAQD,EAASM,GiD7kbhC,YAmBA,SAAAivD,GAAAj0C,EAAAC,GACA,MAAAuF,MAAAmiC,IAAA3nC,EAAAC,GAAAmE,EAOA,QAAA8vC,KACA,GAAA1rD,GAAAipD,EAAA,EACAA,GAAA,GAAAA,EAAA,GACAA,EAAA,GAAAjpD,EAGA,QAAA2rD,GAAArF,EAAAC,EAAAjJ,EAAAC,EAAAnP,EAAAC,EAAAqX,EAAAC,EAAA9mD,EAAAE,GAEA,GACAA,EAAAwnD,GAAAxnD,EAAAw+C,GAAAx+C,EAAAsvC,GAAAtvC,EAAA4mD,GACA5mD,EAAAwnD,GAAAxnD,EAAAw+C,GAAAx+C,EAAAsvC,GAAAtvC,EAAA4mD,EAEA,MAAA,EAEA,IAAAiG,GAAAxH,EAAAgE,YAAA7B,EAAAhJ,EAAAlP,EAAAsX,EAAA5mD,EAAAsZ,EACA,IAAA,IAAAuzC,EACA,MAAA,EAMA,KAAA,GADAC,GAAAC,EAFAzmC,EAAA,EACA0mC,KAEArsD,EAAA,EAA2BA,EAAAksD,EAAYlsD,IAAA,CACvC,GAAAsgB,GAAA3H,EAAA3Y,GAGAssD,EAAA,IAAAhsC,GAAA,IAAAA,EAAA,GAAA,EAEAisC,EAAA7H,EAAA6C,QAAAX,EAAAhJ,EAAAlP,EAAAsX,EAAA1lC,EACAisC,GAAAptD,IAGAktD,EAAA,IACAA,EAAA3H,EAAA4E,aAAAzC,EAAAhJ,EAAAlP,EAAAsX,EAAAsD,GACAA,EAAA,GAAAA,EAAA,IAAA8C,EAAA,GACAL,IAEAG,EAAAzH,EAAA6C,QAAAV,EAAAhJ,EAAAlP,EAAAsX,EAAAsD,EAAA,IACA8C,EAAA,IACAD,EAAA1H,EAAA6C,QAAAV,EAAAhJ,EAAAlP,EAAAsX,EAAAsD,EAAA,MAMA5jC,GAHA,GAAA0mC,EAEA/rC,EAAAipC,EAAA,GACA4C,EAAAtF,EAAAyF,GAAAA,EAEAhsC,EAAAipC,EAAA,GACA6C,EAAAD,EAAAG,GAAAA,EAGArG,EAAAmG,EAAAE,GAAAA,EAKAhsC,EAAAipC,EAAA,GACA4C,EAAAtF,EAAAyF,GAAAA,EAGArG,EAAAkG,EAAAG,GAAAA,GAIA,MAAA3mC,GAIA,QAAA6mC,GAAA5F,EAAAC,EAAAjJ,EAAAC,EAAAnP,EAAAC,EAAAxvC,EAAAE,GAEA,GACAA,EAAAwnD,GAAAxnD,EAAAw+C,GAAAx+C,EAAAsvC,GACAtvC,EAAAwnD,GAAAxnD,EAAAw+C,GAAAx+C,EAAAsvC,EAEA,MAAA,EAEA,IAAAud,GAAAxH,EAAAkG,gBAAA/D,EAAAhJ,EAAAlP,EAAAtvC,EAAAsZ,EACA,IAAA,IAAAuzC,EACA,MAAA,EAGA,IAAA5rC,GAAAokC,EAAAmG,kBAAAhE,EAAAhJ,EAAAlP,EACA,IAAAruB,GAAA,GAAAA,GAAA,EAAA,CAGA,IAAA,GAFAqF,GAAA,EACA8mC,EAAA/H,EAAAgG,YAAA7D,EAAAhJ,EAAAlP,EAAAruB,GACAtgB,EAAA,EAA+BA,EAAAksD,EAAYlsD,IAAA,CAE3C,GAAAssD,GAAA,IAAA3zC,EAAA3Y,IAAA,IAAA2Y,EAAA3Y,GAAA,GAAA,EAEAusD,EAAA7H,EAAAgG,YAAA9D,EAAAhJ,EAAAlP,EAAA/1B,EAAA3Y,GACAusD,GAAAptD,IAIAwmB,GADAhN,EAAA3Y,GAAAsgB,EACAmsC,EAAA5F,EAAAyF,GAAAA,EAGA3d,EAAA8d,EAAAH,GAAAA,GAGA,MAAA3mC,GAIA,GAAA2mC,GAAA,IAAA3zC,EAAA,IAAA,IAAAA,EAAA,GAAA,GAAA,EAEA4zC,EAAA7H,EAAAgG,YAAA9D,EAAAhJ,EAAAlP,EAAA/1B,EAAA,GACA,OAAA4zC,GAAAptD,EACA,EAEAwvC,EAAAkY,EAAAyF,GAAAA,EAOA,QAAAI,GACAtP,EAAAC,EAAAxxB,EAAAy6B,EAAAC,EAAAC,EAAArnD,EAAAE,GAGA,GADAA,GAAAg+C,EACAh+C,EAAAwsB,GAAAxsB,GAAAwsB,EACA,MAAA,EAEA,IAAAvrB,GAAAgd,KAAAC,KAAAsO,EAAAA,EAAAxsB,EAAAA,EACAsZ,GAAA,IAAArY,EACAqY,EAAA,GAAArY,CAEA,IAAAurD,GAAAvuC,KAAAmiC,IAAA6G,EAAAC,EACA,IAAAsF,EAAA,KACA,MAAA,EAEA,IAAAA,EAAAT,EAAA,KAAA,CAEA9E,EAAA,EACAC,EAAA6E,CACA,IAAAuB,GAAAnG,EAAA,IACA,OAAArnD,IAAAwZ,EAAA,GAAAykC,GAAAj+C,GAAAwZ,EAAA,GAAAykC,EACAuP,EAEA,EAIA,GAAAnG,EAAA,CACA,GAAAlmD,GAAAgmD,CACAA,GAAAsG,EAAArG,GACAA,EAAAqG,EAAAtsD,OAGAgmD,GAAAsG,EAAAtG,GACAC,EAAAqG,EAAArG,EAEAD,GAAAC,IACAA,GAAA6E,EAIA,KAAA,GADAzlC,GAAA,EACA3lB,EAAA,EAAuBA,EAAA,EAAOA,IAAA,CAC9B,GAAAusD,GAAA5zC,EAAA3Y,EACA,IAAAusD,EAAAnP,EAAAj+C,EAAA,CACA,GAAA2sD,GAAAxuC,KAAAE,MAAAne,EAAAktD,GACAI,EAAAnG,EAAA,IACAsF,GAAA,IACAA,EAAAV,EAAAU,IAGAA,GAAAxF,GAAAwF,GAAAvF,GACAuF,EAAAV,GAAA9E,GAAAwF,EAAAV,GAAA7E,KAEAuF,EAAAxuC,KAAAsM,GAAA,GAAAkiC,EAAA,IAAAxuC,KAAAsM,KACA+iC,GAAAA,GAEAhnC,GAAAgnC,IAIA,MAAAhnC,GAGA,QAAAknC,GAAAx9C,EAAAk9B,EAAAugB,EAAA3tD,EAAAE,GAOA,IAAA,GANAsmB,GAAA,EACAiiC,EAAA,EACAC,EAAA,EACAjB,EAAA,EACAC,EAAA,EAEA7mD,EAAA,EAAuBA,EAAAqP,EAAAvP,QAAiB,CACxC,GAAAmgD,GAAA5wC,EAAArP,IAyBA,QAvBAigD,IAAAyB,EAAAG,GAAA7hD,EAAA,IAEA8sD,IACAnnC,GAAAonC,EAAAnF,EAAAC,EAAAjB,EAAAC,EAAA1nD,EAAAE,KAQA,GAAAW,IAKA4nD,EAAAv4C,EAAArP,GACA6nD,EAAAx4C,EAAArP,EAAA,GAEA4mD,EAAAgB,EACAf,EAAAgB,GAGA5H,GACA,IAAAyB,GAAAG,EAGA+E,EAAAv3C,EAAArP,KACA6mD,EAAAx3C,EAAArP,KACA4nD,EAAAhB,EACAiB,EAAAhB,CACA,MACA,KAAAnF,GAAA7zB,EACA,GAAAi/B,GACA,GAAA3I,EAAAyD,EAAAC,EAAAx4C,EAAArP,GAAAqP,EAAArP,EAAA,GAAAusC,EAAAptC,EAAAE,GACA,OAAA,MAKAsmB,IAAAonC,EAAAnF,EAAAC,EAAAx4C,EAAArP,GAAAqP,EAAArP,EAAA,GAAAb,EAAAE,IAAA,CAEAuoD,GAAAv4C,EAAArP,KACA6nD,EAAAx4C,EAAArP,IACA,MACA,KAAA0hD,GAAAI,EACA,GAAAgL,GACA,GAAAE,EAAA7I,cAAAyD,EAAAC,EACAx4C,EAAArP,KAAAqP,EAAArP,KAAAqP,EAAArP,KAAAqP,EAAArP,KAAAqP,EAAArP,GAAAqP,EAAArP,EAAA,GACAusC,EAAAptC,EAAAE,GAEA,OAAA,MAIAsmB,IAAAsmC,EACArE,EAAAC,EACAx4C,EAAArP,KAAAqP,EAAArP,KAAAqP,EAAArP,KAAAqP,EAAArP,KAAAqP,EAAArP,GAAAqP,EAAArP,EAAA,GACAb,EAAAE,IACA,CAEAuoD,GAAAv4C,EAAArP,KACA6nD,EAAAx4C,EAAArP,IACA,MACA,KAAA0hD,GAAAK,EACA,GAAA+K,GACA,GAAAG,EAAA9I,cAAAyD,EAAAC,EACAx4C,EAAArP,KAAAqP,EAAArP,KAAAqP,EAAArP,GAAAqP,EAAArP,EAAA,GACAusC,EAAAptC,EAAAE,GAEA,OAAA,MAIAsmB,IAAA6mC,EACA5E,EAAAC,EACAx4C,EAAArP,KAAAqP,EAAArP,KAAAqP,EAAArP,GAAAqP,EAAArP,EAAA,GACAb,EAAAE,IACA,CAEAuoD,GAAAv4C,EAAArP,KACA6nD,EAAAx4C,EAAArP,IACA,MACA,KAAA0hD,GAAAM,EAEA,GAAA5E,GAAA/tC,EAAArP,KACAq9C,EAAAhuC,EAAArP,KACA8/C,EAAAzwC,EAAArP,KACA+/C,EAAA1wC,EAAArP,KACA2gD,EAAAtxC,EAAArP,KACA8gD,EAAAzxC,EAAArP,KAGAwmD,GADAn3C,EAAArP,KACA,EAAAqP,EAAArP,MACA49C,EAAAtgC,KAAA8B,IAAAuhC,GAAAb,EAAA1C,EACAS,EAAAvgC,KAAA4B,IAAAyhC,GAAAZ,EAAA1C,CAEAr9C,GAAA,EACA2lB,GAAAonC,EAAAnF,EAAAC,EAAAjK,EAAAC,EAAA1+C,EAAAE,IAIAunD,EAAAhJ,EACAiJ,EAAAhJ,EAGA,IAAApnC,IAAAtX,EAAAi+C,GAAA2C,EAAAD,EAAA1C,CACA,IAAA0P,GACA,GAAAzG,EAAAlC,cACA/G,EAAAC,EAAA0C,EAAAY,EAAAA,EAAAG,EAAA0F,EACAja,EAAA91B,EAAApX,GAEA,OAAA,MAIAsmB,IAAA+mC,EACAtP,EAAAC,EAAA0C,EAAAY,EAAAA,EAAAG,EAAA0F,EACA/vC,EAAApX,EAGAuoD,GAAAtqC,KAAA8B,IAAAuhC,EAAAG,GAAAhB,EAAA1C,EACAyK,EAAAvqC,KAAA4B,IAAAyhC,EAAAG,GAAAf,EAAA1C,CACA,MACA,KAAAqE,GAAAn0B,EACAq5B,EAAAgB,EAAAv4C,EAAArP,KACA6mD,EAAAgB,EAAAx4C,EAAArP,IACA,IAAAW,GAAA0O,EAAArP,KACAiB,EAAAoO,EAAArP,KACA49C,EAAAgJ,EAAAjmD,EACAk9C,EAAAgJ,EAAA5lD,CACA,IAAA6rD,GACA,GAAA3I,EAAAyC,EAAAC,EAAAjJ,EAAAiJ,EAAAta,EAAAptC,EAAAE,IACA8kD,EAAAvG,EAAAiJ,EAAAjJ,EAAAC,EAAAtR,EAAAptC,EAAAE,IACA8kD,EAAAvG,EAAAC,EAAA+I,EAAA/I,EAAAtR,EAAAptC,EAAAE,IACA8kD,EAAAyC,EAAA/I,EAAA+I,EAAAC,EAAAta,EAAAptC,EAAAE,GAEA,OAAA,MAKAsmB,IAAAonC,EAAAnP,EAAAiJ,EAAAjJ,EAAAC,EAAA1+C,EAAAE,GACAsmB,GAAAonC,EAAAnG,EAAA/I,EAAA+I,EAAAC,EAAA1nD,EAAAE,EAEA,MACA,KAAAqiD,GAAAO,EACA,GAAA6K,GACA,GAAA3I,EACAyD,EAAAC,EAAAjB,EAAAC,EAAAta,EAAAptC,EAAAE,GAEA,OAAA,MAKAsmB,IAAAonC,EAAAnF,EAAAC,EAAAjB,EAAAC,EAAA1nD,EAAAE,EAOAuoD,GAAAhB,EACAiB,EAAAhB,GAOA,MAHAiG,IAAAf,EAAAlE,EAAAhB,KACAlhC,GAAAonC,EAAAnF,EAAAC,EAAAjB,EAAAC,EAAA1nD,EAAAE,IAAA,GAEA,IAAAsmB,EAjYA,GAAA+7B,GAAA5kD,EAAA,IAAA4kD,IACAwL,EAAApwD,EAAA,IACAkwD,EAAAlwD,EAAA,IACAmwD,EAAAnwD,EAAA,IACAupD,EAAAvpD,EAAA,IACA8vD,EAAA9vD,EAAA,IAAA8vD,gBACAlI,EAAA5nD,EAAA,IAEAiwD,EAAAjwD,EAAA,IAEAqnD,EAAA+I,EAAA/I,cAEAiH,EAAA,EAAA9tC,KAAAsM,GAEA1N,EAAA,KAOAvD,aACA4wC,SA8WA9sD,GAAAD,SACAsX,QAAA,SAAAipC,EAAA59C,EAAAE,GACA,MAAAwtD,GAAA9P,EAAA,GAAA,EAAA59C,EAAAE,IAGA8kD,cAAA,SAAApH,EAAAxQ,EAAAptC,EAAAE,GACA,MAAAwtD,GAAA9P,EAAAxQ,GAAA,EAAAptC,EAAAE,MjDslbM,SAAS5C,EAAQD,GkDl+bvBC,EAAAD,SAYA2nD,cAAA,SAAAyC,EAAAC,EAAAjJ,EAAAC,EAAAtR,EAAAptC,EAAAE,GACA,GAAA,IAAAktC,EACA,OAAA,CAEA,IAAA4gB,GAAA5gB,EACA6gB,EAAA,EACAC,EAAAzG,CAEA,IACAvnD,EAAAwnD,EAAAsG,GAAA9tD,EAAAw+C,EAAAsP,GACA9tD,EAAAwnD,EAAAsG,GAAA9tD,EAAAw+C,EAAAsP,GACAhuD,EAAAynD,EAAAuG,GAAAhuD,EAAAy+C,EAAAuP,GACAhuD,EAAAynD,EAAAuG,GAAAhuD,EAAAy+C,EAAAuP,EAEA,OAAA,CAGA,IAAAvG,IAAAhJ,EAKA,MAAAtgC,MAAAmiC,IAAAtgD,EAAAynD,IAAAuG,EAAA,CAJAC,IAAAvG,EAAAhJ,IAAA+I,EAAAhJ,GACAyP,GAAAzG,EAAA/I,EAAAD,EAAAiJ,IAAAD,EAAAhJ,EAKA,IAAAt9C,GAAA8sD,EAAAjuD,EAAAE,EAAAguD,EACAC,EAAAhtD,EAAAA,GAAA8sD,EAAAA,EAAA,EACA,OAAAE,IAAAH,EAAA,EAAAA,EAAA,KlD4+bM,SAAS1wD,EAAQD,EAASM,GmDjhchC,GAAA4nD,GAAA5nD,EAAA,GAEAL,GAAAD,SAgBA2nD,cAAA,SAAAyC,EAAAC,EAAAjJ,EAAAC,EAAAnP,EAAAC,EAAAqX,EAAAC,EAAA1Z,EAAAptC,EAAAE,GACA,GAAA,IAAAktC,EACA,OAAA,CAEA,IAAA4gB,GAAA5gB,CAEA,IACAltC,EAAAwnD,EAAAsG,GAAA9tD,EAAAw+C,EAAAsP,GAAA9tD,EAAAsvC,EAAAwe,GAAA9tD,EAAA4mD,EAAAkH,GACA9tD,EAAAwnD,EAAAsG,GAAA9tD,EAAAw+C,EAAAsP,GAAA9tD,EAAAsvC,EAAAwe,GAAA9tD,EAAA4mD,EAAAkH,GACAhuD,EAAAynD,EAAAuG,GAAAhuD,EAAAy+C,EAAAuP,GAAAhuD,EAAAuvC,EAAAye,GAAAhuD,EAAA6mD,EAAAmH,GACAhuD,EAAAynD,EAAAuG,GAAAhuD,EAAAy+C,EAAAuP,GAAAhuD,EAAAuvC,EAAAye,GAAAhuD,EAAA6mD,EAAAmH,EAEA,OAAA,CAEA,IAAAltC,GAAAykC,EAAAqF,kBACAnD,EAAAC,EAAAjJ,EAAAC,EAAAnP,EAAAC,EAAAqX,EAAAC,EACA9mD,EAAAE,EAAA,KAEA,OAAA4gB,IAAAktC,EAAA,KnD4hcM,SAAS1wD,EAAQD,EAASM,GoDhkchC,GAAA4nD,GAAA5nD,EAAA,GAEAL,GAAAD,SAcA2nD,cAAA,SAAAyC,EAAAC,EAAAjJ,EAAAC,EAAAnP,EAAAC,EAAApC,EAAAptC,EAAAE,GACA,GAAA,IAAAktC,EACA,OAAA,CAEA,IAAA4gB,GAAA5gB,CAEA,IACAltC,EAAAwnD,EAAAsG,GAAA9tD,EAAAw+C,EAAAsP,GAAA9tD,EAAAsvC,EAAAwe,GACA9tD,EAAAwnD,EAAAsG,GAAA9tD,EAAAw+C,EAAAsP,GAAA9tD,EAAAsvC,EAAAwe,GACAhuD,EAAAynD,EAAAuG,GAAAhuD,EAAAy+C,EAAAuP,GAAAhuD,EAAAuvC,EAAAye,GACAhuD,EAAAynD,EAAAuG,GAAAhuD,EAAAy+C,EAAAuP,GAAAhuD,EAAAuvC,EAAAye,EAEA,OAAA,CAEA,IAAAltC,GAAAykC,EAAAsG,sBACApE,EAAAC,EAAAjJ,EAAAC,EAAAnP,EAAAC,EACAxvC,EAAAE,EAAA,KAEA,OAAA4gB,IAAAktC,EAAA,KpD2kcM,SAAS1wD,EAAQD,EAASM,GqD7mchC,GAAA8vD,GAAA9vD,EAAA,IAAA8vD,gBACAxB,EAAA,EAAA9tC,KAAAsM,EAEAntB,GAAAD,SAcA2nD,cAAA,SACA/G,EAAAC,EAAAxxB,EAAAy6B,EAAAC,EAAAC,EACAja,EAAAptC,EAAAE,GAGA,GAAA,IAAAktC,EACA,OAAA,CAEA,IAAA4gB,GAAA5gB,CAEAptC,IAAAi+C,EACA/9C,GAAAg+C,CACA,IAAAp9B,GAAA3C,KAAAC,KAAApe,EAAAA,EAAAE,EAAAA,EAEA,IAAA4gB,EAAAktC,EAAAthC,GAAA5L,EAAAktC,EAAAthC,EACA,OAAA,CAEA,IAAAvO,KAAAmiC,IAAA6G,EAAAC,GAAA6E,EAAA,KAEA,OAAA,CAEA,IAAA5E,EAAA,CACA,GAAAlmD,GAAAgmD,CACAA,GAAAsG,EAAArG,GACAA,EAAAqG,EAAAtsD,OAEAgmD,GAAAsG,EAAAtG,GACAC,EAAAqG,EAAArG,EAEAD,GAAAC,IACAA,GAAA6E,EAGA,IAAAU,GAAAxuC,KAAAE,MAAAne,EAAAF,EAIA,OAHA2sD,GAAA,IACAA,GAAAV,GAEAU,GAAAxF,GAAAwF,GAAAvF,GACAuF,EAAAV,GAAA9E,GAAAwF,EAAAV,GAAA7E,KrDwncM,SAAS9pD,EAAQD,GsD/qcvB,GAAA4uD,GAAA,EAAA9tC,KAAAsM,EACAntB,GAAAD,SACAowD,gBAAA,SAAAd,GAKA,MAJAA,IAAAV,EACAU,EAAA,IACAA,GAAAV,GAEAU,KtD0rcM,SAASrvD,EAAQD,GuDlscvBC,EAAAD,QAAA,SAAAoqD,EAAAC,EAAAjJ,EAAAC,EAAA1+C,EAAAE,GACA,GAAAA,EAAAwnD,GAAAxnD,EAAAw+C,GAAAx+C,EAAAwnD,GAAAxnD,EAAAw+C,EACA,MAAA,EAGA,IAAAA,IAAAgJ,EACA,MAAA,EAEA,IAAA8F,GAAA9O,EAAAgJ,EAAA,KACAvmC,GAAAjhB,EAAAwnD,IAAAhJ,EAAAgJ,EAGA,KAAAvmC,GAAA,IAAAA,IACAqsC,EAAA9O,EAAAgJ,EAAA,OAGA,IAAA0F,GAAAjsC,GAAAs9B,EAAAgJ,GAAAA,CAEA,OAAA2F,GAAAptD,EAAAwtD,EAAA,IvD2scM,SAASlwD,EAAQD,EAASM,GwDrtchC,QAAAwlD,GAAAzhC,EAAAzjB,GACA,GACA6iD,GACAsN,EACAvtD,EACAwB,EACAsnB,EACAxrB,EANA+R,EAAAwR,EAAAxR,KAQAwyC,EAAAH,EAAAG,EACAC,EAAAJ,EAAAI,EACAj0B,EAAA6zB,EAAA7zB,EACAN,EAAAm0B,EAAAn0B,EACAy0B,EAAAN,EAAAM,EACAD,EAAAL,EAAAK,CAEA,KAAA/hD,EAAA,EAAAwB,EAAA,EAA0BxB,EAAAqP,EAAAvP,QAAiB,CAK3C,OAJAmgD,EAAA5wC,EAAArP,KACAwB,EAAAxB,EACAutD,EAAA,EAEAtN,GACA,IAAA4B,GACA0L,EAAA,CACA,MACA,KAAA1/B,GACA0/B,EAAA,CACA,MACA,KAAAzL,GACAyL,EAAA,CACA,MACA,KAAAxL,GACAwL,EAAA,CACA,MACA,KAAAvL,GACA,GAAA7iD,GAAA/B,EAAA,GACAiC,EAAAjC,EAAA,GACAggB,EAAAojC,EAAApjD,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAigB,EAAAmjC,EAAApjD,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACA0uD,EAAA0B,GAAApwD,EAAA,GAAAigB,EAAAjgB,EAAA,GAAAggB,EAEA/N,GAAArP,MAAAb,EAEAkQ,EAAArP,MAAAX,EAGAgQ,EAAArP,MAAAod,EACA/N,EAAArP,MAAAqd,EAGAhO,EAAArP,MAAA8rD,EAEAz8C,EAAArP,MAAA8rD,EAEA9rD,GAAA,EACAwB,EAAAxB,CACA,MACA,KAAAutB,GAEAjwB,EAAA,GAAA+R,EAAArP,KACA1C,EAAA,GAAA+R,EAAArP,KACA65B,EAAAv8B,EAAAA,EAAAF,GACAiS,EAAA7N,KAAAlE,EAAA,GACA+R,EAAA7N,KAAAlE,EAAA,GAEAA,EAAA,IAAA+R,EAAArP,KACA1C,EAAA,IAAA+R,EAAArP,KACA65B,EAAAv8B,EAAAA,EAAAF,GACAiS,EAAA7N,KAAAlE,EAAA,GACA+R,EAAA7N,KAAAlE,EAAA,GAGA,IAAAwrB,EAAA,EAAuBA,EAAAykC,EAAYzkC,IAAA,CACnC,GAAAxrB,GAAAsmC,EAAA9a,EACAxrB,GAAA,GAAA+R,EAAArP,KACA1C,EAAA,GAAA+R,EAAArP,KAEA65B,EAAAv8B,EAAAA,EAAAF,GAEAiS,EAAA7N,KAAAlE,EAAA,GACA+R,EAAA7N,KAAAlE,EAAA,KAvFA,GAAAokD,GAAA5kD,EAAA,IAAA4kD,IACA9nB,EAAA98B,EAAA,IACA+8B,EAAAD,EAAA1e,eAEA0oB,aACA4c,EAAAljC,KAAAC,KACAiwC,EAAAlwC,KAAAE,KAsFA/gB,GAAAD,QAAA8lD,GxDqucM,SAAS7lD,EAAQD,GyD9zcvB,GAAAo+C,GAAA,SAAAzM,GAEAvxC,KAAAuxC,WAAAA,MAGAyM,GAAAp8C,WAEA+L,YAAAqwC,EAEA9J,aAAA,SAAA1U,EAAA7W,GACA3oB,KAAAuxC,WAAA9tC,MAEA+7B,OAAAA,EAEA7W,MAAAA,MAKA9oB,EAAAD,QAAAo+C,GzD00cM,SAASn+C,EAAQD,EAASM,G0Dv1chC,GAAAs0C,GAAAt0C,EAAA,IACA8K,EAAA9K,EAAA,GACA21C,EAAA31C,EAAA,IAQAw9C,EAAA,SAAA78C,GACA2zC,EAAAj0C,KAAAP,KAAAa,GAGA68C,GAAA97C,WAEA+L,YAAA+vC,EAEAh4C,KAAA,OAEAunC,MAAA,SAAAvyB,EAAAqyB,GACA,GAAA3nC,GAAApF,KAAAoF,MACA7C,EAAA6C,EAAA7C,GAAA,EACAE,EAAA2C,EAAA3C,GAAA,EAEAiwC,EAAAttC,EAAAstC,IAQA,IALA,MAAAA,IAAAA,GAAA,IAGAttC,EAAA0H,KAAA4N,EAAA1a,KAAA+sC,GAEA2F,EAAA,CAEA1yC,KAAAqgB,aAAA3F,EAEA,IAAAq4B,GACAC,EAAA5tC,EAAA4tC,UACAgD,EAAA5wC,EAAA6wC,UAAA7wC,EAAA4wC,IACA,IAAA5wC,EAAA6tC,kBAAA,CACA,GAAAn1B,GAAA+3B,EAAAzxC,gBACAsuC,EAAAsD,EAAA5wC,EAAA4tC,UAAA,MAIA,QADAD,EAAA,SACA3tC,EAAA6tC,mBACA,IAAA,SACAxwC,GAAAqb,EAAAzZ,OAAA,EAAAyZ,EAAAs4B,WAAA,CACA,MACA,KAAA,SACA3zC,GAAAqb,EAAAzZ,OAAAyZ,EAAAs4B,WAAA,CACA,MACA,SACA3zC,GAAAqb,EAAAs4B,WAAA,OAIArD,GAAA3tC,EAAA2tC,YAIAr4B,GAAAs7B,KAAAA,GAAA,kBACAt7B,EAAAs4B,UAAAA,GAAA,OAEAt4B,EAAAs4B,YAAAA,IACAt4B,EAAAs4B,UAAA,QAGAt4B,EAAAq4B,aAAAA,GAAA,aAEAr4B,EAAAq4B,eAAAA,IACAr4B,EAAAq4B,aAAA,aAMA,KAAA,GAHAqD,GAAAP,EAAAiB,YAAA,IAAAp8B,EAAAs7B,MAAAjyC,MAEA0yC,EAAA/D,EAAAruB,MAAA,MACAjhB,EAAA,EAA+BA,EAAAqzC,EAAAvzC,OAAsBE,IAErDgC,EAAAwqC,aAAAl1B,EAAAg8B,WAAAD,EAAArzC,GAAAb,EAAAE,GACA2C,EAAA0uC,WAAAp5B,EAAAi8B,SAAAF,EAAArzC,GAAAb,EAAAE,GACAA,GAAA2zC,CAGAp2C,MAAAsgB,iBAAA5F,KAIAtW,gBAAA,WACA,GAAAgB,GAAApF,KAAAoF,KACA,KAAApF,KAAAo1C,MAAA,CACA,GAAAnC,GAAA7tC,EAAA6tC,kBACAn1B,EAAA+3B,EAAAzxC,gBACAgB,EAAAstC,KAAA,GAAAttC,EAAA6wC,UAAA7wC,EAAA4wC,KAAA5wC,EAAA4tC,UACAC,EAAA,MAAA7tC,EAAA2tC,aAEA,QAAAE,GACA,IAAA,SACAn1B,EAAArb,GAAAqb,EAAAzZ,OAAA,CACA,MACA,KAAA,SACAyZ,EAAArb,GAAAqb,EAAAzZ,OAKA,GAFAyZ,EAAAvb,GAAA6C,EAAA7C,GAAA,EACAub,EAAArb,GAAA2C,EAAA3C,GAAA,EACA2C,EAAAwqC,YAAA,CACA,GAAA7mB,GAAA3jB,EAAAuqC,SACA7xB,GAAAvb,GAAAwmB,EAAA,EACAjL,EAAArb,GAAAsmB,EAAA,EACAjL,EAAA/Z,OAAAglB,EACAjL,EAAAzZ,QAAA0kB,EAEA/oB,KAAAo1C,MAAAt3B,EAGA,MAAA9d,MAAAo1C,QAIApqC,EAAAgH,SAAA0rC,EAAAlJ,GAEA30C,EAAAD,QAAA89C,G1Dy2cM,SAAS79C,EAAQD,EAASM,G2D/+chC,YAQAL,GAAAD,QAAAM,EAAA,IAAAwR,QAEAhM,KAAA,SAEA+C,OACA+3C,GAAA,EACAC,GAAA,EACAxxB,EAAA,GAIAmZ,UAAA,SAAA1tB,EAAAjS,EAAAw+C,GAGAA,GACAvsC,EAAAouC,OAAArgD,EAAA+3C,GAAA/3C,EAAAwmB,EAAAxmB,EAAAg4C,IAIA/lC,EAAA+uC,IAAAhhD,EAAA+3C,GAAA/3C,EAAAg4C,GAAAh4C,EAAAwmB,EAAA,EAAA,EAAAvO,KAAAsM,IAAA,O3Dy/cM,SAASntB,EAAQD,EAASM,G4D7gdhC,GAAAmL,GAAAnL,EAAA,GACAo/C,EAAAp/C,EAAA,IAEA2wD,IACA,aAAA,IACA,cAAA,SACA,gBAAA,IACA,gBAAA,GAGAhxD,GAAAD,QAAA0/C,EAAA5tC,QAEAhM,KAAA,SAEA+C,OAEA+3C,GAAA,EAEAC,GAAA,EAEAqQ,GAAA,EAEA7hC,EAAA,EAEAy6B,WAAA,EAEAC,SAAA,EAAAjpC,KAAAsM,GAEA+jC,WAAA,GAGA9jB,MAAA5hC,EAAAmE,QAAAG,IAAAtE,EAAAmE,QAAAtF,SAAA,GAcA,WACA,GAEA8mD,GAFA90C,EAAAlc,KAAA6c,YACAzX,EAAApF,KAAAoF,KAGA,IAAA8W,EACA,IAAA,GAAA9Y,GAAA,EAAmCA,EAAA8Y,EAAAhZ,OAAsBE,IAAA,CACzD,GAAAqF,GAAAyT,EAAA9Y,IAAA8Y,EAAA9Y,GAAAqF,KACA,IAAAA,GAAAA,EAAAihD,aAAAjhD,EAAAkhD,SAAA,CACA,IAAA,GAAA/kD,GAAA,EAA2CA,EAAAisD,EAAA3tD,OAAuB0B,IAClEisD,EAAAjsD,GAAA,GAAAQ,EAAAyrD,EAAAjsD,GAAA,IACAQ,EAAAyrD,EAAAjsD,GAAA,IAAAisD,EAAAjsD,GAAA,EAEAosD,IAAA,CACA,QAOA,GAFA1R,EAAA19C,UAAAqrC,MAAAt5B,MAAA3T,KAAA0T,WAEAs9C,EACA,IAAA,GAAApsD,GAAA,EAAmCA,EAAAisD,EAAA3tD,OAAuB0B,IAC1DQ,EAAAyrD,EAAAjsD,GAAA,IAAAisD,EAAAjsD,GAAA,IAIA06C,EAAA19C,UAAAqrC,MAEA7E,UAAA,SAAA1tB,EAAAjS,GAEA,GAAAlG,GAAAkG,EAAA+3C,GACA/9C,EAAAgG,EAAAg4C,GACAqQ,EAAApwC,KAAApZ,IAAAmB,EAAAqoD,IAAA,EAAA,GACA7hC,EAAAvO,KAAApZ,IAAAmB,EAAAwmB,EAAA,GACAy6B,EAAAjhD,EAAAihD,WACAC,EAAAlhD,EAAAkhD,SACAoH,EAAAtoD,EAAAsoD,UAEAE,EAAAvwC,KAAA8B,IAAAknC,GACAwH,EAAAxwC,KAAA4B,IAAAonC,EAEAhvC,GAAAouC,OAAAmI,EAAAH,EAAAvuD,EAAA2uD,EAAAJ,EAAAruD,GAEAiY,EAAAquC,OAAAkI,EAAAhiC,EAAA1sB,EAAA2uD,EAAAjiC,EAAAxsB,GAEAiY,EAAA+uC,IAAAlnD,EAAAE,EAAAwsB,EAAAy6B,EAAAC,GAAAoH,GAEAr2C,EAAAquC,OACAroC,KAAA8B,IAAAmnC,GAAAmH,EAAAvuD,EACAme,KAAA4B,IAAAqnC,GAAAmH,EAAAruD,GAGA,IAAAquD,GACAp2C,EAAA+uC,IAAAlnD,EAAAE,EAAAquD,EAAAnH,EAAAD,EAAAqH,GAGAr2C,EAAAqvC,gB5D8hdM,SAASlqD,EAAQD,EAASM,G6DrodhCL,EAAAD,QAAAM,EAAA,IAAAwR,QAEAhM,KAAA,OAEA+C,OACA+3C,GAAA,EACAC,GAAA,EACAxxB,EAAA,EACA6hC,GAAA,GAGA1oB,UAAA,SAAA1tB,EAAAjS,GACA,GAAAlG,GAAAkG,EAAA+3C,GACA/9C,EAAAgG,EAAAg4C,GACA+N,EAAA,EAAA9tC,KAAAsM,EACAtS,GAAAouC,OAAAvmD,EAAAkG,EAAAwmB,EAAAxsB,GACAiY,EAAA+uC,IAAAlnD,EAAAE,EAAAgG,EAAAwmB,EAAA,EAAAu/B,GAAA,GACA9zC,EAAAouC,OAAAvmD,EAAAkG,EAAAqoD,GAAAruD,GACAiY,EAAA+uC,IAAAlnD,EAAAE,EAAAgG,EAAAqoD,GAAA,EAAAtC,GAAA,O7DqpdM,SAAS3uD,EAAQD,EAASM,G8DvqdhC,GAAAixD,GAAAjxD,EAAA,GAEAL,GAAAD,QAAAM,EAAA,IAAAwR,QAEAhM,KAAA,UAEA+C,OACAu+B,OAAA,KAEAoqB,QAAA,EAEAC,iBAAA,MAGAjpB,UAAA,SAAA1tB,EAAAjS,GACA0oD,EAAA/oB,UAAA1tB,EAAAjS,GAAA,O9DsrdM,SAAS5I,EAAQD,EAASM,G+DzsdhC,GAAAoxD,GAAApxD,EAAA,IACAqxD,EAAArxD,EAAA,GAEAL,GAAAD,SACAwoC,UAAA,SAAA1tB,EAAAjS,EAAAshD,GACA,GAAA/iB,GAAAv+B,EAAAu+B,OACAoqB,EAAA3oD,EAAA2oD,MACA,IAAApqB,GAAAA,EAAA9jC,QAAA,EAAA,CACA,GAAAkuD,GAAA,WAAAA,EAAA,CACA,GAAAI,GAAAD,EACAvqB,EAAAoqB,EAAArH,EAAAthD,EAAA4oD,iBAGA32C,GAAAouC,OAAA9hB,EAAA,GAAA,GAAAA,EAAA,GAAA,GAEA,KAAA,GADAp2B,GAAAo2B,EAAA9jC,OACAE,EAAA,EAAmCA,GAAA2mD,EAAAn5C,EAAAA,EAAA,GAAiCxN,IAAA,CACpE,GAAAquD,GAAAD,EAAA,EAAApuD,GACAsuD,EAAAF,EAAA,EAAApuD,EAAA,GACA1C,EAAAsmC,GAAA5jC,EAAA,GAAAwN,EACA8J,GAAAyuC,cACAsI,EAAA,GAAAA,EAAA,GAAAC,EAAA,GAAAA,EAAA,GAAAhxD,EAAA,GAAAA,EAAA,SAIA,CACA,WAAA0wD,IACApqB,EAAAsqB,EAAAtqB,EAAA+iB,IAGArvC,EAAAouC,OAAA9hB,EAAA,GAAA,GAAAA,EAAA,GAAA,GACA,KAAA,GAAA5jC,GAAA,EAAAyX,EAAAmsB,EAAA9jC,OAAsDE,EAAAyX,EAAOzX,IAC7DsX,EAAAquC,OAAA/hB,EAAA5jC,GAAA,GAAA4jC,EAAA5jC,GAAA,IAIA2mD,GAAArvC,EAAAqvC,gB/DqtdM,SAASlqD,EAAQD,EAASM,GgE7udhC,QAAAyxD,GAAAlsC,EAAAC,EAAAgB,EAAAC,EAAAjD,EAAAkD,EAAAC,GACA,GAAAE,GAAA,IAAAL,EAAAjB,GACA5C,EAAA,IAAA8D,EAAAjB,EACA,QAAA,GAAAA,EAAAgB,GAAAK,EAAAlE,GAAAgE,OACAnB,EAAAgB,GAAA,EAAAK,EAAAlE,GAAA+D,EACAG,EAAArD,EAAAgC,EAVA,GAAAsX,GAAA98B,EAAA,GAmBAL,GAAAD,QAAA,SAAAonC,EAAA4qB,GAKA,IAAA,GAJAhhD,GAAAo2B,EAAA9jC,OACA+jB,KAEA3D,EAAA,EACAlgB,EAAA,EAAuBA,EAAAwN,EAASxN,IAChCkgB,GAAA0Z,EAAA1Z,SAAA0jB,EAAA5jC,EAAA,GAAA4jC,EAAA5jC,GAGA,IAAAyuD,GAAAvuC,EAAA,CACAuuC,GAAAA,EAAAjhD,EAAAA,EAAAihD,CACA,KAAA,GAAAzuD,GAAA,EAAuBA,EAAAyuD,EAAUzuD,IAAA,CACjC,GAKAqiB,GAEAiB,EACAC,EARA1gB,EAAA7C,GAAAyuD,EAAA,IAAAD,EAAAhhD,EAAAA,EAAA,GACAoM,EAAA0D,KAAA0G,MAAAnhB,GAEA8iB,EAAA9iB,EAAA+W,EAGA0I,EAAAshB,EAAAhqB,EAAApM,EAGAghD,IAMAnsC,EAAAuhB,GAAAhqB,EAAA,EAAApM,GAAAA,GACA8V,EAAAsgB,GAAAhqB,EAAA,GAAApM,GACA+V,EAAAqgB,GAAAhqB,EAAA,GAAApM,KAPA6U,EAAAuhB,EAAA,IAAAhqB,EAAAA,EAAAA,EAAA,GACA0J,EAAAsgB,EAAAhqB,EAAApM,EAAA,EAAAA,EAAA,EAAAoM,EAAA,GACA2J,EAAAqgB,EAAAhqB,EAAApM,EAAA,EAAAA,EAAA,EAAAoM,EAAA,GAQA,IAAA80C,GAAA/oC,EAAAA,EACAgpC,EAAAhpC,EAAA+oC,CAEA7qC,GAAAxjB,MACAkuD,EAAAlsC,EAAA,GAAAC,EAAA,GAAAgB,EAAA,GAAAC,EAAA,GAAAoC,EAAA+oC,EAAAC,GACAJ,EAAAlsC,EAAA,GAAAC,EAAA,GAAAgB,EAAA,GAAAC,EAAA,GAAAoC,EAAA+oC,EAAAC,KAGA,MAAA9qC,KhEmwdM,SAASpnB,EAAQD,EAASM,GiE7zdhC,GAAA88B,GAAA98B,EAAA,IACA8xD,EAAAh1B,EAAA31B,IACA4qD,EAAAj1B,EAAA11B,IACA4qD,EAAAl1B,EAAA72B,MACAgsD,EAAAn1B,EAAA1Z,SACA8uC,EAAAp1B,EAAAh7B,GAaAnC,GAAAD,QAAA,SAAAonC,EAAAoqB,EAAAQ,EAAAS,GACA,GAKAC,GACAC,EAEAlrD,EAAAC,EARAkrD,KAEA3wC,KACAgB,KACA9B,IAKA,IAAAsxC,EAAA,CACAhrD,GAAAkmD,EAAAA,EAAAA,EAAAA,GACAjmD,KAAAimD,EAAAA,KAAAA,EAAAA,GACA,KAAA,GAAAnqD,GAAA,EAAAwN,EAAAo2B,EAAA9jC,OAAgDE,EAAAwN,EAASxN,IACzD4uD,EAAA3qD,EAAAA,EAAA2/B,EAAA5jC,IACA6uD,EAAA3qD,EAAAA,EAAA0/B,EAAA5jC,GAGA4uD,GAAA3qD,EAAAA,EAAAgrD,EAAA,IACAJ,EAAA3qD,EAAAA,EAAA+qD,EAAA,IAGA,IAAA,GAAAjvD,GAAA,EAAAwN,EAAAo2B,EAAA9jC,OAA4CE,EAAAwN,EAASxN,IAAA,CACrD,GAAAqvD,GAAAzrB,EAAA5jC,EAEA,IAAAwuD,EACAU,EAAAtrB,EAAA5jC,EAAAA,EAAA,EAAAwN,EAAA,GACA2hD,EAAAvrB,GAAA5jC,EAAA,GAAAwN,OAEA,CACA,GAAA,IAAAxN,GAAAA,IAAAwN,EAAA,EAAA,CACA4hD,EAAA/uD,KAAAu5B,EAAAzsB,MAAAy2B,EAAA5jC,IACA,UAGAkvD,EAAAtrB,EAAA5jC,EAAA,GACAmvD,EAAAvrB,EAAA5jC,EAAA,GAIA45B,EAAAja,IAAAlB,EAAA0wC,EAAAD,GAGAJ,EAAArwC,EAAAA,EAAAuvC,EAEA,IAAAsB,GAAAP,EAAAM,EAAAH,GACAlF,EAAA+E,EAAAM,EAAAF,GACAI,EAAAD,EAAAtF,CACA,KAAAuF,IACAD,GAAAC,EACAvF,GAAAuF,GAGAT,EAAArvC,EAAAhB,GAAA6wC,GACAR,EAAAnxC,EAAAc,EAAAurC,EACA,IAAAwF,GAAAR,KAAAK,EAAA5vC,GACA4uC,EAAAW,KAAAK,EAAA1xC,EACAsxC,KACAJ,EAAAW,EAAAA,EAAAvrD,GACA2qD,EAAAY,EAAAA,EAAAtrD,GACA2qD,EAAAR,EAAAA,EAAApqD,GACA2qD,EAAAP,EAAAA,EAAAnqD,IAEAkrD,EAAA/uD,KAAAmvD,GACAJ,EAAA/uD,KAAAguD,GAOA,MAJAG,IACAY,EAAA/uD,KAAA+uD,EAAA7uD,SAGA6uD,IjE+0dM,SAAS3yD,EAAQD,EAASM,GkE56dhC,GAAAixD,GAAAjxD,EAAA,GAEAL,GAAAD,QAAAM,EAAA,IAAAwR,QAEAhM,KAAA,WAEA+C,OACAu+B,OAAA,KAEAoqB,QAAA,EAEAC,iBAAA,MAGAjsD,OACAktC,OAAA,OAEAD,KAAA,MAGAjK,UAAA,SAAA1tB,EAAAjS,GACA0oD,EAAA/oB,UAAA1tB,EAAAjS,GAAA,OlE07dM,SAAS5I,EAAQD,EAASM,GmE98dhC,GAAA2yD,GAAA3yD,EAAA,GAEAL,GAAAD,QAAAM,EAAA,IAAAwR,QAEAhM,KAAA,OAEA+C,OAMAwmB,EAAA,EAEA1sB,EAAA,EACAE,EAAA,EACAsB,MAAA,EACAM,OAAA,GAGA+jC,UAAA,SAAA1tB,EAAAjS,GACA,GAAAlG,GAAAkG,EAAAlG,EACAE,EAAAgG,EAAAhG,EACAsB,EAAA0E,EAAA1E,MACAM,EAAAoE,EAAApE,MACAoE,GAAAwmB,EAIA4jC,EAAAzqB,UAAA1tB,EAAAjS,GAHAiS,EAAAoD,KAAAvb,EAAAE,EAAAsB,EAAAM,GAKAqW,EAAAqvC,gBnE+9dM,SAASlqD,EAAQD,GoElgevBC,EAAAD,SACAwoC,UAAA,SAAA1tB,EAAAjS,GACA,GAKAqqD,GACAC,EACAC,EACAC,EARA1wD,EAAAkG,EAAAlG,EACAE,EAAAgG,EAAAhG,EACAsB,EAAA0E,EAAA1E,MACAM,EAAAoE,EAAApE,OACA4qB,EAAAxmB,EAAAwmB,CAOAlrB,GAAA,IACAxB,GAAAwB,EACAA,GAAAA,GAEAM,EAAA,IACA5B,GAAA4B,EACAA,GAAAA,GAGA,gBAAA4qB,GACA6jC,EAAAC,EAAAC,EAAAC,EAAAhkC,EAEAA,YAAAjZ,OACA,IAAAiZ,EAAA/rB,OACA4vD,EAAAC,EAAAC,EAAAC,EAAAhkC,EAAA,GAEA,IAAAA,EAAA/rB,QACA4vD,EAAAE,EAAA/jC,EAAA,GACA8jC,EAAAE,EAAAhkC,EAAA,IAEA,IAAAA,EAAA/rB,QACA4vD,EAAA7jC,EAAA,GACA8jC,EAAAE,EAAAhkC,EAAA,GACA+jC,EAAA/jC,EAAA,KAGA6jC,EAAA7jC,EAAA,GACA8jC,EAAA9jC,EAAA,GACA+jC,EAAA/jC,EAAA,GACAgkC,EAAAhkC,EAAA,IAIA6jC,EAAAC,EAAAC,EAAAC,EAAA,CAGA,IAAAC,EACAJ,GAAAC,EAAAhvD,IACAmvD,EAAAJ,EAAAC,EACAD,GAAA/uD,EAAAmvD,EACAH,GAAAhvD,EAAAmvD,GAEAF,EAAAC,EAAAlvD,IACAmvD,EAAAF,EAAAC,EACAD,GAAAjvD,EAAAmvD,EACAD,GAAAlvD,EAAAmvD,GAEAH,EAAAC,EAAA3uD,IACA6uD,EAAAH,EAAAC,EACAD,GAAA1uD,EAAA6uD,EACAF,GAAA3uD,EAAA6uD,GAEAJ,EAAAG,EAAA5uD,IACA6uD,EAAAJ,EAAAG,EACAH,GAAAzuD,EAAA6uD,EACAD,GAAA5uD,EAAA6uD,GAEAx4C,EAAAouC,OAAAvmD,EAAAuwD,EAAArwD,GACAiY,EAAAquC,OAAAxmD,EAAAwB,EAAAgvD,EAAAtwD,GACA,IAAAswD,GAAAr4C,EAAA6uC,iBACAhnD,EAAAwB,EAAAtB,EAAAF,EAAAwB,EAAAtB,EAAAswD,GAEAr4C,EAAAquC,OAAAxmD,EAAAwB,EAAAtB,EAAA4B,EAAA2uD,GACA,IAAAA,GAAAt4C,EAAA6uC,iBACAhnD,EAAAwB,EAAAtB,EAAA4B,EAAA9B,EAAAwB,EAAAivD,EAAAvwD,EAAA4B,GAEAqW,EAAAquC,OAAAxmD,EAAA0wD,EAAAxwD,EAAA4B,GACA,IAAA4uD,GAAAv4C,EAAA6uC,iBACAhnD,EAAAE,EAAA4B,EAAA9B,EAAAE,EAAA4B,EAAA4uD,GAEAv4C,EAAAquC,OAAAxmD,EAAAE,EAAAqwD,GACA,IAAAA,GAAAp4C,EAAA6uC,iBAAAhnD,EAAAE,EAAAF,EAAAuwD,EAAArwD,MpE6geM,SAAS5C,EAAQD,EAASM,GqE9lehCL,EAAAD,QAAAM,EAAA,IAAAwR,QAEAhM,KAAA,OAEA+C,OAEAu4C,GAAA,EACAC,GAAA,EAEAnP,GAAA,EACAC,GAAA,EAEApsB,QAAA,GAGAvgB,OACAktC,OAAA,OACAD,KAAA,MAGAjK,UAAA,SAAA1tB,EAAAjS,GACA,GAAAu4C,GAAAv4C,EAAAu4C,GACAC,EAAAx4C,EAAAw4C,GACAnP,EAAArpC,EAAAqpC,GACAC,EAAAtpC,EAAAspC,GACApsB,EAAAld,EAAAkd,OAEA,KAAAA,IAIAjL,EAAAouC,OAAA9H,EAAAC,GAEAt7B,EAAA,IACAmsB,EAAAkP,GAAA,EAAAr7B,GAAAmsB,EAAAnsB,EACAosB,EAAAkP,GAAA,EAAAt7B,GAAAosB,EAAApsB,GAEAjL,EAAAquC,OAAAjX,EAAAC,KAQAohB,QAAA,SAAAzyD,GACA,GAAA+H,GAAAzI,KAAAyI,KACA,QACAA,EAAAu4C,IAAA,EAAAtgD,GAAA+H,EAAAqpC,GAAApxC,EACA+H,EAAAw4C,IAAA,EAAAvgD,GAAA+H,EAAAspC,GAAArxC,OrE8meM,SAASb,EAAQD,EAASM,GsEpqehC,YAkBA,SAAAkzD,GAAA3qD,EAAAib,EAAA2vC,GACA,GAAAC,GAAA7qD,EAAA6qD,KACAC,EAAA9qD,EAAA8qD,IACA,OAAA,QAAAD,GAAA,OAAAC,IAEAF,EAAAxH,EAAAlB,GAAAliD,EAAAu4C,GAAAv4C,EAAA+qD,KAAA/qD,EAAA6qD,KAAA7qD,EAAAqpC,GAAApuB,IACA2vC,EAAAxH,EAAAlB,GAAAliD,EAAAw4C,GAAAx4C,EAAAgrD,KAAAhrD,EAAA8qD,KAAA9qD,EAAAspC,GAAAruB,MAKA2vC,EAAAtF,EAAAD,GAAArlD,EAAAu4C,GAAAv4C,EAAA+qD,KAAA/qD,EAAAqpC,GAAApuB,IACA2vC,EAAAtF,EAAAD,GAAArlD,EAAAw4C,GAAAx4C,EAAAgrD,KAAAhrD,EAAAspC,GAAAruB,IAvBA,GAAAgwC,GAAAxzD,EAAA,IACA88B,EAAA98B,EAAA,IACAiuD,EAAAuF,EAAAvF,mBACAvB,EAAA8G,EAAA9G,eACAkB,EAAA4F,EAAA5F,YACAnD,EAAA+I,EAAA/I,QACAoD,EAAA2F,EAAA3F,sBACAlC,EAAA6H,EAAA7H,kBAEA1qC,IAkBAthB,GAAAD,QAAAM,EAAA,IAAAwR,QAEAhM,KAAA,eAEA+C,OACAu4C,GAAA,EACAC,GAAA,EACAnP,GAAA,EACAC,GAAA,EACAyhB,KAAA,EACAC,KAAA,EAKA9tC,QAAA,GAGAvgB,OACAktC,OAAA,OACAD,KAAA,MAGAjK,UAAA,SAAA1tB,EAAAjS,GACA,GAAAu4C,GAAAv4C,EAAAu4C,GACAC,EAAAx4C,EAAAw4C,GACAnP,EAAArpC,EAAAqpC,GACAC,EAAAtpC,EAAAspC,GACAyhB,EAAA/qD,EAAA+qD,KACAC,EAAAhrD,EAAAgrD,KACAH,EAAA7qD,EAAA6qD,KACAC,EAAA9qD,EAAA8qD,KACA5tC,EAAAld,EAAAkd,OACA,KAAAA,IAIAjL,EAAAouC,OAAA9H,EAAAC,GAEA,MAAAqS,GAAA,MAAAC,GACA5tC,EAAA,IACAwoC,EACAnN,EAAAwS,EAAA1hB,EAAAnsB,EAAAxE,GAEAqyC,EAAAryC,EAAA,GACA2wB,EAAA3wB,EAAA,GACAgtC,EACAlN,EAAAwS,EAAA1hB,EAAApsB,EAAAxE,GAEAsyC,EAAAtyC,EAAA,GACA4wB,EAAA5wB,EAAA,IAGAzG,EAAA6uC,iBACAiK,EAAAC,EACA3hB,EAAAC,KAIApsB,EAAA,IACAinC,EACA5L,EAAAwS,EAAAF,EAAAxhB,EAAAnsB,EAAAxE,GAEAqyC,EAAAryC,EAAA,GACAmyC,EAAAnyC,EAAA,GACA2wB,EAAA3wB,EAAA,GACAyrC,EACA3L,EAAAwS,EAAAF,EAAAxhB,EAAApsB,EAAAxE,GAEAsyC,EAAAtyC,EAAA,GACAoyC,EAAApyC,EAAA,GACA4wB,EAAA5wB,EAAA,IAEAzG,EAAAyuC,cACAqK,EAAAC,EACAH,EAAAC,EACAzhB,EAAAC,MAUAohB,QAAA,SAAAzvC,GACA,MAAA0vC,GAAApzD,KAAAyI,MAAAib,GAAA,IAQAiwC,UAAA,SAAAjwC,GACA,GAAAhjB,GAAA0yD,EAAApzD,KAAAyI,MAAAib,GAAA,EACA,OAAAsZ,GAAA5Z,UAAA1iB,EAAAA,OtE8qeM,SAASb,EAAQD,EAASM,GuE3yehCL,EAAAD,QAAAM,EAAA,IAAAwR,QAEAhM,KAAA,MAEA+C,OAEA+3C,GAAA,EAEAC,GAAA,EAEAxxB,EAAA,EAEAy6B,WAAA,EAEAC,SAAA,EAAAjpC,KAAAsM,GAEA+jC,WAAA,GAGA3rD,OAEAktC,OAAA,OAEAD,KAAA,MAGAjK,UAAA,SAAA1tB,EAAAjS,GAEA,GAAAlG,GAAAkG,EAAA+3C,GACA/9C,EAAAgG,EAAAg4C,GACAxxB,EAAAvO,KAAApZ,IAAAmB,EAAAwmB,EAAA,GACAy6B,EAAAjhD,EAAAihD,WACAC,EAAAlhD,EAAAkhD,SACAoH,EAAAtoD,EAAAsoD,UAEAE,EAAAvwC,KAAA8B,IAAAknC,GACAwH,EAAAxwC,KAAA4B,IAAAonC,EAEAhvC,GAAAouC,OAAAmI,EAAAhiC,EAAA1sB,EAAA2uD,EAAAjiC,EAAAxsB,GACAiY,EAAA+uC,IAAAlnD,EAAAE,EAAAwsB,EAAAy6B,EAAAC,GAAAoH,OvE0zeM,SAASlxD,EAAQD,EAASM,GwEv2ehC,YAGA,IAAA8K,GAAA9K,EAAA,GAEA89C,EAAA99C,EAAA,IAWA6/C,EAAA,SAAAx9C,EAAAE,EAAAqvC,EAAAC,EAAAR,EAAAqiB,GACA5zD,KAAAuC,EAAA,MAAAA,EAAA,EAAAA,EAEAvC,KAAAyC,EAAA,MAAAA,EAAA,EAAAA,EAEAzC,KAAA8xC,GAAA,MAAAA,EAAA,EAAAA,EAEA9xC,KAAA+xC,GAAA,MAAAA,EAAA,EAAAA,EAGA/xC,KAAA0F,KAAA,SAGA1F,KAAAgyC,OAAA4hB,IAAA,EAEA5V,EAAAz9C,KAAAP,KAAAuxC,GAGAwO,GAAAn+C,WAEA+L,YAAAoyC,GAGA/0C,EAAAgH,SAAA+tC,EAAA/B,GAEAn+C,EAAAD,QAAAmgD,GxE82eM,SAASlgD,EAAQD,EAASM,GyEv5ehC,YAGA,IAAA8K,GAAA9K,EAAA,GAEA89C,EAAA99C,EAAA,IAUA8/C,EAAA,SAAAz9C,EAAAE,EAAAwsB,EAAAsiB,EAAAqiB,GACA5zD,KAAAuC,EAAA,MAAAA,EAAA,GAAAA,EAEAvC,KAAAyC,EAAA,MAAAA,EAAA,GAAAA,EAEAzC,KAAAivB,EAAA,MAAAA,EAAA,GAAAA,EAGAjvB,KAAA0F,KAAA,SAGA1F,KAAAgyC,OAAA4hB,IAAA,EAEA5V,EAAAz9C,KAAAP,KAAAuxC,GAGAyO,GAAAp+C,WAEA+L,YAAAqyC,GAGAh1C,EAAAgH,SAAAguC,EAAAhC,GAEAn+C,EAAAD,QAAAogD,GzE85eM,SAASngD,EAAQD,EAASM,G0E37ehC,QAAA2zD,GAAAphD,EAAA5R,GAMAb,KAAAq4C,MAAA5lC,EAOAzS,KAAA8zD,UAAAjzD,EAAA2B,SAEAxC,KAAA+zD,MAAAlzD,EAAA6E,MAAA,UAOA1F,KAAAg0D,WAAAnzD,EAAA65C,YAAA,EACA16C,KAAAi0D,WAAApzD,EAAAs6C,UAOAn7C,KAAA65C,OAAA,GAAAp4C,GAAAK,MACA9B,KAAA65C,OAAAt0C,KAAAvF,KAAAq4C,MAAAh4C,GAGAL,KAAA+5C,UArCA,GAAAv4C,GAAAtB,EAAA,IACAuB,EAAAvB,EAAA,IAuCAg0D,EAAAL,EAAAjyD,SAMAsyD,GAAApxD,SAAA,WACA,MAAA9C,MAAA65C,QAOAqa,EAAAna,QAAA,WAEA/5C,KAAAm0D,oBAEAn0D,KAAAo0D,oBAOAF,EAAAC,kBAAA,WAGA,GAAA9vD,GAAA7C,EAAAm7C,gBACAp6C,EAAAvC,KAAA8zD,UAAAvxD,EAAA,EACAE,EAAAzC,KAAA8zD,UAAArxD,EACAsB,EAAA,WAAA/D,KAAA+zD,MAAAvyD,EAAAo7C,eAAAp7C,EAAA27C,oBAEA10C,EAAA,GAAAhH,GAAAk+C,SACAp6C,KAAAvF,KAAAq4C,MAAAh4C,GACAoI,OACAu+B,SACAzkC,EAAAE,IACAF,EAAAwB,EAAA,GAAAtB,IACAF,EAAAwB,EAAAtB,EAAA4B,EAAA,IACA9B,EAAAwB,EAAA,GAAAtB,EAAA4B,IACA9B,EAAAE,EAAA4B,KAGAe,OACAitC,KAAA,UACAC,OAAA,UACA3C,UAAA,MAKA3vC,MAAAg0D,aACAvrD,EAAAiyC,UAAA16C,KAAAg0D,WACAvrD,EAAA4vC,MAAAr4C,KAAAq4C,MACA5vC,EAAAwrD,WAAAj0D,KAAAi0D,WACAxrD,EAAAkyC,QAAA36C,KAAA46C,QAIA56C,KAAA65C,OAAA73C,IAAAyG,IAOAyrD,EAAAtZ,OAAA,WACA,GAAA9vB,GAAAytB,KAAA7mC,QAEA4mC,YACAgE,KAAAt8C,KAAAq4C,OAEAt0C,MAAA,IACAM,OAAA,KACarE,KAAAi0D,WAEb1b,MAAAgE,UAAAzxB,IAOAopC,EAAAE,iBAAA,WACA,GAAA7xD,GAAAvC,KAAA8zD,UAAAvxD,GAAA,WAAAvC,KAAA+zD,MAAAvyD,EAAAy7C,qBAAA,IACAx6C,EAAAzC,KAAA8zD,UAAArxD,EAEA4xD,EAAA,GAAA5yD,GAAAi8C,MACAt4C,OACAstC,KAAA1yC,KAAAq4C,MAAA9yC,KACA0wC,SAAAz0C,EAAAq7C,cACA7J,UAAA,OACAD,aAAA,OAGA7sC,UAAA3D,EAAAE,IAGAzC,MAAAg0D,aACAK,EAAA3Z,UAAA16C,KAAAg0D,WACAK,EAAAhc,MAAAr4C,KAAAq4C,MACAgc,EAAAJ,WAAAj0D,KAAAi0D,WACAI,EAAA1Z,QAAA36C,KAAA46C,QAGA56C,KAAA65C,OAAA73C,IAAAqyD,IAGAx0D,EAAAD,QAAAi0D,G1E48eM,SAASh0D,EAAQD,EAASM,G2EvlfhC,QAAAw7C,GAAAl5C,GAEA,GAAA8xD,IAAsB/xD,EAAAC,EAAAD,EAAAf,EAAAoC,cAAAnB,EAAAD,EAAAC,EAEtB,OAAA8xD,GAAA/xD,EAAA8xD,GASA,QAAA3Y,GAAAn5C,GAEA,GAAA8xD,IAAsB/xD,EAAAC,EAAAD,EAAAf,EAAAoC,cAAAnB,EAAAD,EAAAC,GACtB2C,GAAqBmtC,UAAA/wC,EAAA47C,WAErB,OAAAmX,GAAA/xD,EAAA8xD,EAAAlvD,GAUA,QAAA42C,GAAAx5C,EAAAgyD,GACA,GAAAF,IAAsB/xD,EAAAC,EAAAD,EAAAE,EAAAD,EAAAC,EAAA+xD,GACtBpvD,GAAqBmtC,UAAA/wC,EAAA47C,WAErB,OAAAmX,GAAA/xD,EAAA8xD,EAAAlvD,GAWA,QAAAmvD,GAAA/xD,EAAA8xD,EAAAlvD,GAEA,GAAAqvD,IACAC,YAAA,UACA/kB,UAAA,GACAhqB,QAAA,EAGAtkB,GAAAqQ,OAAA+iD,EAAArvD,EAEA,IAAAqD,GAAA,GAAAhH,GAAAy4C,MACAzxC,OAEAu4C,GAAAx+C,EAAAD,EACA0+C,GAAAz+C,EAAAC,EAGAqvC,GAAAwiB,EAAA/xD,EACAwvC,GAAAuiB,EAAA7xD,EAEAkjB,QAAA,GAGAvgB,MAAAqvD,GAGA,OAAAhsD,GA9EA,GAAAjH,GAAAtB,EAAA,IACAuB,EAAAvB,EAAA,IACAmB,EAAAnB,EAAA,EAgFAL,GAAAD,SACA87C,OAAAA,EACAC,SAAAA,EACAK,cAAAA,I3EgnfM,SAASn8C,EAAQD,EAASM,G4E7qfhC,QAAAi6C,GAAAwa,EAAA9zD,GAMAb,KAAAq4C,MAAAsc,EAOA30D,KAAA40D,UAAAD,EAAAE,WAAA,EAOA70D,KAAA8zD,UAAAjzD,EAAA2B,SAOAxC,KAAA80D,iBAAAj0D,EAAA+6C,kBAAA,EAOA57C,KAAA+0D,sBAAAl0D,EAAAg7C,uBAAA,EAOA77C,KAAAg1D,gBAAAn0D,EAAAi7C,iBAAA,EACA97C,KAAAi1D,gBAAAp0D,EAAAk7C,eAOA/7C,KAAA65C,OAAA,GAAAp4C,GAAAK,MACA9B,KAAA65C,OAAAt0C,KAAAvF,KAAAq4C,MAAAh4C,GAGAL,KAAA+5C,UA3EA,GAAAv4C,GAAAtB,EAAA,IACA+5C,EAAA/5C,EAAA,IACAuB,EAAAvB,EAAA,IA4EAg1D,EAAA/a,EAAAv4C,SAMAszD,GAAApyD,SAAA,WACA,MAAA9C,MAAA65C,QAQAqb,EAAAnb,QAAA,WAEA/5C,KAAAm1D,cAGAn1D,KAAAo1D,kBAGAp1D,KAAAs6C,wBAOA4a,EAAAC,YAAA,WAEA,GAAA5yD,GAAAvC,KAAA8zD,UAAAvxD,EAAAf,EAAAy7C,qBACAx6C,EAAAzC,KAAA8zD,UAAArxD,EAEA4yD,EAAA,GAAA5zD,GAAAi8C,MACAt4C,OACAstC,KAAA1yC,KAAAq4C,MAAA9yC,KACA0wC,SAAAz0C,EAAAs7C,aACA9J,UAAA,OACAD,aAAA,MAEAV,KAAAryC,KAAA40D,UAAA,MAAA,SAGA1uD,UAAA3D,EAAAE,IAIA4yD,GAAAjxD,kBAAAC,QAAA7C,EAAAu7C,oBAAAv7C,EAAAw7C,uBAEAqY,EAAAjxD,kBAAAL,MAAAvC,EAAAoC,cAGAyxD,EAAAjxD,kBAAA7B,IAAAf,EAAAy7C,qBAGAj9C,KAAA65C,OAAA73C,IAAAqzD,IAOAH,EAAAE,gBAAA,WACA,GAAAp1D,KAAA80D,iBAAA,CAIA,GAAAvyD,GAAAvC,KAAA8zD,UAAAvxD,EAAAf,EAAAoC,cAAA,GACAnB,EAAAzC,KAAA8zD,UAAArxD,EACAuwC,EAAA,OAGAhzC,MAAA+0D,wBACA/hB,EAAA,OACAzwC,EAAAvC,KAAA8zD,UAAAvxD,EAAAf,EAAAoC,cAAA,EAGA,IAAA0xD,GAAA,GAAA7zD,GAAAi8C,MACAt4C,OACAstC,KAAA1yC,KAAAq4C,MAAAkd,UAAA,GACAtf,SAAAz0C,EAAAs7C,aACA9J,UAAAA,EACAD,aAAA,MACApD,UAAA,GAGAzpC,UAAA3D,EAAAE,IAGAzC,MAAA65C,OAAA73C,IAAAszD,KAOAJ,EAAA5a,qBAAA,WACA,GAAAt6C,KAAA+0D,sBAaA,IAAA,GATAS,GAAAx1D,KAAAq4C,MAAAod,mBACAC,EAAAF,EAAAtyD,OACAyyD,EAAAD,EAAA,EAAA,GAAA,EACA5B,GACAvxD,EAAAvC,KAAA8zD,UAAAvxD,EAAAf,EAAAoC,cAAA,EAAApC,EAAA27C,qBAAAuY,EAAA,GAAAC,EACAlzD,EAAAzC,KAAA8zD,UAAArxD,GAIAW,EAAAsyD,EAAA,EAAyCtyD,GAAA,EAAQA,IACjDpD,KAAA65C,OAAA73C,IAAA,GAAAi4C,GAAAub,EAAApyD,IACAZ,SAAAsxD,EACApuD,KAAA,cACAg1C,UAAA16C,KAAAg1D,gBACA7Z,UAAAn7C,KAAAi1D,kBACanyD,YACbgxD,GAAyBvxD,EAAAuxD,EAAAvxD,EAAAf,EAAA27C,oBAAA,GAAA16C,EAAAqxD,EAAArxD,IAczB5C,EAAAD,QAAAu6C,G5EotfM,SAASt6C,EAAQD,EAASM,G6E95fhC,QAAAqB,GAAAq0D,EAAAC,EAAA9wD,EAAAC,GACAhF,KAAA81D,YAAA/wD,EACA/E,KAAA+1D,YAAA/wD,EAEAhF,KAAA65C,OAAA,GAAAp4C,GAAAK,MAGA9B,KAAAg2D,YACAzzD,EAAAqzD,EAAAxxD,kBAAA7B,EAAAf,EAAAy7C,qBACAx6C,EAAAmzD,EAAAxxD,kBAAA3B,EAAAmzD,EAAAxxD,kBAAAC,OAAA,GAIArE,KAAAi2D,UACA1zD,EAAAszD,EAAAzxD,kBAAA7B,EAAAf,EAAAy7C,qBACAx6C,EAAAozD,EAAAzxD,kBAAA3B,EAAAozD,EAAAzxD,kBAAAC,OAAA,GAIArE,KAAAk2D,YACA3zD,EAAAqzD,EAAAxxD,kBAAA7B,EAAAf,EAAAoC,cAAApC,EAAAy7C,qBACAx6C,EAAAmzD,EAAAxxD,kBAAA3B,EAAAmzD,EAAAxxD,kBAAAC,OAAA,GAIArE,KAAAm2D,UACA5zD,EAAAszD,EAAAzxD,kBAAA7B,EAAAf,EAAAoC,cAAApC,EAAAy7C,qBACAx6C,EAAAozD,EAAAzxD,kBAAA3B,EAAAozD,EAAAzxD,kBAAAC,OAAA,GAIArE,KAAAo2D,eAAAp2D,KAAAg2D,WAAAzzD,EAAAvC,KAAAi2D,SAAA1zD,GAAA,EAGAvC,KAAA+5C,UA7CA,GAAAv4C,GAAAtB,EAAA,IACAuB,EAAAvB,EAAA,IA+CAm2D,EAAA90D,EAAAK,SAMAy0D,GAAAvzD,SAAA,WACA,MAAA9C,MAAA65C,QAOAwc,EAAAtc,QAAA,WAEA/5C,KAAAs2D,cAGAt2D,KAAAu2D,eAGAv2D,KAAAm1D,eAOAkB,EAAAC,YAAA,WACA,GAAAE,KAEAx2D,MAAAo2D,gBAEAI,EAAA/yD,MAAAzD,KAAAg2D,WAAAzzD,EAAAvC,KAAAg2D,WAAAvzD,IAEA+zD,EAAA/yD,MAAAzD,KAAAg2D,WAAAzzD,EAAAf,EAAA67C,gBAAAr9C,KAAAg2D,WAAAvzD,IAEA+zD,EAAA/yD,MAAAzD,KAAAg2D,WAAAzzD,EAAAf,EAAA67C,gBAAAr9C,KAAAi2D,SAAAxzD,IAEA+zD,EAAA/yD,MAAAzD,KAAAi2D,SAAA1zD,EAAAvC,KAAAi2D,SAAAxzD,MAIA+zD,EAAA/yD,MAAAzD,KAAAk2D,WAAA3zD,EAAAvC,KAAAk2D,WAAAzzD,IAEA+zD,EAAA/yD,MAAAzD,KAAAk2D,WAAA3zD,EAAAf,EAAA67C,gBAAAr9C,KAAAg2D,WAAAvzD,IAEA+zD,EAAA/yD,MAAAzD,KAAAk2D,WAAA3zD,EAAAf,EAAA67C,gBAAAr9C,KAAAm2D,SAAA1zD,IAEA+zD,EAAA/yD,MAAAzD,KAAAm2D,SAAA5zD,EAAAvC,KAAAm2D,SAAA1zD,IAGA,IAAA64C,GAAA,GAAA75C,GAAAm+C,UACAn3C,OACAu+B,OAAAwvB,GAGApxD,OAEAktC,OAAA,SAIAtyC,MAAA65C,OAAA73C,IAAAs5C,IAOA+a,EAAAE,aAAA,WACA,GAAAE,KAEAz2D,MAAAo2D,gBAEAK,EAAAhzD,MAAAzD,KAAAi2D,SAAA1zD,EAAAvC,KAAAi2D,SAAAxzD,IAEAg0D,EAAAhzD,MAAAzD,KAAAi2D,SAAA1zD,EAAAf,EAAA87C,qBAAAt9C,KAAAi2D,SAAAxzD,EAAAjB,EAAA+7C,wBAEAkZ,EAAAhzD,MAAAzD,KAAAi2D,SAAA1zD,EAAAf,EAAA87C,qBAAAt9C,KAAAi2D,SAAAxzD,EAAAjB,EAAA+7C,0BAIAkZ,EAAAhzD,MAAAzD,KAAAm2D,SAAA5zD,EAAAvC,KAAAm2D,SAAA1zD,IAEAg0D,EAAAhzD,MAAAzD,KAAAm2D,SAAA5zD,EAAAf,EAAA87C,qBAAAt9C,KAAAm2D,SAAA1zD,EAAAjB,EAAA+7C,wBAEAkZ,EAAAhzD,MAAAzD,KAAAm2D,SAAA5zD,EAAAf,EAAA87C,qBAAAt9C,KAAAm2D,SAAA1zD,EAAAjB,EAAA+7C,wBAGA,IAAAmZ,GAAA,GAAAj1D,GAAAm+C,UACAn3C,OACAu+B,OAAAyvB,GAGArxD,OACAitC,KAAA,OACAC,OAAA,SAIAtyC,MAAA65C,OAAA73C,IAAA00D,IAOAL,EAAAlB,YAAA,WACA,GAAAwB,GACAC,EACAC,CAcA,IAZA72D,KAAAo2D,gBACAO,GAAA32D,KAAAg2D,WAAAzzD,EAAA,GAAAvC,KAAAg2D,WAAAvzD,EAAAjB,EAAAi8C,wBACAmZ,GAAA52D,KAAAi2D,SAAA1zD,EAAA,GAAAf,EAAA87C,qBAAAt9C,KAAAi2D,SAAAxzD,EAAAjB,EAAAi8C,wBACAoZ,EAAA,UAGAF,GAAA32D,KAAAk2D,WAAA3zD,EAAA,GAAAvC,KAAAk2D,WAAAzzD,EAAAjB,EAAAi8C,wBACAmZ,GAAA52D,KAAAm2D,SAAA5zD,EAAA,GAAAf,EAAA87C,qBAAAt9C,KAAAm2D,SAAA1zD,EAAAjB,EAAAi8C,wBACAoZ,EAAA,QAIA72D,KAAA81D,YAAA,CACA,GAAAgB,GAAA,GAAAr1D,GAAAi8C,MACAx3C,SAAAywD,EAEAvxD,OACAstC,KAAA1yC,KAAA81D,YACA7f,SAAAz0C,EAAAs7C,aACA9J,UAAA6jB,EACA9jB,aAAA,SACApD,UAAA,IAGA3vC,MAAA65C,OAAA73C,IAAA80D,GAIA,GAAA92D,KAAA+1D,YAAA,CACA,GAAAgB,GAAA,GAAAt1D,GAAAi8C,MACAx3C,SAAA0wD,EAEAxxD,OACAstC,KAAA1yC,KAAA+1D,YACA9f,SAAAz0C,EAAAs7C,aACA9J,UAAA6jB,EACA9jB,aAAA,SACApD,UAAA,IAGA3vC,MAAA65C,OAAA73C,IAAA+0D,KAKAl3D,EAAAD,QAAA2B,G7Eu7fM,SAAS1B,EAAQD,EAASM,G8E5ogBhCA,EAAA,IACAA,EAAA,GAAA+L,gBAAA,MAAA/L,EAAA,M9EopgBM,SAASL,EAAQD,EAASM,G+ElpgBhC,IAAAA,EAAA,GAAAyL,gBAAA,CACA,GAAAqxB,GAAA98B,EAAA,IACAqd,EAAArd,EAAA,IACA4kD,EAAA5kD,EAAA,IAAA4kD,IACA/G,EAAA79C,EAAA,IACA21C,EAAA31C,EAAA,IACAm1C,EAAAn1C,EAAA,IACAs0C,EAAAt0C,EAAA,IACAq0C,EAAAr0C,EAAA,IACAw9C,EAAAx9C,EAAA,IACAo/C,EAAAp/C,EAAA,IAEA89C,EAAA99C,EAAA,IAEA82D,EAAA92D,EAAA,IAEAmuB,EAAA3N,KAAA2N,MACA1N,EAAAD,KAAAC,KACAkiC,EAAAniC,KAAAmiC,IACArgC,EAAA9B,KAAA8B,IACAF,EAAA5B,KAAA4B,IACA6a,EAAAzc,KAAApZ,IAEAgX,EAAA0e,EAAA1e,eAEA24C,EAAA,IACAC,EAAA,oCAEA7R,EAAA,MACA8R,EAAA9R,EAAA,EAEA+R,EAAA,IACAC,EAAA,IAEAC,EAAA,SAAA/pD,GACAA,EAAAnI,MAAAmjC,QAAA,uDACAh7B,EAAAgqD,UAAAlS,EAAA,IAAAA,EACA93C,EAAAiqD,YAAA,OAGAC,EAAA,SAAAt0C,GACA,MAAAu0C,QAAAv0C,GAAAwM,QAAA,KAAA,SAA6CA,QAAA,KAAA,WAG7CgoC,EAAA,SAAA1oC,EAAAC,EAAA/T,GACA,MAAA,QAAA8T,EAAAC,EAAA/T,GAAAkM,KAAA,KAAA,KAGAuwC,EAAA,SAAAv0D,EAAAL,GACAA,GAAAK,GAAAL,EAAAyV,aAAApV,GACAA,EAAAwmC,YAAA7mC,IAIA8K,EAAA,SAAAzK,EAAAL,GACAA,GAAAK,GAAAL,EAAAyV,aAAApV,GACAA,EAAAmrC,YAAAxrC,IAIA60D,EAAA,SAAAz8C,EAAAC,EAAAC,GAEA,OAAAsT,WAAAxT,IAAA,GAAAg8C,GAAAxoC,WAAAvT,IAAA,GAAAg8C,EAAA/7C,GAGAo6B,EAAA,SAAA3jC,EAAA4jC,GACA,MAAA,gBAAA5jC,GACAA,EAAA6jC,YAAA,MAAA,EACAhnB,WAAA7c,GAAA,IAAA4jC,EAEA/mB,WAAA7c,GAEAA,GAOA+lD,EAAA,SAAAvqD,EAAAob,EAAAgkB,GACA,GAAArb,GAAAysB,EAAAn1B,MAAAD,EACAgkB,IAAAA,EACApmB,MAAAomB,KACAA,EAAA,GAEArb,IACA/jB,EAAAob,MAAAgvC,EAAArmC,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACA/jB,EAAAo/B,QAAAA,EAAArb,EAAA,KAIAymC,EAAA,SAAApvC,GACA,GAAA2I,GAAAysB,EAAAn1B,MAAAD,EACA,QACAgvC,EAAArmC,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAA,EAAA,KAIA0mC,EAAA,SAAAzqD,EAAAnI,EAAA6yD,GAEA,GAAA5lB,GAAAjtC,EAAAitC,IACA,IAAA,MAAAA,EAEA,GAAAA,YAAA2L,GAAA,CACA,GAAAka,GACAhJ,EAAA,EACAiJ,GAAA,EAAA,GAEAx0D,EAAA,EAEAy0D,EAAA,EACAt6C,EAAAm6C,EAAA7zD,kBACAi0D,EAAAv6C,EAAA/Z,MACAu0D,EAAAx6C,EAAAzZ,MACA,IAAA,WAAAguC,EAAA3sC,KAAA,CACAwyD,EAAA,UACA,IAAA/5C,GAAA85C,EAAA95C,UACAsH,GAAA4sB,EAAA9vC,EAAA81D,EAAAhmB,EAAA5vC,EAAA61D,GACA5yC,GAAA2sB,EAAAP,GAAAumB,EAAAhmB,EAAAN,GAAAumB,EACAn6C,KACAG,EAAAmH,EAAAA,EAAAtH,GACAG,EAAAoH,EAAAA,EAAAvH,GAEA,IAAApE,GAAA2L,EAAA,GAAAD,EAAA,GACAzL,EAAA0L,EAAA,GAAAD,EAAA,EACAypC,GAAA,IAAAxuC,KAAAE,MAAA7G,EAAAC,GAAA0G,KAAAsM,GAEAkiC,EAAA,IACAA,GAAA,KAKAA,EAAA,OACAA,EAAA,OAGA,CACAgJ,EAAA,gBACA,IAAAzyC,IAAA4sB,EAAA9vC,EAAA81D,EAAAhmB,EAAA5vC,EAAA61D,GACAn6C,EAAA85C,EAAA95C,UACAhY,EAAA8xD,EAAA9xD,MACApC,EAAAs0D,EACAh0D,EAAAi0D,CACAH,KAEA1yC,EAAA,GAAA3H,EAAAvb,GAAAwB,GACA0hB,EAAA,GAAA3H,EAAArb,GAAA4B,GAEA8Z,GACAG,EAAAmH,EAAAA,EAAAtH,GAGApa,GAAAoC,EAAA,GAAAk/C,EACAhhD,GAAA8B,EAAA,GAAAk/C,CACA,IAAAkT,GAAAp7B,EAAAp5B,EAAAM,EACAV,GAAA,EAAA40D,EACAH,EAAA,EAAA/lB,EAAApjB,EAAAspC,EAAA50D,EAKA,GAAA60D,GAAAnmB,EAAAd,WAAAl9B,OACAmkD,GAAAnwC,KAAA,SAAAowC,EAAAC,GACA,MAAAD,GAAAj5B,OAAAk5B,EAAAl5B,QAOA,KAAA,GAJAt8B,GAAAs1D,EAAAt1D,OAEAy1D,KACAhnC,KACAvuB,EAAA,EAA+BA,EAAAF,EAAYE,IAAA,CAC3C,GAAAwD,GAAA4xD,EAAAp1D,GACAw1D,EAAAb,EAAAnxD,EAAA+hB,MACAgJ,GAAAluB,KAAAmD,EAAA44B,OAAA44B,EAAAz0D,EAAA,IAAAi1D,EAAA,IACA,IAAAx1D,GAAAA,IAAAF,EAAA,GACAy1D,EAAAl1D,KAAAm1D,GAIA,GAAA11D,GAAA,EAAA,CACA,GAAA21D,GAAAF,EAAA,GAAA,GACAG,EAAAH,EAAA,GAAA,GACAI,EAAAJ,EAAA,GAAA,GAAAvzD,EAAAunC,QACAqsB,EAAAL,EAAA,GAAA,GAAAvzD,EAAAunC,OAEAp/B,GAAA7H,KAAAwyD,EACA3qD,EAAA0mC,OAAA,OACA1mC,EAAA4qD,MAAA,OACA5qD,EAAA2hD,MAAAA,EACA3hD,EAAAob,MAAAkwC,EACAtrD,EAAAurD,OAAAA,EACAvrD,EAAAokB,OAAAA,EAAAtK,KAAA,KAGA9Z,EAAAo/B,QAAAqsB,EAEAzrD,EAAAyrD,SAAAD,EAEA,WAAAb,IACA3qD,EAAA0rD,cAAAd,EAAA9wC,KAAA,UAKAywC,GAAAvqD,EAAA8kC,EAAAjtC,EAAAunC,UAKAusB,EAAA,SAAA3rD,EAAAnI,GAUA,MAAAA,EAAAmtC,WACAhlC,EAAA4rD,UAAA/zD,EAAAmtC,SAAAlrB,KAAA,MAEA,MAAAjiB,EAAAktC,QAAAltC,EAAAktC,iBAAA0L,IACA8Z,EAAAvqD,EAAAnI,EAAAktC,OAAAltC,EAAAunC,UAIAysB,EAAA,SAAAC,EAAA3zD,EAAAN,EAAA6yD,GACA,GAAAqB,GAAA,QAAA5zD,EACA6H,EAAA8rD,EAAAE,qBAAA7zD,GAAA,EAEA,OAAAN,EAAAM,IAAA,SAAAN,EAAAM,KAAA4zD,IAAAA,GAAAl0D,EAAAuqC,YACA0pB,EAAAC,EAAA,SAAA,WAAA,OAEAl0D,EAAAM,YAAAs4C,IACAlwC,EAAAurD,EAAA9rD,GAEAA,IACAA,EAAAypD,EAAAwC,WAAA9zD,IAGA4zD,EAAAtB,EAAAzqD,EAAAnI,EAAA6yD,GAAAiB,EAAA3rD,EAAAnI,GACAwyD,EAAAyB,EAAA9rD,KAGA8rD,EAAAC,EAAA,SAAA,WAAA,QACAxrD,EAAAurD,EAAA9rD,KAIAy5B,aACAyyB,EAAA,SAAAhnD,EAAAjS,GACA,GAOAmwD,GACA+I,EACArW,EACAjgD,EACA4nD,EACAC,EAZAhG,EAAAH,EAAAG,EACAC,EAAAJ,EAAAI,EACAj0B,EAAA6zB,EAAA7zB,EACAm0B,EAAAN,EAAAM,EACAD,EAAAL,EAAAK,EAEAz2B,IAOA,KAAAtrB,EAAA,EAAmBA,EAAAqP,EAAAvP,QAAiB,CAIpC,OAHAmgD,EAAA5wC,EAAArP,KACAs2D,EAAA,GACA/I,EAAA,EACAtN,GACA,IAAA4B,GACAyU,EAAA,MACA/I,EAAA,EACA3F,EAAAv4C,EAAArP,KACA6nD,EAAAx4C,EAAArP,KACA4jC,EAAA,GAAA,GAAAgkB,EACAhkB,EAAA,GAAA,GAAAikB,CACA,MACA,KAAAh6B,GACAyoC,EAAA,MACA/I,EAAA,EACA3F,EAAAv4C,EAAArP,KACA6nD,EAAAx4C,EAAArP,KACA4jC,EAAA,GAAA,GAAAgkB,EACAhkB,EAAA,GAAA,GAAAikB,CACA,MACA,KAAA9F,GACA,IAAAD,GACAwU,EAAA,MACA/I,EAAA,CACA,IAIAvH,GACAC,EALArI,EAAAvuC,EAAArP,KACA69C,EAAAxuC,EAAArP,KACA0uC,EAAAr/B,EAAArP,KACA2uC,EAAAt/B,EAAArP,IAGAigD,KAAA8B,GAEAiE,EAAAtX,EACAuX,EAAAtX,EACAD,GAAAA,EAAA,EAAAkP,GAAA,EACAjP,GAAAA,EAAA,EAAAkP,GAAA,EACAD,GAAAgK,EAAA,EAAAhK,GAAA,EACAC,GAAAgK,EAAA,EAAAhK,GAAA,IAGAmI,EAAA32C,EAAArP,KACAimD,EAAA52C,EAAArP,MAEA4jC,EAAA,GAAA,GAAAga,EACAha,EAAA,GAAA,GAAAia,EACAja,EAAA,GAAA,GAAA8K,EACA9K,EAAA,GAAA,GAAA+K,EACA/K,EAAA,GAAA,GAAAoiB,EACApiB,EAAA,GAAA,GAAAqiB,EAEA2B,EAAA5B,EACA6B,EAAA5B,CACA,MACA,KAAAjE,GACA,GAAA7iD,GAAA,EACAE,EAAA,EACA+d,EAAA,EACAC,EAAA,EACAyuC,EAAA,CACA1uD,KAEA+B,EAAA/B,EAAA,GACAiC,EAAAjC,EAAA,GACAggB,EAAAG,EAAAngB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAigB,EAAAE,EAAAngB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACA0uD,EAAAxuC,KAAAE,OAAApgB,EAAA,GAAAigB,EAAAjgB,EAAA,GAAAggB,GAGA,IAAAggC,GAAA/tC,EAAArP,KACAq9C,EAAAhuC,EAAArP,KACA8/C,EAAAzwC,EAAArP,KACA+/C,EAAA1wC,EAAArP,KACAsmD,EAAAj3C,EAAArP,KAAA8rD,EACAvF,EAAAl3C,EAAArP,KAAAsmD,EAAAwF,CAGA9rD,IACA,IAAA2tD,GAAAt+C,EAAArP,KAEA4mD,EAAAxJ,EAAAh+B,EAAAknC,GAAAxG,EACA+G,EAAAxJ,EAAAn+B,EAAAonC,GAAAvG,EAEAnC,EAAAR,EAAAh+B,EAAAmnC,GAAAzG,EACAjC,EAAAR,EAAAn+B,EAAAqnC,GAAAxG,EAEAz9C,EAAAqrD,EAAA,OAAA,MACArwC,MAAAmiC,IAAAmH,EAAAhJ,GAAA,OAEAtgC,KAAAmiC,IAAA8G,EAAAD,GAAA,IAGAqH,IACA/G,GAAA,IAAA3E,GAKA3kC,KAAAmiC,IAAAoH,EAAAxJ,GAAA,KACAsQ,GAAA/G,EAAAxJ,IAAAuQ,GAAA/G,EAAAxJ,EACAS,GAAA,IAAAoE,EAGApE,GAAA,IAAAoE,EAGA0L,GAAA9G,EAAAxJ,IAAAsQ,GAAA9G,EAAAxJ,EACAO,GAAA,IAAAqE,EAGArE,GAAA,IAAAqE,GAIA32B,EAAAjrB,KACAiC,EACA2oB,IAAAmyB,EAAA0C,GAAA1iC,EAAAje,GAAA8iD,EAAA8R,GAAAF,EACA5oC,IAAAoyB,EAAA0C,GAAA1iC,EAAAhe,GAAA4iD,EAAA8R,GAAAF,EACA5oC,IAAAmyB,EAAA0C,GAAA1iC,EAAAje,GAAA8iD,EAAA8R,GAAAF,EACA5oC,IAAAoyB,EAAA0C,GAAA1iC,EAAAhe,GAAA4iD,EAAA8R,GAAAF,EACA5oC,GAAA27B,EAAAxpC,EAAAje,GAAA8iD,EAAA8R,GAAAF,EACA5oC,GAAA47B,EAAAxpC,EAAAhe,GAAA4iD,EAAA8R,GAAAF,EACA5oC,GAAA2yB,EAAAxgC,EAAAje,GAAA8iD,EAAA8R,GAAAF,EACA5oC,GAAA4yB,EAAAxgC,EAAAhe,GAAA4iD,EAAA8R,IAGAnM,EAAAhK,EACAiK,EAAAhK,CACA,MACA,KAAA6D,GAAAn0B,EACA,GAAAlL,GAAAuhB,EAAA,GACAthB,EAAAshB,EAAA,EAEAvhB,GAAA,GAAAhT,EAAArP,KACAqiB,EAAA,GAAAhT,EAAArP,KAEAsiB,EAAA,GAAAD,EAAA,GAAAhT,EAAArP,KACAsiB,EAAA,GAAAD,EAAA,GAAAhT,EAAArP,KAEA5C,IACA8d,EAAAmH,EAAAA,EAAAjlB,GACA8d,EAAAoH,EAAAA,EAAAllB,IAGAilB,EAAA,GAAA4I,EAAA5I,EAAA,GAAA4/B,EAAA8R,GACAzxC,EAAA,GAAA2I,EAAA3I,EAAA,GAAA2/B,EAAA8R,GACA1xC,EAAA,GAAA4I,EAAA5I,EAAA,GAAA4/B,EAAA8R,GACAzxC,EAAA,GAAA2I,EAAA3I,EAAA,GAAA2/B,EAAA8R,GACAzoC,EAAAjrB,KAEA,MAAAgiB,EAAA,GAAAwxC,EAAAxxC,EAAA,GAEA,MAAAC,EAAA,GAAAuxC,EAAAxxC,EAAA,GAEA,MAAAC,EAAA,GAAAuxC,EAAAvxC,EAAA,GAEA,MAAAD,EAAA,GAAAwxC,EAAAvxC,EAAA,GAEA,MACA,KAAAo/B,GAAAO,EAEA32B,EAAAjrB,KAAA,OAGA,GAAAktD,EAAA,EAAA,CACAjiC,EAAAjrB,KAAAi2D,EACA,KAAA,GAAAxtC,GAAA,EAA+BA,EAAAykC,EAAYzkC,IAAA,CAC3C,GAAAxrB,GAAAsmC,EAAA9a,EAEA1rB,IAAA8d,EAAA5d,EAAAA,EAAAF,GAEAkuB,EAAAjrB,KACA4qB,EAAA3tB,EAAA,GAAA2kD,EAAA8R,GAAAF,EAAA5oC,EAAA3tB,EAAA,GAAA2kD,EAAA8R,GACAjrC,EAAAykC,EAAA,EAAAsG,EAAA,MAMA,MAAAvoC,GAAArH,KAAA,IAIAi4B,GAAA19C,UAAA+3D,SAAA,SAAAC,GACA,GAAAx0D,GAAApF,KAAAoF,MAEAi0D,EAAAr5D,KAAA65D,MACAR,KACAA,EAAArC,EAAAwC,WAAA,SACAlC,EAAA+B,GAEAr5D,KAAA65D,OAAAR,GAGAD,EAAAC,EAAA,OAAAj0D,EAAApF,MACAo5D,EAAAC,EAAA,SAAAj0D,EAAApF,KAEA,IAAAQ,GAAAR,KAAAme,UACA27C,EAAA,MAAAt5D,EACAu5D,EAAAV,EAAAE,qBAAA,UAAA,EACA,IAAAQ,EAAA,CACA,GAAApqB,GAAAvqC,EAAAuqC,SAKA,IAAAmqB,IAAA10D,EAAAqtC,cAAA,CACA,GAAA9vB,GAAAniB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,EACAmvC,IAAAhvB,EAAAkiC,EAAAlgC,IAEAo3C,EAAAC,OAAArqB,EAAA,KAGA,GAAA1rB,GAAAjkB,KAAAikB,IACAjkB,MAAAomD,cACAniC,EAAAkkB,YACAnoC,KAAAooC,UAAAnkB,EAAAjkB,KAAAyI,OACAwb,EAAAqhC,WACAtlD,KAAAomD,aAAA,GAGAiT,EAAAp1C,KAAAw1C,EAAAx1C,EAAAxR,KAAAzS,KAAAme,WAEAk7C,EAAAj0D,MAAA60D,OAAApC,EAAA73D,KAAAob,OAAApb,KAAAqb,EAAArb,KAAAsb,IAGAs8C,EAAAgC,EAAAP,GAGA,MAAAj0D,EAAAstC,KACA1yC,KAAAm1C,aAAAykB,EAAA55D,KAAAoE,mBAGApE,KAAAk6D,eAAAN,IAIAta,EAAA19C,UAAAu4D,SAAA,SAAAP,GACA9rD,EAAA8rD,EAAA55D,KAAA65D,QACA75D,KAAAk6D,eAAAN,IAGAta,EAAA19C,UAAAw4D,MAAA,SAAAR,GACAhC,EAAAgC,EAAA55D,KAAA65D,QACA75D,KAAAq6D,eAAAT,GAMA,IAAAU,GAAA,SAAAC,GAEA,MAAA,gBAAAA,IAAAA,EAAAC,SAAA,QAAAD,EAAAC,QAAA3xB,cAKA0L,GAAA3yC,UAAA+3D,SAAA,SAAAC,GACA,GAIAa,GACAC,EALAt1D,EAAApF,KAAAoF,MACAirC,EAAAjrC,EAAAirC,KAMA,IAAAiqB,EAAAjqB,GAAA,CACA,GAAAqE,GAAArE,EAAAqE,GACA,IAAAA,IAAA10C,KAAA26D,UACAF,EAAAz6D,KAAA46D,YACAF,EAAA16D,KAAA66D,iBAEA;AACA,GAAAC,GAAAzqB,EAAA0qB,aACAC,EAAAF,EAAA/2D,MACAk3D,EAAAH,EAAAz2D,MACAy2D,GAAA/2D,MAAA,OACA+2D,EAAAz2D,OAAA,OAGAo2D,EAAApqB,EAAAtsC,MACA22D,EAAArqB,EAAAhsC,OAGAy2D,EAAA/2D,MAAAi3D,EACAF,EAAAz2D,OAAA42D,EAGAj7D,KAAA26D,UAAAjmB,EACA10C,KAAA46D,YAAAH,EACAz6D,KAAA66D,aAAAH,EAEArqB,EAAAqE,MAGArE,KAAArwC,KAAA26D,YACAF,EAAAz6D,KAAA46D,YACAF,EAAA16D,KAAA66D,aAGA,IAAAxqB,EAAA,CAIA,GAAA9tC,GAAA6C,EAAA7C,GAAA,EACAE,EAAA2C,EAAA3C,GAAA,EAEAy4D,EAAA91D,EAAArB,MACAo3D,EAAA/1D,EAAAf,OAEA+2D,EAAAh2D,EAAA6vC,OACAomB,EAAAj2D,EAAA8vC,QACA10B,EAAApb,EAAAob,IAAA,EACAC,EAAArb,EAAAqb,IAAA,EAEA66C,EAAAF,GAAAC,EAEAhC,EAAAr5D,KAAA65D,MACAR,KAGAA,EAAArC,EAAAuE,IAAAvrD,cAAA,OACAsnD,EAAA+B,GAEAr5D,KAAA65D,OAAAR,EAGA,IAEA74D,GAFAg7D,EAAAnC,EAAAj0D,MACAq2D,GAAA,EAEAjQ,EAAA,EACAC,EAAA,CAQA,IAPAzrD,KAAAme,YACA3d,EAAAR,KAAAme,UACAqtC,EAAA7qC,EAAAngB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACAirD,EAAA9qC,EAAAngB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAEAi7D,EAAAj7D,EAAA,IAAAA,EAAA,IAEAi7D,EAAA,CAMA,GAAAh2C,IAAAljB,EAAAE,GACAijB,GAAAnjB,EAAA24D,EAAAz4D,GACAikB,GAAAnkB,EAAAE,EAAA04D,GACAx0C,GAAApkB,EAAA24D,EAAAz4D,EAAA04D,EACA78C,GAAAmH,EAAAA,EAAAjlB,GACA8d,EAAAoH,EAAAA,EAAAllB,GACA8d,EAAAoI,EAAAA,EAAAlmB,GACA8d,EAAAqI,EAAAA,EAAAnmB,EAEA,IAAAi9B,GAAAN,EAAA1X,EAAA,GAAAC,EAAA,GAAAgB,EAAA,GAAAC,EAAA,IACA+W,EAAAP,EAAA1X,EAAA,GAAAC,EAAA,GAAAgB,EAAA,GAAAC,EAAA,IAEA+0C,IACAA,GAAAj4D,KAAA,OAAAjD,EAAA,GAAAgrD,EAAAyL,EACA,OAAAz2D,EAAA,GAAAirD,EAAAwL,EACA,OAAAz2D,EAAA,GAAAgrD,EAAAyL,EACA,OAAAz2D,EAAA,GAAAirD,EAAAwL,EACA,MAAA5oC,EAAA9rB,EAAAipD,EAAAhrD,EAAA,IAAAy2D,EACA,MAAA5oC,EAAA5rB,EAAAgpD,EAAAjrD,EAAA,KAEAg7D,EAAA7F,QAAA,KAAAtnC,EAAAoP,GAAA,MAAApP,EAAAqP,GAAA,OAEA89B,EAAApoD,OAAA8jD,EAAA,WACAwE,EAAAr0C,KAAA,IAAA,2BAIA7mB,KACA+B,EAAAA,EAAAipD,EAAAhrD,EAAA,GACAiC,EAAAA,EAAAgpD,EAAAjrD,EAAA,IAEAg7D,EAAApoD,OAAA,GACAooD,EAAAt8B,KAAA7Q,EAAA9rB,GAAA,KACAi5D,EAAA/4B,IAAApU,EAAA5rB,GAAA,IAGA,IAAAk5D,GAAA37D,KAAA47D,SACAC,EAAA77D,KAAA87D,OAEAH,KACAA,EAAA3E,EAAAuE,IAAAvrD,cAAA,OACAhQ,KAAA47D,SAAAD,EAEA,IAAAI,GAAAJ,EAAAv2D,KACA,IAAAk2D,EAAA,CAEA,GAAAb,GAAAC,EAmBAqB,EAAAh4D,MAAAsqB,EAAAm9B,EAAAiP,EAAAS,EAAAE,GAAA,KACAW,EAAA13D,OAAAgqB,EAAAo9B,EAAAiP,EAAAS,EAAAE,GAAA,SApBA,CACA,GAAAW,GAAA,GAAAnnB,OACA1oC,EAAAnM,IACAg8D,GAAAlnB,OAAA,WACAknB,EAAAlnB,OAAA,KACA2lB,EAAAuB,EAAAj4D,MACA22D,EAAAsB,EAAA33D,OAEA03D,EAAAh4D,MAAAsqB,EAAAm9B,EAAAiP,EAAAS,EAAAE,GAAA,KACAW,EAAA13D,OAAAgqB,EAAAo9B,EAAAiP,EAAAS,EAAAE,GAAA,KAGAlvD,EAAAyuD,YAAAH,EACAtuD,EAAA0uD,aAAAH,EACAvuD,EAAAwuD,UAAAtqB,GAEA2rB,EAAAtnB,IAAArE,EAOAwrB,IACAA,EAAA7E,EAAAuE,IAAAvrD,cAAA,OACA6rD,EAAAz2D,MAAA62D,SAAA,SACAj8D,KAAA87D,QAAAD,EAEA,IAAAK,GAAAL,EAAAz2D,KACA82D,GAAAn4D,MAAAsqB,GAAA6sC,EAAA16C,EAAA06C,EAAAE,GAAA5P,GACA0Q,EAAA73D,OAAAgqB,GAAA8sC,EAAA16C,EAAA06C,EAAAE,GAAA5P,GACAyQ,EAAA9oD,OAAA8jD,EAAA,eACA12C,EAAA06C,EAAAE,EAAA5P,EAAA,QAAA/qC,EAAA06C,EAAAE,EAAA5P,EAAA,IAEAoQ,EAAApjD,YACA4gD,EAAAxvB,YAAAgyB,GAEAF,EAAAljD,YAAAojD,GACAA,EAAAhyB,YAAA8xB,OAIAI,GAAAh4D,MAAAsqB,EAAAm9B,EAAA0P,GAAA,KACAa,EAAA13D,OAAAgqB,EAAAo9B,EAAA0P,GAAA,KAEA9B,EAAAxvB,YAAA8xB,GAEAE,GAAAA,EAAApjD,aACA4gD,EAAA7qB,YAAAqtB,GACA77D,KAAA87D,QAAA,KAIA,IAAAK,GAAA,GACAhsC,EAAA/qB,EAAAunC,OACAxc,GAAA,IACAgsC,GAAA,kBAAA9tC,EAAA,IAAA8B,GAAA,MAEAgsC,GAAAjF,EAAA,yBAAA7mB,EAAA,wBAEA0rB,EAAA3oD,OAAA+oD,EAEA9C,EAAAj0D,MAAA60D,OAAApC,EAAA73D,KAAAob,OAAApb,KAAAqb,EAAArb,KAAAsb,IAGAs8C,EAAAgC,EAAAP,GAGA,MAAAj0D,EAAAstC,MACA1yC,KAAAm1C,aAAAykB,EAAA55D,KAAAoE,qBAIAmwC,EAAA3yC,UAAAu4D,SAAA,SAAAP,GACA9rD,EAAA8rD,EAAA55D,KAAA65D,QAEA75D,KAAA65D,OAAA,KACA75D,KAAA87D,QAAA,KACA97D,KAAA47D,SAAA,KAEA57D,KAAAk6D,eAAAN,IAGArlB,EAAA3yC,UAAAw4D,MAAA,SAAAR,GACAhC,EAAAgC,EAAA55D,KAAA65D,QACA75D,KAAAq6D,eAAAT,GAQA,IAuCAwC,GAvCAC,EAAA,SAEAC,KACAC,EAAA,EACAC,EAAA,IACAC,EAAA1sD,SAAAC,cAAA,OAEA0sD,EAAA,SAAAC,GACA,GAAAC,GAAAN,EAAAK,EACA,KAAAC,EAAA,CAEAL,EAAAC,IACAD,EAAA,EACAD,KAGA,IACAO,GADAz3D,EAAAq3D,EAAAr3D,KAEA,KACAA,EAAA4wC,KAAA2mB,EACAE,EAAAz3D,EAAAy3D,WAAAx4C,MAAA,KAAA,GAEA,MAAA1d,IAGAi2D,GACAx3D,MAAAA,EAAAw3D,WAAAP,EACAS,QAAA13D,EAAA23D,aAAAV,EACArC,OAAA50D,EAAA43D,YAAAX,EACAY,KAAA,EAAAruC,WAAAxpB,EAAA83D,UAAA,IACAC,OAAAN,GAAA,mBAGAP,EAAAK,GAAAC,EACAL,IAEA,MAAAK,GAKA/mB,GAAAiB,YAAA,SAAApE,EAAAuD,GACA,GAAAslB,GAAAvE,EAAAuE,GACAa,KACAA,EAAAb,EAAAvrD,cAAA,OACAosD,EAAAh3D,MAAAmjC,QAAA,wFAEAyuB,EAAAuE,IAAA6B,KAAAvzB,YAAAuyB,GAGA,KACAA,EAAAh3D,MAAA4wC,KAAAC,EACS,MAAAonB,IAMT,MAHAjB,GAAAnzB,UAAA,GAEAmzB,EAAAvyB,YAAA0xB,EAAA+B,eAAA5qB,KAEA3uC,MAAAq4D,EAAAmB,aAqNA,KAAA,GAjNAx/C,GAAA,GAAAR,GAEA43B,EAAA,SAAAykB,EAAA97C,EAAAg4B,EAAA0nB,GAEA,GAAAp4D,GAAApF,KAAAoF,MACAstC,EAAAttC,EAAAstC,IAGA,IADA,MAAAA,IAAAA,GAAA,IACAA,EAAA,CAIA,GAAAnwC,GACAE,EACAszC,EAAA3wC,EAAA4tC,UACA4pB,EAAAF,EAAAt3D,EAAA6wC,UAEAD,EAAA4mB,EAAAx3D,MAAA,IAAAw3D,EAAAE,QAAA,IAAAF,EAAA5C,OAAA,IACA4C,EAAAK,KAAA,OAAAL,EAAAO,OAAA,IAEAjnB,EAAA9wC,EAAA2tC,aACAoD,EAAA/wC,EAAA6tC,iBAEA6C,GAAAA,GAAAD,EAAAzxC,gBAAAsuC,EAAAsD,EAAAD,EAAAG,EAGA,IAAA11C,GAAAR,KAAAme,SAQA,IANA3d,IAAAg9D,IACAz/C,EAAAM,KAAAP,GACAC,EAAAO,eAAA9d,GACAsd,EAAAC,GAGAy/C,EAwBAj7D,EAAAub,EAAAvb,EACAE,EAAAqb,EAAArb,MAzBA,CACA,GAAAowC,GAAAztC,EAAAytC,aACAvvB,EAAAle,EAAA8tC,YAEA,IAAAL,YAAA78B,OACAzT,EAAAub,EAAAvb,EAAAmzC,EAAA7C,EAAA,GAAA/0B,EAAA/Z,OACAtB,EAAAqb,EAAArb,EAAAizC,EAAA7C,EAAA,GAAA/0B,EAAAzZ,QAEA0xC,EAAAA,GAAA,OACAG,EAAAA,GAAA,UAEA,CACA,GAAAG,GAAAR,EAAAS,yBACAzD,EAAA/0B,EAAAg4B,EAAAxyB,EAEA/gB,GAAA8zC,EAAA9zC,EACAE,EAAA4zC,EAAA5zC,EAGAszC,EAAAA,GAAAM,EAAArD,UACAkD,EAAAA,GAAAG,EAAAtD,cAOA,GAAAoD,EAAA,CACA,OAAAA,GACA,IAAA,SACA1zC,GAAAqzC,EAAAzxC,OAAA,CACA,MACA,KAAA,SACA5B,GAAAqzC,EAAAzxC,OAKA6xC,EAAA,MAGA,GAAAgnB,GAAAN,EAAAK,IAEA,QAAA/mB,GACA,IAAA,UACA,IAAA,MACAzzC,GAAAy6D,EAAA,IACA,MACA,KAAA,SACA,KACA,SAKAz6D,GAAAy6D,EAAA,KAGA,OAAAnnB,GACA,IAAA,OACA,KACA,KAAA,SACAxzC,GAAAuzC,EAAA/xC,MAAA,CACA,MACA,KAAA,QACAxB,GAAAuzC,EAAA/xC,MAYA,GAGAiiD,GACAyX,EACAC,EALAlE,EAAAxC,EAAAwC,WAEAmE,EAAA39D,KAAA49D,UAIAD,IA0BAD,EAAAC,EAAAlwB,WACAuY,EAAA0X,EAAAhgD,YACA+/C,EAAAzX,EAAAtoC,cA3BAigD,EAAAnE,EAAA,QACAxT,EAAAwT,EAAA,QACAiE,EAAAjE,EAAA,YACAkE,EAAAlE,EAAA,QAIAiE,EAAAr4D,MAAA,gBAAA,OAEAkyD,EAAAqG,GAEA3X,EAAA6X,YAAA,EACAJ,EAAA/2D,IAAA,EAEAi3D,EAAA7sD,KAAA,MACA6sD,EAAAG,GAAA,YAEAlG,EAAA+F,EAAAD,GACA9F,EAAA+F,EAAA3X,GACA4R,EAAA+F,EAAAF,GAEAz9D,KAAA49D,WAAAD,EASA,IAAAI,IAAAx7D,EAAAE,GACAu7D,EAAAL,EAAAv4D,KAEA5E,IAAAg9D,GACAl/C,EAAAy/C,EAAAA,EAAAv9D,GAEAk9D,EAAAh3D,IAAA,EAEAg3D,EAAAn+C,OAAA/e,EAAA,GAAAy9D,QAAA,GAAAhH,EAAAz2D,EAAA,GAAAy9D,QAAA,GAAAhH,EACAz2D,EAAA,GAAAy9D,QAAA,GAAAhH,EAAAz2D,EAAA,GAAAy9D,QAAA,GAAA,OAGAP,EAAAl+B,QAAAnR,EAAA0vC,EAAA,KAAA,GAAA,KAAA1vC,EAAA0vC,EAAA,KAAA,GAEAL,EAAA99C,OAAA,MAEAo+C,EAAA9+B,KAAA,MACA8+B,EAAAv7B,IAAA,QAGAi7B,EAAAh3D,IAAA,EACAs3D,EAAA9+B,KAAA7Q,EAAA9rB,GAAA,KACAy7D,EAAAv7B,IAAApU,EAAA5rB,GAAA,MAGAg7D,EAAAS,OAAAzG,EAAA/kB,EAEA,KACA+qB,EAAAr4D,MAAA4wC,KAAAA,EAGA,MAAArvC,IAEAyyD,EAAAuE,EAAA,QACAtrB,KAAAmrB,EAAAp4D,EAAAitC,KAAAjtC,EAAAutC,SACAhG,QAAAvnC,EAAAunC,SACS3sC,MACTo5D,EAAAuE,EAAA,UACArrB,OAAAkrB,EAAAp4D,EAAAktC,OAAAltC,EAAAwtC,WACAjG,QAAAvnC,EAAAunC,QACA4F,SAAAntC,EAAAmtC,UACSvyC,MAET29D,EAAAv4D,MAAA60D,OAAApC,EAAA73D,KAAAob,OAAApb,KAAAqb,EAAArb,KAAAsb,IAGAs8C,EAAAgC,EAAA+D,KAGAzD,EAAA,SAAAN,GACA9rD,EAAA8rD,EAAA55D,KAAA49D,YACA59D,KAAA49D,WAAA,MAGAvD,EAAA,SAAAT,GACAhC,EAAAgC,EAAA55D,KAAA49D,aAGA3kD,IAAAo8B,EAAAb,EAAAD,EAAA+K,EAAA5B,GAGAt6C,GAAA,EAAmBA,GAAA6V,GAAA/V,OAAiBE,KAAA,CACpC,GAAA+6D,IAAAllD,GAAA7V,IAAAxB,SACAu8D,IAAAhpB,aAAAA,EACAgpB,GAAAjE,eAAAA,EACAiE,GAAA9D,eAAAA,EAGA3c,EAAA97C,UAAA+3D,SAAA,SAAAC,GACA,GAAAx0D,GAAApF,KAAAoF,KACA,OAAAA,EAAAstC,KACA1yC,KAAAm1C,aAAAykB,GACAr3D,EAAA6C,EAAA7C,GAAA,EAAAE,EAAA2C,EAAA3C,GAAA,EACAsB,MAAA,EAAAM,OAAA,GACarE,KAAAoE,mBAAA,GAGbpE,KAAAk6D,eAAAN,IAIAlc,EAAA97C,UAAAu4D,SAAA,SAAAP,GACA55D,KAAAk6D,eAAAN,IAGAlc,EAAA97C,UAAAw4D,MAAA,SAAAR,GACA55D,KAAAq6D,eAAAT,M/E+pgBM,SAAS/5D,EAAQD,EAASM,GgFxriBhC,IAAAA,EAAA,GAAAyL,gBAAA,CACA,GAEA6tD,GAFA4E,EAAA,gCAGAC,EAAAluD,OACAorD,EAAA8C,EAAAtuD,SAEAuuD,GAAA,CAEA,MACA/C,EAAAgD,WAAAC,OAAAjD,EAAAgD,WAAAv8D,IAAA,QAAAo8D,GACA5E,EAAA,SAAAgB,GACA,MAAAe,GAAAvrD,cAAA,UAAAwqD,EAAA,oBAGA,MAAA7zD,GACA6yD,EAAA,SAAAgB,GACA,MAAAe,GAAAvrD,cAAA,IAAAwqD,EAAA,WAAA4D,EAAA,qBAKA,GAAAK,GAAA,WACA,IAAAH,EAAA,CAGAA,GAAA,CAEA,IAAAI,GAAAnD,EAAAmD,WACAA,GAAAx7D,OAAA,GACAq4D,EAAAoD,mBAAAC,QAAA,SAAA,8BAIAF,EAAA,GAAAE,QAAA,SAAA,+BAKA/+D,GAAAD,SACA27D,IAAAA,EACAkD,QAAAA,EACAjF,WAAAA,KhFmsiBM,SAAS35D,EAAQD,EAASM,GiFpuiBhC,QAAAsnC,GAAAnoB,GACA,MAAAwP,UAAAxP,EAAA,IAMA,QAAAw/C,GAAAn/D,EAAA0M,GAEA4qD,EAAAyH,UAEAz+D,KAAAN,KAAAA,EAEAM,KAAAoM,QAAAA,CAEA,IAAA0yD,GAAA/uD,SAAAC,cAAA,OAEA4pD,EAAA7pD,SAAAC,cAAA,MAEA8uD,GAAA15D,MAAAmjC,QAAA,mFAEAqxB,EAAAx0D,MAAAmjC,QAAA,kCAEA7oC,EAAAmqC,YAAAi1B,GAEA9+D,KAAA++D,SAAAnF,EACA55D,KAAAg/D,aAAAF,EAEA9+D,KAAAkC,QAGA,IAAAgL,GAAAd,EAAAe,WACAC,EAAAhB,EAAAiB,QACAjB,GAAAe,WAAA,SAAAG,GACA,GAAAC,GAAAnB,EAAAoB,IAAAF,EAEAJ,GAAA3M,KAAA6L,EAAAkB,GAEAC,GACAA,EAAA4sD,UAAA5sD,EAAA4sD,SAAAP,IAIAxtD,EAAAiB,SAAA,SAAAE,GAEAA,EAAA6sD,OAAA7sD,EAAA6sD,MAAAR,GAEAxsD,EAAA7M,KAAA6L,EAAAmB,IAGAvN,KAAAi/D,aAAA,EAmHA,QAAAC,GAAAjrB,GACA,MAAA,YACAkrB,EAAA,iDAAAlrB,EAAA,MA1KA,GAAAkrB,GAAAj/D,EAAA,IACA82D,EAAA92D,EAAA,GAuDA2+D,GAAAj9D,WAEA+L,YAAAkxD,EAKApyD,gBAAA,WACA,MAAAzM,MAAAg/D,cAMA5wD,QAAA,WAEA,GAAA6K,GAAAjZ,KAAAoM,QAAA8M,gBAAA,GAAA,EAEAlZ,MAAAmqC,WAAAlxB,IAGAkxB,WAAA,SAAAlxB,GAEA,IAAA,GADA2gD,GAAA55D,KAAA++D,SACA37D,EAAA,EAA2BA,EAAA6V,EAAA/V,OAAiBE,IAAA,CAC5C,GAAAmK,GAAA0L,EAAA7V,EACAmK,GAAA0Q,WAAA1Q,EAAA4L,QACA5L,EAAA6xD,qBACA7xD,EAAA4sD,SAAAP,GAGArsD,EAAA6xD,qBAAA,IAGA7xD,EAAA6xD,qBACA7xD,EAAA6sD,MAAAR,GAEArsD,EAAA6xD,qBAAA,EACA7xD,EAAA6O,UACA7O,EAAAy/B,aAAAz/B,EAAAy/B,eACAz/B,EAAAosD,UAAApsD,EAAA0/B,OAAA1sC,KAAAgN,EAAAqsD,GACArsD,EAAA2/B,YAAA3/B,EAAA2/B,eAGA3/B,EAAA6O,SAAA,EAGApc,KAAAi/D,cAKAj/D,KAAAg/D,aAAAn1B,YAAA+vB,GACA55D,KAAAi/D,aAAA,IAIA/8D,OAAA,SAAA6B,EAAAM,GACA,GAAAN,GAAA,MAAAA,EAAA/D,KAAAq/D,YAAAt7D,EACAM,EAAA,MAAAA,EAAArE,KAAAs/D,aAAAj7D,CAEA,IAAArE,KAAAupC,QAAAxlC,GAAA/D,KAAAwpC,SAAAnlC,EAAA,CACArE,KAAAupC,OAAAxlC,EACA/D,KAAAwpC,QAAAnlC,CAEA,IAAAk7D,GAAAv/D,KAAAg/D,aAAA55D,KACAm6D,GAAAx7D,MAAAA,EAAA,KACAw7D,EAAAl7D,OAAAA,EAAA,OAIAwG,QAAA,WACA7K,KAAAN,KAAAupC,UAAA,GAEAjpC,KAAA++D,SACA/+D,KAAAg/D,aACAh/D,KAAAoM,QAAA,MAGA5F,SAAA,WACA,MAAAxG,MAAAupC,QAGA9iC,UAAA,WACA,MAAAzG,MAAAwpC,SAGA/jC,MAAA,WACAzF,KAAAg/D,cACAh/D,KAAAN,KAAA8uC,YAAAxuC,KAAAg/D,eAIAK,UAAA,WACA,GAAA3/D,GAAAM,KAAAN,KACA2vC,EAAA3vC,EAAA8/D,YAEA,QAAA9/D,EAAA+/D,aAAAj4B,EAAA6H,EAAAtrC,QACAyjC,EAAA6H,EAAAqwB,aACAl4B,EAAA6H,EAAAswB,cAAA,GAGAL,WAAA,WACA,GAAA5/D,GAAAM,KAAAN,KACA2vC,EAAA3vC,EAAA8/D,YAEA,QAAA9/D,EAAAkgE,cAAAp4B,EAAA6H,EAAAhrC,SACAmjC,EAAA6H,EAAAwwB,YACAr4B,EAAA6H,EAAAywB,eAAA,GAgBA,KAAA,GALAC,IACA,WAAA,cAAA,YAAA,mBAAA,iBAAA,YACA,WAAA,WAAA,aAAA,YAAA,eAGA38D,EAAA,EAAmBA,EAAA28D,EAAA78D,OAAgCE,IAAA,CACnD,GAAAmC,GAAAw6D,EAAA38D,EACAy7D,GAAAj9D,UAAA2D,GAAA25D,EAAA35D,GAGA1F,EAAAD,QAAAi/D","file":"fish-topo-bo.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoBo\"] = factory();\n\telse\n\t\troot[\"fishTopoBo\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoBo\"] = factory();\n\telse\n\t\troot[\"fishTopoBo\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Export fishTopo as CommonJS module\r\n\t */\r\n\tmodule.exports = __webpack_require__(2);\r\n\t//IE8 VML IE8\r\n\t__webpack_require__(77);\r\n\t\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Created by majianan on 16/5/19.\r\n\t *\r\n\t */\r\n\t\r\n\t    var zr = __webpack_require__(3);\r\n\t    var util = __webpack_require__(6);\r\n\t    var BoNode = __webpack_require__(39);\r\n\t    var Relation = __webpack_require__(76);\r\n\t    var Const = __webpack_require__(40);\r\n\t    var graphic = __webpack_require__(42);\r\n\t    var eventTool = __webpack_require__(27);\r\n\t\r\n\t    function FishTopoBo(dom, opts) {\r\n\t        /**\r\n\t         * \r\n\t         * @type {number}\r\n\t         */\r\n\t        this.nowZoom = 1;\r\n\t        this.canScale = true;\r\n\t\r\n\t        /**\r\n\t         * zrender\r\n\t         */\r\n\t        this._zr = zr.init(dom, {\r\n\t            renderer: opts.renderer || 'canvas',\r\n\t            devicePixelRatio: opts.devicePixelRatio\r\n\t        });\r\n\t    }\r\n\t\r\n\t    var fishTopoProto = FishTopoBo.prototype;\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     */\r\n\t    fishTopoProto.init = function () {\r\n\t        this.group = new graphic.Group();\r\n\t        this.groupDrag(this.group);\r\n\t        this._zr.add(this.group);\r\n\t        this.zrScale();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     *   \r\n\t     */\r\n\t    fishTopoProto.resize = function () {\r\n\t        this._zr.resize();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @param {Object} boData, bo\r\n\t     * @param {{\r\n\t     *          startPos: {x: number, y: number} ,\r\n\t     *          displayAttrDataType: boolean ,\r\n\t     *          displayAttrEvent: boolean ,\r\n\t     *          boClickable: boolean BO,  false\r\n\t     *          boPopupUrl: String BO\r\n\t     *          boEventClickable: boolean BO,  false\r\n\t     *          boEventPopupUrl: String BO\r\n\t     *          attrEventClickable: boolean BO,  false\r\n\t     *          attrEventPopupUrl: String BO\r\n\t     *          isCurrent: boolean BO\r\n\t     *          }} opts\r\n\t     * @returns {*}\r\n\t     */\r\n\t    fishTopoProto.addBo = function (boData, opts) {\r\n\t        //BO\r\n\t        this._setParent(boData);\r\n\t\r\n\t        //layout BOx,y, level:\r\n\t        boData.layout = {\r\n\t            x: opts.startPos.x,\r\n\t            y: opts.startPos.y,\r\n\t            level: 1\r\n\t        };\r\n\t\r\n\t        //BOX\r\n\t        this._bfs(boData);\r\n\t\r\n\t        //\r\n\t        this._moveRightByParent(boData, opts.startPos.x - boData.layout.x);\r\n\t\r\n\t        //BO\r\n\t        var boNode = new BoNode(boData, opts);\r\n\t        this.group.add(boNode.getShape());\r\n\t\r\n\t        //BO\r\n\t        this.addChildBo(boNode, opts);\r\n\t\r\n\t        return boNode;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @param {Object} boData BO\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._setParent = function (boData) {\r\n\t        if (boData.child) {\r\n\t            var childCnt = boData.child.length,\r\n\t                childBoArr = boData.child;\r\n\t            for (var i = 0; i < childCnt; i++) {\r\n\t                childBoArr[i].parent = boData;\r\n\t                if (childBoArr[i + 1]) {\r\n\t                    childBoArr[i].next = childBoArr[i + 1];\r\n\t                }\r\n\t                //next=\r\n\t                else if (boData.next && boData.next.child) {\r\n\t                    childBoArr[i].next = boData.next.child[0];\r\n\t                }\r\n\t                this._setParent(childBoArr[i]);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * Breadth-First-Search X\r\n\t     * BOBOX\r\n\t     * BOBOY\r\n\t     * @param boData\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._bfs = function (boData) {\r\n\t        //level\r\n\t        this._levelMaxPos = {};\r\n\t\r\n\t        this._queue = [];   //BO\r\n\t        this._queue.push(boData);\r\n\t\r\n\t        while (this._queue.length > 0) {\r\n\t            var tmp = this._queue.shift();\r\n\t            //console.log('BO[' + tmp.name + '] {x: ' + tmp.layout.x + ', level: ' + tmp.layout.level + '} ');\r\n\t            //console.log('    ***Before this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\t\r\n\t            //level\r\n\t            if (!this._levelMaxPos[tmp.layout.level]) {\r\n\t                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n\t            }\r\n\t            //\r\n\t            else if (this._levelMaxPos[tmp.layout.level].x + Const.BO_NODE_WIDTH <= tmp.layout.x) {\r\n\t                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n\t            }\r\n\t            //\r\n\t            else {\r\n\t                this._moveRightByChild(tmp, this._levelMaxPos[tmp.layout.level].x - tmp.layout.x + Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X)\r\n\t                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n\t            }\r\n\t\r\n\t            //console.log('    ***After this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\t\r\n\t            //x\r\n\t            if (tmp.child) {\r\n\t                var childCnt = tmp.child.length;\r\n\t\r\n\t                for (var i = 0; i < childCnt; i++) {\r\n\t\r\n\t                    tmp.child[i].layout = {\r\n\t                        x: tmp.layout.x - (Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X) * ((childCnt - 1) / 2 - i),\r\n\t                        level: tmp.layout.level + 1\r\n\t                    };\r\n\t\r\n\t                    this._queue.push(tmp.child[i]);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @param boData\r\n\t     * @param width\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._moveRightByChild = function (boData, width) {\r\n\t        if (boData) {\r\n\t\r\n\t            if (!boData.layout.moved) {\r\n\t\r\n\t                if (boData.layout.level == 1) {\r\n\t                    boData.layout.x += width / 2;\r\n\t                } else {\r\n\t                    boData.layout.x += width;\r\n\t                }\r\n\t\r\n\t                boData.layout.moved = true;\r\n\t            }\r\n\t            //\r\n\t            this._moveRightByPrevious(boData.next, width);\r\n\t            //\r\n\t            this._moveRightByChild(boData.parent, width);\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @param boData\r\n\t     * @param width\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._moveRightByPrevious = function (boData, width) {\r\n\t        if (boData) {\r\n\t            boData.layout.x += width;\r\n\t            //\r\n\t            this._moveRightByPrevious(boData.next, width);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @param boData\r\n\t     * @param width\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._moveRightByParent = function (boData, width) {\r\n\t        if (boData) {\r\n\t            boData.layout.x += width;\r\n\t            if (boData.child) {\r\n\t                for (var i = 0; i < boData.child.length; i++) {\r\n\t                    this._moveRightByParent(boData.child[i], width);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @param {BoNode} parentBoNode\r\n\t     * @param {Object} opts\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto.addChildBo = function (parentBoNode, opts) {\r\n\t\r\n\t        this._queue = []; //BOYBoNode\r\n\t        this._queue.push(parentBoNode);\r\n\t\r\n\t        while (this._queue.length > 0) {\r\n\t            var tmp = this._queue.shift(),\r\n\t                boNodeHeight = tmp.getShape().getBoundingRect().height;\r\n\t            //console.log('Parent BO[' + tmp.getData().name + '] {y: ' + tmp.getLayout().y + ', level: ' + tmp.getLayout().level + ', boNodeHeight:' + boNodeHeight + '} ');\r\n\t            //console.log('    ***Before this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\t\r\n\t            //Level\r\n\t            if (!this._levelMaxPos[tmp.getLayout().level].y ||\r\n\t                this._levelMaxPos[tmp.getLayout().level].y < tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y) {\r\n\t                this._levelMaxPos[tmp.getLayout().level].y = tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y;\r\n\t            }\r\n\t\r\n\t            //console.log('    ***After this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\t\r\n\t            if (tmp.getData().child) {\r\n\t\r\n\t                var childBoArr = tmp.getData().child,\r\n\t                    childCnt = childBoArr.length,\r\n\t                    boNode,\r\n\t                    relationNode;\r\n\t\r\n\t                //levelY\r\n\t                opts.startPos.y = this._levelMaxPos[tmp.getLayout().level].y;\r\n\t                for (var i = 0; i < childCnt; i++) {\r\n\t                    opts.startPos.x = childBoArr[i].layout.x;\r\n\t                    childBoArr[i].layout.y = opts.startPos.y;\r\n\t                    boNode = new BoNode(childBoArr[i], opts);\r\n\t                    //console.log('Child BO[' + boNode.getData().name + '] {y: ' + opts.startPos.y + ', level: ' + boNode.getLayout().level + '} ');\r\n\t\r\n\t                    this.group.add(boNode.getShape());\r\n\t                    this._queue.push(boNode);\r\n\t\r\n\t                    //BO\r\n\t                    if (childBoArr[i].relation) {\r\n\t                        var _relationLen = childBoArr[i].relation.length;\r\n\t                        for (var j = 0; j < _relationLen; j++) {\r\n\t                            var sourceId = childBoArr[i].relation[j].sourceId,\r\n\t                                targetId = childBoArr[i].relation[j].targetId,\r\n\t                                sourceText = childBoArr[i].relation[j].sourceText,\r\n\t                                targetText = childBoArr[i].relation[j].targetText;\r\n\t\r\n\t                            relationNode = new Relation(\r\n\t                                boNode.getShape().childOfName(sourceId),\r\n\t                                tmp.getShape().childOfName(targetId),\r\n\t                                sourceText,\r\n\t                                targetText\r\n\t                            );\r\n\t                            this.group.add(relationNode.getShape());\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @param {String} boId, BO\r\n\t     * @param {Object} style, BO,\r\n\t     */\r\n\t    fishTopoProto.setCurrentBo = function (boId, style) {\r\n\t        var length = this.group.childCount();\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            if (this.group.childAt(i).name == boId) {\r\n\t                this.group.childAt(i).setCurrent(style);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     */\r\n\t    fishTopoProto.clear = function () {\r\n\t        this._zr.clear();\r\n\t        this.group = new graphic.Group();\r\n\t        this._zr.add(this.group);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @param type\r\n\t     */\r\n\t    fishTopoProto.zrScale = function (type) {\r\n\t        var that = this;\r\n\t        if (type) {\r\n\t            if (type == \"narrowing\") {\r\n\t                var zoomDelta = 1 / 1.1;\r\n\t                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }\r\n\t            if (type == \"enlarge\") {\r\n\t                var zoomDelta = 1.1;\r\n\t                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }\r\n\t        } else {\r\n\t            that._zr.on('mousewheel', function (e) {\r\n\t                eventTool.stop(e.event);\r\n\t                var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\r\n\t                zoom(zoomDelta, e.offsetX, e.offsetY);\r\n\t            });\r\n\t        }\r\n\t        ;\r\n\t        function zoom(zoomDelta, zoomX, zoomY) {\r\n\t            if (that.canScale == false) {\r\n\t                return;\r\n\t            }\r\n\t            var target = that.group;\r\n\t            if (target) {\r\n\t                var pos = target.position;\r\n\t                var scale = target.scale;\r\n\t                var newZoom = that._zoom = that._zoom || 1;\r\n\t                newZoom *= zoomDelta;\r\n\t                var zoomScale = newZoom / that._zoom;\r\n\t                // if(newZoom>2.6||newZoom<0.38){\r\n\t                //     return;\r\n\t                // };\r\n\t                that._zoom = newZoom;\r\n\t\r\n\t                that.nowZoom = newZoom;\r\n\t                // Keep the mouse center when scaling\r\n\t                pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\r\n\t                pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\r\n\t                scale[0] *= zoomScale;\r\n\t                scale[1] *= zoomScale;\r\n\t                target.attr(\"position\", [pos[0], pos[1]]);\r\n\t                target.attr(\"scale\", [scale[0], scale[1]]);\r\n\t                //that.minimap.updateSelectionPosition(pos,zoomScale);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Group\r\n\t     */\r\n\t    fishTopoProto.groupDrag = function () {\r\n\t        var that = this;\r\n\t        that._zr.on(\"mousedown\", function (e) {\r\n\t            groupDragFunction(e);\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t        function groupDragFunction(e) {\r\n\t            var startX = e.event.clientX;\r\n\t            var startY = e.event.clientY;\r\n\t            var moveFunction = function (e) {\r\n\t                moveDrag(e);\r\n\t            }\r\n\t            var nowGroupPosition = that.group.position;\r\n\t            var groupPositionX = that.group.position[0];\r\n\t            var groupPositionY = that.group.position[1];\r\n\t            var alarmPositionX, alarmPositionY;\r\n\t\r\n\t            function moveDrag(e) {\r\n\t                var width = that.group.getBoundingRect().width * that.nowZoom;\r\n\t                var height = that.group.getBoundingRect().height * that.nowZoom;\r\n\t                var gx = that.group.getBoundingRect().x * that.nowZoom;\r\n\t                var gy = that.group.getBoundingRect().y * that.nowZoom;\r\n\t                var min = [10 - (width + gx), 10 - (height + gy)];\r\n\t                var max = [(that._zr.getWidth() - gx) - 10, (that._zr.getHeight() - gy) - 10];\r\n\t                var sX = (e.event.clientX - startX) * (that.nowZoom);\r\n\t                var sY = (e.event.clientY - startY) * (that.nowZoom);\r\n\t                nowGroupPosition[0] = groupPositionX + (sX);\r\n\t                nowGroupPosition[1] = groupPositionY + (sY);\r\n\t                if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] < min[0] || nowGroupPosition[1] < min[1]) {\r\n\t                    return;\r\n\t                } else {\r\n\t                    that.group.attr(\"position\", nowGroupPosition);\r\n\t                }\r\n\t            }\r\n\t\r\n\t            that._zr.on('mousemove', moveFunction);\r\n\t            var upFunction = function (e) {\r\n\t                endDrag(e);\r\n\t            }\r\n\t\r\n\t            function endDrag(e) {\r\n\t                that._zr.off('mousemove', moveFunction);\r\n\t                that._zr.off('mouseup', upFunction);\r\n\t                that._zr.off(\"globalout\", upFunction);\r\n\t            }\r\n\t\r\n\t            that._zr.on('mouseup', upFunction);\r\n\t            that._zr.on(\"globalout\", upFunction);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @param node\r\n\t     */\r\n\t    fishTopoProto.drag = function (node) {\r\n\t        var that = this;\r\n\t        node.on(\"mousedown\", function (e) {\r\n\t            if (this.isdraggable == false) {\r\n\t                return;\r\n\t            }\r\n\t            groupDragFunction(e);\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t        function groupDragFunction(e) {\r\n\t            var startX = e.event.clientX;\r\n\t            var startY = e.event.clientY;\r\n\t            var moveFunction = function (e) {\r\n\t                moveDrag(e);\r\n\t            }\r\n\t            var nowGroupPosition = node.position;\r\n\t            var groupPositionX = node.position[0];\r\n\t            var groupPositionY = node.position[1];\r\n\t            var alarmPositionX, alarmPositionY;\r\n\t            if (node.alarm) {\r\n\t                var newAlarmPosition = node.alarm.position;\r\n\t                alarmPositionX = node.alarm.position[0];\r\n\t                alarmPositionY = node.alarm.position[1];\r\n\t            }\r\n\t            ;\r\n\t            function moveDrag(e) {\r\n\t                var sX = (e.event.clientX - startX) / (that.nowZoom);\r\n\t                var sY = (e.event.clientY - startY) / (that.nowZoom);\r\n\t                if (node.parent && node.parent instanceof GroupNode) {\r\n\t                    //nodegroup\r\n\t                    var nodeMessage = {\r\n\t                        width: node.shape.width,\r\n\t                        height: node.shape.height,\r\n\t                        position: node.position,\r\n\t                        nodeXY: [node.shape.x, node.shape.y],\r\n\t                        movePosition: [groupPositionX, groupPositionY],\r\n\t                        moveX: sX,\r\n\t                        moveY: sY\r\n\t                    };\r\n\t                    var groupNode = node.parent;\r\n\t                    groupNode.reDraw(nodeMessage, node);\r\n\t                } else {\r\n\t                    nowGroupPosition[0] = groupPositionX + (sX);\r\n\t                    nowGroupPosition[1] = groupPositionY + (sY);\r\n\t                    node.attr(\"position\", nowGroupPosition);\r\n\t                    if (node.alarm) {\r\n\t                        var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm.getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect().height - 3];\r\n\t                        node.alarm.attr(\"position\", newAlarmPosition);\r\n\t                    }\r\n\t                    ;\r\n\t                }\r\n\t                ConnectionManager.refreshLineByNode(node);\r\n\t            }\r\n\t\r\n\t            that._zr.on('mousemove', moveFunction);\r\n\t            var upFunction = function (e) {\r\n\t                endDrag(e);\r\n\t            }\r\n\t            //\r\n\t            function endDrag(e) {\r\n\t                that._zr.off('mousemove', moveFunction);\r\n\t                that._zr.off('mouseup', upFunction);\r\n\t                that._zr.off(\"globalout\", upFunction);\r\n\t                //\r\n\t                if (node.layout) {\r\n\t                    that.layoutNode(\"tree\", {\"node\": node});\r\n\t                }\r\n\t                if (that.forceLayoutOption) {\r\n\t                    var nodes = that.forceLayoutOption.allNodes;\r\n\t                    if (_.indexOf(nodes, node) != -1) {\r\n\t                        that.layoutNode(\"force\", this.forceLayoutOption);\r\n\t                    }\r\n\t                }\r\n\t                ;\r\n\t            }\r\n\t\r\n\t            that._zr.on('mouseup', upFunction);\r\n\t            that._zr.on(\"globalout\", upFunction);\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    // ---------fishTopoBo------------------\r\n\t    var idBase = new Date() - 0;\r\n\t    var instances = {};\r\n\t    var DOM_ATTRIBUTE_KEY = '_fishTopoBo_instance_';\r\n\t    var fishTopoBo = {\r\n\t        /**\r\n\t         * @type {number}\r\n\t         */\r\n\t        version: '1.0.0',\r\n\t        dependencies: {\r\n\t            zrender: '3.0.4'\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param {HTMLDomElement} dom\r\n\t     * @param {Object} opts\r\n\t     */\r\n\t    fishTopoBo.init = function (dom, opts) {\r\n\t        if (!dom) {\r\n\t            throw new Error('Initialize failed: invalid dom.');\r\n\t        }\r\n\t\r\n\t        opts = opts || {};\r\n\t        // Default value\r\n\t        util.defaults(opts,\r\n\t            {\r\n\t                type: \"bpmn\",\r\n\t                showGridLine: true,\r\n\t                devicePixelRatio: 1,\r\n\t                gridLineSpacing:10\r\n\t            }\r\n\t        );\r\n\t\r\n\t        var fishTopoBo = new FishTopoBo(dom, opts);\r\n\t        fishTopoBo.init();\r\n\t\r\n\t        fishTopoBo.id = 'ft_' + idBase++;\r\n\t        instances[fishTopoBo.id] = fishTopoBo;\r\n\t\r\n\t        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoBo.id);\r\n\t\r\n\t        return fishTopoBo;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * @param  {HTMLDomElement} dom\r\n\t     * @return {fishTopo}\r\n\t     */\r\n\t    fishTopoBo.getInstanceByDom = function (dom) {\r\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n\t        return instances[key];\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Dispose a fishTopo instance\r\n\t     * @param  {module:fishTopo|HTMLDomElement|string} fishTopo\r\n\t     */\r\n\t    fishTopoBo.dispose = function (chart) {\r\n\t        var topo;\r\n\t        if (zrUtil.isDom(chart)) {\r\n\t            topo = fishTopoBo.getInstanceByDom(chart);\r\n\t        }\r\n\t        else if (typeof chart === 'string') {\r\n\t            topo = instances[chart];\r\n\t        }\r\n\t        if ((topo instanceof fishTopoBo) && !topo.isDisposed()) {\r\n\t            topo.dispose();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = fishTopoBo;\r\n\t\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * ZRender, a high performance 2d drawing library.\n\t *\n\t * Copyright (c) 2013, Baidu Inc.\n\t * All rights reserved.\n\t *\n\t * LICENSE\n\t * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n\t */\n\t// Global defines\n\t\n\t    var guid = __webpack_require__(4);\n\t    var env = __webpack_require__(5);\n\t    var zrUtil = __webpack_require__(6);\n\t\n\t    var Handler = __webpack_require__(7);\n\t    var Storage = __webpack_require__(10);\n\t    var Animation = __webpack_require__(26);\n\t    var HandlerProxy = __webpack_require__(29);\n\t\n\t    var useVML = !env.canvasSupported;\n\t\n\t    var painterCtors = {\n\t        canvas: __webpack_require__(31)\n\t    };\n\t\n\t    var instances = {};    // ZRendermap\n\t\n\t    var zrender = {};\n\t\n\t    /**\n\t     * @type {string}\n\t     */\n\t    zrender.version = '3.4.1';\n\t\n\t    /**\n\t     * Initializing a zrender instance\n\t     * @param {HTMLElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.init = function(dom, opts) {\n\t        var zr = new ZRender(guid(), dom, opts);\n\t        instances[zr.id] = zr;\n\t        return zr;\n\t    };\n\t\n\t    /**\n\t     * Dispose zrender instance\n\t     * @param {module:zrender/ZRender} zr\n\t     */\n\t    zrender.dispose = function (zr) {\n\t        if (zr) {\n\t            zr.dispose();\n\t        }\n\t        else {\n\t            for (var key in instances) {\n\t                if (instances.hasOwnProperty(key)) {\n\t                    instances[key].dispose();\n\t                }\n\t            }\n\t            instances = {};\n\t        }\n\t\n\t        return zrender;\n\t    };\n\t\n\t    /**\n\t     * Get zrender instance by id\n\t     * @param {string} id zrender instance id\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.getInstance = function (id) {\n\t        return instances[id];\n\t    };\n\t\n\t    zrender.registerPainter = function (name, Ctor) {\n\t        painterCtors[name] = Ctor;\n\t    };\n\t\n\t    function delInstance(id) {\n\t        delete instances[id];\n\t    }\n\t\n\t    /**\n\t     * @module zrender/ZRender\n\t     */\n\t    /**\n\t     * @constructor\n\t     * @alias module:zrender/ZRender\n\t     * @param {string} id\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     */\n\t    var ZRender = function(id, dom, opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         */\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id = id;\n\t\n\t        var self = this;\n\t        var storage = new Storage();\n\t\n\t        var rendererType = opts.renderer;\n\t        // TODO WebGL\n\t        if (useVML) {\n\t            if (!painterCtors.vml) {\n\t                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t            }\n\t            rendererType = 'vml';\n\t        }\n\t        else if (!rendererType || !painterCtors[rendererType]) {\n\t            rendererType = 'canvas';\n\t        }\n\t        var painter = new painterCtors[rendererType](dom, storage, opts);\n\t\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t\n\t        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\t\n\t        /**\n\t         * @type {module:zrender/animation/Animation}\n\t         */\n\t        this.animation = new Animation({\n\t            stage: {\n\t                update: zrUtil.bind(this.flush, this)\n\t            }\n\t        });\n\t        this.animation.start();\n\t\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._needsRefresh;\n\t\n\t        //  storage.delFromMap, \n\t        // FIXME ugly\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t\n\t            oldDelFromMap.call(storage, elId);\n\t\n\t            el && el.removeSelfFromZr(self);\n\t        };\n\t\n\t        storage.addToMap = function (el) {\n\t            oldAddToMap.call(storage, el);\n\t\n\t            el.addSelfToZr(self);\n\t        };\n\t    };\n\t\n\t    ZRender.prototype = {\n\t\n\t        constructor: ZRender,\n\t        /**\n\t         * \n\t         * @return {string}\n\t         */\n\t        getId: function () {\n\t            return this.id;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        add: function (el) {\n\t            this.storage.addRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        remove: function (el) {\n\t            this.storage.delRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Change configuration of layer\n\t         * @param {string} zLevel\n\t         * @param {Object} config\n\t         * @param {string} [config.clearColor=0] Clear color\n\t         * @param {string} [config.motionBlur=false] If enable motion blur\n\t         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n\t        */\n\t        configLayer: function (zLevel, config) {\n\t            this.painter.configLayer(zLevel, config);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Repaint the canvas immediately\n\t         */\n\t        refreshImmediately: function () {\n\t            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t            // Or it will cause zrender refreshes again and again.\n\t            this._needsRefresh = false;\n\t            this.painter.refresh();\n\t            /**\n\t             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t             */\n\t            this._needsRefresh = false;\n\t        },\n\t\n\t        /**\n\t         * Mark and repaint the canvas in the next frame of browser\n\t         */\n\t        refresh: function() {\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Perform all refresh\n\t         */\n\t        flush: function () {\n\t            if (this._needsRefresh) {\n\t                this.refreshImmediately();\n\t            }\n\t            if (this._needsRefreshHover) {\n\t                this.refreshHoverImmediately();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add element to hover layer\n\t         * @param  {module:zrender/Element} el\n\t         * @param {Object} style\n\t         */\n\t        addHover: function (el, style) {\n\t            if (this.painter.addHover) {\n\t                this.painter.addHover(el, style);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add element from hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        removeHover: function (el) {\n\t            if (this.painter.removeHover) {\n\t                this.painter.removeHover(el);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clear all hover elements in hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        clearHover: function () {\n\t            if (this.painter.clearHover) {\n\t                this.painter.clearHover();\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Refresh hover in next frame\n\t         */\n\t        refreshHover: function () {\n\t            this._needsRefreshHover = true;\n\t        },\n\t\n\t        /**\n\t         * Refresh hover immediately\n\t         */\n\t        refreshHoverImmediately: function () {\n\t            this._needsRefreshHover = false;\n\t            this.painter.refreshHover && this.painter.refreshHover();\n\t        },\n\t\n\t        /**\n\t         * Resize the canvas.\n\t         * Should be invoked when container size is changed\n\t         * @param {Object} [opts]\n\t         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t         */\n\t        resize: function(opts) {\n\t            opts = opts || {};\n\t            this.painter.resize(opts.width, opts.height);\n\t            this.handler.resize();\n\t        },\n\t\n\t        /**\n\t         * Stop and clear all animation immediately\n\t         */\n\t        clearAnimation: function () {\n\t            this.animation.clear();\n\t        },\n\t\n\t        /**\n\t         * Get container width\n\t         */\n\t        getWidth: function() {\n\t            return this.painter.getWidth();\n\t        },\n\t\n\t        /**\n\t         * Get container height\n\t         */\n\t        getHeight: function() {\n\t            return this.painter.getHeight();\n\t        },\n\t\n\t        /**\n\t         * Export the canvas as Base64 URL\n\t         * @param {string} type\n\t         * @param {string} [backgroundColor='#fff']\n\t         * @return {string} Base64 URL\n\t         */\n\t        // toDataURL: function(type, backgroundColor) {\n\t        //     return this.painter.getRenderedCanvas({\n\t        //         backgroundColor: backgroundColor\n\t        //     }).toDataURL(type);\n\t        // },\n\t\n\t        /**\n\t         * Converting a path to image.\n\t         * It has much better performance of drawing image rather than drawing a vector path.\n\t         * @param {module:zrender/graphic/Path} e\n\t         * @param {number} width\n\t         * @param {number} height\n\t         */\n\t        pathToImage: function(e, dpr) {\n\t            return this.painter.pathToImage(e, dpr);\n\t        },\n\t\n\t        /**\n\t         * Set default cursor\n\t         * @param {string} [cursorStyle='default']  crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            this.handler.setCursorStyle(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * Bind event\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {Function} eventHandler Handler function\n\t         * @param {Object} [context] Context object\n\t         */\n\t        on: function(eventName, eventHandler, context) {\n\t            this.handler.on(eventName, eventHandler, context);\n\t        },\n\t\n\t        /**\n\t         * Unbind event\n\t         * @param {string} eventName Event name\n\t         * @param {Function} [eventHandler] Handler function\n\t         */\n\t        off: function(eventName, eventHandler) {\n\t            this.handler.off(eventName, eventHandler);\n\t        },\n\t\n\t        /**\n\t         * Trigger event manually\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {event=} event Event object\n\t         */\n\t        trigger: function (eventName, event) {\n\t            this.handler.trigger(eventName, event);\n\t        },\n\t\n\t\n\t        /**\n\t         * Clear all objects and the canvas.\n\t         */\n\t        clear: function () {\n\t            this.storage.delRoot();\n\t            this.painter.clear();\n\t        },\n\t\n\t        /**\n\t         * Dispose self.\n\t         */\n\t        dispose: function () {\n\t            this.animation.stop();\n\t\n\t            this.clear();\n\t            this.storage.dispose();\n\t            this.painter.dispose();\n\t            this.handler.dispose();\n\t\n\t            this.animation =\n\t            this.storage =\n\t            this.painter =\n\t            this.handler = null;\n\t\n\t            delInstance(this.id);\n\t        }\n\t    };\n\t\n\t    module.exports = zrender;\n\t\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/**\n\t * zrender: id\n\t *\n\t * @author errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var idStart = 0x0907;\n\t\n\t    module.exports = function () {\n\t        return idStart++;\n\t    };\n\t\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/**\n\t * echarts\n\t *\n\t * @desc echartsCanvasJavascript\n\t * @author firede[firede@firede.us]\n\t * @desc thanks zepto.\n\t */\n\t\n\t    var env = {};\n\t    if (typeof navigator === 'undefined') {\n\t        // In node\n\t        env = {\n\t            browser: {},\n\t            os: {},\n\t            node: true,\n\t            // Assume canvas is supported\n\t            canvasSupported: true\n\t        };\n\t    }\n\t    else {\n\t        env = detect(navigator.userAgent);\n\t    }\n\t\n\t    module.exports = env;\n\t\n\t    // Zepto.js\n\t    // (c) 2010-2013 Thomas Fuchs\n\t    // Zepto.js may be freely distributed under the MIT license.\n\t\n\t    function detect(ua) {\n\t        var os = {};\n\t        var browser = {};\n\t        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t        // var touchpad = webos && ua.match(/TouchPad/);\n\t        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t        // var playbook = ua.match(/PlayBook/);\n\t        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n\t        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n\t            // IE 11 Trident/7.0; rv:11.0\n\t            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\t\n\t        var weChat = (/micromessenger/i).test(ua);\n\t\n\t        // Todo: clean this up with a better OS/browser seperation:\n\t        // - discern (more) between multiple browsers on android\n\t        // - decide if kindle fire in silk mode is android or not\n\t        // - Firefox on Android doesn't specify the Android version\n\t        // - possibly devide in os, device and browser hashes\n\t\n\t        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t\n\t        // if (android) os.android = true, os.version = android[2];\n\t        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t        // if (webos) os.webos = true, os.version = webos[2];\n\t        // if (touchpad) os.touchpad = true;\n\t        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t        // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t        // if (playbook) browser.playbook = true;\n\t        // if (kindle) os.kindle = true, os.version = kindle[1];\n\t        // if (silk) browser.silk = true, browser.version = silk[1];\n\t        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t        if (firefox) {\n\t            browser.firefox = true;\n\t            browser.version = firefox[1];\n\t        }\n\t        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t        // if (webview) browser.webview = true;\n\t\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t\n\t        if (edge) {\n\t            browser.edge = true;\n\t            browser.version = edge[1];\n\t        }\n\t\n\t        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n\t        // not be set on win phone. So we do not consider Win Phone.\n\t        if (weChat) {\n\t            browser.weChat = true;\n\t        }\n\t\n\t        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t\n\t        return {\n\t            browser: browser,\n\t            os: os,\n\t            node: false,\n\t            // canvas\n\t            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n\t            canvasSupported : document.createElement('canvas').getContext ? true : false,\n\t            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n\t            // works on most browsers\n\t            // IE10/11 does not support touch event, and MS Edge supports them but not by\n\t            // default, so we dont check navigator.maxTouchPoints for them here.\n\t            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t            // <http://caniuse.com/#search=pointer%20event>.\n\t            pointerEventsSupported: 'onpointerdown' in window\n\t                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n\t                // events currently. So we dont use that on other browsers unless tested sufficiently.\n\t                // Although IE 10 supports pointer event, it use old style and is different from the\n\t                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n\t                && (browser.edge || (browser.ie && browser.version >= 11))\n\t        };\n\t    }\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/core/util\n\t */\n\t\n\t\n\t    // mergeDate\n\t    var BUILTIN_OBJECT = {\n\t        '[object Function]': 1,\n\t        '[object RegExp]': 1,\n\t        '[object Date]': 1,\n\t        '[object Error]': 1,\n\t        '[object CanvasGradient]': 1,\n\t        '[object CanvasPattern]': 1,\n\t        // For node-canvas\n\t        '[object Image]': 1,\n\t        '[object Canvas]': 1\n\t    };\n\t\n\t    var TYPED_ARRAY = {\n\t        '[object Int8Array]': 1,\n\t        '[object Uint8Array]': 1,\n\t        '[object Uint8ClampedArray]': 1,\n\t        '[object Int16Array]': 1,\n\t        '[object Uint16Array]': 1,\n\t        '[object Int32Array]': 1,\n\t        '[object Uint32Array]': 1,\n\t        '[object Float32Array]': 1,\n\t        '[object Float64Array]': 1\n\t    };\n\t\n\t    var objToString = Object.prototype.toString;\n\t\n\t    var arrayProto = Array.prototype;\n\t    var nativeForEach = arrayProto.forEach;\n\t    var nativeFilter = arrayProto.filter;\n\t    var nativeSlice = arrayProto.slice;\n\t    var nativeMap = arrayProto.map;\n\t    var nativeReduce = arrayProto.reduce;\n\t\n\t    /**\n\t     * Those data types can be cloned:\n\t     *     Plain object, Array, TypedArray, number, string, null, undefined.\n\t     * Those data types will be assgined using the orginal data:\n\t     *     BUILTIN_OBJECT\n\t     * Instance of user defined class will be cloned to a plain object, without\n\t     * properties in prototype.\n\t     * Other data types is not supported (not sure what will happen).\n\t     *\n\t     * Caution: do not support clone Date, for performance consideration.\n\t     * (There might be a large number of date in `series.data`).\n\t     * So date should not be modified in and out of echarts.\n\t     *\n\t     * @param {*} source\n\t     * @return {*} new\n\t     */\n\t    function clone(source) {\n\t        if (source == null || typeof source != 'object') {\n\t            return source;\n\t        }\n\t\n\t        var result = source;\n\t        var typeStr = objToString.call(source);\n\t\n\t        if (typeStr === '[object Array]') {\n\t            result = [];\n\t            for (var i = 0, len = source.length; i < len; i++) {\n\t                result[i] = clone(source[i]);\n\t            }\n\t        }\n\t        else if (TYPED_ARRAY[typeStr]) {\n\t            result = source.constructor.from(source);\n\t        }\n\t        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n\t            result = {};\n\t            for (var key in source) {\n\t                if (source.hasOwnProperty(key)) {\n\t                    result[key] = clone(source[key]);\n\t                }\n\t            }\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolean} [overwrite=false]\n\t     */\n\t    function merge(target, source, overwrite) {\n\t        // We should escapse that source is string\n\t        // and enter for ... in ...\n\t        if (!isObject(source) || !isObject(target)) {\n\t            return overwrite ? clone(source) : target;\n\t        }\n\t\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                var targetProp = target[key];\n\t                var sourceProp = source[key];\n\t\n\t                if (isObject(sourceProp)\n\t                    && isObject(targetProp)\n\t                    && !isArray(sourceProp)\n\t                    && !isArray(targetProp)\n\t                    && !isDom(sourceProp)\n\t                    && !isDom(targetProp)\n\t                    && !isBuiltInObject(sourceProp)\n\t                    && !isBuiltInObject(targetProp)\n\t                    && !isPrimitive(sourceProp)\n\t                    && !isPrimitive(targetProp)\n\t                ) {\n\t                    // merge\n\t                    merge(targetProp, sourceProp, overwrite);\n\t                }\n\t                else if (overwrite || !(key in target)) {\n\t                    // overwritetrue\n\t                    // NOTE target[key] \n\t                    target[key] = clone(source[key], true);\n\t                }\n\t            }\n\t        }\n\t\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t     * @param {boolean} [overwrite=false]\n\t     * @return {*} target\n\t     */\n\t    function mergeAll(targetAndSources, overwrite) {\n\t        var result = targetAndSources[0];\n\t        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t            result = merge(result, targetAndSources[i], overwrite);\n\t        }\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function extend(target, source) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolen} [overlay=false]\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function defaults(target, source, overlay) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)\n\t                && (overlay ? source[key] != null : target[key] == null)\n\t            ) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    function createCanvas() {\n\t        return document.createElement('canvas');\n\t    }\n\t    // FIXME\n\t    var _ctx;\n\t    function getContext() {\n\t        if (!_ctx) {\n\t            // Use util.createCanvas instead of createCanvas\n\t            // because createCanvas may be overwritten in different environment\n\t            _ctx = util.createCanvas().getContext('2d');\n\t        }\n\t        return _ctx;\n\t    }\n\t\n\t    /**\n\t     * index\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function indexOf(array, value) {\n\t        if (array) {\n\t            if (array.indexOf) {\n\t                return array.indexOf(value);\n\t            }\n\t            for (var i = 0, len = array.length; i < len; i++) {\n\t                if (array[i] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    /**\n\t     * \n\t     *\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} clazz \n\t     * @param {Function} baseClazz \n\t     */\n\t    function inherits(clazz, baseClazz) {\n\t        var clazzPrototype = clazz.prototype;\n\t        function F() {}\n\t        F.prototype = baseClazz.prototype;\n\t        clazz.prototype = new F();\n\t\n\t        for (var prop in clazzPrototype) {\n\t            clazz.prototype[prop] = clazzPrototype[prop];\n\t        }\n\t        clazz.prototype.constructor = clazz;\n\t        clazz.superClass = baseClazz;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Function} target\n\t     * @param {Object|Function} sorce\n\t     * @param {boolean} overlay\n\t     */\n\t    function mixin(target, source, overlay) {\n\t        target = 'prototype' in target ? target.prototype : target;\n\t        source = 'prototype' in source ? source.prototype : source;\n\t\n\t        defaults(target, source, overlay);\n\t    }\n\t\n\t    /**\n\t     * @param {Array|TypedArray} data\n\t     */\n\t    function isArrayLike(data) {\n\t        if (! data) {\n\t            return;\n\t        }\n\t        if (typeof data == 'string') {\n\t            return false;\n\t        }\n\t        return typeof data.length == 'number';\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     */\n\t    function each(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.forEach && obj.forEach === nativeForEach) {\n\t            obj.forEach(cb, context);\n\t        }\n\t        else if (obj.length === +obj.length) {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                cb.call(context, obj[i], i, obj);\n\t            }\n\t        }\n\t        else {\n\t            for (var key in obj) {\n\t                if (obj.hasOwnProperty(key)) {\n\t                    cb.call(context, obj[key], key, obj);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function map(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.map && obj.map === nativeMap) {\n\t            return obj.map(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                result.push(cb.call(context, obj[i], i, obj));\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {Object} [memo]\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function reduce(obj, cb, memo, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.reduce && obj.reduce === nativeReduce) {\n\t            return obj.reduce(cb, memo, context);\n\t        }\n\t        else {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                memo = cb.call(context, memo, obj[i], i, obj);\n\t            }\n\t            return memo;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function filter(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.filter && obj.filter === nativeFilter) {\n\t            return obj.filter(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                if (cb.call(context, obj[i], i, obj)) {\n\t                    result.push(obj[i]);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function find(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        for (var i = 0, len = obj.length; i < len; i++) {\n\t            if (cb.call(context, obj[i], i, obj)) {\n\t                return obj[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @param {*} context\n\t     * @return {Function}\n\t     */\n\t    function bind(func, context) {\n\t        var args = nativeSlice.call(arguments, 2);\n\t        return function () {\n\t            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @return {Function}\n\t     */\n\t    function curry(func) {\n\t        var args = nativeSlice.call(arguments, 1);\n\t        return function () {\n\t            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isArray(value) {\n\t        return objToString.call(value) === '[object Array]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isFunction(value) {\n\t        return typeof value === 'function';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isString(value) {\n\t        return objToString.call(value) === '[object String]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isObject(value) {\n\t        // Avoid a V8 JIT bug in Chrome 19-20.\n\t        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t        var type = typeof value;\n\t        return type === 'function' || (!!value && type == 'object');\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isBuiltInObject(value) {\n\t        return !!BUILTIN_OBJECT[objToString.call(value)];\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isDom(value) {\n\t        return typeof value === 'object'\n\t            && typeof value.nodeType === 'number'\n\t            && typeof value.ownerDocument === 'object';\n\t    }\n\t\n\t    /**\n\t     * Whether is exactly NaN. Notice isNaN('a') returns true.\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function eqNaN(value) {\n\t        return value !== value;\n\t    }\n\t\n\t    /**\n\t     * If value1 is not null, then return value1, otherwise judget rest of values.\n\t     * @memberOf module:zrender/core/util\n\t     * @return {*} Final value\n\t     */\n\t    function retrieve(values) {\n\t        for (var i = 0, len = arguments.length; i < len; i++) {\n\t            if (arguments[i] != null) {\n\t                return arguments[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} arr\n\t     * @param {number} startIndex\n\t     * @param {number} endIndex\n\t     * @return {Array}\n\t     */\n\t    function slice() {\n\t        return Function.call.apply(nativeSlice, arguments);\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {boolean} condition\n\t     * @param {string} message\n\t     */\n\t    function assert(condition, message) {\n\t        if (!condition) {\n\t            throw new Error(message);\n\t        }\n\t    }\n\t\n\t    var primitiveKey = '__ec_primitive__';\n\t    /**\n\t     * Set an object as primitive to be ignored traversing children in clone or merge\n\t     */\n\t    function setAsPrimitive(obj) {\n\t        obj[primitiveKey] = true;\n\t    }\n\t\n\t    function isPrimitive(obj) {\n\t        return obj[primitiveKey];\n\t    }\n\t\n\t    var util = {\n\t        inherits: inherits,\n\t        mixin: mixin,\n\t        clone: clone,\n\t        merge: merge,\n\t        mergeAll: mergeAll,\n\t        extend: extend,\n\t        defaults: defaults,\n\t        getContext: getContext,\n\t        createCanvas: createCanvas,\n\t        indexOf: indexOf,\n\t        slice: slice,\n\t        find: find,\n\t        isArrayLike: isArrayLike,\n\t        each: each,\n\t        map: map,\n\t        reduce: reduce,\n\t        filter: filter,\n\t        bind: bind,\n\t        curry: curry,\n\t        isArray: isArray,\n\t        isString: isString,\n\t        isObject: isObject,\n\t        isFunction: isFunction,\n\t        isBuiltInObject: isBuiltInObject,\n\t        isDom: isDom,\n\t        eqNaN: eqNaN,\n\t        retrieve: retrieve,\n\t        assert: assert,\n\t        setAsPrimitive: setAsPrimitive,\n\t        noop: function () {}\n\t    };\n\t    module.exports = util;\n\t\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Handler\n\t * @module zrender/Handler\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (shenyi.914@gmail.com)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(6);\n\t    var Draggable = __webpack_require__(8);\n\t\n\t    var Eventful = __webpack_require__(9);\n\t\n\t    function makeEventPacket(eveType, target, event) {\n\t        return {\n\t            type: eveType,\n\t            event: event,\n\t            target: target,\n\t            cancelBubble: false,\n\t            offsetX: event.zrX,\n\t            offsetY: event.zrY,\n\t            gestureEvent: event.gestureEvent,\n\t            pinchX: event.pinchX,\n\t            pinchY: event.pinchY,\n\t            pinchScale: event.pinchScale,\n\t            wheelDelta: event.zrDelta,\n\t            zrByTouch: event.zrByTouch\n\t        };\n\t    }\n\t\n\t    function EmptyProxy () {}\n\t    EmptyProxy.prototype.dispose = function () {};\n\t\n\t    var handlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n\t    ];\n\t    /**\n\t     * @alias module:zrender/Handler\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Eventful\n\t     * @param {module:zrender/Storage} storage Storage instance.\n\t     * @param {module:zrender/Painter} painter Painter instance.\n\t     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n\t     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n\t     */\n\t    var Handler = function(storage, painter, proxy, painterRoot) {\n\t        Eventful.call(this);\n\t\n\t        this.storage = storage;\n\t\n\t        this.painter = painter;\n\t\n\t        this.painterRoot = painterRoot;\n\t\n\t        proxy = proxy || new EmptyProxy();\n\t\n\t        /**\n\t         * Proxy of event. can be Dom, WebGLSurface, etc.\n\t         */\n\t        this.proxy = proxy;\n\t\n\t        // Attach handler\n\t        proxy.handler = this;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._hovered;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Date}\n\t         */\n\t        this._lastTouchMoment;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastX;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastY;\n\t\n\t\n\t        Draggable.call(this);\n\t\n\t        util.each(handlerNames, function (name) {\n\t            proxy.on && proxy.on(name, this[name], this);\n\t        }, this);\n\t    };\n\t\n\t    Handler.prototype = {\n\t\n\t        constructor: Handler,\n\t\n\t        mousemove: function (event) {\n\t            var x = event.zrX;\n\t            var y = event.zrY;\n\t\n\t            var hovered = this.findHover(x, y, null);\n\t            var lastHovered = this._hovered;\n\t            var proxy = this.proxy;\n\t\n\t            this._hovered = hovered;\n\t\n\t            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\t\n\t            // Mouse out on previous hovered element\n\t            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n\t                this.dispatchToElement(lastHovered, 'mouseout', event);\n\t            }\n\t\n\t            // Mouse moving on one element\n\t            this.dispatchToElement(hovered, 'mousemove', event);\n\t\n\t            // Mouse over on a new element\n\t            if (hovered && hovered !== lastHovered) {\n\t                this.dispatchToElement(hovered, 'mouseover', event);\n\t            }\n\t        },\n\t\n\t        mouseout: function (event) {\n\t            this.dispatchToElement(this._hovered, 'mouseout', event);\n\t\n\t            // There might be some doms created by upper layer application\n\t            // at the same level of painter.getViewportRoot() (e.g., tooltip\n\t            // dom created by echarts), where 'globalout' event should not\n\t            // be triggered when mouse enters these doms. (But 'mouseout'\n\t            // should be triggered at the original hovered element as usual).\n\t            var element = event.toElement || event.relatedTarget;\n\t            var innerDom;\n\t            do {\n\t                element = element && element.parentNode;\n\t            }\n\t            while (element && element.nodeType != 9 && !(\n\t                innerDom = element === this.painterRoot\n\t            ));\n\t\n\t            !innerDom && this.trigger('globalout', {event: event});\n\t        },\n\t\n\t        /**\n\t         * Resize\n\t         */\n\t        resize: function (event) {\n\t            this._hovered = null;\n\t        },\n\t\n\t        /**\n\t         * Dispatch event\n\t         * @param {string} eventName\n\t         * @param {event=} eventArgs\n\t         */\n\t        dispatch: function (eventName, eventArgs) {\n\t            var handler = this[eventName];\n\t            handler && handler.call(this, eventArgs);\n\t        },\n\t\n\t        /**\n\t         * Dispose\n\t         */\n\t        dispose: function () {\n\t\n\t            this.proxy.dispose();\n\t\n\t            this.storage =\n\t            this.proxy =\n\t            this.painter = null;\n\t        },\n\t\n\t        /**\n\t         * cursor style\n\t         * @param {string} [cursorStyle='default']  crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            var proxy = this.proxy;\n\t            proxy.setCursor && proxy.setCursor(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * \n\t         *\n\t         * @private\n\t         * @param {Object} targetEl \n\t         * @param {string} eventName \n\t         * @param {Object} event \n\t         */\n\t        dispatchToElement: function (targetEl, eventName, event) {\n\t            var eventHandler = 'on' + eventName;\n\t            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\t\n\t            var el = targetEl;\n\t\n\t            while (el) {\n\t                el[eventHandler]\n\t                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t\n\t                el.trigger(eventName, eventPacket);\n\t\n\t                el = el.parent;\n\t\n\t                if (eventPacket.cancelBubble) {\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (!eventPacket.cancelBubble) {\n\t                //  zrender \n\t                this.trigger(eventName, eventPacket);\n\t                // \n\t                //  click  dispose painter \n\t                this.painter && this.painter.eachOtherLayer(function (layer) {\n\t                    if (typeof(layer[eventHandler]) == 'function') {\n\t                        layer[eventHandler].call(layer, eventPacket);\n\t                    }\n\t                    if (layer.trigger) {\n\t                        layer.trigger(eventName, eventPacket);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @param {module:zrender/graphic/Displayable} exclude\n\t         * @method\n\t         */\n\t        findHover: function(x, y, exclude) {\n\t            var list = this.storage.getDisplayList();\n\t            for (var i = list.length - 1; i >= 0 ; i--) {\n\t                if (!list[i].silent\n\t                 && list[i] !== exclude\n\t                 // getDisplayList may include ignored item in VML mode\n\t                 && !list[i].ignore\n\t                 && isHover(list[i], x, y)) {\n\t                    return list[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    // Common handlers\n\t    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t        Handler.prototype[name] = function (event) {\n\t            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t            var hovered = this.findHover(event.zrX, event.zrY, null);\n\t\n\t            if (name === 'mousedown') {\n\t                this._downel = hovered;\n\t                // In case click triggered before mouseup\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'mosueup') {\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'click') {\n\t                if (this._downel !== this._upel) {\n\t                    return;\n\t                }\n\t            }\n\t\n\t            this.dispatchToElement(hovered, name, event);\n\t        };\n\t    });\n\t\n\t    function isHover(displayable, x, y) {\n\t        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t            var el = displayable;\n\t            while (el) {\n\t                // If ancestor is silent or clipped by ancestor\n\t                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n\t                    return false;\n\t                }\n\t                el = el.parent;\n\t            }\n\t            return true;\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    util.mixin(Handler, Eventful);\n\t    util.mixin(Handler, Draggable);\n\t\n\t    module.exports = Handler;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t// TODO Draggable for group\n\t// FIXME Draggable on element which has parent rotation or scale\n\t\n\t    function Draggable() {\n\t\n\t        this.on('mousedown', this._dragStart, this);\n\t        this.on('mousemove', this._drag, this);\n\t        this.on('mouseup', this._dragEnd, this);\n\t        this.on('globalout', this._dragEnd, this);\n\t        // this._dropTarget = null;\n\t        // this._draggingTarget = null;\n\t\n\t        // this._x = 0;\n\t        // this._y = 0;\n\t    }\n\t\n\t    Draggable.prototype = {\n\t\n\t        constructor: Draggable,\n\t\n\t        _dragStart: function (e) {\n\t            var draggingTarget = e.target;\n\t            if (draggingTarget && draggingTarget.draggable) {\n\t                this._draggingTarget = draggingTarget;\n\t                draggingTarget.dragging = true;\n\t                this._x = e.offsetX;\n\t                this._y = e.offsetY;\n\t\n\t                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n\t            }\n\t        },\n\t\n\t        _drag: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t\n\t                var x = e.offsetX;\n\t                var y = e.offsetY;\n\t\n\t                var dx = x - this._x;\n\t                var dy = y - this._y;\n\t                this._x = x;\n\t                this._y = y;\n\t\n\t                draggingTarget.drift(dx, dy, e);\n\t                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\t\n\t                var dropTarget = this.findHover(x, y, draggingTarget);\n\t                var lastDropTarget = this._dropTarget;\n\t                this._dropTarget = dropTarget;\n\t\n\t                if (draggingTarget !== dropTarget) {\n\t                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n\t                    }\n\t                    if (dropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _dragEnd: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t\n\t            if (draggingTarget) {\n\t                draggingTarget.dragging = false;\n\t            }\n\t\n\t            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\t\n\t            if (this._dropTarget) {\n\t                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n\t            }\n\t\n\t            this._draggingTarget = null;\n\t            this._dropTarget = null;\n\t        }\n\t\n\t    };\n\t\n\t    module.exports = Draggable;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/**\n\t * \n\t * @module zrender/mixin/Eventful\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var arrySlice = Array.prototype.slice;\n\t\n\t    /**\n\t     * \n\t     * @alias module:zrender/mixin/Eventful\n\t     * @constructor\n\t     */\n\t    var Eventful = function () {\n\t        this._$handlers = {};\n\t    };\n\t\n\t    Eventful.prototype = {\n\t\n\t        constructor: Eventful,\n\t\n\t        /**\n\t         * trigger\n\t         *\n\t         * @param {string} event \n\t         * @param {Function} handler \n\t         * @param {Object} context\n\t         */\n\t        one: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: true,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {string} event \n\t         * @param {Function} handler \n\t         * @param {Object} [context]\n\t         */\n\t        on: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: false,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {string}  event\n\t         * @return {boolean}\n\t         */\n\t        isSilent: function (event) {\n\t            var _h = this._$handlers;\n\t            return _h[event] && _h[event].length;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {string} event \n\t         * @param {Function} [handler] \n\t         */\n\t        off: function (event, handler) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!event) {\n\t                this._$handlers = {};\n\t                return this;\n\t            }\n\t\n\t            if (handler) {\n\t                if (_h[event]) {\n\t                    var newList = [];\n\t                    for (var i = 0, l = _h[event].length; i < l; i++) {\n\t                        if (_h[event][i]['h'] != handler) {\n\t                            newList.push(_h[event][i]);\n\t                        }\n\t                    }\n\t                    _h[event] = newList;\n\t                }\n\t\n\t                if (_h[event] && _h[event].length === 0) {\n\t                    delete _h[event];\n\t                }\n\t            }\n\t            else {\n\t                delete _h[event];\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         *\n\t         * @param {string} type \n\t         */\n\t        trigger: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 3) {\n\t                    args = arrySlice.call(args, 1);\n\t                }\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(_h[i]['ctx']);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(_h[i]['ctx'], args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * context, context\n\t         * @param {string} type \n\t         */\n\t        triggerWithContext: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 4) {\n\t                    args = arrySlice.call(args, 1, args.length - 1);\n\t                }\n\t                var ctx = args[args.length - 1];\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(ctx);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(ctx, args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(ctx, args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(ctx, args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    //  onxxxx \n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onclick\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseout\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousemove\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousewheel\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousedown\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseup\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrag\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragstart\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragend\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragenter\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragleave\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrop\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t\n\t    module.exports = Eventful;\n\t\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Storage\n\t * @module zrender/Storage\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t * @author errorrik (errorrik@gmail.com)\n\t * @author pissang (https://github.com/pissang/)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(6);\n\t    var env = __webpack_require__(5);\n\t\n\t    var Group = __webpack_require__(11);\n\t\n\t    // Use timsort because in most case elements are partially sorted\n\t    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n\t    var timsort = __webpack_require__(25);\n\t\n\t    function shapeCompareFunc(a, b) {\n\t        if (a.zlevel === b.zlevel) {\n\t            if (a.z === b.z) {\n\t                // if (a.z2 === b.z2) {\n\t                //     // FIXME Slow has renderidx compare\n\t                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t                //     return a.__renderidx - b.__renderidx;\n\t                // }\n\t                return a.z2 - b.z2;\n\t            }\n\t            return a.z - b.z;\n\t        }\n\t        return a.zlevel - b.zlevel;\n\t    }\n\t    /**\n\t     *  (M)\n\t     * @alias module:zrender/Storage\n\t     * @constructor\n\t     */\n\t    var Storage = function () {\n\t        // idmap\n\t        this._elements = {};\n\t\n\t        this._roots = [];\n\t\n\t        this._displayList = [];\n\t\n\t        this._displayListLen = 0;\n\t    };\n\t\n\t    Storage.prototype = {\n\t\n\t        constructor: Storage,\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         *\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._roots.length; i++) {\n\t                this._roots[i].traverse(cb, context);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} [update=false] \n\t         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n\t         *\n\t         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n\t         * @return {Array.<module:zrender/graphic/Displayable>}\n\t         */\n\t        getDisplayList: function (update, includeIgnore) {\n\t            includeIgnore = includeIgnore || false;\n\t            if (update) {\n\t                this.updateDisplayList(includeIgnore);\n\t            }\n\t            return this._displayList;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * GroupShapeShape\n\t         * zlevel > z > \n\t         * @param {boolean} [includeIgnore=false]  ignore \n\t         */\n\t        updateDisplayList: function (includeIgnore) {\n\t            this._displayListLen = 0;\n\t            var roots = this._roots;\n\t            var displayList = this._displayList;\n\t            for (var i = 0, len = roots.length; i < len; i++) {\n\t                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t            }\n\t            displayList.length = this._displayListLen;\n\t\n\t            // for (var i = 0, len = displayList.length; i < len; i++) {\n\t            //     displayList[i].__renderidx = i;\n\t            // }\n\t\n\t            // displayList.sort(shapeCompareFunc);\n\t            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t        },\n\t\n\t        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t\n\t            if (el.ignore && !includeIgnore) {\n\t                return;\n\t            }\n\t\n\t            el.beforeUpdate();\n\t\n\t            if (el.__dirty) {\n\t\n\t                el.update();\n\t\n\t            }\n\t\n\t            el.afterUpdate();\n\t\n\t            var userSetClipPath = el.clipPath;\n\t            if (userSetClipPath) {\n\t\n\t                // FIXME \n\t                if (clipPaths) {\n\t                    clipPaths = clipPaths.slice();\n\t                }\n\t                else {\n\t                    clipPaths = [];\n\t                }\n\t\n\t                var currentClipPath = userSetClipPath;\n\t                var parentClipPath = el;\n\t                // Recursively add clip path\n\t                while (currentClipPath) {\n\t                    // clipPath  clipPath \n\t                    currentClipPath.parent = parentClipPath;\n\t                    currentClipPath.updateTransform();\n\t\n\t                    clipPaths.push(currentClipPath);\n\t\n\t                    parentClipPath = currentClipPath;\n\t                    currentClipPath = currentClipPath.clipPath;\n\t                }\n\t            }\n\t\n\t            if (el.isGroup) {\n\t                var children = el._children;\n\t\n\t                for (var i = 0; i < children.length; i++) {\n\t                    var child = children[i];\n\t\n\t                    // Force to mark as dirty if group is dirty\n\t                    // FIXME __dirtyPath ?\n\t                    if (el.__dirty) {\n\t                        child.__dirty = true;\n\t                    }\n\t\n\t                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t                }\n\t\n\t                // Mark group clean here\n\t                el.__dirty = false;\n\t\n\t            }\n\t            else {\n\t                el.__clipPaths = clipPaths;\n\t\n\t                this._displayList[this._displayListLen++] = el;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * (Shape)(Group)\n\t         * @param {module:zrender/Element} el\n\t         */\n\t        addRoot: function (el) {\n\t            // Element has been added\n\t            if (this._elements[el.id]) {\n\t                return;\n\t            }\n\t\n\t            if (el instanceof Group) {\n\t                el.addChildrenToStorage(this);\n\t            }\n\t\n\t            this.addToMap(el);\n\t            this._roots.push(el);\n\t        },\n\t\n\t        /**\n\t         * (Shape)(Group)\n\t         * @param {string|Array.<string>} [elId] Storage\n\t         */\n\t        delRoot: function (elId) {\n\t            if (elId == null) {\n\t                // elId\n\t                for (var i = 0; i < this._roots.length; i++) {\n\t                    var root = this._roots[i];\n\t                    if (root instanceof Group) {\n\t                        root.delChildrenFromStorage(this);\n\t                    }\n\t                }\n\t\n\t                this._elements = {};\n\t                this._roots = [];\n\t                this._displayList = [];\n\t                this._displayListLen = 0;\n\t\n\t                return;\n\t            }\n\t\n\t            if (elId instanceof Array) {\n\t                for (var i = 0, l = elId.length; i < l; i++) {\n\t                    this.delRoot(elId[i]);\n\t                }\n\t                return;\n\t            }\n\t\n\t            var el;\n\t            if (typeof(elId) == 'string') {\n\t                el = this._elements[elId];\n\t            }\n\t            else {\n\t                el = elId;\n\t            }\n\t\n\t            var idx = util.indexOf(this._roots, el);\n\t            if (idx >= 0) {\n\t                this.delFromMap(el.id);\n\t                this._roots.splice(idx, 1);\n\t                if (el instanceof Group) {\n\t                    el.delChildrenFromStorage(this);\n\t                }\n\t            }\n\t        },\n\t\n\t        addToMap: function (el) {\n\t            if (el instanceof Group) {\n\t                el.__storage = this;\n\t            }\n\t            el.dirty(false);\n\t\n\t            this._elements[el.id] = el;\n\t\n\t            return this;\n\t        },\n\t\n\t        get: function (elId) {\n\t            return this._elements[elId];\n\t        },\n\t\n\t        delFromMap: function (elId) {\n\t            var elements = this._elements;\n\t            var el = elements[elId];\n\t            if (el) {\n\t                delete elements[elId];\n\t                if (el instanceof Group) {\n\t                    el.__storage = null;\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Storage\n\t         */\n\t        dispose: function () {\n\t            this._elements =\n\t            this._renderList =\n\t            this._roots = null;\n\t        },\n\t\n\t        displayableSortFunc: shapeCompareFunc\n\t    };\n\t\n\t    module.exports = Storage;\n\t\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * GroupGroup\n\t * @module zrender/graphic/Group\n\t * @example\n\t *     var Group = require('zrender/lib/container/Group');\n\t *     var Circle = require('zrender/lib/graphic/shape/Circle');\n\t *     var g = new Group();\n\t *     g.position[0] = 100;\n\t *     g.position[1] = 100;\n\t *     g.add(new Circle({\n\t *         style: {\n\t *             x: 100,\n\t *             y: 100,\n\t *             r: 20,\n\t *         }\n\t *     }));\n\t *     zr.add(g);\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(6);\n\t    var Element = __webpack_require__(12);\n\t    var BoundingRect = __webpack_require__(24);\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Group\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @extends module:zrender/mixin/Eventful\n\t     */\n\t    var Group = function (opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        for (var key in opts) {\n\t            if (opts.hasOwnProperty(key)) {\n\t                this[key] = opts[key];\n\t            }\n\t        }\n\t\n\t        this._children = [];\n\t\n\t        this.__storage = null;\n\t\n\t        this.__dirty = true;\n\t    };\n\t\n\t    Group.prototype = {\n\t\n\t        constructor: Group,\n\t\n\t        isGroup: true,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        type: 'group',\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/container/Group#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/Element>}\n\t         */\n\t        children: function () {\n\t            return this._children.slice();\n\t        },\n\t\n\t        /**\n\t         *  index \n\t         * @param  {number} idx\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childAt: function (idx) {\n\t            return this._children[idx];\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {string} name\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childOfName: function (name) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (children[i].name === name) {\n\t                    return children[i];\n\t                }\n\t             }\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        childCount: function () {\n\t            return this._children.length;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/Element} child\n\t         */\n\t        add: function (child) {\n\t            if (child && child !== this && child.parent !== this) {\n\t\n\t                this._children.push(child);\n\t\n\t                this._doAdd(child);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         *  nextSibling \n\t         * @param {module:zrender/Element} child\n\t         * @param {module:zrender/Element} nextSibling\n\t         */\n\t        addBefore: function (child, nextSibling) {\n\t            if (child && child !== this && child.parent !== this\n\t                && nextSibling && nextSibling.parent === this) {\n\t\n\t                var children = this._children;\n\t                var idx = children.indexOf(nextSibling);\n\t\n\t                if (idx >= 0) {\n\t                    children.splice(idx, 0, child);\n\t                    this._doAdd(child);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        _doAdd: function (child) {\n\t            if (child.parent) {\n\t                child.parent.remove(child);\n\t            }\n\t\n\t            child.parent = this;\n\t\n\t            var storage = this.__storage;\n\t            var zr = this.__zr;\n\t            if (storage && storage !== child.__storage) {\n\t\n\t                storage.addToMap(child);\n\t\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/Element} child\n\t         */\n\t        remove: function (child) {\n\t            var zr = this.__zr;\n\t            var storage = this.__storage;\n\t            var children = this._children;\n\t\n\t            var idx = zrUtil.indexOf(children, child);\n\t            if (idx < 0) {\n\t                return this;\n\t            }\n\t            children.splice(idx, 1);\n\t\n\t            child.parent = null;\n\t\n\t            if (storage) {\n\t\n\t                storage.delFromMap(child.id);\n\t\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        removeAll: function () {\n\t            var children = this._children;\n\t            var storage = this.__storage;\n\t            var child;\n\t            var i;\n\t            for (i = 0; i < children.length; i++) {\n\t                child = children[i];\n\t                if (storage) {\n\t                    storage.delFromMap(child.id);\n\t                    if (child instanceof Group) {\n\t                        child.delChildrenFromStorage(storage);\n\t                    }\n\t                }\n\t                child.parent = null;\n\t            }\n\t            children.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        eachChild: function (cb, context) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                cb.call(context, child, i);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                cb.call(context, child);\n\t\n\t                if (child.type === 'group') {\n\t                    child.traverse(cb, context);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        addChildrenToStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        delChildrenFromStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function (includeChildren) {\n\t            // TODO Caching\n\t            var rect = null;\n\t            var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t            var children = includeChildren || this._children;\n\t            var tmpMat = [];\n\t\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                if (child.ignore || child.invisible) {\n\t                    continue;\n\t                }\n\t\n\t                var childRect = child.getBoundingRect();\n\t                var transform = child.getLocalTransform(tmpMat);\n\t                // TODO\n\t                // The boundingRect cacluated by transforming original\n\t                // rect may be bigger than the actual bundingRect when rotation\n\t                // is used. (Consider a circle rotated aginst its center, where\n\t                // the actual boundingRect should be the same as that not be\n\t                // rotated.) But we can not find better approach to calculate\n\t                // actual boundingRect yet, considering performance.\n\t                if (transform) {\n\t                    tmpRect.copy(childRect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = rect || tmpRect.clone();\n\t                    rect.union(tmpRect);\n\t                }\n\t                else {\n\t                    rect = rect || childRect.clone();\n\t                    rect.union(childRect);\n\t                }\n\t            }\n\t            return rect || tmpRect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Group, Element);\n\t\n\t    module.exports = Group;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/Element\n\t */\n\t\n\t\n\t    var guid = __webpack_require__(4);\n\t    var Eventful = __webpack_require__(9);\n\t    var Transformable = __webpack_require__(13);\n\t    var Animatable = __webpack_require__(16);\n\t    var zrUtil = __webpack_require__(6);\n\t\n\t    /**\n\t     * @alias module:zrender/Element\n\t     * @constructor\n\t     * @extends {module:zrender/mixin/Animatable}\n\t     * @extends {module:zrender/mixin/Transformable}\n\t     * @extends {module:zrender/mixin/Eventful}\n\t     */\n\t    var Element = function (opts) {\n\t\n\t        Transformable.call(this, opts);\n\t        Eventful.call(this, opts);\n\t        Animatable.call(this, opts);\n\t\n\t        /**\n\t         * ID\n\t         * @type {string}\n\t         */\n\t        this.id = opts.id || guid();\n\t    };\n\t\n\t    Element.prototype = {\n\t\n\t        /**\n\t         * \n\t         * Element type\n\t         * @type {string}\n\t         */\n\t        type: 'element',\n\t\n\t        /**\n\t         * \n\t         * Element name\n\t         * @type {string}\n\t         */\n\t        name: '',\n\t\n\t        /**\n\t         * ZRender  element  zrender \n\t         * ZRender instance will be assigned when element is associated with zrender\n\t         * @name module:/zrender/Element#__zr\n\t         * @type {module:zrender/ZRender}\n\t         */\n\t        __zr: null,\n\t\n\t        /**\n\t         * true\n\t         * If ignore drawing and events of the element object\n\t         * @name module:/zrender/Element#ignore\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        ignore: false,\n\t\n\t        /**\n\t         * (shape) Group \n\t         * \n\t         * @type {module:zrender/graphic/Path}\n\t         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n\t         * @readOnly\n\t         */\n\t        clipPath: null,\n\t\n\t        /**\n\t         * Drift element\n\t         * @param  {number} dx dx on the global space\n\t         * @param  {number} dy dy on the global space\n\t         */\n\t        drift: function (dx, dy) {\n\t            switch (this.draggable) {\n\t                case 'horizontal':\n\t                    dy = 0;\n\t                    break;\n\t                case 'vertical':\n\t                    dx = 0;\n\t                    break;\n\t            }\n\t\n\t            var m = this.transform;\n\t            if (!m) {\n\t                m = this.transform = [1, 0, 0, 1, 0, 0];\n\t            }\n\t            m[4] += dx;\n\t            m[5] += dy;\n\t\n\t            this.decomposeTransform();\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         * Hook before update\n\t         */\n\t        beforeUpdate: function () {},\n\t        /**\n\t         * Hook after update\n\t         */\n\t        afterUpdate: function () {},\n\t        /**\n\t         * Update each frame\n\t         */\n\t        update: function () {\n\t            this.updateTransform();\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {},\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        attrKV: function (key, value) {\n\t            if (key === 'position' || key === 'scale' || key === 'origin') {\n\t                // Copy the array\n\t                if (value) {\n\t                    var target = this[key];\n\t                    if (!target) {\n\t                        target = this[key] = [];\n\t                    }\n\t                    target[0] = value[0];\n\t                    target[1] = value[1];\n\t                }\n\t            }\n\t            else {\n\t                this[key] = value;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Hide the element\n\t         */\n\t        hide: function () {\n\t            this.ignore = true;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * Show the element\n\t         */\n\t        show: function () {\n\t            this.ignore = false;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * @param {string|Object} key\n\t         * @param {*} value\n\t         */\n\t        attr: function (key, value) {\n\t            if (typeof key === 'string') {\n\t                this.attrKV(key, value);\n\t            }\n\t            else if (zrUtil.isObject(key)) {\n\t                for (var name in key) {\n\t                    if (key.hasOwnProperty(name)) {\n\t                        this.attrKV(name, key[name]);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.dirty(false);\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/graphic/Path} clipPath\n\t         */\n\t        setClipPath: function (clipPath) {\n\t            var zr = this.__zr;\n\t            if (zr) {\n\t                clipPath.addSelfToZr(zr);\n\t            }\n\t\n\t            // Remove previous clip path\n\t            if (this.clipPath && this.clipPath !== clipPath) {\n\t                this.removeClipPath();\n\t            }\n\t\n\t            this.clipPath = clipPath;\n\t            clipPath.__zr = zr;\n\t            clipPath.__clipTarget = this;\n\t\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         */\n\t        removeClipPath: function () {\n\t            var clipPath = this.clipPath;\n\t            if (clipPath) {\n\t                if (clipPath.__zr) {\n\t                    clipPath.removeSelfFromZr(clipPath.__zr);\n\t                }\n\t\n\t                clipPath.__zr = null;\n\t                clipPath.__clipTarget = null;\n\t                this.clipPath = null;\n\t\n\t                this.dirty(false);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        addSelfToZr: function (zr) {\n\t            this.__zr = zr;\n\t            // \n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.addAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.addSelfToZr(zr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Remove self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        removeSelfFromZr: function (zr) {\n\t            this.__zr = null;\n\t            // \n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.removeAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.removeSelfFromZr(zr);\n\t            }\n\t        }\n\t    };\n\t\n\t    zrUtil.mixin(Element, Animatable);\n\t    zrUtil.mixin(Element, Transformable);\n\t    zrUtil.mixin(Element, Eventful);\n\t\n\t    module.exports = Element;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/mixin/Transformable\n\t * @author pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var matrix = __webpack_require__(14);\n\t    var vector = __webpack_require__(15);\n\t    var mIdentity = matrix.identity;\n\t\n\t    var EPSILON = 5e-5;\n\t\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/mixin/Transformable\n\t     * @constructor\n\t     */\n\t    var Transformable = function (opts) {\n\t        opts = opts || {};\n\t        // If there are no given position, rotation, scale\n\t        if (!opts.position) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default [0, 0]\n\t             */\n\t            this.position = [0, 0];\n\t        }\n\t        if (opts.rotation == null) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default 0\n\t             */\n\t            this.rotation = 0;\n\t        }\n\t        if (!opts.scale) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default [1, 1]\n\t             */\n\t            this.scale = [1, 1];\n\t        }\n\t        /**\n\t         * \n\t         * @type {Array.<number>}\n\t         * @default null\n\t         */\n\t        this.origin = this.origin || null;\n\t    };\n\t\n\t    var transformableProto = Transformable.prototype;\n\t    transformableProto.transform = null;\n\t\n\t    /**\n\t     * \n\t     * , position, rotation, scaletransformtransform\n\t     */\n\t    transformableProto.needLocalTransform = function () {\n\t        return isNotAroundZero(this.rotation)\n\t            || isNotAroundZero(this.position[0])\n\t            || isNotAroundZero(this.position[1])\n\t            || isNotAroundZero(this.scale[0] - 1)\n\t            || isNotAroundZero(this.scale[1] - 1);\n\t    };\n\t\n\t    transformableProto.updateTransform = function () {\n\t        var parent = this.parent;\n\t        var parentHasTransform = parent && parent.transform;\n\t        var needLocalTransform = this.needLocalTransform();\n\t\n\t        var m = this.transform;\n\t        if (!(needLocalTransform || parentHasTransform)) {\n\t            m && mIdentity(m);\n\t            return;\n\t        }\n\t\n\t        m = m || matrix.create();\n\t\n\t        if (needLocalTransform) {\n\t            this.getLocalTransform(m);\n\t        }\n\t        else {\n\t            mIdentity(m);\n\t        }\n\t\n\t        // \n\t        if (parentHasTransform) {\n\t            if (needLocalTransform) {\n\t                matrix.mul(m, parent.transform, m);\n\t            }\n\t            else {\n\t                matrix.copy(m, parent.transform);\n\t            }\n\t        }\n\t        // \n\t        this.transform = m;\n\t\n\t        this.invTransform = this.invTransform || matrix.create();\n\t        matrix.invert(this.invTransform, m);\n\t    };\n\t\n\t    transformableProto.getLocalTransform = function (m) {\n\t        m = m || [];\n\t        mIdentity(m);\n\t\n\t        var origin = this.origin;\n\t\n\t        var scale = this.scale;\n\t        var rotation = this.rotation;\n\t        var position = this.position;\n\t        if (origin) {\n\t            // Translate to origin\n\t            m[4] -= origin[0];\n\t            m[5] -= origin[1];\n\t        }\n\t        matrix.scale(m, m, scale);\n\t        if (rotation) {\n\t            matrix.rotate(m, m, rotation);\n\t        }\n\t        if (origin) {\n\t            // Translate back from origin\n\t            m[4] += origin[0];\n\t            m[5] += origin[1];\n\t        }\n\t\n\t        m[4] += position[0];\n\t        m[5] += position[1];\n\t\n\t        return m;\n\t    };\n\t    /**\n\t     * transformcontext\n\t     * @param {Context2D} ctx\n\t     */\n\t    transformableProto.setTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        if (m) {\n\t            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t        }\n\t        else {\n\t            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t        }\n\t    };\n\t\n\t    transformableProto.restoreTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t    }\n\t\n\t    var tmpTransform = [];\n\t\n\t    /**\n\t     * `transform``position`, `rotation`, `scale`\n\t     */\n\t    transformableProto.decomposeTransform = function () {\n\t        if (!this.transform) {\n\t            return;\n\t        }\n\t        var parent = this.parent;\n\t        var m = this.transform;\n\t        if (parent && parent.transform) {\n\t            // Get local transform and decompose them to position, scale, rotation\n\t            matrix.mul(tmpTransform, parent.invTransform, m);\n\t            m = tmpTransform;\n\t        }\n\t        var sx = m[0] * m[0] + m[1] * m[1];\n\t        var sy = m[2] * m[2] + m[3] * m[3];\n\t        var position = this.position;\n\t        var scale = this.scale;\n\t        if (isNotAroundZero(sx - 1)) {\n\t            sx = Math.sqrt(sx);\n\t        }\n\t        if (isNotAroundZero(sy - 1)) {\n\t            sy = Math.sqrt(sy);\n\t        }\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        position[0] = m[4];\n\t        position[1] = m[5];\n\t        scale[0] = sx;\n\t        scale[1] = sy;\n\t        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t    };\n\t\n\t    /**\n\t     * Get global scale\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.getGlobalScale = function () {\n\t        var m = this.transform;\n\t        if (!m) {\n\t            return [1, 1];\n\t        }\n\t        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        return [sx, sy];\n\t    };\n\t    /**\n\t     *  shape \n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToLocal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var invTransform = this.invTransform;\n\t        if (invTransform) {\n\t            vector.applyTransform(v2, v2, invTransform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    /**\n\t     * \n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToGlobal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var transform = this.transform;\n\t        if (transform) {\n\t            vector.applyTransform(v2, v2, transform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    module.exports = Transformable;\n\t\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t    /**\n\t     * 3x2\n\t     * @exports zrender/tool/matrix\n\t     */\n\t    var matrix = {\n\t        /**\n\t         * \n\t         * @return {Float32Array|Array.<number>}\n\t         */\n\t        create : function() {\n\t            var out = new ArrayCtor(6);\n\t            matrix.identity(out);\n\t\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         */\n\t        identity : function(out) {\n\t            out[0] = 1;\n\t            out[1] = 0;\n\t            out[2] = 0;\n\t            out[3] = 1;\n\t            out[4] = 0;\n\t            out[5] = 0;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m\n\t         */\n\t        copy: function(out, m) {\n\t            out[0] = m[0];\n\t            out[1] = m[1];\n\t            out[2] = m[2];\n\t            out[3] = m[3];\n\t            out[4] = m[4];\n\t            out[5] = m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m1\n\t         * @param {Float32Array|Array.<number>} m2\n\t         */\n\t        mul : function (out, m1, m2) {\n\t            // Consider matrix.mul(m, m2, m);\n\t            // where out is the same as m2.\n\t            // So use temp variable to escape error.\n\t            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t            out[0] = out0;\n\t            out[1] = out1;\n\t            out[2] = out2;\n\t            out[3] = out3;\n\t            out[4] = out4;\n\t            out[5] = out5;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        translate : function(out, a, v) {\n\t            out[0] = a[0];\n\t            out[1] = a[1];\n\t            out[2] = a[2];\n\t            out[3] = a[3];\n\t            out[4] = a[4] + v[0];\n\t            out[5] = a[5] + v[1];\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {number} rad\n\t         */\n\t        rotate : function(out, a, rad) {\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t            var st = Math.sin(rad);\n\t            var ct = Math.cos(rad);\n\t\n\t            out[0] = aa * ct + ab * st;\n\t            out[1] = -aa * st + ab * ct;\n\t            out[2] = ac * ct + ad * st;\n\t            out[3] = -ac * st + ct * ad;\n\t            out[4] = ct * atx + st * aty;\n\t            out[5] = ct * aty - st * atx;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        scale : function(out, a, v) {\n\t            var vx = v[0];\n\t            var vy = v[1];\n\t            out[0] = a[0] * vx;\n\t            out[1] = a[1] * vy;\n\t            out[2] = a[2] * vx;\n\t            out[3] = a[3] * vy;\n\t            out[4] = a[4] * vx;\n\t            out[5] = a[5] * vy;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         */\n\t        invert : function(out, a) {\n\t\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t\n\t            var det = aa * ad - ab * ac;\n\t            if (!det) {\n\t                return null;\n\t            }\n\t            det = 1.0 / det;\n\t\n\t            out[0] = ad * det;\n\t            out[1] = -ab * det;\n\t            out[2] = -ac * det;\n\t            out[3] = aa * det;\n\t            out[4] = (ac * aty - ad * atx) * det;\n\t            out[5] = (ab * atx - aa * aty) * det;\n\t            return out;\n\t        }\n\t    };\n\t\n\t    module.exports = matrix;\n\t\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t\n\t    /**\n\t     * @typedef {Float32Array|Array.<number>} Vector2\n\t     */\n\t    /**\n\t     * \n\t     * @exports zrender/tool/vector\n\t     */\n\t    var vector = {\n\t        /**\n\t         * \n\t         * @param {number} [x=0]\n\t         * @param {number} [y=0]\n\t         * @return {Vector2}\n\t         */\n\t        create: function (x, y) {\n\t            var out = new ArrayCtor(2);\n\t            if (x == null) {\n\t                x = 0;\n\t            }\n\t            if (y == null) {\n\t                y = 0;\n\t            }\n\t            out[0] = x;\n\t            out[1] = y;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        copy: function (out, v) {\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        clone: function (v) {\n\t            var out = new ArrayCtor(2);\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {number} a\n\t         * @param {number} b\n\t         * @return {Vector2} \n\t         */\n\t        set: function (out, a, b) {\n\t            out[0] = a;\n\t            out[1] = b;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        add: function (out, v1, v2) {\n\t            out[0] = v1[0] + v2[0];\n\t            out[1] = v1[1] + v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} a\n\t         */\n\t        scaleAndAdd: function (out, v1, v2, a) {\n\t            out[0] = v1[0] + v2[0] * a;\n\t            out[1] = v1[1] + v2[1] * a;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        sub: function (out, v1, v2) {\n\t            out[0] = v1[0] - v2[0];\n\t            out[1] = v1[1] - v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        len: function (v) {\n\t            return Math.sqrt(this.lenSquare(v));\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        lenSquare: function (v) {\n\t            return v[0] * v[0] + v[1] * v[1];\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        mul: function (out, v1, v2) {\n\t            out[0] = v1[0] * v2[0];\n\t            out[1] = v1[1] * v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        div: function (out, v1, v2) {\n\t            out[0] = v1[0] / v2[0];\n\t            out[1] = v1[1] / v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        dot: function (v1, v2) {\n\t            return v1[0] * v2[0] + v1[1] * v2[1];\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {number} s\n\t         */\n\t        scale: function (out, v, s) {\n\t            out[0] = v[0] * s;\n\t            out[1] = v[1] * s;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        normalize: function (out, v) {\n\t            var d = vector.len(v);\n\t            if (d === 0) {\n\t                out[0] = 0;\n\t                out[1] = 0;\n\t            }\n\t            else {\n\t                out[0] = v[0] / d;\n\t                out[1] = v[1] / d;\n\t            }\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distance: function (v1, v2) {\n\t            return Math.sqrt(\n\t                (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n\t            );\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distanceSquare: function (v1, v2) {\n\t            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        negate: function (out, v) {\n\t            out[0] = -v[0];\n\t            out[1] = -v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} t\n\t         */\n\t        lerp: function (out, v1, v2, t) {\n\t            out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t            out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {Vector2} m\n\t         */\n\t        applyTransform: function (out, v, m) {\n\t            var x = v[0];\n\t            var y = v[1];\n\t            out[0] = m[0] * x + m[2] * y + m[4];\n\t            out[1] = m[1] * x + m[3] * y + m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        min: function (out, v1, v2) {\n\t            out[0] = Math.min(v1[0], v2[0]);\n\t            out[1] = Math.min(v1[1], v2[1]);\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        max: function (out, v1, v2) {\n\t            out[0] = Math.max(v1[0], v2[0]);\n\t            out[1] = Math.max(v1[1], v2[1]);\n\t            return out;\n\t        }\n\t    };\n\t\n\t    vector.length = vector.len;\n\t    vector.lengthSquare = vector.lenSquare;\n\t    vector.dist = vector.distance;\n\t    vector.distSquare = vector.distanceSquare;\n\t\n\t    module.exports = vector;\n\t\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/mixin/Animatable\n\t */\n\t\n\t\n\t    var Animator = __webpack_require__(17);\n\t    var util = __webpack_require__(6);\n\t    var isString = util.isString;\n\t    var isFunction = util.isFunction;\n\t    var isObject = util.isObject;\n\t    var log = __webpack_require__(22);\n\t\n\t    /**\n\t     * @alias modue:zrender/mixin/Animatable\n\t     * @constructor\n\t     */\n\t    var Animatable = function () {\n\t\n\t        /**\n\t         * @type {Array.<module:zrender/animation/Animator>}\n\t         * @readOnly\n\t         */\n\t        this.animators = [];\n\t    };\n\t\n\t    Animatable.prototype = {\n\t\n\t        constructor: Animatable,\n\t\n\t        /**\n\t         * \n\t         *\n\t         * @param {string} path a.b.c\n\t         * @param {boolean} [loop] \n\t         * @return {module:zrender/animation/Animator}\n\t         * @example:\n\t         *     el.animate('style', false)\n\t         *         .when(1000, {x: 10} )\n\t         *         .done(function(){ // Animation done })\n\t         *         .start()\n\t         */\n\t        animate: function (path, loop) {\n\t            var target;\n\t            var animatingShape = false;\n\t            var el = this;\n\t            var zr = this.__zr;\n\t            if (path) {\n\t                var pathSplitted = path.split('.');\n\t                var prop = el;\n\t                // If animating shape\n\t                animatingShape = pathSplitted[0] === 'shape';\n\t                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t                    if (!prop) {\n\t                        continue;\n\t                    }\n\t                    prop = prop[pathSplitted[i]];\n\t                }\n\t                if (prop) {\n\t                    target = prop;\n\t                }\n\t            }\n\t            else {\n\t                target = el;\n\t            }\n\t\n\t            if (!target) {\n\t                log(\n\t                    'Property \"'\n\t                    + path\n\t                    + '\" is not existed in element '\n\t                    + el.id\n\t                );\n\t                return;\n\t            }\n\t\n\t            var animators = el.animators;\n\t\n\t            var animator = new Animator(target, loop);\n\t\n\t            animator.during(function (target) {\n\t                el.dirty(animatingShape);\n\t            })\n\t            .done(function () {\n\t                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t                animators.splice(util.indexOf(animators, animator), 1);\n\t            });\n\t\n\t            animators.push(animator);\n\t\n\t            // If animate after added to the zrender\n\t            if (zr) {\n\t                zr.animation.addAnimator(animator);\n\t            }\n\t\n\t            return animator;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stopAnimation: function (forwardToLast) {\n\t            var animators = this.animators;\n\t            var len = animators.length;\n\t            for (var i = 0; i < len; i++) {\n\t                animators[i].stop(forwardToLast);\n\t            }\n\t            animators.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {Object} target\n\t         * @param {number} [time=500] Time in ms\n\t         * @param {string} [easing='linear']\n\t         * @param {number} [delay=0]\n\t         * @param {Function} [callback]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el.animateTo({\n\t         *      position: [10, 10]\n\t         *  }, function () { // done })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n\t         *  el.animateTo({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100, 'cubicOut', function () { // done })\n\t         */\n\t         // TODO Return animation key\n\t        animateTo: function (target, time, delay, easing, callback) {\n\t            // animateTo(target, time, easing, callback);\n\t            if (isString(delay)) {\n\t                callback = easing;\n\t                easing = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, delay, callback);\n\t            else if (isFunction(easing)) {\n\t                callback = easing;\n\t                easing = 'linear';\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, callback);\n\t            else if (isFunction(delay)) {\n\t                callback = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, callback)\n\t            else if (isFunction(time)) {\n\t                callback = time;\n\t                time = 500;\n\t            }\n\t            // animateTo(target)\n\t            else if (!time) {\n\t                time = 500;\n\t            }\n\t            // Stop all previous animations\n\t            this.stopAnimation();\n\t            this._animateToShallow('', this, target, time, delay, easing, callback);\n\t\n\t            // Animators may be removed immediately after start\n\t            // if there is nothing to animate\n\t            var animators = this.animators.slice();\n\t            var count = animators.length;\n\t            function done() {\n\t                count--;\n\t                if (!count) {\n\t                    callback && callback();\n\t                }\n\t            }\n\t\n\t            // No animators. This should be checked before animators[i].start(),\n\t            // because 'done' may be executed immediately if no need to animate.\n\t            if (!count) {\n\t                callback && callback();\n\t            }\n\t            // Start after all animators created\n\t            // Incase any animator is done immediately when all animation properties are not changed\n\t            for (var i = 0; i < animators.length; i++) {\n\t                animators[i]\n\t                    .done(done)\n\t                    .start(easing);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {string} path=''\n\t         * @param {Object} source=this\n\t         * @param {Object} target\n\t         * @param {number} [time=500]\n\t         * @param {number} [delay=0]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el._animateToShallow({\n\t         *      position: [10, 10]\n\t         *  })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms\n\t         *  el._animateToShallow({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100)\n\t         */\n\t        _animateToShallow: function (path, source, target, time, delay) {\n\t            var objShallow = {};\n\t            var propertyCount = 0;\n\t            for (var name in target) {\n\t                if (!target.hasOwnProperty(name)) {\n\t                    continue;\n\t                }\n\t\n\t                if (source[name] != null) {\n\t                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n\t                        this._animateToShallow(\n\t                            path ? path + '.' + name : name,\n\t                            source[name],\n\t                            target[name],\n\t                            time,\n\t                            delay\n\t                        );\n\t                    }\n\t                    else {\n\t                        objShallow[name] = target[name];\n\t                        propertyCount++;\n\t                    }\n\t                }\n\t                else if (target[name] != null) {\n\t                    // Attr directly if not has property\n\t                    // FIXME, if some property not needed for element ?\n\t                    if (!path) {\n\t                        this.attr(name, target[name]);\n\t                    }\n\t                    else {  // Shape or style\n\t                        var props = {};\n\t                        props[path] = {};\n\t                        props[path][name] = target[name];\n\t                        this.attr(props);\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (propertyCount > 0) {\n\t                this.animate(path, false)\n\t                    .when(time == null ? 500 : time, objShallow)\n\t                    .delay(delay || 0);\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    module.exports = Animatable;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/animation/Animator\n\t */\n\t\n\t\n\t    var Clip = __webpack_require__(18);\n\t    var color = __webpack_require__(20);\n\t    var util = __webpack_require__(6);\n\t    var isArrayLike = util.isArrayLike;\n\t\n\t    var arraySlice = Array.prototype.slice;\n\t\n\t    function defaultGetter(target, key) {\n\t        return target[key];\n\t    }\n\t\n\t    function defaultSetter(target, key, value) {\n\t        target[key] = value;\n\t    }\n\t\n\t    /**\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} percent\n\t     * @return {number}\n\t     */\n\t    function interpolateNumber(p0, p1, percent) {\n\t        return (p1 - p0) * percent + p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {string} p0\n\t     * @param  {string} p1\n\t     * @param  {number} percent\n\t     * @return {string}\n\t     */\n\t    function interpolateString(p0, p1, percent) {\n\t        return percent > 0.5 ? p1 : p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {number} percent\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function interpolateArray(p0, p1, percent, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = interpolateNumber(\n\t                        p0[i][j], p1[i][j], percent\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    // arr0 is source array, arr1 is target array.\n\t    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t    function fillArr(arr0, arr1, arrDim) {\n\t        var arr0Len = arr0.length;\n\t        var arr1Len = arr1.length;\n\t        if (arr0Len !== arr1Len) {\n\t            // FIXME Not work for TypedArray\n\t            var isPreviousLarger = arr0Len > arr1Len;\n\t            if (isPreviousLarger) {\n\t                // Cut the previous\n\t                arr0.length = arr1Len;\n\t            }\n\t            else {\n\t                // Fill the previous\n\t                for (var i = arr0Len; i < arr1Len; i++) {\n\t                    arr0.push(\n\t                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n\t                    );\n\t                }\n\t            }\n\t        }\n\t        // Handling NaN value\n\t        var len2 = arr0[0] && arr0[0].length;\n\t        for (var i = 0; i < arr0.length; i++) {\n\t            if (arrDim === 1) {\n\t                if (isNaN(arr0[i])) {\n\t                    arr0[i] = arr1[i];\n\t                }\n\t            }\n\t            else {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (isNaN(arr0[i][j])) {\n\t                        arr0[i][j] = arr1[i][j];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} arr0\n\t     * @param  {Array} arr1\n\t     * @param  {number} arrDim\n\t     * @return {boolean}\n\t     */\n\t    function isArraySame(arr0, arr1, arrDim) {\n\t        if (arr0 === arr1) {\n\t            return true;\n\t        }\n\t        var len = arr0.length;\n\t        if (len !== arr1.length) {\n\t            return false;\n\t        }\n\t        if (arrDim === 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                if (arr0[i] !== arr1[i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var len2 = arr0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (arr0[i][j] !== arr1[i][j]) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate array\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {Array} p2\n\t     * @param  {Array} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function catmullRomInterpolateArray(\n\t        p0, p1, p2, p3, t, t2, t3, out, arrDim\n\t    ) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = catmullRomInterpolate(\n\t                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n\t                );\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = catmullRomInterpolate(\n\t                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n\t                        t, t2, t3\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate number\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @return {number}\n\t     */\n\t    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    function cloneValue(value) {\n\t        if (isArrayLike(value)) {\n\t            var len = value.length;\n\t            if (isArrayLike(value[0])) {\n\t                var ret = [];\n\t                for (var i = 0; i < len; i++) {\n\t                    ret.push(arraySlice.call(value[i]));\n\t                }\n\t                return ret;\n\t            }\n\t\n\t            return arraySlice.call(value);\n\t        }\n\t\n\t        return value;\n\t    }\n\t\n\t    function rgba2String(rgba) {\n\t        rgba[0] = Math.floor(rgba[0]);\n\t        rgba[1] = Math.floor(rgba[1]);\n\t        rgba[2] = Math.floor(rgba[2]);\n\t\n\t        return 'rgba(' + rgba.join(',') + ')';\n\t    }\n\t\n\t    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n\t        var getter = animator._getter;\n\t        var setter = animator._setter;\n\t        var useSpline = easing === 'spline';\n\t\n\t        var trackLen = keyframes.length;\n\t        if (!trackLen) {\n\t            return;\n\t        }\n\t        // Guess data type\n\t        var firstVal = keyframes[0].value;\n\t        var isValueArray = isArrayLike(firstVal);\n\t        var isValueColor = false;\n\t        var isValueString = false;\n\t\n\t        // For vertices morphing\n\t        var arrDim = (\n\t                isValueArray\n\t                && isArrayLike(firstVal[0])\n\t            )\n\t            ? 2 : 1;\n\t        var trackMaxTime;\n\t        // Sort keyframe as ascending\n\t        keyframes.sort(function(a, b) {\n\t            return a.time - b.time;\n\t        });\n\t\n\t        trackMaxTime = keyframes[trackLen - 1].time;\n\t        // Percents of each keyframe\n\t        var kfPercents = [];\n\t        // Value of each keyframe\n\t        var kfValues = [];\n\t        var prevValue = keyframes[0].value;\n\t        var isAllValueEqual = true;\n\t        for (var i = 0; i < trackLen; i++) {\n\t            kfPercents.push(keyframes[i].time / trackMaxTime);\n\t            // Assume value is a color when it is a string\n\t            var value = keyframes[i].value;\n\t\n\t            // Check if value is equal, deep check if value is array\n\t            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n\t                || (!isValueArray && value === prevValue))) {\n\t                isAllValueEqual = false;\n\t            }\n\t            prevValue = value;\n\t\n\t            // Try converting a string to a color array\n\t            if (typeof value == 'string') {\n\t                var colorArray = color.parse(value);\n\t                if (colorArray) {\n\t                    value = colorArray;\n\t                    isValueColor = true;\n\t                }\n\t                else {\n\t                    isValueString = true;\n\t                }\n\t            }\n\t            kfValues.push(value);\n\t        }\n\t        if (isAllValueEqual) {\n\t            return;\n\t        }\n\t\n\t        var lastValue = kfValues[trackLen - 1];\n\t        // Polyfill array and NaN value\n\t        for (var i = 0; i < trackLen - 1; i++) {\n\t            if (isValueArray) {\n\t                fillArr(kfValues[i], lastValue, arrDim);\n\t            }\n\t            else {\n\t                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t                    kfValues[i] = lastValue;\n\t                }\n\t            }\n\t        }\n\t        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\t\n\t        // Cache the key of last frame to speed up when\n\t        // animation playback is sequency\n\t        var lastFrame = 0;\n\t        var lastFramePercent = 0;\n\t        var start;\n\t        var w;\n\t        var p0;\n\t        var p1;\n\t        var p2;\n\t        var p3;\n\t\n\t        if (isValueColor) {\n\t            var rgba = [0, 0, 0, 0];\n\t        }\n\t\n\t        var onframe = function (target, percent) {\n\t            // Find the range keyframes\n\t            // kf1-----kf2---------current--------kf3\n\t            // find kf2 and kf3 and do interpolation\n\t            var frame;\n\t            // In the easing function like elasticOut, percent may less than 0\n\t            if (percent < 0) {\n\t                frame = 0;\n\t            }\n\t            else if (percent < lastFramePercent) {\n\t                // Start from next key\n\t                // PENDING start from lastFrame ?\n\t                start = Math.min(lastFrame + 1, trackLen - 1);\n\t                for (frame = start; frame >= 0; frame--) {\n\t                    if (kfPercents[frame] <= percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                // PENDING really need to do this ?\n\t                frame = Math.min(frame, trackLen - 2);\n\t            }\n\t            else {\n\t                for (frame = lastFrame; frame < trackLen; frame++) {\n\t                    if (kfPercents[frame] > percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                frame = Math.min(frame - 1, trackLen - 2);\n\t            }\n\t            lastFrame = frame;\n\t            lastFramePercent = percent;\n\t\n\t            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n\t            if (range === 0) {\n\t                return;\n\t            }\n\t            else {\n\t                w = (percent - kfPercents[frame]) / range;\n\t            }\n\t            if (useSpline) {\n\t                p1 = kfValues[frame];\n\t                p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t                if (isValueArray) {\n\t                    catmullRomInterpolateArray(\n\t                        p0, p1, p2, p3, w, w * w, w * w * w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        value = catmullRomInterpolateArray(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(p1, p2, w);\n\t                    }\n\t                    else {\n\t                        value = catmullRomInterpolate(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w\n\t                        );\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t            else {\n\t                if (isValueArray) {\n\t                    interpolateArray(\n\t                        kfValues[frame], kfValues[frame + 1], w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        interpolateArray(\n\t                            kfValues[frame], kfValues[frame + 1], w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    else {\n\t                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t        };\n\t\n\t        var clip = new Clip({\n\t            target: animator._target,\n\t            life: trackMaxTime,\n\t            loop: animator._loop,\n\t            delay: animator._delay,\n\t            onframe: onframe,\n\t            ondestroy: oneTrackDone\n\t        });\n\t\n\t        if (easing && easing !== 'spline') {\n\t            clip.easing = easing;\n\t        }\n\t\n\t        return clip;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animator\n\t     * @constructor\n\t     * @param {Object} target\n\t     * @param {boolean} loop\n\t     * @param {Function} getter\n\t     * @param {Function} setter\n\t     */\n\t    var Animator = function(target, loop, getter, setter) {\n\t        this._tracks = {};\n\t        this._target = target;\n\t\n\t        this._loop = loop || false;\n\t\n\t        this._getter = getter || defaultGetter;\n\t        this._setter = setter || defaultSetter;\n\t\n\t        this._clipCount = 0;\n\t\n\t        this._delay = 0;\n\t\n\t        this._doneList = [];\n\t\n\t        this._onframeList = [];\n\t\n\t        this._clipList = [];\n\t    };\n\t\n\t    Animator.prototype = {\n\t        /**\n\t         * \n\t         * @param  {number} time ms\n\t         * @param  {Object} props key-value\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        when: function(time /* ms */, props) {\n\t            var tracks = this._tracks;\n\t            for (var propName in props) {\n\t                if (!props.hasOwnProperty(propName)) {\n\t                    continue;\n\t                }\n\t\n\t                if (!tracks[propName]) {\n\t                    tracks[propName] = [];\n\t                    // Invalid value\n\t                    var value = this._getter(this._target, propName);\n\t                    if (value == null) {\n\t                        // zrLog('Invalid property ' + propName);\n\t                        continue;\n\t                    }\n\t                    // If time is 0\n\t                    //  Then props is given initialize value\n\t                    // Else\n\t                    //  Initialize value from current prop value\n\t                    if (time !== 0) {\n\t                        tracks[propName].push({\n\t                            time: 0,\n\t                            value: cloneValue(value)\n\t                        });\n\t                    }\n\t                }\n\t                tracks[propName].push({\n\t                    time: time,\n\t                    value: props[propName]\n\t                });\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Function} callback\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        during: function (callback) {\n\t            this._onframeList.push(callback);\n\t            return this;\n\t        },\n\t\n\t        pause: function () {\n\t            for (var i = 0; i < this._clipList.length; i++) {\n\t                this._clipList[i].pause();\n\t            }\n\t            this._paused = true;\n\t        },\n\t\n\t        resume: function () {\n\t            for (var i = 0; i < this._clipList.length; i++) {\n\t                this._clipList[i].resume();\n\t            }\n\t            this._paused = false;\n\t        },\n\t\n\t        isPaused: function () {\n\t            return !!this._paused;\n\t        },\n\t\n\t        _doneCallback: function () {\n\t            // Clear all tracks\n\t            this._tracks = {};\n\t            // Clear all clips\n\t            this._clipList.length = 0;\n\t\n\t            var doneList = this._doneList;\n\t            var len = doneList.length;\n\t            for (var i = 0; i < len; i++) {\n\t                doneList[i].call(this);\n\t            }\n\t        },\n\t        /**\n\t         * \n\t         * @param  {string|Function} easing\n\t         *         {@link module:zrender/animation/easing}\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        start: function (easing) {\n\t\n\t            var self = this;\n\t            var clipCount = 0;\n\t\n\t            var oneTrackDone = function() {\n\t                clipCount--;\n\t                if (!clipCount) {\n\t                    self._doneCallback();\n\t                }\n\t            };\n\t\n\t            var lastClip;\n\t            for (var propName in this._tracks) {\n\t                if (!this._tracks.hasOwnProperty(propName)) {\n\t                    continue;\n\t                }\n\t                var clip = createTrackClip(\n\t                    this, easing, oneTrackDone,\n\t                    this._tracks[propName], propName\n\t                );\n\t                if (clip) {\n\t                    this._clipList.push(clip);\n\t                    clipCount++;\n\t\n\t                    // If start after added to animation\n\t                    if (this.animation) {\n\t                        this.animation.addClip(clip);\n\t                    }\n\t\n\t                    lastClip = clip;\n\t                }\n\t            }\n\t\n\t            // Add during callback on the last clip\n\t            if (lastClip) {\n\t                var oldOnFrame = lastClip.onframe;\n\t                lastClip.onframe = function (target, percent) {\n\t                    oldOnFrame(target, percent);\n\t\n\t                    for (var i = 0; i < self._onframeList.length; i++) {\n\t                        self._onframeList[i](target, percent);\n\t                    }\n\t                };\n\t            }\n\t\n\t            if (!clipCount) {\n\t                this._doneCallback();\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * \n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stop: function (forwardToLast) {\n\t            var clipList = this._clipList;\n\t            var animation = this.animation;\n\t            for (var i = 0; i < clipList.length; i++) {\n\t                var clip = clipList[i];\n\t                if (forwardToLast) {\n\t                    // Move to last frame before stop\n\t                    clip.onframe(this._target, 1);\n\t                }\n\t                animation && animation.removeClip(clip);\n\t            }\n\t            clipList.length = 0;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {number} time ms\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        delay: function (time) {\n\t            this._delay = time;\n\t            return this;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Function} cb\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        done: function(cb) {\n\t            if (cb) {\n\t                this._doneList.push(cb);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/animation/Clip>}\n\t         */\n\t        getClips: function () {\n\t            return this._clipList;\n\t        }\n\t    };\n\t\n\t    module.exports = Animator;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @config target onframe\n\t * @config life(1000) \n\t * @config delay(0) \n\t * @config loop(true)\n\t * @config gap(0) \n\t * @config onframe\n\t * @config easing(optional)\n\t * @config ondestroy(optional)\n\t * @config onrestart(optional)\n\t *\n\t * TODO pause\n\t */\n\t\n\t\n\t    var easingFuncs = __webpack_require__(19);\n\t\n\t    function Clip(options) {\n\t\n\t        this._target = options.target;\n\t\n\t        // \n\t        this._life = options.life || 1000;\n\t        // \n\t        this._delay = options.delay || 0;\n\t        // \n\t        // this._startTime = new Date().getTime() + this._delay;// \n\t        this._initialized = false;\n\t\n\t        // \n\t        this.loop = options.loop == null ? false : options.loop;\n\t\n\t        this.gap = options.gap || 0;\n\t\n\t        this.easing = options.easing || 'Linear';\n\t\n\t        this.onframe = options.onframe;\n\t        this.ondestroy = options.ondestroy;\n\t        this.onrestart = options.onrestart;\n\t\n\t        this._pausedTime = 0;\n\t        this._paused = false;\n\t    }\n\t\n\t    Clip.prototype = {\n\t\n\t        constructor: Clip,\n\t\n\t        step: function (globalTime, deltaTime) {\n\t            // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t            // PENDING\n\t            if (!this._initialized) {\n\t                this._startTime = globalTime + this._delay;\n\t                this._initialized = true;\n\t            }\n\t\n\t            if (this._paused) {\n\t                this._pausedTime += deltaTime;\n\t                return;\n\t            }\n\t\n\t            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n\t\n\t            // \n\t            if (percent < 0) {\n\t                return;\n\t            }\n\t\n\t            percent = Math.min(percent, 1);\n\t\n\t            var easing = this.easing;\n\t            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t            var schedule = typeof easingFunc === 'function'\n\t                ? easingFunc(percent)\n\t                : percent;\n\t\n\t            this.fire('frame', schedule);\n\t\n\t            // \n\t            if (percent == 1) {\n\t                if (this.loop) {\n\t                    this.restart (globalTime);\n\t                    // \n\t                    //  stage.update \n\t                    return 'restart';\n\t                }\n\t\n\t                // \n\t                // Animation.update\n\t                this._needsRemove = true;\n\t                return 'destroy';\n\t            }\n\t\n\t            return null;\n\t        },\n\t\n\t        restart: function (globalTime) {\n\t            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n\t            this._startTime = globalTime - remainder + this.gap;\n\t            this._pausedTime = 0;\n\t\n\t            this._needsRemove = false;\n\t        },\n\t\n\t        fire: function (eventType, arg) {\n\t            eventType = 'on' + eventType;\n\t            if (this[eventType]) {\n\t                this[eventType](this._target, arg);\n\t            }\n\t        },\n\t\n\t        pause: function () {\n\t            this._paused = true;\n\t        },\n\t\n\t        resume: function () {\n\t            this._paused = false;\n\t        }\n\t    };\n\t\n\t    module.exports = Clip;\n\t\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t/**\n\t *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n\t * @see http://sole.github.io/tween.js/examples/03_graphs.html\n\t * @exports zrender/animation/easing\n\t */\n\t\n\t    var easing = {\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        linear: function (k) {\n\t            return k;\n\t        },\n\t\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticIn: function (k) {\n\t            return k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticOut: function (k) {\n\t            return k * (2 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k;\n\t            }\n\t            return -0.5 * (--k * (k - 2) - 1);\n\t        },\n\t\n\t        // t^3\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicIn: function (k) {\n\t            return k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicOut: function (k) {\n\t            return --k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k + 2);\n\t        },\n\t\n\t        // t^4\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticIn: function (k) {\n\t            return k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticOut: function (k) {\n\t            return 1 - (--k * k * k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k;\n\t            }\n\t            return -0.5 * ((k -= 2) * k * k * k - 2);\n\t        },\n\t\n\t        // t^5\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticIn: function (k) {\n\t            return k * k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticOut: function (k) {\n\t            return --k * k * k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t        },\n\t\n\t        // sin(t)\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalIn: function (k) {\n\t            return 1 - Math.cos(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalOut: function (k) {\n\t            return Math.sin(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalInOut: function (k) {\n\t            return 0.5 * (1 - Math.cos(Math.PI * k));\n\t        },\n\t\n\t        // 2^t\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialIn: function (k) {\n\t            return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialOut: function (k) {\n\t            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialInOut: function (k) {\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * Math.pow(1024, k - 1);\n\t            }\n\t            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t        },\n\t\n\t        // sqrt(1-t^2)\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularIn: function (k) {\n\t            return 1 - Math.sqrt(1 - k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularOut: function (k) {\n\t            return Math.sqrt(1 - (--k * k));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t            }\n\t            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t        },\n\t\n\t        // \n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticIn: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return -(a * Math.pow(2, 10 * (k -= 1)) *\n\t                        Math.sin((k - s) * (2 * Math.PI) / p));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return (a * Math.pow(2, -10 * k) *\n\t                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticInOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p));\n\t            }\n\t            return a * Math.pow(2, -10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\n\t        },\n\t\n\t        // \n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backIn: function (k) {\n\t            var s = 1.70158;\n\t            return k * k * ((s + 1) * k - s);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backOut: function (k) {\n\t            var s = 1.70158;\n\t            return --k * k * ((s + 1) * k + s) + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backInOut: function (k) {\n\t            var s = 1.70158 * 1.525;\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * (k * k * ((s + 1) * k - s));\n\t            }\n\t            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t        },\n\t\n\t        // \n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceIn: function (k) {\n\t            return 1 - easing.bounceOut(1 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceOut: function (k) {\n\t            if (k < (1 / 2.75)) {\n\t                return 7.5625 * k * k;\n\t            }\n\t            else if (k < (2 / 2.75)) {\n\t                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t            }\n\t            else if (k < (2.5 / 2.75)) {\n\t                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t            }\n\t            else {\n\t                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t            }\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceInOut: function (k) {\n\t            if (k < 0.5) {\n\t                return easing.bounceIn(k * 2) * 0.5;\n\t            }\n\t            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t        }\n\t    };\n\t\n\t    module.exports = easing;\n\t\n\t\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/tool/color\n\t */\n\t\n\t\n\t    var LRU = __webpack_require__(21);\n\t\n\t    var kCSSColorTable = {\n\t        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n\t        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n\t        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n\t        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n\t        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n\t        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n\t        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n\t        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n\t        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n\t        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n\t        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n\t        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n\t        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n\t        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n\t        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n\t        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n\t        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n\t        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n\t        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n\t        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n\t        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n\t        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n\t        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n\t        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n\t        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n\t        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n\t        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n\t        'gray': [128,128,128,1], 'green': [0,128,0,1],\n\t        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n\t        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n\t        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n\t        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n\t        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n\t        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n\t        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n\t        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n\t        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n\t        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n\t        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n\t        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n\t        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n\t        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n\t        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n\t        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n\t        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n\t        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n\t        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n\t        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n\t        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n\t        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n\t        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n\t        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n\t        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n\t        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n\t        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n\t        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n\t        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n\t        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n\t        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n\t        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n\t        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n\t        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n\t        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n\t        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n\t        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n\t        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n\t        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n\t        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n\t        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n\t        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n\t        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n\t        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n\t        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n\t        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n\t    };\n\t\n\t    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 255 ? 255 : i;\n\t    }\n\t\n\t    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 360 ? 360 : i;\n\t    }\n\t\n\t    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n\t        return f < 0 ? 0 : f > 1 ? 1 : f;\n\t    }\n\t\n\t    function parseCssInt(str) {  // int or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssByte(parseFloat(str) / 100 * 255);\n\t        }\n\t        return clampCssByte(parseInt(str, 10));\n\t    }\n\t\n\t    function parseCssFloat(str) {  // float or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssFloat(parseFloat(str) / 100);\n\t        }\n\t        return clampCssFloat(parseFloat(str));\n\t    }\n\t\n\t    function cssHueToRgb(m1, m2, h) {\n\t        if (h < 0) {\n\t            h += 1;\n\t        }\n\t        else if (h > 1) {\n\t            h -= 1;\n\t        }\n\t\n\t        if (h * 6 < 1) {\n\t            return m1 + (m2 - m1) * h * 6;\n\t        }\n\t        if (h * 2 < 1) {\n\t            return m2;\n\t        }\n\t        if (h * 3 < 2) {\n\t            return m1 + (m2 - m1) * (2/3 - h) * 6;\n\t        }\n\t        return m1;\n\t    }\n\t\n\t    function lerp(a, b, p) {\n\t        return a + (b - a) * p;\n\t    }\n\t\n\t    function setRgba(out, r, g, b, a) {\n\t        out[0] = r; out[1] = g; out[2] = b; out[3] = a;\n\t        return out;\n\t    }\n\t    function copyRgba(out, a) {\n\t        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n\t        return out;\n\t    }\n\t    var colorCache = new LRU(20);\n\t    var lastRemovedArr = null;\n\t    function putToCache(colorStr, rgbaArr) {\n\t        // Reuse removed array\n\t        if (lastRemovedArr) {\n\t            copyRgba(lastRemovedArr, rgbaArr);\n\t        }\n\t        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n\t    }\n\t    /**\n\t     * @param {string} colorStr\n\t     * @param {Array.<number>} out\n\t     * @return {Array.<number>}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function parse(colorStr, rgbaArr) {\n\t        if (!colorStr) {\n\t            return;\n\t        }\n\t        rgbaArr = rgbaArr || [];\n\t\n\t        var cached = colorCache.get(colorStr);\n\t        if (cached) {\n\t            return copyRgba(rgbaArr, cached);\n\t        }\n\t\n\t        // colorStr may be not string\n\t        colorStr = colorStr + '';\n\t        // Remove all whitespace, not compliant, but should just be more accepting.\n\t        var str = colorStr.replace(/ /g, '').toLowerCase();\n\t\n\t        // Color keywords (and transparent) lookup.\n\t        if (str in kCSSColorTable) {\n\t            copyRgba(rgbaArr, kCSSColorTable[str]);\n\t            putToCache(colorStr, rgbaArr);\n\t            return rgbaArr;\n\t        }\n\t\n\t        // #abc and #abc123 syntax.\n\t        if (str.charAt(0) === '#') {\n\t            if (str.length === 4) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xfff)) {\n\t                    setRgba(rgbaArr, 0, 0, 0, 1);\n\t                    return;  // Covers NaN.\n\t                }\n\t                setRgba(rgbaArr,\n\t                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n\t                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n\t                    (iv & 0xf) | ((iv & 0xf) << 4),\n\t                    1\n\t                );\n\t                putToCache(colorStr, rgbaArr);\n\t                return rgbaArr;\n\t            }\n\t            else if (str.length === 7) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xffffff)) {\n\t                    setRgba(rgbaArr, 0, 0, 0, 1);\n\t                    return;  // Covers NaN.\n\t                }\n\t                setRgba(rgbaArr,\n\t                    (iv & 0xff0000) >> 16,\n\t                    (iv & 0xff00) >> 8,\n\t                    iv & 0xff,\n\t                    1\n\t                );\n\t                putToCache(colorStr, rgbaArr);\n\t                return rgbaArr;\n\t            }\n\t\n\t            return;\n\t        }\n\t        var op = str.indexOf('('), ep = str.indexOf(')');\n\t        if (op !== -1 && ep + 1 === str.length) {\n\t            var fname = str.substr(0, op);\n\t            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t            var alpha = 1;  // To allow case fallthrough.\n\t            switch (fname) {\n\t                case 'rgba':\n\t                    if (params.length !== 4) {\n\t                        setRgba(rgbaArr, 0, 0, 0, 1);\n\t                        return;\n\t                    }\n\t                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n\t                // Fall through.\n\t                case 'rgb':\n\t                    if (params.length !== 3) {\n\t                        setRgba(rgbaArr, 0, 0, 0, 1);\n\t                        return;\n\t                    }\n\t                    setRgba(rgbaArr,\n\t                        parseCssInt(params[0]),\n\t                        parseCssInt(params[1]),\n\t                        parseCssInt(params[2]),\n\t                        alpha\n\t                    );\n\t                    putToCache(colorStr, rgbaArr);\n\t                    return rgbaArr;\n\t                case 'hsla':\n\t                    if (params.length !== 4) {\n\t                        setRgba(rgbaArr, 0, 0, 0, 1);\n\t                        return;\n\t                    }\n\t                    params[3] = parseCssFloat(params[3]);\n\t                    hsla2rgba(params, rgbaArr);\n\t                    putToCache(colorStr, rgbaArr);\n\t                    return rgbaArr;\n\t                case 'hsl':\n\t                    if (params.length !== 3) {\n\t                        setRgba(rgbaArr, 0, 0, 0, 1);\n\t                        return;\n\t                    }\n\t                    hsla2rgba(params, rgbaArr);\n\t                    putToCache(colorStr, rgbaArr);\n\t                    return rgbaArr;\n\t                default:\n\t                    return;\n\t            }\n\t        }\n\t\n\t        setRgba(rgbaArr, 0, 0, 0, 1);\n\t        return;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} hsla\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} rgba\n\t     */\n\t    function hsla2rgba(hsla, rgba) {\n\t        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n\t        // NOTE(deanm): According to the CSS spec s/l should only be\n\t        // percentages, but we don't bother and let float or percentage.\n\t        var s = parseCssFloat(hsla[1]);\n\t        var l = parseCssFloat(hsla[2]);\n\t        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t        var m1 = l * 2 - m2;\n\t\n\t        rgba = rgba || [];\n\t        setRgba(rgba,\n\t            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),\n\t            1\n\t        );\n\t\n\t        if (hsla.length === 4) {\n\t            rgba[3] = hsla[3];\n\t        }\n\t\n\t        return rgba;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} hsla\n\t     */\n\t    function rgba2hsla(rgba) {\n\t        if (!rgba) {\n\t            return;\n\t        }\n\t\n\t        // RGB from 0 to 255\n\t        var R = rgba[0] / 255;\n\t        var G = rgba[1] / 255;\n\t        var B = rgba[2] / 255;\n\t\n\t        var vMin = Math.min(R, G, B); // Min. value of RGB\n\t        var vMax = Math.max(R, G, B); // Max. value of RGB\n\t        var delta = vMax - vMin; // Delta RGB value\n\t\n\t        var L = (vMax + vMin) / 2;\n\t        var H;\n\t        var S;\n\t        // HSL results from 0 to 1\n\t        if (delta === 0) {\n\t            H = 0;\n\t            S = 0;\n\t        }\n\t        else {\n\t            if (L < 0.5) {\n\t                S = delta / (vMax + vMin);\n\t            }\n\t            else {\n\t                S = delta / (2 - vMax - vMin);\n\t            }\n\t\n\t            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n\t            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n\t            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\t\n\t            if (R === vMax) {\n\t                H = deltaB - deltaG;\n\t            }\n\t            else if (G === vMax) {\n\t                H = (1 / 3) + deltaR - deltaB;\n\t            }\n\t            else if (B === vMax) {\n\t                H = (2 / 3) + deltaG - deltaR;\n\t            }\n\t\n\t            if (H < 0) {\n\t                H += 1;\n\t            }\n\t\n\t            if (H > 1) {\n\t                H -= 1;\n\t            }\n\t        }\n\t\n\t        var hsla = [H * 360, S, L];\n\t\n\t        if (rgba[3] != null) {\n\t            hsla.push(rgba[3]);\n\t        }\n\t\n\t        return hsla;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number} level\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function lift(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            for (var i = 0; i < 3; i++) {\n\t                if (level < 0) {\n\t                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t                }\n\t                else {\n\t                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n\t                }\n\t            }\n\t            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function toHex(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<Array.<number>>} colors List of rgba color array\n\t     * @param {Array.<number>} [out] Mapped gba color array\n\t     * @return {Array.<number>}\n\t     */\n\t    function fastMapToColor(normalizedValue, colors, out) {\n\t        out = out || [0, 0, 0, 0];\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return out;\n\t        }\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = colors[leftIndex];\n\t        var rightColor = colors[rightIndex];\n\t        var dv = value - leftIndex;\n\t        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n\t        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n\t        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n\t        out[3] = clampCssFloat(lerp(leftColor[3], rightColor[3], dv));\n\t        return out;\n\t    }\n\t    /**\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {boolean=} fullOutput Default false.\n\t     * @return {(string|Object)} Result color. If fullOutput,\n\t     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function mapToColor(normalizedValue, colors, fullOutput) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = parse(colors[leftIndex]);\n\t        var rightColor = parse(colors[rightIndex]);\n\t        var dv = value - leftIndex;\n\t\n\t        var color = stringify(\n\t            [\n\t                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n\t                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n\t                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n\t                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n\t            ],\n\t            'rgba'\n\t        );\n\t\n\t        return fullOutput\n\t            ? {\n\t                color: color,\n\t                leftIndex: leftIndex,\n\t                rightIndex: rightIndex,\n\t                value: value\n\t            }\n\t            : color;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} h 0 ~ 360, ignore when null.\n\t     * @param {number=} s 0 ~ 1, ignore when null.\n\t     * @param {number=} l 0 ~ 1, ignore when null.\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyHSL(color, h, s, l) {\n\t        color = parse(color);\n\t\n\t        if (color) {\n\t            color = rgba2hsla(color);\n\t            h != null && (color[0] = clampCssAngle(h));\n\t            s != null && (color[1] = parseCssFloat(s));\n\t            l != null && (color[2] = parseCssFloat(l));\n\t\n\t            return stringify(hsla2rgba(color), 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} alpha 0 ~ 1\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyAlpha(color, alpha) {\n\t        color = parse(color);\n\t\n\t        if (color && alpha != null) {\n\t            color[3] = clampCssFloat(alpha);\n\t            return stringify(color, 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {string} type 'rgba', 'hsva', ...\n\t     * @return {string} Result color. (If input illegal, return undefined).\n\t     */\n\t    function stringify(arrColor, type) {\n\t        if (!arrColor) {\n\t            return;\n\t        }\n\t        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t            colorStr += ',' + arrColor[3];\n\t        }\n\t        return type + '(' + colorStr + ')';\n\t    }\n\t\n\t    module.exports = {\n\t        parse: parse,\n\t        lift: lift,\n\t        toHex: toHex,\n\t        fastMapToColor: fastMapToColor,\n\t        mapToColor: mapToColor,\n\t        modifyHSL: modifyHSL,\n\t        modifyAlpha: modifyAlpha,\n\t        stringify: stringify\n\t    };\n\t\n\t\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t// Simple LRU cache use doubly linked list\n\t// @module zrender/core/LRU\n\t\n\t\n\t    /**\n\t     * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t     * @constructor\n\t     */\n\t    var LinkedList = function () {\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.head = null;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.tail = null;\n\t\n\t        this._len = 0;\n\t    };\n\t\n\t    var linkedListProto = LinkedList.prototype;\n\t    /**\n\t     * Insert a new value at the tail\n\t     * @param  {} val\n\t     * @return {module:zrender/core/LRU~Entry}\n\t     */\n\t    linkedListProto.insert = function (val) {\n\t        var entry = new Entry(val);\n\t        this.insertEntry(entry);\n\t        return entry;\n\t    };\n\t\n\t    /**\n\t     * Insert an entry at the tail\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.insertEntry = function (entry) {\n\t        if (!this.head) {\n\t            this.head = this.tail = entry;\n\t        }\n\t        else {\n\t            this.tail.next = entry;\n\t            entry.prev = this.tail;\n\t            entry.next = null;\n\t            this.tail = entry;\n\t        }\n\t        this._len++;\n\t    };\n\t\n\t    /**\n\t     * Remove entry.\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.remove = function (entry) {\n\t        var prev = entry.prev;\n\t        var next = entry.next;\n\t        if (prev) {\n\t            prev.next = next;\n\t        }\n\t        else {\n\t            // Is head\n\t            this.head = next;\n\t        }\n\t        if (next) {\n\t            next.prev = prev;\n\t        }\n\t        else {\n\t            // Is tail\n\t            this.tail = prev;\n\t        }\n\t        entry.next = entry.prev = null;\n\t        this._len--;\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    linkedListProto.len = function () {\n\t        return this._len;\n\t    };\n\t\n\t    /**\n\t     * Clear list\n\t     */\n\t    linkedListProto.clear = function () {\n\t        this.head = this.tail = null;\n\t        this._len = 0;\n\t    };\n\t\n\t    /**\n\t     * @constructor\n\t     * @param {} val\n\t     */\n\t    var Entry = function (val) {\n\t        /**\n\t         * @type {}\n\t         */\n\t        this.value = val;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.next;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.prev;\n\t    };\n\t\n\t    /**\n\t     * LRU Cache\n\t     * @constructor\n\t     * @alias module:zrender/core/LRU\n\t     */\n\t    var LRU = function (maxSize) {\n\t\n\t        this._list = new LinkedList();\n\t\n\t        this._map = {};\n\t\n\t        this._maxSize = maxSize || 10;\n\t\n\t        this._lastRemovedEntry = null;\n\t    };\n\t\n\t    var LRUProto = LRU.prototype;\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @param  {} value\n\t     * @return {} Removed value\n\t     */\n\t    LRUProto.put = function (key, value) {\n\t        var list = this._list;\n\t        var map = this._map;\n\t        var removed = null;\n\t        if (map[key] == null) {\n\t            var len = list.len();\n\t            // Reuse last removed entry\n\t            var entry = this._lastRemovedEntry;\n\t\n\t            if (len >= this._maxSize && len > 0) {\n\t                // Remove the least recently used\n\t                var leastUsedEntry = list.head;\n\t                list.remove(leastUsedEntry);\n\t                delete map[leastUsedEntry.key];\n\t\n\t                removed = leastUsedEntry.value;\n\t                this._lastRemovedEntry = leastUsedEntry;\n\t            }\n\t\n\t            if (entry) {\n\t                entry.value = value;\n\t            }\n\t            else {\n\t                entry = new Entry(value);\n\t            }\n\t            entry.key = key;\n\t            list.insertEntry(entry);\n\t            map[key] = entry;\n\t        }\n\t\n\t        return removed;\n\t    };\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @return {}\n\t     */\n\t    LRUProto.get = function (key) {\n\t        var entry = this._map[key];\n\t        var list = this._list;\n\t        if (entry != null) {\n\t            // Put the latest used entry in the tail\n\t            if (entry !== list.tail) {\n\t                list.remove(entry);\n\t                list.insertEntry(entry);\n\t            }\n\t\n\t            return entry.value;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Clear the cache\n\t     */\n\t    LRUProto.clear = function () {\n\t        this._list.clear();\n\t        this._map = {};\n\t    };\n\t\n\t    module.exports = LRU;\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t        var config = __webpack_require__(23);\n\t\n\t        /**\n\t         * @exports zrender/tool/log\n\t         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t         */\n\t        module.exports = function() {\n\t            if (config.debugMode === 0) {\n\t                return;\n\t            }\n\t            else if (config.debugMode == 1) {\n\t                for (var k in arguments) {\n\t                    throw new Error(arguments[k]);\n\t                }\n\t            }\n\t            else if (config.debugMode > 1) {\n\t                for (var k in arguments) {\n\t                    console.log(arguments[k]);\n\t                }\n\t            }\n\t        };\n\t\n\t        /* for debug\n\t        return function(mes) {\n\t            document.getElementById('wrong-message').innerHTML =\n\t                mes + ' ' + (new Date() - 0)\n\t                + '<br/>'\n\t                + document.getElementById('wrong-message').innerHTML;\n\t        };\n\t        */\n\t    \n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t\n\t    var dpr = 1;\n\t    // If in browser environment\n\t    if (typeof window !== 'undefined') {\n\t        dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t    }\n\t    /**\n\t     * config\n\t     * @exports zrender/config\n\t     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t     */\n\t    var config = {\n\t        /**\n\t         * debugcatchBrushExceptiontrue\n\t         * 0 : debug\n\t         * 1 : \n\t         * 2 : \n\t         */\n\t        debugMode: 0,\n\t\n\t        // retina \n\t        devicePixelRatio: dpr\n\t    };\n\t    module.exports = config;\n\t\n\t\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module echarts/core/BoundingRect\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(15);\n\t    var matrix = __webpack_require__(14);\n\t\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    /**\n\t     * @alias module:echarts/core/BoundingRect\n\t     */\n\t    function BoundingRect(x, y, width, height) {\n\t\n\t        if (width < 0) {\n\t            x = x + width;\n\t            width = -width;\n\t        }\n\t        if (height < 0) {\n\t            y = y + height;\n\t            height = -height;\n\t        }\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.x = x;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.y = y;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.width = width;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.height = height;\n\t    }\n\t\n\t    BoundingRect.prototype = {\n\t\n\t        constructor: BoundingRect,\n\t\n\t        /**\n\t         * @param {module:echarts/core/BoundingRect} other\n\t         */\n\t        union: function (other) {\n\t            var x = mathMin(other.x, this.x);\n\t            var y = mathMin(other.y, this.y);\n\t\n\t            this.width = mathMax(\n\t                    other.x + other.width,\n\t                    this.x + this.width\n\t                ) - x;\n\t            this.height = mathMax(\n\t                    other.y + other.height,\n\t                    this.y + this.height\n\t                ) - y;\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} m\n\t         * @methods\n\t         */\n\t        applyTransform: (function () {\n\t            var lt = [];\n\t            var rb = [];\n\t            var lb = [];\n\t            var rt = [];\n\t            return function (m) {\n\t                // In case usage like this\n\t                // el.getBoundingRect().applyTransform(el.transform)\n\t                // And element has no transform\n\t                if (!m) {\n\t                    return;\n\t                }\n\t                lt[0] = lb[0] = this.x;\n\t                lt[1] = rt[1] = this.y;\n\t                rb[0] = rt[0] = this.x + this.width;\n\t                rb[1] = lb[1] = this.y + this.height;\n\t\n\t                v2ApplyTransform(lt, lt, m);\n\t                v2ApplyTransform(rb, rb, m);\n\t                v2ApplyTransform(lb, lb, m);\n\t                v2ApplyTransform(rt, rt, m);\n\t\n\t                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n\t                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n\t                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n\t                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n\t                this.width = maxX - this.x;\n\t                this.height = maxY - this.y;\n\t            };\n\t        })(),\n\t\n\t        /**\n\t         * Calculate matrix of transforming from self to target rect\n\t         * @param  {module:zrender/core/BoundingRect} b\n\t         * @return {Array.<number>}\n\t         */\n\t        calculateTransform: function (b) {\n\t            var a = this;\n\t            var sx = b.width / a.width;\n\t            var sy = b.height / a.height;\n\t\n\t            var m = matrix.create();\n\t\n\t            // \n\t            matrix.translate(m, m, [-a.x, -a.y]);\n\t            matrix.scale(m, m, [sx, sy]);\n\t            matrix.translate(m, m, [b.x, b.y]);\n\t\n\t            return m;\n\t        },\n\t\n\t        /**\n\t         * @param {(module:echarts/core/BoundingRect|Object)} b\n\t         * @return {boolean}\n\t         */\n\t        intersect: function (b) {\n\t            if (!b) {\n\t                return false;\n\t            }\n\t\n\t            if (!(b instanceof BoundingRect)) {\n\t                // Normalize negative width/height.\n\t                b = BoundingRect.create(b);\n\t            }\n\t\n\t            var a = this;\n\t            var ax0 = a.x;\n\t            var ax1 = a.x + a.width;\n\t            var ay0 = a.y;\n\t            var ay1 = a.y + a.height;\n\t\n\t            var bx0 = b.x;\n\t            var bx1 = b.x + b.width;\n\t            var by0 = b.y;\n\t            var by1 = b.y + b.height;\n\t\n\t            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var rect = this;\n\t            return x >= rect.x\n\t                && x <= (rect.x + rect.width)\n\t                && y >= rect.y\n\t                && y <= (rect.y + rect.height);\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/core/BoundingRect}\n\t         */\n\t        clone: function () {\n\t            return new BoundingRect(this.x, this.y, this.width, this.height);\n\t        },\n\t\n\t        /**\n\t         * Copy from another rect\n\t         */\n\t        copy: function (other) {\n\t            this.x = other.x;\n\t            this.y = other.y;\n\t            this.width = other.width;\n\t            this.height = other.height;\n\t        },\n\t\n\t        plain: function () {\n\t            return {\n\t                x: this.x,\n\t                y: this.y,\n\t                width: this.width,\n\t                height: this.height\n\t            };\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {Object|module:zrender/core/BoundingRect} rect\n\t     * @param {number} rect.x\n\t     * @param {number} rect.y\n\t     * @param {number} rect.width\n\t     * @param {number} rect.height\n\t     * @return {module:zrender/core/BoundingRect}\n\t     */\n\t    BoundingRect.create = function (rect) {\n\t        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n\t    };\n\t\n\t    module.exports = BoundingRect;\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t// https://github.com/mziccard/node-timsort\n\t\n\t    var DEFAULT_MIN_MERGE = 32;\n\t\n\t    var DEFAULT_MIN_GALLOPING = 7;\n\t\n\t    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t\n\t    function minRunLength(n) {\n\t        var r = 0;\n\t\n\t        while (n >= DEFAULT_MIN_MERGE) {\n\t            r |= n & 1;\n\t            n >>= 1;\n\t        }\n\t\n\t        return n + r;\n\t    }\n\t\n\t    function makeAscendingRun(array, lo, hi, compare) {\n\t        var runHi = lo + 1;\n\t\n\t        if (runHi === hi) {\n\t            return 1;\n\t        }\n\t\n\t        if (compare(array[runHi++], array[lo]) < 0) {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t                runHi++;\n\t            }\n\t\n\t            reverseRun(array, lo, runHi);\n\t        }\n\t        else {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t                runHi++;\n\t            }\n\t        }\n\t\n\t        return runHi - lo;\n\t    }\n\t\n\t    function reverseRun(array, lo, hi) {\n\t        hi--;\n\t\n\t        while (lo < hi) {\n\t            var t = array[lo];\n\t            array[lo++] = array[hi];\n\t            array[hi--] = t;\n\t        }\n\t    }\n\t\n\t    function binaryInsertionSort(array, lo, hi, start, compare) {\n\t        if (start === lo) {\n\t            start++;\n\t        }\n\t\n\t        for (; start < hi; start++) {\n\t            var pivot = array[start];\n\t\n\t            var left = lo;\n\t            var right = start;\n\t            var mid;\n\t\n\t            while (left < right) {\n\t                mid = left + right >>> 1;\n\t\n\t                if (compare(pivot, array[mid]) < 0) {\n\t                    right = mid;\n\t                }\n\t                else {\n\t                    left = mid + 1;\n\t                }\n\t            }\n\t\n\t            var n = start - left;\n\t\n\t            switch (n) {\n\t                case 3:\n\t                    array[left + 3] = array[left + 2];\n\t\n\t                case 2:\n\t                    array[left + 2] = array[left + 1];\n\t\n\t                case 1:\n\t                    array[left + 1] = array[left];\n\t                    break;\n\t                default:\n\t                    while (n > 0) {\n\t                        array[left + n] = array[left + n - 1];\n\t                        n--;\n\t                    }\n\t            }\n\t\n\t            array[left] = pivot;\n\t        }\n\t    }\n\t\n\t    function gallopLeft(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) > 0) {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t        else {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) > 0) {\n\t                lastOffset = m + 1;\n\t            }\n\t            else {\n\t                offset = m;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t\n\t    function gallopRight(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) < 0) {\n\t            maxOffset = hint + 1;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t        else {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t\n\t        lastOffset++;\n\t\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) < 0) {\n\t                offset = m;\n\t            }\n\t            else {\n\t                lastOffset = m + 1;\n\t            }\n\t        }\n\t\n\t        return offset;\n\t    }\n\t\n\t    function TimSort(array, compare) {\n\t        var minGallop = DEFAULT_MIN_GALLOPING;\n\t        var length = 0;\n\t        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t        var stackLength = 0;\n\t        var runStart;\n\t        var runLength;\n\t        var stackSize = 0;\n\t\n\t        length = array.length;\n\t\n\t        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t            tmpStorageLength = length >>> 1;\n\t        }\n\t\n\t        var tmp = [];\n\t\n\t        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t\n\t        runStart = [];\n\t        runLength = [];\n\t\n\t        function pushRun(_runStart, _runLength) {\n\t            runStart[stackSize] = _runStart;\n\t            runLength[stackSize] = _runLength;\n\t            stackSize += 1;\n\t        }\n\t\n\t        function mergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t                    if (runLength[n - 1] < runLength[n + 1]) {\n\t                        n--;\n\t                    }\n\t                }\n\t                else if (runLength[n] > runLength[n + 1]) {\n\t                    break;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function forceMergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t                    n--;\n\t                }\n\t\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function mergeAt(i) {\n\t            var start1 = runStart[i];\n\t            var length1 = runLength[i];\n\t            var start2 = runStart[i + 1];\n\t            var length2 = runLength[i + 1];\n\t\n\t            runLength[i] = length1 + length2;\n\t\n\t            if (i === stackSize - 3) {\n\t                runStart[i + 1] = runStart[i + 2];\n\t                runLength[i + 1] = runLength[i + 2];\n\t            }\n\t\n\t            stackSize--;\n\t\n\t            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t            start1 += k;\n\t            length1 -= k;\n\t\n\t            if (length1 === 0) {\n\t                return;\n\t            }\n\t\n\t            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t\n\t            if (length2 === 0) {\n\t                return;\n\t            }\n\t\n\t            if (length1 <= length2) {\n\t                mergeLow(start1, length1, start2, length2);\n\t            }\n\t            else {\n\t                mergeHigh(start1, length1, start2, length2);\n\t            }\n\t        }\n\t\n\t        function mergeLow(start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length1; i++) {\n\t                tmp[i] = array[start1 + i];\n\t            }\n\t\n\t            var cursor1 = 0;\n\t            var cursor2 = start2;\n\t            var dest = start1;\n\t\n\t            array[dest++] = array[cursor2++];\n\t\n\t            if (--length2 === 0) {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t                return;\n\t            }\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t            var count1, count2, exit;\n\t\n\t            while (1) {\n\t                count1 = 0;\n\t                count2 = 0;\n\t                exit = false;\n\t\n\t                do {\n\t                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t                        array[dest++] = array[cursor2++];\n\t                        count2++;\n\t                        count1 = 0;\n\t\n\t                        if (--length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest++] = tmp[cursor1++];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        for (i = 0; i < count1; i++) {\n\t                            array[dest + i] = tmp[cursor1 + i];\n\t                        }\n\t\n\t                        dest += count1;\n\t                        cursor1 += count1;\n\t                        length1 -= count1;\n\t                        if (length1 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest++] = array[cursor2++];\n\t\n\t                    if (--length2 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[dest + i] = array[cursor2 + i];\n\t                        }\n\t\n\t                        dest += count2;\n\t                        cursor2 += count2;\n\t                        length2 -= count2;\n\t\n\t                        if (length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = tmp[cursor1++];\n\t\n\t                    if (--length1 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            minGallop < 1 && (minGallop = 1);\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t            }\n\t            else if (length1 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeLow preconditions were not respected');\n\t            }\n\t            else {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t            }\n\t        }\n\t\n\t        function mergeHigh (start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length2; i++) {\n\t                tmp[i] = array[start2 + i];\n\t            }\n\t\n\t            var cursor1 = start1 + length1 - 1;\n\t            var cursor2 = length2 - 1;\n\t            var dest = start2 + length2 - 1;\n\t            var customCursor = 0;\n\t            var customDest = 0;\n\t\n\t            array[dest--] = array[cursor1--];\n\t\n\t            if (--length1 === 0) {\n\t                customCursor = dest - (length2 - 1);\n\t\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t\n\t            while (true) {\n\t                var count1 = 0;\n\t                var count2 = 0;\n\t                var exit = false;\n\t\n\t                do {\n\t                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t                        array[dest--] = array[cursor1--];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest--] = tmp[cursor2--];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        dest -= count1;\n\t                        cursor1 -= count1;\n\t                        length1 -= count1;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor1 + 1;\n\t\n\t                        for (i = count1 - 1; i >= 0; i--) {\n\t                            array[customDest + i] = array[customCursor + i];\n\t                        }\n\t\n\t                        if (length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = tmp[cursor2--];\n\t\n\t                    if (--length2 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        dest -= count2;\n\t                        cursor2 -= count2;\n\t                        length2 -= count2;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor2 + 1;\n\t\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[customDest + i] = tmp[customCursor + i];\n\t                        }\n\t\n\t                        if (length2 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = array[cursor1--];\n\t\n\t                    if (--length1 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            if (minGallop < 1) {\n\t                minGallop = 1;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t            }\n\t            else if (length2 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeHigh preconditions were not respected');\n\t            }\n\t            else {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t            }\n\t        }\n\t\n\t        this.mergeRuns = mergeRuns;\n\t        this.forceMergeRuns = forceMergeRuns;\n\t        this.pushRun = pushRun;\n\t    }\n\t\n\t    function sort(array, compare, lo, hi) {\n\t        if (!lo) {\n\t            lo = 0;\n\t        }\n\t        if (!hi) {\n\t            hi = array.length;\n\t        }\n\t\n\t        var remaining = hi - lo;\n\t\n\t        if (remaining < 2) {\n\t            return;\n\t        }\n\t\n\t        var runLength = 0;\n\t\n\t        if (remaining < DEFAULT_MIN_MERGE) {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t            return;\n\t        }\n\t\n\t        var ts = new TimSort(array, compare);\n\t\n\t        var minRun = minRunLength(remaining);\n\t\n\t        do {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            if (runLength < minRun) {\n\t                var force = remaining;\n\t                if (force > minRun) {\n\t                    force = minRun;\n\t                }\n\t\n\t                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t                runLength = force;\n\t            }\n\t\n\t            ts.pushRun(lo, runLength);\n\t            ts.mergeRuns();\n\t\n\t            remaining -= runLength;\n\t            lo += runLength;\n\t        } while (remaining !== 0);\n\t\n\t        ts.forceMergeRuns();\n\t    }\n\t\n\t    module.exports = sort;\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * , \n\t *\n\t * @module zrender/animation/Animation\n\t * @author pissang(https://github.com/pissang)\n\t */\n\t// TODO Additive animation\n\t// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n\t// https://developer.apple.com/videos/wwdc2014/#236\n\t\n\t\n\t    var util = __webpack_require__(6);\n\t    var Dispatcher = __webpack_require__(27).Dispatcher;\n\t\n\t    var requestAnimationFrame = __webpack_require__(28);\n\t\n\t    var Animator = __webpack_require__(17);\n\t    /**\n\t     * @typedef {Object} IZRenderStage\n\t     * @property {Function} update\n\t     */\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animation\n\t     * @constructor\n\t     * @param {Object} [options]\n\t     * @param {Function} [options.onframe]\n\t     * @param {IZRenderStage} [options.stage]\n\t     * @example\n\t     *     var animation = new Animation();\n\t     *     var obj = {\n\t     *         x: 100,\n\t     *         y: 100\n\t     *     };\n\t     *     animation.animate(node.position)\n\t     *         .when(1000, {\n\t     *             x: 500,\n\t     *             y: 500\n\t     *         })\n\t     *         .when(2000, {\n\t     *             x: 100,\n\t     *             y: 100\n\t     *         })\n\t     *         .start('spline');\n\t     */\n\t    var Animation = function (options) {\n\t\n\t        options = options || {};\n\t\n\t        this.stage = options.stage || {};\n\t\n\t        this.onframe = options.onframe || function() {};\n\t\n\t        // private properties\n\t        this._clips = [];\n\t\n\t        this._running = false;\n\t\n\t        this._time;\n\t\n\t        this._pausedTime;\n\t\n\t        this._pauseStart;\n\t\n\t        this._paused = false;\n\t\n\t        Dispatcher.call(this);\n\t    };\n\t\n\t    Animation.prototype = {\n\t\n\t        constructor: Animation,\n\t        /**\n\t         *  clip\n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        addClip: function (clip) {\n\t            this._clips.push(clip);\n\t        },\n\t        /**\n\t         *  animator\n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        addAnimator: function (animator) {\n\t            animator.animation = this;\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.addClip(clips[i]);\n\t            }\n\t        },\n\t        /**\n\t         * \n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        removeClip: function(clip) {\n\t            var idx = util.indexOf(this._clips, clip);\n\t            if (idx >= 0) {\n\t                this._clips.splice(idx, 1);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        removeAnimator: function (animator) {\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.removeClip(clips[i]);\n\t            }\n\t            animator.animation = null;\n\t        },\n\t\n\t        _update: function() {\n\t\n\t            var time = new Date().getTime() - this._pausedTime;\n\t            var delta = time - this._time;\n\t            var clips = this._clips;\n\t            var len = clips.length;\n\t\n\t            var deferredEvents = [];\n\t            var deferredClips = [];\n\t            for (var i = 0; i < len; i++) {\n\t                var clip = clips[i];\n\t                var e = clip.step(time, delta);\n\t                // Throw out the events need to be called after\n\t                // stage.update, like destroy\n\t                if (e) {\n\t                    deferredEvents.push(e);\n\t                    deferredClips.push(clip);\n\t                }\n\t            }\n\t\n\t            // Remove the finished clip\n\t            for (var i = 0; i < len;) {\n\t                if (clips[i]._needsRemove) {\n\t                    clips[i] = clips[len - 1];\n\t                    clips.pop();\n\t                    len--;\n\t                }\n\t                else {\n\t                    i++;\n\t                }\n\t            }\n\t\n\t            len = deferredEvents.length;\n\t            for (var i = 0; i < len; i++) {\n\t                deferredClips[i].fire(deferredEvents[i]);\n\t            }\n\t\n\t            this._time = time;\n\t\n\t            this.onframe(delta);\n\t\n\t            this.trigger('frame', delta);\n\t\n\t            if (this.stage.update) {\n\t                this.stage.update();\n\t            }\n\t        },\n\t\n\t        _startLoop: function () {\n\t            var self = this;\n\t\n\t            this._running = true;\n\t\n\t            function step() {\n\t                if (self._running) {\n\t\n\t                    requestAnimationFrame(step);\n\t\n\t                    !self._paused && self._update();\n\t                }\n\t            }\n\t\n\t            requestAnimationFrame(step);\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        start: function () {\n\t\n\t            this._time = new Date().getTime();\n\t            this._pausedTime = 0;\n\t\n\t            this._startLoop();\n\t        },\n\t        /**\n\t         * \n\t         */\n\t        stop: function () {\n\t            this._running = false;\n\t        },\n\t\n\t        /**\n\t         * Pause\n\t         */\n\t        pause: function () {\n\t            if (!this._paused) {\n\t                this._pauseStart = new Date().getTime();\n\t                this._paused = true;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Resume\n\t         */\n\t        resume: function () {\n\t            if (this._paused) {\n\t                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n\t                this._paused = false;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        clear: function () {\n\t            this._clips = [];\n\t        },\n\t        /**\n\t         * animator\n\t         * @param  {Object} target\n\t         * @param  {Object} options\n\t         * @param  {boolean} [options.loop=false] \n\t         * @param  {Function} [options.getter=null]\n\t         *         gettergetter\n\t         * @param  {Function} [options.setter=null]\n\t         *         settersetter\n\t         * @return {module:zrender/animation/Animation~Animator}\n\t         */\n\t        // TODO Gap\n\t        animate: function (target, options) {\n\t            options = options || {};\n\t\n\t            var animator = new Animator(\n\t                target,\n\t                options.loop,\n\t                options.getter,\n\t                options.setter\n\t            );\n\t\n\t            this.addAnimator(animator);\n\t\n\t            return animator;\n\t        }\n\t    };\n\t\n\t    util.mixin(Animation, Dispatcher);\n\t\n\t    module.exports = Animation;\n\t\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/core/event\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t */\n\t\n\t\n\t    var Eventful = __webpack_require__(9);\n\t    var env = __webpack_require__(5);\n\t\n\t    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\t\n\t    function getBoundingClientRect(el) {\n\t        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n\t    }\n\t\n\t    // `calculate` is optional, default false\n\t    function clientToLocal(el, e, out, calculate) {\n\t        out = out || {};\n\t\n\t        // According to the W3C Working Draft, offsetX and offsetY should be relative\n\t        // to the padding edge of the target element. The only browser using this convention\n\t        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n\t        // not support the properties.\n\t        // (see http://www.jacklmoore.com/notes/mouse-position/)\n\t        // In zr painter.dom, padding edge equals to border edge.\n\t\n\t        // FIXME\n\t        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n\t        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n\t        // is too complex. So css-transfrom dont support in this case temporarily.\n\t        if (calculate || !env.canvasSupported) {\n\t            defaultGetZrXY(el, e, out);\n\t        }\n\t        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n\t        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n\t        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n\t        // zoom-factor, overflow / opacity layers, transforms ...)\n\t        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n\t        // <https://bugs.jquery.com/ticket/8523#comment:14>\n\t        // BTW3, In ff, offsetX/offsetY is always 0.\n\t        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n\t            out.zrX = e.layerX;\n\t            out.zrY = e.layerY;\n\t        }\n\t        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n\t        else if (e.offsetX != null) {\n\t            out.zrX = e.offsetX;\n\t            out.zrY = e.offsetY;\n\t        }\n\t        // For some other device, e.g., IOS safari.\n\t        else {\n\t            defaultGetZrXY(el, e, out);\n\t        }\n\t\n\t        return out;\n\t    }\n\t\n\t    function defaultGetZrXY(el, e, out) {\n\t        // This well-known method below does not support css transform.\n\t        var box = getBoundingClientRect(el);\n\t        out.zrX = e.clientX - box.left;\n\t        out.zrY = e.clientY - box.top;\n\t    }\n\t\n\t    /**\n\t     * domtouch.\n\t     * `calculate` is optional, default false.\n\t     */\n\t    function normalizeEvent(el, e, calculate) {\n\t\n\t        e = e || window.event;\n\t\n\t        if (e.zrX != null) {\n\t            return e;\n\t        }\n\t\n\t        var eventType = e.type;\n\t        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t\n\t        if (!isTouch) {\n\t            clientToLocal(el, e, e, calculate);\n\t            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t        }\n\t        else {\n\t            var touch = eventType != 'touchend'\n\t                ? e.targetTouches[0]\n\t                : e.changedTouches[0];\n\t            touch && clientToLocal(el, touch, e, calculate);\n\t        }\n\t\n\t        return e;\n\t    }\n\t\n\t    function addEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.addEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.attachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    function removeEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.removeEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.detachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * preventDefault and stopPropagation.\n\t     * Notice: do not do that in zrender. Upper application\n\t     * do that if necessary.\n\t     *\n\t     * @memberOf module:zrender/core/event\n\t     * @method\n\t     * @param {Event} e : event\n\t     */\n\t    var stop = isDomLevel2\n\t        ? function (e) {\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\t            e.cancelBubble = true;\n\t        }\n\t        : function (e) {\n\t            e.returnValue = false;\n\t            e.cancelBubble = true;\n\t        };\n\t\n\t    module.exports = {\n\t        clientToLocal: clientToLocal,\n\t        normalizeEvent: normalizeEvent,\n\t        addEventListener: addEventListener,\n\t        removeEventListener: removeEventListener,\n\t\n\t        stop: stop,\n\t        // \n\t        Dispatcher: Eventful\n\t    };\n\t\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = (typeof window !== 'undefined' &&\n\t                                    (window.requestAnimationFrame\n\t                                    || window.msRequestAnimationFrame\n\t                                    || window.mozRequestAnimationFrame\n\t                                    || window.webkitRequestAnimationFrame))\n\t                                || function (func) {\n\t                                    setTimeout(func, 16);\n\t                                };\n\t\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var eventTool = __webpack_require__(27);\n\t    var zrUtil = __webpack_require__(6);\n\t    var Eventful = __webpack_require__(9);\n\t    var env = __webpack_require__(5);\n\t    var GestureMgr = __webpack_require__(30);\n\t\n\t    var addEventListener = eventTool.addEventListener;\n\t    var removeEventListener = eventTool.removeEventListener;\n\t    var normalizeEvent = eventTool.normalizeEvent;\n\t\n\t    var TOUCH_CLICK_DELAY = 300;\n\t\n\t    var mouseHandlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n\t    ];\n\t\n\t    var touchHandlerNames = [\n\t        'touchstart', 'touchend', 'touchmove'\n\t    ];\n\t\n\t    var pointerEventNames = {\n\t        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n\t    };\n\t\n\t    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n\t        var nm = name.replace('mouse', 'pointer');\n\t        return pointerEventNames[nm] ? nm : name;\n\t    });\n\t\n\t    function eventNameFix(name) {\n\t        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n\t    }\n\t\n\t    function processGesture(proxy, event, stage) {\n\t        var gestureMgr = proxy._gestureMgr;\n\t\n\t        stage === 'start' && gestureMgr.clear();\n\t\n\t        var gestureInfo = gestureMgr.recognize(\n\t            event,\n\t            proxy.handler.findHover(event.zrX, event.zrY, null),\n\t            proxy.dom\n\t        );\n\t\n\t        stage === 'end' && gestureMgr.clear();\n\t\n\t        // Do not do any preventDefault here. Upper application do that if necessary.\n\t        if (gestureInfo) {\n\t            var type = gestureInfo.type;\n\t            event.gestureEvent = type;\n\t\n\t            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n\t        }\n\t    }\n\t\n\t    // function onMSGestureChange(proxy, event) {\n\t    //     if (event.translationX || event.translationY) {\n\t    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n\t    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n\t    //     }\n\t    //     if (event.scale !== 1) {\n\t    //         event.pinchX = event.offsetX;\n\t    //         event.pinchY = event.offsetY;\n\t    //         event.pinchScale = event.scale;\n\t    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n\t    //     }\n\t    // }\n\t\n\t    /**\n\t     * Prevent mouse event from being dispatched after Touch Events action\n\t     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t     * Result: Blocking Mouse Events for 700ms.\n\t     */\n\t    function setTouchTimer(instance) {\n\t        instance._touching = true;\n\t        clearTimeout(instance._touchTimer);\n\t        instance._touchTimer = setTimeout(function () {\n\t            instance._touching = false;\n\t        }, 700);\n\t    }\n\t\n\t\n\t    var domHandlers = {\n\t        /**\n\t         * Mouse move handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mousemove: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            this.trigger('mousemove', event);\n\t        },\n\t\n\t        /**\n\t         * Mouse out handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mouseout: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            var element = event.toElement || event.relatedTarget;\n\t            if (element != this.dom) {\n\t                while (element && element.nodeType != 9) {\n\t                    // rootdommouseOut\n\t                    if (element === this.dom) {\n\t                        return;\n\t                    }\n\t\n\t                    element = element.parentNode;\n\t                }\n\t            }\n\t\n\t            this.trigger('mouseout', event);\n\t        },\n\t\n\t        /**\n\t         * Touch\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchstart: function (event) {\n\t            // Default mouse behaviour should not be disabled here.\n\t            // For example, page may needs to be slided.\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            this._lastTouchMoment = new Date();\n\t\n\t            processGesture(this, event, 'start');\n\t\n\t            // In touch device, trigger `mousemove`(`mouseover`) should\n\t            // be triggered, and must before `mousedown` triggered.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            domHandlers.mousedown.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchmove: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            processGesture(this, event, 'change');\n\t\n\t            // Mouse move should always be triggered no matter whether\n\t            // there is gestrue event, because mouse move and pinch may\n\t            // be used at the same time.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchend: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            processGesture(this, event, 'end');\n\t\n\t            domHandlers.mouseup.call(this, event);\n\t\n\t            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n\t            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n\t            // we can conveniently implement \"hover style\" in both PC and touch device just\n\t            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n\t            // to remove \"hover style\" on an element, without any additional code for\n\t            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n\t            // style\" will remain for user view)\n\t\n\t            // click event should always be triggered no matter whether\n\t            // there is gestrue event. System click can not be prevented.\n\t            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t                domHandlers.click.call(this, event);\n\t            }\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        pointerdown: function (event) {\n\t            domHandlers.mousedown.call(this, event);\n\t\n\t            // if (useMSGuesture(this, event)) {\n\t            //     this._msGesture.addPointer(event.pointerId);\n\t            // }\n\t        },\n\t\n\t        pointermove: function (event) {\n\t            // FIXME\n\t            // pointermove is so sensitive that it always triggered when\n\t            // tap(click) on touch screen, which affect some judgement in\n\t            // upper application. So, we dont support mousemove on MS touch\n\t            // device yet.\n\t            if (!isPointerFromTouch(event)) {\n\t                domHandlers.mousemove.call(this, event);\n\t            }\n\t        },\n\t\n\t        pointerup: function (event) {\n\t            domHandlers.mouseup.call(this, event);\n\t        },\n\t\n\t        pointerout: function (event) {\n\t            // pointerout will be triggered when tap on touch screen\n\t            // (IE11+/Edge on MS Surface) after click event triggered,\n\t            // which is inconsistent with the mousout behavior we defined\n\t            // in touchend. So we unify them.\n\t            // (check domHandlers.touchend for detailed explanation)\n\t            if (!isPointerFromTouch(event)) {\n\t                domHandlers.mouseout.call(this, event);\n\t            }\n\t        }\n\t    };\n\t\n\t    function isPointerFromTouch(event) {\n\t        var pointerType = event.pointerType;\n\t        return pointerType === 'pen' || pointerType === 'touch';\n\t    }\n\t\n\t    // function useMSGuesture(handlerProxy, event) {\n\t    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n\t    // }\n\t\n\t    // Common handlers\n\t    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t        domHandlers[name] = function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t            this.trigger(name, event);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * dom \n\t     *\n\t     * @inner\n\t     * @param {module:zrender/Handler} instance \n\t     */\n\t    function initDomHandler(instance) {\n\t        zrUtil.each(touchHandlerNames, function (name) {\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        });\n\t\n\t        zrUtil.each(pointerHandlerNames, function (name) {\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        });\n\t\n\t        zrUtil.each(mouseHandlerNames, function (name) {\n\t            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t        });\n\t\n\t        function makeMouseHandler(fn, instance) {\n\t            return function () {\n\t                if (instance._touching) {\n\t                    return;\n\t                }\n\t                return fn.apply(instance, arguments);\n\t            };\n\t        }\n\t    }\n\t\n\t\n\t    function HandlerDomProxy(dom) {\n\t        Eventful.call(this);\n\t\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._touching = false;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._touchTimer;\n\t\n\t        /**\n\t         * @private\n\t         * @type {module:zrender/core/GestureMgr}\n\t         */\n\t        this._gestureMgr = new GestureMgr();\n\t\n\t        this._handlers = {};\n\t\n\t        initDomHandler(this);\n\t\n\t        if (env.pointerEventsSupported) { // Only IE11+/Edge\n\t            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n\t            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n\t            // at the same time.\n\t            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n\t            // screen, which do not occurs in pointer event.\n\t            // So we use pointer event to both detect touch gesture and mouse behavior.\n\t            mountHandlers(pointerHandlerNames, this);\n\t\n\t            // FIXME\n\t            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n\t            // which does not prevent defuault behavior occasionally (which may cause view port\n\t            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n\t            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n\t            // touch screen. And we only support click behavior on MS touch screen now.\n\t\n\t            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n\t            // We dont support touch on IE on win7.\n\t            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n\t            // if (typeof MSGesture === 'function') {\n\t            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n\t            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n\t            // }\n\t        }\n\t        else {\n\t            if (env.touchEventsSupported) {\n\t                mountHandlers(touchHandlerNames, this);\n\t                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t            }\n\t\n\t            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n\t            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t            // mouse event can not be handle in those devices.\n\t            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n\t            // mouseevent after touch event triggered, see `setTouchTimer`.\n\t            mountHandlers(mouseHandlerNames, this);\n\t        }\n\t\n\t        function mountHandlers(handlerNames, instance) {\n\t            zrUtil.each(handlerNames, function (name) {\n\t                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t            }, instance);\n\t        }\n\t    }\n\t\n\t    var handlerDomProxyProto = HandlerDomProxy.prototype;\n\t    handlerDomProxyProto.dispose = function () {\n\t        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t\n\t        for (var i = 0; i < handlerNames.length; i++) {\n\t            var name = handlerNames[i];\n\t            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t        }\n\t    };\n\t\n\t    handlerDomProxyProto.setCursor = function (cursorStyle) {\n\t        this.dom.style.cursor = cursorStyle || 'default';\n\t    };\n\t\n\t    zrUtil.mixin(HandlerDomProxy, Eventful);\n\t\n\t    module.exports = HandlerDomProxy;\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Only implements needed gestures for mobile.\n\t */\n\t\n\t\n\t    var eventUtil = __webpack_require__(27);\n\t\n\t    var GestureMgr = function () {\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._track = [];\n\t    };\n\t\n\t    GestureMgr.prototype = {\n\t\n\t        constructor: GestureMgr,\n\t\n\t        recognize: function (event, target, root) {\n\t            this._doTrack(event, target, root);\n\t            return this._recognize(event);\n\t        },\n\t\n\t        clear: function () {\n\t            this._track.length = 0;\n\t            return this;\n\t        },\n\t\n\t        _doTrack: function (event, target, root) {\n\t            var touches = event.touches;\n\t\n\t            if (!touches) {\n\t                return;\n\t            }\n\t\n\t            var trackItem = {\n\t                points: [],\n\t                touches: [],\n\t                target: target,\n\t                event: event\n\t            };\n\t\n\t            for (var i = 0, len = touches.length; i < len; i++) {\n\t                var touch = touches[i];\n\t                var pos = eventUtil.clientToLocal(root, touch, {});\n\t                trackItem.points.push([pos.zrX, pos.zrY]);\n\t                trackItem.touches.push(touch);\n\t            }\n\t\n\t            this._track.push(trackItem);\n\t        },\n\t\n\t        _recognize: function (event) {\n\t            for (var eventName in recognizers) {\n\t                if (recognizers.hasOwnProperty(eventName)) {\n\t                    var gestureInfo = recognizers[eventName](this._track, event);\n\t                    if (gestureInfo) {\n\t                        return gestureInfo;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    function dist(pointPair) {\n\t        var dx = pointPair[1][0] - pointPair[0][0];\n\t        var dy = pointPair[1][1] - pointPair[0][1];\n\t\n\t        return Math.sqrt(dx * dx + dy * dy);\n\t    }\n\t\n\t    function center(pointPair) {\n\t        return [\n\t            (pointPair[0][0] + pointPair[1][0]) / 2,\n\t            (pointPair[0][1] + pointPair[1][1]) / 2\n\t        ];\n\t    }\n\t\n\t    var recognizers = {\n\t\n\t        pinch: function (track, event) {\n\t            var trackLen = track.length;\n\t\n\t            if (!trackLen) {\n\t                return;\n\t            }\n\t\n\t            var pinchEnd = (track[trackLen - 1] || {}).points;\n\t            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t\n\t            if (pinchPre\n\t                && pinchPre.length > 1\n\t                && pinchEnd\n\t                && pinchEnd.length > 1\n\t            ) {\n\t                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t                !isFinite(pinchScale) && (pinchScale = 1);\n\t\n\t                event.pinchScale = pinchScale;\n\t\n\t                var pinchCenter = center(pinchEnd);\n\t                event.pinchX = pinchCenter[0];\n\t                event.pinchY = pinchCenter[1];\n\t\n\t                return {\n\t                    type: 'pinch',\n\t                    target: track[0].target,\n\t                    event: event\n\t                };\n\t            }\n\t        }\n\t\n\t        // Only pinch currently.\n\t    };\n\t\n\t    module.exports = GestureMgr;\n\t\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Default canvas painter\n\t * @module zrender/Painter\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t \n\t\n\t    var config = __webpack_require__(23);\n\t    var util = __webpack_require__(6);\n\t    var log = __webpack_require__(22);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var timsort = __webpack_require__(25);\n\t\n\t    var Layer = __webpack_require__(32);\n\t\n\t    var requestAnimationFrame = __webpack_require__(28);\n\t\n\t    // PENDIGN\n\t    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t    //\n\t    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\t    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t\n\t    function isLayerValid(layer) {\n\t        if (!layer) {\n\t            return false;\n\t        }\n\t\n\t        if (layer.__builtin__) {\n\t            return true;\n\t        }\n\t\n\t        if (typeof(layer.resize) !== 'function'\n\t            || typeof(layer.refresh) !== 'function'\n\t        ) {\n\t            return false;\n\t        }\n\t\n\t        return true;\n\t    }\n\t\n\t    function preProcessLayer(layer) {\n\t        layer.__unusedCount++;\n\t    }\n\t\n\t    function postProcessLayer(layer) {\n\t        if (layer.__unusedCount == 1) {\n\t            layer.clear();\n\t        }\n\t    }\n\t\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var viewRect = new BoundingRect(0, 0, 0, 0);\n\t    function isDisplayableCulled(el, width, height) {\n\t        tmpRect.copy(el.getBoundingRect());\n\t        if (el.transform) {\n\t            tmpRect.applyTransform(el.transform);\n\t        }\n\t        viewRect.width = width;\n\t        viewRect.height = height;\n\t        return !tmpRect.intersect(viewRect);\n\t    }\n\t\n\t    function isClipPathChanged(clipPaths, prevClipPaths) {\n\t        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n\t            return false;\n\t        }\n\t\n\t        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n\t            return true;\n\t        }\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            if (clipPaths[i] !== prevClipPaths[i]) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t\n\t    function doClip(clipPaths, ctx) {\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            var clipPath = clipPaths[i];\n\t            var path = clipPath.path;\n\t\n\t            clipPath.setTransform(ctx);\n\t            path.beginPath(ctx);\n\t            clipPath.buildPath(path, clipPath.shape);\n\t            ctx.clip();\n\t            // Transform back\n\t            clipPath.restoreTransform(ctx);\n\t        }\n\t    }\n\t\n\t    function createRoot(width, height) {\n\t        var domRoot = document.createElement('div');\n\t\n\t        // domRoot.onselectstart = returnFalse; // \n\t        domRoot.style.cssText = [\n\t            'position:relative',\n\t            'overflow:hidden',\n\t            'width:' + width + 'px',\n\t            'height:' + height + 'px',\n\t            'padding:0',\n\t            'margin:0',\n\t            'border-width:0'\n\t        ].join(';') + ';';\n\t\n\t        return domRoot;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Painter\n\t     * @constructor\n\t     * @param {HTMLElement} root \n\t     * @param {module:zrender/Storage} storage\n\t     * @param {Ojbect} opts\n\t     */\n\t    var Painter = function (root, storage, opts) {\n\t        // In node environment using node-canvas\n\t        var singleCanvas = !root.nodeName // In node ?\n\t            || root.nodeName.toUpperCase() === 'CANVAS';\n\t\n\t        this._opts = opts = util.extend({}, opts || {});\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._singleCanvas = singleCanvas;\n\t        /**\n\t         * \n\t         * @type {HTMLElement}\n\t         */\n\t        this.root = root;\n\t\n\t        var rootStyle = root.style;\n\t\n\t        if (rootStyle) {\n\t            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t            rootStyle['-webkit-user-select'] =\n\t            rootStyle['user-select'] =\n\t            rootStyle['-webkit-touch-callout'] = 'none';\n\t\n\t            root.innerHTML = '';\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/Storage}\n\t         */\n\t        this.storage = storage;\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        var zlevelList = this._zlevelList = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:zrender/Layer>}\n\t         * @private\n\t         */\n\t        var layers = this._layers = {};\n\t\n\t        /**\n\t         * @type {Object.<string, Object>}\n\t         * @type {private}\n\t         */\n\t        this._layerConfig = {};\n\t\n\t        if (!singleCanvas) {\n\t            this._width = this._getSize(0);\n\t            this._height = this._getSize(1);\n\t\n\t            var domRoot = this._domRoot = createRoot(\n\t                this._width, this._height\n\t            );\n\t            root.appendChild(domRoot);\n\t        }\n\t        else {\n\t            if (opts.width != null) {\n\t                root.width = opts.width;\n\t            }\n\t            if (opts.height != null) {\n\t                root.height = opts.height;\n\t            }\n\t            // Use canvas width and height directly\n\t            var width = root.width;\n\t            var height = root.height;\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            // Create layer if only one given canvas\n\t            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t            var mainLayer = new Layer(root, this, 1);\n\t            mainLayer.initContext();\n\t            // FIXME Use canvas width and height\n\t            // mainLayer.resize(width, height);\n\t            layers[0] = mainLayer;\n\t            zlevelList.push(0);\n\t\n\t            this._domRoot = root;\n\t        }\n\t\n\t        // Layers for progressive rendering\n\t        this._progressiveLayers = [];\n\t\n\t        /**\n\t         * @type {module:zrender/Layer}\n\t         * @private\n\t         */\n\t        this._hoverlayer;\n\t\n\t        this._hoverElements = [];\n\t    };\n\t\n\t    Painter.prototype = {\n\t\n\t        constructor: Painter,\n\t\n\t        /**\n\t         * If painter use a single canvas\n\t         * @return {boolean}\n\t         */\n\t        isSingleCanvas: function () {\n\t            return this._singleCanvas;\n\t        },\n\t        /**\n\t         * @return {HTMLDivElement}\n\t         */\n\t        getViewportRoot: function () {\n\t            return this._domRoot;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} [paintAll=false] displayable\n\t         */\n\t        refresh: function (paintAll) {\n\t\n\t            var list = this.storage.getDisplayList(true);\n\t\n\t            var zlevelList = this._zlevelList;\n\t\n\t            this._paintList(list, paintAll);\n\t\n\t            // Paint custum layers\n\t            for (var i = 0; i < zlevelList.length; i++) {\n\t                var z = zlevelList[i];\n\t                var layer = this._layers[z];\n\t                if (!layer.__builtin__ && layer.refresh) {\n\t                    layer.refresh();\n\t                }\n\t            }\n\t\n\t            this.refreshHover();\n\t\n\t            if (this._progressiveLayers.length) {\n\t                this._startProgessive();\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        addHover: function (el, hoverStyle) {\n\t            if (el.__hoverMir) {\n\t                return;\n\t            }\n\t            var elMirror = new el.constructor({\n\t                style: el.style,\n\t                shape: el.shape\n\t            });\n\t            elMirror.__from = el;\n\t            el.__hoverMir = elMirror;\n\t            elMirror.setStyle(hoverStyle);\n\t            this._hoverElements.push(elMirror);\n\t        },\n\t\n\t        removeHover: function (el) {\n\t            var elMirror = el.__hoverMir;\n\t            var hoverElements = this._hoverElements;\n\t            var idx = util.indexOf(hoverElements, elMirror);\n\t            if (idx >= 0) {\n\t                hoverElements.splice(idx, 1);\n\t            }\n\t            el.__hoverMir = null;\n\t        },\n\t\n\t        clearHover: function (el) {\n\t            var hoverElements = this._hoverElements;\n\t            for (var i = 0; i < hoverElements.length; i++) {\n\t                var from = hoverElements[i].__from;\n\t                if (from) {\n\t                    from.__hoverMir = null;\n\t                }\n\t            }\n\t            hoverElements.length = 0;\n\t        },\n\t\n\t        refreshHover: function () {\n\t            var hoverElements = this._hoverElements;\n\t            var len = hoverElements.length;\n\t            var hoverLayer = this._hoverlayer;\n\t            hoverLayer && hoverLayer.clear();\n\t\n\t            if (!len) {\n\t                return;\n\t            }\n\t            timsort(hoverElements, this.storage.displayableSortFunc);\n\t\n\t            // Use a extream large zlevel\n\t            // FIXME?\n\t            if (!hoverLayer) {\n\t                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n\t            }\n\t\n\t            var scope = {};\n\t            hoverLayer.ctx.save();\n\t            for (var i = 0; i < len;) {\n\t                var el = hoverElements[i];\n\t                var originalEl = el.__from;\n\t                // Original el is removed\n\t                // PENDING\n\t                if (!(originalEl && originalEl.__zr)) {\n\t                    hoverElements.splice(i, 1);\n\t                    originalEl.__hoverMir = null;\n\t                    len--;\n\t                    continue;\n\t                }\n\t                i++;\n\t\n\t                // Use transform\n\t                // FIXME style and shape ?\n\t                if (!originalEl.invisible) {\n\t                    el.transform = originalEl.transform;\n\t                    el.invTransform = originalEl.invTransform;\n\t                    el.__clipPaths = originalEl.__clipPaths;\n\t                    // el.\n\t                    this._doPaintEl(el, hoverLayer, true, scope);\n\t                }\n\t            }\n\t            hoverLayer.ctx.restore();\n\t        },\n\t\n\t        _startProgessive: function () {\n\t            var self = this;\n\t\n\t            if (!self._furtherProgressive) {\n\t                return;\n\t            }\n\t\n\t            // Use a token to stop progress steps triggered by\n\t            // previous zr.refresh calling.\n\t            var token = self._progressiveToken = +new Date();\n\t\n\t            self._progress++;\n\t            requestAnimationFrame(step);\n\t\n\t            function step() {\n\t                // In case refreshed or disposed\n\t                if (token === self._progressiveToken && self.storage) {\n\t\n\t                    self._doPaintList(self.storage.getDisplayList());\n\t\n\t                    if (self._furtherProgressive) {\n\t                        self._progress++;\n\t                        requestAnimationFrame(step);\n\t                    }\n\t                    else {\n\t                        self._progressiveToken = -1;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _clearProgressive: function () {\n\t            this._progressiveToken = -1;\n\t            this._progress = 0;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                layer.__dirty && layer.clear();\n\t            });\n\t        },\n\t\n\t        _paintList: function (list, paintAll) {\n\t\n\t            if (paintAll == null) {\n\t                paintAll = false;\n\t            }\n\t\n\t            this._updateLayerStatus(list);\n\t\n\t            this._clearProgressive();\n\t\n\t            this.eachBuiltinLayer(preProcessLayer);\n\t\n\t            this._doPaintList(list, paintAll);\n\t\n\t            this.eachBuiltinLayer(postProcessLayer);\n\t        },\n\t\n\t        _doPaintList: function (list, paintAll) {\n\t            var currentLayer;\n\t            var currentZLevel;\n\t            var ctx;\n\t\n\t            // var invTransform = [];\n\t            var scope;\n\t\n\t            var progressiveLayerIdx = 0;\n\t            var currentProgressiveLayer;\n\t\n\t            var width = this._width;\n\t            var height = this._height;\n\t            var layerProgress;\n\t            var frame = this._progress;\n\t            function flushProgressiveLayer(layer) {\n\t                var dpr = ctx.dpr || 1;\n\t                ctx.save();\n\t                ctx.globalAlpha = 1;\n\t                ctx.shadowBlur = 0;\n\t                // Avoid layer don't clear in next progressive frame\n\t                currentLayer.__dirty = true;\n\t                ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t                ctx.restore();\n\t            }\n\t\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t\n\t                var elFrame = el.__frame;\n\t\n\t                // Flush at current context\n\t                // PENDING\n\t                if (elFrame < 0 && currentProgressiveLayer) {\n\t                    flushProgressiveLayer(currentProgressiveLayer);\n\t                    currentProgressiveLayer = null;\n\t                }\n\t\n\t                // Change draw layer\n\t                if (currentZLevel !== elZLevel) {\n\t                    if (ctx) {\n\t                        ctx.restore();\n\t                    }\n\t\n\t                    // Reset scope\n\t                    scope = {};\n\t\n\t                    // Only 0 zlevel if only has one canvas\n\t                    currentZLevel = elZLevel;\n\t                    currentLayer = this.getLayer(currentZLevel);\n\t\n\t                    if (!currentLayer.__builtin__) {\n\t                        log(\n\t                            'ZLevel ' + currentZLevel\n\t                            + ' has been used by unkown layer ' + currentLayer.id\n\t                        );\n\t                    }\n\t\n\t                    ctx = currentLayer.ctx;\n\t                    ctx.save();\n\t\n\t                    // Reset the count\n\t                    currentLayer.__unusedCount = 0;\n\t\n\t                    if (currentLayer.__dirty || paintAll) {\n\t                        currentLayer.clear();\n\t                    }\n\t                }\n\t\n\t                if (!(currentLayer.__dirty || paintAll)) {\n\t                    continue;\n\t                }\n\t\n\t                if (elFrame >= 0) {\n\t                    // Progressive layer changed\n\t                    if (!currentProgressiveLayer) {\n\t                        currentProgressiveLayer = this._progressiveLayers[\n\t                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n\t                        ];\n\t\n\t                        currentProgressiveLayer.ctx.save();\n\t                        currentProgressiveLayer.renderScope = {};\n\t\n\t                        if (currentProgressiveLayer\n\t                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n\t                        ) {\n\t                            // flushProgressiveLayer(currentProgressiveLayer);\n\t                            // Quick jump all progressive elements\n\t                            // All progressive element are not dirty, jump over and flush directly\n\t                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n\t                            // currentProgressiveLayer = null;\n\t                            continue;\n\t                        }\n\t\n\t                        layerProgress = currentProgressiveLayer.__progress;\n\t\n\t                        if (!currentProgressiveLayer.__dirty) {\n\t                            // Keep rendering\n\t                            frame = layerProgress;\n\t                        }\n\t\n\t                        currentProgressiveLayer.__progress = frame + 1;\n\t                    }\n\t\n\t                    if (elFrame === frame) {\n\t                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t                    }\n\t                }\n\t                else {\n\t                    this._doPaintEl(el, currentLayer, paintAll, scope);\n\t                }\n\t\n\t                el.__dirty = false;\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                flushProgressiveLayer(currentProgressiveLayer);\n\t            }\n\t\n\t            // Restore the lastLayer ctx\n\t            ctx && ctx.restore();\n\t            // If still has clipping state\n\t            // if (scope.prevElClipPaths) {\n\t            //     ctx.restore();\n\t            // }\n\t\n\t            this._furtherProgressive = false;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                if (layer.__maxProgress >= layer.__progress) {\n\t                    this._furtherProgressive = true;\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t            var ctx = currentLayer.ctx;\n\t            var m = el.transform;\n\t            if (\n\t                (currentLayer.__dirty || forcePaint)\n\t                // Ignore invisible element\n\t                && !el.invisible\n\t                // Ignore transparent element\n\t                && el.style.opacity !== 0\n\t                // Ignore scale 0 element, in some environment like node-canvas\n\t                // Draw a scale 0 element can cause all following draw wrong\n\t                // And setTransform with scale 0 will cause set back transform failed.\n\t                && !(m && !m[0] && !m[3])\n\t                // Ignore culled element\n\t                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n\t            ) {\n\t\n\t                var clipPaths = el.__clipPaths;\n\t\n\t                // Optimize when clipping on group with several elements\n\t                if (scope.prevClipLayer !== currentLayer\n\t                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n\t                ) {\n\t                    // If has previous clipping state, restore from it\n\t                    if (scope.prevElClipPaths) {\n\t                        scope.prevClipLayer.ctx.restore();\n\t                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\t\n\t                        // Reset prevEl since context has been restored\n\t                        scope.prevEl = null;\n\t                    }\n\t                    // New clipping state\n\t                    if (clipPaths) {\n\t                        ctx.save();\n\t                        doClip(clipPaths, ctx);\n\t                        scope.prevClipLayer = currentLayer;\n\t                        scope.prevElClipPaths = clipPaths;\n\t                    }\n\t                }\n\t                el.beforeBrush && el.beforeBrush(ctx);\n\t\n\t                el.brush(ctx, scope.prevEl || null);\n\t                scope.prevEl = el;\n\t\n\t                el.afterBrush && el.afterBrush(ctx);\n\t            }\n\t        },\n\t\n\t        /**\n\t         *  zlevel \n\t         * @param {number} zlevel\n\t         * @return {module:zrender/Layer}\n\t         */\n\t        getLayer: function (zlevel) {\n\t            if (this._singleCanvas) {\n\t                return this._layers[0];\n\t            }\n\t\n\t            var layer = this._layers[zlevel];\n\t            if (!layer) {\n\t                // Create a new layer\n\t                layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t                layer.__builtin__ = true;\n\t\n\t                if (this._layerConfig[zlevel]) {\n\t                    util.merge(layer, this._layerConfig[zlevel], true);\n\t                }\n\t\n\t                this.insertLayer(zlevel, layer);\n\t\n\t                // Context is created after dom inserted to document\n\t                // Or excanvas will get 0px clientWidth and clientHeight\n\t                layer.initContext();\n\t            }\n\t\n\t            return layer;\n\t        },\n\t\n\t        insertLayer: function (zlevel, layer) {\n\t\n\t            var layersMap = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var len = zlevelList.length;\n\t            var prevLayer = null;\n\t            var i = -1;\n\t            var domRoot = this._domRoot;\n\t\n\t            if (layersMap[zlevel]) {\n\t                log('ZLevel ' + zlevel + ' has been used already');\n\t                return;\n\t            }\n\t            // Check if is a valid layer\n\t            if (!isLayerValid(layer)) {\n\t                log('Layer of zlevel ' + zlevel + ' is not valid');\n\t                return;\n\t            }\n\t\n\t            if (len > 0 && zlevel > zlevelList[0]) {\n\t                for (i = 0; i < len - 1; i++) {\n\t                    if (\n\t                        zlevelList[i] < zlevel\n\t                        && zlevelList[i + 1] > zlevel\n\t                    ) {\n\t                        break;\n\t                    }\n\t                }\n\t                prevLayer = layersMap[zlevelList[i]];\n\t            }\n\t            zlevelList.splice(i + 1, 0, zlevel);\n\t\n\t            layersMap[zlevel] = layer;\n\t\n\t            // Vitual layer will not directly show on the screen.\n\t            // (It can be a WebGL layer and assigned to a ZImage element)\n\t            // But it still under management of zrender.\n\t            if (!layer.virtual) {\n\t                if (prevLayer) {\n\t                    var prevDom = prevLayer.dom;\n\t                    if (prevDom.nextSibling) {\n\t                        domRoot.insertBefore(\n\t                            layer.dom,\n\t                            prevDom.nextSibling\n\t                        );\n\t                    }\n\t                    else {\n\t                        domRoot.appendChild(layer.dom);\n\t                    }\n\t                }\n\t                else {\n\t                    if (domRoot.firstChild) {\n\t                        domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t                    }\n\t                    else {\n\t                        domRoot.appendChild(layer.dom);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        // Iterate each layer\n\t        eachLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                cb.call(context, this._layers[z], z);\n\t            }\n\t        },\n\t\n\t        // Iterate each buildin layer\n\t        eachBuiltinLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (layer.__builtin__) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        // Iterate each other layer except buildin layer\n\t        eachOtherLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (!layer.__builtin__) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Array.<module:zrender/Layer>} [prevLayer]\n\t         */\n\t        getLayers: function () {\n\t            return this._layers;\n\t        },\n\t\n\t        _updateLayerStatus: function (list) {\n\t\n\t            var layers = this._layers;\n\t            var progressiveLayers = this._progressiveLayers;\n\t\n\t            var elCountsLastFrame = {};\n\t            var progressiveElCountsLastFrame = {};\n\t\n\t            this.eachBuiltinLayer(function (layer, z) {\n\t                elCountsLastFrame[z] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                progressiveElCountsLastFrame[idx] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            var progressiveLayerCount = 0;\n\t            var currentProgressiveLayer;\n\t            var lastProgressiveKey;\n\t            var frameCount = 0;\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var layer = layers[zlevel];\n\t                var elProgress = el.progressive;\n\t                if (layer) {\n\t                    layer.elCount++;\n\t                    layer.__dirty = layer.__dirty || el.__dirty;\n\t                }\n\t\n\t                /////// Update progressive\n\t                if (elProgress >= 0) {\n\t                    // Fix wrong progressive sequence problem.\n\t                    if (lastProgressiveKey !== elProgress) {\n\t                        lastProgressiveKey = elProgress;\n\t                        frameCount++;\n\t                    }\n\t                    var elFrame = el.__frame = frameCount - 1;\n\t                    if (!currentProgressiveLayer) {\n\t                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t                        currentProgressiveLayer = progressiveLayers[idx];\n\t                        if (!currentProgressiveLayer) {\n\t                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n\t                                'progressive', this, this.dpr\n\t                            );\n\t                            currentProgressiveLayer.initContext();\n\t                        }\n\t                        currentProgressiveLayer.__maxProgress = 0;\n\t                    }\n\t                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t                    currentProgressiveLayer.elCount++;\n\t\n\t                    currentProgressiveLayer.__maxProgress = Math.max(\n\t                        currentProgressiveLayer.__maxProgress, elFrame\n\t                    );\n\t\n\t                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t                        // Should keep rendering this  layer because progressive rendering is not finished yet\n\t                        layer.__dirty = true;\n\t                    }\n\t                }\n\t                else {\n\t                    el.__frame = -1;\n\t\n\t                    if (currentProgressiveLayer) {\n\t                        currentProgressiveLayer.__nextIdxNotProg = i;\n\t                        progressiveLayerCount++;\n\t                        currentProgressiveLayer = null;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                progressiveLayerCount++;\n\t                currentProgressiveLayer.__nextIdxNotProg = i;\n\t            }\n\t\n\t            // \n\t            this.eachBuiltinLayer(function (layer, z) {\n\t                if (elCountsLastFrame[z] !== layer.elCount) {\n\t                    layer.__dirty = true;\n\t                }\n\t            });\n\t\n\t            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t                    el.__dirty = true;\n\t                }\n\t                if (layer.__dirty) {\n\t                    layer.__progress = 0;\n\t                }\n\t            });\n\t        },\n\t\n\t        /**\n\t         * hover\n\t         */\n\t        clear: function () {\n\t            this.eachBuiltinLayer(this._clearLayer);\n\t            return this;\n\t        },\n\t\n\t        _clearLayer: function (layer) {\n\t            layer.clear();\n\t        },\n\t\n\t        /**\n\t         * zlevel\n\t         *\n\t         * @param {string} zlevel\n\t         * @param {Object} config \n\t         * @param {string} [config.clearColor=0] \n\t         * @param {string} [config.motionBlur=false] \n\t         * @param {number} [config.lastFrameAlpha=0.7]\n\t         *                 alpha\n\t         */\n\t        configLayer: function (zlevel, config) {\n\t            if (config) {\n\t                var layerConfig = this._layerConfig;\n\t                if (!layerConfig[zlevel]) {\n\t                    layerConfig[zlevel] = config;\n\t                }\n\t                else {\n\t                    util.merge(layerConfig[zlevel], config, true);\n\t                }\n\t\n\t                var layer = this._layers[zlevel];\n\t\n\t                if (layer) {\n\t                    util.merge(layer, layerConfig[zlevel], true);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {number} zlevel zlevel\n\t         */\n\t        delLayer: function (zlevel) {\n\t            var layers = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var layer = layers[zlevel];\n\t            if (!layer) {\n\t                return;\n\t            }\n\t            layer.dom.parentNode.removeChild(layer.dom);\n\t            delete layers[zlevel];\n\t\n\t            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        resize: function (width, height) {\n\t            var domRoot = this._domRoot;\n\t            // FIXME Why ?\n\t            domRoot.style.display = 'none';\n\t\n\t            // Save input w/h\n\t            var opts = this._opts;\n\t            width != null && (opts.width = width);\n\t            height != null && (opts.height = height);\n\t\n\t            width = this._getSize(0);\n\t            height = this._getSize(1);\n\t\n\t            domRoot.style.display = '';\n\t\n\t            // resize\n\t            if (this._width != width || height != this._height) {\n\t                domRoot.style.width = width + 'px';\n\t                domRoot.style.height = height + 'px';\n\t\n\t                for (var id in this._layers) {\n\t                    if (this._layers.hasOwnProperty(id)) {\n\t                        this._layers[id].resize(width, height);\n\t                    }\n\t                }\n\t                util.each(this._progressiveLayers, function (layer) {\n\t                    layer.resize(width, height);\n\t                });\n\t\n\t                this.refresh(true);\n\t            }\n\t\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {number} zlevel\n\t         */\n\t        clearLayer: function (zlevel) {\n\t            var layer = this._layers[zlevel];\n\t            if (layer) {\n\t                layer.clear();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t\n\t            this.root =\n\t            this.storage =\n\t\n\t            this._domRoot =\n\t            this._layers = null;\n\t        },\n\t\n\t        /**\n\t         * Get canvas which has all thing rendered\n\t         * @param {Object} opts\n\t         * @param {string} [opts.backgroundColor]\n\t         */\n\t        getRenderedCanvas: function (opts) {\n\t            opts = opts || {};\n\t            if (this._singleCanvas) {\n\t                return this._layers[0].dom;\n\t            }\n\t\n\t            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t            imageLayer.initContext();\n\t\n\t            imageLayer.clearColor = opts.backgroundColor;\n\t            imageLayer.clear();\n\t\n\t            var displayList = this.storage.getDisplayList(true);\n\t\n\t            var scope = {};\n\t            for (var i = 0; i < displayList.length; i++) {\n\t                var el = displayList[i];\n\t                this._doPaintEl(el, imageLayer, true, scope);\n\t            }\n\t\n\t            return imageLayer.dom;\n\t        },\n\t        /**\n\t         * \n\t         */\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t\n\t        _getSize: function (whIdx) {\n\t            var opts = this._opts;\n\t            var wh = ['width', 'height'][whIdx];\n\t            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n\t            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n\t            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\t\n\t            if (opts[wh] != null && opts[wh] !== 'auto') {\n\t                return parseFloat(opts[wh]);\n\t            }\n\t\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t\n\t            return (\n\t                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n\t                - (parseInt10(stl[plt]) || 0)\n\t                - (parseInt10(stl[prb]) || 0)\n\t            ) | 0;\n\t        },\n\t\n\t        pathToImage: function (path, dpr) {\n\t            dpr = dpr || this.dpr;\n\t\n\t            var canvas = document.createElement('canvas');\n\t            var ctx = canvas.getContext('2d');\n\t            var rect = path.getBoundingRect();\n\t            var style = path.style;\n\t            var shadowBlurSize = style.shadowBlur;\n\t            var shadowOffsetX = style.shadowOffsetX;\n\t            var shadowOffsetY = style.shadowOffsetY;\n\t            var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\t\n\t            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n\t            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n\t            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n\t            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n\t            var width = rect.width + leftMargin + rightMargin;\n\t            var height = rect.height + topMargin + bottomMargin;\n\t\n\t            canvas.width = width * dpr;\n\t            canvas.height = height * dpr;\n\t\n\t            ctx.scale(dpr, dpr);\n\t            ctx.clearRect(0, 0, width, height);\n\t            ctx.dpr = dpr;\n\t\n\t            var pathTransform = {\n\t                position: path.position,\n\t                rotation: path.rotation,\n\t                scale: path.scale\n\t            };\n\t            path.position = [leftMargin - rect.x, topMargin - rect.y];\n\t            path.rotation = 0;\n\t            path.scale = [1, 1];\n\t            path.updateTransform();\n\t            if (path) {\n\t                path.brush(ctx);\n\t            }\n\t\n\t            var ImageShape = __webpack_require__(35);\n\t            var imgShape = new ImageShape({\n\t                style: {\n\t                    x: 0,\n\t                    y: 0,\n\t                    image: canvas\n\t                }\n\t            });\n\t\n\t            if (pathTransform.position != null) {\n\t                imgShape.position = path.position = pathTransform.position;\n\t            }\n\t\n\t            if (pathTransform.rotation != null) {\n\t                imgShape.rotation = path.rotation = pathTransform.rotation;\n\t            }\n\t\n\t            if (pathTransform.scale != null) {\n\t                imgShape.scale = path.scale = pathTransform.scale;\n\t            }\n\t\n\t            return imgShape;\n\t        }\n\t    };\n\t\n\t    module.exports = Painter;\n\t\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/Layer\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(6);\n\t    var config = __webpack_require__(23);\n\t    var Style = __webpack_require__(33);\n\t    var Pattern = __webpack_require__(34);\n\t\n\t    function returnFalse() {\n\t        return false;\n\t    }\n\t\n\t    /**\n\t     * dom\n\t     *\n\t     * @inner\n\t     * @param {string} id dom id \n\t     * @param {string} type dom typesuch as canvas, div etc.\n\t     * @param {Painter} painter painter instance\n\t     * @param {number} number\n\t     */\n\t    function createDom(id, type, painter, dpr) {\n\t        var newDom = document.createElement(type);\n\t        var width = painter.getWidth();\n\t        var height = painter.getHeight();\n\t\n\t        var newDomStyle = newDom.style;\n\t        // append~\n\t        newDomStyle.position = 'absolute';\n\t        newDomStyle.left = 0;\n\t        newDomStyle.top = 0;\n\t        newDomStyle.width = width + 'px';\n\t        newDomStyle.height = height + 'px';\n\t        newDom.width = width * dpr;\n\t        newDom.height = height * dpr;\n\t\n\t        // id\n\t        newDom.setAttribute('data-zr-dom-id', id);\n\t        return newDom;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Layer\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @param {string} id\n\t     * @param {module:zrender/Painter} painter\n\t     * @param {number} [dpr]\n\t     */\n\t    var Layer = function(id, painter, dpr) {\n\t        var dom;\n\t        dpr = dpr || config.devicePixelRatio;\n\t        if (typeof id === 'string') {\n\t            dom = createDom(id, 'canvas', painter, dpr);\n\t        }\n\t        // Not using isDom because in node it will return false\n\t        else if (util.isObject(id)) {\n\t            dom = id;\n\t            id = dom.id;\n\t        }\n\t        this.id = id;\n\t        this.dom = dom;\n\t\n\t        var domStyle = dom.style;\n\t        if (domStyle) { // Not in node\n\t            dom.onselectstart = returnFalse; // \n\t            domStyle['-webkit-user-select'] = 'none';\n\t            domStyle['user-select'] = 'none';\n\t            domStyle['-webkit-touch-callout'] = 'none';\n\t            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t            domStyle['padding'] = 0;\n\t            domStyle['margin'] = 0;\n\t            domStyle['border-width'] = 0;\n\t        }\n\t\n\t        this.domBack = null;\n\t        this.ctxBack = null;\n\t\n\t        this.painter = painter;\n\t\n\t        this.config = null;\n\t\n\t        // Configs\n\t        /**\n\t         * \n\t         * @type {string}\n\t         * @default 0\n\t         */\n\t        this.clearColor = 0;\n\t        /**\n\t         * \n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        this.motionBlur = false;\n\t        /**\n\t         * alpha\n\t         * @type {number}\n\t         * @default 0.7\n\t         */\n\t        this.lastFrameAlpha = 0.7;\n\t\n\t        /**\n\t         * Layer dpr\n\t         * @type {number}\n\t         */\n\t        this.dpr = dpr;\n\t    };\n\t\n\t    Layer.prototype = {\n\t\n\t        constructor: Layer,\n\t\n\t        elCount: 0,\n\t\n\t        __dirty: true,\n\t\n\t        initContext: function () {\n\t            this.ctx = this.dom.getContext('2d');\n\t\n\t            this.ctx.dpr = this.dpr;\n\t        },\n\t\n\t        createBackBuffer: function () {\n\t            var dpr = this.dpr;\n\t\n\t            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n\t            this.ctxBack = this.domBack.getContext('2d');\n\t\n\t            if (dpr != 1) {\n\t                this.ctxBack.scale(dpr, dpr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param  {number} width\n\t         * @param  {number} height\n\t         */\n\t        resize: function (width, height) {\n\t            var dpr = this.dpr;\n\t\n\t            var dom = this.dom;\n\t            var domStyle = dom.style;\n\t            var domBack = this.domBack;\n\t\n\t            domStyle.width = width + 'px';\n\t            domStyle.height = height + 'px';\n\t\n\t            dom.width = width * dpr;\n\t            dom.height = height * dpr;\n\t\n\t            if (domBack) {\n\t                domBack.width = width * dpr;\n\t                domBack.height = height * dpr;\n\t\n\t                if (dpr != 1) {\n\t                    this.ctxBack.scale(dpr, dpr);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} clearAll Clear all with out motion blur\n\t         */\n\t        clear: function (clearAll) {\n\t            var dom = this.dom;\n\t            var ctx = this.ctx;\n\t            var width = dom.width;\n\t            var height = dom.height;\n\t\n\t            var clearColor = this.clearColor;\n\t            var haveMotionBLur = this.motionBlur && !clearAll;\n\t            var lastFrameAlpha = this.lastFrameAlpha;\n\t\n\t            var dpr = this.dpr;\n\t\n\t            if (haveMotionBLur) {\n\t                if (!this.domBack) {\n\t                    this.createBackBuffer();\n\t                }\n\t\n\t                this.ctxBack.globalCompositeOperation = 'copy';\n\t                this.ctxBack.drawImage(\n\t                    dom, 0, 0,\n\t                    width / dpr,\n\t                    height / dpr\n\t                );\n\t            }\n\t\n\t            ctx.clearRect(0, 0, width, height);\n\t            if (clearColor) {\n\t                var clearColorGradientOrPattern;\n\t                // Gradient\n\t                if (clearColor.colorStops) {\n\t                    // Cache canvas gradient\n\t                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t                        x: 0,\n\t                        y: 0,\n\t                        width: width,\n\t                        height: height\n\t                    });\n\t\n\t                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t                }\n\t                // Pattern\n\t                else if (clearColor.image) {\n\t                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t                }\n\t                ctx.save();\n\t                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t                ctx.fillRect(0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t\n\t            if (haveMotionBLur) {\n\t                var domBack = this.domBack;\n\t                ctx.save();\n\t                ctx.globalAlpha = lastFrameAlpha;\n\t                ctx.drawImage(domBack, 0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Layer;\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/graphic/Style\n\t */\n\t\n\t\n\t    var STYLE_COMMON_PROPS = [\n\t        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n\t        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n\t    ];\n\t\n\t    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t\n\t    var Style = function (opts) {\n\t        this.extendFrom(opts);\n\t    };\n\t\n\t    function createLinearGradient(ctx, obj, rect) {\n\t        // var size =\n\t        var x = obj.x;\n\t        var x2 = obj.x2;\n\t        var y = obj.y;\n\t        var y2 = obj.y2;\n\t\n\t        if (!obj.global) {\n\t            x = x * rect.width + rect.x;\n\t            x2 = x2 * rect.width + rect.x;\n\t            y = y * rect.height + rect.y;\n\t            y2 = y2 * rect.height + rect.y;\n\t        }\n\t\n\t        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t    function createRadialGradient(ctx, obj, rect) {\n\t        var width = rect.width;\n\t        var height = rect.height;\n\t        var min = Math.min(width, height);\n\t\n\t        var x = obj.x;\n\t        var y = obj.y;\n\t        var r = obj.r;\n\t        if (!obj.global) {\n\t            x = x * width + rect.x;\n\t            y = y * height + rect.y;\n\t            r = r * min;\n\t        }\n\t\n\t        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t\n\t    Style.prototype = {\n\t\n\t        constructor: Style,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        fill: '#000000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        stroke: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        opacity: 1,\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         */\n\t        lineDash: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineDashOffset: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowBlur: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetX: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetY: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineWidth: 1,\n\t\n\t        /**\n\t         * If stroke ignore scale\n\t         * @type {Boolean}\n\t         */\n\t        strokeNoScale: false,\n\t\n\t        // Bounding rect text configuration\n\t        // Not affected by element transform\n\t        /**\n\t         * @type {string}\n\t         */\n\t        text: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textFill: '#000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textStroke: null,\n\t\n\t        /**\n\t         * 'inside', 'left', 'right', 'top', 'bottom'\n\t         * [x, y]\n\t         * @type {string|Array.<number>}\n\t         * @default 'inside'\n\t         */\n\t        textPosition: 'inside',\n\t\n\t        /**\n\t         * [x, y]\n\t         * @type {Array.<number>}\n\t         */\n\t        textOffset: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textBaseline: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textAlign: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textVerticalAlign: null,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textDistance: 5,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowBlur: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetX: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetY: 0,\n\t\n\t        /**\n\t         * If transform text\n\t         * Only useful in Path and Image element\n\t         * @type {boolean}\n\t         */\n\t        textTransform: false,\n\t\n\t        /**\n\t         * Text rotate around position of Path or Image\n\t         * Only useful in Path and Image element and textTransform is false.\n\t         */\n\t        textRotation: 0,\n\t\n\t        /**\n\t         * @type {string}\n\t         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t         */\n\t        blend: null,\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         */\n\t        bind: function (ctx, el, prevEl) {\n\t            var style = this;\n\t            var prevStyle = prevEl && prevEl.style;\n\t            var firstDraw = !prevStyle;\n\t\n\t            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t                var prop = STYLE_COMMON_PROPS[i];\n\t                var styleName = prop[0];\n\t\n\t                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t                    // FIXME Invalid property value will cause style leak from previous element.\n\t                    ctx[styleName] = style[styleName] || prop[1];\n\t                }\n\t            }\n\t\n\t            if ((firstDraw || style.fill !== prevStyle.fill)) {\n\t                ctx.fillStyle = style.fill;\n\t            }\n\t            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n\t                ctx.strokeStyle = style.stroke;\n\t            }\n\t            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n\t                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t            }\n\t\n\t            if ((firstDraw || style.blend !== prevStyle.blend)) {\n\t                ctx.globalCompositeOperation = style.blend || 'source-over';\n\t            }\n\t            if (this.hasStroke()) {\n\t                var lineWidth = style.lineWidth;\n\t                ctx.lineWidth = lineWidth / (\n\t                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n\t                );\n\t            }\n\t        },\n\t\n\t        hasFill: function () {\n\t            var fill = this.fill;\n\t            return fill != null && fill !== 'none';\n\t        },\n\t\n\t        hasStroke: function () {\n\t            var stroke = this.stroke;\n\t            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t        },\n\t\n\t        /**\n\t         * Extend from other style\n\t         * @param {zrender/graphic/Style} otherStyle\n\t         * @param {boolean} overwrite\n\t         */\n\t        extendFrom: function (otherStyle, overwrite) {\n\t            if (otherStyle) {\n\t                var target = this;\n\t                for (var name in otherStyle) {\n\t                    if (otherStyle.hasOwnProperty(name)\n\t                        && (overwrite || ! target.hasOwnProperty(name))\n\t                    ) {\n\t                        target[name] = otherStyle[name];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Batch setting style with a given object\n\t         * @param {Object|string} obj\n\t         * @param {*} [obj]\n\t         */\n\t        set: function (obj, value) {\n\t            if (typeof obj === 'string') {\n\t                this[obj] = value;\n\t            }\n\t            else {\n\t                this.extendFrom(obj, true);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clone\n\t         * @return {zrender/graphic/Style} [description]\n\t         */\n\t        clone: function () {\n\t            var newStyle = new this.constructor();\n\t            newStyle.extendFrom(this, true);\n\t            return newStyle;\n\t        },\n\t\n\t        getGradient: function (ctx, obj, rect) {\n\t            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t            var canvasGradient = method(ctx, obj, rect);\n\t            var colorStops = obj.colorStops;\n\t            for (var i = 0; i < colorStops.length; i++) {\n\t                canvasGradient.addColorStop(\n\t                    colorStops[i].offset, colorStops[i].color\n\t                );\n\t            }\n\t            return canvasGradient;\n\t        }\n\t    };\n\t\n\t    var styleProto = Style.prototype;\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t        var prop = STYLE_COMMON_PROPS[i];\n\t        if (!(prop[0] in styleProto)) {\n\t            styleProto[prop[0]] = prop[1];\n\t        }\n\t    }\n\t\n\t    // Provide for others\n\t    Style.getGradient = styleProto.getGradient;\n\t\n\t    module.exports = Style;\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var Pattern = function (image, repeat) {\n\t        this.image = image;\n\t        this.repeat = repeat;\n\t\n\t        // Can be cloned\n\t        this.type = 'pattern';\n\t    };\n\t\n\t    Pattern.prototype.getCanvasPattern = function (ctx) {\n\t\n\t        return this._canvasPattern\n\t            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n\t    };\n\t\n\t    module.exports = Pattern;\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Image element\n\t * @module zrender/graphic/Image\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(36);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var zrUtil = __webpack_require__(6);\n\t\n\t    var LRU = __webpack_require__(21);\n\t    var globalImageCache = new LRU(50);\n\t    /**\n\t     * @alias zrender/graphic/Image\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function ZImage(opts) {\n\t        Displayable.call(this, opts);\n\t    }\n\t\n\t    ZImage.prototype = {\n\t\n\t        constructor: ZImage,\n\t\n\t        type: 'image',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var src = style.image;\n\t            var image;\n\t\n\t            // Must bind each time\n\t            style.bind(ctx, this, prevEl);\n\t            // style.image is a url string\n\t            if (typeof src === 'string') {\n\t                image = this._image;\n\t            }\n\t            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t            else {\n\t                image = src;\n\t            }\n\t            // FIXME Case create many images with src\n\t            if (!image && src) {\n\t                // Try get from global image cache\n\t                var cachedImgObj = globalImageCache.get(src);\n\t                if (!cachedImgObj) {\n\t                    // Create a new image\n\t                    image = new Image();\n\t                    image.onload = function () {\n\t                        image.onload = null;\n\t                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t                            cachedImgObj.pending[i].dirty();\n\t                        }\n\t                    };\n\t                    cachedImgObj = {\n\t                        image: image,\n\t                        pending: [this]\n\t                    };\n\t                    image.src = src;\n\t                    globalImageCache.put(src, cachedImgObj);\n\t                    this._image = image;\n\t                    return;\n\t                }\n\t                else {\n\t                    image = cachedImgObj.image;\n\t                    this._image = image;\n\t                    // Image is not complete finish, add to pending list\n\t                    if (!image.width || !image.height) {\n\t                        cachedImgObj.pending.push(this);\n\t                        return;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (image) {\n\t                // \n\t                // if (image.nodeName.toUpperCase() == 'IMG') {\n\t                //     if (!image.complete) {\n\t                //         return;\n\t                //     }\n\t                // }\n\t                // Else is canvas\n\t\n\t                var x = style.x || 0;\n\t                var y = style.y || 0;\n\t                // \n\t                if (!image.width || !image.height) {\n\t                    return;\n\t                }\n\t                var width = style.width;\n\t                var height = style.height;\n\t                var aspect = image.width / image.height;\n\t                if (width == null && height != null) {\n\t                    // Keep image/height ratio\n\t                    width = height * aspect;\n\t                }\n\t                else if (height == null && width != null) {\n\t                    height = width / aspect;\n\t                }\n\t                else if (width == null && height == null) {\n\t                    width = image.width;\n\t                    height = image.height;\n\t                }\n\t\n\t                // transform\n\t                this.setTransform(ctx);\n\t\n\t                if (style.sWidth && style.sHeight) {\n\t                    var sx = style.sx || 0;\n\t                    var sy = style.sy || 0;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, style.sWidth, style.sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else if (style.sx && style.sy) {\n\t                    var sx = style.sx;\n\t                    var sy = style.sy;\n\t                    var sWidth = width - sx;\n\t                    var sHeight = height - sy;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, sWidth, sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else {\n\t                    ctx.drawImage(image, x, y, width, height);\n\t                }\n\t\n\t                this.restoreTransform(ctx);\n\t\n\t                // Draw rect text\n\t                if (style.text != null) {\n\t                    this.drawRectText(ctx, this.getBoundingRect());\n\t                }\n\t\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t            if (! this._rect) {\n\t                this._rect = new BoundingRect(\n\t                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n\t                );\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(ZImage, Displayable);\n\t\n\t    module.exports = ZImage;\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * Base class of all displayable graphic objects\n\t * @module zrender/graphic/Displayable\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(6);\n\t\n\t    var Style = __webpack_require__(33);\n\t\n\t    var Element = __webpack_require__(12);\n\t    var RectText = __webpack_require__(37);\n\t    // var Stateful = require('./mixin/Stateful');\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Displayable\n\t     * @extends module:zrender/Element\n\t     * @extends module:zrender/graphic/mixin/RectText\n\t     */\n\t    function Displayable(opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        // Extend properties\n\t        for (var name in opts) {\n\t            if (\n\t                opts.hasOwnProperty(name) &&\n\t                name !== 'style'\n\t            ) {\n\t                this[name] = opts[name];\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/graphic/Style}\n\t         */\n\t        this.style = new Style(opts.style);\n\t\n\t        this._rect = null;\n\t        // Shapes for cascade clipping.\n\t        this.__clipPaths = [];\n\t\n\t        // FIXME Stateful must be mixined after style is setted\n\t        // Stateful.call(this, opts);\n\t    }\n\t\n\t    Displayable.prototype = {\n\t\n\t        constructor: Displayable,\n\t\n\t        type: 'displayable',\n\t\n\t        /**\n\t         * Displayable Painter \n\t         * Dirty flag. From which painter will determine if this displayable object needs brush\n\t         * @name module:zrender/graphic/Displayable#__dirty\n\t         * @type {boolean}\n\t         */\n\t        __dirty: true,\n\t\n\t        /**\n\t         * true\n\t         * If ignore drawing of the displayable object. Mouse event will still be triggered\n\t         * @name module:/zrender/graphic/Displayable#invisible\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        invisible: false,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z: 0,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z2: 0,\n\t\n\t        /**\n\t         * zlevelcanvas\n\t         * @name module:/zrender/graphic/Displayable#zlevel\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        zlevel: 0,\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        draggable: false,\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        dragging: false,\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/graphic/Displayable#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * If enable culling\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        culling: false,\n\t\n\t        /**\n\t         * Mouse cursor when hovered\n\t         * @name module:/zrender/graphic/Displayable#cursor\n\t         * @type {string}\n\t         */\n\t        cursor: 'pointer',\n\t\n\t        /**\n\t         * If hover area is bounding rect\n\t         * @name module:/zrender/graphic/Displayable#rectHover\n\t         * @type {string}\n\t         */\n\t        rectHover: false,\n\t\n\t        /**\n\t         * Render the element progressively when the value >= 0,\n\t         * usefull for large data.\n\t         * @type {number}\n\t         */\n\t        progressive: -1,\n\t\n\t        beforeBrush: function (ctx) {},\n\t\n\t        afterBrush: function (ctx) {},\n\t\n\t        /**\n\t         * \n\t         * @param {Canvas2DRenderingContext} ctx\n\t         */\n\t        // Interface\n\t        brush: function (ctx, prevEl) {},\n\t\n\t        /**\n\t         * \n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        // Interface\n\t        getBoundingRect: function () {},\n\t\n\t        /**\n\t         *  x, y \n\t         * If displayable element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        contain: function (x, y) {\n\t            return this.rectContain(x, y);\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            cb.call(context, this);\n\t        },\n\t\n\t        /**\n\t         *  x, y \n\t         * If bounding rect of element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        rectContain: function (x, y) {\n\t            var coord = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            return rect.contain(coord[0], coord[1]);\n\t        },\n\t\n\t        /**\n\t         * \n\t         * Mark displayable element dirty and refresh next frame\n\t         */\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t\n\t            this._rect = null;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * \n\t         * If displayable object binded any event\n\t         * @return {boolean}\n\t         */\n\t        // TODO,  bind \n\t        // isSilent: function () {\n\t        //     return !(\n\t        //         this.hoverable || this.draggable\n\t        //         || this.onmousemove || this.onmouseover || this.onmouseout\n\t        //         || this.onmousedown || this.onmouseup || this.onclick\n\t        //         || this.ondragenter || this.ondragover || this.ondragleave\n\t        //         || this.ondrop\n\t        //     );\n\t        // },\n\t        /**\n\t         * Alias for animate('style')\n\t         * @param {boolean} loop\n\t         */\n\t        animateStyle: function (loop) {\n\t            return this.animate('style', loop);\n\t        },\n\t\n\t        attrKV: function (key, value) {\n\t            if (key !== 'style') {\n\t                Element.prototype.attrKV.call(this, key, value);\n\t            }\n\t            else {\n\t                this.style.set(value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setStyle: function (key, value) {\n\t            this.style.set(key, value);\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Use given style object\n\t         * @param  {Object} obj\n\t         */\n\t        useStyle: function (obj) {\n\t            this.style = new Style(obj);\n\t            this.dirty(false);\n\t            return this;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Displayable, Element);\n\t\n\t    zrUtil.mixin(Displayable, RectText);\n\t    // zrUtil.mixin(Displayable, Stateful);\n\t\n\t    module.exports = Displayable;\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Mixin for drawing text in a element bounding rect\n\t * @module zrender/mixin/RectText\n\t */\n\t\n\t\n\t\n\t    var textContain = __webpack_require__(38);\n\t    var BoundingRect = __webpack_require__(24);\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var RectText = function () {};\n\t\n\t    function parsePercent(value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    }\n\t\n\t    RectText.prototype = {\n\t\n\t        constructor: RectText,\n\t\n\t        /**\n\t         * Draw text in a rect with specified position.\n\t         * @param  {CanvasRenderingContext} ctx\n\t         * @param  {Object} rect Displayable rect\n\t         * @return {Object} textRect Alternative precalculated text bounding rect\n\t         */\n\t        drawRectText: function (ctx, rect, textRect) {\n\t            var style = this.style;\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            if (!text) {\n\t                return;\n\t            }\n\t\n\t            // FIXME\n\t            ctx.save();\n\t\n\t            var x;\n\t            var y;\n\t            var textPosition = style.textPosition;\n\t            var textOffset = style.textOffset;\n\t            var distance = style.textDistance;\n\t            var align = style.textAlign;\n\t            var font = style.textFont || style.font;\n\t            var baseline = style.textBaseline;\n\t            var verticalAlign = style.textVerticalAlign;\n\t\n\t            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t\n\t            // Transform rect to view space\n\t            var transform = this.transform;\n\t            if (!style.textTransform) {\n\t                if (transform) {\n\t                    tmpRect.copy(rect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = tmpRect;\n\t                }\n\t            }\n\t            else {\n\t                this.setTransform(ctx);\n\t            }\n\t\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                // Percent\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t\n\t                if (verticalAlign) {\n\t                    switch (verticalAlign) {\n\t                        case 'middle':\n\t                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= textRect.height - textRect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += textRect.lineHeight / 2;\n\t                    }\n\t                    // Force bseline to be middle\n\t                    baseline = 'middle';\n\t                }\n\t            }\n\t            else {\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, textRect, distance\n\t                );\n\t                x = res.x;\n\t                y = res.y;\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t\n\t            if (textOffset) {\n\t                x += textOffset[0];\n\t                y += textOffset[1];\n\t            }\n\t\n\t            // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t            ctx.textAlign = align || 'left';\n\t            // Use canvas default alphabetic baseline\n\t            ctx.textBaseline = baseline || 'alphabetic';\n\t\n\t            var textFill = style.textFill;\n\t            var textStroke = style.textStroke;\n\t            textFill && (ctx.fillStyle = textFill);\n\t            textStroke && (ctx.strokeStyle = textStroke);\n\t\n\t            // TODO Invalid font\n\t            ctx.font = font || '12px sans-serif';\n\t\n\t            // Text shadow\n\t            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n\t            ctx.shadowBlur = style.textShadowBlur;\n\t            ctx.shadowColor = style.textShadowColor || 'transparent';\n\t            ctx.shadowOffsetX = style.textShadowOffsetX;\n\t            ctx.shadowOffsetY = style.textShadowOffsetY;\n\t\n\t            var textLines = text.split('\\n');\n\t\n\t            if (style.textRotation) {\n\t                transform && ctx.translate(transform[4], transform[5]);\n\t                ctx.rotate(style.textRotation);\n\t                transform && ctx.translate(-transform[4], -transform[5]);\n\t            }\n\t\n\t            for (var i = 0; i < textLines.length; i++) {\n\t                    // Fill after stroke so the outline will not cover the main part.\n\t                textStroke && ctx.strokeText(textLines[i], x, y);\n\t                textFill && ctx.fillText(textLines[i], x, y);\n\t                y += textRect.lineHeight;\n\t            }\n\t\n\t            ctx.restore();\n\t        }\n\t    };\n\t\n\t    module.exports = RectText;\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var textWidthCache = {};\n\t    var textWidthCacheCounter = 0;\n\t    var TEXT_CACHE_MAX = 5000;\n\t\n\t    var util = __webpack_require__(6);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var retrieve = util.retrieve;\n\t\n\t    function getTextWidth(text, textFont) {\n\t        var key = text + ':' + textFont;\n\t        if (textWidthCache[key]) {\n\t            return textWidthCache[key];\n\t        }\n\t\n\t        var textLines = (text + '').split('\\n');\n\t        var width = 0;\n\t\n\t        for (var i = 0, l = textLines.length; i < l; i++) {\n\t            // measureText  Canvas \n\t            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n\t        }\n\t\n\t        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t            textWidthCacheCounter = 0;\n\t            textWidthCache = {};\n\t        }\n\t        textWidthCacheCounter++;\n\t        textWidthCache[key] = width;\n\t\n\t        return width;\n\t    }\n\t\n\t    function getTextRect(text, textFont, textAlign, textBaseline) {\n\t        var textLineLen = ((text || '') + '').split('\\n').length;\n\t\n\t        var width = getTextWidth(text, textFont);\n\t        // FIXME \n\t        var lineHeight = getTextWidth('', textFont);\n\t        var height = textLineLen * lineHeight;\n\t\n\t        var rect = new BoundingRect(0, 0, width, height);\n\t        // Text has a special line height property\n\t        rect.lineHeight = lineHeight;\n\t\n\t        switch (textBaseline) {\n\t            case 'bottom':\n\t            case 'alphabetic':\n\t                rect.y -= lineHeight;\n\t                break;\n\t            case 'middle':\n\t                rect.y -= lineHeight / 2;\n\t                break;\n\t            // case 'hanging':\n\t            // case 'top':\n\t        }\n\t\n\t        // FIXME Right to left language\n\t        switch (textAlign) {\n\t            case 'end':\n\t            case 'right':\n\t                rect.x -= rect.width;\n\t                break;\n\t            case 'center':\n\t                rect.x -= rect.width / 2;\n\t                break;\n\t            // case 'start':\n\t            // case 'left':\n\t        }\n\t\n\t        return rect;\n\t    }\n\t\n\t    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\t\n\t        var x = rect.x;\n\t        var y = rect.y;\n\t\n\t        var height = rect.height;\n\t        var width = rect.width;\n\t\n\t        var textHeight = textRect.height;\n\t\n\t        var halfHeight = height / 2 - textHeight / 2;\n\t\n\t        var textAlign = 'left';\n\t\n\t        switch (textPosition) {\n\t            case 'left':\n\t                x -= distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'right':\n\t                x += distance + width;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'top':\n\t                x += width / 2;\n\t                y -= distance + textHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'bottom':\n\t                x += width / 2;\n\t                y += height + distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'inside':\n\t                x += width / 2;\n\t                y += halfHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideLeft':\n\t                x += distance;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideRight':\n\t                x += width - distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideTop':\n\t                x += width / 2;\n\t                y += distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideBottom':\n\t                x += width / 2;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideTopLeft':\n\t                x += distance;\n\t                y += distance;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideTopRight':\n\t                x += width - distance;\n\t                y += distance;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideBottomLeft':\n\t                x += distance;\n\t                y += height - textHeight - distance;\n\t                break;\n\t            case 'insideBottomRight':\n\t                x += width - distance;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'right';\n\t                break;\n\t        }\n\t\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            textAlign: textAlign,\n\t            textBaseline: 'top'\n\t        };\n\t    }\n\t\n\t    /**\n\t     * Show ellipsis if overflow.\n\t     *\n\t     * @param  {string} text\n\t     * @param  {string} containerWidth\n\t     * @param  {string} textFont\n\t     * @param  {number} [ellipsis='...']\n\t     * @param  {Object} [options]\n\t     * @param  {number} [options.maxIterations=3]\n\t     * @param  {number} [options.minChar=0] If truncate result are less\n\t     *                  then minChar, ellipsis will not show, which is\n\t     *                  better for user hint in some cases.\n\t     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t     * @return {string}\n\t     */\n\t    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n\t        if (!containerWidth) {\n\t            return '';\n\t        }\n\t\n\t        options = options || {};\n\t\n\t        ellipsis = retrieve(ellipsis, '...');\n\t        var maxIterations = retrieve(options.maxIterations, 2);\n\t        var minChar = retrieve(options.minChar, 0);\n\t        // FIXME\n\t        // Other languages?\n\t        var cnCharWidth = getTextWidth('', textFont);\n\t        // FIXME\n\t        // Consider proportional font?\n\t        var ascCharWidth = getTextWidth('a', textFont);\n\t        var placeholder = retrieve(options.placeholder, '');\n\t\n\t        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n\t        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\t        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t            contentWidth -= ascCharWidth;\n\t        }\n\t\n\t        var ellipsisWidth = getTextWidth(ellipsis);\n\t        if (ellipsisWidth > contentWidth) {\n\t            ellipsis = '';\n\t            ellipsisWidth = 0;\n\t        }\n\t\n\t        contentWidth = containerWidth - ellipsisWidth;\n\t\n\t        var textLines = (text + '').split('\\n');\n\t\n\t        for (var i = 0, len = textLines.length; i < len; i++) {\n\t            var textLine = textLines[i];\n\t            var lineWidth = getTextWidth(textLine, textFont);\n\t\n\t            if (lineWidth <= containerWidth) {\n\t                continue;\n\t            }\n\t\n\t            for (var j = 0;; j++) {\n\t                if (lineWidth <= contentWidth || j >= maxIterations) {\n\t                    textLine += ellipsis;\n\t                    break;\n\t                }\n\t\n\t                var subLength = j === 0\n\t                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n\t                    : lineWidth > 0\n\t                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n\t                    : 0;\n\t\n\t                textLine = textLine.substr(0, subLength);\n\t                lineWidth = getTextWidth(textLine, textFont);\n\t            }\n\t\n\t            if (textLine === '') {\n\t                textLine = placeholder;\n\t            }\n\t\n\t            textLines[i] = textLine;\n\t        }\n\t\n\t        return textLines.join('\\n');\n\t    }\n\t\n\t    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t        var width = 0;\n\t        var i = 0;\n\t        for (var len = text.length; i < len && width < contentWidth; i++) {\n\t            var charCode = text.charCodeAt(i);\n\t            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n\t        }\n\t        return i;\n\t    }\n\t\n\t    var textContain = {\n\t\n\t        getWidth: getTextWidth,\n\t\n\t        getBoundingRect: getTextRect,\n\t\n\t        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\t\n\t        truncateText: truncateText,\n\t\n\t        measureText: function (text, textFont) {\n\t            var ctx = util.getContext();\n\t            ctx.font = textFont || '12px sans-serif';\n\t            return ctx.measureText(text);\n\t        }\n\t    };\n\t\n\t    module.exports = textContain;\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO\r\n\t * 1.BO\r\n\t * 2.BO\r\n\t * 3.BO[]\r\n\t * 4.BO[]\r\n\t * 5.BOBO\r\n\t * 6.BO\r\n\t * 7.BOBO\r\n\t * @module fish-topo-bo/node/BoNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(40);\r\n\t    var BoName = __webpack_require__(41);\r\n\t    var EventDecision = __webpack_require__(73);\r\n\t    var Line = __webpack_require__(74);\r\n\t    var BoAttr = __webpack_require__(75);\r\n\t    var graphic = __webpack_require__(42);\r\n\t\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param {{\r\n\t     *          id: String BO,\r\n\t     *          name: String BO,\r\n\t     *          boEventArr: [] BO,\r\n\t     *          boAttrArr: [] BO\r\n\t     *          }} boData, bo\r\n\t     * @param {{\r\n\t     *          startPos: {x: number, y: number} ,\r\n\t     *          displayAttrDataType: boolean ,\r\n\t     *          displayAttrEvent: boolean ,\r\n\t     *          boClickable: boolean BO,  false\r\n\t     *          boPopupOpts: Object BOurl,width,height\r\n\t     *          boEventClickable: boolean BO,  false\r\n\t     *          boEventPopupOpts: Object BOurl,width,height\r\n\t     *          attrEventClickable: boolean BO,  false\r\n\t     *          attrEventPopupOpts: Object BOurl,width,height\r\n\t     *          isCurrent: boolean BO\r\n\t     *          viewOption: \r\n\t     *          }} opts\r\n\t     * @constructor\r\n\t     */\r\n\t    function BO(boData, opts) {\r\n\t\r\n\t        /**\r\n\t         * BO\r\n\t         * @type {Object}\r\n\t         * @private\r\n\t         */\r\n\t        this._data = boData;\r\n\t        this._data.viewOption = {};\r\n\t        fish.extend(this._data.viewOption, opts.viewOption||{});\r\n\t\r\n\t        /**\r\n\t         * BO\r\n\t         * @type {{x: number, y: number}}\r\n\t         * @private\r\n\t         */\r\n\t        this._oriStartPos = opts.startPos;\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {{x: number, y: number}}\r\n\t         * @private\r\n\t         */\r\n\t        this._nextStartPos = {\r\n\t            x: opts.startPos.x,\r\n\t            y: opts.startPos.y\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayAttrDataType = opts.displayAttrDataType || false;\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayAttrEvent = opts.displayAttrEvent || false;\r\n\t\r\n\t        //TODO\r\n\t        if (this._displayAttrEvent) {\r\n\t            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 3;\r\n\t        } else if (this._displayAttrDataType) {\r\n\t            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 1.5;\r\n\t        }\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._boClickable = opts.boClickable || false;\r\n\t        this._boPopupOpts = opts.boPopupOpts;\r\n\t        this._boEventClickable = opts.boEventClickable || false;\r\n\t        this._boEventPopupOpts = opts.boEventPopupOpts;\r\n\t        this._attrEventClickable = opts.attrEventClickable || false;\r\n\t        this._attrEventPopupOpts = opts.attrEventPopupOpts;\r\n\t\r\n\t        /**\r\n\t         * BOBO\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._isCurrent = opts.isCurrent || false;\r\n\t\r\n\t\r\n\t        /**\r\n\t         * BO\r\n\t         * @type {number}\r\n\t         * @private\r\n\t         */\r\n\t        this._boShapeHeight = 0;\r\n\t\r\n\t        /**\r\n\t         * Group\r\n\t         * @type zrender/graphic/Group\r\n\t         * @private\r\n\t         */\r\n\t        this._group = new graphic.Group();\r\n\t        this._group.name = this._data.id;\r\n\t        this._group.setCurrent = function (style) {\r\n\t            //GroupBO\r\n\t            var _boShape = this.childAt(this.childCount() - 1);\r\n\t\r\n\t            if (style) {\r\n\t                fish.extend(_boShape.style, style);\r\n\t            } else {\r\n\t                //\r\n\t                _boShape.style.fill = '#66CC99';\r\n\t            }\r\n\t\r\n\t        };\r\n\t\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t\r\n\t    var boProto = BO.prototype;\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @returns {zrender/graphic/Group}\r\n\t     */\r\n\t    boProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @returns {Object}\r\n\t     */\r\n\t    boProto.getData = function () {\r\n\t        return this._data;\r\n\t    };\r\n\t\r\n\t    boProto.getLayout = function () {\r\n\t        return this._data.layout;\r\n\t    };\r\n\t\r\n\t\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     */\r\n\t    boProto.setCurrent = function () {\r\n\t        //BO\r\n\t        this.childAt(this.childCount - 1).style.fill = '#66CC99'\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @private\r\n\t     */\r\n\t    boProto._render = function () {\r\n\t        //BO\r\n\t        this._createBoName();\r\n\t\r\n\t        //BO\r\n\t        this._createEventDecision();\r\n\t\r\n\t        //BO\r\n\t        this._createBoAttr();\r\n\t\r\n\t        //BO\r\n\t        this._createBoShape();\r\n\t\r\n\t        //TODO\r\n\t        Const.BO_NODE_WIDTH = 180;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createBoName = function () {\r\n\t        var _boNameShape = BoName(this._data.name, this._nextStartPos);\r\n\t\r\n\t        if (this._boClickable) {\r\n\t            _boNameShape.clickable = this._boClickable;\r\n\t            _boNameShape._data = this._data;\r\n\t            _boNameShape._boPopupOpts = this._boPopupOpts;\r\n\t            _boNameShape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t        this._group.add(_boNameShape);\r\n\t        this._calNextShapeStartPos(_boNameShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createEventDecision = function () {\r\n\t\r\n\t        //BO\r\n\t        if (!this._data.boEventArr) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var _boEventArr = this._data.boEventArr,\r\n\t            _boEventLen = _boEventArr.length,\r\n\t            _eventShape,\r\n\t            _eventOpts = {\r\n\t                startPos: this._nextStartPos,\r\n\t                clickable: this._boEventClickable,\r\n\t                popupOpts: this._boEventPopupOpts\r\n\t            };\r\n\t\r\n\t        for (var i = 0; i < _boEventLen; i++) {\r\n\t            _eventShape = new EventDecision(_boEventArr[i], _eventOpts);\r\n\t            this._group.add(_eventShape.getShape());\r\n\t            this._calNextShapeStartPos(_eventShape.getShape());\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createBoAttr = function () {\r\n\t        //BO\r\n\t        if (!this._data.boAttrArr) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var _boAttrArr = this._data.boAttrArr,\r\n\t            _boAttrLen = _boAttrArr.length,\r\n\t            _boAttrShape, _lineShape,\r\n\t            _attrEventStartPos = {x: this._nextStartPos.x + Const.BO_NODE_WIDTH / 2, y: this._nextStartPos.y};\r\n\t\r\n\t        for (var i = 0; i < _boAttrLen; i++) {\r\n\t            if (i == 0) {\r\n\t                _lineShape = Line.BoLine(this._nextStartPos); //\r\n\t            }\r\n\t            else {\r\n\t                _lineShape = Line.AttrLine(this._nextStartPos);//\r\n\t            }\r\n\t\r\n\t            this._group.add(_lineShape);\r\n\t\r\n\t            this._calNextShapeStartPos(_lineShape);\r\n\t\r\n\t            _boAttrShape = new BoAttr(_boAttrArr[i],\r\n\t                {\r\n\t                    startPos: this._nextStartPos,\r\n\t                    displayDataType: this._displayAttrDataType,\r\n\t                    displayEventDecision: this._displayAttrEvent,\r\n\t                    eventClickable: this._attrEventClickable,\r\n\t                    eventPopupOpts: this._attrEventPopupOpts\r\n\t                }\r\n\t            );\r\n\t            this._group.add(_boAttrShape.getShape());\r\n\t            this._calNextShapeStartPos(_boAttrShape.getShape())\r\n\t        }\r\n\t\r\n\t        if (this._displayAttrEvent) {\r\n\t            _lineShape = Line.AttrEventLine(_attrEventStartPos,\r\n\t                this._nextStartPos.y - _attrEventStartPos.y\r\n\t            );\r\n\t            this._group.add(_lineShape);\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @param curShape \r\n\t     * @private\r\n\t     */\r\n\t    boProto._calNextShapeStartPos = function (curShape) {\r\n\t        //\r\n\t        this._nextStartPos.y += curShape.getBoundingRect().height;\r\n\t\r\n\t        //BO\r\n\t        this._boShapeHeight += curShape.getBoundingRect().height;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createBoShape = function () {\r\n\t        var height = this._boShapeHeight > Const.BO_NODE_DEFAULT_HEIGHT ?\r\n\t                this._boShapeHeight : Const.BO_NODE_DEFAULT_HEIGHT,\r\n\t            shape = new graphic.Rect({\r\n\t                position: [this._oriStartPos.x, this._oriStartPos.y],\r\n\t\r\n\t                shape: {\r\n\t                    r: 5,\r\n\t                    width: Const.BO_NODE_WIDTH,\r\n\t                    height: height\r\n\t                },\r\n\t\r\n\t                style: {\r\n\t                    brushType: 'both',\r\n\t                    fill: this._isCurrent ? '#66CC99' : 'white',\r\n\t                    stroke: '#000000',\r\n\t                    lineWidth: 1,\r\n\t                    lineCape: 'round'\r\n\t                },\r\n\t\r\n\t                zlevel: -1\r\n\t            });\r\n\t\r\n\t        if (this._boClickable) {\r\n\t            shape._data = this._data;\r\n\t            shape._boPopupOpts = this._boPopupOpts;\r\n\t\r\n\t            shape.clickable = this._boClickable;\r\n\t            shape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t        this._group.add(shape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    boProto._click = function () {\r\n\t        var options = fish.extend(\r\n\t            {\r\n\t                viewOption: {\r\n\t                    DATA: this._data\r\n\t                },\r\n\t                width: 800,\r\n\t                height: 500\r\n\t            }, this._boPopupOpts);\r\n\t\r\n\t        fish.popupView(options);\r\n\t    };\r\n\t\r\n\t    module.exports = BO;\r\n\t\r\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    module.exports = {\r\n\t        BO_NODE_WIDTH: 180,    //BO\r\n\t        BO_NODE_DEFAULT_HEIGHT: 60,\t//BOBO\r\n\t        BO_NODE_OFFSET_X: 90, //BO=\r\n\t        BO_NODE_OFFSET_Y: 50, //BO\r\n\t\r\n\t        BO_NAME_FONT: 'bold 18px Arial', //'normal 16px verdana',    //BO,\r\n\t        BO_NAME_PADDING_TOP: 10,   //BO\r\n\t        BO_NAME_PADDING_BOTTOM: 15,   //BO\r\n\t\r\n\t        BO_EVENT_HEIGHT: 20,   //BO\r\n\t        BO_EVENT_WIDTH: 140,   //BO\r\n\t        BO_EVENT_FONT: 'normal 14px Arial',  //BO\r\n\t\r\n\t        BO_ATTR_FONT: 'normal 14px Arial',   //BO\r\n\t        BO_ATTR_PADDING_TOP: 5,   //BO\r\n\t        BO_ATTR_PADDING_BOTTOM: 5,   //BO\r\n\t        BO_ATTR_PADDING_LEFT: 5,   //BO\r\n\t        BO_ATTR_DATA_TYPE_PADDING_RIGHT: 5, //BO\r\n\t        BO_ATTR_EVENT_WIDTH: 135,   //BO\r\n\t\r\n\t        LINE_DASH: 10,  //\r\n\t        RELATION_OFFSET: 40,   //\r\n\t        RELATION_ARROW_WIDTH: 10,  //\r\n\t        RELATION_ARROW_HEIGHT: 5,  //\r\n\t        RELATION_TEXT_OFFSET_X: 10, //\r\n\t        RELATION_TEXT_OFFSET_Y: 5 //\r\n\t    };\r\n\t\r\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO\r\n\t * @module fish-topo-bo/node/BoName\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(40);\r\n\t    var graphic = __webpack_require__(42);\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param {String} text, BO\r\n\t     * @param {{x: number, y: number}} startPos, \r\n\t     * @returns {zrender/graphic/Text}\r\n\t     * @constructor\r\n\t     */\r\n\t    function BoName(text, startPos) {\r\n\t        var x = startPos.x,\r\n\t            y = startPos.y + Const.BO_NAME_PADDING_TOP, // padding-top=10\r\n\t\r\n\t            shape = new graphic.Text({\r\n\t                style: {\r\n\t                    text: text,\r\n\t                    textFont: Const.BO_NAME_FONT,\r\n\t                    textAlign: 'left',  //\r\n\t                    textBaseline: 'top'\r\n\t                },\r\n\t\r\n\t                position: [x, y]\r\n\t            });\r\n\t\r\n\t        // =  + (BO - )/2\r\n\t        shape.position[0] += (Const.BO_NODE_WIDTH - shape.getBoundingRect().width) / 2;\r\n\t\r\n\t        //BO =  + padding-top + padding-bottom\r\n\t        shape.getBoundingRect().height += Const.BO_NAME_PADDING_TOP + Const.BO_NAME_PADDING_BOTTOM;\r\n\t\r\n\t        return shape;\r\n\t    }\r\n\t\r\n\t    module.exports = BoName;\r\n\t\r\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(6);\r\n\t\r\n\t    var pathTool = __webpack_require__(43);\r\n\t    var round = Math.round;\r\n\t    var Path = __webpack_require__(44);\r\n\t    var colorTool = __webpack_require__(20);\r\n\t    var matrix = __webpack_require__(14);\r\n\t    var vector = __webpack_require__(15);\r\n\t    var Gradient = __webpack_require__(56);\r\n\t    var Draggable = __webpack_require__(8);\r\n\t\r\n\t    var graphic = {};\r\n\t    graphic.Util = zrUtil;\r\n\t    graphic.Group = __webpack_require__(11);\r\n\t\r\n\t    graphic.Image = __webpack_require__(35);\r\n\t\r\n\t    graphic.Text = __webpack_require__(57);\r\n\t\r\n\t    graphic.textContain = __webpack_require__(38);\r\n\t\r\n\t    graphic.Circle = __webpack_require__(58);\r\n\t\r\n\t    graphic.Sector = __webpack_require__(59);\r\n\t\r\n\t    graphic.Ring = __webpack_require__(60);\r\n\t\r\n\t    graphic.Polygon = __webpack_require__(61);\r\n\t\r\n\t    graphic.Polyline = __webpack_require__(65);\r\n\t\r\n\t    graphic.Rect = __webpack_require__(66);\r\n\t\r\n\t    graphic.Line = __webpack_require__(68);\r\n\t\r\n\t    graphic.BezierCurve = __webpack_require__(69);\r\n\t\r\n\t    graphic.Arc = __webpack_require__(70);\r\n\t\r\n\t    graphic.LinearGradient = __webpack_require__(71);\r\n\t\r\n\t    graphic.RadialGradient = __webpack_require__(72);\r\n\t\r\n\t    graphic.BoundingRect = __webpack_require__(24);\r\n\t\r\n\t    /**\r\n\t     * Extend shape with parameters\r\n\t     */\r\n\t    graphic.extendShape = function (opts) {\r\n\t        return Path.extend(opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Extend path\r\n\t     */\r\n\t    graphic.extendPath = function (pathData, opts) {\r\n\t        return pathTool.extendFromString(pathData, opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Create a path element from path data string\r\n\t     * @param {string} pathData\r\n\t     * @param {Object} opts\r\n\t     * @param {module:zrender/core/BoundingRect} rect\r\n\t     * @param {string} [layout=cover] 'center' or 'cover'\r\n\t     */\r\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\r\n\t        var path = pathTool.createFromString(pathData, opts);\r\n\t        Draggable.call(path);\r\n\t        var boundingRect = path.getBoundingRect();\r\n\t        if (rect) {\r\n\t            var aspect = boundingRect.width / boundingRect.height;\r\n\t\r\n\t            if (layout === 'center') {\r\n\t                // Set rect to center, keep width / height ratio.\r\n\t                var width = rect.height * aspect;\r\n\t                var height;\r\n\t                if (width <= rect.width) {\r\n\t                    height = rect.height;\r\n\t                }\r\n\t                else {\r\n\t                    width = rect.width;\r\n\t                    height = width / aspect;\r\n\t                }\r\n\t                var cx = rect.x + rect.width / 2;\r\n\t                var cy = rect.y + rect.height / 2;\r\n\t\r\n\t                rect.x = cx - width / 2;\r\n\t                rect.y = cy - height / 2;\r\n\t                rect.width = width;\r\n\t                rect.height = height;\r\n\t            }\r\n\t\r\n\t            this.resizePath(path, rect);\r\n\t        }\r\n\t\r\n\t        zrUtil.inherits(path, Draggable);\r\n\t        return path;\r\n\t    };\r\n\t\r\n\t    graphic.mergePath = pathTool.mergePath;\r\n\t\r\n\t    /**\r\n\t     * Resize a path to fit the rect\r\n\t     * @param {module:zrender/graphic/Path} path\r\n\t     * @param {Object} rect\r\n\t     */\r\n\t    graphic.resizePath = function (path, rect) {\r\n\t        if (!path.applyTransform) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var pathRect = path.getBoundingRect();\r\n\t\r\n\t        var m = pathRect.calculateTransform(rect);\r\n\t\r\n\t        path.applyTransform(m);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize line for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x1]\r\n\t     * @param {number} [param.shape.y1]\r\n\t     * @param {number} [param.shape.x2]\r\n\t     * @param {number} [param.shape.y2]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeLine = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t\r\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n\t        }\r\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n\t        }\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize rect for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x]\r\n\t     * @param {number} [param.shape.y]\r\n\t     * @param {number} [param.shape.width]\r\n\t     * @param {number} [param.shape.height]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeRect = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t        var originX = shape.x;\r\n\t        var originY = shape.y;\r\n\t        var originWidth = shape.width;\r\n\t        var originHeight = shape.height;\r\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n\t        shape.width = Math.max(\r\n\t            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n\t            originWidth === 0 ? 0 : 1\r\n\t        );\r\n\t        shape.height = Math.max(\r\n\t            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n\t            originHeight === 0 ? 0 : 1\r\n\t        );\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize for canvas\r\n\t     *\r\n\t     * @param {number} position Coordinate, such as x, y\r\n\t     * @param {number} lineWidth Should be nonnegative integer.\r\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\r\n\t     * @return {number} Optimized position.\r\n\t     */\r\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\r\n\t        // otherwise line will be fuzzy in canvas.\r\n\t        var doubledPosition = round(position * 2);\r\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n\t            ? doubledPosition / 2\r\n\t            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    function doSingleEnterHover(el) {\r\n\t        if (el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t        if (el.__hoverStlDirty) {\r\n\t            var stroke = el.style.stroke;\r\n\t            var fill = el.style.fill;\r\n\t\r\n\t            // Create hoverStyle on mouseover\r\n\t            var hoverStyle = el.__hoverStl;\r\n\t            var lift = colorTool.lift;\r\n\t            hoverStyle.fill = hoverStyle.fill\r\n\t                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n\t            hoverStyle.stroke = hoverStyle.stroke\r\n\t                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\t\r\n\t            var normalStyle = {};\r\n\t            for (var name in hoverStyle) {\r\n\t                if (hoverStyle.hasOwnProperty(name)) {\r\n\t                    normalStyle[name] = el.style[name];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            el.__normalStl = normalStyle;\r\n\t\r\n\t            el.__hoverStlDirty = false;\r\n\t        }\r\n\t        el.setStyle(el.__hoverStl);\r\n\t        el.z2 += 1;\r\n\t\r\n\t        el.__isHover = true;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doSingleLeaveHover(el) {\r\n\t        if (!el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var normalStl = el.__normalStl;\r\n\t        normalStl && el.setStyle(normalStl);\r\n\t        el.z2 -= 1;\r\n\t\r\n\t        el.__isHover = false;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doEnterHover(el) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleEnterHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleEnterHover(el);\r\n\t    }\r\n\t    graphic.doEnterHover = doEnterHover;\r\n\t    function doLeaveHover(el) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleLeaveHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleLeaveHover(el);\r\n\t    }\r\n\t    graphic.doLeaveHover = doLeaveHover;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function setElementHoverStl(el, hoverStl) {\r\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n\t        // Often used when item group has a label element and it's hoverStyle is different\r\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n\t        el.__hoverStlDirty = true;\r\n\t    }\r\n\t    graphic.setElementHoverStl = setElementHoverStl;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOver() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOut() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function enterEmphasis() {\r\n\t        this.__isEmphasis = true;\r\n\t        doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function leaveEmphasis() {\r\n\t        this.__isEmphasis = false;\r\n\t        doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Set hover style of element\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} [hoverStyle]\r\n\t     */\r\n\t    graphic.setHoverStyle = function (el, hoverStyle) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    setElementHoverStl(child, hoverStyle);\r\n\t                }\r\n\t            })\r\n\t            : setElementHoverStl(el, hoverStyle);\r\n\t        // Remove previous bound handlers\r\n\t        el.on('mouseover', onElementMouseOver)\r\n\t          .on('mouseout', onElementMouseOut);\r\n\t\r\n\t        // Emphasis, normal can be triggered manually\r\n\t        el.on('emphasis', enterEmphasis)\r\n\t          .on('normal', leaveEmphasis);\r\n\t    };\r\n\t\r\n\t    graphic.setNormalStyle = function(el, options) {\r\n\t        if (el.__normalStl) {\r\n\t            for (var name in options) {\r\n\t                if (el.__normalStl.hasOwnProperty(name)) {\r\n\t                    el.__normalStl[name] = options[name];\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Set text option in the style\r\n\t     * @param {Object} textStyle\r\n\t     * @param {module:echarts/model/Model} labelModel\r\n\t     * @param {string} color\r\n\t     */\r\n\t    graphic.setText = function (textStyle, labelModel, color) {\r\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n\t        var textStyleModel = labelModel.getModel('textStyle');\r\n\t        zrUtil.extend(textStyle, {\r\n\t            textDistance: labelModel.getShallow('distance') || 5,\r\n\t            textFont: textStyleModel.getFont(),\r\n\t            textPosition: labelPosition,\r\n\t            textFill: textStyleModel.getTextColor() || labelColor\r\n\t        });\r\n\t    };\r\n\t\r\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n\t        var postfix = isUpdate ? 'Update' : '';\r\n\t        var duration = animatableModel\r\n\t            && animatableModel.getShallow('animationDuration' + postfix);\r\n\t        var animationEasing = animatableModel\r\n\t            && animatableModel.getShallow('animationEasing' + postfix);\r\n\t\r\n\t        animatableModel && animatableModel.getShallow('animation')\r\n\t            ? el.animateTo(props, duration, animationEasing, cb)\r\n\t            : (el.attr(props), cb && cb());\r\n\t    }\r\n\t    /**\r\n\t     * Update graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\t\r\n\t    /**\r\n\t     * Init graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\t\r\n\t    /**\r\n\t     * Get transform matrix of target (param target),\r\n\t     * in coordinate of its ancestor (param ancestor)\r\n\t     *\r\n\t     * @param {module:zrender/mixin/Transformable} target\r\n\t     * @param {module:zrender/mixin/Transformable} ancestor\r\n\t     */\r\n\t    graphic.getTransform = function (target, ancestor) {\r\n\t        var mat = matrix.identity([]);\r\n\t\r\n\t        while (target && target !== ancestor) {\r\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\r\n\t            target = target.parent;\r\n\t        }\r\n\t\r\n\t        return mat;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Apply transform to an vertex.\r\n\t     * @param {Array.<number>} vertex [x, y]\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {Array.<number>} [x, y]\r\n\t     */\r\n\t    graphic.applyTransform = function (vertex, transform, invert) {\r\n\t        if (invert) {\r\n\t            transform = matrix.invert([], transform);\r\n\t        }\r\n\t        return vector.applyTransform([], vertex, transform);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n\t     */\r\n\t    graphic.transformDirection = function (direction, transform, invert) {\r\n\t\r\n\t        // Pick a base, ensure that transform result will not be (0, 0).\r\n\t        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n\t        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\t\r\n\t        var vertex = [\r\n\t            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n\t            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n\t        ];\r\n\t\r\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\t\r\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n\t            ? (vertex[0] > 0 ? 'right' : 'left')\r\n\t            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n\t    };\r\n\t\r\n\t    module.exports = graphic;\r\n\t\r\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Path = __webpack_require__(44);\n\t    var PathProxy = __webpack_require__(45);\n\t    var transformPath = __webpack_require__(55);\n\t    var matrix = __webpack_require__(14);\n\t\n\t    // command chars\n\t    var cc = [\n\t        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n\t        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n\t    ];\n\t\n\t    var mathSqrt = Math.sqrt;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var PI = Math.PI;\n\t\n\t    var vMag = function(v) {\n\t        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t    };\n\t    var vRatio = function(u, v) {\n\t        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t    };\n\t    var vAngle = function(u, v) {\n\t        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n\t                * Math.acos(vRatio(u, v));\n\t    };\n\t\n\t    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t        var psi = psiDeg * (PI / 180.0);\n\t        var xp = mathCos(psi) * (x1 - x2) / 2.0\n\t                 + mathSin(psi) * (y1 - y2) / 2.0;\n\t        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n\t                 + mathCos(psi) * (y1 - y2) / 2.0;\n\t\n\t        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\t\n\t        if (lambda > 1) {\n\t            rx *= mathSqrt(lambda);\n\t            ry *= mathSqrt(lambda);\n\t        }\n\t\n\t        var f = (fa === fs ? -1 : 1)\n\t            * mathSqrt((((rx * rx) * (ry * ry))\n\t                    - ((rx * rx) * (yp * yp))\n\t                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n\t                    + (ry * ry) * (xp * xp))\n\t                ) || 0;\n\t\n\t        var cxp = f * rx * yp / ry;\n\t        var cyp = f * -ry * xp / rx;\n\t\n\t        var cx = (x1 + x2) / 2.0\n\t                 + mathCos(psi) * cxp\n\t                 - mathSin(psi) * cyp;\n\t        var cy = (y1 + y2) / 2.0\n\t                + mathSin(psi) * cxp\n\t                + mathCos(psi) * cyp;\n\t\n\t        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n\t        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n\t        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n\t        var dTheta = vAngle(u, v);\n\t\n\t        if (vRatio(u, v) <= -1) {\n\t            dTheta = PI;\n\t        }\n\t        if (vRatio(u, v) >= 1) {\n\t            dTheta = 0;\n\t        }\n\t        if (fs === 0 && dTheta > 0) {\n\t            dTheta = dTheta - 2 * PI;\n\t        }\n\t        if (fs === 1 && dTheta < 0) {\n\t            dTheta = dTheta + 2 * PI;\n\t        }\n\t\n\t        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t    }\n\t\n\t    function createPathProxyFromString(data) {\n\t        if (!data) {\n\t            return [];\n\t        }\n\t\n\t        // command string\n\t        var cs = data.replace(/-/g, ' -')\n\t            .replace(/  /g, ' ')\n\t            .replace(/ /g, ',')\n\t            .replace(/,,/g, ',');\n\t\n\t        var n;\n\t        // create pipes so that we can split the data\n\t        for (n = 0; n < cc.length; n++) {\n\t            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t        }\n\t\n\t        // create array\n\t        var arr = cs.split('|');\n\t        // init context point\n\t        var cpx = 0;\n\t        var cpy = 0;\n\t\n\t        var path = new PathProxy();\n\t        var CMD = PathProxy.CMD;\n\t\n\t        var prevCmd;\n\t        for (n = 1; n < arr.length; n++) {\n\t            var str = arr[n];\n\t            var c = str.charAt(0);\n\t            var off = 0;\n\t            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t            var cmd;\n\t\n\t            if (p.length > 0 && p[0] === '') {\n\t                p.shift();\n\t            }\n\t\n\t            for (var i = 0; i < p.length; i++) {\n\t                p[i] = parseFloat(p[i]);\n\t            }\n\t            while (off < p.length && !isNaN(p[off])) {\n\t                if (isNaN(p[0])) {\n\t                    break;\n\t                }\n\t                var ctlPtx;\n\t                var ctlPty;\n\t\n\t                var rx;\n\t                var ry;\n\t                var psi;\n\t                var fa;\n\t                var fs;\n\t\n\t                var x1 = cpx;\n\t                var y1 = cpy;\n\t\n\t                // convert l, H, h, V, and v to L\n\t                switch (c) {\n\t                    case 'l':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'L':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'm':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'l';\n\t                        break;\n\t                    case 'M':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'L';\n\t                        break;\n\t                    case 'h':\n\t                        cpx += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'H':\n\t                        cpx = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'v':\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'V':\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'C':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n\t                        );\n\t                        cpx = p[off - 2];\n\t                        cpy = p[off - 1];\n\t                        break;\n\t                    case 'c':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy\n\t                        );\n\t                        cpx += p[off - 2];\n\t                        cpy += p[off - 1];\n\t                        break;\n\t                    case 'S':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 's':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = cpx + p[off++];\n\t                        y1 = cpy + p[off++];\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'Q':\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'q':\n\t                        x1 = p[off++] + cpx;\n\t                        y1 = p[off++] + cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'T':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 't':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 'A':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                    case 'a':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                }\n\t            }\n\t\n\t            if (c === 'z' || c === 'Z') {\n\t                cmd = CMD.Z;\n\t                path.addData(cmd);\n\t            }\n\t\n\t            prevCmd = cmd;\n\t        }\n\t\n\t        path.toStatic();\n\t\n\t        return path;\n\t    }\n\t\n\t    // TODO Optimize double memory cost problem\n\t    function createPathOptions(str, opts) {\n\t        var pathProxy = createPathProxyFromString(str);\n\t        var transform;\n\t        opts = opts || {};\n\t        opts.buildPath = function (path) {\n\t            path.setData(pathProxy.data);\n\t            transform && transformPath(path, transform);\n\t            // Svg and vml renderer don't have context\n\t            var ctx = path.getContext();\n\t            if (ctx) {\n\t                path.rebuildPath(ctx);\n\t            }\n\t        };\n\t\n\t        opts.applyTransform = function (m) {\n\t            if (!transform) {\n\t                transform = matrix.create();\n\t            }\n\t            matrix.mul(transform, m, transform);\n\t            this.dirty(true);\n\t        };\n\t\n\t        return opts;\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Create a Path object from path string data\n\t         * http://www.w3.org/TR/SVG/paths.html#PathData\n\t         * @param  {Object} opts Other options\n\t         */\n\t        createFromString: function (str, opts) {\n\t            return new Path(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Create a Path class from path string data\n\t         * @param  {string} str\n\t         * @param  {Object} opts Other options\n\t         */\n\t        extendFromString: function (str, opts) {\n\t            return Path.extend(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Merge multiple paths\n\t         */\n\t        // TODO Apply transform\n\t        // TODO stroke dash\n\t        // TODO Optimize double memory cost problem\n\t        mergePath: function (pathEls, opts) {\n\t            var pathList = [];\n\t            var len = pathEls.length;\n\t            for (var i = 0; i < len; i++) {\n\t                var pathEl = pathEls[i];\n\t                if (pathEl.__dirty) {\n\t                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t                }\n\t                pathList.push(pathEl.path);\n\t            }\n\t\n\t            var pathBundle = new Path(opts);\n\t            pathBundle.buildPath = function (path) {\n\t                path.appendPath(pathList);\n\t                // Svg and vml renderer don't have context\n\t                var ctx = path.getContext();\n\t                if (ctx) {\n\t                    path.rebuildPath(ctx);\n\t                }\n\t            };\n\t\n\t            return pathBundle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Path element\n\t * @module zrender/graphic/Path\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(36);\n\t    var zrUtil = __webpack_require__(6);\n\t    var PathProxy = __webpack_require__(45);\n\t    var pathContain = __webpack_require__(48);\n\t\n\t    var Pattern = __webpack_require__(34);\n\t    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\t\n\t    var abs = Math.abs;\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Path\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function Path(opts) {\n\t        Displayable.call(this, opts);\n\t\n\t        /**\n\t         * @type {module:zrender/core/PathProxy}\n\t         * @readOnly\n\t         */\n\t        this.path = new PathProxy();\n\t    }\n\t\n\t    Path.prototype = {\n\t\n\t        constructor: Path,\n\t\n\t        type: 'path',\n\t\n\t        __dirtyPath: true,\n\t\n\t        strokeContainThreshold: 5,\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var path = this.path;\n\t            var hasStroke = style.hasStroke();\n\t            var hasFill = style.hasFill();\n\t            var fill = style.fill;\n\t            var stroke = style.stroke;\n\t            var hasFillGradient = hasFill && !!(fill.colorStops);\n\t            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n\t            var hasFillPattern = hasFill && !!(fill.image);\n\t            var hasStrokePattern = hasStroke && !!(stroke.image);\n\t\n\t            style.bind(ctx, this, prevEl);\n\t            this.setTransform(ctx);\n\t\n\t            if (this.__dirty) {\n\t                var rect = this.getBoundingRect();\n\t                // Update gradient because bounding rect may changed\n\t                if (hasFillGradient) {\n\t                    this._fillGradient = style.getGradient(ctx, fill, rect);\n\t                }\n\t                if (hasStrokeGradient) {\n\t                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t                }\n\t            }\n\t            // Use the gradient or pattern\n\t            if (hasFillGradient) {\n\t                // PENDING If may have affect the state\n\t                ctx.fillStyle = this._fillGradient;\n\t            }\n\t            else if (hasFillPattern) {\n\t                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t            }\n\t            if (hasStrokeGradient) {\n\t                ctx.strokeStyle = this._strokeGradient;\n\t            }\n\t            else if (hasStrokePattern) {\n\t                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t            }\n\t\n\t            var lineDash = style.lineDash;\n\t            var lineDashOffset = style.lineDashOffset;\n\t\n\t            var ctxLineDash = !!ctx.setLineDash;\n\t\n\t            // Update path sx, sy\n\t            var scale = this.getGlobalScale();\n\t            path.setScale(scale[0], scale[1]);\n\t\n\t            // Proxy context\n\t            // Rebuild path in following 2 cases\n\t            // 1. Path is dirty\n\t            // 2. Path needs javascript implemented lineDash stroking.\n\t            //    In this case, lineDash information will not be saved in PathProxy\n\t            if (this.__dirtyPath || (\n\t                lineDash && !ctxLineDash && hasStroke\n\t            )) {\n\t                path = this.path.beginPath(ctx);\n\t\n\t                // Setting line dash before build path\n\t                if (lineDash && !ctxLineDash) {\n\t                    path.setLineDash(lineDash);\n\t                    path.setLineDashOffset(lineDashOffset);\n\t                }\n\t\n\t                this.buildPath(path, this.shape, false);\n\t\n\t                // Clear path dirty flag\n\t                this.__dirtyPath = false;\n\t            }\n\t            else {\n\t                // Replay path building\n\t                ctx.beginPath();\n\t                this.path.rebuildPath(ctx);\n\t            }\n\t\n\t            hasFill && path.fill(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                ctx.setLineDash(lineDash);\n\t                ctx.lineDashOffset = lineDashOffset;\n\t            }\n\t\n\t            hasStroke && path.stroke(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                // PENDING\n\t                // Remove lineDash\n\t                ctx.setLineDash([]);\n\t            }\n\t\n\t\n\t            this.restoreTransform(ctx);\n\t\n\t            // Draw rect text\n\t            if (style.text != null) {\n\t                // var rect = this.getBoundingRect();\n\t                this.drawRectText(ctx, this.getBoundingRect());\n\t            }\n\t        },\n\t\n\t        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n\t        // Like in circle\n\t        buildPath: function (ctx, shapeCfg, inBundle) {},\n\t\n\t        getBoundingRect: function () {\n\t            var rect = this._rect;\n\t            var style = this.style;\n\t            var needsUpdateRect = !rect;\n\t            if (needsUpdateRect) {\n\t                var path = this.path;\n\t                if (this.__dirtyPath) {\n\t                    path.beginPath();\n\t                    this.buildPath(path, this.shape, false);\n\t                }\n\t                rect = path.getBoundingRect();\n\t            }\n\t            this._rect = rect;\n\t\n\t            if (style.hasStroke()) {\n\t                // Needs update rect with stroke lineWidth when\n\t                // 1. Element changes scale or lineWidth\n\t                // 2. Shape is changed\n\t                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t                if (this.__dirty || needsUpdateRect) {\n\t                    rectWithStroke.copy(rect);\n\t                    // FIXME Must after updateTransform\n\t                    var w = style.lineWidth;\n\t                    // PENDING, Min line width is needed when line is horizontal or vertical\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t\n\t                    // Only add extra hover lineWidth when there are no fill\n\t                    if (!style.hasFill()) {\n\t                        w = Math.max(w, this.strokeContainThreshold || 4);\n\t                    }\n\t                    // Consider line width\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        rectWithStroke.width += w / lineScale;\n\t                        rectWithStroke.height += w / lineScale;\n\t                        rectWithStroke.x -= w / lineScale / 2;\n\t                        rectWithStroke.y -= w / lineScale / 2;\n\t                    }\n\t                }\n\t\n\t                // Return rect with stroke\n\t                return rectWithStroke;\n\t            }\n\t\n\t            return rect;\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var localPos = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            var style = this.style;\n\t            x = localPos[0];\n\t            y = localPos[1];\n\t\n\t            if (rect.contain(x, y)) {\n\t                var pathData = this.path.data;\n\t                if (style.hasStroke()) {\n\t                    var lineWidth = style.lineWidth;\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        // Only add extra hover lineWidth when there are no fill\n\t                        if (!style.hasFill()) {\n\t                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t                        }\n\t                        if (pathContain.containStroke(\n\t                            pathData, lineWidth / lineScale, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t                if (style.hasFill()) {\n\t                    return pathContain.contain(pathData, x, y);\n\t                }\n\t            }\n\t            return false;\n\t        },\n\t\n\t        /**\n\t         * @param  {boolean} dirtyPath\n\t         */\n\t        dirty: function (dirtyPath) {\n\t            if (dirtyPath == null) {\n\t                dirtyPath = true;\n\t            }\n\t            // Only mark dirty, not mark clean\n\t            if (dirtyPath) {\n\t                this.__dirtyPath = dirtyPath;\n\t                this._rect = null;\n\t            }\n\t\n\t            this.__dirty = true;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t\n\t            // Used as a clipping path\n\t            if (this.__clipTarget) {\n\t                this.__clipTarget.dirty();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Alias for animate('shape')\n\t         * @param {boolean} loop\n\t         */\n\t        animateShape: function (loop) {\n\t            return this.animate('shape', loop);\n\t        },\n\t\n\t        // Overwrite attrKV\n\t        attrKV: function (key, value) {\n\t            // FIXME\n\t            if (key === 'shape') {\n\t                this.setShape(value);\n\t                this.__dirtyPath = true;\n\t                this._rect = null;\n\t            }\n\t            else {\n\t                Displayable.prototype.attrKV.call(this, key, value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setShape: function (key, value) {\n\t            var shape = this.shape;\n\t            // Path from string may not have shape\n\t            if (shape) {\n\t                if (zrUtil.isObject(key)) {\n\t                    for (var name in key) {\n\t                        if (key.hasOwnProperty(name)) {\n\t                            shape[name] = key[name];\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    shape[key] = value;\n\t                }\n\t                this.dirty(true);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        getLineScale: function () {\n\t            var m = this.transform;\n\t            // Get the line scale.\n\t            // Determinant of `m` means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n\t                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n\t                : 1;\n\t        }\n\t    };\n\t\n\t    /**\n\t     *  Path element, \n\t     * Extend a path element\n\t     * @param {Object} props\n\t     * @param {string} props.type Path type\n\t     * @param {Function} props.init Initialize\n\t     * @param {Function} props.buildPath Overwrite buildPath method\n\t     * @param {Object} [props.style] Extended default style config\n\t     * @param {Object} [props.shape] Extended default shape config\n\t     */\n\t    Path.extend = function (defaults) {\n\t        var Sub = function (opts) {\n\t            Path.call(this, opts);\n\t\n\t            if (defaults.style) {\n\t                // Extend default style\n\t                this.style.extendFrom(defaults.style, false);\n\t            }\n\t\n\t            // Extend default shape\n\t            var defaultShape = defaults.shape;\n\t            if (defaultShape) {\n\t                this.shape = this.shape || {};\n\t                var thisShape = this.shape;\n\t                for (var name in defaultShape) {\n\t                    if (\n\t                        ! thisShape.hasOwnProperty(name)\n\t                        && defaultShape.hasOwnProperty(name)\n\t                    ) {\n\t                        thisShape[name] = defaultShape[name];\n\t                    }\n\t                }\n\t            }\n\t\n\t            defaults.init && defaults.init.call(this, opts);\n\t        };\n\t\n\t        zrUtil.inherits(Sub, Path);\n\t\n\t        // FIXME  extend position, rotation \n\t        for (var name in defaults) {\n\t            // Extending prototype values and methods\n\t            if (name !== 'style' && name !== 'shape') {\n\t                Sub.prototype[name] = defaults[name];\n\t            }\n\t        }\n\t\n\t        return Sub;\n\t    };\n\t\n\t    zrUtil.inherits(Path, Displayable);\n\t\n\t    module.exports = Path;\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Path `buildPath``ctx`, pathpathCommands\n\t *  isInsidePath boundingRect\n\t *\n\t * @module zrender/core/PathProxy\n\t * @author Yi Shen (http://www.github.com/pissang)\n\t */\n\t\n\t // TODO getTotalLength, getPointAtLength\n\t\n\t\n\t    var curve = __webpack_require__(46);\n\t    var vec2 = __webpack_require__(15);\n\t    var bbox = __webpack_require__(47);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var dpr = __webpack_require__(23).devicePixelRatio;\n\t\n\t    var CMD = {\n\t        M: 1,\n\t        L: 2,\n\t        C: 3,\n\t        Q: 4,\n\t        A: 5,\n\t        Z: 6,\n\t        // Rect\n\t        R: 7\n\t    };\n\t\n\t    var min = [];\n\t    var max = [];\n\t    var min2 = [];\n\t    var max2 = [];\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathCos = Math.cos;\n\t    var mathSin = Math.sin;\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAbs = Math.abs;\n\t\n\t    var hasTypedArray = typeof Float32Array != 'undefined';\n\t\n\t    /**\n\t     * @alias module:zrender/core/PathProxy\n\t     * @constructor\n\t     */\n\t    var PathProxy = function () {\n\t\n\t        /**\n\t         * Path data. Stored as flat array\n\t         * @type {Array.<Object>}\n\t         */\n\t        this.data = [];\n\t\n\t        this._len = 0;\n\t\n\t        this._ctx = null;\n\t\n\t        this._xi = 0;\n\t        this._yi = 0;\n\t\n\t        this._x0 = 0;\n\t        this._y0 = 0;\n\t\n\t        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t        this._ux = 0;\n\t        this._uy = 0;\n\t    };\n\t\n\t    /**\n\t     * Path\n\t     * @return {Object}\n\t     */\n\t    PathProxy.prototype = {\n\t\n\t        constructor: PathProxy,\n\t\n\t        _lineDash: null,\n\t\n\t        _dashOffset: 0,\n\t\n\t        _dashIdx: 0,\n\t\n\t        _dashSum: 0,\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        setScale: function (sx, sy) {\n\t            this._ux = mathAbs(1 / dpr / sx) || 0;\n\t            this._uy = mathAbs(1 / dpr / sy) || 0;\n\t        },\n\t\n\t        getContext: function () {\n\t            return this._ctx;\n\t        },\n\t\n\t        /**\n\t         * @param  {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        beginPath: function (ctx) {\n\t\n\t            this._ctx = ctx;\n\t\n\t            ctx && ctx.beginPath();\n\t\n\t            ctx && (this.dpr = ctx.dpr);\n\t\n\t            // Reset\n\t            this._len = 0;\n\t\n\t            if (this._lineDash) {\n\t                this._lineDash = null;\n\t\n\t                this._dashOffset = 0;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        moveTo: function (x, y) {\n\t            this.addData(CMD.M, x, y);\n\t            this._ctx && this._ctx.moveTo(x, y);\n\t\n\t            // x0, y0, xi, yi  _dashedXXXXTo \n\t            // xi, yi , x0, y0  closePath \n\t            //  beginPath  lineTo x0, y0 \n\t            //  lineTo dashed line  IE10- \n\t            this._x0 = x;\n\t            this._y0 = y;\n\t\n\t            this._xi = x;\n\t            this._yi = y;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        lineTo: function (x, y) {\n\t            var exceedUnit = mathAbs(x - this._xi) > this._ux\n\t                || mathAbs(y - this._yi) > this._uy\n\t                // Force draw the first segment\n\t                || this._len < 5;\n\t\n\t            this.addData(CMD.L, x, y);\n\t\n\t            if (this._ctx && exceedUnit) {\n\t                this._needsDash() ? this._dashedLineTo(x, y)\n\t                    : this._ctx.lineTo(x, y);\n\t            }\n\t            if (exceedUnit) {\n\t                this._xi = x;\n\t                this._yi = y;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @param  {number} x3\n\t         * @param  {number} y3\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n\t                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t            }\n\t            this._xi = x3;\n\t            this._yi = y3;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        quadraticCurveTo: function (x1, y1, x2, y2) {\n\t            this.addData(CMD.Q, x1, y1, x2, y2);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n\t                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t            }\n\t            this._xi = x2;\n\t            this._yi = y2;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} cx\n\t         * @param  {number} cy\n\t         * @param  {number} r\n\t         * @param  {number} startAngle\n\t         * @param  {number} endAngle\n\t         * @param  {boolean} anticlockwise\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t            this.addData(\n\t                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n\t            );\n\t            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t\n\t            this._xi = mathCos(endAngle) * r + cx;\n\t            this._yi = mathSin(endAngle) * r + cx;\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        arcTo: function (x1, y1, x2, y2, radius) {\n\t            if (this._ctx) {\n\t                this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        rect: function (x, y, w, h) {\n\t            this._ctx && this._ctx.rect(x, y, w, h);\n\t            this.addData(CMD.R, x, y, w, h);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        closePath: function () {\n\t            this.addData(CMD.Z);\n\t\n\t            var ctx = this._ctx;\n\t            var x0 = this._x0;\n\t            var y0 = this._y0;\n\t            if (ctx) {\n\t                this._needsDash() && this._dashedLineTo(x0, y0);\n\t                ctx.closePath();\n\t            }\n\t\n\t            this._xi = x0;\n\t            this._yi = y0;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Context  rebuildPath  fill\n\t         * stroke \n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        fill: function (ctx) {\n\t            ctx && ctx.fill();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        stroke: function (ctx) {\n\t            ctx && ctx.stroke();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * \n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDash: function (lineDash) {\n\t            if (lineDash instanceof Array) {\n\t                this._lineDash = lineDash;\n\t\n\t                this._dashIdx = 0;\n\t\n\t                var lineDashSum = 0;\n\t                for (var i = 0; i < lineDash.length; i++) {\n\t                    lineDashSum += lineDash[i];\n\t                }\n\t                this._dashSum = lineDashSum;\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDashOffset: function (offset) {\n\t            this._dashOffset = offset;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         *\n\t         * @return {boolean}\n\t         */\n\t        len: function () {\n\t            return this._len;\n\t        },\n\t\n\t        /**\n\t         *  Path \n\t         */\n\t        setData: function (data) {\n\t\n\t            var len = data.length;\n\t\n\t            if (! (this.data && this.data.length == len) && hasTypedArray) {\n\t                this.data = new Float32Array(len);\n\t            }\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                this.data[i] = data[i];\n\t            }\n\t\n\t            this._len = len;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n\t         */\n\t        appendPath: function (path) {\n\t            if (!(path instanceof Array)) {\n\t                path = [path];\n\t            }\n\t            var len = path.length;\n\t            var appendSize = 0;\n\t            var offset = this._len;\n\t            for (var i = 0; i < len; i++) {\n\t                appendSize += path[i].len();\n\t            }\n\t            if (hasTypedArray && (this.data instanceof Float32Array)) {\n\t                this.data = new Float32Array(offset + appendSize);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                var appendPathData = path[i].data;\n\t                for (var k = 0; k < appendPathData.length; k++) {\n\t                    this.data[offset++] = appendPathData[k];\n\t                }\n\t            }\n\t            this._len = offset;\n\t        },\n\t\n\t        /**\n\t         *  Path \n\t         * \n\t         */\n\t        addData: function (cmd) {\n\t            var data = this.data;\n\t            if (this._len + arguments.length > data.length) {\n\t                //  Float32Array\n\t                // \n\t                this._expandData();\n\t                data = this.data;\n\t            }\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                data[this._len++] = arguments[i];\n\t            }\n\t\n\t            this._prevCmd = cmd;\n\t        },\n\t\n\t        _expandData: function () {\n\t            // Only if data is Float32Array\n\t            if (!(this.data instanceof Array)) {\n\t                var newData = [];\n\t                for (var i = 0; i < this._len; i++) {\n\t                    newData[i] = this.data[i];\n\t                }\n\t                this.data = newData;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * If needs js implemented dashed line\n\t         * @return {boolean}\n\t         * @private\n\t         */\n\t        _needsDash: function () {\n\t            return this._lineDash;\n\t        },\n\t\n\t        _dashedLineTo: function (x1, y1) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var dx = x1 - x0;\n\t            var dy = y1 - y0;\n\t            var dist = mathSqrt(dx * dx + dy * dy);\n\t            var x = x0;\n\t            var y = y0;\n\t            var dash;\n\t            var nDash = lineDash.length;\n\t            var idx;\n\t            dx /= dist;\n\t            dy /= dist;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            x -= offset * dx;\n\t            y -= offset * dy;\n\t\n\t            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n\t            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n\t                idx = this._dashIdx;\n\t                dash = lineDash[idx];\n\t                x += dx * dash;\n\t                y += dy * dash;\n\t                this._dashIdx = (idx + 1) % nDash;\n\t                // Skip positive offset\n\t                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n\t                    continue;\n\t                }\n\t                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n\t                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n\t                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n\t                );\n\t            }\n\t            // Offset for next lineTo\n\t            dx = x - x1;\n\t            dy = y - y1;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        // Not accurate dashed line to\n\t        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var t;\n\t            var dx;\n\t            var dy;\n\t            var cubicAt = curve.cubicAt;\n\t            var bezierLen = 0;\n\t            var idx = this._dashIdx;\n\t            var nDash = lineDash.length;\n\t\n\t            var x;\n\t            var y;\n\t\n\t            var tmpLen = 0;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            // Bezier approx length\n\t            for (t = 0; t < 1; t += 0.1) {\n\t                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n\t                    - cubicAt(x0, x1, x2, x3, t);\n\t                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n\t                    - cubicAt(y0, y1, y2, y3, t);\n\t                bezierLen += mathSqrt(dx * dx + dy * dy);\n\t            }\n\t\n\t            // Find idx after add offset\n\t            for (; idx < nDash; idx++) {\n\t                tmpLen += lineDash[idx];\n\t                if (tmpLen > offset) {\n\t                    break;\n\t                }\n\t            }\n\t            t = (tmpLen - offset) / bezierLen;\n\t\n\t            while (t <= 1) {\n\t\n\t                x = cubicAt(x0, x1, x2, x3, t);\n\t                y = cubicAt(y0, y1, y2, y3, t);\n\t\n\t                // Use line to approximate dashed bezier\n\t                // Bad result if dash is long\n\t                idx % 2 ? ctx.moveTo(x, y)\n\t                    : ctx.lineTo(x, y);\n\t\n\t                t += lineDash[idx] / bezierLen;\n\t\n\t                idx = (idx + 1) % nDash;\n\t            }\n\t\n\t            // Finish the last segment and calculate the new offset\n\t            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n\t            dx = x3 - x;\n\t            dy = y3 - y;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            var x3 = x2;\n\t            var y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (this._xi + 2 * x1) / 3;\n\t            y1 = (this._yi + 2 * y1) / 3;\n\t\n\t            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t        },\n\t\n\t        /**\n\t         *  Float32Array \n\t         * Convert dynamic array to static Float32Array\n\t         */\n\t        toStatic: function () {\n\t            var data = this.data;\n\t            if (data instanceof Array) {\n\t                data.length = this._len;\n\t                if (hasTypedArray) {\n\t                    this.data = new Float32Array(data);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function () {\n\t            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t\n\t            var data = this.data;\n\t            var xi = 0;\n\t            var yi = 0;\n\t            var x0 = 0;\n\t            var y0 = 0;\n\t\n\t            for (var i = 0; i < data.length;) {\n\t                var cmd = data[i++];\n\t\n\t                if (i == 1) {\n\t                    //  L, C, Q\n\t                    //  previous point  point\n\t                    //\n\t                    //  Arc \n\t                    xi = data[i];\n\t                    yi = data[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        // moveTo  subpath, \n\t                        //  closePath \n\t                        x0 = data[i++];\n\t                        y0 = data[i++];\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        min2[0] = x0;\n\t                        min2[1] = y0;\n\t                        max2[0] = x0;\n\t                        max2[1] = y0;\n\t                        break;\n\t                    case CMD.L:\n\t                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.C:\n\t                        bbox.fromCubic(\n\t                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.Q:\n\t                        bbox.fromQuadratic(\n\t                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.A:\n\t                        // TODO Arc \n\t                        var cx = data[i++];\n\t                        var cy = data[i++];\n\t                        var rx = data[i++];\n\t                        var ry = data[i++];\n\t                        var startAngle = data[i++];\n\t                        var endAngle = data[i++] + startAngle;\n\t                        // TODO Arc \n\t                        var psi = data[i++];\n\t                        var anticlockwise = 1 - data[i++];\n\t\n\t                        if (i == 1) {\n\t                            //  arc \n\t                            // \n\t                            x0 = mathCos(startAngle) * rx + cx;\n\t                            y0 = mathSin(startAngle) * ry + cy;\n\t                        }\n\t\n\t                        bbox.fromArc(\n\t                            cx, cy, rx, ry, startAngle, endAngle,\n\t                            anticlockwise, min2, max2\n\t                        );\n\t\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = data[i++];\n\t                        y0 = yi = data[i++];\n\t                        var width = data[i++];\n\t                        var height = data[i++];\n\t                        // Use fromLine\n\t                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t                        break;\n\t                    case CMD.Z:\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        break;\n\t                }\n\t\n\t                // Union\n\t                vec2.min(min, min, min2);\n\t                vec2.max(max, max, max2);\n\t            }\n\t\n\t            // No data\n\t            if (i === 0) {\n\t                min[0] = min[1] = max[0] = max[1] = 0;\n\t            }\n\t\n\t            return new BoundingRect(\n\t                min[0], min[1], max[0] - min[0], max[1] - min[1]\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Rebuild path from current data\n\t         * Rebuild path will not consider javascript implemented line dash.\n\t         * @param {CanvasRenderingContext} ctx\n\t         */\n\t        rebuildPath: function (ctx) {\n\t            var d = this.data;\n\t            var x0, y0;\n\t            var xi, yi;\n\t            var x, y;\n\t            var ux = this._ux;\n\t            var uy = this._uy;\n\t            var len = this._len;\n\t            for (var i = 0; i < len;) {\n\t                var cmd = d[i++];\n\t\n\t                if (i == 1) {\n\t                    //  L, C, Q\n\t                    //  previous point  point\n\t                    //\n\t                    //  Arc \n\t                    xi = d[i];\n\t                    yi = d[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        x0 = xi = d[i++];\n\t                        y0 = yi = d[i++];\n\t                        ctx.moveTo(xi, yi);\n\t                        break;\n\t                    case CMD.L:\n\t                        x = d[i++];\n\t                        y = d[i++];\n\t                        // Not draw too small seg between\n\t                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t                            ctx.lineTo(x, y);\n\t                            xi = x;\n\t                            yi = y;\n\t                        }\n\t                        break;\n\t                    case CMD.C:\n\t                        ctx.bezierCurveTo(\n\t                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n\t                        );\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.Q:\n\t                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.A:\n\t                        var cx = d[i++];\n\t                        var cy = d[i++];\n\t                        var rx = d[i++];\n\t                        var ry = d[i++];\n\t                        var theta = d[i++];\n\t                        var dTheta = d[i++];\n\t                        var psi = d[i++];\n\t                        var fs = d[i++];\n\t                        var r = (rx > ry) ? rx : ry;\n\t                        var scaleX = (rx > ry) ? 1 : rx / ry;\n\t                        var scaleY = (rx > ry) ? ry / rx : 1;\n\t                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n\t                        var endAngle = theta + dTheta;\n\t                        if (isEllipse) {\n\t                            ctx.translate(cx, cy);\n\t                            ctx.rotate(psi);\n\t                            ctx.scale(scaleX, scaleY);\n\t                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t                            ctx.scale(1 / scaleX, 1 / scaleY);\n\t                            ctx.rotate(-psi);\n\t                            ctx.translate(-cx, -cy);\n\t                        }\n\t                        else {\n\t                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t                        }\n\t\n\t                        if (i == 1) {\n\t                            //  arc \n\t                            // \n\t                            x0 = mathCos(theta) * rx + cx;\n\t                            y0 = mathSin(theta) * ry + cy;\n\t                        }\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = d[i];\n\t                        y0 = yi = d[i + 1];\n\t                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t                        break;\n\t                    case CMD.Z:\n\t                        ctx.closePath();\n\t                        xi = x0;\n\t                        yi = y0;\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    PathProxy.CMD = CMD;\n\t\n\t    module.exports = PathProxy;\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/core/curve\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(15);\n\t    var v2Create = vec2.create;\n\t    var v2DistSquare = vec2.distSquare;\n\t    var mathPow = Math.pow;\n\t    var mathSqrt = Math.sqrt;\n\t\n\t    var EPSILON = 1e-8;\n\t    var EPSILON_NUMERIC = 1e-4;\n\t\n\t    var THREE_SQRT = mathSqrt(3);\n\t    var ONE_THIRD = 1 / 3;\n\t\n\t    // \n\t    var _v0 = v2Create();\n\t    var _v1 = v2Create();\n\t    var _v2 = v2Create();\n\t    // var _v3 = vec2.create();\n\t\n\t    function isAroundZero(val) {\n\t        return val > -EPSILON && val < EPSILON;\n\t    }\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return onet * onet * (onet * p0 + 3 * t * p1)\n\t             + t * t * (t * p3 + 3 * onet * p2);\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return 3 * (\n\t            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n\t            + (p3 - p2) * t * t\n\t        );\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} val\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} \n\t     */\n\t    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t        // Evaluate roots of cubic functions\n\t        var a = p3 + 3 * (p1 - p2) - p0;\n\t        var b = 3 * (p2 - p1 * 2 + p0);\n\t        var c = 3 * (p1  - p0);\n\t        var d = p0 - val;\n\t\n\t        var A = b * b - 3 * a * c;\n\t        var B = b * c - 9 * a * d;\n\t        var C = c * c - 3 * b * d;\n\t\n\t        var n = 0;\n\t\n\t        if (isAroundZero(A) && isAroundZero(B)) {\n\t            if (isAroundZero(b)) {\n\t                roots[0] = 0;\n\t            }\n\t            else {\n\t                var t1 = -c / b;  //t1, t2, t3, b is not zero\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = B * B - 4 * A * C;\n\t\n\t            if (isAroundZero(disc)) {\n\t                var K = B / A;\n\t                var t1 = -b / a + K;  // t1, a is not zero\n\t                var t2 = -K / 2;  // t2, t3\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t                if (Y1 < 0) {\n\t                    Y1 = -mathPow(-Y1, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y1 = mathPow(Y1, ONE_THIRD);\n\t                }\n\t                if (Y2 < 0) {\n\t                    Y2 = -mathPow(-Y2, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y2 = mathPow(Y2, ONE_THIRD);\n\t                }\n\t                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else {\n\t                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t                var theta = Math.acos(T) / 3;\n\t                var ASqrt = mathSqrt(A);\n\t                var tmp = Math.cos(theta);\n\t\n\t                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t                if (t3 >= 0 && t3 <= 1) {\n\t                    roots[n++] = t3;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {Array.<number>} extrema\n\t     * @return {number} \n\t     */\n\t    function cubicExtrema(p0, p1, p2, p3, extrema) {\n\t        var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t        var c = 3 * p1 - 3 * p0;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <=1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                extrema[0] = -b / (2 * a);\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    extrema[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p23 = (p3 - p2) * t + p2;\n\t\n\t        var p012 = (p12 - p01) * t + p01;\n\t        var p123 = (p23 - p12) * t + p12;\n\t\n\t        var p0123 = (p123 - p012) * t + p012;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        out[3] = p0123;\n\t        // Seg1\n\t        out[4] = p0123;\n\t        out[5] = p123;\n\t        out[6] = p23;\n\t        out[7] = p3;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * \n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} [out] \n\t     * @return {number}\n\t     */\n\t    function cubicProjectPoint(\n\t        x0, y0, x1, y1, x2, y2, x3, y3,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        var prev;\n\t        var next;\n\t        var d1;\n\t        var d2;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        //  t \n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t            d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            prev = t - interval;\n\t            next = t + interval;\n\t            // t - interval\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t\n\t            d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t                d2 = v2DistSquare(_v2, _v0);\n\t\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = cubicAt(x0, x1, x2, x3, t);\n\t            out[1] = cubicAt(y0, y1, y2, y3, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticAt(p0, p1, p2, t) {\n\t        var onet = 1 - t;\n\t        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticDerivativeAt(p0, p1, p2, t) {\n\t        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} \n\t     */\n\t    function quadraticRootAt(p0, p1, p2, val, roots) {\n\t        var a = p0 - 2 * p1 + p2;\n\t        var b = 2 * (p1 - p0);\n\t        var c = p0 - val;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                var t1 = -b / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @return {number}\n\t     */\n\t    function quadraticExtremum(p0, p1, p2) {\n\t        var divider = p0 + p2 - 2 * p1;\n\t        if (divider === 0) {\n\t            // p1 is center of p0 and p2\n\t            return 0.5;\n\t        }\n\t        else {\n\t            return (p0 - p1) / divider;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function quadraticSubdivide(p0, p1, p2, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p012 = (p12 - p01) * t + p01;\n\t\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t\n\t        // Seg1\n\t        out[3] = p012;\n\t        out[4] = p12;\n\t        out[5] = p2;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * \n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} out \n\t     * @return {number}\n\t     */\n\t    function quadraticProjectPoint(\n\t        x0, y0, x1, y1, x2, y2,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        //  t \n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t            _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t            var d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            var prev = t - interval;\n\t            var next = t + interval;\n\t            // t - interval\n\t            _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t\n\t            var d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = quadraticAt(x0, x1, x2, next);\n\t                _v2[1] = quadraticAt(y0, y1, y2, next);\n\t                var d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = quadraticAt(x0, x1, x2, t);\n\t            out[1] = quadraticAt(y0, y1, y2, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        cubicAt: cubicAt,\n\t\n\t        cubicDerivativeAt: cubicDerivativeAt,\n\t\n\t        cubicRootAt: cubicRootAt,\n\t\n\t        cubicExtrema: cubicExtrema,\n\t\n\t        cubicSubdivide: cubicSubdivide,\n\t\n\t        cubicProjectPoint: cubicProjectPoint,\n\t\n\t        quadraticAt: quadraticAt,\n\t\n\t        quadraticDerivativeAt: quadraticDerivativeAt,\n\t\n\t        quadraticRootAt: quadraticRootAt,\n\t\n\t        quadraticExtremum: quadraticExtremum,\n\t\n\t        quadraticSubdivide: quadraticSubdivide,\n\t\n\t        quadraticProjectPoint: quadraticProjectPoint\n\t    };\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author Yi Shen(https://github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(15);\n\t    var curve = __webpack_require__(46);\n\t\n\t    var bbox = {};\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t\n\t    var start = vec2.create();\n\t    var end = vec2.create();\n\t    var extremity = vec2.create();\n\t\n\t    var PI2 = Math.PI * 2;\n\t    /**\n\t     * `min``max`\n\t     * @module zrender/core/bbox\n\t     * @param {Array<Object>} points \n\t     * @param {number} min\n\t     * @param {number} max\n\t     */\n\t    bbox.fromPoints = function(points, min, max) {\n\t        if (points.length === 0) {\n\t            return;\n\t        }\n\t        var p = points[0];\n\t        var left = p[0];\n\t        var right = p[0];\n\t        var top = p[1];\n\t        var bottom = p[1];\n\t        var i;\n\t\n\t        for (i = 1; i < points.length; i++) {\n\t            p = points[i];\n\t            left = mathMin(left, p[0]);\n\t            right = mathMax(right, p[0]);\n\t            top = mathMin(top, p[1]);\n\t            bottom = mathMax(bottom, p[1]);\n\t        }\n\t\n\t        min[0] = left;\n\t        min[1] = top;\n\t        max[0] = right;\n\t        max[1] = bottom;\n\t    };\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n\t        min[0] = mathMin(x0, x1);\n\t        min[1] = mathMin(y0, y1);\n\t        max[0] = mathMax(x0, x1);\n\t        max[1] = mathMax(y0, y1);\n\t    };\n\t\n\t    var xDim = [];\n\t    var yDim = [];\n\t    /**\n\t     * (p0, p1, p2, p3)`min``max`\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromCubic = function(\n\t        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n\t    ) {\n\t        var cubicExtrema = curve.cubicExtrema;\n\t        var cubicAt = curve.cubicAt;\n\t        var i;\n\t        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t        min[0] = Infinity;\n\t        min[1] = Infinity;\n\t        max[0] = -Infinity;\n\t        max[1] = -Infinity;\n\t\n\t        for (i = 0; i < n; i++) {\n\t            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t            min[0] = mathMin(x, min[0]);\n\t            max[0] = mathMax(x, max[0]);\n\t        }\n\t        n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t        for (i = 0; i < n; i++) {\n\t            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t            min[1] = mathMin(y, min[1]);\n\t            max[1] = mathMax(y, max[1]);\n\t        }\n\t\n\t        min[0] = mathMin(x0, min[0]);\n\t        max[0] = mathMax(x0, max[0]);\n\t        min[0] = mathMin(x3, min[0]);\n\t        max[0] = mathMax(x3, max[0]);\n\t\n\t        min[1] = mathMin(y0, min[1]);\n\t        max[1] = mathMax(y0, max[1]);\n\t        min[1] = mathMin(y3, min[1]);\n\t        max[1] = mathMax(y3, max[1]);\n\t    };\n\t\n\t    /**\n\t     * (p0, p1, p2)`min``max`\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n\t        var quadraticExtremum = curve.quadraticExtremum;\n\t        var quadraticAt = curve.quadraticAt;\n\t        // Find extremities, where derivative in x dim or y dim is zero\n\t        var tx =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n\t            );\n\t        var ty =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n\t            );\n\t\n\t        var x = quadraticAt(x0, x1, x2, tx);\n\t        var y = quadraticAt(y0, y1, y2, ty);\n\t\n\t        min[0] = mathMin(x0, x2, x);\n\t        min[1] = mathMin(y0, y2, y);\n\t        max[0] = mathMax(x0, x2, x);\n\t        max[1] = mathMax(y0, y2, y);\n\t    };\n\t\n\t    /**\n\t     * `min``max`\n\t     * @method\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {number} rx\n\t     * @param {number} ry\n\t     * @param {number} startAngle\n\t     * @param {number} endAngle\n\t     * @param {number} anticlockwise\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromArc = function (\n\t        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n\t    ) {\n\t        var vec2Min = vec2.min;\n\t        var vec2Max = vec2.max;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t\n\t\n\t        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n\t            // Is a circle\n\t            min[0] = x - rx;\n\t            min[1] = y - ry;\n\t            max[0] = x + rx;\n\t            max[1] = y + ry;\n\t            return;\n\t        }\n\t\n\t        start[0] = mathCos(startAngle) * rx + x;\n\t        start[1] = mathSin(startAngle) * ry + y;\n\t\n\t        end[0] = mathCos(endAngle) * rx + x;\n\t        end[1] = mathSin(endAngle) * ry + y;\n\t\n\t        vec2Min(min, start, end);\n\t        vec2Max(max, start, end);\n\t\n\t        // Thresh to [0, Math.PI * 2]\n\t        startAngle = startAngle % (PI2);\n\t        if (startAngle < 0) {\n\t            startAngle = startAngle + PI2;\n\t        }\n\t        endAngle = endAngle % (PI2);\n\t        if (endAngle < 0) {\n\t            endAngle = endAngle + PI2;\n\t        }\n\t\n\t        if (startAngle > endAngle && !anticlockwise) {\n\t            endAngle += PI2;\n\t        }\n\t        else if (startAngle < endAngle && anticlockwise) {\n\t            startAngle += PI2;\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = endAngle;\n\t            endAngle = startAngle;\n\t            startAngle = tmp;\n\t        }\n\t\n\t        // var number = 0;\n\t        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t            if (angle > startAngle) {\n\t                extremity[0] = mathCos(angle) * rx + x;\n\t                extremity[1] = mathSin(angle) * ry + y;\n\t\n\t                vec2Min(min, extremity, min);\n\t                vec2Max(max, extremity, max);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = bbox;\n\t\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var CMD = __webpack_require__(45).CMD;\n\t    var line = __webpack_require__(49);\n\t    var cubic = __webpack_require__(50);\n\t    var quadratic = __webpack_require__(51);\n\t    var arc = __webpack_require__(52);\n\t    var normalizeRadian = __webpack_require__(53).normalizeRadian;\n\t    var curve = __webpack_require__(46);\n\t\n\t    var windingLine = __webpack_require__(54);\n\t\n\t    var containStroke = line.containStroke;\n\t\n\t    var PI2 = Math.PI * 2;\n\t\n\t    var EPSILON = 1e-4;\n\t\n\t    function isAroundEqual(a, b) {\n\t        return Math.abs(a - b) < EPSILON;\n\t    }\n\t\n\t    // \n\t    var roots = [-1, -1, -1];\n\t    var extrema = [-1, -1];\n\t\n\t    function swapExtrema() {\n\t        var tmp = extrema[0];\n\t        extrema[0] = extrema[1];\n\t        extrema[1] = tmp;\n\t    }\n\t\n\t    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2 && y > y3)\n\t            || (y < y0 && y < y1 && y < y2 && y < y3)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var w = 0;\n\t            var nExtrema = -1;\n\t            var y0_, y1_;\n\t            for (var i = 0; i < nRoots; i++) {\n\t                var t = roots[i];\n\t\n\t                // Avoid winding error when intersection point is the connect point of two line of polygon\n\t                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t                if (x_ < x) { // Quick reject\n\t                    continue;\n\t                }\n\t                if (nExtrema < 0) {\n\t                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t                        swapExtrema();\n\t                    }\n\t                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t                    if (nExtrema > 1) {\n\t                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t                    }\n\t                }\n\t                if (nExtrema == 2) {\n\t                    // \n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else if (t < extrema[1]) {\n\t                        w += y1_ < y0_ ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y1_ ? unit : -unit;\n\t                    }\n\t                }\n\t                else {\n\t                    // \n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y0_ ? unit : -unit;\n\t                    }\n\t                }\n\t            }\n\t            return w;\n\t        }\n\t    }\n\t\n\t    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2)\n\t            || (y < y0 && y < y1 && y < y2)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var t = curve.quadraticExtremum(y0, y1, y2);\n\t            if (t >= 0 && t <= 1) {\n\t                var w = 0;\n\t                var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t                for (var i = 0; i < nRoots; i++) {\n\t                    // Remove one endpoint.\n\t                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\t\n\t                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t                    if (x_ < x) {   // Quick reject\n\t                        continue;\n\t                    }\n\t                    if (roots[i] < t) {\n\t                        w += y_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y2 < y_ ? unit : -unit;\n\t                    }\n\t                }\n\t                return w;\n\t            }\n\t            else {\n\t                // Remove one endpoint.\n\t                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t                if (x_ < x) {   // Quick reject\n\t                    return 0;\n\t                }\n\t                return y2 < y0 ? unit : -unit;\n\t            }\n\t        }\n\t    }\n\t\n\t    // TODO\n\t    // Arc \n\t    function windingArc(\n\t        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n\t    ) {\n\t        y -= cy;\n\t        if (y > r || y < -r) {\n\t            return 0;\n\t        }\n\t        var tmp = Math.sqrt(r * r - y * y);\n\t        roots[0] = -tmp;\n\t        roots[1] = tmp;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff < 1e-4) {\n\t            return 0;\n\t        }\n\t        if (diff % PI2 < 1e-4) {\n\t            // Is a circle\n\t            startAngle = 0;\n\t            endAngle = PI2;\n\t            var dir = anticlockwise ? 1 : -1;\n\t            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t                return dir;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t\n\t        if (anticlockwise) {\n\t            var tmp = startAngle;\n\t            startAngle = normalizeRadian(endAngle);\n\t            endAngle = normalizeRadian(tmp);\n\t        }\n\t        else {\n\t            startAngle = normalizeRadian(startAngle);\n\t            endAngle = normalizeRadian(endAngle);\n\t        }\n\t        if (startAngle > endAngle) {\n\t            endAngle += PI2;\n\t        }\n\t\n\t        var w = 0;\n\t        for (var i = 0; i < 2; i++) {\n\t            var x_ = roots[i];\n\t            if (x_ + cx > x) {\n\t                var angle = Math.atan2(y, x_);\n\t                var dir = anticlockwise ? 1 : -1;\n\t                if (angle < 0) {\n\t                    angle = PI2 + angle;\n\t                }\n\t                if (\n\t                    (angle >= startAngle && angle <= endAngle)\n\t                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n\t                ) {\n\t                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t                        dir = -dir;\n\t                    }\n\t                    w += dir;\n\t                }\n\t            }\n\t        }\n\t        return w;\n\t    }\n\t\n\t    function containPath(data, lineWidth, isStroke, x, y) {\n\t        var w = 0;\n\t        var xi = 0;\n\t        var yi = 0;\n\t        var x0 = 0;\n\t        var y0 = 0;\n\t\n\t        for (var i = 0; i < data.length;) {\n\t            var cmd = data[i++];\n\t            // Begin a new subpath\n\t            if (cmd === CMD.M && i > 1) {\n\t                // Close previous subpath\n\t                if (!isStroke) {\n\t                    w += windingLine(xi, yi, x0, y0, x, y);\n\t                }\n\t                //  subpath \n\t                // if (w !== 0) {\n\t                //     return true;\n\t                // }\n\t            }\n\t\n\t            if (i == 1) {\n\t                //  L, C, Q\n\t                //  previous point  point\n\t                //\n\t                //  Arc \n\t                xi = data[i];\n\t                yi = data[i + 1];\n\t\n\t                x0 = xi;\n\t                y0 = yi;\n\t            }\n\t\n\t            switch (cmd) {\n\t                case CMD.M:\n\t                    // moveTo  subpath, \n\t                    //  closePath \n\t                    x0 = data[i++];\n\t                    y0 = data[i++];\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t                case CMD.L:\n\t                    if (isStroke) {\n\t                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // NOTE  L, C, Q  NaN\n\t                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.C:\n\t                    if (isStroke) {\n\t                        if (cubic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingCubic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.Q:\n\t                    if (isStroke) {\n\t                        if (quadratic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingQuadratic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.A:\n\t                    // TODO Arc \n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var theta = data[i++];\n\t                    var dTheta = data[i++];\n\t                    // TODO Arc \n\t                    var psi = data[i++];\n\t                    var anticlockwise = 1 - data[i++];\n\t                    var x1 = Math.cos(theta) * rx + cx;\n\t                    var y1 = Math.sin(theta) * ry + cy;\n\t                    //  arc \n\t                    if (i > 1) {\n\t                        w += windingLine(xi, yi, x1, y1, x, y);\n\t                    }\n\t                    else {\n\t                        // \n\t                        x0 = x1;\n\t                        y0 = y1;\n\t                    }\n\t                    // zr scale, x\n\t                    var _x = (x - cx) * ry / rx + cx;\n\t                    if (isStroke) {\n\t                        if (arc.containStroke(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            lineWidth, _x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingArc(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            _x, y\n\t                        );\n\t                    }\n\t                    xi = Math.cos(theta + dTheta) * rx + cx;\n\t                    yi = Math.sin(theta + dTheta) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = data[i++];\n\t                    y0 = yi = data[i++];\n\t                    var width = data[i++];\n\t                    var height = data[i++];\n\t                    var x1 = x0 + width;\n\t                    var y1 = y0 + height;\n\t                    if (isStroke) {\n\t                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n\t                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n\t                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n\t                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n\t                        ) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // FIXME Clockwise ?\n\t                        w += windingLine(x1, y0, x1, y1, x, y);\n\t                        w += windingLine(x0, y1, x0, y0, x, y);\n\t                    }\n\t                    break;\n\t                case CMD.Z:\n\t                    if (isStroke) {\n\t                        if (containStroke(\n\t                            xi, yi, x0, y0, lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // Close a subpath\n\t                        w += windingLine(xi, yi, x0, y0, x, y);\n\t                        //  subpath \n\t                        // FIXME subpaths may overlap\n\t                        // if (w !== 0) {\n\t                        //     return true;\n\t                        // }\n\t                    }\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t            }\n\t        }\n\t        if (!isStroke && !isAroundEqual(yi, y0)) {\n\t            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t        }\n\t        return w !== 0;\n\t    }\n\t\n\t    module.exports = {\n\t        contain: function (pathData, x, y) {\n\t            return containPath(pathData, 0, false, x, y);\n\t        },\n\t\n\t        containStroke: function (pathData, lineWidth, x, y) {\n\t            return containPath(pathData, lineWidth, true, x, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            var _a = 0;\n\t            var _b = x0;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l)\n\t                || (y < y0 - _l && y < y1 - _l)\n\t                || (x > x0 + _l && x > x1 + _l)\n\t                || (x < x0 - _l && x < x1 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t\n\t            if (x0 !== x1) {\n\t                _a = (y0 - y1) / (x0 - x1);\n\t                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n\t            }\n\t            else {\n\t                return Math.abs(x - x0) <= _l / 2;\n\t            }\n\t            var tmp = _a * x - y + _b;\n\t            var _s = tmp * tmp / (_a * _a + 1);\n\t            return _s <= _l / 2 * _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(46);\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  x3\n\t         * @param  {number}  y3\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.cubicProjectPoint(\n\t                x0, y0, x1, y1, x2, y2, x3, y3,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(46);\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.quadraticProjectPoint(\n\t                x0, y0, x1, y1, x2, y2,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var normalizeRadian = __webpack_require__(53).normalizeRadian;\n\t    var PI2 = Math.PI * 2;\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  cx\n\t         * @param  {number}  cy\n\t         * @param  {number}  r\n\t         * @param  {number}  startAngle\n\t         * @param  {number}  endAngle\n\t         * @param  {boolean}  anticlockwise\n\t         * @param  {number} lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {Boolean}\n\t         */\n\t        containStroke: function (\n\t            cx, cy, r, startAngle, endAngle, anticlockwise,\n\t            lineWidth, x, y\n\t        ) {\n\t\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t\n\t            x -= cx;\n\t            y -= cy;\n\t            var d = Math.sqrt(x * x + y * y);\n\t\n\t            if ((d - _l > r) || (d + _l < r)) {\n\t                return false;\n\t            }\n\t            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n\t                // Is a circle\n\t                return true;\n\t            }\n\t            if (anticlockwise) {\n\t                var tmp = startAngle;\n\t                startAngle = normalizeRadian(endAngle);\n\t                endAngle = normalizeRadian(tmp);\n\t            } else {\n\t                startAngle = normalizeRadian(startAngle);\n\t                endAngle = normalizeRadian(endAngle);\n\t            }\n\t            if (startAngle > endAngle) {\n\t                endAngle += PI2;\n\t            }\n\t\n\t            var angle = Math.atan2(y, x);\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return (angle >= startAngle && angle <= endAngle)\n\t                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n\t        }\n\t    };\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var PI2 = Math.PI * 2;\n\t    module.exports = {\n\t        normalizeRadian: function(angle) {\n\t            angle %= PI2;\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n\t        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n\t            return 0;\n\t        }\n\t        // Ignore horizontal line\n\t        if (y1 === y0) {\n\t            return 0;\n\t        }\n\t        var dir = y1 < y0 ? 1 : -1;\n\t        var t = (y - y0) / (y1 - y0);\n\t\n\t        // Avoid winding error when intersection point is the connect point of two line of polygon\n\t        if (t === 1 || t === 0) {\n\t            dir = y1 < y0 ? 0.5 : -0.5;\n\t        }\n\t\n\t        var x_ = t * (x1 - x0) + x0;\n\t\n\t        return x_ > x ? dir : 0;\n\t    };\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var CMD = __webpack_require__(45).CMD;\n\t    var vec2 = __webpack_require__(15);\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t\n\t    var points = [[], [], []];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAtan2 = Math.atan2;\n\t    function transformPath(path, m) {\n\t        var data = path.data;\n\t        var cmd;\n\t        var nPoint;\n\t        var i;\n\t        var j;\n\t        var k;\n\t        var p;\n\t\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var R = CMD.R;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t\n\t        for (i = 0, j = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            j = i;\n\t            nPoint = 0;\n\t\n\t            switch (cmd) {\n\t                case M:\n\t                    nPoint = 1;\n\t                    break;\n\t                case L:\n\t                    nPoint = 1;\n\t                    break;\n\t                case C:\n\t                    nPoint = 3;\n\t                    break;\n\t                case Q:\n\t                    nPoint = 2;\n\t                    break;\n\t                case A:\n\t                    var x = m[4];\n\t                    var y = m[5];\n\t                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n\t                    // cx\n\t                    data[i++] += x;\n\t                    // cy\n\t                    data[i++] += y;\n\t                    // Scale rx and ry\n\t                    // FIXME Assume psi is 0 here\n\t                    data[i++] *= sx;\n\t                    data[i++] *= sy;\n\t\n\t                    // Start angle\n\t                    data[i++] += angle;\n\t                    // end angle\n\t                    data[i++] += angle;\n\t                    // FIXME psi\n\t                    i += 2;\n\t                    j = i;\n\t                    break;\n\t                case R:\n\t                    // x0, y0\n\t                    p[0] = data[i++];\n\t                    p[1] = data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t                    // x1, y1\n\t                    p[0] += data[i++];\n\t                    p[1] += data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t            }\n\t\n\t            for (k = 0; k < nPoint; k++) {\n\t                var p = points[k];\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t\n\t                v2ApplyTransform(p, p, m);\n\t                // Write back\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = transformPath;\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    /**\n\t     * @param {Array.<Object>} colorStops\n\t     */\n\t    var Gradient = function (colorStops) {\n\t\n\t        this.colorStops = colorStops || [];\n\t    };\n\t\n\t    Gradient.prototype = {\n\t\n\t        constructor: Gradient,\n\t\n\t        addColorStop: function (offset, color) {\n\t            this.colorStops.push({\n\t\n\t                offset: offset,\n\t\n\t                color: color\n\t            });\n\t        }\n\t    };\n\t\n\t    module.exports = Gradient;\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Text element\n\t * @module zrender/graphic/Text\n\t *\n\t * TODO Wrapping\n\t *\n\t * Text not support gradient\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(36);\n\t    var zrUtil = __webpack_require__(6);\n\t    var textContain = __webpack_require__(38);\n\t\n\t    /**\n\t     * @alias zrender/graphic/Text\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    var Text = function (opts) {\n\t        Displayable.call(this, opts);\n\t    };\n\t\n\t    Text.prototype = {\n\t\n\t        constructor: Text,\n\t\n\t        type: 'text',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var x = style.x || 0;\n\t            var y = style.y || 0;\n\t            // Convert to string\n\t            var text = style.text;\n\t\n\t            // Convert to string\n\t            text != null && (text += '');\n\t\n\t            // Always bind style\n\t            style.bind(ctx, this, prevEl);\n\t\n\t            if (text) {\n\t\n\t                this.setTransform(ctx);\n\t\n\t                var textBaseline;\n\t                var textAlign = style.textAlign;\n\t                var font = style.textFont || style.font;\n\t                if (style.textVerticalAlign) {\n\t                    var rect = textContain.getBoundingRect(\n\t                        text, font, style.textAlign, 'top'\n\t                    );\n\t                    // Ignore textBaseline\n\t                    textBaseline = 'middle';\n\t                    switch (style.textVerticalAlign) {\n\t                        case 'middle':\n\t                            y -= rect.height / 2 - rect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= rect.height - rect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += rect.lineHeight / 2;\n\t                    }\n\t                }\n\t                else {\n\t                    textBaseline = style.textBaseline;\n\t                }\n\t\n\t                // TODO Invalid font\n\t                ctx.font = font || '12px sans-serif';\n\t                ctx.textAlign = textAlign || 'left';\n\t                // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t                if (ctx.textAlign !== textAlign) {\n\t                    ctx.textAlign = 'left';\n\t                }\n\t                // FIXME in text contain default is top\n\t                ctx.textBaseline = textBaseline || 'alphabetic';\n\t                // Use canvas default alphabetic baseline\n\t                if (ctx.textBaseline !== textBaseline) {\n\t                    ctx.textBaseline = 'alphabetic';\n\t                }\n\t\n\t                var lineHeight = textContain.measureText('', ctx.font).width;\n\t\n\t                var textLines = text.split('\\n');\n\t                for (var i = 0; i < textLines.length; i++) {\n\t                    // Fill after stroke so the outline will not cover the main part.\n\t                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n\t                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n\t                    y += lineHeight;\n\t                }\n\t\n\t                this.restoreTransform(ctx);\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t            if (!this._rect) {\n\t                var textVerticalAlign = style.textVerticalAlign;\n\t                var rect = textContain.getBoundingRect(\n\t                    style.text + '', style.textFont || style.font, style.textAlign,\n\t                    textVerticalAlign ? 'top' : style.textBaseline\n\t                );\n\t                switch (textVerticalAlign) {\n\t                    case 'middle':\n\t                        rect.y -= rect.height / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        rect.y -= rect.height;\n\t                        break;\n\t                }\n\t                rect.x += style.x || 0;\n\t                rect.y += style.y || 0;\n\t                if (style.hasStroke()) {\n\t                    var w = style.lineWidth;\n\t                    rect.x -= w / 2;\n\t                    rect.y -= w / 2;\n\t                    rect.width += w;\n\t                    rect.height += w;\n\t                }\n\t                this._rect = rect;\n\t            }\n\t\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Text, Displayable);\n\t\n\t    module.exports = Text;\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/shape/Circle\n\t */\n\t\n\t\n\t\n\t    module.exports = __webpack_require__(44).extend({\n\t\n\t        type: 'circle',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0\n\t        },\n\t\n\t\n\t        buildPath : function (ctx, shape, inBundle) {\n\t            // Better stroking in ShapeBundle\n\t            // Always do it may have performence issue ( fill may be 2x more cost)\n\t            if (inBundle) {\n\t                ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            }\n\t            // Better stroking in ShapeBundle\n\t            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Sector\n\t */\n\t\n\t\n\t\n\t    var env = __webpack_require__(5);\n\t    var Path = __webpack_require__(44);\n\t\n\t    var shadowTemp = [\n\t        ['shadowBlur', 0],\n\t        ['shadowColor', '#000'],\n\t        ['shadowOffsetX', 0],\n\t        ['shadowOffsetY', 0]\n\t    ];\n\t\n\t    module.exports = Path.extend({\n\t\n\t        type: 'sector',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r0: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\n\t            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\n\t            // where exception \"unexpected call to method or property access\"\n\t            // might be thrown when calling ctx.fill after a path whose area size\n\t            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\n\t            // (e.g.,\n\t            //  ctx.moveTo(10, 10);\n\t            //  ctx.lineTo(20, 10);\n\t            //  ctx.closePath();\n\t            //  ctx.clip();\n\t            //  ctx.shadowBlur = 10;\n\t            //  ...\n\t            //  ctx.fill();\n\t            // )\n\t            ? function () {\n\t                var clipPaths = this.__clipPaths;\n\t                var style = this.style;\n\t                var modified;\n\t\n\t                if (clipPaths) {\n\t                    for (var i = 0; i < clipPaths.length; i++) {\n\t                        var shape = clipPaths[i] && clipPaths[i].shape;\n\t                        if (shape && shape.startAngle === shape.endAngle) {\n\t                            for (var j = 0; j < shadowTemp.length; j++) {\n\t                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n\t                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n\t                            }\n\t                            modified = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t\n\t                Path.prototype.brush.apply(this, arguments);\n\t\n\t                if (modified) {\n\t                    for (var j = 0; j < shadowTemp.length; j++) {\n\t                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n\t                    }\n\t                }\n\t            }\n\t            : Path.prototype.brush,\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r0 = Math.max(shape.r0 || 0, 0);\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t\n\t            ctx.lineTo(unitX * r + x, unitY * r + y);\n\t\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t\n\t            ctx.lineTo(\n\t                Math.cos(endAngle) * r0 + x,\n\t                Math.sin(endAngle) * r0 + y\n\t            );\n\t\n\t            if (r0 !== 0) {\n\t                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t            }\n\t\n\t            ctx.closePath();\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Ring\n\t */\n\t\n\t\n\t    module.exports = __webpack_require__(44).extend({\n\t\n\t        type: 'ring',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            r0: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var PI2 = Math.PI * 2;\n\t            ctx.moveTo(x + shape.r, y);\n\t            ctx.arc(x, y, shape.r, 0, PI2, false);\n\t            ctx.moveTo(x + shape.r0, y);\n\t            ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/shape/Polygon\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(62);\n\t\n\t    module.exports = __webpack_require__(44).extend({\n\t        \n\t        type: 'polygon',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, true);\n\t        }\n\t    });\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var smoothSpline = __webpack_require__(63);\n\t    var smoothBezier = __webpack_require__(64);\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape, closePath) {\n\t            var points = shape.points;\n\t            var smooth = shape.smooth;\n\t            if (points && points.length >= 2) {\n\t                if (smooth && smooth !== 'spline') {\n\t                    var controlPoints = smoothBezier(\n\t                        points, smooth, closePath, shape.smoothConstraint\n\t                    );\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    var len = points.length;\n\t                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t                        var cp1 = controlPoints[i * 2];\n\t                        var cp2 = controlPoints[i * 2 + 1];\n\t                        var p = points[(i + 1) % len];\n\t                        ctx.bezierCurveTo(\n\t                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n\t                        );\n\t                    }\n\t                }\n\t                else {\n\t                    if (smooth === 'spline') {\n\t                        points = smoothSpline(points, closePath);\n\t                    }\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    for (var i = 1, l = points.length; i < l; i++) {\n\t                        ctx.lineTo(points[i][0], points[i][1]);\n\t                    }\n\t                }\n\t\n\t                closePath && ctx.closePath();\n\t            }\n\t        }\n\t    };\n\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Catmull-Rom spline \n\t * @module zrender/shape/util/smoothSpline\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t    var vec2 = __webpack_require__(15);\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/shape/util/smoothSpline\n\t     * @param {Array} points \n\t     * @param {boolean} isLoop\n\t     * @return {Array}\n\t     */\n\t    module.exports = function (points, isLoop) {\n\t        var len = points.length;\n\t        var ret = [];\n\t\n\t        var distance = 0;\n\t        for (var i = 1; i < len; i++) {\n\t            distance += vec2.distance(points[i - 1], points[i]);\n\t        }\n\t\n\t        var segs = distance / 2;\n\t        segs = segs < len ? len : segs;\n\t        for (var i = 0; i < segs; i++) {\n\t            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t            var idx = Math.floor(pos);\n\t\n\t            var w = pos - idx;\n\t\n\t            var p0;\n\t            var p1 = points[idx % len];\n\t            var p2;\n\t            var p3;\n\t            if (!isLoop) {\n\t                p0 = points[idx === 0 ? idx : idx - 1];\n\t                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t            }\n\t            else {\n\t                p0 = points[(idx - 1 + len) % len];\n\t                p2 = points[(idx + 1) % len];\n\t                p3 = points[(idx + 2) % len];\n\t            }\n\t\n\t            var w2 = w * w;\n\t            var w3 = w * w2;\n\t\n\t            ret.push([\n\t                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n\t                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n\t            ]);\n\t        }\n\t        return ret;\n\t    };\n\t\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/shape/util/smoothBezier\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(15);\n\t    var v2Min = vec2.min;\n\t    var v2Max = vec2.max;\n\t    var v2Scale = vec2.scale;\n\t    var v2Distance = vec2.distance;\n\t    var v2Add = vec2.add;\n\t\n\t    /**\n\t     * \n\t     * @alias module:zrender/shape/util/smoothBezier\n\t     * @param {Array} points \n\t     * @param {number} smooth , 0-1\n\t     * @param {boolean} isLoop\n\t     * @param {Array} constraint \n\t     *                            [[0, 0], [100, 100]], \n\t     *                           \n\t     * @param {Array} \n\t     */\n\t    module.exports = function (points, smooth, isLoop, constraint) {\n\t        var cps = [];\n\t\n\t        var v = [];\n\t        var v1 = [];\n\t        var v2 = [];\n\t        var prevPoint;\n\t        var nextPoint;\n\t\n\t        var min, max;\n\t        if (constraint) {\n\t            min = [Infinity, Infinity];\n\t            max = [-Infinity, -Infinity];\n\t            for (var i = 0, len = points.length; i < len; i++) {\n\t                v2Min(min, min, points[i]);\n\t                v2Max(max, max, points[i]);\n\t            }\n\t            // \n\t            v2Min(min, min, constraint[0]);\n\t            v2Max(max, max, constraint[1]);\n\t        }\n\t\n\t        for (var i = 0, len = points.length; i < len; i++) {\n\t            var point = points[i];\n\t\n\t            if (isLoop) {\n\t                prevPoint = points[i ? i - 1 : len - 1];\n\t                nextPoint = points[(i + 1) % len];\n\t            }\n\t            else {\n\t                if (i === 0 || i === len - 1) {\n\t                    cps.push(vec2.clone(points[i]));\n\t                    continue;\n\t                }\n\t                else {\n\t                    prevPoint = points[i - 1];\n\t                    nextPoint = points[i + 1];\n\t                }\n\t            }\n\t\n\t            vec2.sub(v, nextPoint, prevPoint);\n\t\n\t            // use degree to scale the handle length\n\t            v2Scale(v, v, smooth);\n\t\n\t            var d0 = v2Distance(point, prevPoint);\n\t            var d1 = v2Distance(point, nextPoint);\n\t            var sum = d0 + d1;\n\t            if (sum !== 0) {\n\t                d0 /= sum;\n\t                d1 /= sum;\n\t            }\n\t\n\t            v2Scale(v1, v, -d0);\n\t            v2Scale(v2, v, d1);\n\t            var cp0 = v2Add([], point, v1);\n\t            var cp1 = v2Add([], point, v2);\n\t            if (constraint) {\n\t                v2Max(cp0, cp0, min);\n\t                v2Min(cp0, cp0, max);\n\t                v2Max(cp1, cp1, min);\n\t                v2Min(cp1, cp1, max);\n\t            }\n\t            cps.push(cp0);\n\t            cps.push(cp1);\n\t        }\n\t\n\t        if (isLoop) {\n\t            cps.push(cps.shift());\n\t        }\n\t\n\t        return cps;\n\t    };\n\t\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/graphic/shape/Polyline\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(62);\n\t\n\t    module.exports = __webpack_require__(44).extend({\n\t        \n\t        type: 'polyline',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, false);\n\t        }\n\t    });\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Rect\n\t */\n\t\n\t\n\t    var roundRectHelper = __webpack_require__(67);\n\t\n\t    module.exports = __webpack_require__(44).extend({\n\t\n\t        type: 'rect',\n\t\n\t        shape: {\n\t            // r1r2r3r4\n\t            // r1          [1, 1, 1, 1]\n\t            // r[1]        [1, 1, 1, 1]\n\t            // r[1, 2]     [1, 2, 1, 2]\n\t            // r[1, 2, 3]  [1, 2, 3, 2]\n\t            r: 0,\n\t\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            if (!shape.r) {\n\t                ctx.rect(x, y, width, height);\n\t            }\n\t            else {\n\t                roundRectHelper.buildPath(ctx, shape);\n\t            }\n\t            ctx.closePath();\n\t            return;\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            var r = shape.r;\n\t            var r1;\n\t            var r2;\n\t            var r3;\n\t            var r4;\n\t\n\t            // Convert width and height to positive for better borderRadius\n\t            if (width < 0) {\n\t                x = x + width;\n\t                width = -width;\n\t            }\n\t            if (height < 0) {\n\t                y = y + height;\n\t                height = -height;\n\t            }\n\t\n\t            if (typeof r === 'number') {\n\t                r1 = r2 = r3 = r4 = r;\n\t            }\n\t            else if (r instanceof Array) {\n\t                if (r.length === 1) {\n\t                    r1 = r2 = r3 = r4 = r[0];\n\t                }\n\t                else if (r.length === 2) {\n\t                    r1 = r3 = r[0];\n\t                    r2 = r4 = r[1];\n\t                }\n\t                else if (r.length === 3) {\n\t                    r1 = r[0];\n\t                    r2 = r4 = r[1];\n\t                    r3 = r[2];\n\t                }\n\t                else {\n\t                    r1 = r[0];\n\t                    r2 = r[1];\n\t                    r3 = r[2];\n\t                    r4 = r[3];\n\t                }\n\t            }\n\t            else {\n\t                r1 = r2 = r3 = r4 = 0;\n\t            }\n\t\n\t            var total;\n\t            if (r1 + r2 > width) {\n\t                total = r1 + r2;\n\t                r1 *= width / total;\n\t                r2 *= width / total;\n\t            }\n\t            if (r3 + r4 > width) {\n\t                total = r3 + r4;\n\t                r3 *= width / total;\n\t                r4 *= width / total;\n\t            }\n\t            if (r2 + r3 > height) {\n\t                total = r2 + r3;\n\t                r2 *= height / total;\n\t                r3 *= height / total;\n\t            }\n\t            if (r1 + r4 > height) {\n\t                total = r1 + r4;\n\t                r1 *= height / total;\n\t                r4 *= height / total;\n\t            }\n\t            ctx.moveTo(x + r1, y);\n\t            ctx.lineTo(x + width - r2, y);\n\t            r2 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y, x + width, y + r2\n\t            );\n\t            ctx.lineTo(x + width, y + height - r3);\n\t            r3 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y + height, x + width - r3, y + height\n\t            );\n\t            ctx.lineTo(x + r4, y + height);\n\t            r4 !== 0 && ctx.quadraticCurveTo(\n\t                x, y + height, x, y + height - r4\n\t            );\n\t            ctx.lineTo(x, y + r1);\n\t            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Line\n\t */\n\t\n\t    module.exports = __webpack_require__(44).extend({\n\t\n\t        type: 'line',\n\t\n\t        shape: {\n\t            // Start point\n\t            x1: 0,\n\t            y1: 0,\n\t            // End point\n\t            x2: 0,\n\t            y2: 0,\n\t\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var percent = shape.percent;\n\t\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (percent < 1) {\n\t                x2 = x1 * (1 - percent) + x2 * percent;\n\t                y2 = y1 * (1 - percent) + y2 * percent;\n\t            }\n\t            ctx.lineTo(x2, y2);\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} percent\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (p) {\n\t            var shape = this.shape;\n\t            return [\n\t                shape.x1 * (1 - p) + shape.x2 * p,\n\t                shape.y1 * (1 - p) + shape.y2 * p\n\t            ];\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/shape/BezierCurve\n\t */\n\t\n\t\n\t    var curveTool = __webpack_require__(46);\n\t    var vec2 = __webpack_require__(15);\n\t    var quadraticSubdivide = curveTool.quadraticSubdivide;\n\t    var cubicSubdivide = curveTool.cubicSubdivide;\n\t    var quadraticAt = curveTool.quadraticAt;\n\t    var cubicAt = curveTool.cubicAt;\n\t    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n\t    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\t\n\t    var out = [];\n\t\n\t    function someVectorAt(shape, t, isTangent) {\n\t        var cpx2 = shape.cpx2;\n\t        var cpy2 = shape.cpy2;\n\t        if (cpx2 === null || cpy2 === null) {\n\t            return [\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n\t            ];\n\t        }\n\t        else {\n\t            return [\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n\t            ];\n\t        }\n\t    }\n\t    module.exports = __webpack_require__(44).extend({\n\t\n\t        type: 'bezier-curve',\n\t\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            cpx1: 0,\n\t            cpy1: 0,\n\t            // cpx2: 0,\n\t            // cpy2: 0\n\t\n\t            // Curve show percent, for animating\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var cpx1 = shape.cpx1;\n\t            var cpy1 = shape.cpy1;\n\t            var cpx2 = shape.cpx2;\n\t            var cpy2 = shape.cpy2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (cpx2 == null || cpy2 == null) {\n\t                if (percent < 1) {\n\t                    quadraticSubdivide(\n\t                        x1, cpx1, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    x2 = out[2];\n\t                    quadraticSubdivide(\n\t                        y1, cpy1, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    y2 = out[2];\n\t                }\n\t\n\t                ctx.quadraticCurveTo(\n\t                    cpx1, cpy1,\n\t                    x2, y2\n\t                );\n\t            }\n\t            else {\n\t                if (percent < 1) {\n\t                    cubicSubdivide(\n\t                        x1, cpx1, cpx2, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    cpx2 = out[2];\n\t                    x2 = out[3];\n\t                    cubicSubdivide(\n\t                        y1, cpy1, cpy2, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    cpy2 = out[2];\n\t                    y2 = out[3];\n\t                }\n\t                ctx.bezierCurveTo(\n\t                    cpx1, cpy1,\n\t                    cpx2, cpy2,\n\t                    x2, y2\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (t) {\n\t            return someVectorAt(this.shape, t, false);\n\t        },\n\t\n\t        /**\n\t         * Get tangent at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        tangentAt: function (t) {\n\t            var p = someVectorAt(this.shape, t, true);\n\t            return vec2.normalize(p, p);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Arc\n\t */\n\t \n\t\n\t    module.exports = __webpack_require__(44).extend({\n\t\n\t        type: 'arc',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        style: {\n\t\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t        }\n\t    });\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(6);\n\t\n\t    var Gradient = __webpack_require__(56);\n\t\n\t    /**\n\t     * x, y, x2, y2 are all percent from 0 to 1\n\t     * @param {number} [x=0]\n\t     * @param {number} [y=0]\n\t     * @param {number} [x2=1]\n\t     * @param {number} [y2=0]\n\t     * @param {Array.<Object>} colorStops\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t        this.x = x == null ? 0 : x;\n\t\n\t        this.y = y == null ? 0 : y;\n\t\n\t        this.x2 = x2 == null ? 1 : x2;\n\t\n\t        this.y2 = y2 == null ? 0 : y2;\n\t\n\t        // Can be cloned\n\t        this.type = 'linear';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    LinearGradient.prototype = {\n\t\n\t        constructor: LinearGradient\n\t    };\n\t\n\t    zrUtil.inherits(LinearGradient, Gradient);\n\t\n\t    module.exports = LinearGradient;\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(6);\n\t\n\t    var Gradient = __webpack_require__(56);\n\t\n\t    /**\n\t     * x, y, r are all percent from 0 to 1\n\t     * @param {number} [x=0.5]\n\t     * @param {number} [y=0.5]\n\t     * @param {number} [r=0.5]\n\t     * @param {Array.<Object>} [colorStops]\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t        this.x = x == null ? 0.5 : x;\n\t\n\t        this.y = y == null ? 0.5 : y;\n\t\n\t        this.r = r == null ? 0.5 : r;\n\t\n\t        // Can be cloned\n\t        this.type = 'radial';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    RadialGradient.prototype = {\n\t\n\t        constructor: RadialGradient\n\t    };\n\t\n\t    zrUtil.inherits(RadialGradient, Gradient);\n\t\n\t    module.exports = RadialGradient;\n\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * \r\n\t * @module fish-topo-bo/node/EventDecisionNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(40);\r\n\t    var graphic = __webpack_require__(42);\r\n\t\r\n\t    function EventDecisionNode(data, opts) {\r\n\t        /**\r\n\t         * BO\r\n\t         * @type {Object}\r\n\t         * @private\r\n\t         */\r\n\t        this._data = data;\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {startPos}\r\n\t         * @private\r\n\t         */\r\n\t        this._startPos = opts.startPos;\r\n\t\r\n\t        this._type = opts.type || 'boEvent';\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._clickable = opts.clickable || false;\r\n\t        this._popupOpts = opts.popupOpts;\r\n\t\r\n\t        /**\r\n\t         * Group\r\n\t         * @type zrender/graphic/Group\r\n\t         * @private\r\n\t         */\r\n\t        this._group = new graphic.Group();\r\n\t        this._group.name = this._data.id;\r\n\t\r\n\t        //BO\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t    var eventProto = EventDecisionNode.prototype;\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @returns {zrender/graphic/Group}\r\n\t     */\r\n\t    eventProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    eventProto._render = function () {\r\n\t        //\r\n\t        this._createEventShape();\r\n\t        //\r\n\t        this._createEVentName();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    eventProto._createEventShape = function () {\r\n\t\r\n\t        //\r\n\t        var height = Const.BO_EVENT_HEIGHT,\r\n\t            x = this._startPos.x + 1,\r\n\t            y = this._startPos.y,\r\n\t            width = this._type == 'boEvent' ? Const.BO_EVENT_WIDTH : Const.BO_ATTR_EVENT_WIDTH,\r\n\t\r\n\t            shape = new graphic.Polygon({\r\n\t                name: this._data.id,\r\n\t                shape: {\r\n\t                    points: [\r\n\t                        [x, y],\r\n\t                        [x + width - 10, y],\r\n\t                        [x + width, y + height / 2],\r\n\t                        [x + width - 10, y + height],\r\n\t                        [x, y + height]]\r\n\t                },\r\n\t\r\n\t                style: {\r\n\t                    fill: '#FFCCCC',\r\n\t                    stroke: '#000000',\r\n\t                    lineWidth: 0.75\r\n\t                }\r\n\t\r\n\t            });\r\n\t\r\n\t        if (this._clickable) {\r\n\t            shape.clickable = this._clickable;\r\n\t            shape._data = this._data;\r\n\t            shape._popupOpts = this._popupOpts;\r\n\t            shape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t\r\n\t        this._group.add(shape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    eventProto._click = function () {\r\n\t        var options = fish.extend(\r\n\t            {\r\n\t                viewOption: {\r\n\t                    DATA: this._data\r\n\t                },\r\n\t                width: 800,\r\n\t                height: 500\r\n\t            }, this._popupOpts);\r\n\t\r\n\t        fish.popupView(options);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    eventProto._createEVentName = function () {\r\n\t        var x = this._startPos.x + (this._type == 'boEvent' ? Const.BO_ATTR_PADDING_LEFT : 15),\r\n\t            y = this._startPos.y,\r\n\t\r\n\t            eventNameShape = new graphic.Text({\r\n\t                style: {\r\n\t                    text: this._data.name,\r\n\t                    textFont: Const.BO_EVENT_FONT,\r\n\t                    textAlign: 'left',  //\r\n\t                    textBaseline: 'top'\r\n\t                },\r\n\t\r\n\t                position: [x, y]\r\n\t            });\r\n\t\r\n\t        if (this._clickable) {\r\n\t            eventNameShape.clickable = this._clickable;\r\n\t            eventNameShape._data = this._data;\r\n\t            eventNameShape._popupOpts = this._popupOpts;\r\n\t            eventNameShape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t        this._group.add(eventNameShape);\r\n\t    };\r\n\t\r\n\t    module.exports = EventDecisionNode;\r\n\t\r\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO\r\n\t * @module fish-topo-bo/node/LineNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t\r\n\t    var Const = __webpack_require__(40);\r\n\t    var graphic = __webpack_require__(42);\r\n\t    var util = __webpack_require__(6);\r\n\t    /**\r\n\t     * BO\r\n\t     * @param {{x: *, y: *}} startPos, \r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @constructor\r\n\t     */\r\n\t    function BoLine(startPos) {\r\n\t\r\n\t        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y};\r\n\t\r\n\t        return _line(startPos, endPos);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @param {{x: *, y: *}} startPos, \r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @constructor\r\n\t     */\r\n\t    function AttrLine(startPos) {\r\n\t\r\n\t        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y},\r\n\t            style = {lineDash: [Const.LINE_DASH]};\r\n\t\r\n\t        return _line(startPos, endPos, style);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * BOBO\r\n\t     * @param {{x: *, y: *}} startPos, \r\n\t     * @param {int} attrHeight, \r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @constructor\r\n\t     */\r\n\t    function AttrEventLine(startPos, attrHeight) {\r\n\t        var endPos = {x: startPos.x, y: startPos.y + attrHeight},\r\n\t            style = {lineDash: [Const.LINE_DASH]};\r\n\t\r\n\t        return _line(startPos, endPos, style);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @param {{x: *, y: *}} startPos, \r\n\t     * @param {{x: *, y: *}} endPos, \r\n\t     * @param {Object} style, ,\r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @private\r\n\t     */\r\n\t    function _line(startPos, endPos, style) {\r\n\t\r\n\t        var _style = {\r\n\t            strokeColor: '#000000',\r\n\t            lineWidth: 0.5,\r\n\t            percent: 1\r\n\t        };\r\n\t\r\n\t        util.extend(_style, style);\r\n\t\r\n\t        var shape = new graphic.Line({\r\n\t            shape: {\r\n\t                // Start point\r\n\t                x1: startPos.x,\r\n\t                y1: startPos.y,\r\n\t\r\n\t                // End point\r\n\t                x2: endPos.x,\r\n\t                y2: endPos.y,\r\n\t\r\n\t                percent: 1\r\n\t            },\r\n\t\r\n\t            style: _style\r\n\t        });\r\n\t\r\n\t        return shape;\r\n\t    }\r\n\t\r\n\t\r\n\t    module.exports = {\r\n\t        BoLine: BoLine,\r\n\t        AttrLine: AttrLine,\r\n\t        AttrEventLine: AttrEventLine\r\n\t    };\r\n\t\r\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO\r\n\t * 1.BO\r\n\t * 2.BO\r\n\t * 3.BO\r\n\t * @module fish-topo-bo/node/BoAttrNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(40);\r\n\t    var EventDecision = __webpack_require__(73);\r\n\t    var graphic = __webpack_require__(42);\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param {{\r\n\t     *          id: String bo,\r\n\t     *          code: String bo\r\n\t     *          keyValue: boolean ,\r\n\t     *          dataType: String ,\r\n\t     *          boAttrEventArr:[] \r\n\t     *          }} boAttrData BO,\r\n\t     * @param {{\r\n\t     *          startPos: {x: number, y: number},\r\n\t     *          displayDataType: boolean ,\r\n\t     *          displayEventDecision: boolean ,\r\n\t     *          eventClickable: boolean BO,  false,\r\n\t     *          eventPopupOpts: Object BOurl,width,height,\r\n\t     *          }} opts\r\n\t     * @constructor\r\n\t     */\r\n\t    function BoAttr(boAttrData, opts) {\r\n\t        /**\r\n\t         * BO\r\n\t         * @type {Object}\r\n\t         * @private\r\n\t         */\r\n\t        this._data = boAttrData;\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._keyValue = boAttrData.keyValue || false;\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {startPos}\r\n\t         * @private\r\n\t         */\r\n\t        this._startPos = opts.startPos;\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayDataType = opts.displayDataType || false;\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayEventDecision = opts.displayEventDecision || false;\r\n\t\r\n\t        /**\r\n\t         * \r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._eventClickable = opts.eventClickable || false;\r\n\t        this._eventPopupOpts = opts.eventPopupOpts;\r\n\t\r\n\t        /**\r\n\t         * Group\r\n\t         * @type zrender/graphic/Group\r\n\t         * @private\r\n\t         */\r\n\t        this._group = new graphic.Group();\r\n\t        this._group.name = this._data.id;\r\n\t\r\n\t        //BO\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t    var boAttrProto = BoAttr.prototype;\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @returns {zrender/graphic/Group}\r\n\t     */\r\n\t    boAttrProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * BO\r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._render = function () {\r\n\t        //\r\n\t        this._createText();\r\n\t\r\n\t        //\r\n\t        this._createDataType();\r\n\t\r\n\t        //\r\n\t        this._createEventDecision();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._createText = function () {\r\n\t\r\n\t        var x = this._startPos.x + Const.BO_ATTR_PADDING_LEFT,\r\n\t            y = this._startPos.y,\r\n\t\r\n\t            attrNameShape = new graphic.Text({\r\n\t                style: {\r\n\t                    text: this._data.name,\r\n\t                    textFont: Const.BO_ATTR_FONT,\r\n\t                    textAlign: 'left',  //\r\n\t                    textBaseline: 'top',\r\n\t                    //lineWidth: 1,\r\n\t                    fill: this._keyValue ? 'red' : 'black'\r\n\t                },\r\n\t\r\n\t                position: [x, y]\r\n\t            });\r\n\t\r\n\t        // =  + padding-top + padding-bottom\r\n\t        attrNameShape.getBoundingRect().height += Const.BO_ATTR_PADDING_TOP + Const.BO_ATTR_PADDING_BOTTOM;\r\n\t        // = BORelation\r\n\t        attrNameShape.getBoundingRect().width = Const.BO_NODE_WIDTH;\r\n\t\r\n\t        //B = \r\n\t        attrNameShape.getBoundingRect().x += -Const.BO_ATTR_PADDING_LEFT;\r\n\t        //attrNameShape.getBoundingRect().y = + attrNameShape.position[1];\r\n\t\r\n\t        this._group.add(attrNameShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._createDataType = function () {\r\n\t        if (!this._displayDataType) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var x = this._startPos.x + Const.BO_NODE_WIDTH - 10,\r\n\t            y = this._startPos.y,\r\n\t            textAlign = 'right';\r\n\t\r\n\t        //\r\n\t        if (this._displayEventDecision) {\r\n\t            textAlign = 'left';\r\n\t            x = this._startPos.x + Const.BO_NODE_WIDTH / 3;\r\n\t        }\r\n\t\r\n\t        var _dataTypeShape = new graphic.Text({\r\n\t            style: {\r\n\t                text: this._data.dataType || '',\r\n\t                textFont: Const.BO_ATTR_FONT,\r\n\t                textAlign: textAlign,  //\r\n\t                textBaseline: 'top',\r\n\t                lineWidth: 1\r\n\t            },\r\n\t\r\n\t            position: [x, y]\r\n\t        });\r\n\t\r\n\t        this._group.add(_dataTypeShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._createEventDecision = function () {\r\n\t        if (!this._displayEventDecision) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var _boAttrEventArr = this._data.boAttrEventArr || [],\r\n\t            _boAttrEventLen = _boAttrEventArr.length,\r\n\t            padding = (_boAttrEventLen > 1) ? 10 : 0,\r\n\t            _startPos = {\r\n\t                x: this._startPos.x + Const.BO_NODE_WIDTH / 2 + Const.BO_ATTR_EVENT_WIDTH * (_boAttrEventLen - 1) - padding,\r\n\t                y: this._startPos.y\r\n\t            };\r\n\t\r\n\t        //\r\n\t        for (var i = _boAttrEventLen - 1; i >= 0; i--) {\r\n\t            this._group.add(new EventDecision(_boAttrEventArr[i], {\r\n\t                startPos: _startPos,\r\n\t                type: 'boAttrEvent',\r\n\t                clickable: this._eventClickable,\r\n\t                popupOpts: this._eventPopupOpts\r\n\t            }).getShape());\r\n\t            _startPos = {x: _startPos.x - Const.BO_ATTR_EVENT_WIDTH + 10, y: _startPos.y};\r\n\t        }\r\n\t        /*_startPos = {\r\n\t         x: this._startPos.x + Const.BO_NODE_WIDTH / 2,\r\n\t         y: this._startPos.y};\r\n\t\r\n\t         for (var i = 0; i < _boAttrEventLen; i++) {\r\n\t         this._group.add(event.BoAttrEvent(_boAttrEventArr[i], _startPos, i + 2));\r\n\t         _startPos = {x: _startPos.x + Const.BO_ATTR_EVENT_WIDTH - 5, y: _startPos.y};\r\n\t         }*/\r\n\t\r\n\t\r\n\t    };\r\n\t\r\n\t    module.exports = BoAttr;\r\n\t\r\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * \r\n\t * \r\n\t * @module fish-topo-bo/node/Relation\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(40);\r\n\t    var graphic = __webpack_require__(42);\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param sourceShape, \r\n\t     * @param targetShape, \r\n\t     * @param {String} sourceText, ,\r\n\t     * @param {String} targetText, ,\r\n\t     * @constructor\r\n\t     */\r\n\t    function Relation(sourceShape, targetShape, sourceText, targetText) {\r\n\t        this._sourceText = sourceText;\r\n\t        this._targetText = targetText;\r\n\t\r\n\t        this._group = new graphic.Group();\r\n\t\r\n\t        //\r\n\t        this._lStartPos = {\r\n\t            x: sourceShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //\r\n\t        this._lEndPos = {\r\n\t            x: targetShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //\r\n\t        this._rStartPos = {\r\n\t            x: sourceShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //\r\n\t        this._rEndPos = {\r\n\t            x: targetShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //\r\n\t        this._leftDirection = this._lStartPos.x - this._lEndPos.x <= 0;\r\n\t\r\n\t        //\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t    var relationProto = Relation.prototype;\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @returns {*}\r\n\t     */\r\n\t    relationProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    relationProto._render = function () {\r\n\t        //\r\n\t        this._createLine();\r\n\t\r\n\t        //\r\n\t        this._createArrow();\r\n\t\r\n\t        //\r\n\t        this._createText();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createLine = function () {\r\n\t        var _linePoints = [];\r\n\t\r\n\t        if (this._leftDirection) {\r\n\t            //\r\n\t            _linePoints.push([this._lStartPos.x, this._lStartPos.y]);\r\n\t            //\r\n\t            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lStartPos.y]);\r\n\t            //\r\n\t            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lEndPos.y]);\r\n\t            //\r\n\t            _linePoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n\t        }\r\n\t        else {\r\n\t            //\r\n\t            _linePoints.push([this._rStartPos.x, this._rStartPos.y]);\r\n\t            //\r\n\t            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._lStartPos.y]);\r\n\t            //\r\n\t            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._rEndPos.y]);\r\n\t            //\r\n\t            _linePoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n\t        }\r\n\t\r\n\t        var _lineShape = new graphic.Polyline({\r\n\t            shape: {\r\n\t                points: _linePoints\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                //fill: 'blue',\r\n\t                stroke: 'blue'\r\n\t            }\r\n\t        });\r\n\t\r\n\t        this._group.add(_lineShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createArrow = function () {\r\n\t        var _arrowPoints = [];\r\n\t\r\n\t        if (this._leftDirection) {\r\n\t            //\r\n\t            _arrowPoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n\t            //\r\n\t            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n\t            //\r\n\t            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n\t        }\r\n\t        else {\r\n\t            //\r\n\t            _arrowPoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n\t            //\r\n\t            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n\t            //\r\n\t            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n\t        }\r\n\t\r\n\t        var _arrowShape = new graphic.Polyline({\r\n\t            shape: {\r\n\t                points: _arrowPoints\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                fill: 'blue',\r\n\t                stroke: 'blue'\r\n\t            }\r\n\t        });\r\n\t\r\n\t        this._group.add(_arrowShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createText = function () {\r\n\t        var _sourceTextPos,\r\n\t            _targetTextPos,\r\n\t            _textAlign;\r\n\t\r\n\t        if (this._leftDirection) {\r\n\t            _sourceTextPos = [this._lStartPos.x - 10, this._lStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _targetTextPos = [this._lEndPos.x - 10 - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _textAlign = 'right';\r\n\t        }\r\n\t        else {\r\n\t            _sourceTextPos = [this._rStartPos.x + 10, this._rStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _targetTextPos = [this._rEndPos.x + 10 + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _textAlign = 'left';\r\n\t        }\r\n\t\r\n\t        //\r\n\t        if (this._sourceText) {\r\n\t            var _srcTextShape = new graphic.Text({\r\n\t                position: _sourceTextPos,\r\n\t\r\n\t                style: {\r\n\t                    text: this._sourceText,\r\n\t                    textFont: Const.BO_ATTR_FONT,\r\n\t                    textAlign: _textAlign,\r\n\t                    textBaseline: 'buttom',\r\n\t                    lineWidth: 1\r\n\t                }\r\n\t            });\r\n\t            this._group.add(_srcTextShape);\r\n\t        }\r\n\t\r\n\t        //\r\n\t        if (this._targetText) {\r\n\t            var _targetTextShape = new graphic.Text({\r\n\t                position: _targetTextPos,\r\n\t\r\n\t                style: {\r\n\t                    text: this._targetText,\r\n\t                    textFont: Const.BO_ATTR_FONT,\r\n\t                    textAlign: _textAlign,\r\n\t                    textBaseline: 'buttom',\r\n\t                    lineWidth: 1\r\n\t                }\r\n\t            });\r\n\t            this._group.add(_targetTextShape);\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    module.exports = Relation;\r\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    __webpack_require__(78);\n\t    __webpack_require__(3).registerPainter('vml', __webpack_require__(80));\n\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// http://www.w3.org/TR/NOTE-VML\n\t// TODO Use proxy like svg instead of overwrite brush methods\n\t\n\t\n\tif (!__webpack_require__(5).canvasSupported) {\n\t    var vec2 = __webpack_require__(15);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var CMD = __webpack_require__(45).CMD;\n\t    var colorTool = __webpack_require__(20);\n\t    var textContain = __webpack_require__(38);\n\t    var RectText = __webpack_require__(37);\n\t    var Displayable = __webpack_require__(36);\n\t    var ZImage = __webpack_require__(35);\n\t    var Text = __webpack_require__(57);\n\t    var Path = __webpack_require__(44);\n\t\n\t    var Gradient = __webpack_require__(56);\n\t\n\t    var vmlCore = __webpack_require__(79);\n\t\n\t    var round = Math.round;\n\t    var sqrt = Math.sqrt;\n\t    var abs = Math.abs;\n\t    var cos = Math.cos;\n\t    var sin = Math.sin;\n\t    var mathMax = Math.max;\n\t\n\t    var applyTransform = vec2.applyTransform;\n\t\n\t    var comma = ',';\n\t    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\t\n\t    var Z = 21600;\n\t    var Z2 = Z / 2;\n\t\n\t    var ZLEVEL_BASE = 100000;\n\t    var Z_BASE = 1000;\n\t\n\t    var initRootElStyle = function (el) {\n\t        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n\t        el.coordsize = Z + ','  + Z;\n\t        el.coordorigin = '0,0';\n\t    };\n\t\n\t    var encodeHtmlAttribute = function (s) {\n\t        return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n\t    };\n\t\n\t    var rgb2Str = function (r, g, b) {\n\t        return 'rgb(' + [r, g, b].join(',') + ')';\n\t    };\n\t\n\t    var append = function (parent, child) {\n\t        if (child && parent && child.parentNode !== parent) {\n\t            parent.appendChild(child);\n\t        }\n\t    };\n\t\n\t    var remove = function (parent, child) {\n\t        if (child && parent && child.parentNode === parent) {\n\t            parent.removeChild(child);\n\t        }\n\t    };\n\t\n\t    var getZIndex = function (zlevel, z, z2) {\n\t        // z  [0, 1000]\n\t        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n\t    };\n\t\n\t    var parsePercent = function (value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    };\n\t\n\t    /***************************************************\n\t     * PATH\n\t     **************************************************/\n\t\n\t    var setColorAndOpacity = function (el, color, opacity) {\n\t        var colorArr = colorTool.parse(color);\n\t        opacity = +opacity;\n\t        if (isNaN(opacity)) {\n\t            opacity = 1;\n\t        }\n\t        if (colorArr) {\n\t            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n\t            el.opacity = opacity * colorArr[3];\n\t        }\n\t    };\n\t\n\t    var getColorAndAlpha = function (color) {\n\t        var colorArr = colorTool.parse(color);\n\t        return [\n\t            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),\n\t            colorArr[3]\n\t        ];\n\t    };\n\t\n\t    var updateFillNode = function (el, style, zrEl) {\n\t        // TODO pattern\n\t        var fill = style.fill;\n\t        if (fill != null) {\n\t            // Modified from excanvas\n\t            if (fill instanceof Gradient) {\n\t                var gradientType;\n\t                var angle = 0;\n\t                var focus = [0, 0];\n\t                // additional offset\n\t                var shift = 0;\n\t                // scale factor for offset\n\t                var expansion = 1;\n\t                var rect = zrEl.getBoundingRect();\n\t                var rectWidth = rect.width;\n\t                var rectHeight = rect.height;\n\t                if (fill.type === 'linear') {\n\t                    gradientType = 'gradient';\n\t                    var transform = zrEl.transform;\n\t                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\t                    if (transform) {\n\t                        applyTransform(p0, p0, transform);\n\t                        applyTransform(p1, p1, transform);\n\t                    }\n\t                    var dx = p1[0] - p0[0];\n\t                    var dy = p1[1] - p0[1];\n\t                    angle = Math.atan2(dx, dy) * 180 / Math.PI;\n\t                    // The angle should be a non-negative number.\n\t                    if (angle < 0) {\n\t                        angle += 360;\n\t                    }\n\t\n\t                    // Very small angles produce an unexpected result because they are\n\t                    // converted to a scientific notation string.\n\t                    if (angle < 1e-6) {\n\t                        angle = 0;\n\t                    }\n\t                }\n\t                else {\n\t                    gradientType = 'gradientradial';\n\t                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t                    var transform = zrEl.transform;\n\t                    var scale = zrEl.scale;\n\t                    var width = rectWidth;\n\t                    var height = rectHeight;\n\t                    focus = [\n\t                        // Percent in bounding rect\n\t                        (p0[0] - rect.x) / width,\n\t                        (p0[1] - rect.y) / height\n\t                    ];\n\t                    if (transform) {\n\t                        applyTransform(p0, p0, transform);\n\t                    }\n\t\n\t                    width /= scale[0] * Z;\n\t                    height /= scale[1] * Z;\n\t                    var dimension = mathMax(width, height);\n\t                    shift = 2 * 0 / dimension;\n\t                    expansion = 2 * fill.r / dimension - shift;\n\t                }\n\t\n\t                // We need to sort the color stops in ascending order by offset,\n\t                // otherwise IE won't interpret it correctly.\n\t                var stops = fill.colorStops.slice();\n\t                stops.sort(function(cs1, cs2) {\n\t                    return cs1.offset - cs2.offset;\n\t                });\n\t\n\t                var length = stops.length;\n\t                // Color and alpha list of first and last stop\n\t                var colorAndAlphaList = [];\n\t                var colors = [];\n\t                for (var i = 0; i < length; i++) {\n\t                    var stop = stops[i];\n\t                    var colorAndAlpha = getColorAndAlpha(stop.color);\n\t                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\t                    if (i === 0 || i === length - 1) {\n\t                        colorAndAlphaList.push(colorAndAlpha);\n\t                    }\n\t                }\n\t\n\t                if (length >= 2) {\n\t                    var color1 = colorAndAlphaList[0][0];\n\t                    var color2 = colorAndAlphaList[1][0];\n\t                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n\t                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\t\n\t                    el.type = gradientType;\n\t                    el.method = 'none';\n\t                    el.focus = '100%';\n\t                    el.angle = angle;\n\t                    el.color = color1;\n\t                    el.color2 = color2;\n\t                    el.colors = colors.join(',');\n\t                    // When colors attribute is used, the meanings of opacity and o:opacity2\n\t                    // are reversed.\n\t                    el.opacity = opacity2;\n\t                    // FIXME g_o_:opacity ?\n\t                    el.opacity2 = opacity1;\n\t                }\n\t                if (gradientType === 'radial') {\n\t                    el.focusposition = focus.join(',');\n\t                }\n\t            }\n\t            else {\n\t                // FIXME Change from Gradient fill to color fill\n\t                setColorAndOpacity(el, fill, style.opacity);\n\t            }\n\t        }\n\t    };\n\t\n\t    var updateStrokeNode = function (el, style) {\n\t        // if (style.lineJoin != null) {\n\t        //     el.joinstyle = style.lineJoin;\n\t        // }\n\t        // if (style.miterLimit != null) {\n\t        //     el.miterlimit = style.miterLimit * Z;\n\t        // }\n\t        // if (style.lineCap != null) {\n\t        //     el.endcap = style.lineCap;\n\t        // }\n\t        if (style.lineDash != null) {\n\t            el.dashstyle = style.lineDash.join(' ');\n\t        }\n\t        if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n\t            setColorAndOpacity(el, style.stroke, style.opacity);\n\t        }\n\t    };\n\t\n\t    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n\t        var isFill = type == 'fill';\n\t        var el = vmlEl.getElementsByTagName(type)[0];\n\t        // Stroke must have lineWidth\n\t        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {\n\t            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';\n\t            // FIXME Remove before updating, or set `colors` will throw error\n\t            if (style[type] instanceof Gradient) {\n\t                remove(vmlEl, el);\n\t            }\n\t            if (!el) {\n\t                el = vmlCore.createNode(type);\n\t            }\n\t\n\t            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n\t            append(vmlEl, el);\n\t        }\n\t        else {\n\t            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n\t            remove(vmlEl, el);\n\t        }\n\t    };\n\t\n\t    var points = [[], [], []];\n\t    var pathDataToString = function (data, m) {\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t\n\t        var str = [];\n\t        var nPoint;\n\t        var cmdStr;\n\t        var cmd;\n\t        var i;\n\t        var xi;\n\t        var yi;\n\t        for (i = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            cmdStr = '';\n\t            nPoint = 0;\n\t            switch (cmd) {\n\t                case M:\n\t                    cmdStr = ' m ';\n\t                    nPoint = 1;\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    points[0][0] = xi;\n\t                    points[0][1] = yi;\n\t                    break;\n\t                case L:\n\t                    cmdStr = ' l ';\n\t                    nPoint = 1;\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    points[0][0] = xi;\n\t                    points[0][1] = yi;\n\t                    break;\n\t                case Q:\n\t                case C:\n\t                    cmdStr = ' c ';\n\t                    nPoint = 3;\n\t                    var x1 = data[i++];\n\t                    var y1 = data[i++];\n\t                    var x2 = data[i++];\n\t                    var y2 = data[i++];\n\t                    var x3;\n\t                    var y3;\n\t                    if (cmd === Q) {\n\t                        // Convert quadratic to cubic using degree elevation\n\t                        x3 = x2;\n\t                        y3 = y2;\n\t                        x2 = (x2 + 2 * x1) / 3;\n\t                        y2 = (y2 + 2 * y1) / 3;\n\t                        x1 = (xi + 2 * x1) / 3;\n\t                        y1 = (yi + 2 * y1) / 3;\n\t                    }\n\t                    else {\n\t                        x3 = data[i++];\n\t                        y3 = data[i++];\n\t                    }\n\t                    points[0][0] = x1;\n\t                    points[0][1] = y1;\n\t                    points[1][0] = x2;\n\t                    points[1][1] = y2;\n\t                    points[2][0] = x3;\n\t                    points[2][1] = y3;\n\t\n\t                    xi = x3;\n\t                    yi = y3;\n\t                    break;\n\t                case A:\n\t                    var x = 0;\n\t                    var y = 0;\n\t                    var sx = 1;\n\t                    var sy = 1;\n\t                    var angle = 0;\n\t                    if (m) {\n\t                        // Extract SRT from matrix\n\t                        x = m[4];\n\t                        y = m[5];\n\t                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t                        angle = Math.atan2(-m[1] / sy, m[0] / sx);\n\t                    }\n\t\n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var startAngle = data[i++] + angle;\n\t                    var endAngle = data[i++] + startAngle + angle;\n\t                    // FIXME\n\t                    // var psi = data[i++];\n\t                    i++;\n\t                    var clockwise = data[i++];\n\t\n\t                    var x0 = cx + cos(startAngle) * rx;\n\t                    var y0 = cy + sin(startAngle) * ry;\n\t\n\t                    var x1 = cx + cos(endAngle) * rx;\n\t                    var y1 = cy + sin(endAngle) * ry;\n\t\n\t                    var type = clockwise ? ' wa ' : ' at ';\n\t                    if (Math.abs(x0 - x1) < 1e-4) {\n\t                        // IE won't render arches drawn counter clockwise if x0 == x1.\n\t                        if (Math.abs(endAngle - startAngle) > 1e-2) {\n\t                            // Offset x0 by 1/80 of a pixel. Use something\n\t                            // that can be represented in binary\n\t                            if (clockwise) {\n\t                                x0 += 270 / Z;\n\t                            }\n\t                        }\n\t                        else {\n\t                            // Avoid case draw full circle\n\t                            if (Math.abs(y0 - cy) < 1e-4) {\n\t                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {\n\t                                    y1 -= 270 / Z;\n\t                                }\n\t                                else {\n\t                                    y1 += 270 / Z;\n\t                                }\n\t                            }\n\t                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {\n\t                                x1 += 270 / Z;\n\t                            }\n\t                            else {\n\t                                x1 -= 270 / Z;\n\t                            }\n\t                        }\n\t                    }\n\t                    str.push(\n\t                        type,\n\t                        round(((cx - rx) * sx + x) * Z - Z2), comma,\n\t                        round(((cy - ry) * sy + y) * Z - Z2), comma,\n\t                        round(((cx + rx) * sx + x) * Z - Z2), comma,\n\t                        round(((cy + ry) * sy + y) * Z - Z2), comma,\n\t                        round((x0 * sx + x) * Z - Z2), comma,\n\t                        round((y0 * sy + y) * Z - Z2), comma,\n\t                        round((x1 * sx + x) * Z - Z2), comma,\n\t                        round((y1 * sy + y) * Z - Z2)\n\t                    );\n\t\n\t                    xi = x1;\n\t                    yi = y1;\n\t                    break;\n\t                case CMD.R:\n\t                    var p0 = points[0];\n\t                    var p1 = points[1];\n\t                    // x0, y0\n\t                    p0[0] = data[i++];\n\t                    p0[1] = data[i++];\n\t                    // x1, y1\n\t                    p1[0] = p0[0] + data[i++];\n\t                    p1[1] = p0[1] + data[i++];\n\t\n\t                    if (m) {\n\t                        applyTransform(p0, p0, m);\n\t                        applyTransform(p1, p1, m);\n\t                    }\n\t\n\t                    p0[0] = round(p0[0] * Z - Z2);\n\t                    p1[0] = round(p1[0] * Z - Z2);\n\t                    p0[1] = round(p0[1] * Z - Z2);\n\t                    p1[1] = round(p1[1] * Z - Z2);\n\t                    str.push(\n\t                        // x0, y0\n\t                        ' m ', p0[0], comma, p0[1],\n\t                        // x1, y0\n\t                        ' l ', p1[0], comma, p0[1],\n\t                        // x1, y1\n\t                        ' l ', p1[0], comma, p1[1],\n\t                        // x0, y1\n\t                        ' l ', p0[0], comma, p1[1]\n\t                    );\n\t                    break;\n\t                case CMD.Z:\n\t                    // FIXME Update xi, yi\n\t                    str.push(' x ');\n\t            }\n\t\n\t            if (nPoint > 0) {\n\t                str.push(cmdStr);\n\t                for (var k = 0; k < nPoint; k++) {\n\t                    var p = points[k];\n\t\n\t                    m && applyTransform(p, p, m);\n\t                    //  round \n\t                    str.push(\n\t                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),\n\t                        k < nPoint - 1 ? comma : ''\n\t                    );\n\t                }\n\t            }\n\t        }\n\t\n\t        return str.join('');\n\t    };\n\t\n\t    // Rewrite the original path method\n\t    Path.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t\n\t        var vmlEl = this._vmlEl;\n\t        if (!vmlEl) {\n\t            vmlEl = vmlCore.createNode('shape');\n\t            initRootElStyle(vmlEl);\n\t\n\t            this._vmlEl = vmlEl;\n\t        }\n\t\n\t        updateFillAndStroke(vmlEl, 'fill', style, this);\n\t        updateFillAndStroke(vmlEl, 'stroke', style, this);\n\t\n\t        var m = this.transform;\n\t        var needTransform = m != null;\n\t        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\t        if (strokeEl) {\n\t            var lineWidth = style.lineWidth;\n\t            // Get the line scale.\n\t            // Determinant of this.m_ means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            if (needTransform && !style.strokeNoScale) {\n\t                var det = m[0] * m[3] - m[1] * m[2];\n\t                lineWidth *= sqrt(abs(det));\n\t            }\n\t            strokeEl.weight = lineWidth + 'px';\n\t        }\n\t\n\t        var path = this.path;\n\t        if (this.__dirtyPath) {\n\t            path.beginPath();\n\t            this.buildPath(path, this.shape);\n\t            path.toStatic();\n\t            this.__dirtyPath = false;\n\t        }\n\t\n\t        vmlEl.path = pathDataToString(path.data, this.transform);\n\t\n\t        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Append to root\n\t        append(vmlRoot, vmlEl);\n\t\n\t        // Text\n\t        if (style.text != null) {\n\t            this.drawRectText(vmlRoot, this.getBoundingRect());\n\t        }\n\t        else {\n\t            this.removeRectText(vmlRoot);\n\t        }\n\t    };\n\t\n\t    Path.prototype.onRemove = function (vmlRoot) {\n\t        remove(vmlRoot, this._vmlEl);\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    Path.prototype.onAdd = function (vmlRoot) {\n\t        append(vmlRoot, this._vmlEl);\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t\n\t    /***************************************************\n\t     * IMAGE\n\t     **************************************************/\n\t    var isImage = function (img) {\n\t        // FIXME img instanceof Image  img IE8 \n\t        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';\n\t        // return img instanceof Image;\n\t    };\n\t\n\t    // Rewrite the original path method\n\t    ZImage.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t        var image = style.image;\n\t\n\t        // Image original width, height\n\t        var ow;\n\t        var oh;\n\t\n\t        if (isImage(image)) {\n\t            var src = image.src;\n\t            if (src === this._imageSrc) {\n\t                ow = this._imageWidth;\n\t                oh = this._imageHeight;\n\t            }\n\t            else {\n\t                var imageRuntimeStyle = image.runtimeStyle;\n\t                var oldRuntimeWidth = imageRuntimeStyle.width;\n\t                var oldRuntimeHeight = imageRuntimeStyle.height;\n\t                imageRuntimeStyle.width = 'auto';\n\t                imageRuntimeStyle.height = 'auto';\n\t\n\t                // get the original size\n\t                ow = image.width;\n\t                oh = image.height;\n\t\n\t                // and remove overides\n\t                imageRuntimeStyle.width = oldRuntimeWidth;\n\t                imageRuntimeStyle.height = oldRuntimeHeight;\n\t\n\t                // Caching image original width, height and src\n\t                this._imageSrc = src;\n\t                this._imageWidth = ow;\n\t                this._imageHeight = oh;\n\t            }\n\t            image = src;\n\t        }\n\t        else {\n\t            if (image === this._imageSrc) {\n\t                ow = this._imageWidth;\n\t                oh = this._imageHeight;\n\t            }\n\t        }\n\t        if (!image) {\n\t            return;\n\t        }\n\t\n\t        var x = style.x || 0;\n\t        var y = style.y || 0;\n\t\n\t        var dw = style.width;\n\t        var dh = style.height;\n\t\n\t        var sw = style.sWidth;\n\t        var sh = style.sHeight;\n\t        var sx = style.sx || 0;\n\t        var sy = style.sy || 0;\n\t\n\t        var hasCrop = sw && sh;\n\t\n\t        var vmlEl = this._vmlEl;\n\t        if (!vmlEl) {\n\t            // FIXME  group  left, top  0 \n\t            // vmlEl = vmlCore.createNode('group');\n\t            vmlEl = vmlCore.doc.createElement('div');\n\t            initRootElStyle(vmlEl);\n\t\n\t            this._vmlEl = vmlEl;\n\t        }\n\t\n\t        var vmlElStyle = vmlEl.style;\n\t        var hasRotation = false;\n\t        var m;\n\t        var scaleX = 1;\n\t        var scaleY = 1;\n\t        if (this.transform) {\n\t            m = this.transform;\n\t            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t\n\t            hasRotation = m[1] || m[2];\n\t        }\n\t        if (hasRotation) {\n\t            // If filters are necessary (rotation exists), create them\n\t            // filters are bog-slow, so only create them if abbsolutely necessary\n\t            // The following check doesn't account for skews (which don't exist\n\t            // in the canvas spec (yet) anyway.\n\t            // From excanvas\n\t            var p0 = [x, y];\n\t            var p1 = [x + dw, y];\n\t            var p2 = [x, y + dh];\n\t            var p3 = [x + dw, y + dh];\n\t            applyTransform(p0, p0, m);\n\t            applyTransform(p1, p1, m);\n\t            applyTransform(p2, p2, m);\n\t            applyTransform(p3, p3, m);\n\t\n\t            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n\t            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\t\n\t            var transformFilter = [];\n\t            transformFilter.push('M11=', m[0] / scaleX, comma,\n\t                        'M12=', m[2] / scaleY, comma,\n\t                        'M21=', m[1] / scaleX, comma,\n\t                        'M22=', m[3] / scaleY, comma,\n\t                        'Dx=', round(x * scaleX + m[4]), comma,\n\t                        'Dy=', round(y * scaleY + m[5]));\n\t\n\t            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';\n\t            // FIXME DXImageTransform  IE11 \n\t            vmlElStyle.filter = imageTransformPrefix + '.Matrix('\n\t                + transformFilter.join('') + ', SizingMethod=clip)';\n\t\n\t        }\n\t        else {\n\t            if (m) {\n\t                x = x * scaleX + m[4];\n\t                y = y * scaleY + m[5];\n\t            }\n\t            vmlElStyle.filter = '';\n\t            vmlElStyle.left = round(x) + 'px';\n\t            vmlElStyle.top = round(y) + 'px';\n\t        }\n\t\n\t        var imageEl = this._imageEl;\n\t        var cropEl = this._cropEl;\n\t\n\t        if (!imageEl) {\n\t            imageEl = vmlCore.doc.createElement('div');\n\t            this._imageEl = imageEl;\n\t        }\n\t        var imageELStyle = imageEl.style;\n\t        if (hasCrop) {\n\t            // Needs know image original width and height\n\t            if (! (ow && oh)) {\n\t                var tmpImage = new Image();\n\t                var self = this;\n\t                tmpImage.onload = function () {\n\t                    tmpImage.onload = null;\n\t                    ow = tmpImage.width;\n\t                    oh = tmpImage.height;\n\t                    // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\t                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\t\n\t                    // Caching image original width, height and src\n\t                    self._imageWidth = ow;\n\t                    self._imageHeight = oh;\n\t                    self._imageSrc = image;\n\t                };\n\t                tmpImage.src = image;\n\t            }\n\t            else {\n\t                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\t            }\n\t\n\t            if (! cropEl) {\n\t                cropEl = vmlCore.doc.createElement('div');\n\t                cropEl.style.overflow = 'hidden';\n\t                this._cropEl = cropEl;\n\t            }\n\t            var cropElStyle = cropEl.style;\n\t            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n\t            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n\t            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='\n\t                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';\n\t\n\t            if (! cropEl.parentNode) {\n\t                vmlEl.appendChild(cropEl);\n\t            }\n\t            if (imageEl.parentNode != cropEl) {\n\t                cropEl.appendChild(imageEl);\n\t            }\n\t        }\n\t        else {\n\t            imageELStyle.width = round(scaleX * dw) + 'px';\n\t            imageELStyle.height = round(scaleY * dh) + 'px';\n\t\n\t            vmlEl.appendChild(imageEl);\n\t\n\t            if (cropEl && cropEl.parentNode) {\n\t                vmlEl.removeChild(cropEl);\n\t                this._cropEl = null;\n\t            }\n\t        }\n\t\n\t        var filterStr = '';\n\t        var alpha = style.opacity;\n\t        if (alpha < 1) {\n\t            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n\t        }\n\t        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\t\n\t        imageELStyle.filter = filterStr;\n\t\n\t        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Append to root\n\t        append(vmlRoot, vmlEl);\n\t\n\t        // Text\n\t        if (style.text != null) {\n\t            this.drawRectText(vmlRoot, this.getBoundingRect());\n\t        }\n\t    };\n\t\n\t    ZImage.prototype.onRemove = function (vmlRoot) {\n\t        remove(vmlRoot, this._vmlEl);\n\t\n\t        this._vmlEl = null;\n\t        this._cropEl = null;\n\t        this._imageEl = null;\n\t\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    ZImage.prototype.onAdd = function (vmlRoot) {\n\t        append(vmlRoot, this._vmlEl);\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t\n\t\n\t    /***************************************************\n\t     * TEXT\n\t     **************************************************/\n\t\n\t    var DEFAULT_STYLE_NORMAL = 'normal';\n\t\n\t    var fontStyleCache = {};\n\t    var fontStyleCacheCount = 0;\n\t    var MAX_FONT_CACHE_SIZE = 100;\n\t    var fontEl = document.createElement('div');\n\t\n\t    var getFontStyle = function (fontString) {\n\t        var fontStyle = fontStyleCache[fontString];\n\t        if (!fontStyle) {\n\t            // Clear cache\n\t            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n\t                fontStyleCacheCount = 0;\n\t                fontStyleCache = {};\n\t            }\n\t\n\t            var style = fontEl.style;\n\t            var fontFamily;\n\t            try {\n\t                style.font = fontString;\n\t                fontFamily = style.fontFamily.split(',')[0];\n\t            }\n\t            catch (e) {\n\t            }\n\t\n\t            fontStyle = {\n\t                style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n\t                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n\t                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n\t                size: parseFloat(style.fontSize || 12) | 0,\n\t                family: fontFamily || 'Microsoft YaHei'\n\t            };\n\t\n\t            fontStyleCache[fontString] = fontStyle;\n\t            fontStyleCacheCount++;\n\t        }\n\t        return fontStyle;\n\t    };\n\t\n\t    var textMeasureEl;\n\t    // Overwrite measure text method\n\t    textContain.measureText = function (text, textFont) {\n\t        var doc = vmlCore.doc;\n\t        if (!textMeasureEl) {\n\t            textMeasureEl = doc.createElement('div');\n\t            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'\n\t                + 'padding:0;margin:0;border:none;white-space:pre;';\n\t            vmlCore.doc.body.appendChild(textMeasureEl);\n\t        }\n\t\n\t        try {\n\t            textMeasureEl.style.font = textFont;\n\t        } catch (ex) {\n\t            // Ignore failures to set to invalid font.\n\t        }\n\t        textMeasureEl.innerHTML = '';\n\t        // Don't use innerHTML or innerText because they allow markup/whitespace.\n\t        textMeasureEl.appendChild(doc.createTextNode(text));\n\t        return {\n\t            width: textMeasureEl.offsetWidth\n\t        };\n\t    };\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\t\n\t        var style = this.style;\n\t        var text = style.text;\n\t        // Convert to string\n\t        text != null && (text += '');\n\t        if (!text) {\n\t            return;\n\t        }\n\t\n\t        var x;\n\t        var y;\n\t        var align = style.textAlign;\n\t        var fontStyle = getFontStyle(style.textFont);\n\t        // FIXME encodeHtmlAttribute ?\n\t        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '\n\t            + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\t\n\t        var baseline = style.textBaseline;\n\t        var verticalAlign = style.textVerticalAlign;\n\t\n\t        textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t\n\t        // Transform rect to view space\n\t        var m = this.transform;\n\t        // Ignore transform for text in other element\n\t        if (m && !fromTextEl) {\n\t            tmpRect.copy(rect);\n\t            tmpRect.applyTransform(m);\n\t            rect = tmpRect;\n\t        }\n\t\n\t        if (!fromTextEl) {\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t            }\n\t            else {\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, textRect, distance\n\t                );\n\t                x = res.x;\n\t                y = res.y;\n\t\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t        }\n\t        else {\n\t            x = rect.x;\n\t            y = rect.y;\n\t        }\n\t        if (verticalAlign) {\n\t            switch (verticalAlign) {\n\t                case 'middle':\n\t                    y -= textRect.height / 2;\n\t                    break;\n\t                case 'bottom':\n\t                    y -= textRect.height;\n\t                    break;\n\t                // 'top'\n\t            }\n\t            // Ignore baseline\n\t            baseline = 'top';\n\t        }\n\t\n\t        var fontSize = fontStyle.size;\n\t        // 1.75 is an arbitrary number, as there is no info about the text baseline\n\t        switch (baseline) {\n\t            case 'hanging':\n\t            case 'top':\n\t                y += fontSize / 1.75;\n\t                break;\n\t            case 'middle':\n\t                break;\n\t            default:\n\t            // case null:\n\t            // case 'alphabetic':\n\t            // case 'ideographic':\n\t            // case 'bottom':\n\t                y -= fontSize / 2.25;\n\t                break;\n\t        }\n\t        switch (align) {\n\t            case 'left':\n\t                break;\n\t            case 'center':\n\t                x -= textRect.width / 2;\n\t                break;\n\t            case 'right':\n\t                x -= textRect.width;\n\t                break;\n\t            // case 'end':\n\t                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n\t                // break;\n\t            // case 'start':\n\t                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n\t                // break;\n\t            // default:\n\t            //     align = 'left';\n\t        }\n\t\n\t        var createNode = vmlCore.createNode;\n\t\n\t        var textVmlEl = this._textVmlEl;\n\t        var pathEl;\n\t        var textPathEl;\n\t        var skewEl;\n\t        if (!textVmlEl) {\n\t            textVmlEl = createNode('line');\n\t            pathEl = createNode('path');\n\t            textPathEl = createNode('textpath');\n\t            skewEl = createNode('skew');\n\t\n\t            // FIXME Why here is not cammel case\n\t            // Align 'center' seems wrong\n\t            textPathEl.style['v-text-align'] = 'left';\n\t\n\t            initRootElStyle(textVmlEl);\n\t\n\t            pathEl.textpathok = true;\n\t            textPathEl.on = true;\n\t\n\t            textVmlEl.from = '0 0';\n\t            textVmlEl.to = '1000 0.05';\n\t\n\t            append(textVmlEl, skewEl);\n\t            append(textVmlEl, pathEl);\n\t            append(textVmlEl, textPathEl);\n\t\n\t            this._textVmlEl = textVmlEl;\n\t        }\n\t        else {\n\t            //  appendChild \n\t            skewEl = textVmlEl.firstChild;\n\t            pathEl = skewEl.nextSibling;\n\t            textPathEl = pathEl.nextSibling;\n\t        }\n\t\n\t        var coords = [x, y];\n\t        var textVmlElStyle = textVmlEl.style;\n\t        // Ignore transform for text in other element\n\t        if (m && fromTextEl) {\n\t            applyTransform(coords, coords, m);\n\t\n\t            skewEl.on = true;\n\t\n\t            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +\n\t            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';\n\t\n\t            // Text position\n\t            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);\n\t            // Left top point as origin\n\t            skewEl.origin = '0 0';\n\t\n\t            textVmlElStyle.left = '0px';\n\t            textVmlElStyle.top = '0px';\n\t        }\n\t        else {\n\t            skewEl.on = false;\n\t            textVmlElStyle.left = round(x) + 'px';\n\t            textVmlElStyle.top = round(y) + 'px';\n\t        }\n\t\n\t        textPathEl.string = encodeHtmlAttribute(text);\n\t        // TODO\n\t        try {\n\t            textPathEl.style.font = font;\n\t        }\n\t        // Error font format\n\t        catch (e) {}\n\t\n\t        updateFillAndStroke(textVmlEl, 'fill', {\n\t            fill: fromTextEl ? style.fill : style.textFill,\n\t            opacity: style.opacity\n\t        }, this);\n\t        updateFillAndStroke(textVmlEl, 'stroke', {\n\t            stroke: fromTextEl ? style.stroke : style.textStroke,\n\t            opacity: style.opacity,\n\t            lineDash: style.lineDash\n\t        }, this);\n\t\n\t        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Attached to root\n\t        append(vmlRoot, textVmlEl);\n\t    };\n\t\n\t    var removeRectText = function (vmlRoot) {\n\t        remove(vmlRoot, this._textVmlEl);\n\t        this._textVmlEl = null;\n\t    };\n\t\n\t    var appendRectText = function (vmlRoot) {\n\t        append(vmlRoot, this._textVmlEl);\n\t    };\n\t\n\t    var list = [RectText, Displayable, ZImage, Path, Text];\n\t\n\t    // In case Displayable has been mixed in RectText\n\t    for (var i = 0; i < list.length; i++) {\n\t        var proto = list[i].prototype;\n\t        proto.drawRectText = drawRectText;\n\t        proto.removeRectText = removeRectText;\n\t        proto.appendRectText = appendRectText;\n\t    }\n\t\n\t    Text.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t        if (style.text != null) {\n\t            this.drawRectText(vmlRoot, {\n\t                x: style.x || 0, y: style.y || 0,\n\t                width: 0, height: 0\n\t            }, this.getBoundingRect(), true);\n\t        }\n\t        else {\n\t            this.removeRectText(vmlRoot);\n\t        }\n\t    };\n\t\n\t    Text.prototype.onRemove = function (vmlRoot) {\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    Text.prototype.onAdd = function (vmlRoot) {\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t}\n\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\tif (!__webpack_require__(5).canvasSupported) {\n\t    var urn = 'urn:schemas-microsoft-com:vml';\n\t\n\t    var createNode;\n\t    var win = window;\n\t    var doc = win.document;\n\t\n\t    var vmlInited = false;\n\t\n\t    try {\n\t        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n\t        createNode = function (tagName) {\n\t            return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n\t        };\n\t    }\n\t    catch (e) {\n\t        createNode = function (tagName) {\n\t            return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n\t        };\n\t    }\n\t\n\t    // From raphael\n\t    var initVML = function () {\n\t        if (vmlInited) {\n\t            return;\n\t        }\n\t        vmlInited = true;\n\t\n\t        var styleSheets = doc.styleSheets;\n\t        if (styleSheets.length < 31) {\n\t            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n\t        }\n\t        else {\n\t            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n\t            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n\t        }\n\t    };\n\t\n\t    // Not useing return to avoid error when converting to CommonJS module\n\t    module.exports = {\n\t        doc: doc,\n\t        initVML: initVML,\n\t        createNode: createNode\n\t    };\n\t}\n\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * VML Painter.\n\t *\n\t * @module zrender/vml/Painter\n\t */\n\t\n\t\n\t\n\t    var zrLog = __webpack_require__(22);\n\t    var vmlCore = __webpack_require__(79);\n\t\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/vml/Painter\n\t     */\n\t    function VMLPainter(root, storage) {\n\t\n\t        vmlCore.initVML();\n\t\n\t        this.root = root;\n\t\n\t        this.storage = storage;\n\t\n\t        var vmlViewport = document.createElement('div');\n\t\n\t        var vmlRoot = document.createElement('div');\n\t\n\t        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\t\n\t        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\t\n\t        root.appendChild(vmlViewport);\n\t\n\t        this._vmlRoot = vmlRoot;\n\t        this._vmlViewport = vmlViewport;\n\t\n\t        this.resize();\n\t\n\t        // Modify storage\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t\n\t            oldDelFromMap.call(storage, elId);\n\t\n\t            if (el) {\n\t                el.onRemove && el.onRemove(vmlRoot);\n\t            }\n\t        };\n\t\n\t        storage.addToMap = function (el) {\n\t            // Displayable already has a vml node\n\t            el.onAdd && el.onAdd(vmlRoot);\n\t\n\t            oldAddToMap.call(storage, el);\n\t        };\n\t\n\t        this._firstPaint = true;\n\t    }\n\t\n\t    VMLPainter.prototype = {\n\t\n\t        constructor: VMLPainter,\n\t\n\t        /**\n\t         * @return {HTMLDivElement}\n\t         */\n\t        getViewportRoot: function () {\n\t            return this._vmlViewport;\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        refresh: function () {\n\t\n\t            var list = this.storage.getDisplayList(true, true);\n\t\n\t            this._paintList(list);\n\t        },\n\t\n\t        _paintList: function (list) {\n\t            var vmlRoot = this._vmlRoot;\n\t            for (var i = 0; i < list.length; i++) {\n\t                var el = list[i];\n\t                if (el.invisible || el.ignore) {\n\t                    if (!el.__alreadyNotVisible) {\n\t                        el.onRemove(vmlRoot);\n\t                    }\n\t                    // Set as already invisible\n\t                    el.__alreadyNotVisible = true;\n\t                }\n\t                else {\n\t                    if (el.__alreadyNotVisible) {\n\t                        el.onAdd(vmlRoot);\n\t                    }\n\t                    el.__alreadyNotVisible = false;\n\t                    if (el.__dirty) {\n\t                        el.beforeBrush && el.beforeBrush();\n\t                        (el.brushVML || el.brush).call(el, vmlRoot);\n\t                        el.afterBrush && el.afterBrush();\n\t                    }\n\t                }\n\t                el.__dirty = false;\n\t            }\n\t\n\t            if (this._firstPaint) {\n\t                // Detached from document at first time\n\t                // to avoid page refreshing too many times\n\t\n\t                // FIXME  removeChild \n\t                this._vmlViewport.appendChild(vmlRoot);\n\t                this._firstPaint = false;\n\t            }\n\t        },\n\t\n\t        resize: function (width, height) {\n\t            var width = width == null ? this._getWidth() : width;\n\t            var height = height == null ? this._getHeight() : height;\n\t\n\t            if (this._width != width || this._height != height) {\n\t                this._width = width;\n\t                this._height = height;\n\t\n\t                var vmlViewportStyle = this._vmlViewport.style;\n\t                vmlViewportStyle.width = width + 'px';\n\t                vmlViewportStyle.height = height + 'px';\n\t            }\n\t        },\n\t\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t\n\t            this._vmlRoot =\n\t            this._vmlViewport =\n\t            this.storage = null;\n\t        },\n\t\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t\n\t        clear: function () {\n\t            if (this._vmlViewport) {\n\t                this.root.removeChild(this._vmlViewport);\n\t            }\n\t        },\n\t\n\t        _getWidth: function () {\n\t            var root = this.root;\n\t            var stl = root.currentStyle;\n\t\n\t            return ((root.clientWidth || parseInt10(stl.width))\n\t                    - parseInt10(stl.paddingLeft)\n\t                    - parseInt10(stl.paddingRight)) | 0;\n\t        },\n\t\n\t        _getHeight: function () {\n\t            var root = this.root;\n\t            var stl = root.currentStyle;\n\t\n\t            return ((root.clientHeight || parseInt10(stl.height))\n\t                    - parseInt10(stl.paddingTop)\n\t                    - parseInt10(stl.paddingBottom)) | 0;\n\t        }\n\t    };\n\t\n\t    // Not supported methods\n\t    function createMethodNotSupport(method) {\n\t        return function () {\n\t            zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n\t        };\n\t    }\n\t\n\t    var notSupportedMethods = [\n\t        'getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers',\n\t        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'\n\t    ];\n\t\n\t    for (var i = 0; i < notSupportedMethods.length; i++) {\n\t        var name = notSupportedMethods[i];\n\t        VMLPainter.prototype[name] = createMethodNotSupport(name);\n\t    }\n\t\n\t    module.exports = VMLPainter;\n\n\n/***/ }\n/******/ ])\n});\n;\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d999bf11626ecda66fa4\n **/","/**\r\n * Export fishTopo as CommonJS module\r\n */\r\nmodule.exports = require('./lib/fish-topo-bo/lib/FishTopoBo.js');\r\n//IE8 VML IE8\r\nrequire('zrender/lib/vml/vml');\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.bo.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\r\n * Created by majianan on 16/5/19.\r\n *\r\n */\r\n\r\n    var zr = require('zrender/lib/zrender');\r\n    var util = require('zrender/lib/core/util');\r\n    var BoNode = require('./node/BoNode');\r\n    var Relation = require('./node/Relation');\r\n    var Const = require('./models/Const');\r\n    var graphic = require(\"../../fish-topo-core/lib/graphic.js\");\r\n    var eventTool = require('zrender/lib/core/event');\r\n\r\n    function FishTopoBo(dom, opts) {\r\n        /**\r\n         * \r\n         * @type {number}\r\n         */\r\n        this.nowZoom = 1;\r\n        this.canScale = true;\r\n\r\n        /**\r\n         * zrender\r\n         */\r\n        this._zr = zr.init(dom, {\r\n            renderer: opts.renderer || 'canvas',\r\n            devicePixelRatio: opts.devicePixelRatio\r\n        });\r\n    }\r\n\r\n    var fishTopoProto = FishTopoBo.prototype;\r\n\r\n    /**\r\n     * \r\n     */\r\n    fishTopoProto.init = function () {\r\n        this.group = new graphic.Group();\r\n        this.groupDrag(this.group);\r\n        this._zr.add(this.group);\r\n        this.zrScale();\r\n    };\r\n\r\n    /**\r\n     *   \r\n     */\r\n    fishTopoProto.resize = function () {\r\n        this._zr.resize();\r\n    };\r\n\r\n    /**\r\n     * BO\r\n     * @param {Object} boData, bo\r\n     * @param {{\r\n     *          startPos: {x: number, y: number} ,\r\n     *          displayAttrDataType: boolean ,\r\n     *          displayAttrEvent: boolean ,\r\n     *          boClickable: boolean BO,  false\r\n     *          boPopupUrl: String BO\r\n     *          boEventClickable: boolean BO,  false\r\n     *          boEventPopupUrl: String BO\r\n     *          attrEventClickable: boolean BO,  false\r\n     *          attrEventPopupUrl: String BO\r\n     *          isCurrent: boolean BO\r\n     *          }} opts\r\n     * @returns {*}\r\n     */\r\n    fishTopoProto.addBo = function (boData, opts) {\r\n        //BO\r\n        this._setParent(boData);\r\n\r\n        //layout BOx,y, level:\r\n        boData.layout = {\r\n            x: opts.startPos.x,\r\n            y: opts.startPos.y,\r\n            level: 1\r\n        };\r\n\r\n        //BOX\r\n        this._bfs(boData);\r\n\r\n        //\r\n        this._moveRightByParent(boData, opts.startPos.x - boData.layout.x);\r\n\r\n        //BO\r\n        var boNode = new BoNode(boData, opts);\r\n        this.group.add(boNode.getShape());\r\n\r\n        //BO\r\n        this.addChildBo(boNode, opts);\r\n\r\n        return boNode;\r\n    };\r\n\r\n    /**\r\n     * BO\r\n     * @param {Object} boData BO\r\n     * @private\r\n     */\r\n    fishTopoProto._setParent = function (boData) {\r\n        if (boData.child) {\r\n            var childCnt = boData.child.length,\r\n                childBoArr = boData.child;\r\n            for (var i = 0; i < childCnt; i++) {\r\n                childBoArr[i].parent = boData;\r\n                if (childBoArr[i + 1]) {\r\n                    childBoArr[i].next = childBoArr[i + 1];\r\n                }\r\n                //next=\r\n                else if (boData.next && boData.next.child) {\r\n                    childBoArr[i].next = boData.next.child[0];\r\n                }\r\n                this._setParent(childBoArr[i]);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * Breadth-First-Search X\r\n     * BOBOX\r\n     * BOBOY\r\n     * @param boData\r\n     * @private\r\n     */\r\n    fishTopoProto._bfs = function (boData) {\r\n        //level\r\n        this._levelMaxPos = {};\r\n\r\n        this._queue = [];   //BO\r\n        this._queue.push(boData);\r\n\r\n        while (this._queue.length > 0) {\r\n            var tmp = this._queue.shift();\r\n            //console.log('BO[' + tmp.name + '] {x: ' + tmp.layout.x + ', level: ' + tmp.layout.level + '} ');\r\n            //console.log('    ***Before this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\r\n            //level\r\n            if (!this._levelMaxPos[tmp.layout.level]) {\r\n                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n            }\r\n            //\r\n            else if (this._levelMaxPos[tmp.layout.level].x + Const.BO_NODE_WIDTH <= tmp.layout.x) {\r\n                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n            }\r\n            //\r\n            else {\r\n                this._moveRightByChild(tmp, this._levelMaxPos[tmp.layout.level].x - tmp.layout.x + Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X)\r\n                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n            }\r\n\r\n            //console.log('    ***After this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\r\n            //x\r\n            if (tmp.child) {\r\n                var childCnt = tmp.child.length;\r\n\r\n                for (var i = 0; i < childCnt; i++) {\r\n\r\n                    tmp.child[i].layout = {\r\n                        x: tmp.layout.x - (Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X) * ((childCnt - 1) / 2 - i),\r\n                        level: tmp.layout.level + 1\r\n                    };\r\n\r\n                    this._queue.push(tmp.child[i]);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param boData\r\n     * @param width\r\n     * @private\r\n     */\r\n    fishTopoProto._moveRightByChild = function (boData, width) {\r\n        if (boData) {\r\n\r\n            if (!boData.layout.moved) {\r\n\r\n                if (boData.layout.level == 1) {\r\n                    boData.layout.x += width / 2;\r\n                } else {\r\n                    boData.layout.x += width;\r\n                }\r\n\r\n                boData.layout.moved = true;\r\n            }\r\n            //\r\n            this._moveRightByPrevious(boData.next, width);\r\n            //\r\n            this._moveRightByChild(boData.parent, width);\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param boData\r\n     * @param width\r\n     * @private\r\n     */\r\n    fishTopoProto._moveRightByPrevious = function (boData, width) {\r\n        if (boData) {\r\n            boData.layout.x += width;\r\n            //\r\n            this._moveRightByPrevious(boData.next, width);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param boData\r\n     * @param width\r\n     * @private\r\n     */\r\n    fishTopoProto._moveRightByParent = function (boData, width) {\r\n        if (boData) {\r\n            boData.layout.x += width;\r\n            if (boData.child) {\r\n                for (var i = 0; i < boData.child.length; i++) {\r\n                    this._moveRightByParent(boData.child[i], width);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * BO\r\n     * @param {BoNode} parentBoNode\r\n     * @param {Object} opts\r\n     * @private\r\n     */\r\n    fishTopoProto.addChildBo = function (parentBoNode, opts) {\r\n\r\n        this._queue = []; //BOYBoNode\r\n        this._queue.push(parentBoNode);\r\n\r\n        while (this._queue.length > 0) {\r\n            var tmp = this._queue.shift(),\r\n                boNodeHeight = tmp.getShape().getBoundingRect().height;\r\n            //console.log('Parent BO[' + tmp.getData().name + '] {y: ' + tmp.getLayout().y + ', level: ' + tmp.getLayout().level + ', boNodeHeight:' + boNodeHeight + '} ');\r\n            //console.log('    ***Before this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\r\n            //Level\r\n            if (!this._levelMaxPos[tmp.getLayout().level].y ||\r\n                this._levelMaxPos[tmp.getLayout().level].y < tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y) {\r\n                this._levelMaxPos[tmp.getLayout().level].y = tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y;\r\n            }\r\n\r\n            //console.log('    ***After this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\r\n            if (tmp.getData().child) {\r\n\r\n                var childBoArr = tmp.getData().child,\r\n                    childCnt = childBoArr.length,\r\n                    boNode,\r\n                    relationNode;\r\n\r\n                //levelY\r\n                opts.startPos.y = this._levelMaxPos[tmp.getLayout().level].y;\r\n                for (var i = 0; i < childCnt; i++) {\r\n                    opts.startPos.x = childBoArr[i].layout.x;\r\n                    childBoArr[i].layout.y = opts.startPos.y;\r\n                    boNode = new BoNode(childBoArr[i], opts);\r\n                    //console.log('Child BO[' + boNode.getData().name + '] {y: ' + opts.startPos.y + ', level: ' + boNode.getLayout().level + '} ');\r\n\r\n                    this.group.add(boNode.getShape());\r\n                    this._queue.push(boNode);\r\n\r\n                    //BO\r\n                    if (childBoArr[i].relation) {\r\n                        var _relationLen = childBoArr[i].relation.length;\r\n                        for (var j = 0; j < _relationLen; j++) {\r\n                            var sourceId = childBoArr[i].relation[j].sourceId,\r\n                                targetId = childBoArr[i].relation[j].targetId,\r\n                                sourceText = childBoArr[i].relation[j].sourceText,\r\n                                targetText = childBoArr[i].relation[j].targetText;\r\n\r\n                            relationNode = new Relation(\r\n                                boNode.getShape().childOfName(sourceId),\r\n                                tmp.getShape().childOfName(targetId),\r\n                                sourceText,\r\n                                targetText\r\n                            );\r\n                            this.group.add(relationNode.getShape());\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * BO\r\n     * @param {String} boId, BO\r\n     * @param {Object} style, BO,\r\n     */\r\n    fishTopoProto.setCurrentBo = function (boId, style) {\r\n        var length = this.group.childCount();\r\n        for (var i = 0; i < length; i++) {\r\n            if (this.group.childAt(i).name == boId) {\r\n                this.group.childAt(i).setCurrent(style);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * \r\n     */\r\n    fishTopoProto.clear = function () {\r\n        this._zr.clear();\r\n        this.group = new graphic.Group();\r\n        this._zr.add(this.group);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param type\r\n     */\r\n    fishTopoProto.zrScale = function (type) {\r\n        var that = this;\r\n        if (type) {\r\n            if (type == \"narrowing\") {\r\n                var zoomDelta = 1 / 1.1;\r\n                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }\r\n            if (type == \"enlarge\") {\r\n                var zoomDelta = 1.1;\r\n                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }\r\n        } else {\r\n            that._zr.on('mousewheel', function (e) {\r\n                eventTool.stop(e.event);\r\n                var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\r\n                zoom(zoomDelta, e.offsetX, e.offsetY);\r\n            });\r\n        }\r\n        ;\r\n        function zoom(zoomDelta, zoomX, zoomY) {\r\n            if (that.canScale == false) {\r\n                return;\r\n            }\r\n            var target = that.group;\r\n            if (target) {\r\n                var pos = target.position;\r\n                var scale = target.scale;\r\n                var newZoom = that._zoom = that._zoom || 1;\r\n                newZoom *= zoomDelta;\r\n                var zoomScale = newZoom / that._zoom;\r\n                // if(newZoom>2.6||newZoom<0.38){\r\n                //     return;\r\n                // };\r\n                that._zoom = newZoom;\r\n\r\n                that.nowZoom = newZoom;\r\n                // Keep the mouse center when scaling\r\n                pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\r\n                pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\r\n                scale[0] *= zoomScale;\r\n                scale[1] *= zoomScale;\r\n                target.attr(\"position\", [pos[0], pos[1]]);\r\n                target.attr(\"scale\", [scale[0], scale[1]]);\r\n                //that.minimap.updateSelectionPosition(pos,zoomScale);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Group\r\n     */\r\n    fishTopoProto.groupDrag = function () {\r\n        var that = this;\r\n        that._zr.on(\"mousedown\", function (e) {\r\n            groupDragFunction(e);\r\n            e.cancelBubble = true;\r\n        });\r\n        function groupDragFunction(e) {\r\n            var startX = e.event.clientX;\r\n            var startY = e.event.clientY;\r\n            var moveFunction = function (e) {\r\n                moveDrag(e);\r\n            }\r\n            var nowGroupPosition = that.group.position;\r\n            var groupPositionX = that.group.position[0];\r\n            var groupPositionY = that.group.position[1];\r\n            var alarmPositionX, alarmPositionY;\r\n\r\n            function moveDrag(e) {\r\n                var width = that.group.getBoundingRect().width * that.nowZoom;\r\n                var height = that.group.getBoundingRect().height * that.nowZoom;\r\n                var gx = that.group.getBoundingRect().x * that.nowZoom;\r\n                var gy = that.group.getBoundingRect().y * that.nowZoom;\r\n                var min = [10 - (width + gx), 10 - (height + gy)];\r\n                var max = [(that._zr.getWidth() - gx) - 10, (that._zr.getHeight() - gy) - 10];\r\n                var sX = (e.event.clientX - startX) * (that.nowZoom);\r\n                var sY = (e.event.clientY - startY) * (that.nowZoom);\r\n                nowGroupPosition[0] = groupPositionX + (sX);\r\n                nowGroupPosition[1] = groupPositionY + (sY);\r\n                if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] < min[0] || nowGroupPosition[1] < min[1]) {\r\n                    return;\r\n                } else {\r\n                    that.group.attr(\"position\", nowGroupPosition);\r\n                }\r\n            }\r\n\r\n            that._zr.on('mousemove', moveFunction);\r\n            var upFunction = function (e) {\r\n                endDrag(e);\r\n            }\r\n\r\n            function endDrag(e) {\r\n                that._zr.off('mousemove', moveFunction);\r\n                that._zr.off('mouseup', upFunction);\r\n                that._zr.off(\"globalout\", upFunction);\r\n            }\r\n\r\n            that._zr.on('mouseup', upFunction);\r\n            that._zr.on(\"globalout\", upFunction);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param node\r\n     */\r\n    fishTopoProto.drag = function (node) {\r\n        var that = this;\r\n        node.on(\"mousedown\", function (e) {\r\n            if (this.isdraggable == false) {\r\n                return;\r\n            }\r\n            groupDragFunction(e);\r\n            e.cancelBubble = true;\r\n        });\r\n        function groupDragFunction(e) {\r\n            var startX = e.event.clientX;\r\n            var startY = e.event.clientY;\r\n            var moveFunction = function (e) {\r\n                moveDrag(e);\r\n            }\r\n            var nowGroupPosition = node.position;\r\n            var groupPositionX = node.position[0];\r\n            var groupPositionY = node.position[1];\r\n            var alarmPositionX, alarmPositionY;\r\n            if (node.alarm) {\r\n                var newAlarmPosition = node.alarm.position;\r\n                alarmPositionX = node.alarm.position[0];\r\n                alarmPositionY = node.alarm.position[1];\r\n            }\r\n            ;\r\n            function moveDrag(e) {\r\n                var sX = (e.event.clientX - startX) / (that.nowZoom);\r\n                var sY = (e.event.clientY - startY) / (that.nowZoom);\r\n                if (node.parent && node.parent instanceof GroupNode) {\r\n                    //nodegroup\r\n                    var nodeMessage = {\r\n                        width: node.shape.width,\r\n                        height: node.shape.height,\r\n                        position: node.position,\r\n                        nodeXY: [node.shape.x, node.shape.y],\r\n                        movePosition: [groupPositionX, groupPositionY],\r\n                        moveX: sX,\r\n                        moveY: sY\r\n                    };\r\n                    var groupNode = node.parent;\r\n                    groupNode.reDraw(nodeMessage, node);\r\n                } else {\r\n                    nowGroupPosition[0] = groupPositionX + (sX);\r\n                    nowGroupPosition[1] = groupPositionY + (sY);\r\n                    node.attr(\"position\", nowGroupPosition);\r\n                    if (node.alarm) {\r\n                        var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm.getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect().height - 3];\r\n                        node.alarm.attr(\"position\", newAlarmPosition);\r\n                    }\r\n                    ;\r\n                }\r\n                ConnectionManager.refreshLineByNode(node);\r\n            }\r\n\r\n            that._zr.on('mousemove', moveFunction);\r\n            var upFunction = function (e) {\r\n                endDrag(e);\r\n            }\r\n            //\r\n            function endDrag(e) {\r\n                that._zr.off('mousemove', moveFunction);\r\n                that._zr.off('mouseup', upFunction);\r\n                that._zr.off(\"globalout\", upFunction);\r\n                //\r\n                if (node.layout) {\r\n                    that.layoutNode(\"tree\", {\"node\": node});\r\n                }\r\n                if (that.forceLayoutOption) {\r\n                    var nodes = that.forceLayoutOption.allNodes;\r\n                    if (_.indexOf(nodes, node) != -1) {\r\n                        that.layoutNode(\"force\", this.forceLayoutOption);\r\n                    }\r\n                }\r\n                ;\r\n            }\r\n\r\n            that._zr.on('mouseup', upFunction);\r\n            that._zr.on(\"globalout\", upFunction);\r\n        }\r\n    };\r\n\r\n\r\n    // ---------fishTopoBo------------------\r\n    var idBase = new Date() - 0;\r\n    var instances = {};\r\n    var DOM_ATTRIBUTE_KEY = '_fishTopoBo_instance_';\r\n    var fishTopoBo = {\r\n        /**\r\n         * @type {number}\r\n         */\r\n        version: '1.0.0',\r\n        dependencies: {\r\n            zrender: '3.0.4'\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @param {HTMLDomElement} dom\r\n     * @param {Object} opts\r\n     */\r\n    fishTopoBo.init = function (dom, opts) {\r\n        if (!dom) {\r\n            throw new Error('Initialize failed: invalid dom.');\r\n        }\r\n\r\n        opts = opts || {};\r\n        // Default value\r\n        util.defaults(opts,\r\n            {\r\n                type: \"bpmn\",\r\n                showGridLine: true,\r\n                devicePixelRatio: 1,\r\n                gridLineSpacing:10\r\n            }\r\n        );\r\n\r\n        var fishTopoBo = new FishTopoBo(dom, opts);\r\n        fishTopoBo.init();\r\n\r\n        fishTopoBo.id = 'ft_' + idBase++;\r\n        instances[fishTopoBo.id] = fishTopoBo;\r\n\r\n        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoBo.id);\r\n\r\n        return fishTopoBo;\r\n    };\r\n\r\n\r\n    /**\r\n     * @param  {HTMLDomElement} dom\r\n     * @return {fishTopo}\r\n     */\r\n    fishTopoBo.getInstanceByDom = function (dom) {\r\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n        return instances[key];\r\n    };\r\n\r\n    /**\r\n     * Dispose a fishTopo instance\r\n     * @param  {module:fishTopo|HTMLDomElement|string} fishTopo\r\n     */\r\n    fishTopoBo.dispose = function (chart) {\r\n        var topo;\r\n        if (zrUtil.isDom(chart)) {\r\n            topo = fishTopoBo.getInstanceByDom(chart);\r\n        }\r\n        else if (typeof chart === 'string') {\r\n            topo = instances[chart];\r\n        }\r\n        if ((topo instanceof fishTopoBo) && !topo.isDisposed()) {\r\n            topo.dispose();\r\n        }\r\n    };\r\n\r\n    module.exports = fishTopoBo;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/FishTopoBo.js\n ** module id = 2\n ** module chunks = 0\n **/","/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n    var zrUtil = require('./core/util');\n\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: require('./Painter')\n    };\n\n    var instances = {};    // ZRendermap\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.4.1';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        // TODO WebGL\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        //  storage.delFromMap, \n        // FIXME ugly\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToMap = function (el) {\n            oldAddToMap.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * \n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, dpr) {\n            return this.painter.pathToImage(e, dpr);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/zrender.js\n ** module id = 3\n ** module chunks = 0\n **/","/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/guid.js\n ** module id = 4\n ** module chunks = 0\n **/","/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // canvas\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n                // events currently. So we dont use that on other browsers unless tested sufficiently.\n                // Although IE 10 supports pointer event, it use old style and is different from the\n                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n                && (browser.edge || (browser.ie && browser.version >= 11))\n        };\n    }\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/env.js\n ** module id = 5\n ** module chunks = 0\n **/","/**\n * @module zrender/core/util\n */\n\n\n    // mergeDate\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuiltInObject(sourceProp)\n                    && !isBuiltInObject(targetProp)\n                    && !isPrimitive(sourceProp)\n                    && !isPrimitive(targetProp)\n                ) {\n                    // merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // overwritetrue\n                    // NOTE target[key] \n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * \n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz \n     * @param {Function} baseClazz \n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuiltInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * Whether is exactly NaN. Notice isNaN('a') returns true.\n     * @param {*} value\n     * @return {boolean}\n     */\n    function eqNaN(value) {\n        return value !== value;\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var primitiveKey = '__ec_primitive__';\n    /**\n     * Set an object as primitive to be ignored traversing children in clone or merge\n     */\n    function setAsPrimitive(obj) {\n        obj[primitiveKey] = true;\n    }\n\n    function isPrimitive(obj) {\n        return obj[primitiveKey];\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuiltInObject: isBuiltInObject,\n        isDom: isDom,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        assert: assert,\n        setAsPrimitive: setAsPrimitive,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/util.js\n ** module id = 6\n ** module chunks = 0\n **/","'use strict';\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n\n    var Eventful = require('./mixin/Eventful');\n\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n            var proxy = this.proxy;\n\n            this._hovered = hovered;\n\n            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = null;\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * cursor style\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * \n         *\n         * @private\n         * @param {Object} targetEl \n         * @param {string} eventName \n         * @param {Object} event \n         */\n        dispatchToElement: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\n            var el = targetEl;\n\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                //  zrender \n                this.trigger(eventName, eventPacket);\n                // \n                //  click  dispose painter \n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                if (!list[i].silent\n                 && list[i] !== exclude\n                 // getDisplayList may include ignored item in VML mode\n                 && !list[i].ignore\n                 && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n\n            if (name === 'mousedown') {\n                this._downel = hovered;\n                // In case click triggered before mouseup\n                this._upel = hovered;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hovered;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            while (el) {\n                // If ancestor is silent or clipped by ancestor\n                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n                    return false;\n                }\n                el = el.parent;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Handler.js\n ** module id = 7\n ** module chunks = 0\n **/","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    module.exports = Draggable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Draggable.js\n ** module id = 8\n ** module chunks = 0\n **/","/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * \n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * trigger\n         *\n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} [handler] \n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * \n         *\n         * @param {string} type \n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * context, context\n         * @param {string} type \n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    //  onxxxx \n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Eventful.js\n ** module id = 9\n ** module chunks = 0\n **/","'use strict';\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = require('./core/util');\n    var env = require('./core/env');\n\n    var Group = require('./container/Group');\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     *  (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        // idmap\n        this._elements = {};\n\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} [update=false] \n         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n         *\n         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * \n         * GroupShapeShape\n         * zlevel > z > \n         * @param {boolean} [includeIgnore=false]  ignore \n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var userSetClipPath = el.clipPath;\n            if (userSetClipPath) {\n\n                // FIXME \n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                // Recursively add clip path\n                while (currentClipPath) {\n                    // clipPath  clipPath \n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n\n                    clipPaths.push(currentClipPath);\n\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.clipPath;\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            // Element has been added\n            if (this._elements[el.id]) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToMap(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {string|Array.<string>} [elId] Storage\n         */\n        delRoot: function (elId) {\n            if (elId == null) {\n                // elId\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._elements = {};\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (elId instanceof Array) {\n                for (var i = 0, l = elId.length; i < l; i++) {\n                    this.delRoot(elId[i]);\n                }\n                return;\n            }\n\n            var el;\n            if (typeof(elId) == 'string') {\n                el = this._elements[elId];\n            }\n            else {\n                el = elId;\n            }\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromMap(el.id);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToMap: function (el) {\n            if (el instanceof Group) {\n                el.__storage = this;\n            }\n            el.dirty(false);\n\n            this._elements[el.id] = el;\n\n            return this;\n        },\n\n        get: function (elId) {\n            return this._elements[elId];\n        },\n\n        delFromMap: function (elId) {\n            var elements = this._elements;\n            var el = elements[elId];\n            if (el) {\n                delete elements[elId];\n                if (el instanceof Group) {\n                    el.__storage = null;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Storage\n         */\n        dispose: function () {\n            this._elements =\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Storage.js\n ** module id = 10\n ** module chunks = 0\n **/","/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * \n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         *  index \n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * \n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         *  nextSibling \n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToMap(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromMap(child.id);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * \n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/container/Group.js\n ** module id = 11\n ** module chunks = 0\n **/","'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * \n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * \n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender  element  zrender \n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * true\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * (shape) Group \n         * \n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Element.js\n ** module id = 12\n ** module chunks = 0\n **/","'use strict';\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * \n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * \n     * , position, rotation, scaletransformtransform\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // \n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // \n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = this.origin;\n\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n    /**\n     * transformcontext\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n\n    var tmpTransform = [];\n\n    /**\n     * `transform``position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     *  shape \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    module.exports = Transformable;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Transformable.js\n ** module id = 13\n ** module chunks = 0\n **/","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * \n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/matrix.js\n ** module id = 14\n ** module chunks = 0\n **/","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * \n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * \n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} \n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/vector.js\n ** module id = 15\n ** module chunks = 0\n **/","'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * \n         *\n         * @param {string} path a.b.c\n         * @param {boolean} [loop] \n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Animatable.js\n ** module id = 16\n ** module chunks = 0\n **/","/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = (\n                isValueArray\n                && isArrayLike(firstVal[0])\n            )\n            ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * \n         * @param  {number} time ms\n         * @param  {Object} props key-value\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        pause: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].pause();\n            }\n            this._paused = true;\n        },\n\n        resume: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].resume();\n            }\n            this._paused = false;\n        },\n\n        isPaused: function () {\n            return !!this._paused;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * \n         * @param  {string|Function} easing\n         *         {@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * \n         * @param  {number} time ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/Animator.js\n ** module id = 17\n ** module chunks = 0\n **/","/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = require('./easing');\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // \n        this._life = options.life || 1000;\n        // \n        this._delay = options.delay || 0;\n        // \n        // this._startTime = new Date().getTime() + this._delay;// \n        this._initialized = false;\n\n        // \n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n\n        this._pausedTime = 0;\n        this._paused = false;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime, deltaTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            if (this._paused) {\n                this._pausedTime += deltaTime;\n                return;\n            }\n\n            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n\n            // \n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // \n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // \n                    //  stage.update \n                    return 'restart';\n                }\n\n                // \n                // Animation.update\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._pausedTime = 0;\n\n            this._needsRemove = false;\n        },\n\n        fire: function (eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        },\n\n        pause: function () {\n            this._paused = true;\n        },\n\n        resume: function () {\n            this._paused = false;\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/Clip.js\n ** module id = 18\n ** module chunks = 0\n **/","/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // t^3\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // t^4\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // t^5\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // sin(t)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 2^t\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // sqrt(1-t^2)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/easing.js\n ** module id = 19\n ** module chunks = 0\n **/","/**\n * @module zrender/tool/color\n */\n\n\n    var LRU = require('../core/LRU');\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    function setRgba(out, r, g, b, a) {\n        out[0] = r; out[1] = g; out[2] = b; out[3] = a;\n        return out;\n    }\n    function copyRgba(out, a) {\n        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n        return out;\n    }\n    var colorCache = new LRU(20);\n    var lastRemovedArr = null;\n    function putToCache(colorStr, rgbaArr) {\n        // Reuse removed array\n        if (lastRemovedArr) {\n            copyRgba(lastRemovedArr, rgbaArr);\n        }\n        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n    }\n    /**\n     * @param {string} colorStr\n     * @param {Array.<number>} out\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr, rgbaArr) {\n        if (!colorStr) {\n            return;\n        }\n        rgbaArr = rgbaArr || [];\n\n        var cached = colorCache.get(colorStr);\n        if (cached) {\n            return copyRgba(rgbaArr, cached);\n        }\n\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            copyRgba(rgbaArr, kCSSColorTable[str]);\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    setRgba(rgbaArr,\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    );\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsla':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsl':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                default:\n                    return;\n            }\n        }\n\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla, rgba) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        rgba = rgba || [];\n        setRgba(rgba,\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),\n            1\n        );\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        out = out || [0, 0, 0, 0];\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return out;\n        }\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssFloat(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color. (If input illegal, return undefined).\n     */\n    function stringify(arrColor, type) {\n        if (!arrColor) {\n            return;\n        }\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/tool/color.js\n ** module id = 20\n ** module chunks = 0\n **/","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function () {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function (val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function (entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            entry.next = null;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function (entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function () {\n        return this._len;\n    };\n\n    /**\n     * Clear list\n     */\n    linkedListProto.clear = function () {\n        this.head = this.tail = null;\n        this._len = 0;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function (val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function (maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n\n        this._lastRemovedEntry = null;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     * @return {} Removed value\n     */\n    LRUProto.put = function (key, value) {\n        var list = this._list;\n        var map = this._map;\n        var removed = null;\n        if (map[key] == null) {\n            var len = list.len();\n            // Reuse last removed entry\n            var entry = this._lastRemovedEntry;\n\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n\n                removed = leastUsedEntry.value;\n                this._lastRemovedEntry = leastUsedEntry;\n            }\n\n            if (entry) {\n                entry.value = value;\n            }\n            else {\n                entry = new Entry(value);\n            }\n            entry.key = key;\n            list.insertEntry(entry);\n            map[key] = entry;\n        }\n\n        return removed;\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function (key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function () {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/LRU.js\n ** module id = 21\n ** module chunks = 0\n **/","\n        var config = require('../config');\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/log.js\n ** module id = 22\n ** module chunks = 0\n **/","\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config\n     * @exports zrender/config\n     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debugcatchBrushExceptiontrue\n         * 0 : debug\n         * 1 : \n         * 2 : \n         */\n        debugMode: 0,\n\n        // retina \n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/config.js\n ** module id = 23\n ** module chunks = 0\n **/","'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // \n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/BoundingRect.js\n ** module id = 24\n ** module chunks = 0\n **/","// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/timsort.js\n ** module id = 25\n ** module chunks = 0\n **/","'use strict';\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n\n    var requestAnimationFrame = require('./requestAnimationFrame');\n\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         *  clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         *  animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * \n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * \n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time, delta);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * \n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * \n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * \n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * animator\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] \n         * @param  {Function} [options.getter=null]\n         *         gettergetter\n         * @param  {Function} [options.setter=null]\n         *         settersetter\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            this.addAnimator(animator);\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/Animation.js\n ** module id = 26\n ** module chunks = 0\n **/","'use strict';\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = require('../mixin/Eventful');\n    var env = require('./env');\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * domtouch.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * preventDefault and stopPropagation.\n     * Notice: do not do that in zrender. Upper application\n     * do that if necessary.\n     *\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // \n        Dispatcher: Eventful\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/event.js\n ** module id = 27\n ** module chunks = 0\n **/","\n\n    module.exports = (typeof window !== 'undefined' &&\n                                    (window.requestAnimationFrame\n                                    || window.msRequestAnimationFrame\n                                    || window.mozRequestAnimationFrame\n                                    || window.webkitRequestAnimationFrame))\n                                || function (func) {\n                                    setTimeout(func, 16);\n                                };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/requestAnimationFrame.js\n ** module id = 28\n ** module chunks = 0\n **/","\n\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerEventNames = {\n        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n    };\n\n    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n        var nm = name.replace('mouse', 'pointer');\n        return pointerEventNames[nm] ? nm : name;\n    });\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null),\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        // Do not do any preventDefault here. Upper application do that if necessary.\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n        }\n    }\n\n    // function onMSGestureChange(proxy, event) {\n    //     if (event.translationX || event.translationY) {\n    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n    //     }\n    //     if (event.scale !== 1) {\n    //         event.pinchX = event.offsetX;\n    //         event.pinchY = event.offsetY;\n    //         event.pinchScale = event.scale;\n    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n    //     }\n    // }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // rootdommouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered, and must before `mousedown` triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        },\n\n        pointerdown: function (event) {\n            domHandlers.mousedown.call(this, event);\n\n            // if (useMSGuesture(this, event)) {\n            //     this._msGesture.addPointer(event.pointerId);\n            // }\n        },\n\n        pointermove: function (event) {\n            // FIXME\n            // pointermove is so sensitive that it always triggered when\n            // tap(click) on touch screen, which affect some judgement in\n            // upper application. So, we dont support mousemove on MS touch\n            // device yet.\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mousemove.call(this, event);\n            }\n        },\n\n        pointerup: function (event) {\n            domHandlers.mouseup.call(this, event);\n        },\n\n        pointerout: function (event) {\n            // pointerout will be triggered when tap on touch screen\n            // (IE11+/Edge on MS Surface) after click event triggered,\n            // which is inconsistent with the mousout behavior we defined\n            // in touchend. So we unify them.\n            // (check domHandlers.touchend for detailed explanation)\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n\n    // function useMSGuesture(handlerProxy, event) {\n    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n    // }\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * dom \n     *\n     * @inner\n     * @param {module:zrender/Handler} instance \n     */\n    function initDomHandler(instance) {\n        zrUtil.each(touchHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(pointerHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(mouseHandlerNames, function (name) {\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        });\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (env.pointerEventsSupported) { // Only IE11+/Edge\n            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n            // at the same time.\n            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n            // screen, which do not occurs in pointer event.\n            // So we use pointer event to both detect touch gesture and mouse behavior.\n            mountHandlers(pointerHandlerNames, this);\n\n            // FIXME\n            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n            // which does not prevent defuault behavior occasionally (which may cause view port\n            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n            // touch screen. And we only support click behavior on MS touch screen now.\n\n            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n            // We dont support touch on IE on win7.\n            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n            // if (typeof MSGesture === 'function') {\n            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n            // }\n        }\n        else {\n            if (env.touchEventsSupported) {\n                mountHandlers(touchHandlerNames, this);\n                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n            }\n\n            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n            // mouse event can not be handle in those devices.\n            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n            // mouseevent after touch event triggered, see `setTouchTimer`.\n            mountHandlers(mouseHandlerNames, this);\n        }\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/dom/HandlerProxy.js\n ** module id = 29\n ** module chunks = 0\n **/","'use strict';\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = require('./event');\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/GestureMgr.js\n ** module id = 30\n ** module chunks = 0\n **/","'use strict';\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n\n    var Layer = require('./Layer');\n\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.__builtin__) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            var path = clipPath.path;\n\n            clipPath.setTransform(ctx);\n            path.beginPath(ctx);\n            clipPath.buildPath(path, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // \n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root \n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * \n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            if (opts.width != null) {\n                root.width = opts.width;\n            }\n            if (opts.height != null) {\n                root.height = opts.height;\n            }\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n\n            this._domRoot = root;\n        }\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._domRoot;\n        },\n\n        /**\n         * \n         * @param {boolean} [paintAll=false] displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.__builtin__ && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuiltinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuiltinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.__builtin__) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         *  zlevel \n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.__builtin__ = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            layersMap[zlevel] = layer;\n\n            // Vitual layer will not directly show on the screen.\n            // (It can be a WebGL layer and assigned to a ZImage element)\n            // But it still under management of zrender.\n            if (!layer.virtual) {\n                if (prevLayer) {\n                    var prevDom = prevLayer.dom;\n                    if (prevDom.nextSibling) {\n                        domRoot.insertBefore(\n                            layer.dom,\n                            prevDom.nextSibling\n                        );\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n                else {\n                    if (domRoot.firstChild) {\n                        domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n            }\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuiltinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (!layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuiltinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // \n            this.eachBuiltinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * hover\n         */\n        clear: function () {\n            this.eachBuiltinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * zlevel\n         *\n         * @param {string} zlevel\n         * @param {Object} config \n         * @param {string} [config.clearColor=0] \n         * @param {string} [config.motionBlur=false] \n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 alpha\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {number} zlevel zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * \n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * \n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            return imageLayer.dom;\n        },\n        /**\n         * \n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * \n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        pathToImage: function (path, dpr) {\n            dpr = dpr || this.dpr;\n\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            var rect = path.getBoundingRect();\n            var style = path.style;\n            var shadowBlurSize = style.shadowBlur;\n            var shadowOffsetX = style.shadowOffsetX;\n            var shadowOffsetY = style.shadowOffsetY;\n            var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\n            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n            var width = rect.width + leftMargin + rightMargin;\n            var height = rect.height + topMargin + bottomMargin;\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.scale(dpr, dpr);\n            ctx.clearRect(0, 0, width, height);\n            ctx.dpr = dpr;\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [leftMargin - rect.x, topMargin - rect.y];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            path.updateTransform();\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Painter.js\n ** module id = 31\n ** module chunks = 0\n **/","/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * dom\n     *\n     * @inner\n     * @param {string} id dom id \n     * @param {string} type dom typesuch as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // append~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // \n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * \n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * \n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * alpha\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Layer.js\n ** module id = 32\n ** module chunks = 0\n **/","/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        // var size =\n        var x = obj.x;\n        var x2 = obj.x2;\n        var y = obj.y;\n        var y2 = obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x;\n        var y = obj.y;\n        var r = obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * [x, y]\n         * @type {Array.<number>}\n         */\n        textOffset: null,\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Style.js\n ** module id = 33\n ** module chunks = 0\n **/","\n\n    var Pattern = function (image, repeat) {\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n\n        return this._canvasPattern\n            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n    };\n\n    module.exports = Pattern;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Pattern.js\n ** module id = 34\n ** module chunks = 0\n **/","/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // \n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // \n                if (!image.width || !image.height) {\n                    return;\n                }\n                var width = style.width;\n                var height = style.height;\n                var aspect = image.width / image.height;\n                if (width == null && height != null) {\n                    // Keep image/height ratio\n                    width = height * aspect;\n                }\n                else if (height == null && width != null) {\n                    height = width / aspect;\n                }\n                else if (width == null && height == null) {\n                    width = image.width;\n                    height = image.height;\n                }\n\n                // transform\n                this.setTransform(ctx);\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Image.js\n ** module id = 35\n ** module chunks = 0\n **/","/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = require('../core/util');\n\n    var Style = require('./Style');\n\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable Painter \n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * true\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * zlevelcanvas\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * \n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * \n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         *  x, y \n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         *  x, y \n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * \n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * \n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO,  bind \n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Displayable.js\n ** module id = 36\n ** module chunks = 0\n **/","/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var textOffset = style.textOffset;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            if (textOffset) {\n                x += textOffset[0];\n                y += textOffset[1];\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                    // Fill after stroke so the outline will not cover the main part.\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                textFill && ctx.fillText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/mixin/RectText.js\n ** module id = 37\n ** module chunks = 0\n **/","\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText  Canvas \n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME \n        var lineHeight = getTextWidth('', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var halfHeight = height / 2 - textHeight / 2;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/text.js\n ** module id = 38\n ** module chunks = 0\n **/","/**\r\n * BO\r\n * 1.BO\r\n * 2.BO\r\n * 3.BO[]\r\n * 4.BO[]\r\n * 5.BOBO\r\n * 6.BO\r\n * 7.BOBO\r\n * @module fish-topo-bo/node/BoNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var BoName = require('../node/BoName');\r\n    var EventDecision = require('../node/EventDecisionNode');\r\n    var Line = require('../node/LineNode');\r\n    var BoAttr = require('../node/BoAttrNode');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n\r\n    /**\r\n     *\r\n     * @param {{\r\n     *          id: String BO,\r\n     *          name: String BO,\r\n     *          boEventArr: [] BO,\r\n     *          boAttrArr: [] BO\r\n     *          }} boData, bo\r\n     * @param {{\r\n     *          startPos: {x: number, y: number} ,\r\n     *          displayAttrDataType: boolean ,\r\n     *          displayAttrEvent: boolean ,\r\n     *          boClickable: boolean BO,  false\r\n     *          boPopupOpts: Object BOurl,width,height\r\n     *          boEventClickable: boolean BO,  false\r\n     *          boEventPopupOpts: Object BOurl,width,height\r\n     *          attrEventClickable: boolean BO,  false\r\n     *          attrEventPopupOpts: Object BOurl,width,height\r\n     *          isCurrent: boolean BO\r\n     *          viewOption: \r\n     *          }} opts\r\n     * @constructor\r\n     */\r\n    function BO(boData, opts) {\r\n\r\n        /**\r\n         * BO\r\n         * @type {Object}\r\n         * @private\r\n         */\r\n        this._data = boData;\r\n        this._data.viewOption = {};\r\n        fish.extend(this._data.viewOption, opts.viewOption||{});\r\n\r\n        /**\r\n         * BO\r\n         * @type {{x: number, y: number}}\r\n         * @private\r\n         */\r\n        this._oriStartPos = opts.startPos;\r\n\r\n        /**\r\n         * \r\n         * @type {{x: number, y: number}}\r\n         * @private\r\n         */\r\n        this._nextStartPos = {\r\n            x: opts.startPos.x,\r\n            y: opts.startPos.y\r\n        };\r\n\r\n        /**\r\n         * \r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayAttrDataType = opts.displayAttrDataType || false;\r\n\r\n        /**\r\n         * \r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayAttrEvent = opts.displayAttrEvent || false;\r\n\r\n        //TODO\r\n        if (this._displayAttrEvent) {\r\n            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 3;\r\n        } else if (this._displayAttrDataType) {\r\n            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 1.5;\r\n        }\r\n\r\n        /**\r\n         * \r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._boClickable = opts.boClickable || false;\r\n        this._boPopupOpts = opts.boPopupOpts;\r\n        this._boEventClickable = opts.boEventClickable || false;\r\n        this._boEventPopupOpts = opts.boEventPopupOpts;\r\n        this._attrEventClickable = opts.attrEventClickable || false;\r\n        this._attrEventPopupOpts = opts.attrEventPopupOpts;\r\n\r\n        /**\r\n         * BOBO\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._isCurrent = opts.isCurrent || false;\r\n\r\n\r\n        /**\r\n         * BO\r\n         * @type {number}\r\n         * @private\r\n         */\r\n        this._boShapeHeight = 0;\r\n\r\n        /**\r\n         * Group\r\n         * @type zrender/graphic/Group\r\n         * @private\r\n         */\r\n        this._group = new graphic.Group();\r\n        this._group.name = this._data.id;\r\n        this._group.setCurrent = function (style) {\r\n            //GroupBO\r\n            var _boShape = this.childAt(this.childCount() - 1);\r\n\r\n            if (style) {\r\n                fish.extend(_boShape.style, style);\r\n            } else {\r\n                //\r\n                _boShape.style.fill = '#66CC99';\r\n            }\r\n\r\n        };\r\n\r\n        this._render();\r\n    }\r\n\r\n\r\n    var boProto = BO.prototype;\r\n\r\n    /**\r\n     * BO\r\n     * @returns {zrender/graphic/Group}\r\n     */\r\n    boProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @returns {Object}\r\n     */\r\n    boProto.getData = function () {\r\n        return this._data;\r\n    };\r\n\r\n    boProto.getLayout = function () {\r\n        return this._data.layout;\r\n    };\r\n\r\n\r\n\r\n    /**\r\n     * BO\r\n     */\r\n    boProto.setCurrent = function () {\r\n        //BO\r\n        this.childAt(this.childCount - 1).style.fill = '#66CC99'\r\n    };\r\n\r\n    /**\r\n     * BO\r\n     * @private\r\n     */\r\n    boProto._render = function () {\r\n        //BO\r\n        this._createBoName();\r\n\r\n        //BO\r\n        this._createEventDecision();\r\n\r\n        //BO\r\n        this._createBoAttr();\r\n\r\n        //BO\r\n        this._createBoShape();\r\n\r\n        //TODO\r\n        Const.BO_NODE_WIDTH = 180;\r\n    };\r\n\r\n\r\n    /**\r\n     * BO\r\n     * @private\r\n     */\r\n    boProto._createBoName = function () {\r\n        var _boNameShape = BoName(this._data.name, this._nextStartPos);\r\n\r\n        if (this._boClickable) {\r\n            _boNameShape.clickable = this._boClickable;\r\n            _boNameShape._data = this._data;\r\n            _boNameShape._boPopupOpts = this._boPopupOpts;\r\n            _boNameShape.onclick = this._click;\r\n        }\r\n\r\n        this._group.add(_boNameShape);\r\n        this._calNextShapeStartPos(_boNameShape);\r\n    };\r\n\r\n    /**\r\n     * BO\r\n     * @private\r\n     */\r\n    boProto._createEventDecision = function () {\r\n\r\n        //BO\r\n        if (!this._data.boEventArr) {\r\n            return;\r\n        }\r\n\r\n        var _boEventArr = this._data.boEventArr,\r\n            _boEventLen = _boEventArr.length,\r\n            _eventShape,\r\n            _eventOpts = {\r\n                startPos: this._nextStartPos,\r\n                clickable: this._boEventClickable,\r\n                popupOpts: this._boEventPopupOpts\r\n            };\r\n\r\n        for (var i = 0; i < _boEventLen; i++) {\r\n            _eventShape = new EventDecision(_boEventArr[i], _eventOpts);\r\n            this._group.add(_eventShape.getShape());\r\n            this._calNextShapeStartPos(_eventShape.getShape());\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * BO\r\n     * @private\r\n     */\r\n    boProto._createBoAttr = function () {\r\n        //BO\r\n        if (!this._data.boAttrArr) {\r\n            return;\r\n        }\r\n\r\n        var _boAttrArr = this._data.boAttrArr,\r\n            _boAttrLen = _boAttrArr.length,\r\n            _boAttrShape, _lineShape,\r\n            _attrEventStartPos = {x: this._nextStartPos.x + Const.BO_NODE_WIDTH / 2, y: this._nextStartPos.y};\r\n\r\n        for (var i = 0; i < _boAttrLen; i++) {\r\n            if (i == 0) {\r\n                _lineShape = Line.BoLine(this._nextStartPos); //\r\n            }\r\n            else {\r\n                _lineShape = Line.AttrLine(this._nextStartPos);//\r\n            }\r\n\r\n            this._group.add(_lineShape);\r\n\r\n            this._calNextShapeStartPos(_lineShape);\r\n\r\n            _boAttrShape = new BoAttr(_boAttrArr[i],\r\n                {\r\n                    startPos: this._nextStartPos,\r\n                    displayDataType: this._displayAttrDataType,\r\n                    displayEventDecision: this._displayAttrEvent,\r\n                    eventClickable: this._attrEventClickable,\r\n                    eventPopupOpts: this._attrEventPopupOpts\r\n                }\r\n            );\r\n            this._group.add(_boAttrShape.getShape());\r\n            this._calNextShapeStartPos(_boAttrShape.getShape())\r\n        }\r\n\r\n        if (this._displayAttrEvent) {\r\n            _lineShape = Line.AttrEventLine(_attrEventStartPos,\r\n                this._nextStartPos.y - _attrEventStartPos.y\r\n            );\r\n            this._group.add(_lineShape);\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * BO\r\n     * @param curShape \r\n     * @private\r\n     */\r\n    boProto._calNextShapeStartPos = function (curShape) {\r\n        //\r\n        this._nextStartPos.y += curShape.getBoundingRect().height;\r\n\r\n        //BO\r\n        this._boShapeHeight += curShape.getBoundingRect().height;\r\n    };\r\n\r\n\r\n    /**\r\n     * BO\r\n     * @private\r\n     */\r\n    boProto._createBoShape = function () {\r\n        var height = this._boShapeHeight > Const.BO_NODE_DEFAULT_HEIGHT ?\r\n                this._boShapeHeight : Const.BO_NODE_DEFAULT_HEIGHT,\r\n            shape = new graphic.Rect({\r\n                position: [this._oriStartPos.x, this._oriStartPos.y],\r\n\r\n                shape: {\r\n                    r: 5,\r\n                    width: Const.BO_NODE_WIDTH,\r\n                    height: height\r\n                },\r\n\r\n                style: {\r\n                    brushType: 'both',\r\n                    fill: this._isCurrent ? '#66CC99' : 'white',\r\n                    stroke: '#000000',\r\n                    lineWidth: 1,\r\n                    lineCape: 'round'\r\n                },\r\n\r\n                zlevel: -1\r\n            });\r\n\r\n        if (this._boClickable) {\r\n            shape._data = this._data;\r\n            shape._boPopupOpts = this._boPopupOpts;\r\n\r\n            shape.clickable = this._boClickable;\r\n            shape.onclick = this._click;\r\n        }\r\n\r\n        this._group.add(shape);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    boProto._click = function () {\r\n        var options = fish.extend(\r\n            {\r\n                viewOption: {\r\n                    DATA: this._data\r\n                },\r\n                width: 800,\r\n                height: 500\r\n            }, this._boPopupOpts);\r\n\r\n        fish.popupView(options);\r\n    };\r\n\r\n    module.exports = BO;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/BoNode.js\n ** module id = 39\n ** module chunks = 0\n **/","/**\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    module.exports = {\r\n        BO_NODE_WIDTH: 180,    //BO\r\n        BO_NODE_DEFAULT_HEIGHT: 60,\t//BOBO\r\n        BO_NODE_OFFSET_X: 90, //BO=\r\n        BO_NODE_OFFSET_Y: 50, //BO\r\n\r\n        BO_NAME_FONT: 'bold 18px Arial', //'normal 16px verdana',    //BO,\r\n        BO_NAME_PADDING_TOP: 10,   //BO\r\n        BO_NAME_PADDING_BOTTOM: 15,   //BO\r\n\r\n        BO_EVENT_HEIGHT: 20,   //BO\r\n        BO_EVENT_WIDTH: 140,   //BO\r\n        BO_EVENT_FONT: 'normal 14px Arial',  //BO\r\n\r\n        BO_ATTR_FONT: 'normal 14px Arial',   //BO\r\n        BO_ATTR_PADDING_TOP: 5,   //BO\r\n        BO_ATTR_PADDING_BOTTOM: 5,   //BO\r\n        BO_ATTR_PADDING_LEFT: 5,   //BO\r\n        BO_ATTR_DATA_TYPE_PADDING_RIGHT: 5, //BO\r\n        BO_ATTR_EVENT_WIDTH: 135,   //BO\r\n\r\n        LINE_DASH: 10,  //\r\n        RELATION_OFFSET: 40,   //\r\n        RELATION_ARROW_WIDTH: 10,  //\r\n        RELATION_ARROW_HEIGHT: 5,  //\r\n        RELATION_TEXT_OFFSET_X: 10, //\r\n        RELATION_TEXT_OFFSET_Y: 5 //\r\n    };\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/models/Const.js\n ** module id = 40\n ** module chunks = 0\n **/","/**\r\n * BO\r\n * @module fish-topo-bo/node/BoName\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n    /**\r\n     *\r\n     * @param {String} text, BO\r\n     * @param {{x: number, y: number}} startPos, \r\n     * @returns {zrender/graphic/Text}\r\n     * @constructor\r\n     */\r\n    function BoName(text, startPos) {\r\n        var x = startPos.x,\r\n            y = startPos.y + Const.BO_NAME_PADDING_TOP, // padding-top=10\r\n\r\n            shape = new graphic.Text({\r\n                style: {\r\n                    text: text,\r\n                    textFont: Const.BO_NAME_FONT,\r\n                    textAlign: 'left',  //\r\n                    textBaseline: 'top'\r\n                },\r\n\r\n                position: [x, y]\r\n            });\r\n\r\n        // =  + (BO - )/2\r\n        shape.position[0] += (Const.BO_NODE_WIDTH - shape.getBoundingRect().width) / 2;\r\n\r\n        //BO =  + padding-top + padding-bottom\r\n        shape.getBoundingRect().height += Const.BO_NAME_PADDING_TOP + Const.BO_NAME_PADDING_BOTTOM;\r\n\r\n        return shape;\r\n    }\r\n\r\n    module.exports = BoName;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/BoName.js\n ** module id = 41\n ** module chunks = 0\n **/","'use strict';\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var pathTool = require('zrender/lib/tool/path');\r\n    var round = Math.round;\r\n    var Path = require('zrender/lib/graphic/Path');\r\n    var colorTool = require('zrender/lib/tool/color');\r\n    var matrix = require('zrender/lib/core/matrix');\r\n    var vector = require('zrender/lib/core/vector');\r\n    var Gradient = require('zrender/lib/graphic/Gradient');\r\n    var Draggable = require('zrender/lib/mixin/Draggable');\r\n\r\n    var graphic = {};\r\n    graphic.Util = zrUtil;\r\n    graphic.Group = require('zrender/lib/container/Group');\r\n\r\n    graphic.Image = require('zrender/lib/graphic/Image');\r\n\r\n    graphic.Text = require('zrender/lib/graphic/Text');\r\n\r\n    graphic.textContain = require('zrender/lib/contain/text');\r\n\r\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\r\n\r\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\r\n\r\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\r\n\r\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\r\n\r\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\r\n\r\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\r\n\r\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\r\n\r\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\r\n\r\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\r\n\r\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\r\n\r\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\r\n\r\n    graphic.BoundingRect = require('zrender/lib/core/BoundingRect');\r\n\r\n    /**\r\n     * Extend shape with parameters\r\n     */\r\n    graphic.extendShape = function (opts) {\r\n        return Path.extend(opts);\r\n    };\r\n\r\n    /**\r\n     * Extend path\r\n     */\r\n    graphic.extendPath = function (pathData, opts) {\r\n        return pathTool.extendFromString(pathData, opts);\r\n    };\r\n\r\n    /**\r\n     * Create a path element from path data string\r\n     * @param {string} pathData\r\n     * @param {Object} opts\r\n     * @param {module:zrender/core/BoundingRect} rect\r\n     * @param {string} [layout=cover] 'center' or 'cover'\r\n     */\r\n    graphic.makePath = function (pathData, opts, rect, layout) {\r\n        var path = pathTool.createFromString(pathData, opts);\r\n        Draggable.call(path);\r\n        var boundingRect = path.getBoundingRect();\r\n        if (rect) {\r\n            var aspect = boundingRect.width / boundingRect.height;\r\n\r\n            if (layout === 'center') {\r\n                // Set rect to center, keep width / height ratio.\r\n                var width = rect.height * aspect;\r\n                var height;\r\n                if (width <= rect.width) {\r\n                    height = rect.height;\r\n                }\r\n                else {\r\n                    width = rect.width;\r\n                    height = width / aspect;\r\n                }\r\n                var cx = rect.x + rect.width / 2;\r\n                var cy = rect.y + rect.height / 2;\r\n\r\n                rect.x = cx - width / 2;\r\n                rect.y = cy - height / 2;\r\n                rect.width = width;\r\n                rect.height = height;\r\n            }\r\n\r\n            this.resizePath(path, rect);\r\n        }\r\n\r\n        zrUtil.inherits(path, Draggable);\r\n        return path;\r\n    };\r\n\r\n    graphic.mergePath = pathTool.mergePath;\r\n\r\n    /**\r\n     * Resize a path to fit the rect\r\n     * @param {module:zrender/graphic/Path} path\r\n     * @param {Object} rect\r\n     */\r\n    graphic.resizePath = function (path, rect) {\r\n        if (!path.applyTransform) {\r\n            return;\r\n        }\r\n\r\n        var pathRect = path.getBoundingRect();\r\n\r\n        var m = pathRect.calculateTransform(rect);\r\n\r\n        path.applyTransform(m);\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize line for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x1]\r\n     * @param {number} [param.shape.y1]\r\n     * @param {number} [param.shape.x2]\r\n     * @param {number} [param.shape.y2]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeLine = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n\r\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n        }\r\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n        }\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize rect for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x]\r\n     * @param {number} [param.shape.y]\r\n     * @param {number} [param.shape.width]\r\n     * @param {number} [param.shape.height]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeRect = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n        var originX = shape.x;\r\n        var originY = shape.y;\r\n        var originWidth = shape.width;\r\n        var originHeight = shape.height;\r\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n        shape.width = Math.max(\r\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n            originWidth === 0 ? 0 : 1\r\n        );\r\n        shape.height = Math.max(\r\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n            originHeight === 0 ? 0 : 1\r\n        );\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize for canvas\r\n     *\r\n     * @param {number} position Coordinate, such as x, y\r\n     * @param {number} lineWidth Should be nonnegative integer.\r\n     * @param {boolean=} positiveOrNegative Default false (negative).\r\n     * @return {number} Optimized position.\r\n     */\r\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n        // Assure that (position + lineWidth / 2) is near integer edge,\r\n        // otherwise line will be fuzzy in canvas.\r\n        var doubledPosition = round(position * 2);\r\n        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n            ? doubledPosition / 2\r\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    function doSingleEnterHover(el) {\r\n        if (el.__isHover) {\r\n            return;\r\n        }\r\n        if (el.__hoverStlDirty) {\r\n            var stroke = el.style.stroke;\r\n            var fill = el.style.fill;\r\n\r\n            // Create hoverStyle on mouseover\r\n            var hoverStyle = el.__hoverStl;\r\n            var lift = colorTool.lift;\r\n            hoverStyle.fill = hoverStyle.fill\r\n                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n            hoverStyle.stroke = hoverStyle.stroke\r\n                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\r\n            var normalStyle = {};\r\n            for (var name in hoverStyle) {\r\n                if (hoverStyle.hasOwnProperty(name)) {\r\n                    normalStyle[name] = el.style[name];\r\n                }\r\n            }\r\n\r\n            el.__normalStl = normalStyle;\r\n\r\n            el.__hoverStlDirty = false;\r\n        }\r\n        el.setStyle(el.__hoverStl);\r\n        el.z2 += 1;\r\n\r\n        el.__isHover = true;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doSingleLeaveHover(el) {\r\n        if (!el.__isHover) {\r\n            return;\r\n        }\r\n\r\n        var normalStl = el.__normalStl;\r\n        normalStl && el.setStyle(normalStl);\r\n        el.z2 -= 1;\r\n\r\n        el.__isHover = false;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doEnterHover(el) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleEnterHover(child);\r\n                }\r\n            })\r\n            : doSingleEnterHover(el);\r\n    }\r\n    graphic.doEnterHover = doEnterHover;\r\n    function doLeaveHover(el) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleLeaveHover(child);\r\n                }\r\n            })\r\n            : doSingleLeaveHover(el);\r\n    }\r\n    graphic.doLeaveHover = doLeaveHover;\r\n    /**\r\n     * @inner\r\n     */\r\n    function setElementHoverStl(el, hoverStl) {\r\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n        // Often used when item group has a label element and it's hoverStyle is different\r\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n        el.__hoverStlDirty = true;\r\n    }\r\n    graphic.setElementHoverStl = setElementHoverStl;\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOver() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOut() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function enterEmphasis() {\r\n        this.__isEmphasis = true;\r\n        doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function leaveEmphasis() {\r\n        this.__isEmphasis = false;\r\n        doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * Set hover style of element\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} [hoverStyle]\r\n     */\r\n    graphic.setHoverStyle = function (el, hoverStyle) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    setElementHoverStl(child, hoverStyle);\r\n                }\r\n            })\r\n            : setElementHoverStl(el, hoverStyle);\r\n        // Remove previous bound handlers\r\n        el.on('mouseover', onElementMouseOver)\r\n          .on('mouseout', onElementMouseOut);\r\n\r\n        // Emphasis, normal can be triggered manually\r\n        el.on('emphasis', enterEmphasis)\r\n          .on('normal', leaveEmphasis);\r\n    };\r\n\r\n    graphic.setNormalStyle = function(el, options) {\r\n        if (el.__normalStl) {\r\n            for (var name in options) {\r\n                if (el.__normalStl.hasOwnProperty(name)) {\r\n                    el.__normalStl[name] = options[name];\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Set text option in the style\r\n     * @param {Object} textStyle\r\n     * @param {module:echarts/model/Model} labelModel\r\n     * @param {string} color\r\n     */\r\n    graphic.setText = function (textStyle, labelModel, color) {\r\n        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n        var textStyleModel = labelModel.getModel('textStyle');\r\n        zrUtil.extend(textStyle, {\r\n            textDistance: labelModel.getShallow('distance') || 5,\r\n            textFont: textStyleModel.getFont(),\r\n            textPosition: labelPosition,\r\n            textFill: textStyleModel.getTextColor() || labelColor\r\n        });\r\n    };\r\n\r\n    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n        var postfix = isUpdate ? 'Update' : '';\r\n        var duration = animatableModel\r\n            && animatableModel.getShallow('animationDuration' + postfix);\r\n        var animationEasing = animatableModel\r\n            && animatableModel.getShallow('animationEasing' + postfix);\r\n\r\n        animatableModel && animatableModel.getShallow('animation')\r\n            ? el.animateTo(props, duration, animationEasing, cb)\r\n            : (el.attr(props), cb && cb());\r\n    }\r\n    /**\r\n     * Update graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\r\n    /**\r\n     * Init graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\r\n    /**\r\n     * Get transform matrix of target (param target),\r\n     * in coordinate of its ancestor (param ancestor)\r\n     *\r\n     * @param {module:zrender/mixin/Transformable} target\r\n     * @param {module:zrender/mixin/Transformable} ancestor\r\n     */\r\n    graphic.getTransform = function (target, ancestor) {\r\n        var mat = matrix.identity([]);\r\n\r\n        while (target && target !== ancestor) {\r\n            matrix.mul(mat, target.getLocalTransform(), mat);\r\n            target = target.parent;\r\n        }\r\n\r\n        return mat;\r\n    };\r\n\r\n    /**\r\n     * Apply transform to an vertex.\r\n     * @param {Array.<number>} vertex [x, y]\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {Array.<number>} [x, y]\r\n     */\r\n    graphic.applyTransform = function (vertex, transform, invert) {\r\n        if (invert) {\r\n            transform = matrix.invert([], transform);\r\n        }\r\n        return vector.applyTransform([], vertex, transform);\r\n    };\r\n\r\n    /**\r\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n     */\r\n    graphic.transformDirection = function (direction, transform, invert) {\r\n\r\n        // Pick a base, ensure that transform result will not be (0, 0).\r\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\r\n        var vertex = [\r\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n        ];\r\n\r\n        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\r\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n            ? (vertex[0] > 0 ? 'right' : 'left')\r\n            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n    };\r\n\r\n    module.exports = graphic;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/graphic.js\n ** module id = 42\n ** module chunks = 0\n **/","\n\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n    var matrix = require('../core/matrix');\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var transform;\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            path.setData(pathProxy.data);\n            transform && transformPath(path, transform);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            if (!transform) {\n                transform = matrix.create();\n            }\n            matrix.mul(transform, m, transform);\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (pathEl.__dirty) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/tool/path.js\n ** module id = 43\n ** module chunks = 0\n **/","/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect = this.getBoundingRect();\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || (\n                lineDash && !ctxLineDash && hasStroke\n            )) {\n                path = this.path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     *  Path element, \n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME  extend position, rotation \n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Path.js\n ** module id = 44\n ** module chunks = 0\n **/","'use strict';\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n\n        this._len = 0;\n\n        this._ctx = null;\n\n        this._xi = 0;\n        this._yi = 0;\n\n        this._x0 = 0;\n        this._y0 = 0;\n\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        this._ux = 0;\n        this._uy = 0;\n    };\n\n    /**\n     * Path\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            this._len = 0;\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi  _dashedXXXXTo \n            // xi, yi , x0, y0  closePath \n            //  beginPath  lineTo x0, y0 \n            //  lineTo dashed line  IE10- \n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._yi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context  rebuildPath  fill\n         * stroke \n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         *  Path \n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * \n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         *  Path \n         * \n         */\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                //  Float32Array\n                // \n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         *  Float32Array \n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo  subpath, \n                        //  closePath \n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc \n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc \n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/PathProxy.js\n ** module id = 45\n ** module chunks = 0\n **/","'use strict';\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // \n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} \n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] \n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out \n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/curve.js\n ** module id = 46\n ** module chunks = 0\n **/","/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * `min``max`\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points \n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * (p0, p1, p2, p3)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * (p0, p1, p2)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * `min``max`\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/bbox.js\n ** module id = 47\n ** module chunks = 0\n **/","'use strict';\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n\n    var windingLine = require('./windingLine');\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // \n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc \n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                //  subpath \n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE  L, C, Q  NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    //  arc \n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // \n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr scale, x\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        //  subpath \n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/path.js\n ** module id = 48\n ** module chunks = 0\n **/","\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/line.js\n ** module id = 49\n ** module chunks = 0\n **/","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/cubic.js\n ** module id = 50\n ** module chunks = 0\n **/","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/quadratic.js\n ** module id = 51\n ** module chunks = 0\n **/","\n\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/arc.js\n ** module id = 52\n ** module chunks = 0\n **/","\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/util.js\n ** module id = 53\n ** module chunks = 0\n **/","\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/windingLine.js\n ** module id = 54\n ** module chunks = 0\n **/","\n\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i++] += x;\n                    // cy\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/tool/transformPath.js\n ** module id = 55\n ** module chunks = 0\n **/","\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Gradient.js\n ** module id = 56\n ** module chunks = 0\n **/","/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                // FIXME in text contain default is top\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    // Fill after stroke so the outline will not cover the main part.\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (!this._rect) {\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                if (style.hasStroke()) {\n                    var w = style.lineWidth;\n                    rect.x -= w / 2;\n                    rect.y -= w / 2;\n                    rect.width += w;\n                    rect.height += w;\n                }\n                this._rect = rect;\n            }\n\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Text.js\n ** module id = 57\n ** module chunks = 0\n **/","'use strict';\n/**\n * \n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Circle.js\n ** module id = 58\n ** module chunks = 0\n **/","/**\n * \n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    var env = require('../../core/env');\n    var Path = require('../Path');\n\n    var shadowTemp = [\n        ['shadowBlur', 0],\n        ['shadowColor', '#000'],\n        ['shadowOffsetX', 0],\n        ['shadowOffsetY', 0]\n    ];\n\n    module.exports = Path.extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\n            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\n            // where exception \"unexpected call to method or property access\"\n            // might be thrown when calling ctx.fill after a path whose area size\n            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\n            // (e.g.,\n            //  ctx.moveTo(10, 10);\n            //  ctx.lineTo(20, 10);\n            //  ctx.closePath();\n            //  ctx.clip();\n            //  ctx.shadowBlur = 10;\n            //  ...\n            //  ctx.fill();\n            // )\n            ? function () {\n                var clipPaths = this.__clipPaths;\n                var style = this.style;\n                var modified;\n\n                if (clipPaths) {\n                    for (var i = 0; i < clipPaths.length; i++) {\n                        var shape = clipPaths[i] && clipPaths[i].shape;\n                        if (shape && shape.startAngle === shape.endAngle) {\n                            for (var j = 0; j < shadowTemp.length; j++) {\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n                            }\n                            modified = true;\n                            break;\n                        }\n                    }\n                }\n\n                Path.prototype.brush.apply(this, arguments);\n\n                if (modified) {\n                    for (var j = 0; j < shadowTemp.length; j++) {\n                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n                    }\n                }\n            }\n            : Path.prototype.brush,\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Sector.js\n ** module id = 59\n ** module chunks = 0\n **/","/**\n * \n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Ring.js\n ** module id = 60\n ** module chunks = 0\n **/","/**\n * \n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Polygon.js\n ** module id = 61\n ** module chunks = 0\n **/","\n\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/poly.js\n ** module id = 62\n ** module chunks = 0\n **/","/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = require('../../core/vector');\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points \n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/smoothSpline.js\n ** module id = 63\n ** module chunks = 0\n **/","/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * \n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points \n     * @param {number} smooth , 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint \n     *                            [[0, 0], [100, 100]], \n     *                           \n     * @param {Array} \n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // \n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/smoothBezier.js\n ** module id = 64\n ** module chunks = 0\n **/","/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Polyline.js\n ** module id = 65\n ** module chunks = 0\n **/","/**\n * \n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = require('../helper/roundRect');\n\n    module.exports = require('../Path').extend({\n\n        type: 'rect',\n\n        shape: {\n            // r1r2r3r4\n            // r1          [1, 1, 1, 1]\n            // r[1]        [1, 1, 1, 1]\n            // r[1, 2]     [1, 2, 1, 2]\n            // r[1, 2, 3]  [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Rect.js\n ** module id = 66\n ** module chunks = 0\n **/","\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/roundRect.js\n ** module id = 67\n ** module chunks = 0\n **/","/**\n * \n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = require('../Path').extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Line.js\n ** module id = 68\n ** module chunks = 0\n **/","'use strict';\n/**\n * \n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = require('../Path').extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/BezierCurve.js\n ** module id = 69\n ** module chunks = 0\n **/","/**\n * \n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = require('../Path').extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Arc.js\n ** module id = 70\n ** module chunks = 0\n **/","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/LinearGradient.js\n ** module id = 71\n ** module chunks = 0\n **/","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/RadialGradient.js\n ** module id = 72\n ** module chunks = 0\n **/","/**\r\n * \r\n * @module fish-topo-bo/node/EventDecisionNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n    function EventDecisionNode(data, opts) {\r\n        /**\r\n         * BO\r\n         * @type {Object}\r\n         * @private\r\n         */\r\n        this._data = data;\r\n\r\n        /**\r\n         * \r\n         * @type {startPos}\r\n         * @private\r\n         */\r\n        this._startPos = opts.startPos;\r\n\r\n        this._type = opts.type || 'boEvent';\r\n\r\n        /**\r\n         * \r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._clickable = opts.clickable || false;\r\n        this._popupOpts = opts.popupOpts;\r\n\r\n        /**\r\n         * Group\r\n         * @type zrender/graphic/Group\r\n         * @private\r\n         */\r\n        this._group = new graphic.Group();\r\n        this._group.name = this._data.id;\r\n\r\n        //BO\r\n        this._render();\r\n    }\r\n\r\n    var eventProto = EventDecisionNode.prototype;\r\n\r\n    /**\r\n     * \r\n     * @returns {zrender/graphic/Group}\r\n     */\r\n    eventProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    eventProto._render = function () {\r\n        //\r\n        this._createEventShape();\r\n        //\r\n        this._createEVentName();\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    eventProto._createEventShape = function () {\r\n\r\n        //\r\n        var height = Const.BO_EVENT_HEIGHT,\r\n            x = this._startPos.x + 1,\r\n            y = this._startPos.y,\r\n            width = this._type == 'boEvent' ? Const.BO_EVENT_WIDTH : Const.BO_ATTR_EVENT_WIDTH,\r\n\r\n            shape = new graphic.Polygon({\r\n                name: this._data.id,\r\n                shape: {\r\n                    points: [\r\n                        [x, y],\r\n                        [x + width - 10, y],\r\n                        [x + width, y + height / 2],\r\n                        [x + width - 10, y + height],\r\n                        [x, y + height]]\r\n                },\r\n\r\n                style: {\r\n                    fill: '#FFCCCC',\r\n                    stroke: '#000000',\r\n                    lineWidth: 0.75\r\n                }\r\n\r\n            });\r\n\r\n        if (this._clickable) {\r\n            shape.clickable = this._clickable;\r\n            shape._data = this._data;\r\n            shape._popupOpts = this._popupOpts;\r\n            shape.onclick = this._click;\r\n        }\r\n\r\n\r\n        this._group.add(shape);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    eventProto._click = function () {\r\n        var options = fish.extend(\r\n            {\r\n                viewOption: {\r\n                    DATA: this._data\r\n                },\r\n                width: 800,\r\n                height: 500\r\n            }, this._popupOpts);\r\n\r\n        fish.popupView(options);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    eventProto._createEVentName = function () {\r\n        var x = this._startPos.x + (this._type == 'boEvent' ? Const.BO_ATTR_PADDING_LEFT : 15),\r\n            y = this._startPos.y,\r\n\r\n            eventNameShape = new graphic.Text({\r\n                style: {\r\n                    text: this._data.name,\r\n                    textFont: Const.BO_EVENT_FONT,\r\n                    textAlign: 'left',  //\r\n                    textBaseline: 'top'\r\n                },\r\n\r\n                position: [x, y]\r\n            });\r\n\r\n        if (this._clickable) {\r\n            eventNameShape.clickable = this._clickable;\r\n            eventNameShape._data = this._data;\r\n            eventNameShape._popupOpts = this._popupOpts;\r\n            eventNameShape.onclick = this._click;\r\n        }\r\n\r\n        this._group.add(eventNameShape);\r\n    };\r\n\r\n    module.exports = EventDecisionNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/EventDecisionNode.js\n ** module id = 73\n ** module chunks = 0\n **/","/**\r\n * BO\r\n * @module fish-topo-bo/node/LineNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var util = require('zrender/lib/core/util');\r\n    /**\r\n     * BO\r\n     * @param {{x: *, y: *}} startPos, \r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @constructor\r\n     */\r\n    function BoLine(startPos) {\r\n\r\n        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y};\r\n\r\n        return _line(startPos, endPos);\r\n    }\r\n\r\n    /**\r\n     * BO\r\n     * @param {{x: *, y: *}} startPos, \r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @constructor\r\n     */\r\n    function AttrLine(startPos) {\r\n\r\n        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y},\r\n            style = {lineDash: [Const.LINE_DASH]};\r\n\r\n        return _line(startPos, endPos, style);\r\n    }\r\n\r\n    /**\r\n     * BOBO\r\n     * @param {{x: *, y: *}} startPos, \r\n     * @param {int} attrHeight, \r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @constructor\r\n     */\r\n    function AttrEventLine(startPos, attrHeight) {\r\n        var endPos = {x: startPos.x, y: startPos.y + attrHeight},\r\n            style = {lineDash: [Const.LINE_DASH]};\r\n\r\n        return _line(startPos, endPos, style);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {{x: *, y: *}} startPos, \r\n     * @param {{x: *, y: *}} endPos, \r\n     * @param {Object} style, ,\r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @private\r\n     */\r\n    function _line(startPos, endPos, style) {\r\n\r\n        var _style = {\r\n            strokeColor: '#000000',\r\n            lineWidth: 0.5,\r\n            percent: 1\r\n        };\r\n\r\n        util.extend(_style, style);\r\n\r\n        var shape = new graphic.Line({\r\n            shape: {\r\n                // Start point\r\n                x1: startPos.x,\r\n                y1: startPos.y,\r\n\r\n                // End point\r\n                x2: endPos.x,\r\n                y2: endPos.y,\r\n\r\n                percent: 1\r\n            },\r\n\r\n            style: _style\r\n        });\r\n\r\n        return shape;\r\n    }\r\n\r\n\r\n    module.exports = {\r\n        BoLine: BoLine,\r\n        AttrLine: AttrLine,\r\n        AttrEventLine: AttrEventLine\r\n    };\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/LineNode.js\n ** module id = 74\n ** module chunks = 0\n **/","/**\r\n * BO\r\n * 1.BO\r\n * 2.BO\r\n * 3.BO\r\n * @module fish-topo-bo/node/BoAttrNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var EventDecision = require('../node/EventDecisionNode');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n    /**\r\n     *\r\n     * @param {{\r\n     *          id: String bo,\r\n     *          code: String bo\r\n     *          keyValue: boolean ,\r\n     *          dataType: String ,\r\n     *          boAttrEventArr:[] \r\n     *          }} boAttrData BO,\r\n     * @param {{\r\n     *          startPos: {x: number, y: number},\r\n     *          displayDataType: boolean ,\r\n     *          displayEventDecision: boolean ,\r\n     *          eventClickable: boolean BO,  false,\r\n     *          eventPopupOpts: Object BOurl,width,height,\r\n     *          }} opts\r\n     * @constructor\r\n     */\r\n    function BoAttr(boAttrData, opts) {\r\n        /**\r\n         * BO\r\n         * @type {Object}\r\n         * @private\r\n         */\r\n        this._data = boAttrData;\r\n\r\n        /**\r\n         * \r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._keyValue = boAttrData.keyValue || false;\r\n\r\n        /**\r\n         * \r\n         * @type {startPos}\r\n         * @private\r\n         */\r\n        this._startPos = opts.startPos;\r\n\r\n        /**\r\n         * \r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayDataType = opts.displayDataType || false;\r\n\r\n        /**\r\n         * \r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayEventDecision = opts.displayEventDecision || false;\r\n\r\n        /**\r\n         * \r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._eventClickable = opts.eventClickable || false;\r\n        this._eventPopupOpts = opts.eventPopupOpts;\r\n\r\n        /**\r\n         * Group\r\n         * @type zrender/graphic/Group\r\n         * @private\r\n         */\r\n        this._group = new graphic.Group();\r\n        this._group.name = this._data.id;\r\n\r\n        //BO\r\n        this._render();\r\n    }\r\n\r\n    var boAttrProto = BoAttr.prototype;\r\n\r\n    /**\r\n     * \r\n     * @returns {zrender/graphic/Group}\r\n     */\r\n    boAttrProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n\r\n    /**\r\n     * BO\r\n     * @private\r\n     */\r\n    boAttrProto._render = function () {\r\n        //\r\n        this._createText();\r\n\r\n        //\r\n        this._createDataType();\r\n\r\n        //\r\n        this._createEventDecision();\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    boAttrProto._createText = function () {\r\n\r\n        var x = this._startPos.x + Const.BO_ATTR_PADDING_LEFT,\r\n            y = this._startPos.y,\r\n\r\n            attrNameShape = new graphic.Text({\r\n                style: {\r\n                    text: this._data.name,\r\n                    textFont: Const.BO_ATTR_FONT,\r\n                    textAlign: 'left',  //\r\n                    textBaseline: 'top',\r\n                    //lineWidth: 1,\r\n                    fill: this._keyValue ? 'red' : 'black'\r\n                },\r\n\r\n                position: [x, y]\r\n            });\r\n\r\n        // =  + padding-top + padding-bottom\r\n        attrNameShape.getBoundingRect().height += Const.BO_ATTR_PADDING_TOP + Const.BO_ATTR_PADDING_BOTTOM;\r\n        // = BORelation\r\n        attrNameShape.getBoundingRect().width = Const.BO_NODE_WIDTH;\r\n\r\n        //B = \r\n        attrNameShape.getBoundingRect().x += -Const.BO_ATTR_PADDING_LEFT;\r\n        //attrNameShape.getBoundingRect().y = + attrNameShape.position[1];\r\n\r\n        this._group.add(attrNameShape);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    boAttrProto._createDataType = function () {\r\n        if (!this._displayDataType) {\r\n            return;\r\n        }\r\n\r\n        var x = this._startPos.x + Const.BO_NODE_WIDTH - 10,\r\n            y = this._startPos.y,\r\n            textAlign = 'right';\r\n\r\n        //\r\n        if (this._displayEventDecision) {\r\n            textAlign = 'left';\r\n            x = this._startPos.x + Const.BO_NODE_WIDTH / 3;\r\n        }\r\n\r\n        var _dataTypeShape = new graphic.Text({\r\n            style: {\r\n                text: this._data.dataType || '',\r\n                textFont: Const.BO_ATTR_FONT,\r\n                textAlign: textAlign,  //\r\n                textBaseline: 'top',\r\n                lineWidth: 1\r\n            },\r\n\r\n            position: [x, y]\r\n        });\r\n\r\n        this._group.add(_dataTypeShape);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    boAttrProto._createEventDecision = function () {\r\n        if (!this._displayEventDecision) {\r\n            return;\r\n        }\r\n\r\n        var _boAttrEventArr = this._data.boAttrEventArr || [],\r\n            _boAttrEventLen = _boAttrEventArr.length,\r\n            padding = (_boAttrEventLen > 1) ? 10 : 0,\r\n            _startPos = {\r\n                x: this._startPos.x + Const.BO_NODE_WIDTH / 2 + Const.BO_ATTR_EVENT_WIDTH * (_boAttrEventLen - 1) - padding,\r\n                y: this._startPos.y\r\n            };\r\n\r\n        //\r\n        for (var i = _boAttrEventLen - 1; i >= 0; i--) {\r\n            this._group.add(new EventDecision(_boAttrEventArr[i], {\r\n                startPos: _startPos,\r\n                type: 'boAttrEvent',\r\n                clickable: this._eventClickable,\r\n                popupOpts: this._eventPopupOpts\r\n            }).getShape());\r\n            _startPos = {x: _startPos.x - Const.BO_ATTR_EVENT_WIDTH + 10, y: _startPos.y};\r\n        }\r\n        /*_startPos = {\r\n         x: this._startPos.x + Const.BO_NODE_WIDTH / 2,\r\n         y: this._startPos.y};\r\n\r\n         for (var i = 0; i < _boAttrEventLen; i++) {\r\n         this._group.add(event.BoAttrEvent(_boAttrEventArr[i], _startPos, i + 2));\r\n         _startPos = {x: _startPos.x + Const.BO_ATTR_EVENT_WIDTH - 5, y: _startPos.y};\r\n         }*/\r\n\r\n\r\n    };\r\n\r\n    module.exports = BoAttr;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/BoAttrNode.js\n ** module id = 75\n ** module chunks = 0\n **/","/**\r\n * \r\n * \r\n * @module fish-topo-bo/node/Relation\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n    /**\r\n     *\r\n     * @param sourceShape, \r\n     * @param targetShape, \r\n     * @param {String} sourceText, ,\r\n     * @param {String} targetText, ,\r\n     * @constructor\r\n     */\r\n    function Relation(sourceShape, targetShape, sourceText, targetText) {\r\n        this._sourceText = sourceText;\r\n        this._targetText = targetText;\r\n\r\n        this._group = new graphic.Group();\r\n\r\n        //\r\n        this._lStartPos = {\r\n            x: sourceShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //\r\n        this._lEndPos = {\r\n            x: targetShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //\r\n        this._rStartPos = {\r\n            x: sourceShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //\r\n        this._rEndPos = {\r\n            x: targetShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //\r\n        this._leftDirection = this._lStartPos.x - this._lEndPos.x <= 0;\r\n\r\n        //\r\n        this._render();\r\n    }\r\n\r\n    var relationProto = Relation.prototype;\r\n\r\n    /**\r\n     * \r\n     * @returns {*}\r\n     */\r\n    relationProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    relationProto._render = function () {\r\n        //\r\n        this._createLine();\r\n\r\n        //\r\n        this._createArrow();\r\n\r\n        //\r\n        this._createText();\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    relationProto._createLine = function () {\r\n        var _linePoints = [];\r\n\r\n        if (this._leftDirection) {\r\n            //\r\n            _linePoints.push([this._lStartPos.x, this._lStartPos.y]);\r\n            //\r\n            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lStartPos.y]);\r\n            //\r\n            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lEndPos.y]);\r\n            //\r\n            _linePoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n        }\r\n        else {\r\n            //\r\n            _linePoints.push([this._rStartPos.x, this._rStartPos.y]);\r\n            //\r\n            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._lStartPos.y]);\r\n            //\r\n            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._rEndPos.y]);\r\n            //\r\n            _linePoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n        }\r\n\r\n        var _lineShape = new graphic.Polyline({\r\n            shape: {\r\n                points: _linePoints\r\n            },\r\n\r\n            style: {\r\n                //fill: 'blue',\r\n                stroke: 'blue'\r\n            }\r\n        });\r\n\r\n        this._group.add(_lineShape);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    relationProto._createArrow = function () {\r\n        var _arrowPoints = [];\r\n\r\n        if (this._leftDirection) {\r\n            //\r\n            _arrowPoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n            //\r\n            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n            //\r\n            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n        }\r\n        else {\r\n            //\r\n            _arrowPoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n            //\r\n            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n            //\r\n            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n        }\r\n\r\n        var _arrowShape = new graphic.Polyline({\r\n            shape: {\r\n                points: _arrowPoints\r\n            },\r\n\r\n            style: {\r\n                fill: 'blue',\r\n                stroke: 'blue'\r\n            }\r\n        });\r\n\r\n        this._group.add(_arrowShape);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     */\r\n    relationProto._createText = function () {\r\n        var _sourceTextPos,\r\n            _targetTextPos,\r\n            _textAlign;\r\n\r\n        if (this._leftDirection) {\r\n            _sourceTextPos = [this._lStartPos.x - 10, this._lStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _targetTextPos = [this._lEndPos.x - 10 - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _textAlign = 'right';\r\n        }\r\n        else {\r\n            _sourceTextPos = [this._rStartPos.x + 10, this._rStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _targetTextPos = [this._rEndPos.x + 10 + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _textAlign = 'left';\r\n        }\r\n\r\n        //\r\n        if (this._sourceText) {\r\n            var _srcTextShape = new graphic.Text({\r\n                position: _sourceTextPos,\r\n\r\n                style: {\r\n                    text: this._sourceText,\r\n                    textFont: Const.BO_ATTR_FONT,\r\n                    textAlign: _textAlign,\r\n                    textBaseline: 'buttom',\r\n                    lineWidth: 1\r\n                }\r\n            });\r\n            this._group.add(_srcTextShape);\r\n        }\r\n\r\n        //\r\n        if (this._targetText) {\r\n            var _targetTextShape = new graphic.Text({\r\n                position: _targetTextPos,\r\n\r\n                style: {\r\n                    text: this._targetText,\r\n                    textFont: Const.BO_ATTR_FONT,\r\n                    textAlign: _textAlign,\r\n                    textBaseline: 'buttom',\r\n                    lineWidth: 1\r\n                }\r\n            });\r\n            this._group.add(_targetTextShape);\r\n        }\r\n\r\n    };\r\n\r\n    module.exports = Relation;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/Relation.js\n ** module id = 76\n ** module chunks = 0\n **/","\n    require('./graphic');\n    require('../zrender').registerPainter('vml', require('./Painter'));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/vml/vml.js\n ** module id = 77\n ** module chunks = 0\n **/","// http://www.w3.org/TR/NOTE-VML\n// TODO Use proxy like svg instead of overwrite brush methods\n\n\nif (!require('../core/env').canvasSupported) {\n    var vec2 = require('../core/vector');\n    var BoundingRect = require('../core/BoundingRect');\n    var CMD = require('../core/PathProxy').CMD;\n    var colorTool = require('../tool/color');\n    var textContain = require('../contain/text');\n    var RectText = require('../graphic/mixin/RectText');\n    var Displayable = require('../graphic/Displayable');\n    var ZImage = require('../graphic/Image');\n    var Text = require('../graphic/Text');\n    var Path = require('../graphic/Path');\n\n    var Gradient = require('../graphic/Gradient');\n\n    var vmlCore = require('./core');\n\n    var round = Math.round;\n    var sqrt = Math.sqrt;\n    var abs = Math.abs;\n    var cos = Math.cos;\n    var sin = Math.sin;\n    var mathMax = Math.max;\n\n    var applyTransform = vec2.applyTransform;\n\n    var comma = ',';\n    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\n    var Z = 21600;\n    var Z2 = Z / 2;\n\n    var ZLEVEL_BASE = 100000;\n    var Z_BASE = 1000;\n\n    var initRootElStyle = function (el) {\n        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n        el.coordsize = Z + ','  + Z;\n        el.coordorigin = '0,0';\n    };\n\n    var encodeHtmlAttribute = function (s) {\n        return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n    };\n\n    var rgb2Str = function (r, g, b) {\n        return 'rgb(' + [r, g, b].join(',') + ')';\n    };\n\n    var append = function (parent, child) {\n        if (child && parent && child.parentNode !== parent) {\n            parent.appendChild(child);\n        }\n    };\n\n    var remove = function (parent, child) {\n        if (child && parent && child.parentNode === parent) {\n            parent.removeChild(child);\n        }\n    };\n\n    var getZIndex = function (zlevel, z, z2) {\n        // z  [0, 1000]\n        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n    };\n\n    var parsePercent = function (value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    };\n\n    /***************************************************\n     * PATH\n     **************************************************/\n\n    var setColorAndOpacity = function (el, color, opacity) {\n        var colorArr = colorTool.parse(color);\n        opacity = +opacity;\n        if (isNaN(opacity)) {\n            opacity = 1;\n        }\n        if (colorArr) {\n            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n            el.opacity = opacity * colorArr[3];\n        }\n    };\n\n    var getColorAndAlpha = function (color) {\n        var colorArr = colorTool.parse(color);\n        return [\n            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),\n            colorArr[3]\n        ];\n    };\n\n    var updateFillNode = function (el, style, zrEl) {\n        // TODO pattern\n        var fill = style.fill;\n        if (fill != null) {\n            // Modified from excanvas\n            if (fill instanceof Gradient) {\n                var gradientType;\n                var angle = 0;\n                var focus = [0, 0];\n                // additional offset\n                var shift = 0;\n                // scale factor for offset\n                var expansion = 1;\n                var rect = zrEl.getBoundingRect();\n                var rectWidth = rect.width;\n                var rectHeight = rect.height;\n                if (fill.type === 'linear') {\n                    gradientType = 'gradient';\n                    var transform = zrEl.transform;\n                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n                    if (transform) {\n                        applyTransform(p0, p0, transform);\n                        applyTransform(p1, p1, transform);\n                    }\n                    var dx = p1[0] - p0[0];\n                    var dy = p1[1] - p0[1];\n                    angle = Math.atan2(dx, dy) * 180 / Math.PI;\n                    // The angle should be a non-negative number.\n                    if (angle < 0) {\n                        angle += 360;\n                    }\n\n                    // Very small angles produce an unexpected result because they are\n                    // converted to a scientific notation string.\n                    if (angle < 1e-6) {\n                        angle = 0;\n                    }\n                }\n                else {\n                    gradientType = 'gradientradial';\n                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n                    var transform = zrEl.transform;\n                    var scale = zrEl.scale;\n                    var width = rectWidth;\n                    var height = rectHeight;\n                    focus = [\n                        // Percent in bounding rect\n                        (p0[0] - rect.x) / width,\n                        (p0[1] - rect.y) / height\n                    ];\n                    if (transform) {\n                        applyTransform(p0, p0, transform);\n                    }\n\n                    width /= scale[0] * Z;\n                    height /= scale[1] * Z;\n                    var dimension = mathMax(width, height);\n                    shift = 2 * 0 / dimension;\n                    expansion = 2 * fill.r / dimension - shift;\n                }\n\n                // We need to sort the color stops in ascending order by offset,\n                // otherwise IE won't interpret it correctly.\n                var stops = fill.colorStops.slice();\n                stops.sort(function(cs1, cs2) {\n                    return cs1.offset - cs2.offset;\n                });\n\n                var length = stops.length;\n                // Color and alpha list of first and last stop\n                var colorAndAlphaList = [];\n                var colors = [];\n                for (var i = 0; i < length; i++) {\n                    var stop = stops[i];\n                    var colorAndAlpha = getColorAndAlpha(stop.color);\n                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n                    if (i === 0 || i === length - 1) {\n                        colorAndAlphaList.push(colorAndAlpha);\n                    }\n                }\n\n                if (length >= 2) {\n                    var color1 = colorAndAlphaList[0][0];\n                    var color2 = colorAndAlphaList[1][0];\n                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\n                    el.type = gradientType;\n                    el.method = 'none';\n                    el.focus = '100%';\n                    el.angle = angle;\n                    el.color = color1;\n                    el.color2 = color2;\n                    el.colors = colors.join(',');\n                    // When colors attribute is used, the meanings of opacity and o:opacity2\n                    // are reversed.\n                    el.opacity = opacity2;\n                    // FIXME g_o_:opacity ?\n                    el.opacity2 = opacity1;\n                }\n                if (gradientType === 'radial') {\n                    el.focusposition = focus.join(',');\n                }\n            }\n            else {\n                // FIXME Change from Gradient fill to color fill\n                setColorAndOpacity(el, fill, style.opacity);\n            }\n        }\n    };\n\n    var updateStrokeNode = function (el, style) {\n        // if (style.lineJoin != null) {\n        //     el.joinstyle = style.lineJoin;\n        // }\n        // if (style.miterLimit != null) {\n        //     el.miterlimit = style.miterLimit * Z;\n        // }\n        // if (style.lineCap != null) {\n        //     el.endcap = style.lineCap;\n        // }\n        if (style.lineDash != null) {\n            el.dashstyle = style.lineDash.join(' ');\n        }\n        if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n            setColorAndOpacity(el, style.stroke, style.opacity);\n        }\n    };\n\n    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n        var isFill = type == 'fill';\n        var el = vmlEl.getElementsByTagName(type)[0];\n        // Stroke must have lineWidth\n        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {\n            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';\n            // FIXME Remove before updating, or set `colors` will throw error\n            if (style[type] instanceof Gradient) {\n                remove(vmlEl, el);\n            }\n            if (!el) {\n                el = vmlCore.createNode(type);\n            }\n\n            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n            append(vmlEl, el);\n        }\n        else {\n            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n            remove(vmlEl, el);\n        }\n    };\n\n    var points = [[], [], []];\n    var pathDataToString = function (data, m) {\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        var str = [];\n        var nPoint;\n        var cmdStr;\n        var cmd;\n        var i;\n        var xi;\n        var yi;\n        for (i = 0; i < data.length;) {\n            cmd = data[i++];\n            cmdStr = '';\n            nPoint = 0;\n            switch (cmd) {\n                case M:\n                    cmdStr = ' m ';\n                    nPoint = 1;\n                    xi = data[i++];\n                    yi = data[i++];\n                    points[0][0] = xi;\n                    points[0][1] = yi;\n                    break;\n                case L:\n                    cmdStr = ' l ';\n                    nPoint = 1;\n                    xi = data[i++];\n                    yi = data[i++];\n                    points[0][0] = xi;\n                    points[0][1] = yi;\n                    break;\n                case Q:\n                case C:\n                    cmdStr = ' c ';\n                    nPoint = 3;\n                    var x1 = data[i++];\n                    var y1 = data[i++];\n                    var x2 = data[i++];\n                    var y2 = data[i++];\n                    var x3;\n                    var y3;\n                    if (cmd === Q) {\n                        // Convert quadratic to cubic using degree elevation\n                        x3 = x2;\n                        y3 = y2;\n                        x2 = (x2 + 2 * x1) / 3;\n                        y2 = (y2 + 2 * y1) / 3;\n                        x1 = (xi + 2 * x1) / 3;\n                        y1 = (yi + 2 * y1) / 3;\n                    }\n                    else {\n                        x3 = data[i++];\n                        y3 = data[i++];\n                    }\n                    points[0][0] = x1;\n                    points[0][1] = y1;\n                    points[1][0] = x2;\n                    points[1][1] = y2;\n                    points[2][0] = x3;\n                    points[2][1] = y3;\n\n                    xi = x3;\n                    yi = y3;\n                    break;\n                case A:\n                    var x = 0;\n                    var y = 0;\n                    var sx = 1;\n                    var sy = 1;\n                    var angle = 0;\n                    if (m) {\n                        // Extract SRT from matrix\n                        x = m[4];\n                        y = m[5];\n                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n                        angle = Math.atan2(-m[1] / sy, m[0] / sx);\n                    }\n\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var startAngle = data[i++] + angle;\n                    var endAngle = data[i++] + startAngle + angle;\n                    // FIXME\n                    // var psi = data[i++];\n                    i++;\n                    var clockwise = data[i++];\n\n                    var x0 = cx + cos(startAngle) * rx;\n                    var y0 = cy + sin(startAngle) * ry;\n\n                    var x1 = cx + cos(endAngle) * rx;\n                    var y1 = cy + sin(endAngle) * ry;\n\n                    var type = clockwise ? ' wa ' : ' at ';\n                    if (Math.abs(x0 - x1) < 1e-4) {\n                        // IE won't render arches drawn counter clockwise if x0 == x1.\n                        if (Math.abs(endAngle - startAngle) > 1e-2) {\n                            // Offset x0 by 1/80 of a pixel. Use something\n                            // that can be represented in binary\n                            if (clockwise) {\n                                x0 += 270 / Z;\n                            }\n                        }\n                        else {\n                            // Avoid case draw full circle\n                            if (Math.abs(y0 - cy) < 1e-4) {\n                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {\n                                    y1 -= 270 / Z;\n                                }\n                                else {\n                                    y1 += 270 / Z;\n                                }\n                            }\n                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {\n                                x1 += 270 / Z;\n                            }\n                            else {\n                                x1 -= 270 / Z;\n                            }\n                        }\n                    }\n                    str.push(\n                        type,\n                        round(((cx - rx) * sx + x) * Z - Z2), comma,\n                        round(((cy - ry) * sy + y) * Z - Z2), comma,\n                        round(((cx + rx) * sx + x) * Z - Z2), comma,\n                        round(((cy + ry) * sy + y) * Z - Z2), comma,\n                        round((x0 * sx + x) * Z - Z2), comma,\n                        round((y0 * sy + y) * Z - Z2), comma,\n                        round((x1 * sx + x) * Z - Z2), comma,\n                        round((y1 * sy + y) * Z - Z2)\n                    );\n\n                    xi = x1;\n                    yi = y1;\n                    break;\n                case CMD.R:\n                    var p0 = points[0];\n                    var p1 = points[1];\n                    // x0, y0\n                    p0[0] = data[i++];\n                    p0[1] = data[i++];\n                    // x1, y1\n                    p1[0] = p0[0] + data[i++];\n                    p1[1] = p0[1] + data[i++];\n\n                    if (m) {\n                        applyTransform(p0, p0, m);\n                        applyTransform(p1, p1, m);\n                    }\n\n                    p0[0] = round(p0[0] * Z - Z2);\n                    p1[0] = round(p1[0] * Z - Z2);\n                    p0[1] = round(p0[1] * Z - Z2);\n                    p1[1] = round(p1[1] * Z - Z2);\n                    str.push(\n                        // x0, y0\n                        ' m ', p0[0], comma, p0[1],\n                        // x1, y0\n                        ' l ', p1[0], comma, p0[1],\n                        // x1, y1\n                        ' l ', p1[0], comma, p1[1],\n                        // x0, y1\n                        ' l ', p0[0], comma, p1[1]\n                    );\n                    break;\n                case CMD.Z:\n                    // FIXME Update xi, yi\n                    str.push(' x ');\n            }\n\n            if (nPoint > 0) {\n                str.push(cmdStr);\n                for (var k = 0; k < nPoint; k++) {\n                    var p = points[k];\n\n                    m && applyTransform(p, p, m);\n                    //  round \n                    str.push(\n                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),\n                        k < nPoint - 1 ? comma : ''\n                    );\n                }\n            }\n        }\n\n        return str.join('');\n    };\n\n    // Rewrite the original path method\n    Path.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n\n        var vmlEl = this._vmlEl;\n        if (!vmlEl) {\n            vmlEl = vmlCore.createNode('shape');\n            initRootElStyle(vmlEl);\n\n            this._vmlEl = vmlEl;\n        }\n\n        updateFillAndStroke(vmlEl, 'fill', style, this);\n        updateFillAndStroke(vmlEl, 'stroke', style, this);\n\n        var m = this.transform;\n        var needTransform = m != null;\n        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n        if (strokeEl) {\n            var lineWidth = style.lineWidth;\n            // Get the line scale.\n            // Determinant of this.m_ means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            if (needTransform && !style.strokeNoScale) {\n                var det = m[0] * m[3] - m[1] * m[2];\n                lineWidth *= sqrt(abs(det));\n            }\n            strokeEl.weight = lineWidth + 'px';\n        }\n\n        var path = this.path;\n        if (this.__dirtyPath) {\n            path.beginPath();\n            this.buildPath(path, this.shape);\n            path.toStatic();\n            this.__dirtyPath = false;\n        }\n\n        vmlEl.path = pathDataToString(path.data, this.transform);\n\n        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Append to root\n        append(vmlRoot, vmlEl);\n\n        // Text\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, this.getBoundingRect());\n        }\n        else {\n            this.removeRectText(vmlRoot);\n        }\n    };\n\n    Path.prototype.onRemove = function (vmlRoot) {\n        remove(vmlRoot, this._vmlEl);\n        this.removeRectText(vmlRoot);\n    };\n\n    Path.prototype.onAdd = function (vmlRoot) {\n        append(vmlRoot, this._vmlEl);\n        this.appendRectText(vmlRoot);\n    };\n\n    /***************************************************\n     * IMAGE\n     **************************************************/\n    var isImage = function (img) {\n        // FIXME img instanceof Image  img IE8 \n        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';\n        // return img instanceof Image;\n    };\n\n    // Rewrite the original path method\n    ZImage.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n        var image = style.image;\n\n        // Image original width, height\n        var ow;\n        var oh;\n\n        if (isImage(image)) {\n            var src = image.src;\n            if (src === this._imageSrc) {\n                ow = this._imageWidth;\n                oh = this._imageHeight;\n            }\n            else {\n                var imageRuntimeStyle = image.runtimeStyle;\n                var oldRuntimeWidth = imageRuntimeStyle.width;\n                var oldRuntimeHeight = imageRuntimeStyle.height;\n                imageRuntimeStyle.width = 'auto';\n                imageRuntimeStyle.height = 'auto';\n\n                // get the original size\n                ow = image.width;\n                oh = image.height;\n\n                // and remove overides\n                imageRuntimeStyle.width = oldRuntimeWidth;\n                imageRuntimeStyle.height = oldRuntimeHeight;\n\n                // Caching image original width, height and src\n                this._imageSrc = src;\n                this._imageWidth = ow;\n                this._imageHeight = oh;\n            }\n            image = src;\n        }\n        else {\n            if (image === this._imageSrc) {\n                ow = this._imageWidth;\n                oh = this._imageHeight;\n            }\n        }\n        if (!image) {\n            return;\n        }\n\n        var x = style.x || 0;\n        var y = style.y || 0;\n\n        var dw = style.width;\n        var dh = style.height;\n\n        var sw = style.sWidth;\n        var sh = style.sHeight;\n        var sx = style.sx || 0;\n        var sy = style.sy || 0;\n\n        var hasCrop = sw && sh;\n\n        var vmlEl = this._vmlEl;\n        if (!vmlEl) {\n            // FIXME  group  left, top  0 \n            // vmlEl = vmlCore.createNode('group');\n            vmlEl = vmlCore.doc.createElement('div');\n            initRootElStyle(vmlEl);\n\n            this._vmlEl = vmlEl;\n        }\n\n        var vmlElStyle = vmlEl.style;\n        var hasRotation = false;\n        var m;\n        var scaleX = 1;\n        var scaleY = 1;\n        if (this.transform) {\n            m = this.transform;\n            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\n            hasRotation = m[1] || m[2];\n        }\n        if (hasRotation) {\n            // If filters are necessary (rotation exists), create them\n            // filters are bog-slow, so only create them if abbsolutely necessary\n            // The following check doesn't account for skews (which don't exist\n            // in the canvas spec (yet) anyway.\n            // From excanvas\n            var p0 = [x, y];\n            var p1 = [x + dw, y];\n            var p2 = [x, y + dh];\n            var p3 = [x + dw, y + dh];\n            applyTransform(p0, p0, m);\n            applyTransform(p1, p1, m);\n            applyTransform(p2, p2, m);\n            applyTransform(p3, p3, m);\n\n            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\n            var transformFilter = [];\n            transformFilter.push('M11=', m[0] / scaleX, comma,\n                        'M12=', m[2] / scaleY, comma,\n                        'M21=', m[1] / scaleX, comma,\n                        'M22=', m[3] / scaleY, comma,\n                        'Dx=', round(x * scaleX + m[4]), comma,\n                        'Dy=', round(y * scaleY + m[5]));\n\n            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';\n            // FIXME DXImageTransform  IE11 \n            vmlElStyle.filter = imageTransformPrefix + '.Matrix('\n                + transformFilter.join('') + ', SizingMethod=clip)';\n\n        }\n        else {\n            if (m) {\n                x = x * scaleX + m[4];\n                y = y * scaleY + m[5];\n            }\n            vmlElStyle.filter = '';\n            vmlElStyle.left = round(x) + 'px';\n            vmlElStyle.top = round(y) + 'px';\n        }\n\n        var imageEl = this._imageEl;\n        var cropEl = this._cropEl;\n\n        if (!imageEl) {\n            imageEl = vmlCore.doc.createElement('div');\n            this._imageEl = imageEl;\n        }\n        var imageELStyle = imageEl.style;\n        if (hasCrop) {\n            // Needs know image original width and height\n            if (! (ow && oh)) {\n                var tmpImage = new Image();\n                var self = this;\n                tmpImage.onload = function () {\n                    tmpImage.onload = null;\n                    ow = tmpImage.width;\n                    oh = tmpImage.height;\n                    // Adjust image width and height to fit the ratio destinationSize / sourceSize\n                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\n                    // Caching image original width, height and src\n                    self._imageWidth = ow;\n                    self._imageHeight = oh;\n                    self._imageSrc = image;\n                };\n                tmpImage.src = image;\n            }\n            else {\n                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n            }\n\n            if (! cropEl) {\n                cropEl = vmlCore.doc.createElement('div');\n                cropEl.style.overflow = 'hidden';\n                this._cropEl = cropEl;\n            }\n            var cropElStyle = cropEl.style;\n            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='\n                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';\n\n            if (! cropEl.parentNode) {\n                vmlEl.appendChild(cropEl);\n            }\n            if (imageEl.parentNode != cropEl) {\n                cropEl.appendChild(imageEl);\n            }\n        }\n        else {\n            imageELStyle.width = round(scaleX * dw) + 'px';\n            imageELStyle.height = round(scaleY * dh) + 'px';\n\n            vmlEl.appendChild(imageEl);\n\n            if (cropEl && cropEl.parentNode) {\n                vmlEl.removeChild(cropEl);\n                this._cropEl = null;\n            }\n        }\n\n        var filterStr = '';\n        var alpha = style.opacity;\n        if (alpha < 1) {\n            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n        }\n        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\n        imageELStyle.filter = filterStr;\n\n        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Append to root\n        append(vmlRoot, vmlEl);\n\n        // Text\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, this.getBoundingRect());\n        }\n    };\n\n    ZImage.prototype.onRemove = function (vmlRoot) {\n        remove(vmlRoot, this._vmlEl);\n\n        this._vmlEl = null;\n        this._cropEl = null;\n        this._imageEl = null;\n\n        this.removeRectText(vmlRoot);\n    };\n\n    ZImage.prototype.onAdd = function (vmlRoot) {\n        append(vmlRoot, this._vmlEl);\n        this.appendRectText(vmlRoot);\n    };\n\n\n    /***************************************************\n     * TEXT\n     **************************************************/\n\n    var DEFAULT_STYLE_NORMAL = 'normal';\n\n    var fontStyleCache = {};\n    var fontStyleCacheCount = 0;\n    var MAX_FONT_CACHE_SIZE = 100;\n    var fontEl = document.createElement('div');\n\n    var getFontStyle = function (fontString) {\n        var fontStyle = fontStyleCache[fontString];\n        if (!fontStyle) {\n            // Clear cache\n            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n                fontStyleCacheCount = 0;\n                fontStyleCache = {};\n            }\n\n            var style = fontEl.style;\n            var fontFamily;\n            try {\n                style.font = fontString;\n                fontFamily = style.fontFamily.split(',')[0];\n            }\n            catch (e) {\n            }\n\n            fontStyle = {\n                style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n                size: parseFloat(style.fontSize || 12) | 0,\n                family: fontFamily || 'Microsoft YaHei'\n            };\n\n            fontStyleCache[fontString] = fontStyle;\n            fontStyleCacheCount++;\n        }\n        return fontStyle;\n    };\n\n    var textMeasureEl;\n    // Overwrite measure text method\n    textContain.measureText = function (text, textFont) {\n        var doc = vmlCore.doc;\n        if (!textMeasureEl) {\n            textMeasureEl = doc.createElement('div');\n            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'\n                + 'padding:0;margin:0;border:none;white-space:pre;';\n            vmlCore.doc.body.appendChild(textMeasureEl);\n        }\n\n        try {\n            textMeasureEl.style.font = textFont;\n        } catch (ex) {\n            // Ignore failures to set to invalid font.\n        }\n        textMeasureEl.innerHTML = '';\n        // Don't use innerHTML or innerText because they allow markup/whitespace.\n        textMeasureEl.appendChild(doc.createTextNode(text));\n        return {\n            width: textMeasureEl.offsetWidth\n        };\n    };\n\n    var tmpRect = new BoundingRect();\n\n    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\n        var style = this.style;\n        var text = style.text;\n        // Convert to string\n        text != null && (text += '');\n        if (!text) {\n            return;\n        }\n\n        var x;\n        var y;\n        var align = style.textAlign;\n        var fontStyle = getFontStyle(style.textFont);\n        // FIXME encodeHtmlAttribute ?\n        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '\n            + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\n        var baseline = style.textBaseline;\n        var verticalAlign = style.textVerticalAlign;\n\n        textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n        // Transform rect to view space\n        var m = this.transform;\n        // Ignore transform for text in other element\n        if (m && !fromTextEl) {\n            tmpRect.copy(rect);\n            tmpRect.applyTransform(m);\n            rect = tmpRect;\n        }\n\n        if (!fromTextEl) {\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n\n                align = align || 'left';\n                baseline = baseline || 'top';\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n        }\n        else {\n            x = rect.x;\n            y = rect.y;\n        }\n        if (verticalAlign) {\n            switch (verticalAlign) {\n                case 'middle':\n                    y -= textRect.height / 2;\n                    break;\n                case 'bottom':\n                    y -= textRect.height;\n                    break;\n                // 'top'\n            }\n            // Ignore baseline\n            baseline = 'top';\n        }\n\n        var fontSize = fontStyle.size;\n        // 1.75 is an arbitrary number, as there is no info about the text baseline\n        switch (baseline) {\n            case 'hanging':\n            case 'top':\n                y += fontSize / 1.75;\n                break;\n            case 'middle':\n                break;\n            default:\n            // case null:\n            // case 'alphabetic':\n            // case 'ideographic':\n            // case 'bottom':\n                y -= fontSize / 2.25;\n                break;\n        }\n        switch (align) {\n            case 'left':\n                break;\n            case 'center':\n                x -= textRect.width / 2;\n                break;\n            case 'right':\n                x -= textRect.width;\n                break;\n            // case 'end':\n                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n                // break;\n            // case 'start':\n                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n                // break;\n            // default:\n            //     align = 'left';\n        }\n\n        var createNode = vmlCore.createNode;\n\n        var textVmlEl = this._textVmlEl;\n        var pathEl;\n        var textPathEl;\n        var skewEl;\n        if (!textVmlEl) {\n            textVmlEl = createNode('line');\n            pathEl = createNode('path');\n            textPathEl = createNode('textpath');\n            skewEl = createNode('skew');\n\n            // FIXME Why here is not cammel case\n            // Align 'center' seems wrong\n            textPathEl.style['v-text-align'] = 'left';\n\n            initRootElStyle(textVmlEl);\n\n            pathEl.textpathok = true;\n            textPathEl.on = true;\n\n            textVmlEl.from = '0 0';\n            textVmlEl.to = '1000 0.05';\n\n            append(textVmlEl, skewEl);\n            append(textVmlEl, pathEl);\n            append(textVmlEl, textPathEl);\n\n            this._textVmlEl = textVmlEl;\n        }\n        else {\n            //  appendChild \n            skewEl = textVmlEl.firstChild;\n            pathEl = skewEl.nextSibling;\n            textPathEl = pathEl.nextSibling;\n        }\n\n        var coords = [x, y];\n        var textVmlElStyle = textVmlEl.style;\n        // Ignore transform for text in other element\n        if (m && fromTextEl) {\n            applyTransform(coords, coords, m);\n\n            skewEl.on = true;\n\n            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +\n            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';\n\n            // Text position\n            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);\n            // Left top point as origin\n            skewEl.origin = '0 0';\n\n            textVmlElStyle.left = '0px';\n            textVmlElStyle.top = '0px';\n        }\n        else {\n            skewEl.on = false;\n            textVmlElStyle.left = round(x) + 'px';\n            textVmlElStyle.top = round(y) + 'px';\n        }\n\n        textPathEl.string = encodeHtmlAttribute(text);\n        // TODO\n        try {\n            textPathEl.style.font = font;\n        }\n        // Error font format\n        catch (e) {}\n\n        updateFillAndStroke(textVmlEl, 'fill', {\n            fill: fromTextEl ? style.fill : style.textFill,\n            opacity: style.opacity\n        }, this);\n        updateFillAndStroke(textVmlEl, 'stroke', {\n            stroke: fromTextEl ? style.stroke : style.textStroke,\n            opacity: style.opacity,\n            lineDash: style.lineDash\n        }, this);\n\n        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Attached to root\n        append(vmlRoot, textVmlEl);\n    };\n\n    var removeRectText = function (vmlRoot) {\n        remove(vmlRoot, this._textVmlEl);\n        this._textVmlEl = null;\n    };\n\n    var appendRectText = function (vmlRoot) {\n        append(vmlRoot, this._textVmlEl);\n    };\n\n    var list = [RectText, Displayable, ZImage, Path, Text];\n\n    // In case Displayable has been mixed in RectText\n    for (var i = 0; i < list.length; i++) {\n        var proto = list[i].prototype;\n        proto.drawRectText = drawRectText;\n        proto.removeRectText = removeRectText;\n        proto.appendRectText = appendRectText;\n    }\n\n    Text.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, {\n                x: style.x || 0, y: style.y || 0,\n                width: 0, height: 0\n            }, this.getBoundingRect(), true);\n        }\n        else {\n            this.removeRectText(vmlRoot);\n        }\n    };\n\n    Text.prototype.onRemove = function (vmlRoot) {\n        this.removeRectText(vmlRoot);\n    };\n\n    Text.prototype.onAdd = function (vmlRoot) {\n        this.appendRectText(vmlRoot);\n    };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/vml/graphic.js\n ** module id = 78\n ** module chunks = 0\n **/","\n\nif (!require('../core/env').canvasSupported) {\n    var urn = 'urn:schemas-microsoft-com:vml';\n\n    var createNode;\n    var win = window;\n    var doc = win.document;\n\n    var vmlInited = false;\n\n    try {\n        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n        createNode = function (tagName) {\n            return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n        };\n    }\n    catch (e) {\n        createNode = function (tagName) {\n            return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n        };\n    }\n\n    // From raphael\n    var initVML = function () {\n        if (vmlInited) {\n            return;\n        }\n        vmlInited = true;\n\n        var styleSheets = doc.styleSheets;\n        if (styleSheets.length < 31) {\n            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n        }\n        else {\n            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n        }\n    };\n\n    // Not useing return to avoid error when converting to CommonJS module\n    module.exports = {\n        doc: doc,\n        initVML: initVML,\n        createNode: createNode\n    };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/vml/core.js\n ** module id = 79\n ** module chunks = 0\n **/","/**\n * VML Painter.\n *\n * @module zrender/vml/Painter\n */\n\n\n\n    var zrLog = require('../core/log');\n    var vmlCore = require('./core');\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    /**\n     * @alias module:zrender/vml/Painter\n     */\n    function VMLPainter(root, storage) {\n\n        vmlCore.initVML();\n\n        this.root = root;\n\n        this.storage = storage;\n\n        var vmlViewport = document.createElement('div');\n\n        var vmlRoot = document.createElement('div');\n\n        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\n        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\n        root.appendChild(vmlViewport);\n\n        this._vmlRoot = vmlRoot;\n        this._vmlViewport = vmlViewport;\n\n        this.resize();\n\n        // Modify storage\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            if (el) {\n                el.onRemove && el.onRemove(vmlRoot);\n            }\n        };\n\n        storage.addToMap = function (el) {\n            // Displayable already has a vml node\n            el.onAdd && el.onAdd(vmlRoot);\n\n            oldAddToMap.call(storage, el);\n        };\n\n        this._firstPaint = true;\n    }\n\n    VMLPainter.prototype = {\n\n        constructor: VMLPainter,\n\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._vmlViewport;\n        },\n\n        /**\n         * \n         */\n        refresh: function () {\n\n            var list = this.storage.getDisplayList(true, true);\n\n            this._paintList(list);\n        },\n\n        _paintList: function (list) {\n            var vmlRoot = this._vmlRoot;\n            for (var i = 0; i < list.length; i++) {\n                var el = list[i];\n                if (el.invisible || el.ignore) {\n                    if (!el.__alreadyNotVisible) {\n                        el.onRemove(vmlRoot);\n                    }\n                    // Set as already invisible\n                    el.__alreadyNotVisible = true;\n                }\n                else {\n                    if (el.__alreadyNotVisible) {\n                        el.onAdd(vmlRoot);\n                    }\n                    el.__alreadyNotVisible = false;\n                    if (el.__dirty) {\n                        el.beforeBrush && el.beforeBrush();\n                        (el.brushVML || el.brush).call(el, vmlRoot);\n                        el.afterBrush && el.afterBrush();\n                    }\n                }\n                el.__dirty = false;\n            }\n\n            if (this._firstPaint) {\n                // Detached from document at first time\n                // to avoid page refreshing too many times\n\n                // FIXME  removeChild \n                this._vmlViewport.appendChild(vmlRoot);\n                this._firstPaint = false;\n            }\n        },\n\n        resize: function (width, height) {\n            var width = width == null ? this._getWidth() : width;\n            var height = height == null ? this._getHeight() : height;\n\n            if (this._width != width || this._height != height) {\n                this._width = width;\n                this._height = height;\n\n                var vmlViewportStyle = this._vmlViewport.style;\n                vmlViewportStyle.width = width + 'px';\n                vmlViewportStyle.height = height + 'px';\n            }\n        },\n\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this._vmlRoot =\n            this._vmlViewport =\n            this.storage = null;\n        },\n\n        getWidth: function () {\n            return this._width;\n        },\n\n        getHeight: function () {\n            return this._height;\n        },\n\n        clear: function () {\n            if (this._vmlViewport) {\n                this.root.removeChild(this._vmlViewport);\n            }\n        },\n\n        _getWidth: function () {\n            var root = this.root;\n            var stl = root.currentStyle;\n\n            return ((root.clientWidth || parseInt10(stl.width))\n                    - parseInt10(stl.paddingLeft)\n                    - parseInt10(stl.paddingRight)) | 0;\n        },\n\n        _getHeight: function () {\n            var root = this.root;\n            var stl = root.currentStyle;\n\n            return ((root.clientHeight || parseInt10(stl.height))\n                    - parseInt10(stl.paddingTop)\n                    - parseInt10(stl.paddingBottom)) | 0;\n        }\n    };\n\n    // Not supported methods\n    function createMethodNotSupport(method) {\n        return function () {\n            zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n        };\n    }\n\n    var notSupportedMethods = [\n        'getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers',\n        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'\n    ];\n\n    for (var i = 0; i < notSupportedMethods.length; i++) {\n        var name = notSupportedMethods[i];\n        VMLPainter.prototype[name] = createMethodNotSupport(name);\n    }\n\n    module.exports = VMLPainter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/vml/Painter.js\n ** module id = 80\n ** module chunks = 0\n **/"],"sourceRoot":"/source/"}